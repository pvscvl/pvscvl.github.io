<?label 5.2. Handling Input with CGI.pm?><html><head><title>Handling Input with CGI.pm (CGI Programming with Perl)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="Scott Guelich, Gunther Birznieks and Shishir Gundavaram" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="1565924193L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="CGI Programming with Perl" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="CGI Programming with Perl" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch05_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm">CGI Programming with Perl</a></td><td width="172" valign="top" align="right"><a href="ch05_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<h2 class="sect1">5.2. Handling Input with CGI.pm</h2>


<p>
<a name="INDEX-973" /> <a name="INDEX-974" /> <a name="INDEX-975" />CGI.pm primarily handles
two separate tasks: it reads and parses input from the user, and it
provides a convenient way to return HTML output. Let's first
look at how it collects input.</p>


<a name="ch05-2-fm2xml" /><div class="sect2">
<h3 class="sect2">5.2.1. Environment Information</h3>


<p>CGI.pm provides many
<a name="INDEX-976" /> <a name="INDEX-977" />methods to get information about your
environment. Of course, when you use CGI.pm, all of your standard CGI
environment variables are still available in Perl's
<tt class="literal">%ENV</tt> hash, but CGI.pm also makes most of these
available via method calls. It also provides some unique methods.
<a href="ch05_02.htm">Table 5-1</a> shows how CGI.pm's functions
correspond to the standard CGI environment variables.</p>



<a name="ch05-65059" /><h4 class="objtitle">Table 5-1. CGI.pm Environment Methods and CGI Environment Variables </h4><table border="1">



<tr>
<th>
<p>CGI.pm Method</p></th>
<th>
<p>CGI Environment Variable</p></th>
</tr>




<tr>
<td>
<p><tt class="function">auth_type</tt></p></td>
<td>
<p>AUTH_TYPE</p></td>
</tr>

<tr>
<td>
<p>Not available</p></td>
<td>
<p>CONTENT_LENGTH</p></td>
</tr>

<tr>
<td>
<p><tt class="function">content_type</tt></p></td>
<td>
<p>CONTENT_TYPE</p></td>
</tr>

<tr>
<td>
<p>Not available</p></td>
<td>
<p>DOCUMENT_ROOT</p></td>
</tr>

<tr>
<td>
<p>Not available</p></td>
<td>
<p>GATEWAY_INTERFACE</p></td>
</tr>

<tr>
<td>
<p><tt class="function">path_info</tt></p></td>
<td>
<p>PATH_INFO</p></td>
</tr>

<tr>
<td>
<p><tt class="function">path_translated</tt></p></td>
<td>
<p>PATH_TRANSLATED</p></td>
</tr>

<tr>
<td>
<p><tt class="function">query_string</tt></p></td>
<td>
<p>QUERY_STRING</p></td>
</tr>

<tr>
<td>
<p><tt class="function">remote_addr</tt></p></td>
<td>
<p>REMOTE_ADDR</p></td>
</tr>

<tr>
<td>
<p><tt class="function">remote_host</tt></p></td>
<td>
<p>REMOTE_HOST</p></td>
</tr>

<tr>
<td>
<p><tt class="function">remote_ident</tt></p></td>
<td>
<p>REMOTE_IDENT</p></td>
</tr>

<tr>
<td>
<p><tt class="function">remote_user</tt></p></td>
<td>
<p>REMOTE_USER</p></td>
</tr>

<tr>
<td>
<p><tt class="function">request_method</tt></p></td>
<td>
<p>REQUEST_METHOD</p></td>
</tr>

<tr>
<td>
<p><tt class="function">script_name</tt></p></td>
<td>
<p>SCRIPT_NAME</p></td>
</tr>

<tr>
<td>
<p><tt class="function">self_url</tt></p></td>
<td>
<p>Not available</p></td>
</tr>

<tr>
<td>
<p><tt class="function">server_name</tt></p></td>
<td>
<p>SERVER_NAME</p></td>
</tr>

<tr>
<td>
<p><tt class="function">server_port</tt></p></td>
<td>
<p>SERVER_PORT</p></td>
</tr>

<tr>
<td>
<p><tt class="function">server_protocol</tt></p></td>
<td>
<p>SERVER_PROTOCOL</p></td>
</tr>

<tr>
<td>
<p><tt class="function">server_software</tt></p></td>
<td>
<p>SERVER_SOFTWARE</p></td>
</tr>

<tr>
<td>
<p><tt class="function">url</tt></p></td>
<td>
<p>Not available</p></td>
</tr>

<tr>
<td>
<p><tt class="function">Accept</tt></p></td>
<td>
<p>HTTP_ACCEPT</p></td>
</tr>

<tr>
<td>
<p><tt class="function">http("Accept-charset")</tt></p></td>
<td>
<p>HTTP_ACCEPT_CHARSET</p></td>
</tr>

<tr>
<td>
<p><tt class="function">http("Accept-encoding")</tt></p></td>
<td>
<p>HTTP_ACCEPT_ENCODING</p></td>
</tr>

<tr>
<td>
<p><tt class="function">http("Accept-language")</tt></p></td>
<td>
<p>HTTP_ACCEPT_LANGUAGE</p></td>
</tr>

<tr>
<td>
<p><tt class="function">raw_cookie</tt></p></td>
<td>
<p>HTTP_COOKIE</p></td>
</tr>

<tr>
<td>
<p><tt class="function">http("From")</tt></p></td>
<td>
<p>HTTP_FROM</p></td>
</tr>

<tr>
<td>
<p><tt class="function">virtual_host</tt></p></td>
<td>
<p>HTTP_HOST</p></td>
</tr>

<tr>
<td>
<p><tt class="function">referer</tt></p></td>
<td>
<p>HTTP_REFERER</p></td>
</tr>

<tr>
<td>
<p><tt class="function">user_agent</tt></p></td>
<td>
<p>HTTP_USER_AGENT</p></td>
</tr>

<tr>
<td>
<p><tt class="function">https</tt></p></td>
<td>
<p>HTTPS</p></td>
</tr>

<tr>
<td>
<p><tt class="function">https("Cipher")</tt></p></td>
<td>
<p>HTTPS_CIPHER</p></td>
</tr>

<tr>
<td>
<p><tt class="function">https("Keysize")</tt></p></td>
<td>
<p>HTTPS_KEYSIZE</p></td>
</tr>

<tr>
<td>
<p><tt class="function">https("SecretKeySize")</tt></p></td>
<td>
<p>HTTPS_SECRETKEYSIZE</p></td>
</tr>


</table>


<p>Most of these CGI.pm methods take no arguments and return that same
value as the corresponding environment variable. For example, to get
the additional path information passed to your CGI script, you can
use the following method:</p>


<blockquote><pre class="code">my $path = $q-&gt;path_info;</pre></blockquote>


<p>This is the same information that you could also get this way:</p>


<blockquote><pre class="code">my $path = $ENV{PATH_INFO};</pre></blockquote>


<p>However, a few methods differ or have features worth noting.
Let's take a look at these.</p>


<a name="ch05-3-fm2xml" /><div class="sect3">
<h3 class="sect3">5.2.1.1. Accept</h3>


<p>As a <a name="INDEX-978" />general rule, if a CGI.pm method has
the same name as a built-in Perl function or keyword (e.g.,
<tt class="function">accept</tt> or <tt class="function">tr</tt>), then the
CGI.pm method is
<a name="INDEX-979" />capitalized. Although there would be no
collision if CGI.pm were available only via an object-oriented
syntax, the collision creates problem for people who use it via the
standard syntax. <tt class="function">accept</tt> was originally
lowercase, but it was renamed to <tt class="function">Accept</tt> in
version 2.44 of CGI.pm, and the new name affects both syntaxes.</p>


<p>Unlike the other methods that take no arguments and simply return a
value, <tt class="function">Accept</tt> can also be given a
<a name="INDEX-980" />content type and it will
evaluate to true or false depending on whether that content type is
acceptable according to the
<em class="emphasis">HTTP-Accept</em>
<a name="INDEX-981" /> header:</p>


<blockquote><pre class="code">if ( $q-&gt;Accept( "image/png" ) ) {
    .
    .
    .</pre></blockquote>


<p>Keep in mind that most browsers today send
<tt class="literal">*/*</tt>
<a name="INDEX-982" /> in their <em class="emphasis">Accept</em>
header. This matches anything, so using the
<tt class="function">Accept</tt> method in this manner is not especially
useful. For new file formats like <tt class="literal">image/png</tt>, it is
best to get the values for the HTTP header and perform the check
yourself, ignoring wildcard matches (this is unfortunate, since it
defeats the purpose of wildcards):</p>


<blockquote><pre class="code">my @accept = $q-&gt;Accept;
if ( grep $_ eq "image/png", @accept ) {
    .
    .
    .</pre></blockquote>
</div>



<a name="ch05-4-fm2xml" /><div class="sect3">
<h3 class="sect3">5.2.1.2. http</h3>


<p>If the <tt class="function">http</tt>
<a name="INDEX-983" /> <a name="INDEX-984" /> method is called without arguments, it
returns the name of the environment variables available that contain
an HTTP_ prefix. If you call <tt class="function">http</tt> with an
argument, then it will return the value of the corresponding HTTP_
environment variable. When passing an argument to
<tt class="function">http</tt>, the HTTP_ prefix is optional,
capitalization does not matter, and hyphens and underscores are
interpreted the same. In other words, you can pass the actual HTTP
header field name or the environment variable name or even some
hybrid of the two, and <tt class="function">http</tt> will generally
figure it out. Here is how you can display all the HTTP_ environment
variables your CGI script receives:</p>


<blockquote><pre class="code">#!/usr/bin/perl -wT

use strict;
use CGI;

my $q = new CGI;
print $q-&gt;header( "text/plain" );

print "These are the HTTP environment variables I received:\n\n";

foreach ( $q-&gt;http ) {
    print "$_:\n";
    print "  ", $q-&gt;http( $_ ), "\n";
}</pre></blockquote>
</div>



<a name="ch05-5-fm2xml" /><div class="sect3">
<h3 class="sect3">5.2.1.3. https</h3>


<p>The
<tt class="function">https</tt>
<a name="INDEX-985" /> method functions
similarly to the <tt class="function">http</tt> method when it is passed a
parameter. It returns the corresponding
<a name="INDEX-986" />HTTPS_ environment
variable. These variables are set by your web server only if you are
receiving a secure request via SSL. When <tt class="function">https</tt>
is called without arguments, it returns the value of the HTTPS
environment variable, which indicates whether the connection is
secure (its values are server-dependent).</p>
</div>



<a name="ch05-6-fm2xml" /><div class="sect3">
<h3 class="sect3">5.2.1.4. query_string</h3>


<p>The <tt class="function">query_string</tt>
<a name="INDEX-987" /> method does not do what you might
think since it does not correspond one-to-one with
<tt class="literal">$ENV{QUERY_STRING}</tt>.
<tt class="literal">$ENV{QUERY_STRING}</tt> holds the query portion of the
URL that called your CGI script. <tt class="function">query_string</tt>,
on the other hand, is dynamic, so if you modify any of the query
parameters in your script (see <a href="ch05_02.htm">Section 5.2.2.1, "Modifying parameters"</a>
later in this chapter), then the value returned by
<tt class="function">query_string</tt> will include these new values. If
you want to know what the original query string was, then you should
refer to <tt class="literal">$ENV{QUERY_STRING}</tt> instead.</p>


<p>Also, if the request method is<a name="INDEX-988" /> POST, then
<tt class="function">query_string</tt> returns the POST parameters that
were submitted in the content of the request, and ignores any
parameters passed to the CGI script via the query string. This means
that if you create a form that submits its values via POST to a URL
that also contains a query string, you will not be able to access the
parameters on the query string via CGI.pm unless you make a slight
modification to CGI.pm to tell it to include parameters from the
original query string with POST requests. We'll see how to do
this in <a href="ch05_02.htm">Section 5.2.2.2, "POST and the query string"</a> later in this chapter.</p>
</div>



<a name="ch05-7-fm2xml" /><div class="sect3">
<a name="INDEX-989" /><h3 class="sect3">5.2.1.5. 
self_url</h3>


<p>This method does not correspond to a standard CGI
<a name="INDEX-990" />environment variable, although you could
manually construct it from other environment variables. It provides
you with a <a name="INDEX-991" />URL that can call your CGI with the same
parameters. The path information is maintained and the query string
is set to the value of the <tt class="function">query_string</tt> method.</p>


<p>Note that this URL is not necessarily the same URL that was used to
call your CGI script. Your CGI script may have been called because of
an internal redirection by the web server. Also, because all of the
parameters are moved to the query string, this new URL is built to be
used with a GET request, even if the current request was a POST
request.</p>
</div>



<a name="ch05-8-fm2xml" /><div class="sect3">
<h3 class="sect3">5.2.1.6. url</h3>


<p>The <tt class="function">url </tt>
<a name="INDEX-992" />method functions similarly to the
<tt class="function">self_url</tt> method, except that it returns a URL to
the current CGI script without any parameters, i.e., no path
information and an empty query string.</p>
</div>



<a name="ch05-9-fm2xml" /><div class="sect3">
<h3 class="sect3">5.2.1.7. virtual_host</h3>


<p>The <tt class="function">virtual_host</tt>
<a name="INDEX-993" /> <a name="INDEX-994" />
<a name="INDEX-995" /> method is handy because it returns the
value of the HTTP_HOST environment variable, if set, and SERVER_NAME
otherwise. Remember that HTTP_HOST is the name of the web server as
the browser referred to it, which may differ if multiple domains
share the same IP address. HTTP_HOST is available only if the browser
supplied the Host HTTP header, added for HTTP 1.1.</p>
</div>
</div>




<a name="ch05-10-fm2xml" /><div class="sect2">
<h3 class="sect2">5.2.2. Accessing Parameters</h3>


<p><tt class="function">param</tt>
<a name="INDEX-996" /> is probably the most useful method
CGI.pm provides. It allows you to access the parameters submitted to
your <a name="INDEX-997" />CGI
script, whether these parameters come to you via a GET request or a
POST request. If you call <tt class="function">param</tt> without
arguments, it will return a list of all of the parameter names your
script received. If you provide a single argument to it, it will
return the value for the parameter with that name. If no parameter
with that name was submitted to your script, it returns
<tt class="literal">undef</tt>.</p>


<p>It is possible for your CGI script to receive multiple values for a
parameter with the same name. This happens when you create two form
elements with the same name or you have a select box that allows
multiple selections. In this case, <tt class="function">param</tt> returns
a list of all of the values if it is called in a list context and
just the first value if it is called in a scalar context. This may
sound a little complicated, but in practice it works such that you
should end up with what you expect. If you ask
<tt class="function">param</tt> for one value, you will get one value
(even if other values were also submitted), and if you ask it for a
list, you will always get a list (even if the list contains only one
element).</p>


<p><a href="ch05_02.htm">Example 5-1</a> is a simple example that displays all
the parameters your script receives.</p>



<a name="ch05-79926" /><div class="example">
<h4 class="objtitle">Example 5-1. param_list.cgi </h4>

<blockquote><pre class="code">#!/usr/bin/perl -wT

use strict;
use CGI;

my $q = new CGI;
print $q-&gt;header( "text/plain" );

print "These are the parameters I received:\n\n";

my( $name, $value );

foreach $name ( $q-&gt;param ) {
    print "$name:\n";
    foreach $value ( $q-&gt;param( $name ) ) {
        print "  $value\n";
    }
}</pre></blockquote>
</div>


<p>If you call this CGI script with multiple parameters, like this:</p>


<blockquote><pre class="code">http://localhost/cgi/param_list.cgi?color=red&amp;color=blue&amp;shade=dark</pre></blockquote>


<p>you will get the following output:</p>


<blockquote><pre class="code">These are the parameters I received:

color:
  red
  blue
shade:
  dark</pre></blockquote>


<a name="ch05-43788" /><div class="sect3">
<h3 class="sect3">5.2.2.1. Modifying parameters</h3>


<p>CGI.pm also lets you add, modify, or delete the value of
<a name="INDEX-998" /> <a name="INDEX-999" />parameters within your script. To add or
modify a parameter, just pass <tt class="function">param</tt> more than
one argument. Using Perl's <tt class="literal">=&gt;</tt> operator
instead of a comma makes the code easier to read and allows you to
omit the quotes around the parameter name, so long as it's a
word (i.e., only contains includes letters, numbers, and underscores)
that does not conflict with a built-in function or keyword:</p>


<blockquote><pre class="code">$q-&gt;param( title =&gt; "Web Developer" );</pre></blockquote>


<p>You can create a parameter with multiple values by passing additional
arguments:</p>


<blockquote><pre class="code">$q-&gt;param( hobbies =&gt; "Biking", "Windsurfing", "Music" );</pre></blockquote>


<p>To <a name="INDEX-1000" />delete a parameter, use the
<tt class="function">delete</tt> method and provide the name of the
parameter:</p>


<blockquote><pre class="code">$q-&gt;delete( "age" );</pre></blockquote>


<p>You can clear all of the parameters with
<tt class="function">delete_all</tt>
<a name="INDEX-1001" />:</p>


<blockquote><pre class="code">$q-&gt;delete_all;</pre></blockquote>


<p>It may seem odd that you would ever want to modify parameters
yourself, since these will typically be coming from the user. Setting
parameters is useful for many reasons, but especially when assigning
default values to fields in forms. We will see how to do this later
in this chapter.</p>
</div>



<a name="ch05-40519" /><div class="sect3">
<h3 class="sect3">5.2.2.2. POST and the query string</h3>


<p><tt class="function">param</tt> automatically determines if the request
method is <a name="INDEX-1002" /> <a name="INDEX-1,003" />
<a name="INDEX-1004" />POST or GET. If it is POST, it reads any
parameters submitted to it from STDIN. If it is GET, it reads them
from the query string. It is possible to POST information to a URL
that already has a query string. In this case, you have two souces of
input data, and because CGI.pm determines what to do by checking the
request method, it will ignore the data in the query string.</p>


<p>You can change this behavior if you are willing to edit CGI.pm. In
fact, CGI.pm includes comments to help you do this. You can find this
block of code in the
<tt class="function">init</tt>
<a name="INDEX-1005" /> subroutine (the line number will
vary depending on the version of CGI.pm you have):</p>


<blockquote><pre class="code">if ($meth eq 'POST') {
    $self-&gt;read_from_client(\*STDIN,\$query_string,$content_length,0)
        if $content_length &gt; 0;
    # Some people want to have their cake and eat it too!
    # Uncomment this line to have the contents of the query string
    # APPENDED to the POST data.
    # $query_string .= (length($query_string) ? '&amp;' : '') . $ENV{'QUERY_STRING'}
             if defined $ENV{'QUERY_STRING'};
    last METHOD;
}</pre></blockquote>


<p>By removing the pound sign from the beginning of the line indicated,
you will be able to use POST and query string data together. Note
that the line you would need to uncomment is too long to display on
one line in this text, so it has been wrapped to the next line, but
it is just one line in CGI.pm.</p>
</div>



<a name="ch05-11-fm2xml" /><div class="sect3">
<h3 class="sect3">5.2.2.3. Index queries</h3>


<p>You may receive a query string that contains words that do not
comprise name-value pairs. The <a name="INDEX-1006" /> <a name="INDEX-1,007" /> <a name="INDEX-1,008" />&lt;ISINDEX&gt; HTML tag, which is not
used much anymore, creates a single text field along with a prompt to
enter search keywords. When a user enters words into this field and
presses Enter, it makes a new request for the same URL, adding the
text the user entered as the query string with keywords separated by
a <a name="INDEX-1009" /> <a name="INDEX-1,010" />plus sign (<tt class="literal">+</tt>), such
as this:</p>


<blockquote><pre class="code">http://www.localhost.com/cgi/lookup.cgi?cgi+perl</pre></blockquote>


<p>You can retrieve the list of keywords that the user entered by
calling <tt class="function">param</tt>
<a name="INDEX-1011" /> with "keywords" as the
name of the parameter or by calling the separate keywords method:</p>


<blockquote><pre class="code">my @words = $q-&gt;keywords;            # these lines do the same thing
my @words = $q-&gt;param( "keywords" );</pre></blockquote>


<p>These methods return index keywords only if CGI.pm finds no
name-value pair parameters, so you don't have to worry about
using "keywords" as the name of an element in your HTML
forms; it will work correctly. On the other hand, if you want to
<a name="INDEX-1012" />POST form data to a URL
with a keyword, CGI.pm cannot return that keyword to you. You must
use <tt class="literal">$ENV{QUERY_STRING}</tt>
<a name="INDEX-1013" /> to get it.</p>
</div>



<a name="ch05-12-fm2xml" /><div class="sect3">
<h3 class="sect3">5.2.2.4. Supporting image buttons as submit buttons</h3>


<p>Whether <a name="INDEX-1014" /> <a name="INDEX-1,015" />you use &lt;INPUT TYPE="IMAGE" &gt; or
&lt;INPUT TYPE="SUBMIT"&gt;, the form is still sent to the CGI
script. However, with the image button, the name is not transmitted
by itself. Instead, the web browser splits an image button name into
two separate variables:
<em class="emphasis">name.x</em>
<a name="INDEX-1016" />
and <em class="emphasis">name.y</em>.</p>


<p>If you want your program to support image and regular submit buttons
interchangeably, it is useful to translate the image button names to
normal submit button names. Thus, the main program code can use logic
based upon which submit button was clicked even if image buttons
later replace them.</p>


<p>To accomplish this, we can use the following code that will set a
form variable without the coordinates in the name for each variable
that ends in ".x":</p>


<blockquote><pre class="code">foreach ( $q-&gt;param ) {
    $q-&gt;param( $1, 1 ) if /(.*)\.x/;
}</pre></blockquote>
</div>
</div>




<a name="ch05-13-fm2xml" /><div class="sect2">
<h3 class="sect2">5.2.3. Exporting Parameters to a Namespace</h3>


<p>One of the problems with using a method to retrieve the value of a
<a name="INDEX-1017" />
<a name="INDEX-1018" />parameter is that it is more work
to embed the value in a string. If you wish to print the value of
someone's input, you can use an intermediate variable:</p>


<blockquote><pre class="code">my $name = $q-&gt;param( 'user' );
print "Hi, $user!";</pre></blockquote>


<p>Another way to do this is via an odd Perl construct that forces the
subroutine to be evaluated as part of an anonymous list:</p>


<blockquote><pre class="code">print "Hi, @{[ $q-&gt;param( 'user' ) ]}!";</pre></blockquote>


<p>The first solution is more work and the second can be hard to read.
Fortunately, there is a better way. If you know that you are going to
need to refer to many output values in a string, you can import all
the parameters as variables to a specified namespace:</p>


<blockquote><pre class="code">$q-&gt;import_names( "Q" );
print "Hi, $Q::user!";</pre></blockquote>


<p>Parameters with multiple values become arrays in the new namespace,
and any
<a name="INDEX-1019" />
<a name="INDEX-1020" />characters in a parameter name
other than a letter or number become underscores. You must provide a
namespace and cannot pass "main", the default namespace,
because that might create security risks.</p>


<p>The price you pay for this convenience is increased memory usage
because Perl must create an alias for each parameter.</p>
</div>




<a name="ch05-67561" /><div class="sect2">
<h3 class="sect2">5.2.4. File Uploads with CGI.pm</h3>


<p>As we mentioned in the last 
<a name="INDEX-1021" /> <a name="INDEX-1,022" />chapter, it is possible to create a
form with a
<em class="emphasis">multipart/form-data</em>
<a name="INDEX-1023" />
media type that permits users to upload files via
<a name="INDEX-1024" />HTTP. We avoided discussing how to handle
this type of input then because handling file uploads properly can be
quite complex. Fortunately, there's no need for us to do this
because, like other form input, CGI.pm provides a very simple
interface for handling file uploads.</p>


<p>You can access the
<a name="INDEX-1025" />name of an uploaded file with the
<tt class="function">param</tt>
<a name="INDEX-1026" /> method, just like the value of any other
form element. For example, if your CGI script were receiving input
from the following HTML form:</p>


<blockquote><pre class="code">&lt;FORM ACTION="/cgi/upload.cgi" METHOD="POST" ENCTYPE="multipart/form-data"&gt;
  &lt;P&gt;Please choose a file to upload:
  &lt;INPUT TYPE="FILE" NAME="file"&gt;
  &lt;INPUT TYPE="SUBMIT"&gt;
&lt;/FORM&gt;</pre></blockquote>


<p>then you could get the name of the uploaded file this way, by
referring to the name of the &lt;FILE&gt; input element, in this case
"file":</p>


<blockquote><pre class="code">my $file = $q-&gt;param( "file" );</pre></blockquote>


<p>The name you receive from this parameter is the name of the file as
it appeared on the user's machine when they uploaded it. CGI.pm
stores the file as a temporary file on your system, but the name of
this temporary file does not correspond to the name you get from this
parameter. We will see how to access the temporary file in a moment.</p>


<p>The name supplied by this parameter varies according to
<a name="INDEX-1027" /> <a name="INDEX-1,028" />platform and browser. Some systems
supply just the name of the uploaded file; others supply the entire
path of the file on the user's machine. Because
<a name="INDEX-1029" />path
delimiters also vary between systems, it can be a challenge
determining the name of the file. The following command appears to
work for Windows, Macintosh, and Unix-compatible systems:</p>


<blockquote><pre class="code">my( $file ) = $q-&gt;param( "file" ) =~ m|([^/:\\]+)$|;</pre></blockquote>


<p>However, it may strip parts of filenames, since "report
11/3/99" is a valid filename on Macintosh systems and the above
command would in this case set <tt class="literal">$file</tt> to
"99". Another solution is to replace any characters other
than letters, digits, underscores, dashes, and periods with
<a name="INDEX-1030" />underscores and
prevent any files from beginning with <a name="INDEX-1031" />
<a name="INDEX-1032" />periods or dashes:</p>


<blockquote><pre class="code">my $file = $q-&gt;param( "file" );
$file =~ s/([^\w.-])/_/g;
$file =~ s/^[-.]+//;</pre></blockquote>


<p>The problem with this is that
<a name="INDEX-1033" />
<a name="INDEX-1034" />
<a name="INDEX-1035" />Netscape's browsers
on Windows sends the full path to the file as the filename. Thus,
<tt class="literal">$file</tt> may be set to something long and ugly like
"C_ _ _Windows_Favorites_report.doc".</p>


<p>You could try to sort out the behaviors of the different operating
systems and browsers, check for the user's browser and
operating system, and then treat the filename appropriately, but that
would be a very poor solution. You are bound to miss some
combinations, you would constantly need to update it, and one of the
greatest advantages of the Web is that it works across platforms; you
should not build any limitations into your solutions.</p>


<p>So the simple, obvious solution is actually nontechnical. If you do
need to know the name of the uploaded file, just add another text
field to the form allowing the user to enter the name of the file
they are uploading. This has the added advantage of allowing a user
to provide a different name than the file has, if appropriate. The
<a name="INDEX-1036" />HTML form looks like
this:</p>


<blockquote><pre class="code">&lt;FORM ACTION="/cgi/upload.cgi" METHOD="POST" ENCTYPE="multipart/form-data"&gt;
  &lt;P&gt;Please choose a file to upload:
  &lt;INPUT TYPE="FILE" NAME="file"&gt;
  &lt;P&gt;Please enter the name of this file:
  &lt;INPUT TYPE="TEXT" NAME="filename"&gt;
&lt;/FORM&gt;</pre></blockquote>


<p>You can then get the name from the text field, remembering to strip
out any odd characters:</p>


<blockquote><pre class="code">my $filename = $q-&gt;param( "filename" );
$filename =~ s/([^\w.-])/_/g;
$filename =~ s/^[-.]+//;</pre></blockquote>


<p>So now that we know how to get the name of the
<a name="INDEX-1037" />file uploaded, let's look at
how we get at the content. CGI.pm creates a temporary file to store
the contents of the upload; you can get a file handle for this file
by passing the name of the file according to the file element to the
<tt class="function">upload</tt>
<a name="INDEX-1038" /> <a name="INDEX-1,039" />
method as follows:</p>


<blockquote><pre class="code">my $file = $q-&gt;param( "file" );
my $fh   = $q-&gt;upload( $file );</pre></blockquote>


<p>The <tt class="function">upload</tt> method was added to CGI.pm in Version
2.47. Prior to this you could use the value returned by
<tt class="function">param</tt>
<a name="INDEX-1040" /> (in this case
<tt class="literal">$file</tt>) as a file handle in order to read from the
file; if you use it as a string it returns the name of the file. This
actually still works, but there are conflicts with strict mode and
other problems, so <tt class="function">upload</tt> is the preferred way
to get a file handle now. Be sure that you pass
<em class="emphasis">upload</em> the name of the file according to
<em class="emphasis">param</em>, and not a different name (e.g., the name
the user supplied, the name with nonalphanumeric characters replaced
with underscores, etc.).</p>


<p>Note that <a name="INDEX-1041" />
<a name="INDEX-1042" />
<a name="INDEX-1043" />transfer errors are much more common with
file uploads than with other forms of input. If the user presses the
Stop button in the browser as the file is uploading, for example,
CGI.pm will receive only a portion of the uploaded file. Because of
the format of
<em class="emphasis">multipart/form-data</em>
<a name="INDEX-1044" /> requests, CGI.pm will
recognize that the transfer is incomplete. You can check for errors
such as this by using the
<tt class="function">cgi_error</tt>
<a name="INDEX-1045" />
<a name="INDEX-1046" />
<a name="INDEX-1047" />
method after creating a CGI.pm object. It returns the
<a name="INDEX-1048" /> <a name="INDEX-1,049" />HTTP status code and message
corresponding to the error, if applicable, or an empty string if no
error has occurred. For instance, if the
<em class="emphasis">Content-length</em> of a POST request exceeds
<tt class="literal">$CGI::POST_MAX</tt>, then
<tt class="function">cgi_error</tt> will return "413 Request entity
too large". As a general rule, you should always check for an
error when you are recording input on the server. This includes file
uploads and other POST requests. It doesn't hurt to check for
an error with GET requests either.</p>


<p><a href="ch05_02.htm">Example 5-2</a> provides the <a name="INDEX-1050" />complete code, with error checking, to
receive a file upload via our previous HTML form.</p>



<a name="ch05-48711" /><div class="example">
<h4 class="objtitle">Example 5-2. upload.cgi </h4>

<blockquote><pre class="code">#!/usr/bin/perl -wT

use strict;
use CGI;
use Fcntl qw( :DEFAULT :flock );

use constant UPLOAD_DIR     =&gt; "/usr/local/apache/data/uploads";
use constant BUFFER_SIZE    =&gt; 16_384;
use constant MAX_FILE_SIZE  =&gt; 1_048_576;       # Limit each upload to 1 MB
use constant MAX_DIR_SIZE   =&gt; 100 * 1_048_576; # Limit total uploads to 100 MB
use constant MAX_OPEN_TRIES =&gt; 100;

$CGI::DISABLE_UPLOADS   = 0;
$CGI::POST_MAX          = MAX_FILE_SIZE;

my $q = new CGI;
$q-&gt;cgi_error and error( $q, "Error transferring file: " . $q-&gt;cgi_error );

my $file      = $q-&gt;param( "file" )     || error( $q, "No file received." );
my $filename  = $q-&gt;param( "filename" ) || error( $q, "No filename entered." );
my $fh        = $q-&gt;upload( $file );
my $buffer    = "";

if ( dir_size( UPLOAD_DIR ) + $ENV{CONTENT_LENGTH} &gt; MAX_DIR_SIZE ) {
    error( $q, "Upload directory is full." );
}

# Allow letters, digits, periods, underscores, dashes
# Convert anything else to an underscore
$filename =~ s/[^\w.-]/_/g;
if ( $filename =~ /^(\w[\w.-]*)/ ) {
    $filename = $1;
}
else {
    error( $q, "Invalid file name; files must start with a letter or number." );
}

# Open output file, making sure the name is unique
until ( sysopen OUTPUT, UPLOAD_DIR . $filename, O_CREAT | O_EXCL ) {
    $filename =~ s/(\d*)(\.\w+)$/($1||0) + 1 . $2/e;
    $1 &gt;= MAX_OPEN_TRIES and error( $q, "Unable to save your file." );
}

# This is necessary for non-Unix systems; does nothing on Unix
binmode $fh;
binmode OUTPUT;

# Write contents to output file
while ( read( $fh, $buffer, BUFFER_SIZE ) ) {
    print OUTPUT $buffer;
}

close OUTPUT;


sub dir_size {
    my $dir = shift;
    my $dir_size = 0;
    
    # Loop through files and sum the sizes; doesn't descend down subdirs
    opendir DIR, $dir or die "Unable to open $dir: $!";
    while ( readdir DIR ) {
        $dir_size += -s "$dir/$_";
    }
    return $dir_size;
}


sub error {
    my( $q, $reason ) = @_;
    
    print $q-&gt;header( "text/html" ),
          $q-&gt;start_html( "Error" ),
          $q-&gt;h1( "Error" ),
          $q-&gt;p( "Your upload was not procesed because the following error ",
                 "occured: " ),
          $q-&gt;p( $q-&gt;i( $reason ) ),
          $q-&gt;end_html;
    exit;
}</pre></blockquote>
</div>


<p>We start by creating several constants to configure this script.
<tt class="literal">UPLOAD_DIR</tt>
<a name="INDEX-1051" />
is the path to the directory where we will store uploaded files.
<tt class="literal">BUFFER_SIZE</tt>
<a name="INDEX-1052" />
is the amount of data to read into memory while transferring from the
temporary file to the output file. <tt class="literal">MAX_FILE_SIZE</tt>
is the maximum file size we will accept; this is important because we
want to limit users from uploading gigabyte-sized files and filling
up all of the server's disk space.
<tt class="literal">MAX_DIR_SIZE</tt>
<a name="INDEX-1053" /> is the
maximum size that we will allow our upload directory to grow to. This
restriction is as important as the last because users can fill up our
disks by posting lots of small files just as easily as posting large
files. Finally, <tt class="literal">MAX_OPEN_TRIES</tt> is the number of
times we try to generate a unique filename and open that file before
we give up; we'll see why this step is necessary in a moment.</p>


<p>First, we enable file uploads, then we set
<tt class="literal">$CGI::POST_MAX</tt>
<a name="INDEX-1054" />
<a name="INDEX-1055" /> to
<tt class="literal">MAX_FILE_SIZE</tt>. Note
<tt class="literal">$CGI::POST_MAX</tt> is actually the size of the entire
content of the request, which includes the data for other form fields
as well as overhead for the <em class="emphasis">multipart/form-data</em>
encoding, so this value is actually a little larger than the maximum
file size that the script will actually accept. For this form, the
difference is minor, but if you add a file upload field to a complex
form with multiple text fields, then you should keep this distinction
in mind.</p>


<p>We then create a CGI object and check for errors. As we said earlier,
errors with file uploads are much more common than with other forms
of CGI input. Next we get the file's upload name and the
filename the user provided, reporting errors if either of these is
missing. Note that a user may be rather upset to get a message saying
that the filename is missing after uploading a large file via a
modem. There is no way to interrupt that transfer, but in a
production application, it might be more user-friendly to save the
unnamed file temporarily, prompt the user for a filename, and then
rename the file. Of course, you would then need periodically clean up
temporary files that were abandoned.</p>


<p>We get a <a name="INDEX-1056" />file handle, <tt class="literal">$fh</tt>, to
the temporary file where CGI.pm has stored the input. We check
whether our upload directory is full and report an error if this is
the case. Again, this message is likely to create some unhappy users.
In a production application you should add code to notify an
administrator who can see why the upload directory is full and
resolve the problem. See <a href="ch09_01.htm">Chapter 9, "Sending Email"</a>.</p>


<p>Next, we replace any characters in the filename the user supplied
that may cause problems with an underscore and make sure the name
doesn't start with a <a name="INDEX-1057" />
<a name="INDEX-1058" />period or a dash. The odd construct that
reassigns the result of the <a name="INDEX-1059" />regular expression to
<tt class="literal">$filename</tt> untaints that variable. We'll
discuss tainting and why this is important in <a href="ch08_01.htm">Chapter 8, "Security"</a>. We confirm again that
<tt class="literal">$filename</tt> is not empty (which would happen if it
had consisted of nothing but periods and/or dashes) and generate an
error if this is the case.</p>


<p>We try to open a file with this name in our upload directory. If we
fail, then we add a digit to <tt class="literal">$filename</tt> and try
again. The regular expression allows us to keep the file extension
the same: if there is already a <em class="filename">report.txt</em> file,
then the next upload with that name will be named
<em class="filename">report1.txt</em>, the next one
<em class="filename">report2.txt</em>, etc. This continues until we exceed
<tt class="literal">MAX_OPEN_TRIES</tt>
<a name="INDEX-1060" /> <a name="INDEX-1,061" />. It is important that
we create a limit to this loop because there may be a reason other
than a non-unique name that prevents us from saving the file. If the
disk is full or the system has too many open files, for example, we
do not want to start looping endlessly. This error should also notify
an administrator that something is wrong.</p>


<p>This script is written to handle any type of file upload, including
binary files such as images or audio. By default, whenever Perl
accesses a file handle on non-Unix systems (more specifically,
systems that do not use <tt class="literal">\n</tt> as their end of line
character), Perl translates the native <a name="INDEX-1062" /> <a name="INDEX-1,063" /> <a name="INDEX-1,064" />operating system's end of line
characters, such as <tt class="literal">\r\n</tt> for Windows or
<tt class="literal">\r</tt> for MacOS, to <tt class="literal">\n</tt> on input
and back to the native characters on output. This works great for
text files, but it can corrupt binary files. Thus, we enable
<a name="INDEX-1065" />binary mode with the
<tt class="function">binmode</tt> function in order to disable this
translation. On systems, like Unix, where no end of line translation
occurs, <tt class="function">binmode</tt> has no effect.</p>


<p>Finally, we read from our temporary file handle and write to our
output file and exit. We use the
<tt class="function">read</tt>
<a name="INDEX-1066" /> function to read and write a chunk a data
at a time. The size of this chunk is defined by our
<tt class="literal">BUFFER_SIZE</tt> constant. In case you are wondering,
CGI.pm will remove its temporary file automatically when our script
exits (technically, when <tt class="literal">$q</tt> goes out of scope).</p>


<p>There is another way we could have moved the file to our
<em class="emphasis">uploads</em> directory. We could use CGI.pm's
undocumented
<tt class="function">tmpFileName</tt>
<a name="INDEX-1067" />
<a name="INDEX-1068" />
<a name="INDEX-1069" /> method to get the name of the
temporary file containing the upload and then used
<a name="INDEX-1070" />Perl's <tt class="function">rename</tt>
function to move the file. However, relying on undocumented code is
dangerous, because it may not be compatible with future versions of
CGI.pm. Thus, in our example we stick to the public API instead.</p>


<p>The
<tt class="function">dir_size</tt>
<a name="INDEX-1071" />
<a name="INDEX-1072" /> subroutine calculates the size of a
directory by summing the size of each of its files. The
<tt class="function">error</tt> subroutine prints a message telling the
user why the transfer failed. In a production application, you
probably want to provide links for the user to get help <a name="INDEX-1073" />or to notify

<a name="INDEX-1074" /> <a name="INDEX-1,075" />someone <a name="INDEX-1,076" /> <a name="INDEX-1,077" /> <a name="INDEX-1,078" />about problems.</p>
</div>


<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch05_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch05_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">5. CGI.pm</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">5.3. Generating Output with CGI.pm</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="../run/index.htm" coords="172,2,252,105" shape="rect" /><area href="../apache/index.htm" coords="238,2,334,95" shape="rect" /><area href="../sql/index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>