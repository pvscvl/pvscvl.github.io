<?label 14.6. Functions?><html><head><title>Functions (Apache: The Definitive Guide)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="Ben Laurie and Peter Laurie" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="1565925289L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Apache: The Definitive Guide" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="Apache: The Definitive Guide" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch14_05.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm">Apache: The Definitive Guide</a></td><td width="172" valign="top" align="right"><a href="ch15_01.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<h2 class="sect1">14.6. Functions</h2>




<p>
<a name="INDEX-1248" />
<a name="INDEX-1249" />
<a name="INDEX-1250" />
<a name="INDEX-1251" />
<a name="INDEX-1252" />Now that we have covered the main structures used by modules, we can detail the functions available to use and manipulate those structures.</p>





<a name="ch14-1-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.1. Pool Functions</h3>





<a name="INDEX-1253" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_make_sub_pool</i></b></font></td><td align="right"><i>create a subpool</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>pool *ap_make_sub_pool(pool *p)</pre></td><td align="right" /></tr></table>Creates a subpool within a pool. The subpool is destroyed automatically when the pool <tt class="literal">p</tt> is destroyed, but can also be destroyed earlier with <tt class="literal">destroy_pool</tt> or cleared with <tt class="literal">clear_pool</tt>. Returns the new pool.</p></div>

<a name="INDEX-1254" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_clear_pool</i></b></font></td><td align="right"><i>clear a pool without destroying it</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_clear_pool(pool *p)</pre></td><td align="right" /></tr></table>Clears a pool, destroying all its subpools with <tt class="literal">destroy_pool</tt> and running cleanups. This leaves the pool itself empty but intact, and therefore available for reuse.</p></div>

<a name="INDEX-1255" /><a name="INDEX-1256" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_destroy_pool</i></b></font></td><td align="right"><i>destroy a pool and all its contents</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_destroy_pool(pool *p)</pre></td><td align="right" /></tr></table>Destroys a pool, running cleanup methods for the contents and also destroying all subpools. The subpools are destroyed before the pool's cleanups are run.</p></div>

<a name="INDEX-1257" /><a name="INDEX-1258" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bytes_in_pool</i></b></font></td><td align="right"><i>report the size of a pool</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>long ap_bytes_in_pool(pool *p)</pre></td><td align="right" /></tr></table>Returns the number of bytes currently allocated to a pool.</p></div>

<a name="INDEX-1259" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bytes_in_free_blocks</i></b></font></td><td align="right"><i>report the total size of free blocks in the pool system</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>long ap_bytes_in_free_blocks(void)</pre></td><td align="right" /></tr></table>Returns the number of bytes currently in free blocks for all pools.</p></div>

<a name="INDEX-1260" /><a name="INDEX-1261" /><a name="INDEX-1262" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_palloc</i></b></font></td><td align="right"><i>allocate memory within a pool</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void *ap_palloc(pool *p, int size)</pre></td><td align="right" /></tr></table>Allocates memory of at least <tt class="literal">size</tt> bytes. The memory is destroyed when the pool is destroyed. Returns a pointer to the new block of memory.</p></div>

<a name="INDEX-1263" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pcalloc</i></b></font></td><td align="right"><i>allocate and clear memory within a pool</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void *ap_pcalloc(pool *p, int size)</pre></td><td align="right" /></tr></table>Allocates memory of at least <tt class="literal">size</tt> bytes. The memory is initialized to zero. The memory is destroyed when the pool is destroyed. Returns a pointer to the new block of memory.</p></div>

<a name="INDEX-1264" /><a name="INDEX-1265" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pstrdup</i></b></font></td><td align="right"><i>duplicate a string in a pool</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_pstrdup(pool *p,const char *s)</pre></td><td align="right" /></tr></table>Duplicates a string within a pool. The memory is destroyed when the pool is destroyed. If <tt class="literal">s</tt> is <tt class="literal">NULL</tt>, the return value is <tt class="literal">NULL</tt>; otherwise, it is a pointer to the new copy of the string.</p></div>

<a name="INDEX-1266" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pstrndup</i></b></font></td><td align="right"><i>duplicate a string in a pool with limited length</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_pstrndup(pool *p, const char *s, int n)</pre></td><td align="right" /></tr></table>Allocates <tt class="literal">n</tt>+1 bytes of memory and copies up to <tt class="literal">n</tt> characters from <tt class="literal">s</tt>, <tt class="literal">NULL</tt>-      terminating the result. The memory is destroyed when the pool is destroyed. Returns a pointer to the new block of memory, or <tt class="literal">NULL</tt> if <tt class="literal">s</tt> is <tt class="literal">NULL</tt>.</p></div>

<a name="INDEX-1267" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pstrcat</i></b></font></td><td align="right"><i>concatenate and duplicate a list of strings</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_pstrcat(pool *p, ...)</pre></td><td align="right" /></tr></table>Concatenates the <tt class="literal">NULL</tt>-terminated list of strings together in a new block of memory. The memory is destroyed when the pool is destroyed. Returns a pointer to the new block of memory. For example:</p><blockquote><pre class="code">pstrcat(p,"Hello,","world!",NULL);</pre></blockquote><p>returns a block of memory containing <tt class="literal">Hello, world!</tt></p></div>
</div>
















<a name="ch14-12-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.2. Array Functions</h3>






<a name="INDEX-1268" /><a name="INDEX-1269" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_make_array</i></b></font></td><td align="right"><i>allocate an array of arbitrary-size elements</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>array_header *ap_make_array(pool *p, int nelts, int elt_size)</pre></td><td align="right" /></tr></table>Allocates memory to contain <tt class="literal">nelts</tt> elements of size <tt class="literal">elt_size</tt>. The array can grow to contain as many elements as needed. The array is destroyed when the pool is destroyed. Returns a pointer to the new array.</p></div>

<a name="INDEX-1270" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_push_array</i></b></font></td><td align="right"><i>add a new element to an array</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void *ap_push_array(array_header *arr)</pre></td><td align="right" /></tr></table>Returns a pointer to the next element of the array <tt class="literal">arr</tt>, allocating more memory to accommodate it if necessary.</p></div>

<a name="INDEX-1271" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_array_cat</i></b></font></td><td align="right"><i>concatenate two arrays</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_array_cat(array_header *dst, const array_header *src)</pre></td><td align="right" /></tr></table>Appends the array <tt class="literal">src</tt> to the array <tt class="literal">dst</tt>. The <tt class="literal">dst</tt> array is allocated more memory if necessary to accommodate the extra elements. Although this operation only makes sense if the two arrays have the same element size, there is no check for this.</p></div>

<a name="INDEX-1272" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_copy_array</i></b></font></td><td align="right"><i>create a copy of an array</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>array_header *ap_copy_array(pool *p, const array_header *arr)</pre></td><td align="right" /></tr></table>Creates a new copy of the array <tt class="literal">arr</tt> in the pool <tt class="literal">p</tt>. The new array is destroyed when the pool is destroyed. Returns a pointer to the new array.</p></div>

<a name="INDEX-1273" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_copy_array_hdr</i></b></font></td><td align="right"><i>create a copy of an array with copy-on-write</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>array_header *ap_copy_array_hdr(pool *p, const array_header *arr)</pre></td><td align="right" /></tr></table>Copies the array <tt class="literal">arr</tt> into the pool <tt class="literal">p</tt> without immediately copying the array's storage. If the array is extended with <tt class="literal">push_array</tt>, the original array is copied to the new array before the extension takes place. Returns a pointer to the new array.</p><p>There are at least two pitfalls with this function. First, if the array is not extended, its memory is destroyed when the original array is destroyed; second, any changes made to the original array may also affect the new array if they occur before the new array is extended.</p></div>

<a name="INDEX-1274" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_append_arrays</i></b></font></td><td align="right"><i>concatenate two arrays into a new array</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>array_header*ap_append_arrays(pool*p, const array_haeder*first, const array_header *second)</pre></td><td align="right" /></tr></table>Creates a new array consisting of the elements of <tt class="literal">second</tt> appended to the elements of <tt class="literal">first</tt>. If <tt class="literal">second</tt> is empty, the new array shares memory with <tt class="literal">first</tt> until a new element is appended (this is a consequence of using <tt class="literal">ap_copy_array_hdr()</tt> to create the new array; see the warning in that function). Returns a pointer to the new array.</p></div>
</div>
















<a name="ch14-19-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.3. Table Functions</h3>




<p>A table is an association between two strings known as the <em class="emphasis">key</em> and the <em class="emphasis">value</em>, accessible by the key.</p>






<a name="INDEX-1275" /><a name="INDEX-1276" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_make_table</i></b></font></td><td align="right"><i>create a new table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>table *ap_make_table(pool *p, int nelts)</pre></td><td align="right" /></tr></table>Creates a new table with sufficient initial storage for <tt class="literal">nelts</tt> elements. Returns a pointer to the table.</p></div>

<a name="INDEX-1277" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_copy_table</i></b></font></td><td align="right"><i>copy a table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>table *ap_copy_table(pool *p, const table *t)</pre></td><td align="right" /></tr></table>Returns a pointer to a copy of the table.</p></div>

<a name="INDEX-1278" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_elts</i></b></font></td><td align="right"><i>access the array that underlies a table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>array_header *ap_table_elts(table *t)</pre></td><td align="right" /></tr></table>Returns the array upon which the table is based.</p></div>

<a name="INDEX-1279" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_is_empty_table</i></b></font></td><td align="right"><i>test whether a table is empty</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_is_empty_table(table *t)</pre></td><td align="right" /></tr></table>Returns nonzero if the table is empty.</p></div>

<a name="INDEX-1280" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_set</i></b></font></td><td align="right"><i>create or replace an entry in a table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_table_set(table *t, const char *key, const char *value)</pre></td><td align="right" /></tr></table>If <tt class="literal">key</tt> already has an associated value in <tt class="literal">t</tt>, it is replaced with a copy of <tt class="literal">value</tt>; otherwise, a new entry is created in the table. Note that the key and value are duplicated with <tt class="literal">ap_pstrdup()</tt>.</p></div>

<a name="INDEX-1281" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_setn</i></b></font></td><td align="right"><i>create or replace an entry in a table without duplication</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_table_setn(table *t, const char *key, const char *value)</pre></td><td align="right" /></tr></table>This is similar to <tt class="literal">ap_table_set()</tt>, except that the key and value are not duplicated. This is normally used to copy a value from a pool to a subpool.</p></div>

<a name="INDEX-1282" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_merge</i></b></font></td><td align="right"><i>merge a new value into a table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_table_merge(table *t, const char *key, const char *value)</pre></td><td align="right" /></tr></table>If an entry already exists for <tt class="literal">key</tt> in the table, <tt class="literal">value</tt> is appended to the existing value, separated by a comma and a space. Otherwise, a new entry is created, as in <tt class="literal">table_set</tt>. Note that if multiple instances of <tt class="literal">key</tt> exist in the table, only the first is affected.</p><blockquote><pre class="code">pool *p;     /* Assumed to be set elsewhere */
table *t;
char *v;

t=make_table(1);
table_set(t,"somekey","Hello");
table_merge(t,"somekey","world!");
v=table_get(t,"somekey");     /* v now contains "Hello, world!" */</pre></blockquote></div>

<a name="INDEX-1283" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_mergen</i></b></font></td><td align="right"><i>merge a new value into a table without duplication</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_table_mergen(table *t, const char *key, const char *value)</pre></td><td align="right" /></tr></table>This is similar to <tt class="literal">ap_table_merge()</tt>, except that if a new key/value pair is created, it is not duplicated. This is normally used to merge a value from a pool into a subpool.</p></div>

<a name="INDEX-1284" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_add</i></b></font></td><td align="right"><i>add a new key/value pair to a table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_table_add(table *t, const char *key, const char *value)</pre></td><td align="right" /></tr></table>Adds a new entry to the table, associating <tt class="literal">key</tt> with <tt class="literal">value</tt>. Note that a new entry is created whether or not the key already exists in the table. The key and value stored are duplicated using <tt class="literal">ap_pstrdup()</tt>.</p></div>

<a name="INDEX-1285" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_addn</i></b></font></td><td align="right"><i>add a new key/value pair to a table without duplication</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_table_addn(table *t, const char *key, const char *value)</pre></td><td align="right" /></tr></table>Adds a new entry to the table, associating <tt class="literal">key</tt> with <tt class="literal">value</tt>. Note that a new entry is created whether or not the key already exists in the table. The key and value stored are <em class="emphasis">not</em> duplicated, so care must be taken to ensure they are not changed. This function is normally used to copy a table element from a pool into a subpool.</p></div>

<a name="INDEX-1286" /><a name="INDEX-1287" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_unset</i></b></font></td><td align="right"><i>remove an entry from a table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_table_unset(table *t, const char *key)</pre></td><td align="right" /></tr></table>Removes the entry in the table corresponding to <tt class="literal">key</tt>. It is not an error to remove an entry that does not exist.</p></div>

<a name="INDEX-1288" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_get</i></b></font></td><td align="right"><i>find the value in a table corresponding to a key</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_table_ get(const table *t, const char *key)</pre></td><td align="right" /></tr></table>Returns the value corresponding to <tt class="literal">key</tt> in the table <tt class="literal">t</tt>. Note that you may not modify the returned value.</p></div>

<a name="INDEX-1289" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_table_do</i></b></font></td><td align="right"><i>apply a function to each element of a table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_table_do(int(*comp)(void*, const char*, const char*), void*rec, const table *t,...)</pre></td><td align="right" /></tr></table>If the NULL terminated <tt class="literal">vararg</tt> list is empty,
traverses the whole table and runs the function
<tt class="literal">comp(rec,key,value)</tt> on each key/value pair. If the
<tt class="literal">vararg</tt> list is non-empty, traverses the matching
keys (<tt class="literal">strcasecmp()</tt> is used to determine a match)
and runs the same function. Each traversal is terminated if the
function comp returns the value 0.</p><p>In either case it may happen that the <tt class="literal">comp()</tt>
function is called multiple times for the same key. The table may
again contain various entries of the same key; and if the
<tt class="literal">vararg</tt> list is non-empty, the traversal is repeated
for any <tt class="literal">vararg</tt> item, even if they are equal.</p></div>

<a name="INDEX-1290" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_overlay_tables</i></b></font></td><td align="right"><i>concatenate two tables to give a new table</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>table *ap_overlay_tables(pool *p, const table *overlay, const table *base)
</pre></td><td align="right" /></tr></table>Creates a new table consisting of the two tables <tt class="literal">overlay</tt> and <tt class="literal">base</tt> concatenated, <tt class="literal">overlay</tt> first. No attempt is made to merge or override existing keys in either table, but since <tt class="literal">overlay</tt> comes first, any retrieval done with <tt class="literal">table_get</tt> on the new table gets the entry from <tt class="literal">overlay</tt> if it exists. Returns a pointer to the new table.</p></div>

<a name="INDEX-1291" /><a name="INDEX-1292" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_clear_table</i></b></font></td><td align="right"><i>clear a table without deleting it</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>API_EXPORT(void) ap_clear_table(table *t)</pre></td><td align="right" /></tr></table>Clears the table. None of the elements are destroyed (since the pool mechanism doesn't permit it, anyway), but they become unavailable.<a name="INDEX-1292" /></p></div>
</div>
















<a name="ch14-35-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.4. Cleanup Functions</h3>




<p>
<a name="INDEX-1293" />An important part of the pool is the cleanup functions that are run when the pool is destroyed. These functions deal with those cleanup functions.</p>





<a name="INDEX-1294" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_register_cleanup</i></b></font></td><td align="right"><i>register a cleanup function</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_register_cleanup(pool*p, void*data, void(*plain_cleanup)(void*),void (*child_cleanup)(void *))</pre></td><td align="right" /></tr></table>Registers a pair of functions to be called when the pool is destroyed. Pools can be destroyed for two reasons: first, because the server has finished with that pool, in which case it destroys it and calls the <tt class="literal">plain_cleanup</tt> function, or second, because the server has forked and is preparing to <tt class="literal">exec</tt> some other program, in which case the <tt class="literal">child_cleanup</tt> function is called. In either case, <tt class="literal">data</tt> is passed as the only argument to the cleanup function. If either of these cleanups is not required, use <tt class="literal">ap_null_cleanup</tt>.</p></div>

<a name="INDEX-1295" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_kill_cleanup</i></b></font></td><td align="right"><i>remove a cleanup function</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_kill_cleanup(pool *p, void *data, void (*plain_cleanup)(void *))
</pre></td><td align="right" /></tr></table>Removes the previously registered cleanup function from the pool. The cleanup function is identified by the <tt class="literal">plain_cleanup</tt> function and the <tt class="literal">data</tt> pointer previously registered with <tt class="literal">register_cleanup</tt>. Note that the <tt class="literal">data</tt> pointer must point to the same memory as was used in <tt class="literal">register_cleanup</tt>.</p></div>

<a name="INDEX-1296" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_cleanup_for_exec</i></b></font></td><td align="right"><i>clear all pools in preparation for an exec</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_cleanup_for_exec(void)</pre></td><td align="right" /></tr></table>Destroys all pools using the <tt class="literal">child_cleanup</tt> methods. Needless to say, this should only be done after forking and before running a (nonserver) child. Calling this in a running server certainly stops it from working!</p><p><img src="figs/win32_icon.gif" alt="Figure 14.3" />   Note that on Win32 this actually does nothing, on the slightly dubious grounds that we aren't forked. Unfortunately, there isn't really much alternative.</p></div>

<a name="INDEX-1297" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_note_cleanups_for_fd</i></b></font></td><td align="right"><i>register a cleanup for a file descriptor</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_note_cleanups_for_fd(pool *p, int fd)</pre></td><td align="right" /></tr></table>Registers a cleanup function that will close the file descriptor when the pool is destroyed. Normally one of the file-opening functions does this for you, but it is occasionally necessary to do it "by hand." Note that sockets have their own cleanup functions.</p></div>

<a name="INDEX-1298" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_kill_cleanups_for_fd</i></b></font></td><td align="right"><i>remove the cleanup for a file descriptor</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_kill_cleanups_for_fd(pool *p, int fd)</pre></td><td align="right" /></tr></table>Kills cleanups for a file descriptor registered using <tt class="literal">popenf()</tt>, <tt class="literal">pfopen()</tt>, <tt class="literal">pfdopen()</tt>, or <tt class="literal">note_cleanups_for_fd()</tt>. Normally this is taken care of when the file is closed, but occasionally it is necessary to call it directly.</p></div>

<a name="INDEX-1299" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_note_cleanups_for_socket</i></b></font></td><td align="right"><i>register a cleanup for a socket</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_note_cleanups_for_socket(pool *p, int fd)</pre></td><td align="right" /></tr></table>Registers a cleanup function that will close the socket when the pool is destroyed. This is distinct from <tt class="literal">ap_note_cleanups_for_fd()</tt> because sockets and file descriptors are not equivalent on Win32.</p></div>

<a name="INDEX-1300" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_kill_cleanups_for_socket</i></b></font></td><td align="right"><i>remove the cleanup for a socket</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_kill_cleanups_for_socket(pool *p, int sock)</pre></td><td align="right" /></tr></table>Removes the cleanup function for the socket <tt class="literal">sock</tt>. This is normally done for you when the socket is closed by <tt class="literal">ap_pclosesocket()</tt>, but it may occasionally be necessary to call it directly.</p></div>

<a name="INDEX-1301" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_note_cleanups_for_file</i></b></font></td><td align="right"><i>register a cleanup for a FILE *</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_note_cleanups_for_file(pool *p, FILE *f)</pre></td><td align="right" /></tr></table>Registers a cleanup function to close the stream when the pool is destroyed. Strangely, there isn't an <tt class="literal">ap_kill_cleanups_for_file()</tt>.</p></div>

<a name="INDEX-1302" /><a name="INDEX-1303" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_run_cleanup</i></b></font></td><td align="right"><i>run a cleanup function, blocking alarms</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_run_cleanup(pool *p, void *data, void (*cleanup)(void *))</pre></td><td align="right" /></tr></table>Runs a cleanup function, passing <tt class="literal">data</tt> to it, with alarms blocked. It isn't usually necessary to call this, since cleanups are run automatically, but it can be used for any custom cleanup code. The cleanup function is removed from <tt class="literal">p</tt>.<a name="INDEX-1303" /></p></div>
</div>
















<a name="ch14-45-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.5. File and Socket Functions</h3>




<p>
<a name="INDEX-1304" />
<a name="INDEX-1305" />These functions are used to open and close files and sockets with automatic cleanup registration and killing.</p>





<a name="INDEX-1306" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_popenf</i></b></font></td><td align="right"><i>open a file with automatic cleanup</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_popenf(pool *p, const char *name, int flg, int mode)</pre></td><td align="right" /></tr></table>The equivalent to the standard C function <tt class="literal">open()</tt>, except that it ensures that the file is closed when the pool is destroyed. Returns the file descriptor for the opened file, or <tt class="literal">-1</tt> on error.</p></div>

<a name="INDEX-1307" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pclosef</i></b></font></td><td align="right"><i>close a file opened with popenf</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_pclosef(pool *p, int fd)</pre></td><td align="right" /></tr></table>Closes a file previously opened with <tt class="literal">ap</tt>_<tt class="literal">popenf()</tt>. The return value is whatever <tt class="literal">close()</tt> returns. The file's cleanup function is destroyed.</p></div>

<a name="INDEX-1308" /><a name="INDEX-1309" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pfopen</i></b></font></td><td align="right"><i>open a stream with automatic cleanup</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>FILE *ap_pfopen(pool *p, const char *name, const char *mode)</pre></td><td align="right" /></tr></table>Equivalent to <tt class="literal">fopen()</tt>, except that it ensures that the stream is closed when the pool is destroyed. Returns a pointer to the new stream, or <tt class="literal">NULL</tt> on error.</p></div>

<a name="INDEX-1310" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pfdopen</i></b></font></td><td align="right"><i>open a stream from a file descriptor with automatic cleanup</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>FILE *ap_pfdopen(pool *p, int fd, const char *mode)</pre></td><td align="right" /></tr></table>Equivalent to <tt class="literal">fdopen()</tt>, except that it ensures the stream is closed when the pool is destroyed. Returns a pointer to the new stream, or <tt class="literal">NULL</tt> on error.</p></div>

<a name="INDEX-1311" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pfclose</i></b></font></td><td align="right"><i>close a stream opened with pfopen(  ) or pfdopen(  )</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_pfclose(pool *p, FILE *fd)</pre></td><td align="right" /></tr></table>Closes the stream with <tt class="literal">fclose()</tt>, removing its cleanup function from the pool. Returns whatever <tt class="literal">fclose()</tt> returns.</p></div>

<a name="INDEX-1312" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_psocket</i></b></font></td><td align="right"><i>open a socket with automatic cleanup</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_psocket(pool *p, int domain, int type, int protocol)</pre></td><td align="right" /></tr></table>Opens a socket, using <tt class="literal">socket()</tt>, registering a cleanup function to close the socket when the pool is destroyed.</p></div>

<a name="INDEX-1313" /><a name="INDEX-1314" /><a name="INDEX-1315" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pclosesocket</i></b></font></td><td align="right"><i>close a socket created with ap_psocket(  )</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_pclosesocket(pool *a, int sock)</pre></td><td align="right" /></tr></table>Closes the socket, using <tt class="literal">closesocket()</tt>, removing the cleanup function from the pool. Returns whatever <tt class="literal">closesocket()</tt> returns.<a name="INDEX-1314" />
<a name="INDEX-1315" /></p></div>
</div>
















<a name="ch14-53-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.6. Regular Expression Functions</h3>





<p>
<a name="INDEX-1316" />Note that only the functions that allocate memory are wrapped by Apache API functions.</p>





<a name="INDEX-1317" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pregcomp</i></b></font></td><td align="right"><i>compile a regular expression with automatic cleanup</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>regex_t *ap_pregcomp(pool *p, const char *pattern, int cflags)</pre></td><td align="right" /></tr></table>Equivalent to <tt class="literal">regcomp()</tt>, except that memory used is automatically freed when the pool is destroyed and that the <tt class="literal">regex_t *</tt> argument to <tt class="literal">regcomp()</tt> is created in the pool and returned, rather than being passed as a parameter.</p></div>

<a name="INDEX-1318" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pregsub</i></b></font></td><td align="right"><i>substitute for regular expression submatches</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_pregsub(pool *p, const char *input, const char *source, size_t nmatch, regmatch_t pmatch[])
</pre></td><td align="right" /></tr></table>Substitutes for <tt class="literal">$0-$9</tt> in <tt class="literal">input</tt>, using <tt class="literal">source</tt> as the source of the substitutions, and <tt class="literal">pmatch</tt> to determine where to substitute from. <tt class="literal">nmatch</tt>, <tt class="literal">pmatch</tt>, and <tt class="literal">source</tt> should be the same as passed to <tt class="literal">regexec()</tt>. Returns the substituted version of <tt class="literal">input</tt> in memory allocated from <tt class="literal">p</tt>.</p></div>

<a name="INDEX-1319" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pregfree</i></b></font></td><td align="right"><i>free a regular expression compiled with ap_pregcomp(  )</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_pregfree(pool *p, regex_t * reg)</pre></td><td align="right" /></tr></table>Frees the regular expression with <tt class="literal">regfree()</tt>, removing its cleanup function from the pool.</p></div>

<a name="INDEX-1320" /><a name="INDEX-1321" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_os_is_path_absolute</i></b></font></td><td align="right"><i>determine whether a path is absolute</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_os_is_path_absolute(const char *file)</pre></td><td align="right" /></tr></table>Returns <tt class="literal">1</tt> if <tt class="literal">file</tt> is an absolute path, <tt class="literal">0</tt> otherwise.<a name="INDEX-1321" /></p></div>
</div>
















<a name="ch14-58-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.7. Process and CGI Functions</h3>





<a name="INDEX-1322" /><a name="INDEX-1323" /><a name="INDEX-1324" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_note_subprocess</i></b></font></td><td align="right"><i>register a subprocess for killing on pool destruction</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_note_subprocess(pool *p, int pid, enum kill_conditions how)</pre></td><td align="right" /></tr></table>Registers a subprocess to be killed on pool destruction. Exactly
how it is killed depends on <tt class="literal">how</tt>:</p><dl>
<dt><b><tt class="literal">kill_never</tt></b></dt>
<dd><p>Don't kill the process or wait for it. This is normally used
internally.</p></dd>





<dt><b><tt class="literal">kill_after_timeout</tt></b></dt>
<dd><p>Send the process a <tt class="literal">SIGTERM</tt>, wait three seconds,
send a <tt class="literal">SIGKILL</tt>, and wait for the process to die.</p></dd>





<dt><b><tt class="literal">kill_always</tt></b></dt>
<dd><p>Send the process a <tt class="literal">SIGKILL</tt> and wait for the
process to die.</p></dd>





<dt><b><tt class="literal">just_wait</tt></b></dt>
<dd><p>Don't send the process any kind of kill.</p></dd>





<dt><b><tt class="literal">kill_only_once</tt></b></dt>
<dd><p>Send a <tt class="literal">SIGTERM</tt>, then wait.</p></dd>

</dl><p>Note that all three-second delays are carried out at once, rather than one after the other.</p></div>

<a name="INDEX-1325" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_spawn_child</i></b></font></td><td align="right"><i>spawn a child process</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>
int ap_spawn_child(pool *p, void(*func)(void *,child_info *), void *data, 
enum kill_conditions kill_how, FILE **pipe_in, FILE **pipe_out, FILE **pipe_err)
</pre></td><td align="right" /></tr></table>This function should not be used, as it is known to expose bugs in Microsoft's libraries on Win32. You should use <tt class="literal">ap_bspawn_child()</tt> instead. This function was called <tt class="literal">spawn_child_err</tt> in previous versions of Apache.</p></div>

<a name="INDEX-1326" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bspawn_child</i></b></font></td><td align="right"><i>spawn a child process</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bspawn_child(pool *p, int (*func) (void *, child_info *), void
*data,
 enum kill_conditions kill_how, BUFF **pipe_in, BUFF **pipe_out, BUFF **pipe_err)
</pre></td><td align="right" /></tr></table>Spawns a child process, with pipes optionally connected to its standard input, output, and error. This function takes care of the details of forking (if the platform supports it) and setting up the pipes. <tt class="literal">func</tt> is called with <tt class="literal">data</tt> and a <tt class="literal">child_info</tt> structure as its arguments in the child process.</p><p><img src="figs/win32_icon.gif" alt="Figure 14.3" />   The <tt class="literal">child_info</tt> structure carries information needed to spawn the child under Win32; it is normally passed straight on to <tt class="literal">ap_call_exec()</tt>. If <tt class="literal">func()</tt> wants cleanup to occur, it calls <tt class="literal">cleanup_for_exec</tt>. <tt class="literal">func()</tt> will normally actually execute the child process with <tt class="literal">ap_call_exec()</tt>. If any of <tt class="literal">pipe_in</tt>, <tt class="literal">pipe_out</tt>, or <tt class="literal">pipe_err</tt> are <tt class="literal">NULL</tt>, those pipes aren't created; otherwise, they are filled in with pointers to <tt class="literal">BUFF</tt>s that are connected to the subprocesses' standard input, output, and error, respectively. Note that on Win32, the pipes use Win32 native handles rather than C file handles. This function only returns in the parent. Returns the PID of the child process, or <tt class="literal">-1</tt> on error. This function was called <tt class="literal">spawn_child_err_buff</tt> in previous versions of Apache.</p></div>

<a name="INDEX-1327" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_call_exec</i></b></font></td><td align="right"><i>exec, spawn, or call setuid wrapper</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_call_exec(request_rec*r, child_info*pinfo, char*argv0, char**env, int shellcmd)</pre></td><td align="right" /></tr></table>Calls <tt class="literal">exec()</tt> (or an appropriate spawning function on nonforking platforms) or the <em class="emphasis">setuid</em> wrapper, depending on whether <em class="emphasis">setuid</em> wrappers are enabled. <tt class="literal">argv0</tt> is the name of the program to run; <tt class="literal">env</tt> is a <tt class="literal">NULL</tt>-terminated array of strings to be used as the environment of the <tt class="literal">exec</tt>'d program. If <tt class="literal">shellcmd</tt> is nonzero, the command is run via a shell. If <tt class="literal">r-&gt;args</tt> is set and does not contain an equal sign, it is passed as command-line arguments. <tt class="literal">pinfo</tt> should be the structure passed by <tt class="literal">ap_bspawn_child()</tt>. This function should not return on forking platforms. On nonforking platforms it returns the PID of the new process.</p></div>

<a name="INDEX-1328" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_can_exec</i></b></font></td><td align="right"><i>check whether a path can be executed</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_can_exec(const struct stat *finfo)</pre></td><td align="right" /></tr></table>Given a <tt class="literal">struct</tt> <tt class="literal">stat</tt> (from <tt class="literal">stat()</tt> et al.), returns nonzero if the file described by <tt class="literal">finfo</tt> can be executed.</p></div>

<a name="INDEX-1329" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_add_cgi_vars</i></b></font></td><td align="right"><i>set environment variables for CGIs</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_add_cgi_vars(request_rec *r)</pre></td><td align="right" /></tr></table>Adds the environment variables required by the CGI specification (apart from those added by <tt class="literal">ap_add_common_vars()</tt>). Call this before actually <tt class="literal">exec()</tt>ing a CGI. <tt class="literal">ap_add_common_vars()</tt> should also be called.</p></div>

<a name="INDEX-1330" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_add_common_vars</i></b></font></td><td align="right"><i>set environment variables for subprograms</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_add_common_vars(request_rec *r)</pre></td><td align="right" /></tr></table>Adds the environment variables common to all subprograms run as a result of a request. Usually, <tt class="literal">ap_add_cgi_vars()</tt> should be called as well. The only exception we are aware of is ISAPI programs.</p></div>

<a name="INDEX-1331" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_scan_script_header_err</i></b></font></td><td align="right"><i>scan the headers output by a CGI</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_scan_script_header_err(request_rec *r, FILE *f, char *buffer)</pre></td><td align="right" /></tr></table>Read the headers arriving from a CGI on <tt class="literal">f</tt>, checking them for correctness. Most headers are simply stored in <tt class="literal">r-&gt;headers_out</tt>, which means they'll ultimately be sent to the client, but a few are dealt with specially:</p><dl>
<dt><b><tt class="literal">Status</tt></b></dt>
<dd><p>If this is set, it is used as the HTTP response code.</p></dd>





<dt><b><tt class="literal">Location</tt></b></dt>
<dd><p>If this is set, the result is a redirect to the URL specified.</p></dd>

</dl><p>If <tt class="literal">buffer</tt> is provided (it can be <tt class="literal">NULL</tt>), then, should the script send an illegal header, it will be left in <tt class="literal">buffer</tt>, which must be at least <tt class="literal">MAX_STRING_LEN</tt> bytes long. The return value is <tt class="literal">HTTP_OK</tt>, the status set by the script, or <tt class="literal">SERVER_ERROR</tt> if an error occurred.</p></div>

<a name="INDEX-1332" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_scan_script_header_err_buff</i></b></font></td><td align="right"><i>scan the headers output by a CGI</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_scan_script_header_err_buff(request_rec *r, BUFF *fb, char*buffer)</pre></td><td align="right" /></tr></table>This is similar to <tt class="literal">ap_scan_script_header_err()</tt>, except that the CGI is connected with a <tt class="literal">BUFF *</tt> instead of a <tt class="literal">FILE *</tt>.</p></div>

<a name="INDEX-1333" /><a name="INDEX-1334" /><a name="INDEX-1335" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_scan_script_header</i></b></font></td><td align="right"><i>scan the headers output by a CGI</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_scan_script_header(request_rec *r, FILE *f)</pre></td><td align="right" /></tr></table>This is similar to <tt class="literal">ap_scan_script_header_err()</tt>, except that no error buffer is passed.<a name="INDEX-1334" />
<a name="INDEX-1335" /></p></div>
</div>
















<a name="ch14-69-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.8. MD5 Functions</h3>





<a name="INDEX-1336" /><a name="INDEX-1337" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_md5</i></b></font></td><td align="right"><i>calculate the MD5 hash of a string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_md5(pool *p, unsigned char *string)</pre></td><td align="right" /></tr></table>Calculates the MD5 hash of <tt class="literal">string</tt>, returning the ASCII hex representation of the hash (which is 33 bytes, including terminating <tt class="literal">NUL</tt>), allocated in the pool <tt class="literal">p</tt>.</p></div>

<a name="INDEX-1338" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_md5contextTo64</i></b></font></td><td align="right"><i>convert an MD5 context to base 64 encoding</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_md5contextTo64(pool *a, AP_MD5_CTX * context)</pre></td><td align="right" /></tr></table>Take the MD5 hash in <tt class="literal">context</tt> (which must <em class="emphasis">not</em> have had <tt class="literal">ap_MD5Final</tt> run) and make a base 64 representation of it in the pool <tt class="literal">a</tt>.</p></div>

<a name="INDEX-1339" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_md5digest</i></b></font></td><td align="right"><i>make a base 64 MD5 digest of an open file</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_md5digest(pool *p, FILE *infile)</pre></td><td align="right" /></tr></table>Reads the file <tt class="literal">infile</tt> from its current position to the end, returning a base 64 MD5 digest allocated in the pool <tt class="literal">p</tt>. The file is rewound to the beginning after calculating the digest.</p></div>

<div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_MD5Init</i></b></font></td><td align="right"><i>initialize an MD5 digest</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_MD5Init(AP_MD5_CTX *context)</pre></td><td align="right" /></tr></table>Initializes <tt class="literal">context</tt>, in preparation for an MD5 digest.</p></div>

<a name="INDEX-1340" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_MD5Final</i></b></font></td><td align="right"><i>finalize an MD5 digest</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_MD5Final(unsigned char digest[16], AP_MD5_CTX *context)</pre></td><td align="right" /></tr></table>Finishes the MD5 operation, writing the digest to <tt class="literal">digest</tt> and zeroing <tt class="literal">context</tt>.</p></div>

<a name="INDEX-1341" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_MD5Update</i></b></font></td><td align="right"><i>add a block to an MD5 digest</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_MD5Update(AP_MD5_CTX * context, const unsigned char *input, unsigned int inputLen)
</pre></td><td align="right" /></tr></table>Processes <tt class="literal">inputLen</tt> bytes of <tt class="literal">input</tt>, adding them to the digest being calculated in <tt class="literal">context</tt>.</p></div>
</div>
















<a name="ch14-76-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.9. Synchronization and Thread Functions</h3>




<p>
<a name="INDEX-1342" />
<a name="INDEX-1343" />
<a name="INDEX-1344" />These functions hide operating system-dependent functions. On platforms that do not use threads for Apache, these functions exist but do not do anything; they simulate success if called.</p>




<p>Note that of these functions, only the mutex functions are actually implemented. The rest are documented for completeness (and in case they get implemented).</p>





<a name="ch14-77-fm2xml" /><div class="sect3">
<h3 class="sect3">14.6.9.1. Mutex Functions</h3>





<a name="INDEX-1345" /><a name="INDEX-1346" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_create_mutex</i></b></font></td><td align="right"><i>create a mutual exclusion object</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>mutex *ap_create_mutex(char *name)</pre></td><td align="right" /></tr></table>Creates a mutex object with the name <tt class="literal">name</tt>. Returns <tt class="literal">NULL</tt> if the operation fails.</p></div>

<a name="INDEX-1347" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_open_mutex</i></b></font></td><td align="right"><i>open a mutual exclusion object</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>mutex *ap_open_mutex(char *name)</pre></td><td align="right" /></tr></table>Opens an existing mutex with the <tt class="literal">name</tt> name. Returns <tt class="literal">NULL</tt> if the operation fails.</p></div>

<a name="INDEX-1348" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_acquire_mutex</i></b></font></td><td align="right"><i>lock an open mutex object</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_acquire_mutex(mutex *mutex_id)</pre></td><td align="right" /></tr></table>Locks the open mutex <tt class="literal">mutex_id</tt>. Blocks until the lock is available. Returns <tt class="literal">MULTI_OK</tt> or <tt class="literal">MULTI_ERR</tt>.</p></div>

<a name="INDEX-1349" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_release_mutex</i></b></font></td><td align="right"><i>release a locked mutex</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_release_mutex(mutex *mutex_id)</pre></td><td align="right" /></tr></table>Unlocks the open mutex <tt class="literal">mutex_id</tt>. Blocks until the lock is available. Returns <tt class="literal">MULTI_OK</tt> or <tt class="literal">MULTI_ERR</tt>.</p></div>

<a name="INDEX-1350" /><a name="INDEX-1351" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_destroy_mutex</i></b></font></td><td align="right"><i>destroy an open mutex</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_destroy_mutex(mutex *mutex_id);</pre></td><td align="right" /></tr></table>Destroys the mutex <tt class="literal">mutex_id</tt>.</p></div>
</div>









<a name="ch14-83-fm2xml" /><div class="sect3">
<h3 class="sect3">14.6.9.2. Semaphore Functions</h3>





<a name="INDEX-1352" /><a name="INDEX-1353" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>create_semaphore</i></b></font></td><td align="right"><i>create a semaphore</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>semaphore *create_semaphore(int initial)</pre></td><td align="right" /></tr></table>Creates a semaphore with an initial value of <tt class="literal">initial</tt>.</p></div>

<div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>acquire_semaphore</i></b></font></td><td align="right"><i>acquire a semaphore</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int acquire_semaphore(semaphore *semaphore_id)</pre></td><td align="right" /></tr></table>Acquires the semaphore <tt class="literal">semaphore_id</tt>. Blocks until it is available. Returns <tt class="literal">MULTI_OK</tt> or <tt class="literal">MULTI_ERR.</tt></p></div>

<a name="INDEX-1354" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>release_semaphore</i></b></font></td><td align="right"><i>release a semaphore</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int release_semaphore(semaphore *semaphore_id)</pre></td><td align="right" /></tr></table>Releases the semaphore <tt class="literal">semaphore_id</tt>. Returns <tt class="literal">MULTI_OK</tt> or <tt class="literal">MULTI_ERR</tt>.</p></div>

<a name="INDEX-1355" /><a name="INDEX-1356" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>destroy_semaphore</i></b></font></td><td align="right"><i>destroy an open semaphore</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void destroy_semaphore(semaphore *semaphore_id)</pre></td><td align="right" /></tr></table>Destroys the semaphore <tt class="literal">semaphore_id</tt>.</p></div>
</div>









<a name="ch14-88-fm2xml" /><div class="sect3">
<h3 class="sect3">14.6.9.3. Event Functions</h3>






<a name="INDEX-1357" /><a name="INDEX-1358" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>create_event</i></b></font></td><td align="right"><i>create an event</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>event *create_event(int manual, int initial, char *name)</pre></td><td align="right" /></tr></table>Creates an event named <tt class="literal">name</tt>, with an initial state of <tt class="literal">initial</tt>. If <tt class="literal">manual</tt> is true, the event must be reset manually. If not, setting the event immediately resets it. Returns <tt class="literal">NULL</tt> on failure.</p></div>

<a name="INDEX-1359" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>open_event</i></b></font></td><td align="right"><i>open an existing event</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>event *open_event(char *name)</pre></td><td align="right" /></tr></table>Opens an existing event named <tt class="literal">name</tt>. Returns <tt class="literal">NULL</tt> on failure.</p></div>

<a name="INDEX-1360" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>acquire_event</i></b></font></td><td align="right"><i>wait for an event to be signaled</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int acquire_event(event *event_id)</pre></td><td align="right" /></tr></table>Waits for the event <tt class="literal">event_id</tt> to be signaled. Returns <tt class="literal">MULTI_OK</tt> or <tt class="literal">MULTI_ERR</tt>.</p></div>

<a name="INDEX-1361" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>set_event</i></b></font></td><td align="right"><i>signal an event</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int set_event(event *event_id)</pre></td><td align="right" /></tr></table>Signals the event <tt class="literal">event_id</tt>. Returns <tt class="literal">MULTI_OK</tt> or <tt class="literal">MULTI_ERR</tt>.</p></div>

<a name="INDEX-1362" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>reset_event</i></b></font></td><td align="right"><i>clear an event</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int reset_event(event *event_id)</pre></td><td align="right" /></tr></table>Clears the event <tt class="literal">event_id</tt>. Returns <tt class="literal">MULTI_OK</tt> or <tt class="literal">MULTI_ERR</tt>.</p></div>

<a name="INDEX-1363" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>destroy_event</i></b></font></td><td align="right"><i>destroy an open event</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void destroy_event(event *event_id)</pre></td><td align="right" /></tr></table>Destroys the event <tt class="literal">event_id </tt>.</p></div>
</div>









<a name="ch14-95-fm2xml" /><div class="sect3">
<h3 class="sect3">14.6.9.4. Thread Functions</h3>





<a name="INDEX-1364" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>create_thread</i></b></font></td><td align="right"><i>create a thread</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>thread *create_thread(void (thread_fn) (void *thread_arg), void *thread_arg)
</pre></td><td align="right" /></tr></table>Creates a thread, calling <tt class="literal">thread_fn</tt> with the argument <tt class="literal">thread_arg</tt> in the newly created thread. Returns <tt class="literal">NULL</tt> on failure.</p></div>

<a name="INDEX-1365" /><a name="INDEX-1366" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>kill_thread</i></b></font></td><td align="right"><i>kill a thread</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int kill_thread(thread *thread_id)</pre></td><td align="right" /></tr></table>Kills the thread <tt class="literal">thread_id</tt>. Since this may leave a thread's resources in an unknown state, it should only be used with caution.</p></div>

<a name="INDEX-1367" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>await_thread</i></b></font></td><td align="right"><i>wait for a thread to complete</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int await_thread(thread *thread_id, int sec_to_wait)</pre></td><td align="right" /></tr></table>Waits for the thread <tt class="literal">thread_id</tt> to complete, or for <tt class="literal">sec_to_wait</tt> seconds to pass, whichever comes first. Returns <tt class="literal">MULTI_OK</tt>, <tt class="literal">MULTI_TIMEOUT</tt>, or <tt class="literal">MULTI_ERR</tt>.</p></div>

<a name="INDEX-1368" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>exit_thread</i></b></font></td><td align="right"><i>exit the current thread</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void exit_thread(int status)</pre></td><td align="right" /></tr></table>Exits the current thread, returning <tt class="literal">status</tt> as the thread's status.</p></div>

<a name="INDEX-1369" /><a name="INDEX-1370" /><a name="INDEX-1371" /><a name="INDEX-1372" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>free_thread</i></b></font></td><td align="right"><i>free a thread's resources</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void free_thread(thread *thread_id)</pre></td><td align="right" /></tr></table>Frees the resources associated with the thread <tt class="literal">thread_id</tt>. Should only be done after the thread has terminated.<a name="INDEX-1370" />
<a name="INDEX-1371" />
<a name="INDEX-1372" /></p></div>
</div>
</div>
















<a name="ch14-101-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.10. Time and Date Functions</h3>





<a name="INDEX-1373" /><a name="INDEX-1374" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_time</i></b></font></td><td align="right"><i>return a human-readable version of the current time</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_get_time(void)</pre></td><td align="right" /></tr></table>Uses <tt class="literal">ctime</tt> to format the current time and removes the trailing newline. Returns a pointer to a string containing the time.</p></div>

<a name="INDEX-1375" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_ht_time</i></b></font></td><td align="right"><i>return a pool-allocated string describing a time</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_ht_time(pool *p, time_t t, const char *fmt, int gmt)</pre></td><td align="right" /></tr></table>Formats the time using <tt class="literal">strftime</tt> and returns a pool-allocated copy of it. If <tt class="literal">gmt</tt> is nonzero, the time is formatted as GMT; otherwise, it is formatted as local time. Returns a pointer to the string containing the time.</p></div>

<a name="INDEX-1376" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_gm_timestr_822</i></b></font></td><td align="right"><i>format a time according to RFC 822</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_gm_timestr_822(pool *p, time_t t)</pre></td><td align="right" /></tr></table>Formats the time as specified by RFC 822 (<em class="emphasis">Standard for the Format of ARPA Internet Text Messages</em>
<a href="#FOOTNOTE-72">[72]</a> ). The time is always formatted as GMT. Returns a pointer to the string containing the time.</p><blockquote>




<a name="FOOTNOTE-72" /><p>[72]Or, in other words, <em class="emphasis">mail</em>. Since HTTP has elements borrowed from MIME, and MIME is for <em class="emphasis">mail</em>, you can see the connection.</p>




</blockquote></div>

<a name="INDEX-1377" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_gmtoff</i></b></font></td><td align="right"><i>get the time and calculate the local time zone offset from GMT</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>struct tm *ap_get_gmtoff(long *tz)</pre></td><td align="right" /></tr></table>Returns the current local time, and <tt class="literal">tz</tt> is filled in with the offset of the local time zone from GMT, in seconds.</p></div>

<a name="INDEX-1378" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_tm2sec</i></b></font></td><td align="right"><i>convert a struct tm to standard Unix time</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>time_t ap_tm2sec(const struct tm *t)</pre></td><td align="right" /></tr></table>Returns the time in <tt class="literal">t</tt> as the time in seconds since 1 Jan 1970 00:00 GMT. <tt class="literal">t</tt> is assumed to be in GMT.</p></div>

<a name="INDEX-1379" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_parseHTTPdate</i></b></font></td><td align="right"><i>convert an HTTP date to Unix time</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>time_t ap_parseHTTPdate(const char *date)</pre></td><td align="right" /></tr></table>Parses a date in one of three formats, returning the time in seconds since 1 Jan 1970 00:00 GMT. The three formats are as follows:</p><ul><li><p>Sun, 06 Nov 1994 08:49:37 GMT (RFC 822, updated by RFC 1123)</p></li><li><p>Sunday, 06-Nov-94 08:49:37 GMT (RFC 850, made obsolete by RFC 1036)</p></li><li><p>Sun Nov 6 08:49:37 1994 (ANSI C <tt class="literal">asctime()</tt> format)</p></li></ul><p>Note that since HTTP requires dates to be in GMT, this routine ignores the timezone field.</p></div>
</div>
















<a name="ch14-108-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.11. String Functions</h3>





<a name="INDEX-1380" /><a name="INDEX-1381" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_strcmp_match</i></b></font></td><td align="right"><i>wildcard match two strings</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_strcmp_match(const char *str, const char *exp)</pre></td><td align="right" /></tr></table>Matches <tt class="literal">str</tt> to <tt class="literal">exp</tt>, except that * and ? can be used in <tt class="literal">exp</tt> to mean "any number of characters" and "any character," respectively. You should probably use the newer and more powerful regular expressions for new code. Returns <tt class="literal">1</tt> for success, <tt class="literal">0</tt> for failure, and <tt class="literal">-1</tt> for abort.</p></div>

<a name="INDEX-1382" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_strcasecmp_match</i></b></font></td><td align="right"><i>case-blind wildcard match two strings</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_strcasecmp_match(const char *str, const char *exp)</pre></td><td align="right" /></tr></table>Similar to <tt class="literal">strcmp_match</tt>, except matching is case blind.</p></div>

<a name="INDEX-1383" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_is_matchexp</i></b></font></td><td align="right"><i>does a string contain wildcards?</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_is_matchexp(const char *exp)</pre></td><td align="right" /></tr></table>Returns <tt class="literal">1</tt> if <tt class="literal">exp</tt> contains <tt class="literal">*</tt> or <tt class="literal">?</tt>; <tt class="literal">0</tt> otherwise.</p></div>

<a name="INDEX-1384" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_getword</i></b></font></td><td align="right"><i>extract one word from a list of words</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_getword(pool *p, const char **line, char stop)
char *ap_getword_nc(pool *p, char **line, char stop)</pre></td><td align="right" /></tr></table>Looks for the first occurrence of <tt class="literal">stop</tt> in <tt class="literal">*line</tt> and copies everything before it to a new buffer, which it returns. If <tt class="literal">*line</tt> contains no <tt class="literal">stop</tt>s, the whole of <tt class="literal">*line</tt> is copied. <tt class="literal">*line</tt> is updated to point after the occurrence of <tt class="literal">stop</tt>, skipping multiple instances of <tt class="literal">stop</tt> if present. <tt class="literal">ap_getword_nc()</tt> is a version of <tt class="literal">ap_getword()</tt> that takes a nonconstant pointer. This is because some C compilers complain if a <tt class="literal">char **</tt> is passed to a function expecting a <tt class="literal">const char **</tt>.</p></div>

<a name="INDEX-1385" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_getword_white</i></b></font></td><td align="right"><i>extract one word from a list of words</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_getword_white(pool *p, const char **line)
char *ap_getword_white_nc(pool *p, char **line)</pre></td><td align="right" /></tr></table>Works like <tt class="literal">ap_getword()</tt>, except the words are separated by whitespace (as determined by <tt class="literal">isspace</tt>).</p></div>

<a name="INDEX-1386" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_getword_nulls</i></b></font></td><td align="right"><i>extract one word from a list of words</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_getword_nulls(pool *p, const char **line, char stop)
char *ap_getword_nulls_nc(pool *p, char **line, char stop)</pre></td><td align="right" /></tr></table>Works like <tt class="literal">ap_getword()</tt>, except that multiple occurrences of <tt class="literal">stop</tt> are not skipped, so null entries are correctly processed.</p></div>

<a name="INDEX-1387" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_getword_conf</i></b></font></td><td align="right"><i>extract one word from a list of words</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_getword_conf(pool *p, const char **line)
char *ap_getword_conf_nc(pool *p, char **line)</pre></td><td align="right" /></tr></table>Works like <tt class="literal">ap_getword()</tt>, except that words can be separated by whitespace and can use quotes and backslashes to escape characters. The quotes and backslashes are stripped.</p></div>

<a name="INDEX-1388" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_token</i></b></font></td><td align="right"><i>extract a token from a string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_get_token(pool *p, const char **line, int accept_white)</pre></td><td align="right" /></tr></table>Extracts a token from <tt class="literal">*line</tt>, skipping leading whitespace. The token is delimited by a comma or a semicolon. If <tt class="literal">accept_white</tt> is zero, it can also be delimited by whitespace. The token can also include delimiters if they are enclosed in double quotes, which are stripped in the result. Returns a pointer to the extracted token, which has been allocated in the pool <tt class="literal">p</tt>.</p></div>

<a name="INDEX-1389" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_find_token</i></b></font></td><td align="right"><i>look for a token in a line (usually an HTTP header)</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_find_token(pool *p, const char *line, const char *tok)</pre></td><td align="right" /></tr></table>Looks for <tt class="literal">tok</tt> in
<tt class="literal">line</tt>. Returns nonzero if found. The token must
exactly match (case blind) and is delimited by control characters
(determined by <tt class="literal">iscntrl</tt>), tabs, spaces, or one of
these characters:</p><blockquote><pre class="code">()&lt;&gt;@,;\\/[]?={}</pre></blockquote><p>This corresponds to the definition of a token in RFC 2068.</p></div>

<a name="INDEX-1390" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_find_last_token</i></b></font></td><td align="right"><i>check if the last token is a particular string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_find_last_token(pool *p, const char *line, const char *tok)</pre></td><td align="right" /></tr></table>Checks whether the end of <tt class="literal">line</tt> matches
<tt class="literal">tok</tt>, and <tt class="literal">tok</tt> is preceded by a
space or a comma. Returns <tt class="literal">1</tt> if so,
<tt class="literal">0</tt> otherwise.</p></div>

<a name="INDEX-1391" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_escape_shell_cmd</i></b></font></td><td align="right"><i>escape dangerous characters in a shell command</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_escape_shell_cmd(pool *p, const char *s)</pre></td><td align="right" /></tr></table>Prefixes dangerous characters in <tt class="literal">s</tt> with a backslash, returning the new version. The current set of dangerous characters is as follows:</p><blockquote><pre class="code">&amp;;`'\"|*?~&lt;&gt;^()[]{}$\\\n</pre></blockquote><p>Under OS/2, <tt class="literal">&amp;</tt> is converted to a space.<a href="#FOOTNOTE-73">[73]</a></p><blockquote>




<a name="FOOTNOTE-73" /><p>[73]Don't think that using this function makes shell scripts safe: it doesn't. See <a href="ch13_01.htm">Chapter 13, "Security"</a>.</p>




</blockquote></div>

<a name="INDEX-1392" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_uudecode</i></b></font></td><td align="right"><i>uudecode a block of characters</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_uudecode(pool *p, const char *coded)</pre></td><td align="right" /></tr></table>Returns a decoded version of <tt class="literal">coded</tt> allocated in <tt class="literal">p</tt>.</p></div>

<a name="INDEX-1393" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_escape_html</i></b></font></td><td align="right"><i>escape some HTML</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_escape_html(pool *p, const char *s)</pre></td><td align="right" /></tr></table>Escapes HTML so that the characters <tt class="literal">&lt;</tt>, <tt class="literal">&gt;</tt>, and <tt class="literal">&amp;</tt> are displayed correctly. Returns a pointer to the escaped HTML.</p></div>

<a name="INDEX-1394" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_checkmask</i></b></font></td><td align="right"><i>check whether a string matches a mask</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_checkmask(const char *data, const char *mask)</pre></td><td align="right" /></tr></table>Checks whether data conforms to the mask in <tt class="literal">mask</tt>. <tt class="literal">mask</tt> is composed of the following characters:</p><dl>
<dt><b><tt class="literal">@</tt></b></dt>
<dd><p>An uppercase letter</p></dd>





<dt><b><tt class="literal">$</tt></b></dt>
<dd><p>A lowercase letter</p></dd>





<dt><b><tt class="literal">&amp;</tt></b></dt>
<dd><p>A hexadecimal digit</p></dd>





<dt><b><tt class="literal">#</tt></b></dt>
<dd><p>A decimal digit</p></dd>





<dt><b><tt class="literal">~</tt></b></dt>
<dd><p>A decimal digit or a space</p></dd>





<dt><b><tt class="literal">*</tt></b></dt>
<dd><p>Any number of any character</p></dd>






<dt><b><em class="emphasis">Anything else</em></b></dt>
<dd><p>Itself</p></dd>

</dl><p><tt class="literal">data</tt> is arbitrarily limited to 256 characters. Returns <tt class="literal">1</tt> for a match, <tt class="literal">0</tt> if not. For example, the following code checks for RFC 1123 date format:</p><blockquote><pre class="code">if(ap_checkmask(date, "## @$$ #### ##:##:## *"))
    ...</pre></blockquote></div>

<a name="INDEX-1395" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_str_tolower</i></b></font></td><td align="right"><i>convert a string to lowercase</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_str_tolower(char *str)</pre></td><td align="right" /></tr></table>Converts <tt class="literal">str</tt> to lowercase, in place.</p></div>

<a name="INDEX-1396" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_psprintf</i></b></font></td><td align="right"><i>format a string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_psprintf(pool *p, const char *fmt, ...)</pre></td><td align="right" /></tr></table>Much the same as the standard function <tt class="literal">sprintf()</tt> except that no buffer is supplied; instead, the new string is allocated in <tt class="literal">p</tt>. This makes this function completely immune from buffer overflow. Also see <tt class="literal">ap_vformatter()</tt>.</p></div>

<a name="INDEX-1397" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pvsprintf</i></b></font></td><td align="right"><i>format a string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_pvsprintf(pool *p, const char *fmt, va_list ap)</pre></td><td align="right" /></tr></table>Similar to <tt class="literal">ap_psprintf()</tt>, except that varargs are used.</p></div>

<a name="INDEX-1398" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_ind</i></b></font></td><td align="right"><i>find the first index of a character in a string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_ind(const char *s, char c)</pre></td><td align="right" /></tr></table>Returns the offset of the first occurrence of <tt class="literal">c</tt> in <tt class="literal">s</tt>, or <tt class="literal">-1</tt> if <tt class="literal">c</tt> is not in <tt class="literal">s</tt>.</p></div>

<a name="INDEX-1399" /><a name="INDEX-1400" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_rind</i></b></font></td><td align="right"><i>find the last index of a character in a string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_rind(const char *s, char c)</pre></td><td align="right" /></tr></table>Returns the offset of the last occurrence of <tt class="literal">c</tt> in <tt class="literal">s</tt>, or <tt class="literal">-1</tt> if <tt class="literal">c</tt> is not in <tt class="literal">s</tt>.<a name="INDEX-1400" /></p></div>
</div>
















<a name="ch14-128-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.12. Path, Filename, and URL Manipulation Functions</h3>





<a name="INDEX-1401" /><a name="INDEX-1402" /><a name="INDEX-1403" /><a name="INDEX-1404" /><a name="INDEX-1405" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_getparents</i></b></font></td><td align="right"><i>remove "." and  ".." segments from a path</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_getparents(char *name)</pre></td><td align="right" /></tr></table>Removes ".." and "." segments from a path, as specified in RFC 1808 (<em class="emphasis">Relative Uniform Resource Locators</em>). This is important not only for security but also to allow correct matching of URLs. Note that Apache should never be presented with a path containing such things, but it should behave correctly when it is.</p></div>

<a name="INDEX-1406" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_no2slash</i></b></font></td><td align="right"><i>remove "//" from a path</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_no2slash(char *name)</pre></td><td align="right" /></tr></table>Removes double slashes from a path. This is important for correct matching of URLs.</p></div>

<a name="INDEX-1407" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_make_dirstr</i></b></font></td><td align="right"><i>make a copy of a path with a trailing slash, if needed</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_make_dirstr(pool *p, const char *path, int n)</pre></td><td align="right" /></tr></table>Makes a copy of <tt class="literal">path</tt> guaranteed to end with a slash. It will truncate the path at the <tt class="literal">n</tt>th slash. Returns a pointer to the copy, which was allocated in the pool <tt class="literal">p</tt>.</p></div>

<a name="INDEX-1408" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_make_dirstr_parent</i></b></font></td><td align="right"><i>make the path of the parent directory</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char * ap_make_dirstr_parent(pool *p, const char *s)</pre></td><td align="right" /></tr></table>Make a new string in <tt class="literal">p</tt> with the path of <tt class="literal">s</tt>'s parent directory, with a trailing slash.</p></div>

<a name="INDEX-1409" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_make_dirstr_prefix</i></b></font></td><td align="right"><i>copy part of a path</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_make_dirstr_prefix(char *d, const char *s, int n)</pre></td><td align="right" /></tr></table>Copy the first <tt class="literal">n</tt> path elements from <tt class="literal">s</tt> to <tt class="literal">d</tt>, or the whole of <tt class="literal">s</tt> if there are less than <tt class="literal">n</tt> path elements. Note that a leading slash counts as a path element.</p></div>

<a name="INDEX-1410" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_count_dirs</i></b></font></td><td align="right"><i>count the number of slashes in a path</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_count_dirs(const char *path)</pre></td><td align="right" /></tr></table>Returns the number of slashes in a path.</p></div>

<a name="INDEX-1411" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_chdir_file</i></b></font></td><td align="right"><i>change to the directory containing file</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_chdir_file(const char *file)</pre></td><td align="right" /></tr></table>Performs a <tt class="literal">chdir()</tt> to the directory containing <tt class="literal">file</tt>. This is done by finding the last slash in the file and changing to the directory preceding it. If there are no slashes in the file, it attempts a <tt class="literal">chdir</tt> to the whole of <tt class="literal">file</tt>. It does not check that the directory is valid, nor that the <tt class="literal">chdir</tt> succeeds.</p></div>

<a name="INDEX-1412" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_unescape_url</i></b></font></td><td align="right"><i>remove escape sequences from a URL</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_unescape_url(char *url)</pre></td><td align="right" /></tr></table>Converts escape sequences (<tt class="literal">%xx</tt>) in a URL back to the original character. The conversion is done in place. Returns <tt class="literal">0</tt> if successful, <tt class="literal">BAD_REQUEST</tt> if a bad escape sequence is found, and <tt class="literal">NOT_FOUND</tt> if <tt class="literal">%2f</tt> (which converts to "/" ) or <tt class="literal">%00</tt> is found.</p></div>

<a name="INDEX-1413" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_construct_server</i></b></font></td><td align="right"><i>make the server part of a URL</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_construct_server(pool *p, const char *hostname, int port, request_rec *r)</pre></td><td align="right" /></tr></table>Makes the server part of a URL by appending <tt class="literal">:&lt;port&gt;</tt> to <tt class="literal">hostname</tt> if <tt class="literal">port</tt> is not the default port for the scheme used to make the request.</p></div>

<a name="INDEX-1414" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_construct_url</i></b></font></td><td align="right"><i>make an HTTP URL</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_construct_url(pool *p, const char *uri, const request_rec *r)</pre></td><td align="right" /></tr></table>Makes a URL by prefixing the scheme used by <tt class="literal">r</tt> to the server name and port extracted from <tt class="literal">r</tt>, and appending <tt class="literal">uri</tt>. Returns a pointer to the URL.</p></div>

<a name="INDEX-1415" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_escape_path_segment</i></b></font></td><td align="right"><i>escape a path segment as per RFC 1808</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_escape_path_segment(pool *p, const char *segment)</pre></td><td align="right" /></tr></table>Returns an escaped version of <tt class="literal">segment</tt>, as per RFC 1808.</p></div>

<a name="INDEX-1416" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_os_escape_path</i></b></font></td><td align="right"><i>escape a path as per RFC 1808</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_os_escape_path(pool *p, const char *path, int partial)</pre></td><td align="right" /></tr></table>Returns an escaped version of <tt class="literal">path</tt>, per RFC 1808. If <tt class="literal">partial</tt> is nonzero, the path is assumed to be a trailing partial path (so that a "./" is not used to hide a ":").</p></div>

<a name="INDEX-1417" /><a name="INDEX-1418" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_is_directory</i></b></font></td><td align="right"><i>checks whether a path refers to a directory</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_is_directory(const char *path)</pre></td><td align="right" /></tr></table>Returns nonzero if <tt class="literal">path</tt> is a directory.</p></div>

<a name="INDEX-1419" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_make_full_path</i></b></font></td><td align="right"><i>combines two paths into one</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_make_full_path(pool *p, const char *path1, const char *path2)</pre></td><td align="right" /></tr></table>Appends <tt class="literal">path2</tt> to <tt class="literal">path1</tt>, ensuring that there is only one slash between them. Returns a pointer to the new path.</p></div>

<a name="INDEX-1420" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_is_url</i></b></font></td><td align="right"><i>checks whether a string is in fact a URL</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_is_url(const char *url)</pre></td><td align="right" /></tr></table>Returns nonzero if <tt class="literal">url</tt> is a URL. A URL is defined, for this purpose, to be "&lt;any string of numbers, letters, +, -, or . (dot)&gt;:&lt;anything&gt;."</p></div>

<a name="INDEX-1421" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_fnmatch</i></b></font></td><td align="right"><i>match a filename</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_fnmatch(const char *pattern, const char *string, int flags)</pre></td><td align="right" /></tr></table>Matches <tt class="literal">string</tt> against <tt class="literal">pattern</tt>, returning <tt class="literal">0</tt> for a match and <tt class="literal">FNM_NOMATCH</tt> otherwise. <tt class="literal">pattern</tt> consists of the following:</p><dl>
<dt><b><tt class="literal">?</tt></b></dt>
<dd><p>Match a single character.</p></dd>





<dt><b><tt class="literal">*</tt></b></dt>
<dd><p>Match any number of characters.</p></dd>






<dt><b><tt class="literal">[...]</tt></b></dt>
<dd><p>A closure, like in regular expressions. A leading caret
(<tt class="literal">^</tt>) inverts the closure.</p></dd>





<dt><b><tt class="literal">\</tt></b></dt>
<dd><p>If <tt class="literal">FNM_NOESCAPE</tt> is not set, removes any special
meaning from next character.</p></dd>

</dl><p><tt class="literal">flags</tt> is a combination of the following:</p><dl>
<dt><b><tt class="literal">FNM_NOESCAPE</tt></b></dt>
<dd><p>Treat a "<tt class="literal">\</tt>"<tt class="literal"> </tt>as a
normal character.</p></dd>





<dt><b><tt class="literal">FNM_PATHNAME</tt></b></dt>
<dd><p><tt class="literal">*</tt>, <tt class="literal">?</tt>, and
<tt class="literal">[...]</tt> don't match<tt class="literal">
</tt>"<tt class="literal">/</tt>.".</p></dd>





<dt><b><tt class="literal">FNM_PERIOD</tt></b></dt>
<dd><p><tt class="literal">*</tt>, <tt class="literal">?</tt>, and
<tt class="literal">[...]</tt> don't match leading dots.
"Leading" means either at the beginning of the string, or
after a "<tt class="literal">/</tt>" if
<tt class="literal">FNM_PATHNAME</tt> is set.</p></dd>

</dl></div>

<a name="INDEX-1422" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_is_fnmatch</i></b></font></td><td align="right"><i>check whether a string is a pattern</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_is_fnmatch(const char *pattern)</pre></td><td align="right" /></tr></table>Returns <tt class="literal">1</tt> if <tt class="literal">pattern</tt> contains <tt class="literal">?</tt>, <tt class="literal">*</tt>, or<tt class="literal"> [...]</tt>, <tt class="literal">0</tt> otherwise.</p></div>

<a name="INDEX-1423" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_server_root_relative</i></b></font></td><td align="right"><i>make a path relative to the server root</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_server_root_relative(pool *p, char *file)</pre></td><td align="right" /></tr></table>If <tt class="literal">file</tt> is not an absolute path, append it to the <tt class="literal">server</tt> <tt class="literal">root</tt>, in the pool <tt class="literal">p</tt>. If it is absolute, simply return it (<em class="emphasis">not</em> a copy).</p></div>

<a name="INDEX-1424" /><a name="INDEX-1425" /><a name="INDEX-1426" /><a name="INDEX-1427" /><a name="INDEX-1428" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_os_canonical_filename</i></b></font></td><td align="right"><i>convert a filename to its canonical form</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_os_canonical_filename(pool *pPool, const char *szFile)</pre></td><td align="right" /></tr></table>Returns a canonical form of a filename. This is needed because some operating systems will accept more than one string for the same file.</p><p><img src="figs/win32_icon.gif" alt="Figure 14.19" />   Win32, for example, is case blind, ignores trailing dots and spaces, and so on.<a href="#FOOTNOTE-74">[74]</a> This function is generally used before checking a filename against a pattern or other similar operations.<a name="INDEX-1425" />
<a name="INDEX-1426" />
<a name="INDEX-1427" />
<a name="INDEX-1428" /></p><blockquote>




<a name="FOOTNOTE-74" /><p>[74]In fact, exactly what Windows does with filenames is very poorly documented and is a seemingly endless source of security holes.</p>




</blockquote></div>
</div>
















<a name="ch14-148-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.13. User and Group Functions</h3>





<a name="INDEX-1429" /><a name="INDEX-1430" /><a name="INDEX-1431" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_uname2id</i></b></font></td><td align="right"><i>convert a username to a user ID (UID)</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>uid_t ap_uname2id(const char *name)</pre></td><td align="right" /></tr></table><img src="figs/win32_icon.gif" alt="Figure 14.1" />   If <tt class="literal">name</tt> starts with a "#", returns the number following it; otherwise, looks it up using <tt class="literal">getpwnam()</tt> and returns the UID. Under Win32, this function always returns <tt class="literal">1</tt>.</p></div>

<a name="INDEX-1432" /><a name="INDEX-1433" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_gname2id</i></b></font></td><td align="right"><i>convert a group name to a group ID (GID)</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>gid_t ap_gname2id(const char *name)</pre></td><td align="right" /></tr></table><img src="figs/win32_icon.gif" alt="Figure 14.2" />   If <tt class="literal">name</tt> starts with a "#", returns the number following it; otherwise, looks it up using <tt class="literal">getgrnam()</tt> and returns the GID. Under Win32, this function always returns <tt class="literal">1</tt>.</p></div>
</div>
















<a name="ch14-151-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.14. TCP/IP and I/O Functions</h3>





<a name="INDEX-1434" /><a name="INDEX-1435" /><a name="INDEX-1436" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_virthost_addr</i></b></font></td><td align="right"><i>convert a hostname or port to an address</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>unsigned long ap_get_virthost_addr(const char *hostname, short *ports)</pre></td><td align="right" /></tr></table>Converts a hostname of the form <em class="replaceable">name</em><tt class="literal">[:</tt><em class="replaceable">port</em><tt class="literal">]</tt> to an IP address in network order, which it returns. <tt class="literal">*ports</tt> is filled in with the port number if it is not <tt class="literal">NULL</tt>. If <em class="replaceable">name</em> is missing or "*", <tt class="literal">INADDR_ANY</tt> is returned. If <em class="replaceable">port</em> is missing or "*", <tt class="literal">*ports</tt> is set to <tt class="literal">0</tt>.</p><p>If the host has multiple IP addresses, an error message is printed and <tt class="literal">exit()</tt> is called.</p></div>

<a name="INDEX-1437" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_local_host</i></b></font></td><td align="right"><i>get the FQDN for the local host</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_get_local_host(pool *p)</pre></td><td align="right" /></tr></table>Returns a pointer to the fully qualified domain name for the local host. If it fails, an error message is printed, and <tt class="literal">exit()</tt> is called.</p></div>

<a name="INDEX-1438" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_remote_host</i></b></font></td><td align="right"><i>get client hostname or IP address</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_get_remote_host(conn_rec *conn, void *dir_config, int type)</pre></td><td align="right" /></tr></table>Returns the hostname or IP address (as a string) of the client. <tt class="literal">dir_config</tt> is the <tt class="literal">per_dir_config</tt> member of the current request or NULL. <tt class="literal">type</tt> is one of the following:</p><dl>
<dt><b><tt class="literal">REMOTE_HOST</tt></b></dt>
<dd><p>Returns the hostname or <tt class="literal">NULL</tt> (if it either
couldn't be found or hostname lookups are disabled with the
<tt class="literal">HostnameLookups</tt> directive).</p></dd>





<dt><b><tt class="literal">REMOTE_NAME</tt></b></dt>
<dd><p>Returns the hostname or, if it can't be found, returns the IP
address.</p></dd>





<dt><b><tt class="literal">REMOTE_NOLOOKUP</tt></b></dt>
<dd><p>Similar to <tt class="literal">REMOTE_NAME</tt>, except that a DNS lookup
is not performed (note that the name can still be returned if a
previous call did do a DNS lookup).</p></dd>





<dt><b><tt class="literal">REMOTE_DOUBLE_REV</tt></b></dt>
<dd><p>Do a double-reverse lookup (that is, look up the hostname from the IP
address, then look up the IP address from the name). If the double
reverse works and the IP addresses match, return the name; otherwise,
return a <tt class="literal">NULL</tt>.</p></dd>

</dl></div>

<a name="INDEX-1439" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_send_fd</i></b></font></td><td align="right"><i>copy an open file to the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>long ap_send_fd(FILE *f, request_rec *r)</pre></td><td align="right" /></tr></table>Copies the stream <tt class="literal">f</tt> to the client. Returns the number of bytes sent.</p></div>

<a name="INDEX-1440" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_send_fd_length</i></b></font></td><td align="right"><i>copy a number of bytes from an open file to the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>long ap_send_fd_length(FILE *f, request_rec *r, long length)</pre></td><td align="right" /></tr></table>Copies no more than <tt class="literal">length</tt> bytes from <tt class="literal">f</tt> to the client. If <tt class="literal">length</tt> is less than 0, copies the whole file. Returns the number of bytes sent.</p></div>

<a name="INDEX-1441" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_send_fb</i></b></font></td><td align="right"><i>copy an open stream to a client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>long ap_send_fb(BUFF *fb, request_rec *r)</pre></td><td align="right" /></tr></table>Similar to <tt class="literal">ap_send_fd()</tt> except that it sends a <tt class="literal">BUFF *</tt> instead of a <tt class="literal">FILE *</tt>.</p></div>

<a name="INDEX-1442" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_send_fb_length</i></b></font></td><td align="right"><i>copy a number of bytes from an open stream to a client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>long ap_send_fb_length(BUFF *fb, request_rec *r, long length)</pre></td><td align="right" /></tr></table>Similar to <tt class="literal">ap_send_fd_length()</tt>, except that it sends a <tt class="literal">BUFF *</tt> instead of a <tt class="literal">FILE *</tt>.</p></div>

<a name="INDEX-1443" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_send_mmap</i></b></font></td><td align="right"><i>send data from an in-memory buffer</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>size_t ap_send_mmap(void *mm, request_rec *r, size_t offset, size_t
length)
</pre></td><td align="right" /></tr></table>Copies <tt class="literal">length</tt> bytes from <tt class="literal">mm+offset</tt> to the client. The data is copied <tt class="literal">MMAP_SEGMENT_SIZE</tt> bytes at a time, with the timeout reset in between each one. Although this can be used for any memory buffer, it is really intended for use with memory mapped files (which may give performance advantages over other means of sending files on some platforms).</p></div>

<a name="INDEX-1444" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_rwrite</i></b></font></td><td align="right"><i>write a buffer to the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_rwrite(const void *buf, int nbyte, request_rec *r)</pre></td><td align="right" /></tr></table>Writes <tt class="literal">nbyte</tt> bytes from <tt class="literal">buf</tt> to the client. Returns the number of bytes written or <tt class="literal">-1</tt> on an error.</p></div>

<a name="INDEX-1445" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_rputc</i></b></font></td><td align="right"><i>send a character to the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_rputc(int c, request_rec *r)</pre></td><td align="right" /></tr></table>Sends the character <tt class="literal">c</tt> to the client. Returns <tt class="literal">c</tt>, or <tt class="literal">EOF</tt> if the connection has been closed.</p></div>

<a name="INDEX-1446" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_rputs</i></b></font></td><td align="right"><i>send a string to the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_rputs(const char *s, request_rec *r)</pre></td><td align="right" /></tr></table>Sends the string <tt class="literal">s</tt> to the client. Returns the number of bytes sent, or <tt class="literal">-1</tt> if there is an error.</p></div>

<a name="INDEX-1447" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_rvputs</i></b></font></td><td align="right"><i>send a list of strings to the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_rvputs(request_rec *r, ...)</pre></td><td align="right" /></tr></table>Sends the <tt class="literal">NULL</tt>-terminated list of strings to the client. Returns the number of bytes sent, or <tt class="literal">-1</tt> if there is an error.</p></div>

<a name="INDEX-1448" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_rprintf</i></b></font></td><td align="right"><i>send a formatted string to the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_rprintf(request_rec *r, const char *fmt,...)</pre></td><td align="right" /></tr></table>Formats the extra arguments according to <tt class="literal">fmt</tt> (as they would be formatted by <tt class="literal">printf()</tt>) and sends the resulting string to the client. Returns the number of bytes sent, or <tt class="literal">-1</tt> if there is an error.</p></div>

<a name="INDEX-1449" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_rflush</i></b></font></td><td align="right"><i>flush client output</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_rflush(request_rec *r)</pre></td><td align="right" /></tr></table>Causes any buffered data to be sent to the client. Returns <tt class="literal">0</tt> on success, <tt class="literal">-1</tt> on an error.</p></div>

<a name="INDEX-1450" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_setup_client_block</i></b></font></td><td align="right"><i>prepare to receive data from the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_setup_client_block(request_rec *r, int read_policy)</pre></td><td align="right" /></tr></table>Prepares to receive (or not receive, depending on <tt class="literal">read_policy</tt>) data from the client, typically because the client made a <tt class="literal">PUT</tt> or <tt class="literal">POST</tt> request. Checks that all is well to do the receive. Returns <tt class="literal">OK</tt> if all is well, or a status code if not. Note that this routine still returns <tt class="literal">OK</tt> if the request is not one that includes data from the client. This should be called before <tt class="literal">ap_should_client_block()</tt>.</p><p><tt class="literal">read_policy</tt> is one of the following:</p><dl>
<dt><b><tt class="literal">REQUEST_NO_BODY</tt></b></dt>
<dd><p>Return <tt class="literal">HTTP_REQUEST_ENTITY_TOO_LARGE</tt> if the
request has any body.</p></dd>





<dt><b><tt class="literal">REQUEST_CHUNKED_ERROR</tt></b></dt>
<dd><p>If the <tt class="literal">Transfer-Encoding</tt> is chunked, return
<tt class="literal">HTTP_BAD_REQUEST</tt> if there is a
<tt class="literal">Content-Length</tt> header, or
<tt class="literal">HTTP_LENGTH_REQUIRED</tt> if not.<a href="#FOOTNOTE-75">[75]</a></p><blockquote>




<a name="FOOTNOTE-75" /><p>[75]This
may seem perverse, but the idea is that by asking for a
<tt class="literal">Content-Length</tt>, we are implicitly requesting that
there is no <tt class="literal">Transfer-Encoding</tt> (at least, not a
chunked one). Getting both is an error.</p>




</blockquote></dd>





<dt><b><tt class="literal">REQUEST_CHUNKED_DECHUNK</tt></b></dt>
<dd><p>Handles chunked encoding in <tt class="literal">ap_
get_client_block()</tt>, returning just the data.</p></dd>





<dt><b><tt class="literal">REQUEST_CHUNKED_PASS</tt></b></dt>
<dd><p>Handles chunked encoding in <tt class="literal">ap_
get_client_block()</tt>, returning the data and the chunk
headers.</p></dd>

</dl></div>

<a name="INDEX-1451" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_should_client_block</i></b></font></td><td align="right"><i>ready to receive data from the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_should_client_block(request_rec *r)</pre></td><td align="right" /></tr></table>Checks whether the client will send data and invites it to continue, if necessary (by sending a <tt class="literal">100</tt> <tt class="literal">Continue</tt> response if the client is HTTP/1.1 or higher). Returns <tt class="literal">1</tt> if the client should send data; <tt class="literal">0</tt> if not. <tt class="literal">ap_setup_client_block()</tt> should be called before this function, and this function should be called before <tt class="literal">ap_get_client_block()</tt>. This function should only be called once. It should also not be called until we are ready to receive data from the client.</p></div>

<a name="INDEX-1452" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_client_block</i></b></font></td><td align="right"><i>read a block of data from the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>long ap_get_client_block(request_rec *r, char *buffer, int bufsiz)</pre></td><td align="right" /></tr></table>Reads up to <tt class="literal">bufsiz</tt> characters into buffer from the client. Returns the number of bytes read, <tt class="literal">0</tt> if there is no more data, or <tt class="literal">-1</tt> if an error occurs. <tt class="literal">ap_setup_client_block()</tt> and <tt class="literal">ap_should_client_block()</tt> should be called before this. Note that the buffer should be at least big enough to hold a chunk-size header line (because it may be used to store one temporarily). Since a chunk-size header line is simply a number in hex, 50 bytes should be plenty.</p></div>

<a name="INDEX-1453" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_send_http_header</i></b></font></td><td align="right"><i>send the response headers to the client</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_send_http_header(request_rec *r)</pre></td><td align="right" /></tr></table>Sends the headers (mostly from <tt class="literal">r-&gt;headers_out</tt>) to the client. It is essential to call this in a request handler before sending the content.</p></div>

<a name="INDEX-1454" /><a name="INDEX-1455" /><a name="INDEX-1456" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_send_size</i></b></font></td><td align="right"><i>send a size approximately</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_send_size(size_t size, request_rec *r)</pre></td><td align="right" /></tr></table>Sends <tt class="literal">size</tt> to the client, rounding it to the nearest thousand, million, or whatever. If <tt class="literal">size</tt> is <tt class="literal">-1</tt>, prints a minus sign only.<a name="INDEX-1455" />
<a name="INDEX-1456" /></p></div>
</div>
















<a name="ch14-171-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.15. Request-Handling Functions</h3>





<a name="INDEX-1457" /><a name="INDEX-1458" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_sub_req_lookup_uri</i></b></font></td><td align="right"><i>look up a URI as if it were a request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>request_rec *ap_sub_req_lookup_uri(const char *new_uri, const request_rec *r)</pre></td><td align="right" /></tr></table>Feeds <tt class="literal">new_uri</tt> into the system to produce a new <tt class="literal">request_rec</tt>, which has been processed to just before the point at which the request handler would be called. If the URI is relative, it is resolved relative to the URI of <tt class="literal">r</tt>. Returns the new <tt class="literal">request_rec</tt>. The <tt class="literal">status</tt> member of the new <tt class="literal">request_rec</tt> contains any error code.</p></div>

<a name="INDEX-1459" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_sub_req_lookup_file</i></b></font></td><td align="right"><i>look up a file as if it were a request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>request_rec *ap_sub_req_lookup_file(const char *new_file, const request_rec *r)</pre></td><td align="right" /></tr></table>Similar to ap_<tt class="literal">sub_req_lookup_uri()</tt> except that it looks up a file, so it therefore doesn't call the name translators or match against <tt class="literal">&lt;Location&gt;</tt> sections.</p></div>

<a name="INDEX-1460" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_run_sub_req</i></b></font></td><td align="right"><i>run a subrequest</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_run_sub_req(request_rec *r)</pre></td><td align="right" /></tr></table>Runs a subrequest prepared with ap_<tt class="literal">sub_req_lookup_file()</tt> or ap_<tt class="literal">sub_req_lookup_uri()</tt>. Returns the status code of the request handler.</p></div>

<a name="INDEX-1461" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_destroy_sub_req</i></b></font></td><td align="right"><i>destroy a subrequest</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_destroy_sub_req(request_rec *r)</pre></td><td align="right" /></tr></table>Destroys a subrequest created with ap_<tt class="literal">sub_req_lookup_file()</tt> or ap_<tt class="literal">sub_req_lookup_uri()</tt> and releases the memory associated with it. Needless to say, you should copy anything you want from a subrequest before destroying it.</p></div>

<a name="INDEX-1462" /><a name="INDEX-1463" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_internal_redirect</i></b></font></td><td align="right"><i>internally redirect a request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_internal_redirect(const char *uri, request_rec *r)</pre></td><td align="right" /></tr></table>Internally redirects a request to <tt class="literal">uri</tt>. The request is processed immediately, rather than returning a redirect to the client.</p></div>

<a name="INDEX-1464" /><a name="INDEX-1465" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_internal_redirect_handler</i></b></font></td><td align="right"><i>internally redirect a request, preserving handler</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_internal_redirect_handler(const char *uri, request_rec *r)</pre></td><td align="right" /></tr></table>Similar to <tt class="literal">ap_internal_redirect()</tt>, but uses the handler specified by <tt class="literal">r</tt>.<a name="INDEX-1465" /></p></div>
</div>
















<a name="ch14-178-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.16. Timeout and Alarm Functions</h3>





<a name="INDEX-1466" /><a name="INDEX-1467" /><a name="INDEX-1468" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_hard_timeout</i></b></font></td><td align="right"><i>set a hard timeout on a request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_hard_timeout(char *name, request_rec *r)</pre></td><td align="right" /></tr></table>Sets an alarm to go off when the server's configured timeout expires. When the alarm goes off, the current request is aborted by doing a <tt class="literal">longjmp()</tt> back to the top level and destroying all pools for the request <tt class="literal">r</tt>. The string <tt class="literal">name</tt> is logged to the error log.</p></div>

<a name="INDEX-1469" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_keepalive_timeout</i></b></font></td><td align="right"><i>set the keepalive timeout on a request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_keepalive_timeout(char *name, request_rec *r)</pre></td><td align="right" /></tr></table>Works like <tt class="literal">ap_hard_timeout()</tt> except that if the request is kept alive, the keep-alive timeout is used instead of the server timeout. This should normally be used only when awaiting a request from the client, and thus is used only in <em class="filename">http_protocol.c</em>, but is included here for completeness.</p></div>

<a name="INDEX-1470" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_soft_timeout</i></b></font></td><td align="right"><i>set a soft timeout on a request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_soft_timeout(char *name, request_rec *r)</pre></td><td align="right" /></tr></table>Similar to <tt class="literal">ap_hard_timeout()</tt>, except that the request that is destroyed is not set. The parameter <tt class="literal">r</tt> is not used (it is there for historical reasons).</p></div>

<a name="INDEX-1471" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_reset_timeout</i></b></font></td><td align="right"><i>resets a hard or soft timeout to its original time</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_reset_timeout(request_rec *r)</pre></td><td align="right" /></tr></table>Resets the hard or soft timeout to what it originally was. The effect is as if you had called <tt class="literal">ap_hard_timeout()</tt> or <tt class="literal">ap_soft_timeout()</tt> again.</p></div>

<a name="INDEX-1472" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_kill_timeout</i></b></font></td><td align="right"><i>clears a timeout</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_kill_timeout(request_rec *r)</pre></td><td align="right" /></tr></table>Clears the current timeout on the request <tt class="literal">r</tt>.</p></div>

<a name="INDEX-1473" /><a name="INDEX-1474" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_block_alarms( )</i></b></font></td><td align="right"><i>temporarily prevents a timeout from occurring</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_block_alarms(void)</pre></td><td align="right" /></tr></table>Temporarily blocks any pending timeouts. Protects critical sections of code that would leak resources (or would go wrong in some other way) if a timeout occurred during their execution. Calls to this function can be nested, but each call must be matched by a call to <tt class="literal">ap_unblock_alarms()</tt>.</p></div>

<a name="INDEX-1475" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_unblock_alarms( )</i></b></font></td><td align="right"><i>unblock a blocked alarm</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_unblock_alarms(void)</pre></td><td align="right" /></tr></table>Remove a block placed by <tt class="literal">ap_block_alarms()</tt>.</p></div>

<a name="INDEX-1476" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_check_alarm</i></b></font></td><td align="right"><i>check alarm (Win32 only)</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_check_alarm(void)</pre></td><td align="right" /></tr></table><img src="figs/win32_icon.gif" alt="Figure 14.8" />   Since Win32 has no <tt class="literal">alarm()</tt> function, it is necessary to check alarms "by hand." This function does that, calling the alarm function set with one of the timeout functions. Returns <tt class="literal">-1</tt> if the alarm has gone off, the number of seconds left before the alarm does go off, or <tt class="literal">0</tt> if no alarm is set.</p></div>
</div>
















<a name="ch14-187-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.17. Configuration Functions</h3>





<a name="INDEX-1477" /><a name="INDEX-1478" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pcfg_openfile</i></b></font></td><td align="right"><i>open a file as a configuration</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>configfile_t *ap_pcfg_openfile(pool *p, const char *name)</pre></td><td align="right" /></tr></table>Opens <tt class="literal">name</tt> as a file (using <tt class="literal">fopen()</tt>), returning <tt class="literal">NULL</tt> if the open fails, or a pointer to a configuration on success.</p></div>

<a name="INDEX-1479" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pcfg_open_custom</i></b></font></td><td align="right"><i>create a custom configuration</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>configfile_t *ap_pcfg_open_custom(pool *p, const char *descr, void
*synopsism, 
int(*getch)(void *param), void *(*getstr) (void *buf, size_t bufsiz, void *param), 
int(*close_func)(void *param))</pre></td><td align="right" /></tr></table>Creates a custom configuration. The function
<tt class="literal">getch()</tt> should read a character from the
configuration, returning it or <tt class="literal">EOF</tt> if the
configuration is finished. The function <tt class="literal">getstr()</tt>
(if supplied -- it can be <tt class="literal">NULL</tt>, in which case
<tt class="literal">getch()</tt> will be used instead) should read a whole
line into <tt class="literal">buf</tt>, terminating with
<tt class="literal">NUL</tt>. It should return <tt class="literal">buf</tt>, or
<tt class="literal">NULL</tt> if the configuration is
finished. <tt class="literal">close_func()</tt> (if supplied -- it can be
<tt class="literal">NULL</tt>) should close the configuration, returning
<tt class="literal">0</tt> or more on success. All the functions are passed
<tt class="literal">param</tt> when called.</p></div>

<a name="INDEX-1480" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_cfg_getc</i></b></font></td><td align="right"><i>read a character from a configuration</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_cfg_ getc(configfile_t *cfp)</pre></td><td align="right" /></tr></table>Reads a single character from <tt class="literal">cfp</tt>. If the character is LF, the line number is incremented. Returns the character, or <tt class="literal">EOF</tt> if the configuration has completed.</p></div>

<a name="INDEX-1481" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_cfg_getline</i></b></font></td><td align="right"><i>read a line from a configuration, stripping whitespace</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_cfg_ getline(char *s, int n, configfile_t *cfp)</pre></td><td align="right" /></tr></table>Reads a line (up to <tt class="literal">n</tt> characters) from <tt class="literal">cfp</tt> into <tt class="literal">s</tt>, stripping leading and trailing whitespace and converting internal whitespace to single spaces. Continuation lines (indicated by a backslash immediately before the newline) are concatenated. Returns <tt class="literal">0</tt> normally, <tt class="literal">1</tt> if EOF has been reached.</p></div>

<a name="INDEX-1482" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_cfg_closefile</i></b></font></td><td align="right"><i>close a configuration</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_cfg_closefile(configfile_t *cfp)</pre></td><td align="right" /></tr></table>Close the configuration <tt class="literal">cfp</tt>. Return is less than zero on error.</p></div>

<a name="INDEX-1483" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_check_cmd_context</i></b></font></td><td align="right"><i>check if configuration cmd allowed in current context</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_check_cmd_context(cmd_parms *cmd, unsigned forbidden)</pre></td><td align="right" /></tr></table>Checks whether <tt class="literal">cmd</tt> is permitted in the current configuration context, according to the value of <tt class="literal">forbidden</tt>. Returns <tt class="literal">NULL</tt> if it is, or an appropriate error message if not. <tt class="literal">forbidden</tt> must be a combination of the following:</p><dl>
<dt><b><tt class="literal">NOT_IN_VIRTUALHOST</tt></b></dt>
<dd><p>Command cannot appear in a <tt class="literal">&lt;VirtualHost&gt;</tt>
section.</p></dd>





<dt><b><tt class="literal">NOT_IN_LIMIT</tt></b></dt>
<dd><p>Command cannot occur in a <tt class="literal">&lt;Limit&gt;</tt> section.</p></dd>





<dt><b><tt class="literal">NOT_IN_DIRECTORY</tt></b></dt>
<dd><p>Command cannot occur in a <tt class="literal">&lt;Directory&gt;</tt>
section.</p></dd>





<dt><b><tt class="literal">NOT_IN_LOCATION</tt></b></dt>
<dd><p>Command cannot occur in a <tt class="literal">&lt;Location&gt;</tt> section.</p></dd>





<dt><b><tt class="literal">NOT_IN_FILES</tt></b></dt>
<dd><p>Command cannot occur in a <tt class="literal">&lt;Files&gt;</tt> section.</p></dd>





<dt><b><tt class="literal">NOT_IN_DIR_LOC_FILE</tt></b></dt>
<dd><p>Shorthand for
<tt class="literal">NOT_IN_DIRECTORY|NOT_IN_LOCATION|NOT_IN_FILES</tt>.</p></dd>





<dt><b><tt class="literal">GLOBAL_ONLY</tt></b></dt>
<dd><p>Shorthand for
<tt class="literal">NOT_IN_VIRTUALHOST|NOT_IN_LIMIT|NOT_IN_DIR_LOC_FILE</tt>.</p></dd>

</dl></div>

<a name="INDEX-1484" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_set_file_slot</i></b></font></td><td align="right"><i>set a file slot in a configuration structure</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_set_file_slot(cmd_parms *cmd, char *struct_ptr, char
*arg)
</pre></td><td align="right" /></tr></table>Designed to be used in a <tt class="literal">command_rec</tt> to set a string for a file. It expects to be used with a <tt class="literal">TAKE1</tt> command. If the file is not absolute, it is made relative to the server root. Obviously, the corresponding structure member should be a <tt class="literal">char *</tt>.</p></div>

<a name="INDEX-1485" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_set_flag_slot</i></b></font></td><td align="right"><i>set a flag slot in a configuration structure.</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char * ap_set_flag_slot(cmd_parms *cmd, char *struct_ptr, int arg)</pre></td><td align="right" /></tr></table>Designed to be used in a <tt class="literal">command_rec</tt> to set a flag. It expects to be used with a <tt class="literal">FLAG</tt> command. The corresponding structure member should be an <tt class="literal">int</tt>, and it will be set to <tt class="literal">0</tt> or <tt class="literal">1</tt>.</p></div>

<a name="INDEX-1486" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_set_string_slot</i></b></font></td><td align="right"><i>set a string slot in a configuration structure</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_set_string_slot(cmd_parms *cmd, char *struct_ptr, char *arg)</pre></td><td align="right" /></tr></table>Designed to be used in a <tt class="literal">command_rec</tt> to set a string. It expects to be used with a <tt class="literal">TAKE1</tt> command. Obviously, the corresponding structure member should be a <tt class="literal">char *</tt>.</p></div>

<a name="INDEX-1487" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_set_string_slot_lower</i></b></font></td><td align="right"><i>set a lowercase string slot in a configuration structure</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_set_string_slot_lower(cmd_parms *cmd, char *struct_ptr, char *arg)
</pre></td><td align="right" /></tr></table>Similar to <tt class="literal">ap_set_string_slot()</tt>, except the string is made lowercase.</p></div>
</div>
















<a name="ch14-198-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.18. Configuration Information Functions</h3>




<p>
<a name="INDEX-1488" />Modules may need to know how some things have been configured. These functions give access to that information.</p>





<a name="INDEX-1489" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_allow_options</i></b></font></td><td align="right"><i>return options set with the Options directive</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_allow_options (request_rec *r)</pre></td><td align="right" /></tr></table>Returns the option set for the request <tt class="literal">r</tt>. This is a bitmap composed of the bitwise OR of the following:</p><dl>
<dt><b><tt class="literal">OPT_NONE</tt></b></dt>
<dd><p>No options set.</p></dd>





<dt><b><tt class="literal">OPT_INDEXES</tt></b></dt>
<dd><p>The <tt class="literal">Indexes</tt> option.</p></dd>





<dt><b><tt class="literal">OPT_INCLUDES</tt></b></dt>
<dd><p>The <tt class="literal">Includes</tt> option.</p></dd>





<dt><b><tt class="literal">OPT_SYM_LINKS</tt></b></dt>
<dd><p>The <tt class="literal">FollowSymLinks</tt> option.</p></dd>





<dt><b><tt class="literal">OPT_EXECCGI</tt></b></dt>
<dd><p>The <tt class="literal">ExecCGI</tt> option.</p></dd>





<dt><b><tt class="literal">OPT_INCNOEXEC</tt></b></dt>
<dd><p>The <tt class="literal">IncludesNOEXEC</tt> option.</p></dd>





<dt><b><tt class="literal">OPT_SYM_OWNER</tt></b></dt>
<dd><p>The <tt class="literal">FollowSymLinksIfOwnerMatch</tt> option.</p></dd>





<dt><b><tt class="literal">OPT_MULTI</tt></b></dt>
<dd><p>The <tt class="literal">MultiViews</tt> option.</p></dd>

</dl></div>

<a name="INDEX-1490" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_allow_overrides</i></b></font></td><td align="right"><i>return overrides set with the AllowOverride option</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_allow_overrides (request_rec *r)</pre></td><td align="right" /></tr></table>Returns the overrides permitted for the request <tt class="literal">r</tt>. These are the bitwise OR of the following:</p><dl>
<dt><b><tt class="literal">OR_NONE</tt></b></dt>
<dd><p>No overrides are permitted.</p></dd>





<dt><b><tt class="literal">OR_LIMIT</tt></b></dt>
<dd><p>The <tt class="literal">Limit</tt> override.</p></dd>





<dt><b><tt class="literal">OR_OPTIONS</tt></b></dt>
<dd><p>The <tt class="literal">Options</tt> override.</p></dd>





<dt><b><tt class="literal">OR_FILEINFO</tt></b></dt>
<dd><p>The <tt class="literal">FileInfo</tt> override.</p></dd>





<dt><b><tt class="literal">OR_AUTHCFG</tt></b></dt>
<dd><p>The <tt class="literal">AuthConfig</tt> override.</p></dd>





<dt><b><tt class="literal">OR_INDEXES</tt></b></dt>
<dd><p>The <tt class="literal">Indexes</tt> override.</p></dd>

</dl></div>

<a name="INDEX-1491" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_auth_type</i></b></font></td><td align="right"><i>return the authentication type for this request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_auth_type (request_rec *r)</pre></td><td align="right" /></tr></table>Returns the authentication type (as set by the <tt class="literal">AuthType</tt> directive) for the request <tt class="literal">r</tt>. Currently this should only be <tt class="literal">Basic</tt>, <tt class="literal">Digest</tt>, or <tt class="literal">NULL</tt>.</p></div>

<a name="INDEX-1492" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_auth_name</i></b></font></td><td align="right"><i>return the authentication domain name</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_auth_name (request_rec *r)</pre></td><td align="right" /></tr></table>Returns the authentication domain name (as set by the <tt class="literal">AuthName</tt> directive) for the request <tt class="literal">r</tt>.</p></div>

<a name="INDEX-1493" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_requires</i></b></font></td><td align="right"><i>return the require array</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const array_header *ap_requires (request_rec *r)</pre></td><td align="right" /></tr></table>Returns the array of <tt class="literal">require_line</tt>s that correspond to the <tt class="literal">require</tt> directive for the request <tt class="literal">r</tt>. <tt class="literal">require_line</tt> is defined as follows:</p><blockquote><pre class="code">typedef struct {
    int method_mask;
    char *requirement;
} require_line;</pre></blockquote><p><tt class="literal">method_mask</tt> is the bitwise OR of:</p><blockquote><pre class="code">1 &lt;&lt; M_GET
1 &lt;&lt; M_PUT
1 &lt;&lt; M_POST
1 &lt;&lt; M_DELETE
1 &lt;&lt; M_CONNECT
1 &lt;&lt; M_OPTIONS
1 &lt;&lt; M_TRACE
1 &lt;&lt; M_INVALID</pre></blockquote><p>as set by a <tt class="literal">Limit</tt> directive.</p></div>

<a name="INDEX-1494" /><a name="INDEX-1495" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_satisfies</i></b></font></td><td align="right"><i>return the satisfy setting</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_satisfies (request_rec *r)</pre></td><td align="right" /></tr></table>Returns the setting of <tt class="literal">satisfy</tt> for the request <tt class="literal">r</tt>. This is one of the following:</p><dl>
<dt><b><tt class="literal">SATISFY_ALL</tt></b></dt>
<dd><p>Must satisfy all authentication requirements (<tt class="literal">satisfy
all</tt>).</p></dd>





<dt><b><tt class="literal">SATISFY_ANY</tt></b></dt>
<dd><p>Can satisfy any one of the authentication requirements
(<tt class="literal">satisfy any</tt>).<a name="INDEX-1495" /></p></dd>

</dl></div>
</div>
















<a name="ch14-205-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.19. Server Information Functions</h3>





<a name="INDEX-1496" /><a name="INDEX-1497" /><a name="INDEX-1498" /><a name="INDEX-1499" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_server_built</i></b></font></td><td align="right"><i>get the date and time Apache was built</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_get_server_built(void)</pre></td><td align="right" /></tr></table>Returns a string containing the date and time the server was
built. Since this uses the C preprocessor
<tt class="literal">__DATE__</tt> and
<tt class="literal">__TIME__</tt> variables, the format is
somewhat system dependent. If the preprocessor doesn't support
<tt class="literal">__DATE__</tt> or
<tt class="literal">__TIME__</tt>, the string is set to "unknown."</p></div>

<a name="INDEX-1500" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_server_version</i></b></font></td><td align="right"><i>get the Apache version string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_get_server_version(  )</pre></td><td align="right" /></tr></table>Returns a string containing Apache's version (plus any module version strings that have been added).</p></div>

<a name="INDEX-1501" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_add_version_component</i></b></font></td><td align="right"><i>add a module version string</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_add_version_component(const char *component)</pre></td><td align="right" /></tr></table>Adds a string to the server version string. This function only has an effect during startup, after which the version string is locked. Version strings should take the form <em class="replaceable">module</em> <em class="replaceable">name</em><tt class="literal"> </tt><em class="replaceable">/version number</em>, for example, <tt class="literal">MyModule/1.3</tt>. Most modules do not add a version string.</p></div>
</div>
















<a name="ch14-209-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.20. Logging Functions</h3>





<a name="INDEX-1502" /><a name="INDEX-1503" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_error_log2stderr</i></b></font></td><td align="right"><i>map stderr to an error log</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_error_log2stderr (server_rec *s)</pre></td><td align="right" /></tr></table>Makes stderr the error log for the server <tt class="literal">s</tt>. Useful when running a subprocess.</p></div>

<a name="INDEX-1504" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_log_error</i></b></font></td><td align="right"><i>log an error</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_log_error(const char*file, int line, int level, const server_rec*s, const char *fmt, ...)</pre></td><td align="right" /></tr></table>Logs an error (if <tt class="literal">level</tt> is higher than the level set with the <tt class="literal">LogLevel</tt> directive). <tt class="literal">file</tt> and <tt class="literal">line</tt> are only logged if <tt class="literal">level</tt> is <tt class="literal">APLOG_DEBUG</tt>. <tt class="literal">file</tt> and <tt class="literal">line</tt> are normally set by calling <tt class="literal">ap_log_error()</tt> like so:</p><blockquote><pre class="code">ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,"some
error");</pre></blockquote><p><tt class="literal">APLOG_MARK</tt> is a
<tt class="literal">#define</tt> that uses <tt class="literal">__FILE__</tt> and
<tt class="literal">__LINE__</tt> to generate the filename and line number
of the call.</p><p><tt class="literal">level</tt> is a combination of
one of the following:</p><dl>
<dt><b><tt class="literal">APLOG_EMERG</tt></b></dt>
<dd><p>The system is unusable.</p></dd>





<dt><b><tt class="literal">APLOG_ALERT</tt></b></dt>
<dd><p>Action must be taken immediately.</p></dd>





<dt><b><tt class="literal">APLOG_CRIT</tt></b></dt>
<dd><p>Critical conditions.</p></dd>





<dt><b><tt class="literal">APLOG_ERR</tt></b></dt>
<dd><p>Error conditions.</p></dd>





<dt><b><tt class="literal">APLOG_WARNING</tt></b></dt>
<dd><p>Warnings.</p></dd>





<dt><b><tt class="literal">APLOG_NOTICE</tt></b></dt>
<dd><p>Normal but significant condition.</p></dd>





<dt><b><tt class="literal">APLOG_INFO</tt></b></dt>
<dd><p>Informational.</p></dd>





<dt><b><tt class="literal">APLOG_DEBUG</tt></b></dt>
<dd><p>Debugging messages.</p></dd>

</dl><p>optionally ORed with:</p><dl>
<dt><b><tt class="literal">APLOG_NOERRNO</tt></b></dt>
<dd><p>Do not log <tt class="literal">errno</tt>.</p></dd>





<dt><b><tt class="literal">APLOG_WIN32ERROR</tt></b></dt>

<dd><p><img src="figs/win32_icon.gif" alt="Figure 14.2" />   On Win32 use <tt class="literal">GetLastError()</tt> instead of
<tt class="literal">errno</tt>.</p></dd>

</dl></div>

<a name="INDEX-1505" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_log_reason</i></b></font></td><td align="right"><i>log an access failure</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_log_reason (const char *reason, const char *file, request_rec *r)
</pre></td><td align="right" /></tr></table>Logs a message of the form "access to <em class="replaceable">file</em> failed for <em class="replaceable">remotehost</em>, reason: <em class="replaceable">reason</em>". The remote host is extracted from <tt class="literal">r</tt>. The message is logged with <tt class="literal">ap_log_error()</tt> at level <tt class="literal">APLOG_ERR</tt>.</p></div>
</div>
















<a name="ch14-213-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.21. Piped Log Functions</h3>




<p>Apache provides functions to manage reliable piped logs. These are logs which are piped to another program. Apache restarts the program if it dies. This functionality is disabled if <tt class="literal">NO_RELIABLE_PIPED_LOGS</tt> is defined. The functions still exist and work, but the "reliability" is disabled.</p>






<a name="INDEX-1506" /><a name="INDEX-1507" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_open_piped_log</i></b></font></td><td align="right"><i>open a piped log program</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>piped_log *ap_open_piped_log (pool *p, const char *program)</pre></td><td align="right" /></tr></table>The program <tt class="literal">program</tt> is launched with appropriate pipes. <tt class="literal">program</tt> may include arguments.</p></div>

<a name="INDEX-1508" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_close_piped_log</i></b></font></td><td align="right"><i>close a piped log</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_close_piped_log (piped_log *pl)</pre></td><td align="right" /></tr></table>Closes <tt class="literal">pl</tt>. Doesn't kill the spawned child.</p></div>

<a name="INDEX-1509" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_piped_log_write_fd</i></b></font></td><td align="right"><i>get the file descriptor of a log pipe</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_piped_log_write_fd(piped_log *pl)</pre></td><td align="right" /></tr></table>Returns the file descriptor of an open piped log.</p></div>
</div>
















<a name="ch14-217-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.22. Buffering Functions</h3>




<p>
<a name="INDEX-1510" />
<a name="INDEX-1511" />Apache provides its own I/O buffering interface. This allows chunked transfers to be done transparently and hides differences between files and sockets under Win32.</p>





<a name="INDEX-1512" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bcreate</i></b></font></td><td align="right"><i>create a buffered stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>BUFF *ap_bcreate(pool *p, int flags)</pre></td><td align="right" /></tr></table>Creates a new buffered stream in <tt class="literal">p</tt>. The stream is not associated with any file or socket at this point. <tt class="literal">flags</tt> are a combination of one of the following:</p><dl>
<dt><b><tt class="literal">B_RD</tt></b></dt>
<dd><p>Reading is buffered.</p></dd>





<dt><b><tt class="literal">B_WR</tt></b></dt>
<dd><p>Writing is buffered.</p></dd>





<dt><b><tt class="literal">B_RDWR</tt></b></dt>
<dd><p>Reading and writing are buffered.</p></dd>

</dl><p>and, optionally:</p><dl>
<dt><b><tt class="literal">B_SOCKET</tt></b></dt>
<dd><p>The stream will be buffering a socket. Note that this flag also
causes ASCII/EBCDIC translation to be enabled on platforms that use
EBCDIC (see <tt class="literal">ap_bsetflag()</tt>).</p></dd>

</dl></div>

<a name="INDEX-1513" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bpushfd</i></b></font></td><td align="right"><i>set the file descriptors for a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_bpushfd(BUFF *fb, int fd_in, int fd_out)</pre></td><td align="right" /></tr></table>Sets the read file descriptor to <tt class="literal">fd_in</tt> and the write file descriptor to <tt class="literal">fd_out</tt>. Use <tt class="literal">-1</tt> for file descriptors you don't want to set. Note that these descriptors must be readable with <tt class="literal">read()</tt> and writable with <tt class="literal">write()</tt>.</p></div>

<a name="INDEX-1514" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bpushh</i></b></font></td><td align="right"><i>set a Win32 handle for a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_bpushh(BUFF *fb, HANDLE hFH)</pre></td><td align="right" /></tr></table><img src="figs/win32_icon.gif" alt="Figure 14.3" />   Sets a Win32 file handle for both input and output. The handle will be written with <tt class="literal">WriteFile()</tt> and read with <tt class="literal">ReadFile()</tt>. Note that this function should not be used for a socket, even though a socket is a Win32 handle. <tt class="literal">ap_bpushfd()</tt> should be used for sockets.</p></div>

<div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bsetopt</i></b></font></td><td align="right"><i>set an option</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bsetopt(BUFF *fb, int optname, const void *optval)</pre></td><td align="right" /></tr></table>Sets the option <tt class="literal">optname</tt> to the value pointed at by <tt class="literal">optval</tt>. There is currently only one option, which is the count of bytes sent to the stream,<a href="#FOOTNOTE-76">[76]</a> set with <tt class="literal">BO_BYTECT</tt>. In this case, <tt class="literal">optval</tt> should point to a <tt class="literal">long</tt>. This function is used for logging and statistics and is not normally called by modules. Its main use, when it is called, is to zero the count after sending headers to a client. Returns <tt class="literal">0</tt> on success, <tt class="literal">-1</tt> on failure.</p><blockquote>




<a name="FOOTNOTE-76" /><p>[76]Not really an option, in our view, but we didn't name the function.</p>




</blockquote></div>

<div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bgetopt</i></b></font></td><td align="right"><i>get the value of an option</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bgetopt(BUFF *fb, int optname, void *optval)</pre></td><td align="right" /></tr></table>Gets the value of the option <tt class="literal">optname</tt> in the location pointed at by <tt class="literal">optval</tt>. The only supported option is <tt class="literal">BO_BYTECT</tt> (see <tt class="literal">ap_bsetopt()</tt>).</p></div>

<div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bsetflag</i></b></font></td><td align="right"><i>set or clear a flag</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bsetflag(BUFF *fb, int flag, int value)</pre></td><td align="right" /></tr></table>If <tt class="literal">value</tt> is <tt class="literal">0</tt>, clear <tt class="literal">flag</tt>; otherwise, set it. <tt class="literal">flag</tt> is one of the following:</p><dl>
<dt><b><tt class="literal">B_EOUT</tt></b></dt>
<dd><p>Prevent further I/O.</p></dd>





<dt><b><tt class="literal">B_CHUNK</tt></b></dt>
<dd><p>Use chunked writing.</p></dd>





<dt><b><tt class="literal">B_SAFEREAD</tt></b></dt>
<dd><p>Force an <tt class="literal">ap_bflush()</tt> if a read would block.</p></dd>





<dt><b><tt class="literal">B_ASCII2EBCDIC</tt></b></dt>
<dd><p>Convert ASCII to EBCDIC when reading. Only available on systems that
support EBCDIC.</p></dd>





<dt><b><tt class="literal">B_EBCDIC2ASCII</tt></b></dt>
<dd><p>Convert EBCDIC to ASCII when writing. Only available on systems that
support EBCDIC.</p></dd>

</dl></div>

<a name="INDEX-1515" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bgetflag</i></b></font></td><td align="right"><i>get a flag's setting</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bgetflag(BUFF *fb, int flag)</pre></td><td align="right" /></tr></table>Returns <tt class="literal">0</tt> if <tt class="literal">flag</tt> is not set, nonzero otherwise. See <tt class="literal">ap_bsetflag()</tt> for a list of flags.</p></div>

<a name="INDEX-1516" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bonerror</i></b></font></td><td align="right"><i>register an error function</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_bonerror(BUFF *fb, void (*error) (BUFF *, int, void *), void *data)
</pre></td><td align="right" /></tr></table>When an error occurs on <tt class="literal">fb</tt>, <tt class="literal">error()</tt> is called with <tt class="literal">fb</tt>, the direction (<tt class="literal">B_RD</tt> or   <tt class="literal">B_WR</tt>), and <tt class="literal">data</tt>.</p></div>

<a name="INDEX-1517" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bnonblock</i></b></font></td><td align="right"><i>set a stream to nonblocking mode</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bnonblock(BUFF *fb, int direction)</pre></td><td align="right" /></tr></table><tt class="literal">direction</tt> is one of <tt class="literal">B_RD</tt> or <tt class="literal">B_WR</tt>. Sets the corresponding file descriptor to be nonblocking. Returns whatever <tt class="literal">fcntl()</tt> returns.</p></div>

<a name="INDEX-1518" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bfileno</i></b></font></td><td align="right"><i>get a file descriptor from a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bfileno(BUFF *fb, int direction)</pre></td><td align="right" /></tr></table><tt class="literal">direction</tt> is one of <tt class="literal">B_RD</tt> or <tt class="literal">B_WR</tt>. Returns the corresponding file descriptor.</p></div>

<a name="INDEX-1519" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bread</i></b></font></td><td align="right"><i>read from a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bread(BUFF *fb, void *buf, int nbyte)</pre></td><td align="right" /></tr></table>Reads up to <tt class="literal">nbyte</tt> bytes into <tt class="literal">buf</tt>. Returns the number of bytes read, <tt class="literal">0</tt> on end of file (EOF), or <tt class="literal">-1</tt> for an error. Only reads the data currently available.</p></div>

<a name="INDEX-1520" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bgetc</i></b></font></td><td align="right"><i>get a character from a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bgetc(BUFF *fb)</pre></td><td align="right" /></tr></table>Reads a single character from <tt class="literal">fb</tt>. Returns the character on success, and returns <tt class="literal">EOF</tt> on error or end of file. If the <tt class="literal">EOF</tt> is the result of an end of file, <tt class="literal">errno</tt> will be zero.</p></div>

<a name="INDEX-1521" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bgets</i></b></font></td><td align="right"><i>read a line from a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bgets(char *buff, int n, BUFF *fb)</pre></td><td align="right" /></tr></table>Reads up to <tt class="literal">n</tt>-1 bytes into <tt class="literal">buff</tt>, until an LF is seen or the end of file is reached. If LF is preceded by CR, the CR is deleted. The buffer is then terminated with a <tt class="literal">NUL</tt> (leaving the LF as the character before the <tt class="literal">NUL</tt>). Returns the number of bytes stored in the buffer, excluding the terminating <tt class="literal">NUL</tt>.</p></div>

<a name="INDEX-1522" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_blookc</i></b></font></td><td align="right"><i>peek at the next character in a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_blookc(char *buff, BUFF *fb)</pre></td><td align="right" /></tr></table>Places the next character in the stream in <tt class="literal">*buff</tt>, without removing it from the stream. Returns <tt class="literal">1</tt> on success, <tt class="literal">0</tt> on EOF, and <tt class="literal">-1</tt> on error.</p></div>

<a name="INDEX-1523" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bskiplf</i></b></font></td><td align="right"><i>discard until an LF is read</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bskiplf(BUFF *fb)</pre></td><td align="right" /></tr></table>Discards input until an LF is read. Returns <tt class="literal">1</tt> on success, <tt class="literal">0</tt> on EOF, and <tt class="literal">-1</tt> on an error. The stream must be read-buffered (i.e., in <tt class="literal">B_RD</tt> or <tt class="literal">B_RDWR</tt> mode).</p></div>

<a name="INDEX-1524" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bwrite</i></b></font></td><td align="right"><i>write to a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bwrite(BUFF *fb, const void *buf, int nbyte)</pre></td><td align="right" /></tr></table>Writes <tt class="literal">nbyte</tt> bytes from <tt class="literal">buf</tt> to <tt class="literal">fb</tt>. Returns the number of bytes written. This can only be less than <tt class="literal">nbyte</tt> if an error occurred. Takes care of chunked encoding if the <tt class="literal">B_CHUNK</tt> flag is set.</p></div>

<a name="INDEX-1525" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bputc</i></b></font></td><td align="right"><i>write a single character to a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bputc(char c, BUFF *fb)</pre></td><td align="right" /></tr></table>Writes <tt class="literal">c</tt> to <tt class="literal">fb</tt>, returning <tt class="literal">0</tt> on success, <tt class="literal">-1</tt> on an error.</p></div>

<a name="INDEX-1526" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bputs</i></b></font></td><td align="right"><i>write a NUL-terminated string to a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bputs(const char *buf, BUFF *fb)</pre></td><td align="right" /></tr></table>Writes the contents of <tt class="literal">buf</tt> up to, but not including, the first <tt class="literal">NUL</tt>. Returns the number of bytes written, or <tt class="literal">-1</tt> on an error.</p></div>

<a name="INDEX-1527" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bvputs</i></b></font></td><td align="right"><i>write several NUL-terminated strings to a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bvputs(BUFF *fb,...)</pre></td><td align="right" /></tr></table>Writes the contents of a list of buffers in the same manner as <tt class="literal">ap_bputs()</tt>. The list of buffers is terminated with a <tt class="literal">NULL</tt>. Returns the total number of bytes written, or <tt class="literal">-1</tt> on an error. For example:</p><blockquote><pre class="code">if(ap_bvputs(fb,buf1,buf2,buf3,NULL) &lt; 0)
	...</pre></blockquote></div>

<a name="INDEX-1528" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bprintf</i></b></font></td><td align="right"><i>write formatted output to a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bprintf(BUFF *fb, const char *fmt, ...)</pre></td><td align="right" /></tr></table>Write formatted output, as defined by <tt class="literal">fmt</tt>, to <tt class="literal">fb</tt>. Returns the number of bytes sent to the stream.</p></div>

<a name="INDEX-1529" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_vbprintf</i></b></font></td><td align="right"><i>write formatted output to a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_vbprintf(BUFF *fb, const char *fmt, va_list ap)</pre></td><td align="right" /></tr></table>Similar to <tt class="literal">ap_bprintf()</tt>, except it uses a <tt class="literal">va_list</tt> instead of "<tt class="literal">...</tt>".</p></div>

<a name="INDEX-1530" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bflush</i></b></font></td><td align="right"><i>flush output buffers</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bflush(BUFF *fb)</pre></td><td align="right" /></tr></table>Flush <tt class="literal">fb</tt>'s output buffers. Returns <tt class="literal">0</tt> on success and <tt class="literal">-1</tt> on error. Note that the file must be write-buffered (i.e., in <tt class="literal">B_WR</tt> or <tt class="literal">B_RDWR</tt> mode).</p></div>

<a name="INDEX-1531" /><a name="INDEX-1532" /><a name="INDEX-1533" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_bclose</i></b></font></td><td align="right"><i>close a stream</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_bclose(BUFF *fb)</pre></td><td align="right" /></tr></table>Flushes the output buffer and closes the underlying file descriptors/handle/socket. Returns <tt class="literal">0</tt> on success and <tt class="literal">-1</tt> on error.<a name="INDEX-1532" />
<a name="INDEX-1533" /></p></div>
</div>
















<a name="ch14-241-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.23. URI Functions</h3>




<p>
<a name="INDEX-1534" />Some of these functions use the <tt class="literal">uri_components</tt>
<a name="INDEX-1535" /> structure:</p>





<blockquote><pre class="code">typedef struct {
    char *scheme;     /* scheme ("http"/"ftp"/...) */
    char *hostinfo;   /* combined [user[:password]@]host[:port] */
    char *user;       /* username, as in http://user:passwd@host:port/ */
    char *password;   /* password, as in http://user:passwd@host:port/ */
    char *hostname;   /* hostname from URI (or from Host: header) */
    char *port_str;   /* port string (integer representation is in "port") */
    char *path;       /* The request path (or "/" if only scheme://host was 
                      /* given) */
    char *query;      /* Everything after a '?' in the path, if present */
    char *fragment;   /* Trailing "#fragment" string, if present */
    struct hostent *hostent;
    unsigned short port;	
                      /* The port number, numeric, valid only if
                      /* port_str != NULL */

    unsigned is_initialized:1;
    unsigned dns_looked_up:1;
    unsigned dns_resolved:1;
} uri_components;</pre></blockquote>





<a name="INDEX-1536" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_parse_uri_components</i></b></font></td><td align="right"><i>dissect a full URI</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_parse_uri_components(pool *p, const char *uri, uri_components *uptr)</pre></td><td align="right" /></tr></table>Dissects the URI <tt class="literal">uri</tt> into its components, which are placed in <tt class="literal">uptr</tt>. Each component is allocated in <tt class="literal">p</tt>. Any missing components are set to <tt class="literal">NULL</tt>. <tt class="literal">uptr-&gt;is_initialized</tt> is set to <tt class="literal">1</tt>.</p></div>

<a name="INDEX-1537" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_parse_hostinfo_components</i></b></font></td><td align="right"><i>dissect host:port</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_parse_hostinfo_components(pool *p, const char *hostinfo, uri_components *uptr)</pre></td><td align="right" /></tr></table>Occasionally, it is necessary to parse <em class="replaceable">host:port</em>, for example, when handling a <tt class="literal">CONNECT</tt> request. This function does that, setting <tt class="literal">uptr-&gt;hostname</tt>, <tt class="literal">uptr-&gt;port_str</tt>, and <tt class="literal">uptr-&gt;port</tt> (if the port component is present). All other elements are set to <tt class="literal">NULL</tt>.</p></div>

<a name="INDEX-1538" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_unparse_uri_components</i></b></font></td><td align="right"><i>convert back to a URI</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>char *ap_unparse_uri_components(pool *p, const uri_components *uptr, unsigned flags)</pre></td><td align="right" /></tr></table>Takes a filled-in <tt class="literal">uri_components</tt>, <tt class="literal">uptr</tt>, and makes a string containing the corresponding URI. The string is allocated in <tt class="literal">p</tt>. <tt class="literal">flags</tt> is a combination of none or more of the following:</p><dl>
<dt><b><tt class="literal">UNP_OMITSITEPART</tt></b></dt>
<dd><p>Leave out "scheme://user:password@site:port".</p></dd>





<dt><b><tt class="literal">UNP_OMITUSER</tt></b></dt>
<dd><p>Leave out the user.</p></dd>





<dt><b><tt class="literal">UNP_OMITPASSWORD</tt></b></dt>
<dd><p>Leave out the password.</p></dd>





<dt><b><tt class="literal">UNP_OMITUSERINFO</tt></b></dt>
<dd><p>Shorthand for <tt class="literal">UNP_OMITUSER|UNP_OMITPASSWORD.</tt></p></dd>





<dt><b><tt class="literal">UNP_REVEALPASSWORD</tt></b></dt>
<dd><p>Show the password (instead of replacing it with XXX).</p></dd>

</dl></div>

<a name="INDEX-1539" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pgethostbyname</i></b></font></td><td align="right"><i>resolve a hostname</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>struct hostent *ap_pgethostbyname(pool *p, const char *hostname)</pre></td><td align="right" /></tr></table>Essentially does the same as the standard function <tt class="literal">gethostbyname()</tt> except that the result is allocated in <tt class="literal">p</tt> instead of being temporary.</p></div>

<a name="INDEX-1540" /><a name="INDEX-1541" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pduphostent</i></b></font></td><td align="right"><i>duplicate a hostent structure</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>struct hostent *ap_pduphostent(pool *p, const struct hostent *hp)</pre></td><td align="right" /></tr></table>Duplicates <tt class="literal">hp</tt> (and everything it points at) in the pool <tt class="literal">p</tt>.<a name="INDEX-1541" /></p></div>
</div>
















<a name="ch14-247-fm2xml" /><div class="sect2">
<h3 class="sect2">14.6.24. Miscellaneous Functions</h3>





<a name="INDEX-1542" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_child_terminate</i></b></font></td><td align="right"><i>cause the current process to terminate</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_child_terminate(request_rec *r)</pre></td><td align="right" /></tr></table>Makes this instance of Apache terminate after the current request has completed. If the connection is a keepalive connection, keepalive is cancelled.</p></div>

<a name="INDEX-1543" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_default_port</i></b></font></td><td align="right"><i>return the default port for a request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>unsigned short ap_default_port(request_rec *r)</pre></td><td align="right" /></tr></table>Returns the default port number for the type of request handled by <tt class="literal">r</tt>. In standard Apache this is always an HTTP request, so the return is always 80, but in Apache-SSL, for example, it depends on whether HTTP or HTTPS is in use.</p></div>

<a name="INDEX-1544" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_is_default_port</i></b></font></td><td align="right"><i>check whether a port is the default port</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_is_default_port(int port, request_rec *r)</pre></td><td align="right" /></tr></table>Returns <tt class="literal">1</tt> if <tt class="literal">port</tt> is the default port for <tt class="literal">r</tt>, <tt class="literal">0</tt> if not.</p></div>

<a name="INDEX-1545" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_default_port_for_scheme</i></b></font></td><td align="right"><i>return the default port for a scheme</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>unsigned short ap_default_port_for_scheme(const char *scheme_str)</pre></td><td align="right" /></tr></table>Returns the default port for the scheme <tt class="literal">scheme</tt>.</p></div>

<a name="INDEX-1546" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_http_method</i></b></font></td><td align="right"><i>return the scheme for a request</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_http_method(request_rec *r)</pre></td><td align="right" /></tr></table>Returns the default scheme for the type of request handled by <tt class="literal">r</tt>. In standard Apache this is always an HTTP request, so the return is always <tt class="literal">http</tt>, but in Apache-SSL, for example, it depends on whether HTTP or HTTPS is in use.</p></div>

<a name="INDEX-1547" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_default_type</i></b></font></td><td align="right"><i>returns default content type</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_default_type(request_rec *r)</pre></td><td align="right" /></tr></table>Returns the default content type for the request <tt class="literal">r</tt>. This is either set by the <tt class="literal">DefaultType</tt> directive or is <tt class="literal">text/plain</tt>.</p></div>

<a name="INDEX-1548" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_basic_auth_pw</i></b></font></td><td align="right"><i>get the password supplied for basic authentication</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_get_basic_auth_pw(request_rec *r, const char **pw)</pre></td><td align="right" /></tr></table>If a password has been set for basic authentication (by the client), its address is put in <tt class="literal">*pw</tt>.<tt class="literal"> </tt>Otherwise, an appropriate error is returned:</p><dl>
<dt><b><tt class="literal">DECLINED</tt></b></dt>
<dd><p>If the request does not require basic authentication</p></dd>





<dt><b><tt class="literal">SERVER_ERROR</tt></b></dt>
<dd><p>If no authentication domain name has been set (with
<tt class="literal">AuthName</tt>)</p></dd>





<dt><b><tt class="literal">AUTH_REQUIRED</tt></b></dt>
<dd><p>If authentication is required but has not been sent by the client</p></dd>





<dt><b><tt class="literal">OK</tt></b></dt>
<dd><p>If the password has been put in <tt class="literal">*pw</tt></p></dd>

</dl></div>

<a name="INDEX-1549" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_module_config</i></b></font></td><td align="right"><i>get module-specific configuration information</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void *ap_get_module_config(void *conf_vector, module *m)</pre></td><td align="right" /></tr></table>Gets the module-specific configuration set up by the module during startup. <tt class="literal">conf_vector</tt> is usually either the <tt class="literal">per_dir_config</tt> from a <tt class="literal">request_rec</tt>, or <tt class="literal">module_config</tt> from a <tt class="literal">server_rec</tt>. See <a href="ch15_01.htm">Chapter 15, "Writing Apache Modules"</a>, for more information.</p></div>

<a name="INDEX-1550" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_remote_logname</i></b></font></td><td align="right"><i>get the login name of the client's user</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_get_remote_logname(request_rec *r)</pre></td><td align="right" /></tr></table>Returns the login name of the client's user, if it can be found and the facility has been enabled with the <tt class="literal">IdentityCheck</tt> directive. Returns <tt class="literal">NULL</tt> otherwise.</p></div>

<a name="INDEX-1551" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_server_name</i></b></font></td><td align="right"><i>get the name of the current server</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_get_server_name(const request_rec *r)</pre></td><td align="right" /></tr></table>Gets the name of the server that is handling <tt class="literal">r</tt>. If the <tt class="literal">UseCanonicalName</tt> directive is on, then it returns the name configured in the configuration file. If <tt class="literal">UseCanonicalName</tt> is off, it returns the hostname used in the request, if there was one, or the configured name if not.</p></div>

<a name="INDEX-1552" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_get_server_port</i></b></font></td><td align="right"><i>get the port of the current server</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>unsigned ap_get_server_port(const request_rec *r)</pre></td><td align="right" /></tr></table>If <tt class="literal">UseCanonicalName</tt> is on, then returns the port configured for the server that is handling <tt class="literal">r</tt>. If <tt class="literal">UseCanonicalName</tt> is off, returns the port of the connection if the request included a hostname, or the configured port otherwise.<a href="#FOOTNOTE-77">[77]</a></p><blockquote>




<a name="FOOTNOTE-77" /><p>[77]Though what practical difference this makes is somewhat mysterious to us.</p>




</blockquote></div>

<a name="INDEX-1553" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_is_initial_req</i></b></font></td><td align="right"><i>is this the main request_rec?</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_is_initial_req(request_rec *r)</pre></td><td align="right" /></tr></table>Returns <tt class="literal">1</tt> if <tt class="literal">r</tt> is the main <tt class="literal">request_rec</tt> (as opposed to a subrequest or internal redirect), and <tt class="literal">0</tt> otherwise.</p></div>

<a name="INDEX-1554" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_matches_request_vhost</i></b></font></td><td align="right"><i>does a host match a request's virtual host?</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_matches_request_vhost(request_rec *r, const char *host,
unsigned port)
</pre></td><td align="right" /></tr></table>Returns <tt class="literal">1</tt> if <tt class="literal">host</tt>:<tt class="literal">port</tt> matches the virtual host that is handling <tt class="literal">r</tt>, <tt class="literal">0</tt> otherwise.</p></div>

<a name="INDEX-1555" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_os_dso_load</i></b></font></td><td align="right"><i>load a dynamic shared object (DSO)</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void *ap_os_dso_load(const char *path)</pre></td><td align="right" /></tr></table>Loads the dynamic shared object (that is, DLL, shared library, or whatever) specified by <tt class="literal">path</tt>. This has a different underlying implementation according to platform. The return value is a handle that can be used by other DSO functions. Returns <tt class="literal">NULL</tt> if <tt class="literal">path</tt> cannot be loaded.</p></div>

<a name="INDEX-1556" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_os_dso_unload</i></b></font></td><td align="right"><i>unload a dynamic shared object</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_os_dso_unload(void *handle)</pre></td><td align="right" /></tr></table>Unloads the dynamic shared object described by <tt class="literal">handle</tt>.</p></div>

<a name="INDEX-1557" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_os_dso_sym</i></b></font></td><td align="right"><i>return the address of a symbol</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void *ap_os_dso_sym(void *handle, const char *symname)</pre></td><td align="right" /></tr></table>Returns the address of <tt class="literal">symname</tt> in the dynamic shared object referred to by <tt class="literal">handle</tt>. If the platform mangles symbols in some way (for example, by prepending an underscore), this function does the same mangling before lookup. Returns <tt class="literal">NULL</tt> if <tt class="literal">symname</tt> cannot be found or an error occurs.</p></div>

<a name="INDEX-1558" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_os_dso_error</i></b></font></td><td align="right"><i>get a string describing a DSO error</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_os_dso_error(void)</pre></td><td align="right" /></tr></table>If an error occurs with a DSO function, this function returns a string describing the error. If no error has occurred, returns <tt class="literal">NULL</tt>.</p></div>

<a name="INDEX-1559" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_popendir</i></b></font></td><td align="right"><i>do an opendir(  ) with cleanup</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>DIR *ap_popendir(pool *p, const char *name)</pre></td><td align="right" /></tr></table>Essentially the same as the standard function <tt class="literal">opendir()</tt>, except that it registers a cleanup function that will do a <tt class="literal">closedir()</tt>. A <tt class="literal">DIR</tt> created with this function should be closed with <tt class="literal">ap_pclosedir()</tt> (or left for the cleanup to close). Apart from that, the standard functions should be used.</p></div>

<a name="INDEX-1560" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_pclosedir</i></b></font></td><td align="right"><i>close a DIR opened with ap_popendir(  )</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>void ap_pclosedir(pool *p, DIR * d)</pre></td><td align="right" /></tr></table>Does a <tt class="literal">closedir()</tt> and cancels the cleanup registered by <tt class="literal">ap_popendir()</tt>. This function should only be called on a <tt class="literal">DIR</tt> created with <tt class="literal">ap_popendir()</tt>.</p></div>

<a name="INDEX-1561" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_psignature</i></b></font></td><td align="right"><i>create the server "signature"</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>const char *ap_psignature(const char *prefix, request_rec *r)</pre></td><td align="right" /></tr></table>Creates a "signature" for the server handling <tt class="literal">r</tt>. This can be nothing, the server name and port, or the server name and port hotlinked to the administrator's email address, depending on the setting of the <tt class="literal">ServerSignature</tt> directive. Unless <tt class="literal">ServerSignature</tt> is off, the returned string has <tt class="literal">prefix</tt> prepended.</p></div>

<a name="INDEX-1562" /><a name="INDEX-1563" /><a name="INDEX-1564" /><a name="INDEX-1565" /><a name="INDEX-1566" /><a name="INDEX-1567" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>ap_vformatter</i></b></font></td><td align="right"><i>general-purpose formatter</i></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>int ap_vformatter(int (*flush_func)(ap_vformatter_buff *),ap_vformatter_buff *vbuff, 
const char *fmt, va_list ap)</pre></td><td align="right" /></tr></table>Because Apache has several requirements for formatting functions (e.g., <tt class="literal">ap_bprintf()</tt>, <tt class="literal">ap_psprintf()</tt>) and it is actually not possible to implement them safely using standard functions, Apache has its own <tt class="literal">printf()</tt>-style routines. This function is the interface to them. It takes a buffer-flushing function as an argument, and an <tt class="literal">ap_vformatter_buff</tt> structure, which looks like this:</p><blockquote><pre class="code">typedef struct {
    char *curpos;
    char *endpos;
} ap_vformatter_buff;</pre></blockquote><p>as well as the usual format string, <tt class="literal">fmt</tt>, and varargs list, <tt class="literal">ap</tt>. <tt class="literal">ap_vformatter()</tt> fills the buffer (at <tt class="literal">vbuff-&gt;curpos</tt>) until <tt class="literal">vbuff-&gt;curpos == vbuff-&gt;endpos</tt>; then <tt class="literal">flush_func()</tt> is called with <tt class="literal">vbuff</tt> as the argument. <tt class="literal">flush_func()</tt> should empty the buffer and reset the values in <tt class="literal">vbuff</tt> to allow the formatting to proceed. <tt class="literal">flush_func()</tt> is not called when formatting is complete (unless it happens to fill the buffer). It is the responsibility of the function that calls <tt class="literal">ap_vformatter()</tt> to finish things off.</p><p>Since <tt class="literal">flush_func()</tt> almost always needs more information than that found in <tt class="literal">vbuff</tt>, the following ghastly hack is frequently employed. First, a structure with an <tt class="literal">ap_vformatter_buff</tt> as its first element<a href="#FOOTNOTE-78">[78]</a> is defined:</p><blockquote>




<a name="FOOTNOTE-78" /><p>[78]Of course, if you don't mind the hack being even more ghastly, it doesn't <em class="emphasis">have</em> to be first.</p>




</blockquote><blockquote><pre class="code">struct extra_data {
    ap_vformatter_buff vbuff;
    int some_extra_data;
    ...
};</pre></blockquote><p>Next, the <tt class="literal">printf()</tt>-style routine calls <tt class="literal">ap_vformatter</tt> with an instance of this structure:</p><blockquote><pre class="code">struct extra_data mine;
    ...
    mine.some_extra_data=123;
    ap_vformatter(my_flush,&amp;mine.vbuff,fmt,ap);
    ...</pre></blockquote><p>Finally, <tt class="literal">my_flush()</tt> does this:</p><blockquote><pre class="code">API_EXPORT(int) my_flush(ap_vformatter_buff *vbuff)
{
    struct extra_data *pmine=(struct extra_data *)vbuff;
    assert(pmine-&gt;some_extra_data == 123);
    ...</pre></blockquote><p>As you can probably guess, we don't entirely approve of this technique, but it works.</p><p><tt class="literal">ap_vformatter()</tt> does all the usual formatting, except that <tt class="literal">%p</tt> has been changed to <tt class="literal">%pp</tt>, and <tt class="literal">%pA</tt> formats a <tt class="literal">struct</tt> <tt class="literal">in_addr</tt> <tt class="literal">*</tt> as <tt class="literal">a.b.c.d </tt>, and <tt class="literal">%pI</tt> formats a <tt class="literal">struct</tt> <tt class="literal">sockaddr_in</tt> <tt class="literal">*</tt> as <tt class="literal">a.b.c.d:port</tt>. The reason for these strange-looking formats is to take advantage of <em class="filename">gcc </em>'s format string checking, which will make sure a <tt class="literal">%p</tt> corresponds to a <a name="INDEX-1563" />
<a name="INDEX-1564" />
<a name="INDEX-1565" />pointer.<a name="INDEX-1566" />
<a name="INDEX-1567" /></p></div>
</div>


<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch14_05.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch15_01.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">14.5. Access to Configuration and Request Information</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">15. Writing Apache Modules</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="../run/index.htm" coords="172,2,252,105" shape="rect" /><area href="index.htm" coords="238,2,334,95" shape="rect" /><area href="../sql/index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="../cgi/index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>