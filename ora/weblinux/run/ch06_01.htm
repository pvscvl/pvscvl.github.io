<?label 6. Managing
 Filesystems, Swap,
 and Devices?><html><head><title>Managing
 Filesystems, Swap,
 and Devices (Running Linux)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="Running Linux" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch05_07.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm" /></td><td width="172" valign="top" align="right"><a href="ch06_02.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<h1 class="chapter">Chapter 6. Managing
 Filesystems, Swap,
 and Devices</h1>
<div class="htmltoc"><h4 class="tochead">Contents:</h4><p>
<a href="ch06_01.htm">Managing Filesystems</a><br />
<a href="ch06_02.htm">Managing Swap Space</a><br />
<a href="ch06_03.htm">Device Files</a><br /></p></div>

<p>You probably created filesystems and swap space when you first
installed Linux (most distributions help you do the basics).  Here is
a chance to fine-tune these resources.  Most of the time, you do
these things shortly after installing your operating system, before
you start loading up your disks with fun stuff.  But occasionally you
will want to change a running system, in order to add a new device or
perhaps upgrade the swap space when you upgrade your <span class="acronym">RAM</span>.</p>

<div class="sect1"><a name="x-100-3-sec-sysadm-fs" />
<h2 class="sect1">6.1. Managing Filesystems</h2>

<p><a name="INDEX-1418" />
To Unix systems, a filesystem
is some device (such as a hard drive, floppy, or
<span class="acronym">CD-ROM</span>) that is formatted to store files.
Filesystems can be found on hard drives, floppies,
<span class="acronym">CD-ROM</span>s, and other storage media that permit
random access. (Note: a tape allows only sequential access,
and therefore can't contain a filesystem per se.)</p>

<p><a name="INDEX-1419" />
The exact format and means by which files are stored is not
important; the system provides a common interface for all
<em class="emphasis">filesystem types</em> it recognizes. Under
Linux, filesystem types include the Second Extended filesystem, or
<em class="emphasis">ext2fs</em>, which you probably use to store Linux
files; the <span class="acronym">MS-DOS</span> filesystem, which allows files on
<span class="acronym">MS-DOS</span> partitions and floppies to be accessed under
Linux; and several others, including the ISO 9660 filesystem used by
<span class="acronym">CD-ROM</span>.
<a name="INDEX-1420" /></p>

<p>Each of these filesystem types has a very different underlying format
for storing data. However, when you access any filesystem under Linux,
the system presents the data as files arranged into a hierarchy of
directories, along with owner and group IDs, permissions bits, and the
other characteristics you're familiar with.</p>

<p>In fact, information on file ownership, permissions, and so forth is
provided only by filesystem types that are meant to be used for
storing Linux files. For filesystem types that don't store this
information, the kernel drivers used to access these filesystems
"fake" the information.  For example, the
<span class="acronym">MS-DOS</span> filesystem has no concept of file ownership;
therefore, all files are presented as if they were owned by
root.  This way, above a certain
level, all filesystem types look alike, and each file has certain
attributes associated with it. Whether or not these data are actually
used in the underlying filesystem is another matter altogether.</p>

<p>As the system administrator, you need to know how to create
filesystems should you want to store Linux files on a floppy or add
additional filesystems to your hard drives. You also need to know
how to use the various tools to check and maintain filesystems should
data corruption occur. Also, you must know the commands and
files used to access filesystems, for example, those on floppy or
<span class="acronym">CD-ROM</span>.</p>

<a name="x-100-3-sec-sysadm-fs-types" /><div class="sect2">
<h3 class="sect2">6.1.1. Filesystem Types</h3>

<p><a name="INDEX-1421" />
<a href="ch06_01.htm">Table 6-1</a> lists the filesystem types
supported by the Linux kernel as of Version 2.2.2.  New filesystem
types are always being added to the system, and experimental drivers
for several filesystems not listed here are available. To find out
what filesystem types your kernel supports, look at the kernel source
tree, in the directory <em class="filename">/usr/src/linux/fs</em>. You can

select which filesystem types to support when building your kernel;
see the section "<a href="ch07_04.htm">Section 7.4.2, "Building the Kernel"</a>" in

<a href="ch07_01.htm">Chapter 7, "Upgrading Software and the Kernel"</a>.</p>

<a name="x-100-3-table-fs-types" /><h4 class="objtitle">Table 6-1. Linux Filesystem Types</h4><table border="1">

<tr>
<th>Filesystem</th>
<th>Type</th>
<th>Description</th>
</tr>




<tr>
<td rowspan="0">Second Extended filesystem</td>
<td rowspan="0"><em class="emphasis">ext2</em></td>
<td rowspan="0"><p>Most common Linux filesystem</p></td>
</tr>

<tr>
<td rowspan="0">Minix filesystem</td>
<td rowspan="0"><em class="emphasis">minix</em></td>
<td rowspan="0"><p>Original Minix filesystem; rarely used</p></td>
</tr>

<tr>
<td rowspan="0">ROM filesystem</td>
<td rowspan="0"><em class="emphasis">romfs</em></td>
<td rowspan="0"><p>A tiny read-only filesystem, mainly used for ramdisks</p></td>
</tr>

<tr>
<td rowspan="0">Network File System (<span class="acronym">NFS</span>)</td>
<td rowspan="0"><em class="emphasis"><span class="acronym">NFS</span></em></td>
<td rowspan="0"><p>Allows access to remote files on network</p></td>
</tr>

<tr>
<td rowspan="0"><span class="acronym">UMSDOS</span> filesystem</td>
<td rowspan="0"><em class="emphasis">umsdos</em></td>
<td rowspan="0"><p>Installs Linux on an <span class="acronym">MS-DOS</span> partition</p></td>
</tr>

<tr>
<td rowspan="0"><span class="acronym">DOS-FAT</span> filesystem</td>
<td rowspan="0"><em class="emphasis">msdos</em></td>
<td rowspan="0"><p>Accesses <span class="acronym">MS-DOS</span> files</p></td>
</tr>

<tr>
<td rowspan="0"><span class="acronym">VFAT</span> filesystem</td>
<td rowspan="0"><em class="emphasis">vfat</em></td>
<td rowspan="0"><p>Accesses Windows 95/98 files</p></td>
</tr>

<tr>
<td rowspan="0"><span class="acronym">NT</span> filesystem</td>
<td rowspan="0"><em class="emphasis">ntfs</em></td>
<td rowspan="0"><p>Accesses Windows <span class="acronym">NT</span> files</p></td>
</tr>

<tr>
<td rowspan="0"><span class="acronym">HPFS</span> filesystem</td>
<td rowspan="0"><em class="emphasis">hpfs</em></td>
<td rowspan="0"><p>OS/2 filesystem</p></td>
</tr>

<tr>
<td rowspan="0"><em class="filename">/proc</em> filesystem</td>
<td rowspan="0"><em class="emphasis">proc</em></td>
<td rowspan="0"><p>Provides process information for <tt class="command">ps</tt></p></td>
</tr>

<tr>
<td rowspan="0"><span class="acronym">ISO</span> 9660 filesystem</td>
<td rowspan="0"><em class="emphasis">iso9660</em></td>
<td rowspan="0"><p>Used by most <span class="acronym">CD-ROM</span>s</p></td>
</tr>

<tr>
<td rowspan="0">Joliet filesystem</td>
<td rowspan="0"><em class="emphasis">iso9660</em></td>
<td rowspan="0"><p>An extension to the <span class="acronym">ISO 9660</span>
  filesystem that can handle Unicode filenames</p></td>
</tr>

<tr>
<td rowspan="0">Xenix filesystem</td>
<td rowspan="0"><em class="emphasis">xenix</em></td>
<td rowspan="0"><p>Accesses files from Xenix</p></td>
</tr>

<tr>
<td rowspan="0">System V filesystem</td>
<td rowspan="0"><em class="emphasis">sysv</em></td>
<td rowspan="0"><p>Accesses files from System V variants</p></td>
</tr>

<tr>
<td rowspan="0">Coherent filesystem</td>
<td rowspan="0"><em class="emphasis">coherent</em></td>
<td rowspan="0"><p>Accesses files from Coherent</p></td>
</tr>

<tr>
<td rowspan="0"><span class="acronym">UFS</span> filesystem</td>
<td rowspan="0"><em class="emphasis">ufs</em></td>
<td rowspan="0"><p>Accesses files from <span class="acronym">UFS</span> filesystems,
  like those on <span class="acronym">SunOS</span> or <span class="acronym">BSD</span></p></td>
</tr>

<tr>
<td rowspan="0">ADFS filesystem</td>
<td rowspan="0"><em class="emphasis">adfs</em></td>
<td rowspan="0"><p>Accesses files from Acorn partitions</p></td>
</tr>

<tr>
<td rowspan="0">AFFS filesystem</td>
<td rowspan="0"><em class="emphasis">affs</em></td>
<td rowspan="0"><p>Accesses files from standard AmigaOS filesystem partitions</p></td>
</tr>

<tr>
<td rowspan="0">Apple Mac filesystem</td>
<td rowspan="0"><em class="emphasis">hfs</em></td>
<td rowspan="0"><p>Accesses files from Apple Macintosh</p></td>
</tr>

<tr>
<td rowspan="0">QNX4 filesystem</td>
<td rowspan="0"><em class="emphasis">qnx4</em></td>
<td rowspan="0"><p>Accesses files from a QNX4 partitions</p></td>
</tr>

<tr>
<td rowspan="0">Novell filesystem</td>
<td rowspan="0"><em class="emphasis">ncpfs</em></td>
<td rowspan="0"><p>Accesses files from a Novell server</p></td>
</tr>

<tr>
<td rowspan="0">SMB filesystem</td>
<td rowspan="0"><em class="emphasis">smbfs</em></td>
<td rowspan="0"><p>Accesses files from a Windows for Workgroups or Windows NT server</p></td>
</tr>


</table>

<p>Each filesystem type has its own
attributes and limitations; for example, the <span class="acronym">MS-DOS</span>
<a name="INDEX-1422" />
filesystem restricts filenames to eight characters plus a
three-character extension and should be used only to access existing
<span class="acronym">MS-DOS</span> floppies or partitions. For most of your
<a name="INDEX-1423" />
work with Linux, you'll use the Second Extended filesystem, which was
developed primarily for Linux and supports 256-character filenames, a
4-terabyte maximum filesystem size, and a slew of other
goodies. Earlier Linux systems used the Extended
filesystem (no longer supported) and the
<a name="INDEX-1424" />
Minix filesystem. (The Minix filesystem was originally used for
several reasons. First of all, Linux was originally cross-compiled
under Minix. Also, Linus was quite familiar with the Minix filesystem,
and it was straightforward to implement in the original kernels.) The
Xia filesystem is no longer supported.</p>

<p>You will rarely need the ROM
<a name="INDEX-1425" />
		filesystem, which is very small, does not
		support write operations, and is meant to be used in ramdisks
		at system configuration, startup time, or even in EPROMS.</p>

<p><a name="INDEX-1426" />
The <span class="acronym">UMSDOS</span> filesystem is used to install Linux under a private
directory of an existing <span class="acronym">MS-DOS</span> partition. This is
a good way for new users to try out Linux without repartitioning. The
<a name="INDEX-1427" />
<span class="acronym">DOS-FAT</span> filesystem, on the other hand, is used to
access <span class="acronym">MS-DOS</span> files directly. Files on partitions
created with Windows 95 or 98 can be accessed via the
<span class="acronym">VFAT</span> filesystem, while the <span class="acronym">NTFS</span>
<a name="INDEX-1428" />
filesystem lets you access 
Windows <span class="acronym">NT</span> filesystems. The
<span class="acronym">HPFS</span> filesystem is used to access the OS/2
filesystem.
<a name="INDEX-1429" /></p>

<p><a name="INDEX-1430" />
<a name="INDEX-1431" />
<a name="INDEX-1432" />
<a name="INDEX-1433" />
With the <span class="acronym">CVF-FAT</span> extension to the
<span class="acronym">DOS-FAT</span> filesystem, it is possible to access
partitions that have been compressed with DoubleSpace/DriveSpace
from Microsoft or Stacker from Stac. See the file
<em class="filename">Documentation/filesystems/fat_cvf.txt</em> 
in the Linux kernel sources for further details.</p>

<p><a name="INDEX-1434" />
<a name="INDEX-1435" />
<a name="INDEX-1436" />
<em class="filename">/proc</em> is a virtual filesystem; that is, no
actual disk space is associated with it. See the <em class="filename">/proc</em> 
filesystem in 
<a href="ch05_01.htm">Chapter 5, "Essential System Management"</a>.<a href="#FOOTNOTE-27">[27]</a></p><blockquote>

<a name="FOOTNOTE-27" /><p>[27]Note that the <em class="filename">/proc</em> filesystem under Linux is not
the same format as the <em class="filename">/proc</em> filesystem under
<span class="acronym">SVR</span>4 (say, Solaris 2.x). Under
<span class="acronym">SVR</span>4, each running process has a single
"file" entry in <em class="filename">/proc</em>, which can be
opened and treated with certain <em class="emphasis">ioctl()</em> calls to obtain process information. On the contrary,
Linux provides most of its information in <em class="filename">/proc</em>
through <em class="emphasis">read()</em> and
<em class="emphasis">write()</em> requests.</p>

</blockquote>

<p><a name="INDEX-1437" />
<a name="INDEX-1438" />
<a name="INDEX-1439" />
<a name="INDEX-1440" />
The <span class="acronym">ISO</span> 9660 filesystem (previously known as the
High Sierra Filesystem and abbreviated <em class="emphasis">hsfs</em> on
other Unix systems), is used by most
<span class="acronym">CD-ROM</span>s.  Like <span class="acronym">MS-DOS</span>, this
filesystem type restricts filename length and stores only limited
information about each file. However, most <span class="acronym">CD-ROM</span>s
<a name="INDEX-1441" />
provide the Rock Ridge Extensions to <span class="acronym">ISO</span> 9660,
which allow the kernel filesystem driver to assign long filenames,
ownerships, and permissions to each file. The net result is that
accessing an <span class="acronym">ISO</span> 9660 <span class="acronym">CD-ROM</span>
under <span class="acronym">MS-DOS</span> gives you 8.3-format filenames,
but under Linux gives you the "true," complete
filenames.</p>

<p>In addition, Linux now supports the Microsoft Joliet
extensions to <span class="acronym">ISO</span> 9660 which can handle long
filenames made up of Unicode characters. This is not widely used now
but may become valuable in the future, because Unicode has been accepted 
internationally as the standard for encoding characters
of scripts world-wide.</p>

<p><a name="INDEX-1442" />
<a name="INDEX-1443" />
<a name="INDEX-1444" />
<a name="INDEX-1445" />
Next, we
have four filesystem types corresponding to other
Unix variants found on the personal computer:
UFS, Xenix, System V, and Coherent.  (The latter three are actually
handled by the 
same kernel driver, with slightly different parameters for each). If
you have filesystems created under one of these formats, you'll be
able to access the files from Linux.</p>

<p>Finally, there is a slew of filesystems for accessing
		data on partitions; these are created by operating systems other than the 
		<span class="acronym">DOS</span> and Unix
		families. Those filesystems support the Acorn Disk Filing
<a name="INDEX-1446" />
<a name="INDEX-1447" />
<a name="INDEX-1448" />
<a name="INDEX-1449" />
		System (ADFS), the AmigaOS filesystems (no floppy disk
		support except on Amigas), the Apple Mac HFS, and the QNX4 filesystem.
		Most of the specialized filesystems are useful only on
		certain hardware architectures; for instance,  you
		won't have hard disks formatted with
		the Amiga <span class="acronym">FFS</span> filesystem in an Intel machine. If you
		need one of those drivers, please read the information that
		comes with them; some are only in an experimental
		state.</p>

<a name="INDEX-1450" />
</div>




<a name="x-100-3-sec-sysadm-fs-mount" /><div class="sect2">
<h3 class="sect2">6.1.2. Mounting Filesystems</h3>

<p><a name="INDEX-1451" />
<a name="INDEX-1452" />
In order to access any filesystem under Linux, you must mount it
on a certain directory. This makes the files on the filesystem appear 
as though they reside in the given directory, allowing you to access them.</p>

<p><a name="INDEX-1453" />
The <tt class="command">mount</tt> command is used to do this and usually must
be executed as root. (As we'll
see later, ordinary users can use <tt class="command">mount</tt> if the
device is listed in the <em class="filename">/etc/fstab</em> file.)  The
format of this command is:
<?troff-ps_indent0?>
<blockquote><pre class="code">mount -t <em class="replaceable">type</em> <em class="replaceable">device</em> <em class="replaceable">mount-point</em></pre></blockquote>


where <em class="replaceable">type</em> is the type name of the
filesystem as given in <a href="ch06_01.htm">Table 6-1</a>,
<em class="replaceable">device</em> is the physical device where the
filesystem resides (the device file in <em class="filename">/dev</em>), and
<em class="replaceable">mount-point</em> is the directory on which to mount the
filesystem.  You have to create the directory before issuing
<tt class="command">mount</tt>.</p>

<p>For example, if you have a Second Extended filesystem on
the partition <em class="filename">/dev/hda2</em>, and wish to mount it on the directory
<em class="filename">/mnt</em>, use the command:

<blockquote><pre class="code">mount -t ext2 /dev/hda2 /mnt</pre></blockquote>


If all goes well you should be able to access the filesystem 
under <em class="filename">/mnt</em>. Likewise, to mount a floppy that was created on a Windows system and
therefore is in <span class="acronym">DOS</span> format, you use the command:

<blockquote><pre class="code">mount -t msdos /dev/fd0 /mnt</pre></blockquote>


This makes the files available on an <span class="acronym">MS-DOS</span>
format floppy under <em class="filename">/mnt</em>.</p>

<p>There are many
options to the <tt class="command">mount</tt> command, which can be
specified with the <span class="option">-o</span> switch. For example, the
<span class="acronym">MS-DOS</span> and <span class="acronym">ISO</span> 9660 filesystems support
"auto-conversion" of text files from
<span class="acronym">MS-DOS</span> format (which contain <span class="acronym">CR-LF</span> at the end of
each line), to Unix format (which contain merely a
newline at the end of each line). Using a command such as:

<blockquote><pre class="code">mount -o conv=auto -t msdos /dev/fd0 /mnt</pre></blockquote>


turns on this conversion for files that don't have a filename
extension that could be associated with a binary file (such as
<em class="filename">.exe</em>, <em class="filename">.bin</em>, and so forth).</p>

<p><a name="INDEX-1454" />
<a name="INDEX-1455" />
<a name="INDEX-1456" />
One common option to mount is <span class="option">-o ro</span> (or,
equivalently, <span class="option">-r</span>), which mounts the
filesystem as read-only. All write access to such a filesystem is
met with a "permission denied" error. Mounting a
filesystem as read-only is necessary for media like
<span class="acronym">CD-ROM</span>s that are nonwritable. You can successfully mount
a <span class="acronym">CD-ROM</span> without the <span class="option">-r</span>
option, but you'll get the annoying warning message:

<blockquote><pre class="code">mount: block device /dev/cdrom is write-protected, mounting read-only</pre></blockquote>

<?troff .ne 10?>
Use a command such as:

<blockquote><pre class="code">mount -t iso9660 -r /dev/cdrom /mnt</pre></blockquote>


instead. This is also necessary if you are trying to mount a floppy that
has the write-protect tab in place.</p>

<p>The <tt class="command">mount</tt> manual page lists all available mounting
options. Not all are of immediate
interest, but you might have a need for some of them, someday.</p>

<p><a name="INDEX-1457" />
<a name="INDEX-1458" />
The inverse of mounting a filesystem is, naturally, unmounting it.
Unmounting a filesystem has two effects: it synchronizes the system's buffers
with the actual contents of the filesystem on disk, and it makes the
filesystem no longer available from its mount point.  You are then
free to mount another filesystem on that mount point.</p>

<p><a name="INDEX-1459" />
Unmounting is done with the <tt class="command">umount</tt> command (note
that the first "n" is missing from the word
"unmount"), as in:

<blockquote><pre class="code">umount /dev/fd0</pre></blockquote>


to unmount the filesystem on <em class="filename">/dev/fd0</em>. Similarly,
to unmount whatever filesystem is currently mounted on a particular
directory, use a command such as:

<blockquote><pre class="code">umount /mnt</pre></blockquote></p>

<p>
<img src="figs/bomb.gif">&nbsp;&nbsp;It is important to note that removable media, including floppies and
<span class="acronym">CD-ROM</span>s, should not be removed from the drive or
swapped for another disk while mounted. This causes the system's
information on the device to be out of sync with what's actually
there and could lead to no end of trouble. Whenever you want to

switch a floppy or <span class="acronym">CD-ROM</span>, unmount it first, using
the <tt class="command">umount</tt> command, and then remount the device.</p>

<p><a name="INDEX-1460" />
Reads and writes to filesystems on floppies are buffered in memory as
they are for hard drives. This means that when you read or write data
to a floppy, there may not be any immediate drive activity. The system
handles I/O on the floppy asynchronously and reads or writes data
only when absolutely necessary. So if you copy a small file to a
floppy, but the drive light doesn't come on, don't panic; the
data will be written eventually. You can use the <tt class="command">sync</tt> 
<a name="INDEX-1461" />
command to force the system to write all filesystem buffers to disk, causing
a physical write of any buffered data. Unmounting a filesystem makes
this happen as well.</p>

<p>If you wish to allow mortal users to mount and unmount certain
devices, you have two options. The first option is to include the
<tt class="literal">user</tt> option for the device in
<em class="filename">/etc/fstab</em> (described later in this
section). This allows any user to use the <tt class="command">mount</tt>
and <tt class="command">umount</tt> command for a given device. Another
option is to use one of the mount frontends available for
Linux. These programs run setuid root and allow ordinary users to mount
certain devices. In general, you wouldn't want normal users mounting
and unmounting a hard drive partition, but use of
<span class="acronym">CD-ROM</span> and floppy drives might be more lenient on
your system.</p>

<p>There are quite a few things that can go wrong when attempting to
mount a filesystem. Unfortunately, the <tt class="command">mount</tt>
command will give you the same error message in response to a number
of problems:

<blockquote><pre class="code">mount: wrong fs type, /dev/cdrom already mounted, /mnt busy, or other error</pre></blockquote>


<a name="INDEX-1462" />
<tt class="literal">wrong fs type</tt> is simple enough: this means that you
may have specified the wrong type to
<tt class="command">mount</tt>. If you don't specify a type,
<tt class="command">mount</tt> tries to guess the filesystem type from the
superblock (this only works for <em class="emphasis">minix</em>,
<em class="emphasis">ext</em>, <em class="emphasis">ext2</em>,
<em class="emphasis">xia</em> and <em class="emphasis">iso9660</em>). If
<tt class="command">mount</tt> 
still cannot determine the type of the filesystem, it tries all the
types for which drivers are included in the kernel (as listed in
<em class="filename">/proc/filesystems</em>). If this still does
not lead to success, <tt class="command">mount</tt> fails. <em class="replaceable">device</em> <tt class="literal">already mounted</tt> means just that: the device is 
already mounted on another directory. You can find out what devices are 
mounted, and where, using the <tt class="command">mount</tt> command with no arguments:

<blockquote><pre class="code">rutabaga# <tt class="userinput"><b>mount</b></tt> 
/dev/hda2 on / type ext2 (rw) 
/dev/hda3 on /msdos type msdos (rw) 
/dev/cdrom on /cdrom type iso9660 (ro) 
/proc on /proc type proc (rw,none)</pre></blockquote>


Here, we see two hard-drive partitions, one of type
<em class="filename">ext2</em> and the other of type
<em class="emphasis">msdos</em>, a <span class="acronym">CD-ROM</span> mounted on
<em class="filename">/cdrom</em>, and the <em class="filename">/proc</em>
filesystem. The last field of each line (for example,
<tt class="literal">(rw)</tt>) lists the options under which the filesystem
is mounted.  More on these soon.
<a name="INDEX-1463" />
Note that the <span class="acronym">CD-ROM</span> device is mounted in
<em class="filename">/cdrom</em>. If you use your <span class="acronym">CD-ROM</span>
often, it's convenient to create the directory
<em class="filename">/cdrom</em> and mount the device
there. <em class="filename">/mnt</em> is generally used to temporarily
mount filesystems such as floppies.</p>

<p><a name="INDEX-1464" />
The error <em class="replaceable">mount-point</em>
<tt class="literal">busy</tt> is rather odd. Essentially, it means
there is some activity taking place under
<em class="replaceable">mount-point</em> that prevents you from mounting
a filesystem there. Usually, this means that there is an open file
under this directory, or some process has its current working
directory beneath <em class="replaceable">mount-point</em>.  When using
<tt class="command">mount</tt>, be sure your root shell is not within
<em class="replaceable">mount-point</em>; do a <tt class="command">cd /</tt>
to get to the top-level directory.  Or, another filesystem could be
mounted with the same <em class="replaceable">mount-point</em>.  Use
<tt class="command">mount</tt> with no arguments to find out.</p>

<p>Of course, <tt class="literal">other error</tt> isn't very helpful. There
are several other cases in which <tt class="command">mount</tt> could
fail. If the filesystem in question has data or media errors of some
kind, <tt class="command">mount</tt> may report it is unable to read
<a name="INDEX-1465" />
the filesystem's <em class="emphasis">superblock</em>, which is (under
Unix-like filesystems) the portion of the
filesystem that stores information on the files and attributes for
the filesystem as a whole. If you attempt to mount a
<span class="acronym">CD-ROM</span> or floppy, and there's no
<span class="acronym">CD-ROM</span> or floppy in the drive, you will receive an
error message such as:

<blockquote><pre class="code">mount: /dev/cdrom is not a valid block device</pre></blockquote>

<?troff .ne 10?>
Floppies are especially prone to physical defects (more so than you
might initially think), and <span class="acronym">CD-ROM</span>s suffer from
dust, scratches, and fingerprints, as well as being inserted upside-down--that kind
of thing.  (If you attempt to mount your Stan Rogers CD as ISO 9660
format, you will likely run into similar problems.)</p>

<p>Also, be sure the mount point you're trying to use (such as
<em class="filename">/mnt</em>) exists. If not, you can simply create it
with the <tt class="command">mkdir</tt> command.</p>

<p>If you have problems mounting or accessing a filesystem, data on the
filesystem may be corrupt. There are several tools that help
repair certain filesystem types under Linux; see "<a href="ch06_01.htm">Section 6.1.5, "Checking and Repairing Filesystems"</a>" 
later in this chapter.</p>

<p><a name="INDEX-1466" />
<a name="INDEX-1467" />
The system automatically mounts several filesystems when the system
boots. This is handled by the file <em class="filename">/etc/fstab</em>,
which includes an entry for each filesystem that should be mounted at
boot time. Each line in this file is of the format:
<blockquote><pre class="code"><em class="replaceable">device</em> <em class="replaceable">mount-point</em> <em class="replaceable">type</em> <em class="replaceable">options</em></pre></blockquote></p>

<p>Here, <em class="replaceable">device</em>,
<em class="replaceable">mount-point</em>, and
<em class="replaceable">type</em> are equivalent to their meanings in
the <tt class="command">mount</tt> command, and
<em class="replaceable">options</em> is a comma-separated list of
options to use with the <span class="option">-o</span> switch
to <tt class="command">mount</tt>.</p>

<p><a name="INDEX-1468" />
<a name="INDEX-1469" />
A sample <em class="filename">/etc/fstab</em> is shown here:</p>

<blockquote><pre class="code"># device        directory       type      options
/dev/hda2       /               ext2      defaults
/dev/hda3       /msdos          msdos     defaults
/dev/cdrom      /cdrom          iso9660   ro
/proc           /proc           proc      none

/dev/hda1       none            swap      sw</pre></blockquote>

<p>The last line of this file specifies a swap partition. This is
described in the section "<a href="ch06_02.htm">Section 6.2, "Managing Swap Space"</a>." later in this chapter.</p>

<p>
The <tt class="command">mount</tt> manual page lists the possible values for <em class="replaceable">options</em>;
if you wish to specify more than one option, you can list them with
separating commas and no whitespace, as in:
<blockquote><pre class="code">/dev/cdrom      /cdrom          iso9660   ro,user</pre></blockquote>

The <tt class="literal">user</tt> option allows users other than root to mount
the filesystem. If this option is present, a user can execute a command
such as:
<blockquote><pre class="code">mount /cdrom</pre></blockquote>

to mount the device. Note that if you specify only a device or 
mount point (not both) to <tt class="command">mount</tt>, it looks up the device
or mount point in <em class="filename">/etc/fstab</em> and mounts the
device with the
parameters given there. This allows you to mount devices listed in
<em class="filename">/etc/fstab</em> with ease.</p>

<p>The option <tt class="literal">defaults</tt> should be used for most
filesystems; it enables a number of other options, such as <tt class="literal">rw</tt>
(read-write access), <tt class="literal">async</tt> (buffer I/O to the filesystem in
memory asynchronously), and so forth. Unless you have a specific need to
modify one of these parameters, use <tt class="literal">defaults</tt> for most filesystems,
and <tt class="literal">ro</tt> for read-only devices such as
<span class="acronym">CD-ROM</span>s. Another potentially useful option is
<tt class="literal">umask</tt> that lets you set the default mask for the
permission bits, something that is especially useful with some foreign 
filesystems.</p>

<p>The command <tt class="command">mount -a</tt> will mount all filesystems listed in
<em class="filename">/etc/fstab</em>. This command is executed at boot time by one
of the scripts found in <em class="filename">/etc/rc.d</em>, such as
<em class="filename">rc.sysinit</em> (or wherever your distribution stores 
its configuration files). 
This way, all filesystems listed in <em class="filename">/etc/fstab</em> will
be available when the system starts up; your hard drive
partitions, <span class="acronym">CD-ROM</span> drive, and so on will all be mounted.</p>

<p><a name="INDEX-1470" />
<a name="INDEX-1471" />
<a name="INDEX-1472" />

There is an exception to this: the <em class="emphasis">root
filesystem</em>. The root filesystem, mounted on
<em class="filename">/</em>, usually contains the file
<em class="filename">/etc/fstab</em> as well as the scripts in
<em class="filename">/etc/rc.d</em>.  In order for these to be available,
the kernel itself must mount the root filesystem directly at boot
time. The device containing the root filesystem is coded into the
kernel image and can be altered using the <tt class="command">rdev</tt>
command (see "<a href="ch05_02.htm">Section 5.2.1, "Using a Boot Floppy"</a>"
in

<a href="ch05_01.htm">Chapter 5, "Essential System Management"</a>).  While the system boots, the kernel
attempts to mount this device as the root filesystem, 
trying several filesystem types in succession (first Minix, then
Extended, and so forth). If at boot time, the kernel prints an error
message such as:
<blockquote><pre class="code">VFS: Unable to mount root fs</pre></blockquote>

one of the following has happened:</p>

<ul><li><p>
The root device coded into the kernel is incorrect.</p></li><li><p>
The kernel does not have support compiled in for the filesystem type
of the root device. (See "<a href="ch07_04.htm">Section 7.4.2, "Building the Kernel"</a>" in

<a href="ch07_01.htm">Chapter 7, "Upgrading Software and the Kernel"</a> for more
details. This is usually relevant only if you build your own kernel.)</p></li><li><p>
The root device is corrupt in some way.</p></li></ul><p>


In any of these cases, 
the kernel can't proceed and panics. See "<a href="ch08_06.htm">Section 8.6, "What to Do in an Emergency"</a>" in

<a href="ch08_01.htm">Chapter 8, "Other
 Administrative
 Tasks"</a>, for clues on what to do in
this situation. If filesystem corruption is the problem, this can
usually be repaired; see "<a href="ch06_01.htm">Section 6.1.5, "Checking and Repairing Filesystems"</a>" later in this chapter.</p>

<p>A filesystem does not need to be listed in <em class="filename">/etc/fstab</em> in order
to be mounted, but it does need to be listed there in order to be
mounted "automatically" by <tt class="command">mount -a</tt>, or to use the <tt class="literal">user</tt> 
mount option.</p>

<a name="INDEX-1473" /><a name="INDEX-1474" /><a name="INDEX-1475" />
</div>




<div class="sect2">
<h3 class="sect2">6.1.3. Automounting Devices</h3>

<p><a name="INDEX-1476" />
<a name="INDEX-1477" />
<a name="INDEX-1478" />
		If you need to access a lot of different filesystems,
		especially networked ones, you might be interested in a fairly 
		new addition to the Linux kernel: the
		<em class="emphasis">automounter</em>. This is a combination of
		kernel functionality, a daemon, and some configuration files
		that automatically detect when somebody wants to access a
		certain filesystem and mounts the filesystem transparently. When the
		filesystem is not used for some time, the automounter
		automatically unmounts it in order to save resources like
		memory and network throughput.</p>

<p>If you want to use the automounter, you first need to
		turn this feature on when building your kernel. (See "<a href="ch07_04.htm">Section 7.4.2, "Building the Kernel"</a>" in

<a href="ch07_01.htm">Chapter 7, "Upgrading Software and the Kernel"</a> for more
details.) You will also need to enable the NFS option.</p>

<p>Next, you need to start the
		<em class="emphasis">automount</em> daemon. Since this feature is
		quite new, your distribution
		might not yet have it. Look for the directory
<a name="INDEX-1479" />
<a name="INDEX-1480" />
		<em class="filename">/usr/lib/autofs</em>, if it is not 
		there, you will need to get the <em class="emphasis">autofs</em>
		package from your friendly Linux archive and compile and
		install it according to the instruction.</p>

<p>You can automount filesystems wherever you like, but
		for simplicity's sake, we will assume here that you want to
		automount all filesystems below one directory which we will
		call <em class="filename">/automount</em> here. If you want
		your automount points to be scattered over your
		filesystem, you will need to use multiple
		<tt class="command">automount</tt> daemons.</p>

<p>If you have compiled the <em class="emphasis">autofs</em>
		package yourself, it might be a good idea to start by copying
		the sample configuration files that you can find in
		<em class="filename">sample</em> directory, and adapt them to your
		needs. To do this, copy the files
		<em class="filename">sample/auto.master</em> and
		<em class="filename">sample/auto.misc</em> into the
		<em class="filename">/etc</em> directory, and the file
		<em class="filename">sample/rc.autofs</em> under the name
		<tt class="command">autofs</tt> wherever your distribution stores
		its boot scripts. We'll assume here that you use
		<em class="filename">/sbin/init.d</em>.</p>

<p>The first configuration file to edit is
		<em class="filename">/etc/auto.master</em>. This lists all
		the directories (the so-called <em class="emphasis">mount
		points</em>) below which the automounter should mount
		partitions. Since we have decided to use only one
		partition in this chapter's example, we will
		need to make only one entry here. The file could look like
		this:</p>

<blockquote><pre class="code">/automount	/etc/auto.misc</pre></blockquote>

<p>This file consists of lines with two entries each,
		separated by whitespace. The first entry specifies the mount
		point, and the second entry names a so-called <em class="emphasis">map
		file</em> that specifies how and where to mount the devices or partitions
		to be automounted. You need one such map
		file for each mount point.</p>

<p>In our case, the file
		<em class="filename">/etc/auto.misc</em> looks like the
		following:</p>

<blockquote><pre class="code">cd		-fstype=iso9660,ro	:/dev/scd0
floppy		-fstype=auto		:/dev/fd0</pre></blockquote>

<p>Again, this file consists of one-line entries that
		each specify one particular device
		or partition to be automounted. The lines have
		two mandatory and one optional field, separated by
		whitespaces. The first value is mandatory and specifies the
		directory, onto which the device or partition of this entry is 
		automounted. This value is appended to the mount point so that 
		the <span class="acronym">CD-ROM</span> will be automounted onto
		<em class="filename">/automount/cd</em>.</p>

<p>The second value is optional and specifies flags to be
		used for the <tt class="command">mount</tt> operation. These are
		equivalent to those for the <tt class="command">mount</tt> command
		itself, with the exception that the type is specified with the 
		option <span class="option">-fstype=</span> instead of
		<span class="option">-T</span>.</p>

<p>Finally, the third value specifies the partition or
		device to be mounted. In our case, we specify the first
		<span class="acronym">SCSI</span> <span class="acronym">CD-ROM</span> drive and
		the first floppy drive, respectively. The colon in front of
		the entry is mandatory; it separates the host part from the
		device/directory part, just as with
		<tt class="command">mount</tt>. Since those two devices are on a
		local machine, there is nothing to the left of the colon. If we
		wanted to automount the directory
		<em class="filename">sources</em> from the <span class="acronym">NFS</span>
		server sourcemaster,
		we would specify something like:</p>

<blockquote><pre class="code">sources    -fstype=nfs,soft    sourcemaster:/sources</pre></blockquote>

<p>After editing the configuration files to reflect
		your system, you can start the automount daemon by issuing
		(replace the path with the path that suits your
		system):</p>

<blockquote><pre class="code">tigger# <tt class="userinput"><b>/sbin/init.d/autofs start</b></tt></pre></blockquote>

<p>Since this command is very taciturn, you should check
		whether the automounter has really started. One way
		to do this is to issue:</p>

<blockquote><pre class="code">tigger# <tt class="userinput"><b>/sbin/init.d/autofs status</b></tt></pre></blockquote>

<p>but it is difficult to determine from the output whether 
		the automounter is really running. Your best bet,
		therefore, is to check whether the <tt class="command">automount</tt>
		process exists:</p>

<blockquote><pre class="code">tigger# <tt class="userinput"><b>ps -aux | grep automount </b></tt></pre></blockquote>

<p>If this command shows the automount process, everything
		should be all right. If it doesn't, you need to check your
		configuration files again. It could also be the case that the 
		necessary kernel support is not available: either the
		automount support is not in your kernel, or you have compiled
		it as a module but not installed this module. If the latter is 
		the case, you can fix the problem by issuing:</p>

<blockquote><pre class="code">tigger# <tt class="userinput"><b>modprobe autofs</b></tt></pre></blockquote>

<p>When your automounter works to your satisfaction, you
		might want to put the <tt class="command">modprobe</tt> call as well 
		as the <tt class="command">autofs</tt> call in one of your system's
		startup configuration files like
		<em class="filename">/etc/rc.local</em>,
		<em class="filename">/sbin/init.d/boot.local</em> or whatever your
		distribution uses.</p>

<p>If everything is correctly set up, all you need to do is
		access some directory below the mount point, and the
		automounter will mount the appropriate device or partition for 
		you. For example, if you type:</p>

<blockquote><pre class="code">tigger$ <tt class="userinput"><b>ls /automount/cd</b></tt></pre></blockquote>

<p>the automounter will automatically mount the
		<span class="acronym">CD-ROM</span>, so that <tt class="command">ls</tt> can
		list its contents. The only difference between normal and automounting is that with automounting you will notice is a slight delay, before the output
		comes.</p>

<p>In order to conserve resources, the automounter
		unmounts a partition or device if it has not been accessed for 
		a certain amount of time (the default is five minutes).</p>

<p>The automounter supports a number of advanced options;
		for example, you do not need to read the map table from a
		file but can also access system databases or even have the
		automounter run a program and use this program's output as the 
		mapping data. See the man pages for <tt class="command">autofs</tt>
		and <tt class="command">automount</tt> for further details.</p>

<a name="INDEX-1481" /><a name="INDEX-1482" /><a name="INDEX-1483" />
</div>




<a name="x-100-3-sec-sysadm-fs-create" /><div class="sect2">
<h3 class="sect2">6.1.4. Creating Filesystems</h3>

<p><a name="INDEX-1484" />
<a name="INDEX-1485" />
A filesystem can be created using the <tt class="command">mkfs</tt> command. Creating a 
filesystem is analogous to "formatting" a partition or floppy, allowing
it to store files.</p>

<p>Each filesystem type has its own
<tt class="command">mkfs</tt> command associated with it--for example,
<span class="acronym">MS-DOS</span> filesystems may be created using
<tt class="command">mkfs.msdos</tt>, Second Extended filesystems using
<tt class="command">mkfs.ext2</tt>, and so on.  The program
<tt class="command">mkfs</tt> itself is a frontend that creates a
filesystem of any type by executing the appropriate version of
<tt class="command">mkfs</tt> for that type.<a href="#FOOTNOTE-28">[28]</a></p><blockquote>

<a name="FOOTNOTE-28" /><p>[28]Under Linux the
<tt class="command">mkfs</tt> command historically created a Minix filesystem. 
On newer
Linux systems, <tt class="command">mkfs</tt> is a frontend for any
filesystem type, and Minix filesystems are created using
<tt class="command">mkfs.minix</tt>.</p>

</blockquote>

<p>When you installed Linux, you may have created filesystems by hand
using a command such as <tt class="command">mke2fs</tt>. (If not, then the
installation software created the filesystems for you.) In fact,
<tt class="command">mke2fs</tt> is equivalent to
<tt class="command">mkfs.ext2</tt>. The programs are the same (and on many
systems, one is a symbolic link to the other), but the
<em class="filename">mkfs.</em><em class="replaceable">fs-type</em> filename
makes it easier for <tt class="command">mkfs</tt> to execute the
appropriate filesystem-type specific program. If you don't have the
<tt class="command">mkfs</tt> frontend, you can use
<tt class="command">mke2fs</tt> or <tt class="command">mkfs.ext2</tt> directly.</p>

<p>Assuming that you're using the <tt class="command">mkfs</tt> frontend, a
filesystem can be created using this command:

<blockquote><pre class="code">mkfs -t <em class="replaceable">type</em> <em class="replaceable">device</em> <em class="replaceable">blocks</em></pre></blockquote>


where <em class="replaceable">type</em> is the type of filesystem to
create, given in <a href="ch06_01.htm">Table 6-1</a>,
<em class="replaceable">device</em> is the device on which to create the
filesystem (such as <em class="filename">/dev/fd0</em> for a floppy), and
<em class="replaceable">blocks</em> is the size of the filesystem, in
1024-byte blocks.</p>

<p>For example, to create an <em class="emphasis">ext2</em> filesystem on a
floppy, you use this command:

<blockquote><pre class="code">mkfs -t ext2 /dev/fd0 1440</pre></blockquote>


Here, <em class="replaceable">blocks</em> is 1440, which specifies a
1.44-MB, high-density 3.5-inch floppy.  You could create an
<span class="acronym">MS-DOS</span> floppy using <span class="option">-t
msdos</span> instead.</p>

<p>We can now mount the floppy, as described in the previous section,
copy files to it, and so forth. Remember to unmount the floppy before
removing it from the drive.</p>

<p>
<img src="figs/bomb.gif">&nbsp;&nbsp; Creating a filesystem deletes all
data on the corresponding physical device (floppy, hard-drive
partition, whatever). <tt class="command">mkfs</tt> usually does
not prompt you before creating a filesystem, so
be absolutely sure you know what you're doing.</p>

<p><a name="INDEX-1486" />
<a name="INDEX-1487" />
Creating a filesystem on a hard-drive partition is done exactly as
shown earlier, except that you would use the partition name, such as
<tt class="command">/dev/hda2</tt>, as the
<em class="replaceable">device</em>. Don't try to create a filesystem on
a device, such as <tt class="command">/dev/hda</tt>. This refers to the
entire drive, not just a single partition on the drive. You can create
partitions using <tt class="command">fdisk</tt>, as described

in the section "<a href="ch03_01.htm">Section 3.1.3, "Creating Linux Partitions"</a>" in
<a href="ch03_01.htm">Chapter 3, "Installation
 and Initial
 Configuration"</a>.</p>

<p>You should be especially careful when creating filesystems
on hard-drive partitions. Be absolutely sure that the <em class="replaceable">device</em>
and <em class="replaceable">size</em> arguments are correct. If you enter the wrong
<em class="replaceable">device</em>, you could end up destroying the data on your current
filesystems, and if you specify the wrong <em class="replaceable">size</em>, you could overwrite
data on other partitions. Be sure that <em class="replaceable">size</em> corresponds to
the partition size as reported by Linux <tt class="command">fdisk</tt>.</p>

<p><a name="INDEX-1488" />
When creating filesystems on floppies, it's usually best to do a
low-level format first. This lays down the sector and
track information on the floppy so that its size can be automatically
detected using the devices <em class="filename">/dev/fd0</em> or
<em class="filename">/dev/fd1</em>. 
One way to do a low-level format is with the <span class="acronym">MS-DOS</span>
<span class="acronym">FORMAT</span>
command; another way is with the Linux program
<tt class="command">fdformat</tt>.<a href="#FOOTNOTE-29">[29]</a>
For example, to format the floppy in the first floppy drive,
use the command:
<blockquote><pre class="code">rutabaga# <tt class="userinput"><b>fdformat /dev/fd0</b></tt>
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB. 
Formatting ... done 
Verifying ... done</pre></blockquote>

Using the <span class="option">-n</span> option with <tt class="command">fdformat</tt> will skip the verification
step.</p><blockquote>

<a name="FOOTNOTE-29" /><p>[29]Debian users should use
<tt class="command">superformat</tt> instead.</p>

</blockquote>

<p>Each filesystem-specific version of <tt class="command">mkfs</tt> supports
several options you might find useful. Most types support the
<span class="option">-c</span> option, which causes the physical media to
be checked for bad blocks while creating the filesystem. If bad blocks
are found, they are marked and avoided when writing data to the
filesystem. In order to use these type-specific options, include them
after the <span class="option">-t</span> <em class="replaceable">type</em>
option to <tt class="command">mkfs</tt>, as follows:

<blockquote><pre class="code">mkfs -t <em class="replaceable">type</em> -c <em class="replaceable">device</em> <em class="replaceable">blocks</em></pre></blockquote>


To determine what options are available, see the manual page for the
type-specific version of <tt class="command">mkfs</tt>. (For example, for the Second
Extended filesystem, see <tt class="command">mke2fs</tt>.)</p>

<p>You may not have all available type-specific versions of <tt class="command">mkfs</tt> 
installed. If this is the case, <tt class="command">mkfs</tt> will fail when you try to
create a filesystem of a type for which you have no <em class="filename">mkfs.</em><em class="replaceable">type</em>.
Many filesystem types supported by Linux have a corresponding
<em class="filename">mkfs.</em><em class="replaceable">type</em> available, somewhere.</p>

<p>If you run into trouble using <tt class="command">mkfs</tt>, it's possible
that Linux is having problems accessing the physical device. In the
case of a floppy, this might just mean a bad floppy. In the case of a
hard drive, it could be more serious; for example, the disk device
driver in the kernel might be having problems reading your drive. This
could be a hardware problem or a simple matter of your drive geometry
being specified incorrectly.  See the manual pages for the various
versions of <tt class="command">mkfs</tt>, and read the

sections in <a href="ch03_01.htm">Chapter 3, "Installation
 and Initial
 Configuration"</a> on troubleshooting installation 
problems. They apply equally here.<a href="#FOOTNOTE-30">[30]</a></p><blockquote>

<a name="FOOTNOTE-30" /><p>[30]Also, the procedure
for making an ISO9660 filesystem for a <span class="acronym">CD-ROM</span> is
more complicated than simply formatting a filesystem and copying
files. See the CD-Writing HOWTO for more details.</p>

</blockquote>

<a name="INDEX-1489" />
</div>




<a name="x-100-3-sec-sysadm-fs-fsck" /><div class="sect2">
<h3 class="sect2">6.1.5. Checking and Repairing Filesystems</h3>

<p><a name="INDEX-1490" />
<a name="INDEX-1491" />
<a name="INDEX-1492" />
<a name="INDEX-1493" />
<a name="INDEX-1494" />
<a name="INDEX-1495" />

It is sometimes necessary to check your Linux filesystems for consistency
and repair them if there are any errors or lost data. Such errors commonly
result from a system crash or loss of power, where the kernel isn't able
to sync the filesystem buffer cache with the contents of the disk. In most
cases, such errors are relatively minor. However, if the system were to 
crash while writing a large file, that file may be lost and the blocks
associated with it marked as "in use," when in fact there is no file
entry corresponding to them. In other cases, errors can be caused by
accidentally writing data directly to the hard-drive device (such as
<em class="filename">/dev/hda</em>), or one of the partitions.</p>

<p> 
The program <tt class="command">fsck</tt> is used to check filesystems and
correct any problems. Like <tt class="command">mkfs</tt>,
<tt class="command">fsck</tt> is a frontend for a
filesystem-type-specific
<em class="filename">fsck.</em><em class="replaceable">type</em>, such as
<tt class="command">fsck.ext2</tt> for Second Extended filesystems. (As with
<tt class="command">mkfs.ext2</tt>, <tt class="command">fsck.ext2</tt> is a
symbolic link to <tt class="command">e2fsck</tt>, either of which you could
execute directly if the <tt class="command">fsck</tt> frontend is not
installed.)</p>

<p>Use of <tt class="command">fsck</tt> is quite simple; the format of the command is:
<blockquote><pre class="code">fsck -t <em class="replaceable">type</em> <em class="replaceable">device</em></pre></blockquote>

where <em class="replaceable">type</em> is the type of filesystem to repair, as given
in <a href="ch06_01.htm">Table 6-1</a>, and <em class="replaceable">device</em> is the device
(drive partition or floppy) on which the filesystem resides.</p>

<p>For example, to check an <tt class="command">ext2</tt> filesystem on <em class="filename">/dev/hda2</em>,
you use:
<blockquote><pre class="code">rutabaga# <tt class="userinput"><b>fsck -t ext2 /dev/hda2</b></tt>
Parallelizing fsck version 1.06 (7-Oct-96)
e2fsck 1.06, 7-Oct-96 for EXT2 FS 0.5b, 95/08/09     
/dev/hda2 is mounted.  Do you really want to continue (y/n)? <tt class="userinput"><b>yes</b></tt>
 
/dev/hda2 was not cleanly unmounted, check forced.
Pass 1: Checking inodes, blocks, and sizes 
Pass 2: Checking directory structure 
Pass 3: Checking directory connectivity 
Pass 4: Check reference counts. 
Pass 5: Checking group summary information. 
 
Free blocks count wrong for group 3 (3331, counted=3396).  FIXED 
Free blocks count wrong for group 4 (1983, counted=2597).  FIXED 
Free blocks count wrong (29643, counted=30341).  FIXED 
Inode bitmap differences: -8280.  FIXED 
Free inodes count wrong for group #4 (1405, counted=1406).  FIXED 
Free inodes count wrong (34522, counted=34523).  FIXED 
 
/dev/hda2: ***** FILE SYSTEM WAS MODIFIED ***** 
/dev/hda2: ***** REBOOT LINUX ***** 
/dev/hda2: 13285/47808 files, 160875/191216 blocks</pre></blockquote></p>

<p> 
First of all, note that the system asks for confirmation before checking
a mounted filesystem. If any errors are found and corrected while using
<tt class="command">fsck</tt>, you'll have to reboot the system if the filesystem is mounted.
This is because the changes made by <tt class="command">fsck</tt> may not be propagated
back to the system's internal knowledge of the filesystem layout.
In general, it's not a good idea to check mounted filesystems.</p>

<p>As we can see, several problems were found and corrected, and because
this filesystem was mounted, the system informed us that the machine
should be rebooted.</p>

<p>How can you check filesystems without mounting them? With the exception
of the root filesystem, you can simply <tt class="command">umount</tt> any filesystems before
running <tt class="command">fsck</tt> on them. The root filesystem, however, can't be
unmounted while running the system. One way to check your root
filesystem while it's unmounted is 
to use a boot/root floppy combination, such as the installation floppies
used by your Linux distribution. This way, the root filesystem is 

contained on a floppy, and the root filesystem (on your hard drive)
remains unmounted, and you can check the hard-drive root filesystem from there. See 
"<a href="ch08_06.htm">Section 8.6, "What to Do in an Emergency"</a>" in
<a href="ch08_01.htm">Chapter 8, "Other
 Administrative
 Tasks"</a>
for more details about this.</p>

<p><a name="INDEX-1496" />
Another way to check the root filesystem is to mount it read-only. 
This can be done using the option <tt class="literal">ro</tt> from the LILO
boot prompt 

(see the section "<a href="ch05_02.htm">Section 5.2.2.3, "Specifying boot time options"</a>" in <a href="ch05_01.htm">Chapter 5, "Essential System Management"</a>). However, other parts of your system
configuration (for example, the programs executed by
<em class="filename">/etc/init</em> at boot time) may require write access
to the root filesystem, so you can't boot the system normally or these
programs will fail. To boot the system with the root filesystem
mounted as read-only you might want to boot the system into
single-user mode as well (using the boot option
<tt class="literal">single</tt>). This prevents additional system
configuration at boot time; you can then check the root filesystem and
reboot the system normally.</p>

<p>To cause the root filesystem to be mounted read-only, you can either
use the <tt class="literal">ro</tt> boot option, or use <tt class="command">rdev</tt> to set the read-only
flag in the kernel image itself.</p>

<p><a name="INDEX-1497" /> 
Many Linux systems automatically check the filesystems at boot time.
This is usually done by executing <tt class="command">fsck</tt> from
<em class="filename">/etc/rc.d/rc.sysinit</em>. When this is done, the
system usually mounts the root filesystem initially as read-only, runs
<tt class="command">fsck</tt> to check it, and then runs the command:

<blockquote><pre class="code">mount -w -o remount /</pre></blockquote>


The <span class="option">-o remount</span> option causes the given
filesystem to be remounted with the new parameters; in
this case, the <span class="option">-w</span> option (equivalent to
<span class="option">-o rw</span>) causes the filesystem to be mounted
read-write. The net result is that the root filesystem is remounted
with read-write access.</p>

<p>When <tt class="command">fsck</tt> is executed at boot time, it checks all filesystems other
than root before they are mounted. Once <tt class="command">fsck</tt> completes,
the other filesystems are mounted using <tt class="command">mount</tt>. Check out the
files in <em class="filename">/etc/rc.d</em>, especially <em class="filename">rc.sysinit</em> (if present on your
system), to see how this is done. If you want to disable this feature
on your system, comment out the lines in the appropriate <em class="filename">/etc/rc.d</em>
file that execute <tt class="command">fsck</tt>.</p>

<p>There are several options you can pass to the type-specific 
<tt class="command">fsck</tt>. Most types support the options
<span class="option">-a</span>, which automatically confirms any prompts
that <em class="filename">fsck.</em><em class="replaceable">type</em> may
display; <span class="option">-c</span>, which does bad-block checking, as
with <tt class="command">mkfs</tt>; and <span class="option">-v</span>, which
prints verbose information during the check operation. These options
should be given after the <span class="option">-t</span>
<em class="replaceable">type</em> argument to <tt class="command">fsck</tt>,
as in:
<blockquote><pre class="code">fsck -t <em class="replaceable">type</em> -v <em class="replaceable">device</em></pre></blockquote>

to run <tt class="command">fsck</tt> with verbose output.</p>

<p>See the manual pages for <tt class="command">fsck</tt> and <tt class="command">e2fsck</tt> for more information.</p>

<p>Not all filesystem types supported by Linux have a
<tt class="command">fsck</tt> variant available. To check and repair
<span class="acronym">MS-DOS</span> filesystems, you
should use a tool under <span class="acronym">MS-DOS</span>, such as the Norton
Utilities, to accomplish
this task. You should be able to find versions of <tt class="command">fsck</tt> for
the Second Extended filesystem, Minix filesystem, and Xia filesystem at least.</p>

<p>
In the section "<a href="ch08_06.htm">Section 8.6, "What to Do in an Emergency"</a>" in
<a href="ch08_01.htm">Chapter 8, "Other
 Administrative
 Tasks"</a>,
we provide additional information on checking filesystems and recovering
from disaster. <tt class="command">fsck</tt> will by no means catch and repair every error
to your filesystems, but most common problems should be handled. If you
delete an important file, there is currently no easy way to recover 
it--<tt class="command">fsck</tt> can't do that for you. There is work underway to 
provide an "undelete" utility in the Second extended filesystem. 
Be sure to keep backups, or use <tt class="command">rm -i</tt>, which always prompts you before
deleting a file.</p>

<a name="INDEX-1498" /><a name="INDEX-1499" /><a name="INDEX-1500" /><a name="INDEX-1501" /><a name="INDEX-1502" /><a name="INDEX-1503" /><a name="INDEX-1504" />
</div>
</div>




















<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch05_07.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch06_02.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">5.7. Managing User Accounts</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">6.2. Managing Swap Space</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="index.htm" coords="172,2,252,105" shape="rect" /><area href="../apache/index.htm" coords="238,2,334,95" shape="rect" /><area href="../sql/index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="../cgi/index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>