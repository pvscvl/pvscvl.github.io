<?label 1.4. System Features?><html><head><title>System Features (Running Linux)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="Running Linux" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch01_03.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm" /></td><td width="172" valign="top" align="right"><a href="ch01_05.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<h2 class="sect1">1.4. System Features</h2>

<p><a name="INDEX-411" />
Linux supports most of the features found in other implementations of
Unix, plus quite a few not found
elsewhere. This section is a nickel tour of the Linux kernel features.</p>

<div class="sect2">
<h3 class="sect2">1.4.1. A Note on Linux Version Numbers</h3>

<p><a name="INDEX-412" />
<a name="INDEX-413" />
One potentially confusing aspect of Linux for newcomers is the way in
which different pieces of software are assigned a version number.
When you first approach Linux, chances are you'll be looking at a
CD-ROM distribution, such as "Red Hat Version 5.2" or
"SuSE Linux Version 6.0." It's important to understand
that these version numbers only relate to the particular distribution
(which is a prepackaged version of Linux along with tons of free
application packages, usually sold on CD-ROM). Therefore, the version
number assigned by Red Hat, SuSE, or Debian might not have anything to do
with the individual version numbers of the software in that distribution.
Don't be fooled--just because one distribution company uses a
higher version number than another doesn't mean that the software is any more
up-to-date.</p>

<p>The Linux kernel, as well as each application, component, library, or
software package in a Linux distribution, generally has its
<em class="emphasis">own</em> version number. For example,
you might be using <tt class="command">gcc</tt> Version 2.7.2.3, as well as
the XFree86 graphical user interface Version 3.3.1. As you can guess,
the higher the version number, the newer the software is. By installing
a distribution (such as Red Hat and SuSE), all of this is simplified
for you since the latest versions of each package are usually included
in the distribution.</p>

<p>The Linux kernel has a peculiar version numbering scheme that you should
be familiar with. As mentioned before, the kernel is the core operating
system itself, responsible for managing all of the hardware resources in
your machine--such as disks, network interfaces, memory, and so on.
Unlike Windows systems, the Linux kernel doesn't include any application-level
libraries or graphical user interfaces. In some sense, as a
user you will never interact with the kernel directly, but rather through
interfaces such as the shell or the GUI (more on
this later).</p>

<p>However, many people still consider the Linux kernel version to be the
version of the "entire system," which is somewhat misleading.
Someone might say, "I'm running kernel Version 2.3.32," but
this doesn't mean much if everything else on the system is years out of
date.</p>

<p>The Linux kernel versioning system works as follows. At any given time,
there are <em class="emphasis">two</em> "latest" versions of
the kernel out there (meaning available for download from the Internet)--the "stable" and "development" releases.
The stable release is meant for most Linux users who aren't interested
in hacking on bleeding-edge experimental features, but who need a stable, working
system that isn't changing underneath them from day to day. The development
release, on the other hand, changes very rapidly as new features are
added and tested by developers across the Internet. Changes to the stable
release consist mostly of bug fixes and security patches, while changes
to the development release
can be anything from major new kernel subsystems to minor tweaks in a
device driver for added performance. The Linux developers don't guarantee
that the development kernel version will work for everyone, but they do maintain
the stable version with the intention of making it run well everywhere.</p>

<p>The stable kernel release has an even minor version number (such as
2.2), while the development release has an odd minor version number
(such as 2.3). Note that the current development kernel always has
a minor version number exactly one greater than the current stable
kernel. So, when the current stable kernel is 2.4, the current
development kernel will be 2.5. (Unless, of course, Linus decides to
rename Version 2.4 to 3.0--in which case the development
version will be 3.1, naturally).</p>

<p>Each of these kernel versions has a third "patch level"
version number associated with it, such as 2.2.19 or 2.3.85. The
patch level specifies the particular revision of that kernel version,
with higher numbers specifying newer revisions. As of the time of
this writing in July 1999, the latest stable kernel is 2.2.10 and
the latest development kernel is 2.3.11.</p>
</div>




<div class="sect2">
<h3 class="sect2">1.4.2. A Bag of Features</h3>

<p><a name="INDEX-414" />
Linux is a complete multitasking, multiuser operating system (just
like all other versions of Unix). This means that
many users can be logged into the same machine at once, running
multiple programs simultaneously.  Linux also supports multiprocessor
systems (such as dual-Pentium motherboards), with support for up to
16 processors in a system, which is great for high-performance servers
and scientific applications.</p>

<p><a name="INDEX-415" />
The Linux system is mostly compatible with a number of
Unix standards (inasmuch as Unix
has standards) on the source level, including <span class="acronym">IEEE</span>
<span class="acronym">POSIX</span>.1, System V, and <span class="acronym">BSD</span>
features. Linux was developed with source portability in mind: therefore,
you will probably find features in the Linux system that
are shared across multiple Unix implementations. A great deal of free
Unix software available on the Internet and
elsewhere compiles on Linux out of the box.</p>

<p>If you have some Unix background, you may be interested in some other
specific internal features of Linux, including <span class="acronym">POSIX</span>
job control (used by shells such as the C shell, <tt class="command">csh</tt>, and
<tt class="command">bash</tt>),
  pseudoterminals
(
<?troff \/?><em class="emphasis">pty</em> devices), and support for
national or customized keyboards using dynamically loadable keyboard
drivers. Linux also supports <em class="emphasis">virtual consoles</em>,
  which allow
you to switch between multiple login sessions from the system console
in text mode. Users of the <em class="filename">screen</em> program will
find the Linux virtual console implementation familiar.</p>

<p>Linux can quite happily co-exist on a system that has other operating
systems installed, such as Windows 95/98, Windows NT, OS/2, or other versions of Unix. The Linux boot loader (LILO) allows you to select which
operating system to start at boot time, and Linux is compatible with other
boot loaders as well (such as the one found in Windows NT).</p>

<p><a name="INDEX-416" />
<a name="INDEX-417" />
Linux can run on a wide range of CPU architectures, including
the Intel x86 (386, 486, Pentium, Pentium Pro, II, and III), SPARC,
Alpha, PowerPC, MIPS, and m68k. Ports to
various other architectures are underway, and it is expected that
Linux will run just fine on Intel's next-generation "Merced"
processors. There has even been work to port Linux to embedded
processors, such as the one found in the 3Com PalmPilot personal
digital assistant.</p>

<p><a name="INDEX-418" />
Linux supports various filesystem types for storing data. Some
filesystems, such as the Second Extended (<em class="emphasis">ext2fs</em>) filesystem, have
been developed specifically for Linux.  Other filesystem types, such
as the Minix-1 and Xenix filesystems,

are also supported. The <span class="acronym">MS-DOS</span> filesystem has been
implemented as well, allowing you to access Windows and <span class="acronym">DOS</span>
on hard drive or floppy directly. Support is included for OS/2, Apple,
Amiga, and
Windows NT filesystems as well.
The <span class="acronym">ISO</span> 9660 <span class="acronym">CD-ROM</span> filesystem type, which reads
all standard formats of <span class="acronym">CD-ROM</span>s, is also supported.
We'll talk more about filesystems in <a href="ch03_01.htm">Chapter 3, "Installation
 and Initial
 Configuration"</a>, and <a href="ch05_01.htm">Chapter 5, "Essential System Management"</a>.</p>

<p><a name="INDEX-419" />
<a name="INDEX-420" />
<a name="INDEX-421" />
Networking support is one of the greatest strengths of Linux, both in terms
of functionality and performance.
Linux provides a complete implementation of <span class="acronym">TCP/IP</span>
networking. This includes device drivers for many popular Ethernet
cards, <span class="acronym">PPP</span> and <span class="acronym">SLIP</span> (allowing you to access a
<span class="acronym">TCP/IP</span> network via a serial connection), Parallel
Line Internet Protocol (<span class="acronym">PLIP</span>), and the <span class="acronym">NFS</span>
Network File System.

The complete range of <span class="acronym">TCP/IP</span> clients and services
is supported, such as <span class="acronym">FTP</span>, Telnet,
<span class="acronym">NNTP</span>, and Simple Mail Transfer Protocol
(<span class="acronym">SMTP</span>). The Linux kernel includes complete
network firewall support, allowing you to configure any Linux machine
as a firewall (which screens network packets, preventing unauthorized
access to an intranet, for example). It is widely held that networking
performance under Linux is superior to other operating systems.
We'll talk more about networking in <a href="ch15_01.htm">Chapter 15, "TCP/IP and PPP"</a>.</p>
</div>




<div class="sect2">
<h3 class="sect2">1.4.3. Kernel</h3>

<p><a name="INDEX-422" />
The <em class="emphasis">kernel</em> is the guts of the operating system
itself; it's the code that controls the interface between user
programs and hardware devices, the scheduling of processes to achieve
multitasking, and many other aspects of the system. The kernel is not
a separate process running on the system. Instead, you can think
of the kernel as a set of routines, constantly in memory, that every
process has access to. Kernel routines can be called in a number of
ways.  One direct method to utilize the kernel is for a process to
<a name="INDEX-423" />
execute a <em class="firstterm">system call</em>, which is a function that
causes the kernel to execute some code on behalf of the process. For
example, the <em class="emphasis">read</em> system call will read data from
a file descriptor. To the programmer, this looks like another C
function, but in actuality the code for <em class="emphasis">read</em> is
contained within the
<?troff \p?> kernel.</p>

<p>Kernel code is also executed in other situations. For example, when a
hardware device issues an interrupt, the interrupt handler is found within
the kernel. When a process takes an action that requires it to wait
for results, the kernel steps in and puts the process to sleep, scheduling
another process in its place. Similarly, the kernel switches control between
processes rapidly, using the clock interrupt (and other means) to trigger
a switch from one process to another. This is basically how multitasking
is accomplished.</p>

<p><a name="INDEX-424" />
<a name="INDEX-425" />
The Linux kernel is known as a <em class="emphasis">monolithic</em> kernel, in
that all device drivers are part of the kernel proper. Some operating
systems employ a <em class="emphasis">microkernel</em> architecture whereby device
drivers and other components (such as filesystems and memory management code)
are <em class="emphasis">not</em> part of the kernel--rather, they are
treated similarly to regular user applications. There are advantages and
disadvantages
to both designs: the monolithic architecture is more common
among Unix implementations and is the design
employed by classic kernel designs, such as System V and
<span class="acronym">BSD</span>. Linux does support loadable device drivers
(which can be loaded and unloaded from memory through user commands);
this is the subject of the section

"<a href="ch07_05.htm">Section 7.5, "Loadable Device Drivers"</a>"
in <a href="ch07_01.htm">Chapter 7, "Upgrading Software and the Kernel"</a>.</p>

<p><a name="INDEX-426" />
The kernel is able to emulate <span class="acronym">FPU</span> instructions
itself on many architectures, so that systems without a math
coprocessor can run programs
that require floating-point math instructions.</p>

<p>The Linux kernel on Intel platforms is developed to use the special
protected-mode
features of the Intel 80x86 processors (starting with the 80386). In
particular, Linux makes use of the
protected-mode descriptor-based memory management paradigm and many of
the other advanced features of these processors. Anyone familiar with
80386 protected-mode programming knows that this chip was designed for
a multitasking system such as Unix (it was actually
inspired by Multics). Linux exploits this functionality.</p>

<p>The Linux kernel supports demand-paged loaded executables. That is, only
those segments of a program that are actually used are read into
memory from disk.  Also, if multiple instances of a program are
running at once, only one copy of the program code will be in memory.</p>

<p><a name="INDEX-427" />
<a name="INDEX-428" />
<a name="INDEX-429" />
In order to increase the amount of available memory, Linux also implements
disk paging: that is, a certain amount of
<em class="emphasis">swap space </em><a href="#FOOTNOTE-9">[9]</a>
can be allocated on disk. When the system requires more physical
memory, it will swap out inactive pages to disk, thus allowing you to
run larger applications and support more users at once. However, swap
is no substitute for physical <span class="acronym">RAM</span>; it's much
slower due to the time required to access the disk.</p><blockquote>

<a name="FOOTNOTE-9" /><p>[9]Technically speaking, swap space is inappropriately named: entire
processes are not swapped, but rather individual pages of memory are
paged out. Of course, in many cases, entire processes will be
swapped out, but this is not necessarily always the case.</p>

</blockquote>

<p>The kernel also implements a unified memory pool for user programs and
disk cache. In this way, all free memory is used for caching, and the
cache is reduced when the processor is running large programs.</p>

<p><a name="INDEX-430" />
Executables use dynamically linked shared libraries, meaning that
executables share common library code in a single library file found
on disk, not unlike the SunOS shared library mechanism. This allows
executable files to occupy much less space on disk, especially those files
that use many library functions. This also means that a single copy of
the library code is held in memory at one time, thus reducing overall
memory usage. There are also statically linked
libraries for those who wish to maintain
"complete" executables without the need for shared
libraries to be in place. Because Linux shared libraries are dynamically
linked at runtime, programmers can replace modules of the
libraries with their own routines.</p>

<p><a name="INDEX-431" />
<a name="INDEX-432" />
To facilitate debugging, the Linux kernel does core dumps for

post-mortem analysis. Using a core dump and an executable linked with
debugging support, you can determine what caused a program to crash.
We'll talk about this in the section "<a href="ch14_01.htm">Section 14.1.2, "Examining a Core File"</a>" in <a href="ch14_01.htm">Chapter 14, "Tools for
 Programmers"</a>.</p>

<a name="INDEX-433" /><a name="INDEX-434" />
</div>


<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch01_03.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch01_05.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">1.3. Who's Using Linux?</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">1.5. Software Features</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="index.htm" coords="172,2,252,105" shape="rect" /><area href="../apache/index.htm" coords="238,2,334,95" shape="rect" /><area href="../sql/index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="../cgi/index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>