<?label 14.2. Programming Tools?><html><head><title>Programming Tools (Running Linux)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="Running Linux" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch14_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm" /></td><td width="172" valign="top" align="right"><a href="ch15_01.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<h2 class="sect1">14.2. Programming Tools</h2>

<p>Along with languages and compilers, there is a plethora of programming
tools out there, including libraries, interface builders, debuggers,
and other utilities to aid the programming process. In this section, we'll
talk about some of the most interesting bells and whistles of these
tools to let you know what's out there.</p>

<div class="sect2">
<h3 class="sect2">14.2.1. Debuggers</h3>

<p><a name="INDEX-2863" />
There are several interactive debuggers available for Linux. The
de facto standard debugger is <tt class="command">gdb</tt>, which we just covered in detail.</p>

<p>In addition
to <tt class="command">gdb</tt>, there are several other debuggers, each
with features very similar to
<tt class="command">gdb</tt>. 
<a name="INDEX-2864" />
<tt class="command">xxgdb</tt> is a version of
<tt class="command">gdb</tt> with an X Window System interface similar to
that found on the <tt class="command">xdbx</tt> debugger on other
Unix systems. There are several panes in the <tt class="command">xxgdb</tt>
debugger's window. One pane looks like the regular
<tt class="command">gdb</tt> text interface, allowing you to input commands
manually to interact with the system. Another pane automatically
displays the current source file along with a marker displaying the
current line. You can use the source pane to set and select
breakpoints, browse the source, and so on, while typing commands
directly to <tt class="command">gdb</tt>. A number of buttons are provided
on the <tt class="command">xxgdb</tt> window as well, providing quick access
to
frequently used commands, such as <tt class="command">step</tt>,
<tt class="command">next</tt>, and so on. Given the buttons, you can use the mouse in
conjunction with the keyboard to debug your program within an
easy-to-use X interface.</p>

<p><a name="INDEX-2865" />
Another debugger similar
to <tt class="command">xxgdb</tt> is <span class="acronym">UPS</span>, an X-based
debugger that has been ported to a number of Unix
platforms. <span class="acronym">UPS</span> is much simpler than
<tt class="command">xxgdb</tt> and doesn't provide the same features, but it
is a good debugger nonetheless and has a less demanding learning curve
than <tt class="command">gdb</tt>.  It is adequate for most
applications and straightforward debugging needs.</p>

<p>Two other graphical frontends for <tt class="command">gdb</tt> 
<a name="INDEX-2866" />
<a name="INDEX-2867" />
		deserve mention. DDD, the Data Display Debugger, has the same
		features as <tt class="command">xxgdb</tt> with a nicer, Motif user
		interface. In addition, it can display structures and classes
		in a graphical manner, which is especially useful if you want
		to explore the data structures of an unknown
<a name="INDEX-2868" />
		program. <tt class="command">kdbg</tt> comes from the KDE project
		and--in addition to the features that
		<tt class="command">xxgdb</tt> provides--is fully
		integrated into the KDE desktop.</p>

<a name="INDEX-2869" />
</div>




<div class="sect2">
<h3 class="sect2">14.2.2. Profiling and Performance Tools</h3>

<p><a name="INDEX-2870" />
<a name="INDEX-2871" />
<a name="INDEX-2872" />
There are several utilities out there that allow you to monitor and
rate the performance of your program. These tools help you
locate bottlenecks in your code--places where performance is
lacking.  These tools also give you a rundown on the call
structure of your program, indicating what functions are called, from
where, and how often. (Everything you ever wanted to know about your
program, but were afraid to ask.)</p>

<p><a name="INDEX-2873" />
<tt class="command">gprof</tt> is a profiling utility that gives you a
detailed listing of the running statistics for your program,
including how often each function was called, from where, the total
amount of time that each function required, and so forth.</p>

<p>In order to use
<tt class="command">gprof</tt> with a program, you must compile the program
using the <span class="option">-pg</span> option with
<tt class="command">gcc</tt>. This adds profiling information to the object
file and links the executable with standard libraries that have
profiling information enabled.</p>

<p>Having compiled the program to profile with <span class="option">-pg</span>,
simply run it.  If it exits normally, the file
<em class="filename">gmon.out</em> will be written to the working directory
of the program. This file contains profiling information for that run
and can be used with <tt class="command">gprof</tt> to display a table of
statistics.</p>

<p>As an example, let's take a program called <em class="filename">getstat</em>, which gathers
statistics about an image file. First, we compile <em class="filename">getstat</em> with 
<span class="option">-pg</span>, and run it:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>getstat image11.pgm &gt; stats.dat</b></tt> 
papaya$ <tt class="userinput"><b>ls -l gmon.out</b></tt> 
-rw-------   1 mdw      mdw         54448 Feb  5 17:00 gmon.out 
papaya$</pre></blockquote>

Indeed, the profiling information was written to <em class="filename">gmon.out</em>.</p>

<p>To examine the profiling data, we run <tt class="command">gprof</tt> and give it the name
of the executable and the profiling file <em class="filename">gmon.out</em> :
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gprof getstat gmon.out</b></tt></pre></blockquote>


If you do not specify the name of the profiling file,
<tt class="command">gprof</tt> assumes the name
<em class="filename">gmon.out</em>. It also assumes the executable name
<em class="filename">a.out</em> if you do not specify that, either.</p>

<p><tt class="command">gprof</tt> output is rather verbose, so you may want to
redirect it to a file or pipe it through a pager. It comes in two
parts. The first part is the "flat profile," which gives a
one-line entry for each function, listing the percentage of time spent
in that function, the time (in seconds) used to execute that function,
the number of calls to the function, and other information. For
example:
<blockquote><pre class="code">Each sample counts as 0.01 seconds. 
  %   cumulative   self              self     total            
 time   seconds   seconds    calls  ms/call  ms/call  name     
 45.11     27.49    27.49       41   670.51   903.13  GetComponent 
 16.25     37.40     9.91                             mcount 
 10.72     43.93     6.54  1811863     0.00     0.00  Push 
 10.33     50.23     6.30  1811863     0.00     0.00  Pop 
  5.87     53.81     3.58       40    89.50   247.06  stackstats 
  4.92     56.81     3.00  1811863     0.00     0.00  TrimNeighbors</pre></blockquote>

If any of the fields are blank in the output, <tt class="command">gprof</tt> was unable to
determine any further information about that function. This is usually
caused by parts of the code that were not compiled with the
<span class="option">-pg</span> option; for
example, if you call routines in nonstandard libraries that haven't been
compiled with <span class="option">-pg</span>, <tt class="command">gprof</tt> won't be able to gather much
information about those routines. In the previous output, the function 
<em class="emphasis">mcount</em> probably hasn't been compiled with profiling enabled.</p>

<p>As we can see, 45.11% of the total running time was spent in the
function <em class="emphasis">GetComponent</em>--which amounts to
27.49 seconds. But is this because <em class="emphasis">GetComponent</em>
is horribly inefficient or because <em class="emphasis">GetComponent</em>
itself called many other slow functions? The functions
<em class="emphasis">Push</em> and <em class="emphasis">Pop</em> were called
many times during execution: could they be the
culprits?<a href="#FOOTNOTE-52">[52]</a></p><blockquote>

<a name="FOOTNOTE-52" /><p>[52]Always a possibility where this
author's code is concerned!</p>

</blockquote>

<p>The second part of the <tt class="command">gprof</tt> report can help us
here. It gives a detailed "call graph" describing which
functions called other functions and how many times they were called. For example:


<blockquote><pre class="code">index % time    self  children    called     name 
                                                 &lt;spontaneous&gt; 
[1]     92.7    0.00   47.30                 start [1] 
                0.01   47.29       1/1           main [2] 
                0.00    0.00       1/2           on_exit [53] 
                0.00    0.00       1/1           exit [172]</pre></blockquote>


The first column of the call graph is the index: a unique number given to
every function, allowing you to find other functions in the graph.
Here, the first function, <em class="emphasis">start</em>, is called implicitly when the
program begins. <em class="emphasis">start</em> required 92.7% of the total running time (47.30
seconds), including its children, but required very little time to run
itself. This is because <em class="emphasis">start</em> is the parent of all other functions
in the program, including <em class="emphasis">main</em>; it makes sense
that <em class="emphasis">start</em>
plus its children requires that percentage of time.</p>

<p>The call graph normally displays the children as well as the parents
of each function in the graph. Here, we can see that
<em class="emphasis">start</em> called the functions
<em class="emphasis">main</em>, <em class="emphasis">on_exit</em>, and
<em class="emphasis">exit</em> (listed below the line for
<em class="emphasis">start</em>). However, there are no parents (normally
listed above <em class="emphasis">start</em>); instead, we see the ominous
word <tt class="literal">&lt;spontaneous&gt;</tt>. This means that
<tt class="command">gprof</tt> was unable to determine the parent function
of <em class="emphasis">start</em>; more than likely because
<em class="emphasis">start</em> was not called from within the program
itself but kicked off by the operating system.</p>

<p>Skipping down to the entry for <em class="emphasis">GetComponent</em>, or
function-under-suspect, we see the following:

<blockquote><pre class="code">index % time    self  children    called     name 
                0.67    0.23       1/41          GetFirstComponent [12] 
               26.82    9.30      40/41          GetNextComponent [5] 
[4]     72.6   27.49    9.54      41         GetComponent [4] 
                6.54    0.00 1811863/1811863     Push [7] 
                3.00    0.00 1811863/1811863     TrimNeighbors [9] 
                0.00    0.00       1/1           InitStack [54]</pre></blockquote>


The parent functions of <em class="emphasis">GetComponent</em> were
<em class="emphasis">GetFirstComponent</em> and
<em class="emphasis">GetNextComponent</em>, and its children were
<em class="emphasis">Push</em>, <em class="emphasis">TrimNeighbors</em>, and
<em class="emphasis">InitStack</em>. As we can see,
<em class="emphasis">GetComponent</em> was called 41 times--one time
from <em class="emphasis">GetFirstComponent</em> and 40 times from
<em class="emphasis">GetNextComponent</em>. The <tt class="command">gprof</tt>
output contains notes that describe the report in more detail.</p>

<p><em class="emphasis">GetComponent</em> itself requires over 27.49 seconds to 
run; only 9.54 seconds are spent executing the children of <em class="emphasis">GetComponent</em>
(including the many calls to <em class="emphasis">Push</em> and <em class="emphasis">TrimNeighbors</em>!). So
it looks as though <em class="emphasis">GetComponent</em> and possibly its parent 
<em class="emphasis">GetNextComponent</em> need some tuning; the oft-called <em class="emphasis">Push</em>
function is not the sole cause of the problem.</p>

<p><tt class="command">gprof</tt> also keeps track of recursive calls and
"cycles" of called functions and indicates the amount of
time required for each call. Of course, using <tt class="command">gprof</tt>
effectively requires that all code to be profiled is compiled with the
<span class="option">-pg</span> option. It also requires a knowledge of the
program you're attempting to profile; <tt class="command">gprof</tt> can
only tell you so much about what's going on.  It's up to the
programmer to optimize inefficient code.</p>

<p>
<img src="figs/bomb.gif">&nbsp;&nbsp;One last note about <tt class="command">gprof</tt>:
running it on a program that calls only a few
functions--and runs very quickly--may not give you meaningful results.
The units used for timing execution are usually rather coarse--maybe
one-hundredth of a second--and if many functions in your program run
more quickly than that, <tt class="command">gprof</tt> will be unable to distinguish between
their respective running times (rounding them to the nearest hundredth
of a second). In order to get good profiling information, you may need to
run your program under unusual circumstances--for example, giving it
an unusually large data set to churn on, as in the previous example. 
<a name="INDEX-2874" /></p>

<p><a name="INDEX-2875" />
If <tt class="command">gprof</tt> is more than you need,
<tt class="command">calls</tt> is a program that 
displays a tree of all function calls in your C source code. This can be 
useful to generate either an index of all called functions or to produce a 
high-level hierarchical report of the structure of a program.</p>

<p>Use of <tt class="command">calls</tt> is simple: you tell it the names of the
source files to map out, and a function-call tree is displayed. For example:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>calls scan.c</b></tt> 
    1   level1 [scan.c] 
    2           getid [scan.c] 
    3                   getc 
    4                   eatwhite [scan.c] 
    5                           getc 
    6                           ungetc 
    7                   strcmp 
    8           eatwhite [see line 4] 
    9           balance [scan.c] 
   10                   eatwhite [see line 4]</pre></blockquote>

<?troff .ne 10?>
By default, <tt class="command">calls</tt> lists only one instance of each called function 
at each level of the tree (so that if <em class="emphasis">printf</em> is called
five times in a given function, it is listed only once). The <span class="option">-a</span>
switch prints all instances. <tt class="command">calls</tt> has several other options
as well; using <tt class="command">calls -h</tt> gives you a summary.</p>

<a name="INDEX-2876" /><a name="INDEX-2877" /><a name="INDEX-2878" />
</div>




<div class="sect2">
<h3 class="sect2">14.2.3. Using strace</h3>

<p><a name="INDEX-2879" />
<a name="INDEX-2880" />
<tt class="command">strace</tt> is a tool that displays the system calls being executed
by a running program.<a href="#FOOTNOTE-53">[53]</a>
This can be extremely useful for real-time monitoring
of a program's activity, although it does take some knowledge of
programming at the system-call level. For example, when
the library routine <em class="emphasis">printf</em> is used within a program, <tt class="command">strace</tt>
displays information only about the underlying <em class="emphasis">write</em> system call 
when it is executed. Also, <tt class="command">strace</tt> can be quite verbose: many
system calls are executed within a program that the programmer may not
be aware of. However, <tt class="command">strace</tt> is a good way to quickly determine the
cause for a program crash or other strange failure.</p><blockquote>

<a name="FOOTNOTE-53" /><p>[53]Debian users may find the <tt class="command">ltrace</tt> package useful as
well. It's a library call tracer that tracks all library calls, not just
calls to the kernel; users of other distributions can download the
latest version of the source at ftp://ftp.debian.org/debian/dists/unstable/main/ source/utils /.</p>

</blockquote>

<p>Take the "Hello, World!" program given earlier in the chapter. Running
<tt class="command">strace</tt> on the executable <em class="filename">hello</em> gives us:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>strace hello</b></tt> 
execve("./hello", ["hello"], [/* 49 vars */]) = 0
mmap(0, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS,\
 -1, 0) = 0x40007000
mprotect(0x40000000, 20881, PROT_READ|PROT_WRITE|PROT_EXEC) = 0
mprotect(0x8048000, 4922, PROT_READ|PROT_WRITE|PROT_EXEC) = 0
stat("/etc/ld.so.cache", {st_mode=S_IFREG|0644, st_size=18612,\
 ...}) = 0
open("/etc/ld.so.cache", O_RDONLY)      = 3
mmap(0, 18612, PROT_READ, MAP_SHARED, 3, 0) = 0x40008000
close(3)                                = 0
stat("/etc/ld.so.preload", 0xbffff52c)  = -1 ENOENT (No such\
 file or directory)
open("/usr/local/KDE/lib/libc.so.5", O_RDONLY) = -1 ENOENT (No\
 such file or directory)
open("/usr/local/qt/lib/libc.so.5", O_RDONLY) = -1 ENOENT (No\
 such file or directory)
open("/lib/libc.so.5", O_RDONLY)        = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3"..., 4096) = 4096
mmap(0, 770048, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = \
0x4000d000
mmap(0x4000d000, 538959, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_\
FIXED, 3, 0) = 0x4000d000
mmap(0x40091000, 21564, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_\
FIXED, 3, 0x83000) = 0x40091000
mmap(0x40097000, 204584, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_\
FIXED|MAP_ANONYMOUS, -1, 0) = 0x40097000
close(3)                                = 0
mprotect(0x4000d000, 538959, PROT_READ|PROT_WRITE|PROT_EXEC) = 0
munmap(0x40008000, 18612)               = 0
mprotect(0x8048000, 4922, PROT_READ|PROT_EXEC) = 0
mprotect(0x4000d000, 538959, PROT_READ|PROT_EXEC) = 0
mprotect(0x40000000, 20881, PROT_READ|PROT_EXEC) = 0
personality(PER_LINUX)                  = 0
geteuid()                               = 501
getuid()                                = 501
getgid()                                = 100
getegid()                               = 100
fstat(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(3, 10), ...}) = 0
mmap(0, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS,\
 -1, 0) = 0x40008000
ioctl(1, TCGETS, {B9600 opost isig icanon echo ...}) = 0
write(1, "Hello World!\n", 13Hello World!
)          = 13
_exit(0)                                = ?
papaya$</pre></blockquote>

This may be much more than you expected to see from a simple program.
Let's walk through it, briefly, to explain what's going on.</p>

<p>The first call <em class="emphasis">execve</em> starts the program
itself. All the <em class="emphasis">mmap</em>,
<em class="emphasis">mprotect</em>, and <em class="emphasis">munmap</em> calls
come from the kernel's memory management and are not really
interesting here. In the three consecutive <em class="emphasis">open</em>
calls, the loader is looking for the C library and finds it on the
third try. The library header is then read and the library mapped into
memory. After a few more memory-management operations and the calls to 
<em class="emphasis">getuid</em>, <em class="emphasis">geteuid</em>,
<em class="emphasis">getgid</em>, and <em class="emphasis">getegid</em>, which
retrieve the rights of the process, there is a call to
<em class="emphasis">ioctl</em>. The <em class="emphasis">ioctl</em> is the result of a
<em class="emphasis">tcgetattr</em> library call, which the program uses to
retrieve the
terminal attributes before attempting to write to the terminal. Finally, the
<em class="emphasis">write</em> call prints our friendly message to the
terminal and <em class="emphasis">exit</em> ends the program.</p>

<p>The calls to <em class="emphasis">munmap</em> (which unmaps a memory-mapped portion of a file)
and <em class="emphasis">brk</em> (which allocates memory on the heap) set up the memory 
image of the running process. The <em class="emphasis">ioctl</em> call is the result of
a <em class="emphasis">tcgetattr</em> library call, which retrieves the terminal attributes
before attempting to write to it. Finally, the <em class="emphasis">write</em> call prints
our friendly message to the terminal, and <em class="emphasis">exit</em> ends the program.</p>

<p><tt class="command">strace</tt> sends its output to standard error, so you can redirect it 
to a file
separately from the actual output of the program (usually on standard 
output). As you can see, <tt class="command">strace</tt> tells you not only the names of 
the system calls,
but also their parameters (expressed as well-known constant names, if
possible, instead of just numerics) and return values.</p>

<a name="INDEX-2881" /><a name="INDEX-2882" />
</div>




<div class="sect2">
<h3 class="sect2">14.2.4. make and imake</h3>

<p><a name="INDEX-2883" />
<a name="INDEX-2884" />
<a name="INDEX-2885" />
We have already introduced <tt class="command">make</tt>, the project 
manager used to compile projects, among other things.
One problem with <tt class="command">make</tt> is that makefiles aren't always easy to write.
When large projects are involved, writing a makefile with cases for
each kind of source file can be tedious. Even with the
built-in <tt class="command">make</tt> defaults, this is often more work than should
be necessary.</p>

<p>One solution is to use <tt class="command">imake</tt>, an extension to
<tt class="command">make</tt> based on the use of the C preprocessor.
<tt class="command">imake</tt> is simply a makefile generator: you write an
Imakefile that <tt class="command">imake</tt> converts to a robust makefile.
<tt class="command">imake</tt> is used by programs in the X Window System
distribution but is not limited to use by X applications.</p>

<p>We should note at this point that <tt class="command">imake</tt> can simplify the process of
writing makefiles, especially for compiling C programs. However,
<tt class="command">make</tt> is more generally applicable than
<tt class="command">imake</tt> for this task.
For example, you can use <tt class="command">make</tt> to automatically format documents
using <tt class="command">groff</tt> or TeX. In this case, you need the flexibility
of <tt class="command">make</tt> alone, and <tt class="command">imake</tt> may not be the best solution.</p>

<p>Here is a sample Imakefile that builds two programs, <em class="filename">laplacian</em>
and <em class="filename">getstat</em>. At the top of the Imakefile, options for the entire
compilation are specified (<tt class="command">imake</tt> has its own defaults for these, but they
aren't always useful). Following that, variables are defined for each
program to be compiled, and the <tt class="command">imake</tt> macros <tt class="literal">AllTarget</tt> and
<tt class="literal">NormalProgramTarget</tt> create makefile rules for compiling
these programs:</p>

<blockquote><pre class="code"># Linker options: 
LDOPTIONS = -L/usr/local/lib -L../lib  
# The C compiler to use: 
CC = gcc 
# Flags to be used with gcc: 
CFLAGS = -I. -I$(HOME)/include -g  
# Local and system libraries to link against: 
LOCAL_LIBRARIES = -lvistuff 
SYS_LIBRARIES = -lm 
 
# Specify the sources in the SRCS variable, and the corresponding object 
# files in the variable LAP_OBJS. 
SRCS = laplacian.c laplacian-main.c 
LAP_OBJS = laplacian.o laplacian-main.o 

# Create rules for building laplacian. 
AllTarget(laplacian) 
NormalProgramTarget(laplacian,$(LAP_OBJS),,$(LOCAL_LIBRARIES),\
$(SYS_LIBRARIES)) 
 
# Do the same thing for getstat. Note that SRCS can be redefined for each 
# target, but LAP_OBJS can't, so we use a unique name for each target. 
SRCS = getstat.c getstat-main.c component.c 
GS_OBJS = getstat.o getstat-main.o component.o 

AllTarget(getstat) 
NormalProgramTarget(getstat,$(GS_OBJS),,$(LOCAL_LIBRARIES),\
$(SYS_LIBRARIES))</pre></blockquote>

<p>Note that we must use a different variable for the object files for each
target, although <tt class="literal">SRCS</tt> can be redefined for each.</p>

<p>In order to translate the Imakefile into a makefile, use the command
<tt class="command">xmkmf</tt>. <tt class="command">xmkmf</tt> will simply run <tt class="command">imake</tt> with the
options to do the translation correctly, using the default <tt class="command">imake</tt> macros
(such as <tt class="literal">AllTarget</tt> and <tt class="literal">NormalProgramTarget</tt>). You can then
issue <tt class="command">make</tt> to compile the program:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>xmkmf</b></tt> 
mv Makefile Makefile.bak 
imake -DUseInstalled -I/usr/X386/lib/X11/config 
papaya$</pre></blockquote>


If you want to
use your own <tt class="command">imake</tt> macros, you can invoke <tt class="command">imake</tt> by hand using the
appropriate options. The <tt class="command">imake</tt> and <tt class="command">xmkmf</tt> manual pages should
fill in the gaps. <em class="emphasis">Software Portability with imake</em> by Paul DuBois
is another guide to the
<?troff \p?> system.</p>

<p>If you find <tt class="command">imake</tt> too complex for your taste, other "makefile makers" 
are available as well, such as <tt class="command">ICmake</tt>, which generates makefiles
using a macro language similar to C.</p>

<p>If you have compiled software packages yourself, you
		will often have found compilation instructions that told you
		to run a provided script called
<a name="INDEX-2886" />
<a name="INDEX-2887" />
		<em class="filename">configure</em>. This is produced by a Makefile 
		generator called <tt class="command">autoconf</tt>, which is often
		used together with another program called
		<tt class="command">automake</tt>. <tt class="command">autoconf</tt> and
		<tt class="command">automake</tt> are not easy to use, but they give 
		you way more flexibility than <tt class="command">imake</tt>,
		<tt class="command">ICmake</tt>, and all other Makefile
		generators. Unfortunately, the usage of
		<tt class="command">autoconf</tt> is way beyond the scope of this
		book. If you're interested in this, get yourself a copy from the
		archives and start reading the documentation.</p>

<a name="INDEX-2888" />
</div>




<a name="x-100-3-sec-prog-tools-checker" /><div class="sect2">
<h3 class="sect2">14.2.5. Using Checker</h3>

<p><a name="INDEX-2889" />
<a name="INDEX-2890" />
Checker is a replacement for the various memory-allocation routines, 
such as <em class="emphasis">malloc</em>, <em class="emphasis">realloc</em>, and <em class="emphasis">free</em>, used by C programs.
It provides smarter memory-allocation procedures and code to detect
illegal memory accesses and common faults, such as attempting to 
free a block of memory more than once. Checker displays detailed
error messages if your program attempts any kind of hazardous memory
access, helping you to catch segmentation faults in your program before
they happen. It can also detect memory leaks--for example,
places in the
code where new memory is <em class="emphasis">malloc</em>'d without being <em class="emphasis">free</em>'d after use.</p>

<p>Checker is not just a replacement for <em class="emphasis">malloc</em> and friends. It also
inserts code into your program to verify all memory reads and writes.
It is very robust and therefore somewhat slower than the 
regular <em class="emphasis">malloc</em> routines. Checker is meant to be used during program
development and testing; once all potential memory-corrupting bugs have
been fixed, you can link your program with the standard libraries.</p>

<p>For example, take the following program, which allocates some memory 
and attempts to do various nasty things with it:
<blockquote><pre class="code">#include &lt;malloc.h&gt; 
int main() { 
  char *thememory, ch; 
 
  thememory=(char *)malloc(10*sizeof(char)); 
   
  ch=thememory[1];     /* Attempt to read uninitialized memory */ 
  thememory[12]=' ';   /* Attempt to write after the block */ 
  ch=thememory[-2];    /* Attempt to read before the block */ 
}</pre></blockquote>

We simply compile this program with the <span class="option">-lchecker</span> option, which
links it with the Checker libraries. Upon running it, we get the following
error messages (among others):
<blockquote><pre class="code">From Checker: 
        Memory access error 
        When Reading at address 0x10033 
        inside the heap 
        1 bytes after the begin of the block 

From Checker: 
        Memory access error 
        When Writing at address 0x1003e 
        inside the heap 
        2 bytes after the end of the block 
From Checker: 
        Memory access error 
        When Reading at address 0x10030 
        inside the heap 
        2 bytes before the begin of the block</pre></blockquote>

<a name="INDEX-2891" />
For each memory violation, Checker reports an error and gives us information
on what happened. The actual Checker error messages include information on
where the program is executing as well as where the memory block was 
allocated. You can coax even more information out of Checker if you 
wish, and, along with a debugger such as <tt class="command">gdb</tt>, you
can pinpoint problems easily.<a href="#FOOTNOTE-54">[54]</a></p><blockquote>

<a name="FOOTNOTE-54" /><p>[54]We have edited the output somewhat
in order to remove extraneous information and to increase readability
for the purpose of the example.</p>

</blockquote>

<p><a name="INDEX-2892" />
Checker also provides a garbage collector and detector you can call
from within your program. In brief, the garbage detector informs you
of any memory leaks: places where a function <em class="emphasis">malloc</em>'d a block of
memory but forgot to <em class="emphasis">free</em> it before returning. The garbage
collector routine walks through the heap and cleans up the results
of these leaks. You can also call the garbage collector and detector
manually when running the program from within <tt class="command">gdb</tt> (as <tt class="command">gdb</tt>
allows you to directly call functions during execution).</p>

<a name="INDEX-2893" /><a name="INDEX-2894" />
</div>




<div class="sect2">
<h3 class="sect2">14.2.6. Interface Building Tools</h3>

<p> 
<a name="INDEX-2895" />
<a name="INDEX-2896" />
A number of applications and libraries let you easily generate a
user interface for your applications under the X Window System. If you do not want
to bother with the complexity of the X programming interface, using one
of these simple interface-building tools may be the answer for you.
There are also tools for producing a text-based interface for programs
that don't require X.</p>

<p>The classic X programming model has attempted to be as general
as possible, providing only the bare minimum of interface restrictions
and assumptions. This generality allows programmers to build their own interface
from scratch, as the core X libraries don't make any assumptions
about the interface in advance. The X Toolkit Intrinsics (Xt) provides a 
rudimentary set of interface widgets (such as simple buttons, scrollbars,
and the like), as well as a general interface for writing your own
widgets if necessary. Unfortunately this can require a great deal of
work for programmers who would rather use a set of pre-made interface
routines. A number of Xt widget sets and programming libraries are available 
for Linux, all of which make the user interface easier to program.</p>

<p><a name="INDEX-2897" />
In addition, the commercial Motif library and widget set is available
from several vendors for an inexpensive single-user license fee. 
<a name="INDEX-2898" />
Also available is the XView library and widget interface, which
is another alternative to using Xt for building interfaces under X. 
XView and Motif are two sets of X-based programming libraries that in 
some ways are easier to program than the X Toolkit Intrinsics. 
Many applications are available that utilize Motif and XView,
such as XVhelp (a system for generating interactive hypertext help for
your program). Binaries statically linked with Motif
may be distributed freely and used by people who don't own Motif
itself.</p>

<p>Before you start developing with XView or Motif, a word
		of caution is in order. XView, which was once a commercial
		product of Sun Microsystems, has been dropped by the
		developers and is no longer maintained. Also,
		while some people like the look, the programs written with
		XView look very nonstandard. Motif on the other hand is still
		being actively developed (albeit rather slowly), but has some
		problems itself. First, programming with Motif can be
		frustrating, because it is difficult, error prone, and
		cumbersome since the Motif API was not designed according to
		modern GUI API design principles. Also, Motif programs tend to 
		run very slowly.</p>

<p>But there are other widget sets and interface libraries for X like:</p>

<dl>
<dt><b>Xaw3D</b></dt><dd><p>A modified
version of the standard Athena widget set which provides a 3D, Motif-like
look and feel 
<a name="INDEX-2899" />
<a name="INDEX-2900" /></p></dd>


<dt><b><em class="filename">Qt</em></b></dt><dd><p>A C++ GUI toolkit written
			by the Norwegian company Troll Tech</p></dd>


<dt><b><em class="filename">GTK</em></b></dt><dd><p>A C GUI toolkit that was
			originally written for the image manipulation program
			GIMP</p></dd>

</dl>

<p><a name="INDEX-2901" />
Many people complain that the Athena widgets are too
plain in appearance. Xaw3D is completely compatible with the standard
Athena set and can even replace the Athena libraries
on your system, giving all programs that use Athena widgets a modern
look. Xaw3D also provides a few widgets not found in the Athena
set, such as a layout widget with a TeX-like interface for specifying 
the position of child widgets.</p>

<p><em class="filename">Qt</em> is an excellent package for GUI development in 
C++ that sports an ingenious mechanism for connecting user interaction 
with program code, a very fast drawing engine, and a comprehensive but
easy-to-use API. Qt is considered by many as the successor to
Motif as the de facto GUI programming standard, because it is the
foundation of the desktop
KDE (see "<a href="ch11_03.htm">Section 11.3, "The K Desktop Environment"</a>" in <a href="ch11_01.htm">Chapter 11, "Customizing Your X Environment"</a>), which has gotten a lot
of interest.</p>

<p>Qt is a commercial product, but you can use it for free if you
write free software for Unix (and hence Linux) systems with it. There
is also a (commercial) Windows version of Qt, which makes it possible
to develop for Linux and Windows at the same time and create an
application for the other platform by simply recompiling. Imagine
being able to develop on your favorite operating system Linux and
still being able to target the larger Windows market! One of the authors, 
Kalle, uses Qt to write both free software (the KDE Desktop
Environment just mentioned) and commercial
software (often cross-platform products that are
developed for Linux and Windows). Qt is being very actively developed; for more information, see <em class="emphasis">Programming with Qt</em> by Kalle Dalheimer.</p>

<p><a name="INDEX-2902" />
<a name="INDEX-2903" />
For those who do not like to program in C++, <tt class="command">GTK</tt>
might be a good choice. <tt class="command">GTK</tt> programs usually offer
just as good response time as
<tt class="command">Qt</tt> programs, but the toolkit
itself is not as complete. Documentation especially is
lacking. For C-based projects, though, <tt class="command">GTK</tt> is good alternative if you
do not need to be able to recompile your code on
Windows.</p>

<p>Many programmers are finding that building a user interface,
even with a complete set of widgets and routines in C, requires much
overhead and can be quite difficult. This is a question of flexibility
versus ease of programming: the easier the interface is to build, the
less control the programmer has over it. Many programmers are
finding that prebuilt widgets are adequate enough for their needs, so
the loss in flexibility is not a problem.</p>

<p>One of the problems with interface generation and X programming
is that it is difficult to generalize the most widely used elements
of a user interface into a simple programming model. For example, 
many programs use features such as buttons, dialog boxes, pull-down
menus, and so forth, but almost every program uses these widgets
in a different context. In simplifying the creation of a graphical
interface, generators tend to make assumptions about what you'll want.
For example, it is simple enough to specify
that a button, when pressed, should execute a certain procedure within
your program, but what if you want the button to execute some specialized
behavior the programming interface does not allow for? For example,
what if you wanted the button to have a different effect when pressed with
mouse button 2 instead of mouse button 1? If the interface-building
system does not allow for this degree of generality, it is not of much 
use to programmers who need a powerful, customized interface.</p>

<p>
<a name="INDEX-2904" />
<a name="INDEX-2905" />
<a name="INDEX-2906" />
<a name="INDEX-2907" />
The Tcl/Tk programming interface described in the previous chapter is
growing in popularity, partly because it is so simple to use and
provides a good amount of flexibility. Because Tcl and Tk routines can
be called from interpreted "scripts" as well as internally
from a C program, it is not difficult to tie the interface features
provided by this language and toolkit to functionality in the program.
Using Tcl and Tk is on the whole less demanding than learning to
program Xlib and Xt (along with the myriad of widget sets)
directly. It should be noted, though, that the larger a project gets,
the more likely it is that you will want to use a language like C++
that is more suited towards large-scale development. For several reasons, larger
projects tend to become very unwieldy with Tcl: the use of an
interpreted language slows the execution of the program, 
Tcl/Tk design is hard to scale up to large projects, and important
reliability features like compile- and link-time type
checking are missing. The
scaling problem is improved by the use of namespaces (a way to keep
names in different parts of the program from clashing) and an
object-oriented extension called [incr Tcl].</p>

<p><a name="INDEX-2908" />
TclMotif, a version of Tcl bound with the popular Motif widget set, is
also available for Linux. The Motif widgets are widely acclaimed to be
easy to program and pleasant to use. The advantage of TclMotif is that
the binary is freely distributable although Motif itself is a
commercial product. Therefore, you do not have to own Motif to use
TclMotif. TclMotif will in effect let you write programs that use
Motif widgets and routines through the Tcl interface. A statically
linked binary is available on a number of Linux <span class="acronym">FTP</span>
sites and from other sources. If you want to recompile TclMotif
itself, for some reason, you need to own Motif in order to do so.</p>

<p><a name="INDEX-2909" />
<a name="INDEX-2910" />
Wafe is another version of Tcl/Tk that includes the Athena widgets and
miscellaneous other tools that make the programming model easier to
use. If you are accustomed to programming Xt with the Athena widgets,
but you want to move to Tcl and Tk, Wafe is a good place to start.</p>

<p>
Tcl and Tk allow you to generate an X-based interface complete with
windows, buttons, menus, scrollbars, and the like, around your
existing program. The interface may be accessed from a Tcl script (as
described in the section "<a href="ch13_05.htm">Section 13.5.2, "Writing Tk Applications"</a>" in <a href="ch13_01.htm">Chapter 13, "Programming
 Languages"</a>) or from within a C program.</p>

<p><a name="INDEX-2911" />
Another interface-building tool much like Tcl and Tk is
<tt class="command">xtpanel</tt>.  <tt class="command">xtpanel</tt> is meant
primarily to generate an X interface "wrapper" around an
existing text-based program. <tt class="command">xtpanel</tt> allows you to
set up a window with various panes, text editing regions, buttons,
scrollbars, and so on, and bind the actions of these widgets to
features in the program. For example, one could use
<tt class="command">xtpanel</tt> to produce an X-based interface for the
<tt class="command">gdb</tt> debugger, similar to
<tt class="command">xxgdb</tt>. You could define a "step" button
which, when pressed, sends the <tt class="command">step</tt> command to the
regular <tt class="command">gdb</tt> interface.  A text-editing pane could
be defined to interact with <tt class="command">gdb</tt> in the regular
way. Of course, doing something more complex, like setting up a
source-view pane, would be difficult using something as general as
<tt class="command">xtpanel</tt>.</p>

<p>If you like the Tk toolkit, but do not like the programming language
Tcl, you will be delighted to hear that you can use Tk with other
languages as well; it has become the GUI toolkit of choice for the
scripting languages Python and Perl, too.</p>

<p><a name="INDEX-2912" />
<a name="INDEX-2913" />
If you require a nice text-based interface for a program, there are
several options. The <span class="acronym">GNU</span>
<em class="filename">getline</em> library is a set of routines that
provides advanced command-line editing, prompting, command history,
and other features used by many programs. As an example, both
<tt class="command">bash</tt> and <tt class="command">gdb</tt> use the
<em class="filename">getline</em> library to read user
input. <em class="filename">getline</em> provides the Emacs and
<tt class="command">vi</tt>-like command-line editing features found in
<tt class="command">bash</tt> and similar programs.  (The use of command-line editing

within <tt class="command">bash</tt> is described in the section
"<a href="ch04_07.htm">Section 4.7, "Typing Shortcuts"</a>" in <a href="ch04_01.htm">Chapter 4, "Basic Unix
 Commands
 and Concepts"</a>.)</p>

<p><a name="INDEX-2914" />
Another option is to write a set of Emacs interface routines for your
program. An example of this is the <tt class="command">gdb</tt> Emacs
interface, which sets up multiple windows, special key sequences, and
so on, within Emacs. The interface is discussed in the earlier section
"<a href="ch14_01.htm">Section 14.1.6.3, "Using Emacs with gdb"</a>." (No changes
were required to <tt class="command">gdb</tt> code in order to implement
this: look at the Emacs library file <em class="filename">gdb.el</em> for
hints on how this was accomplished.) Emacs allows you to start up a
subprogram within a text buffer and provides many routines for
parsing and processing text within that buffer. For example, within
the Emacs <tt class="command">gdb</tt> interface, the <tt class="command">gdb</tt>
source listing output is captured by Emacs and turned into a command
that displays the current line of code in another window. Routines
written in Emacs <span class="acronym">LISP</span> process the
<tt class="command">gdb</tt> output and take certain actions based on it.</p>

<p>The advantage to using Emacs to interact with text-based programs is
that Emacs is a powerful and customizable user interface within
itself. The user can easily redefine keys and commands to fit
her own needs; you don't need to provide these customization
features yourself. As long as the text interface of the program is
straightforward enough to interact with Emacs, customization is not difficult
to accomplish. In addition, many users prefer to do virtually everything
within Emacs--from reading electronic mail and news, to compiling and
debugging programs. Giving your program an Emacs frontend allows
it to be used more easily by people with this mindset. It also
allows your program to interact with other programs running under Emacs--for
example, text can easily be cut and pasted between different Emacs text 
buffers. You can even write entire programs using Emacs
<span class="acronym">LISP</span>, if you wish.</p>

<a name="INDEX-2915" /><a name="INDEX-2916" />
</div>




<a name="x-100-3-sec-prog-tools-rcs" /><div class="sect2">
<h3 class="sect2">14.2.7. Revision Control Tools--RCS</h3>

<p><a name="INDEX-2917" />
<a name="INDEX-2918" />
<a name="INDEX-2919" />
<a name="INDEX-2920" />
Revision Control System (<span class="acronym">RCS</span>) has been ported to Linux.
This is a set of programs that allow you to maintain a "library"
of files that records a history of revisions, allows source-file locking
(in case several people are working on the same project), and 
automatically keeps track of source-file version numbers. <span class="acronym">RCS</span> is generally
used with program source-code files, but is general enough to be applicable
to any type of file where multiple revisions must be maintained.</p>

<p>Why bother with revision control? Many large 
projects require some kind of revision control in order to keep track
of many tiny complex changes to the system. For example, attempting to
maintain a program with a thousand source files and a team of several
dozen programmers would be nearly impossible without using something like
<span class="acronym">RCS</span>. With <span class="acronym">RCS</span>, you can ensure that only one person may modify a given
source file at any one time, and all changes are checked in along with
a log message detailing the change.</p>

<p><a name="INDEX-2921" />
<a name="INDEX-2922" />
<span class="acronym">RCS</span> is based on the concept of an <em class="emphasis">RCS file</em>, a file which acts as
a "library" where source files are "checked in" and "checked out." 
Let's say that you have a source file <em class="filename">importrtf.c</em> that you want to maintain
with <span class="acronym">RCS</span>. The <span class="acronym">RCS</span> filename would be <em class="filename">importrtf.c,v</em> by default. The <span class="acronym">RCS</span> file
contains a history of revisions to the file, allowing you to extract
any previous checked-in version of the file. Each revision is tagged with a
log message that you provide.</p>

<p>When you check in a file with <span class="acronym">RCS</span>, revisions are added to the <span class="acronym">RCS</span>
file, and the original file is deleted by default. In order to access the 
original file, you must check it out from the <span class="acronym">RCS</span> file. 
When you're editing a file, you generally don't want someone else to be able to 
edit it at the same time. Therefore, <span class="acronym">RCS</span> places a lock on the file when
you check it out for editing.
A locked file may only be modified by the
user who checks it out (this is accomplished through file permissions). 
Once you're done making changes to the source, you check it back 
in, which allows anyone working on the project to check it back out again 
for further work.
Checking out a file as unlocked does not subject it to these restrictions;
generally, files are checked out as locked only when they are to be edited
but are checked out as unlocked just for reading (for example, to use the
source file in a program build).</p>

<p><span class="acronym">RCS</span> automatically keeps track of all previous revisions in the <span class="acronym">RCS</span> file
and assigns incremental version numbers to each new revision that you
check in. You can also specify a version number of your own when checking
in a file with <span class="acronym">RCS</span>; this allows you to start a new "revision branch"
so that multiple projects can stem from different revisions of the same
file. This is a good way to share code between projects but also to assure that
changes made to one branch won't be reflected in
<?troff \p?> others.</p>

<p>Here's an example. Take the source file <em class="filename">importrtf.c</em>, which contains
our friendly program:
<blockquote><pre class="code">#include &lt;stdio.h&gt; 
 
int main(void) { 
  printf("Hello, world!"); 
}</pre></blockquote>

<a name="INDEX-2923" />
The first step is to check it into <span class="acronym">RCS</span> with the <tt class="command">ci</tt> command:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>ci importrtf.c</b></tt> 
importrtf.c,v  &lt;--  importrtf.c 
enter description, terminated with single '.' or end of file: 
NOTE: This is NOT the log message! 
&gt;&gt; <tt class="userinput"><b>Hello world source code</b></tt> 
&gt;&gt; <tt class="userinput"><b>.</b></tt> 
initial revision: 1.1 
done 
papaya$</pre></blockquote>

The <span class="acronym">RCS</span> file <em class="filename">importrtf.c,v</em> is created, and <em class="filename">importrtf.c</em> is removed.</p>

<p><a name="INDEX-2924" />
In order to work on the source file again, use the <tt class="command">co</tt> command to
check it out. For example:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>co -l importrtf.c</b></tt> 
importrtf.c,v  --&gt;  importrtf.c 
revision 1.1 (locked) 
done 
papaya$</pre></blockquote>

will check out <em class="filename">importrtf.c</em> (from <em class="filename">importrtf.c,v</em>) and lock it. Locking
the file allows you to edit it, and to check it back in. If you only
need to check the file out in order to read it (for example, to issue a
<tt class="command">make</tt>), you can leave the <span class="option">-l</span> switch off of the <tt class="command">co</tt> command
to check it out unlocked. You can't check in a file unless it is locked
first (or it has never been checked in before, as in the example).</p>

<p><a name="INDEX-2925" />
Now, you can make some changes to the source and check it back in
when done. In many cases, you'll want to always have the file checked
out and use <tt class="command">ci</tt> to merely record your most recent revisions in the
<span class="acronym">RCS</span> file and bump the version number. For this, you can use the <span class="option">-l</span>
switch with <tt class="command">ci</tt>, as so:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>ci -l importrtf.c</b></tt> 
importrtf.c,v  &lt;--  importrtf.c 
new revision: 1.2; previous revision: 1.1 
enter log message, terminated with single '.' or end of file: 
&gt;&gt; <tt class="userinput"><b>Changed printf call</b></tt> 
&gt;&gt; <tt class="userinput"><b>.</b></tt> 
done 
papaya$</pre></blockquote>

This automatically checks out the file, locked, after checking it in.
This is a useful way to keep track of revisions even if you're the only one
working on a project.</p>

<p>If you use <span class="acronym">RCS</span> often, you may not like all of those unsightly 
<em class="filename">importrtf.c,v</em> <span class="acronym">RCS</span> files cluttering up your directory. If you create
the subdirectory <em class="filename">RCS</em> within your project directory,
<tt class="command">ci</tt> and <tt class="command">co</tt> will place the <span class="acronym">RCS</span> files there, out of the way
from the rest of the source.</p>

<p>In addition, <span class="acronym">RCS</span> keeps track of all previous revisions of your file.
For instance, if you make a change to your program that causes it to
break in some way and want to revert to the previous version to "undo"
your changes and retrace your steps, you can specify a particular
version number to check out with <tt class="command">co</tt>. For example:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>co -l1.1 importrtf.c</b></tt> 
importrtf.c,v  --&gt;  importrtf.c 
revision 1.1 (locked) 
writable importrtf.c exists; remove it? [ny](n): <tt class="userinput"><b>y</b></tt>  
done 
papaya$</pre></blockquote>


checks out version 1.1 of the file <em class="filename">importrtf.c</em>. 
You can use the program <tt class="command">rlog</tt> to print the revision history of a
particular file; this displays your revision log entries (entered with
<tt class="command">ci</tt>) along with other information such as the date, the user
who checked in the revision, and so forth.</p>

<p><a name="INDEX-2926" />
<span class="acronym">RCS</span> automatically updates embedded "keyword strings" in your
source file at checkout time. For example, if you have the string:
<blockquote><pre class="code">/* $Header$ */</pre></blockquote>


in the source file, <tt class="command">co</tt> will replace it with an informative
line about the revision date, version number, and so forth, as in:
<blockquote><pre class="code">/* $Header: /work/linux/hitch/programming/tools/RCS/rcs.tex 1.2 1994/12/04 15:19:31 mdw Exp mdw $ */</pre></blockquote>


<p>Other keywords exist as well, such as <tt class="literal">$Author$
$Date$</tt>, and <tt>$Log$</tt>
(the latter keeps a complete record of the log entries for each
revision embedded in the source file).</p>

<p>Many programmers place a static string within each source file
to identify the version of the program after it has been compiled.
For example, within each source file in your program, you can
place the line:</p>

<blockquote><tt>static char rcsid[] = "\@(#)$Header$";</tt></blockquote>
<p><a name="INDEX-2927" />
<tt class="command">co</tt> replaces the keyword
<tt class="literal">$Header$</tt> 
with a string of the form given here. This static string survives in the executable, 
and the <tt class="command">what</tt> command displays these strings
in a given binary. For example, after compiling <em class="filename">importrtf.c</em> into the
executable <em class="filename">importrtf</em>, we can use the command:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>what importrtf</b></tt> 
importrtf: 
        $Header: /work/linux/hitch/programming/tools/RCS/rcs.tex 
                      1.2 1994/12/04 15:19:31 mdw Exp mdw $ 
papaya$</pre></blockquote>

<tt class="command">what</tt> picks out strings beginning with the characters <tt class="literal">@(#)</tt>
in a file and displays them. If you have a program that has been compiled
from many source files and libraries, and you don't know how up to date
each of the components are, you can use <tt class="command">what</tt> to display a version 
string for each source file used to compile the binary.</p>

<p>
<span class="acronym">RCS</span> has several other programs in its suite, including <tt class="command">rcs</tt>, 
used for maintaining <span class="acronym">RCS</span> files. Among other things, <tt class="command">rcs</tt> can 
give other users permission to check out sources from an <span class="acronym">RCS</span> file.
See the manual pages for <tt class="command">ci</tt>, <tt class="command">co</tt>, and <tt class="command">rcs</tt> for more
information.</p>

<a name="INDEX-2928" /><a name="INDEX-2929" /><a name="INDEX-2930" /><a name="INDEX-2931" />
</div>




<a name="x-100-3-sec-prog-tools-cvs" /><div class="sect2">
<h3 class="sect2">14.2.8. Revision Control Tools--CVS</h3>

<p><span class="acronym">CVS</span>, the <em class="firstterm">Concurrent
		Version System</em>, is more complex than
<a name="INDEX-2932" />
<a name="INDEX-2933" />
<a name="INDEX-2934" />
<a name="INDEX-2935" />
<a name="INDEX-2936" />
		<span class="acronym">RCS</span> and thus perhaps a little bit oversized 
		for one-man projects. But whenever more than one or two
		programmers are working on a project or the source code is
		distributed over several directories, <span class="acronym">CVS</span>
		is the better choice. <span class="acronym">CVS</span> uses the
		<span class="acronym">RCS</span> file format for saving changes, but
		employs a management structure of its own.</p>

<p>By default, <span class="acronym">CVS</span> works with full
		directory trees. That is, each <span class="acronym">CVS</span> command
		you issue affects
		the current directory and all the
		subdirectories it contains, including their subdirectories and so on.
		This recursive traversal can be switched off with a
		command-line option, or you can specify a single file
		for the command to operate on.</p>

<p><span class="acronym">CVS</span> has formalized the sandbox
		concept that is used
		in many software development shops. In this concept, there is
<a name="INDEX-2937" />
<a name="INDEX-2938" />
		a so-called <em class="emphasis">repository</em> containing the 
		"official" sources that are known to compile and
		work (at least partly). No developer is ever allowed to
		directly edit files in this repository. Instead, each
		developer checks out a local directory tree, the so-called
		<em class="emphasis">sandbox</em>. Here, he can edit the sources to 
		his heart's delight, make changes, add or remove files, and do
		all sorts of things that developers usually do (no, not
		playing Quake or eating marshmallows). When the developer has
		made sure that her changes compile and work, she transmits them 
		to the repository again and thus makes them available for the
		other developers.</p>

<p>When you as a developer have checked out a local directory
		tree, all the files are writable. You can make any
		necessary changes to the files in your personal
		workspace. When you have finished local testing and
		feel sure enough of your work to share the changes
		with the rest of the programming team, you write any
		changed files back into the central repository by
		issuing a <span class="acronym">CVS commit</span> command.
		<span class="acronym">CVS</span> then checks whether another
		developer has checked in changes since you checked
		out your directory tree. If this is the case,
		<span class="acronym">CVS</span> does not let you check your changes in, 
		but asks you first to take the changes of the other
		developers over to your local tree. During this update
		operation, <span class="acronym">CVS</span> uses a sophisticated
		algorithm to reconcile ("merge") your changes with 
		those of the other developers. There are cases in which this
		is not automatically possible. In this case,
		<span class="acronym">CVS</span> informs you that there have been
		conflicts and asks you to resolve those. The file in question
		is marked up with special characters so that you can see where 
		the conflict has occurred and decide which version should be
		used. Note that <span class="acronym">CVS</span> makes sure that
		conflicts can only occur in local developers' trees.
		There is always a consistent version in the
		repository.</p>

<a name="x-100-3-sec-prog-tools-cvs-init" /><div class="sect3">
<h3 class="sect3">14.2.8.1. Setting up a <span class="acronym">CVS</span> repository</h3>

<p>If you are working in a larger project, it is likely
<a name="INDEX-2939" />
		  that someone else has already set up all the necessary
		  machinery to use <span class="acronym">CVS</span>. But if you are your 
		  project's administrator or you just want to tinker around
		  with <span class="acronym">CVS</span> on your local machine, you will
		  have to set up a repository yourself.</p>

<p>First, set your environment variable
<a name="INDEX-2940" />
		  <tt class="literal">CVSROOT</tt> to a directory where you want
		  your <span class="acronym">CVS</span> repository to
		  be. <span class="acronym">CVS</span> can keep as many projects as you
		  like in a repository and makes sure they do not interfere
		  with each other. Thus, you just have to pick a
		  directory once to store all projects maintained by
		  <span class="acronym">CVS</span>, and you won't need to
		  need to change it when you switch
		  projects. Instead of using the variable
		  <tt class="literal">CVSROOT</tt>, you can always use the
		  command-line switch <tt class="literal">-d</tt> with all
		  <span class="acronym">CVS</span> commands, but since this is
		  cumbersome to type all the time, we will assume that you
		  have set <tt class="literal">CVSROOT</tt>.</p>

<p>Once the directory exists for a repository, you can
		  create the repository itself with the following command (assuming that
		  <span class="acronym">CVS</span> is installed on your machine):</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs init</b></tt></pre></blockquote>

<p>There are several different ways to create a project
		  tree in the <span class="acronym">CVS</span> repository. If you
		  already have a directory tree, but it is not yet managed by
		  <span class="acronym">RCS</span>, you can simply import it into the
		  repository by calling:
		  <blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs import <em class="replaceable">directory</em> <em class="replaceable">manufacturer</em> <em class="replaceable">tag</em></b></tt></pre></blockquote>

		  where <em class="replaceable">directory</em> is the name of
		  the top-level directory of the project,
		  <em class="replaceable">manufacturer</em> is the name of the
		  author of the code (you can use whatever you like here) and
		  <em class="replaceable">tag</em> is a so-called release tag
		  that can be chosen at will. For example:</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs import dataimport acmeinc initial</b></tt>
... lots of output ...</pre></blockquote>

<p>If you want to start a completely new project, you can 
		  simply create the directory tree with
		  <tt class="command">mkdir</tt> calls and then import this empty
		  tree like shown in the previous example.</p>

<p>If you want to import a project that is already
		  managed by <span class="acronym">RCS</span>, things get a
		  little bit more difficult, because you cannot use
		  <tt class="command">cvs import</tt>. In this case, you have to
		  create the needed directories directly in the repository and 
		  then copy all <span class="acronym">RCS</span> files (all files that
		  end in <tt class="command">,v</tt>) into those directories. Do not 
		  use <span class="acronym">RCS</span> subdirectories here!</p>

<p>Every repository contains a file named
		  <em class="filename">CVSROOT/modules</em> that contains names 
		  of projects in the repository. It is a good idea to edit the 
		  <em class="filename">modules</em> file of the repository to add
		  the new module. You can check out, 
		  edit, and check in this file like every other file. Thus, in
		  order to add your module to the list, do the following (we
		  will cover the various commands soon):</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs checkout CVSROOT/modules</b></tt>
$tigger <tt class="userinput"><b>cd CVSROOT</b></tt>
$tigger <tt class="userinput"><b>emacs modules</b></tt>
... or any other editor of your choice, see below for what to enter ...
$tigger <tt class="userinput"><b>cvs commit modules</b></tt>
$tigger <tt class="userinput"><b>cd ..</b></tt>
$tigger <tt class="userinput"><b>cvs release -d CVSROOT</b></tt></pre></blockquote>

<p>If you are not doing anything fancy, the format of the
		  <em class="filename">modules</em> file is very easy: Each line starts
		  with the name of module, followed by a space or tab and the path
		  within the repository. There are many more things you can do with
		  the <em class="filename">modules</em> file which you can find in the
		  <span class="acronym">CVS</span> documentation, especially in the Info 
		  pages or at <a href="../../../../../../www.loria.fr/~molli/cvs-index.html">http://www.loria.fr/~molli/cvs-index.html</a>.</p>
</div>


<div class="sect3">
<h3 class="sect3">14.2.8.2. Working with <span class="acronym">CVS</span></h3>

<p>In the following section, we will assume that either you or
		  your system administrator has set up a module called
		  <tt class="literal">dataimport</tt>. You can now check out a local tree of this
		  module with the following command:</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs checkout dataimport</b></tt></pre></blockquote>

<p>If there is no module defined for the project you want to 
		  work on, you need to know the path within the repository. For
		  example, something like the following could be needed:</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs checkout <em class="replaceable">clients/acmeinc/dataimport</em></b></tt></pre></blockquote>

<p>Whichever version of the <tt class="command">checkout</tt>
		  command you use, <span class="acronym">CVS</span>
		  will create a directory called
		  <em class="filename">dataimport</em> under your current working
		  directory and check
		  out all files and directories from the repository that belong to
		  this module. All files are writable, and you can start editing them
		  right away.</p>

<p>After you have made some changes, you can write back the
		  changed files into the repository with one single command:</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs commit</b></tt></pre></blockquote>

<?troff .Nd 10?><p>Of course, you can also check in single files:</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs commit importrtf.c</b></tt></pre></blockquote>

<p>But whatever you do, <span class="acronym">CVS</span> will ask you--as <span class="acronym">RCS</span> does--for a comment to
		  include with your changes. But
		  <span class="acronym">CVS</span> goes a step beyond
		  <span class="acronym">RCS</span> in convenience. Instead of the 
		  rudimentary prompt from <span class="acronym">RCS</span>, you
		  get a full-screen editor to work in. You can
		  choose this editor by setting the environment variable
		  <tt class="literal">CVSEDITOR</tt>; if this is not set,
		  <span class="acronym">CVS</span> looks in <tt class="literal">EDITOR</tt>, and if
		  this is not defined either, <span class="acronym">CVS</span>
		  invokes <tt class="command">vi</tt>.
		  If you 
		  check in a whole project, <span class="acronym">CVS</span> will use the
		  comment you entered for each directory in which there have been
		  changes but will start a new editor every time to ask you
		  whether you might want to change each file.</p>

<p>As already mentioned, it is not necessary to set
		  <tt class="command">CVSROOT</tt> correctly for checking files in, because
		  when checking the tree out, <span class="acronym">CVS</span> has created a
		  directory <em class="filename">CVS</em> in each work directory. This
		  directory contains all the information that <span class="acronym">CVS</span> needs 
		  for its work, including where to find the repository.</p>

<p>While you have been working on your files, it may well be that 
		  a co-worker has checked in some of the files that you are currently
		  working on. In this case, <span class="acronym">CVS</span> will not let you
		  check in your files but asks you to first update your local
		  tree. Do this with the command:</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs update</b></tt>
M importrtf.c
A exportrtf.c
? importrtf
U importword.c</pre></blockquote>

<p>(You can specify a single file here as well.) You should
		  carefully examine the output of this command: <span class="acronym">CVS</span> 
		  outputs the names of all the files it handles, each preceded by a single key letter. This 
		  letter tells you what has happened during the update operation. The
		  most important letters are shown in <a href="ch14_02.htm">Table 14-1</a>.</p>

<a name="x-100-3-table-cvs-letters" /><h4 class="objtitle">Table 14-1. Key Letters for Files Under CVS</h4><table border="1">

<tr>
<th><p>Letter</p></th>
<th><p>Explanation</p></th>
</tr>




<tr>
<td rowspan="0"><p><tt class="literal">P</tt></p></td>
<td rowspan="0"><p>The file has been updated. The P is shown if the file 
				  has been added to the repository in
				  the meantime or if it has been 
				  changed, but you have not made any changes to this file
				  yourself.</p></td>
</tr>

<tr>
<td rowspan="0"><p><tt class="literal">U</tt></p></td>
<td rowspan="0"><p>You have changed this file in the meantime, but
				  nobody else has.</p></td>
</tr>

<tr>
<td rowspan="0"><p><tt class="literal">M</tt></p></td>
<td rowspan="0"><p>You have changed this file in the meantime, and
				  somebody else has checked in a newer version. All the
				  changes have been merged successfully.</p></td>
</tr>

<tr>
<td rowspan="0"><p><tt class="literal">C</tt></p></td>
<td rowspan="0"><p>You have changed this file in the meantime, and
				  somebody else has checked in a newer version. During the
				  merge attempt, conflicts have arisen.</p></td>
</tr>

<tr>
<td rowspan="0"><p><tt class="literal">?</tt></p></td>
<td rowspan="0"><p><span class="acronym">CVS</span> has no information about this
				  file, that is, this file is not under <span class="acronym">CVS</span>'s
				  control.</p></td>
</tr>


</table>

<p>The <tt class="literal">C</tt> is the most important of those
		  letters. <span class="acronym">CVS</span> was not able to merge all changes
		  and needs your help. Load those files into your editor and look for
		  the string <tt class="literal">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</tt>. After
		  this string, the name 
		  of the file is shown again, followed by your version, ending with a line
		  containing <tt class="literal">=======</tt>. Then comes
		  the version of the code from the repository, ending
		  with a line containing
		  <tt class="literal">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</tt>. You now have to find out--probably by communicating with your co-worker--which version is better or whether it is possible to merge
		  the two versions by hand. Change the file accordingly and remove the 
		  <span class="acronym">CVS</span> markings <tt class="literal">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</tt>,
		  <tt class="literal">=======</tt> and
		  <tt class="literal">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</tt>. Save the file and
		  once again commit it.</p>

<p>If you decide that you want to stop working on a project for a 
		  time, you should check whether you have really committed all
		  changes. To do this, change to the directory above the root
		  directory of your project and issue the command:</p>

<blockquote><pre class="code">$tigger <tt class="userinput"><b>cvs release dataimport</b></tt></pre></blockquote>

<p><span class="acronym">CVS</span> then checks whether you have written
		  back all changes into the repository and warns you if necessary. A
		  useful option is <tt class="command">-d</tt>, which
		  deletes the local tree if all changes have been committed.</p>
</div>


<div class="sect3">
<h3 class="sect3">14.2.8.3. CVS over the Internet</h3>

<p>CVS is also very useful where distributed
<a name="INDEX-2941" />
<a name="INDEX-2942" />
<a name="INDEX-2943" />
<a name="INDEX-2944" />

		  development teams<a href="#FOOTNOTE-55">[55]</a> are concerned, because it provides several
			possibilities to access a repository on another machine.</p><blockquote>

<a name="FOOTNOTE-55" /><p>[55]The use of <span class="acronym">CVS</span> has
		  burgeoned along with the number of free software projects which
			  are developed over the Internet by people from different
			  continents.</p>

</blockquote>

<p>If you can log into the machine holding the repository with
<a name="INDEX-2945" />
		  <tt class="command">rsh</tt>, you can use remote <span class="acronym">CVS</span> to access the
		  repository. To check out a module, do the following:</p>

<blockquote><pre class="code"><tt class="userinput"><b>cvs -d :ext:<em class="replaceable">user@domain.com</em>:<em class="replaceable">/path/to/repository</em> checkout dataimport</b></tt></pre></blockquote>

<p>If you cannot or do not want to use <tt class="command">rsh</tt>
		  for security reasons, you can also use the secure shell
		  <tt class="command">ssh</tt>. You can tell <span class="acronym">CVS</span> that you 
		  want to use <tt class="command">ssh</tt> by setting the environment
		  variable <tt class="literal">CVS_RSH</tt> to
		  <tt class="command">ssh</tt>.</p>

<p>Authentication and access to the repository can also be done 
		  via a client/server protocol. Remote access requires a
		  <span class="acronym">CVS</span> server running on the machine with the
		  repository; see the <span class="acronym">CVS</span> documentation for how to
		  do this. If the server is set up, you can login to it with:</p>

<blockquote><pre class="code"><tt class="userinput"><b>cvs -d :pserver:<em class="replaceable">user@domain.com</em>:<em class="replaceable">path/to/repository</em></b></tt>
CVS password:</pre></blockquote>

<p>As shown, the <span class="acronym">CVS</span> server will ask you for
		  your <span class="acronym">CVS</span> password, which has been assigned to you
		  by the administrator of the <span class="acronym">CVS</span> server. This
		  login procedure is necessary only once for every repository. When
		  you check out a module, you need to specify the machine with the
		  server, your username on that machine, and the remote path to the
		  repository; as with local repositories, this information is saved
		  in your local tree. Since the password is saved with
		  minimal encryption in the file <em class="filename">.cvspass</em> in your home
		  directory, there is a potential security risk here. The
		  <span class="acronym">CVS</span> documentation tells you more about
		  this.</p>

<p>When you use <span class="acronym">CVS</span> over the Internet and check out or update
largish modules, you might also want to use the
<tt class="command">-z</tt> option, which expects an additional integer 
parameter and transmits the data in compressed form.</p>
</div>


<a name="INDEX-2946" /><a name="INDEX-2947" /><a name="INDEX-2948" /><a name="INDEX-2949" /><a name="INDEX-2950" />
</div>




<a name="x-100-3-prog-tools-patch" /><div class="sect2">
<h3 class="sect2">14.2.9. Patching Files</h3>

<p><a name="INDEX-2951" />
<a name="INDEX-2952" />
<a name="INDEX-2953" />
Let's say that you're trying to maintain a program that is updated
periodically, but the program contains many source files, and releasing
a complete source distribution with every update is not feasible.
The best way to incrementally update source files is with <tt class="command">patch</tt>,
a program by Larry Wall, author of Perl.</p>

<p><tt class="command">patch</tt> is a program that makes context-dependent changes
in a file in order to update that file from one version to the next. 
This way,
when your program changes, you simply release a patch file against the
source, which the
user applies with <tt class="command">patch</tt> to get the newest version. For example,
Linus Torvalds usually releases new Linux kernel versions in the form of patch files as
well as complete source distributions.</p>

<p>A nice feature of <tt class="command">patch</tt> is that it applies updates
in context; that
is, if you have made changes to the source yourself, but still wish to
get the changes in the patch file update, <tt class="command">patch</tt> usually can
figure out the right location in the original file to apply the
changes to.
This way, your versions of the original source files don't need to 
correspond exactly to those that the patch file was made against.</p>

<p><a name="INDEX-2954" />
In order to make a patch file, the program <tt class="command">diff</tt> is used, which
produces "context diffs" between two files. For example, take our
overused "Hello World" source code, given here:</p>

<blockquote><pre class="code">/* hello.c version 1.0 by Norbert Ebersol */ 
#include &lt;stdio.h&gt;  
 
int main() { 
  printf("Hello, World!"); 
  exit(0); 
}</pre></blockquote>

<p>Let's say that you were to update this source, as in the following:
<blockquote><pre class="code">/* hello.c version 2.0 */ 
/* (c)1994 Norbert Ebersol */ 
#include &lt;stdio.h&gt;  
 
int main() { 
  printf("Hello, Mother Earth!\n"); 
  return 0; 
}</pre></blockquote></p>

<p>If you want to produce a patch file to update the original <em class="filename">hello.c</em> to
the newest version, use <tt class="command">diff</tt> with the <span class="option">-c</span> option:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>diff -c hello.c.old hello.c &gt; hello.patch</b></tt></pre></blockquote>

This produces the patch file <em class="filename">hello.patch</em> that describes how
to convert the original <em class="filename">hello.c</em> (here, saved in the file
<em class="filename">hello.c.old</em>) to the new version. You can
distribute this patch file
to anyone who has the original version of "Hello, World," and they can
use <tt class="command">patch</tt> to update it.</p>

<p>Using <tt class="command">patch</tt> is quite simple; in most cases, you
simply run it with the patch file as input:<a href="#FOOTNOTE-56">[56]</a>
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>patch &lt; hello.patch</b></tt> 
Hmm...  Looks like a new-style context diff to me... 
The text leading up to this was: 
-------------------------- 
|*** hello.c.old        Sun Feb  6 15:30:52 1994 
|--- hello.c    Sun Feb  6 15:32:21 1994 
-------------------------- 
Patching file hello.c using Plan A... 
Hunk #1 succeeded at 1. 
done 
papaya$</pre></blockquote>

<tt class="command">patch</tt> warns you if it appears as though the patch has already
been applied. If we tried to apply the patch file again, <tt class="command">patch</tt> 
would ask us if we wanted to assume that <span class="option">-R</span> was
enabled--which
reverses the patch. This is a good way to back out patches
you didn't intend to apply. <tt class="command">patch</tt> also saves the original
version of each file that it updates in a backup file, usually named
<em class="replaceable">filename</em><tt class="literal">~</tt> (the filename with a tilde appended).</p><blockquote>

<a name="FOOTNOTE-56" /><p>[56]The output shown here is from the last version that Larry Wall has
released, Version 2.1. If you have a newer version of patch, you will
need the <span class="option">- -verbose</span> flag to get
the same output.</p>

</blockquote>

<p>In many cases, you'll want to update not only a single source file
but an entire directory tree of sources.  <tt class="command">patch</tt>
allows many files to be updated from a single diff. Let's say you have
two directory trees, <em class="filename">hello.old</em> and
<em class="filename">hello</em>, which contain the sources
<?troff .ne 10?> for the old and
new versions of a program, respectively.  To make a patch file for the
entire tree, use the <span class="option">-r</span> switch with
<tt class="command">diff</tt>:</p>

<blockquote><pre class="code">papaya$ <tt class="userinput"><b>diff -cr hello.old hello &gt; hello.patch</b></tt></pre></blockquote>

<p>Now, let's move to the system where the software needs to be updated.
Assuming that the original source is contained in the
directory <em class="filename">hello</em>, you can apply the patch with:</p>

<blockquote><pre class="code">papaya$ <tt class="userinput"><b>patch -p0 &lt; hello.patch</b></tt></pre></blockquote>

<p>The <span class="option">-p0</span> switch tells <tt class="command">patch</tt> to preserve the pathnames of
files to be updated (so it knows to look in the <em class="filename">hello</em>
directory for the source). If you have the source to be patched
saved in a directory named differently from that given in the patch file,
you may need to use the <span class="option">-p</span> option.

See the <tt class="command">patch</tt> manual page for details about this.</p>

<a name="INDEX-2955" /><a name="INDEX-2956" />
</div>




<div class="sect2">
<h3 class="sect2">14.2.10. Indenting Code</h3>

<p><a name="INDEX-2957" />
<a name="INDEX-2958" />
<a name="INDEX-2959" />
<a name="INDEX-2960" />
If you're terrible at indenting code and find the idea of an editor
that automatically indents code for you on-the-fly a bit annoying,
you can use the <tt class="command">indent</tt> program to pretty-print your code after you're
done writing it. <tt class="command">indent</tt> is a smart C-code formatter, and 
has many options allowing you to specify just what kind of indentation
style you wish to use.</p>

<p>Take this terribly formatted source:
<blockquote><pre class="code">double fact (double n) { if (n==1) return 1; 
else return (n*fact(n-1)); } 
int main () { 
printf("Factorial 5 is %f.\n",fact(5)); 
printf("Factorial 10 is %f.\n",fact(10)); exit (0); }</pre></blockquote>


Running <tt class="command">indent</tt> on this source produces the
relatively beautiful code:
<blockquote><pre class="code">#include &lt;math.h&gt; 
 
double 
fact (double n) 
{ 
  if (n == 1) 
    return 1; 
  else 
    return (n * fact (n - 1)); 
} 
void 
main () 
{ 
<?troff .ne 10?>
  printf ("Factorial 5 is %f.\n", fact (5)); 
  printf ("Factorial 10 is %f.\n", fact (10)); 
  exit (0); 
}</pre></blockquote>

<a name="INDEX-2961" />
Not only are lines indented well, but whitespace is added around operators
and function parameters to make them more readable. There are many 
ways to specify how the output of <tt class="command">indent</tt> will look;
if you're not fond of this particular indentation style,
<tt class="command">indent</tt> can accommodate you.</p>

<p><a name="INDEX-2962" />
<tt class="command">indent</tt> can also produce <tt class="command">troff</tt> code from a source file, 
suitable for printing or for inclusion in a technical document. 
This code will have such nice features as italicized comments, boldfaced
keywords, and so on. Using a command such as:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>indent -troff importrtf.c | groff -mindent</b></tt></pre></blockquote>

produces <tt class="command">troff</tt> code and formats it with <tt class="command">groff</tt>.</p>

<a name="INDEX-2963" /><a name="INDEX-2964" /><a name="INDEX-2965" /><a name="INDEX-2966" />
</div>


<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch14_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch15_01.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">14. Tools for
 Programmers</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">15. TCP/IP and PPP</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="index.htm" coords="172,2,252,105" shape="rect" /><area href="../apache/index.htm" coords="238,2,334,95" shape="rect" /><area href="../sql/index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="../cgi/index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>
