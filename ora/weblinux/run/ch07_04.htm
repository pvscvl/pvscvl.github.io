<?label 7.4. Building a New Kernel?><html><head><title>Building a New Kernel (Running Linux)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="Running Linux" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch07_03.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm" /></td><td width="172" valign="top" align="right"><a href="ch07_05.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<h2 class="sect1">7.4. Building a New Kernel</h2>

<p><a name="INDEX-1626" />
<a name="INDEX-1627" />
<a name="INDEX-1628" />
Rebuilding the kernel sounds like a pastime for hackers, but it is
an important skill for any system administrator.  First, you should
rebuild the kernel on your system to eliminate the device drivers
you don't need. This
reduces the amount of memory used by the kernel itself, as
described in the section
"<a href="ch06_02.htm">Section 6.2, "Managing Swap Space"</a>," in

<a href="ch06_01.htm">Chapter 6, "Managing
 Filesystems, Swap,
 and Devices"</a>,
the kernel is always
present in memory, and the memory it uses cannot be
reclaimed for use by programs if necessary.</p>

<p>You also need to occasionally upgrade your kernel to a newer version.
As with any piece of your system, if you know of important bug fixes 
or new features in a kernel release, you may want to upgrade to pick them up. 
Those people who are actively developing kernel code will also need to 
keep their kernel up to date in case changes are made to the code
they are working on. Sometimes, it is necessary to upgrade your kernel
to use a new version of the compiler or libraries. Some applications
(such as the X Window System) require a certain kernel version
to run.</p>

<p><a name="INDEX-1629" />
You can find out what kernel version you are running through the command 
<tt class="command">uname -a</tt>. This should produce something like:

<blockquote><pre class="code">rutabaga% <tt class="userinput"><b>uname -a</b></tt> 
Linux tigger 2.0.35 #4 Wed Sep 30 12:44:16 CEST 1998 i586</pre></blockquote>


Here, we see a machine running Version 2.0.35 of the kernel, which was
last compiled on September 30. We see other information as well,
such as the hostname of the machine, the number of times this

kernel has been compiled (four), and the fact that the machine is a
Pentium or equivalent (as denoted by <tt class="literal">i586</tt>). The
manual page for <tt class="command">uname</tt>
can tell you more.</p>

<p> 
The Linux kernel is a many-tentacled beast. Many groups of people work
on different pieces of it, and some parts of the code are a patchwork
of ideas meeting different design goals. Overall, however, the kernel
code is clean and uniform, and those interested in exploring its
innards should have little trouble doing so. However, because of the 
great amount of development going on with the kernel, new releases
are made very rapidly--sometimes daily! The chief reason for this
is that nearly all device drivers are contained within the kernel
code, and every time someone updates a driver, a new release is
necessary. As the Linux community moves towards loadable device drivers, 
the maintainers of those drivers can release them independently of the 
main kernel, alleviating the necessity of such rapid updates.</p>

<p><a name="INDEX-1630" />
Currently, Linus Torvalds maintains the "official" kernel release. 
Although the General Public License allows anyone to modify and
rerelease the kernel under the same copyright, Linus's maintenance
of an "official" kernel is a helpful convention that
keeps version numbers uniform and allows everyone to be on equal
footing when talking about kernel revisions. In order for a bug fix
or new feature to be included in the kernel, all one must do is
send it to Linus, who will usually incorporate the change as long
as it doesn't break anything.</p>

<p><a name="INDEX-1631" />
<a name="INDEX-1632" />
Kernel version numbers follow the convention:

<blockquote><pre class="code"><em class="replaceable">major</em>.<em class="replaceable">minor</em>.<em class="replaceable">patchlevel</em></pre></blockquote>


<em class="replaceable">major</em> is the major version number, which rarely changes,
<em class="replaceable">minor</em> is the minor version number, which indicates the current
"strain" of the kernel release, and <em class="replaceable">patchlevel</em> is the number
of the patch to the current kernel version. Some examples of kernel
versions are 2.0.36, (patch level 36 of kernel Version 2.0), and 2.1.52 
(patch level 52 of kernel Version 2.1).</p>

<p>By convention, even-numbered kernel versions (2.0, 2.2, and so on)
are "stable" releases, patches that contain only bug fixes
and no new features. Odd-numbered kernel versions (2.1, 2.3, and so on)
are "development" releases, patches that contain whatever new
code developers wish to add and bug fixes for that code. When a development
kernel matures to the point where it is stable enough for wide use,
it is renamed with the next highest (even) minor version number, and
the development cycle begins again.</p>

<p>For example, kernel Versions 2.0 and 2.1 were worked on concurrently.
Patches made to 2.0 were bug fixes--meant only to correct problems
in the existing code. Patches to 2.1 included bug fixes as well as
a great deal of new code--new device drivers, new features, and so on.
When kernel Version 2.1 was stable enough, 
it was renamed to 2.2; a copy was made and named Version 2.3.
Development continued with Versions 2.2 and 2.3. 2.2 would be the
new "stable" kernel while 2.3 was a development kernel for
new features.</p>

<p>Note that this version-numbering convention applies only to Linus's
official kernel release and only to kernel versions after 1.0. 
Prior to 1.0 (this is now ancient
history), there was only one "current" kernel version and patches
were consistently made to it. The kernel development community has
found that having two concurrent kernel versions allows those who
want to experiment to use the development kernel, and those who
need a reliable platform to stick with the stable kernel. In this way,
if the development kernel is seriously broken by new code, it shouldn't
affect those who are running the newest stable kernel. The general rule
is that you should use development kernels if you want to be
on the leading edge of new features and are willing to risk problems
with your system. 
<img src="figs/bomb.gif">&nbsp;&nbsp;Use the development kernels at your own risk.</p>

<p>If you are interested in how the kernel versions so far have evolved,
check out <em class="emphasis">http://ps.cus.mist.ac.uk/~rhw/kernel.versions.html</em>.</p>

<p><a name="INDEX-1633" />
On your system, the kernel sources most probably live in
<em class="filename">/usr/src/linux</em> (unless you use the Debian
distribution, where you can find the kernel sources in
<em class="filename">/usr/src/kernel-source-</em><em class="replaceable">versionsnumber</em>).
If you are going to rebuild your kernel only from the current sources,
you don't need to obtain any files or apply any patches. If you wish
to upgrade your kernel to a new version, you need to follow the
instructions in the following section.</p>

<a name="x-100-3-sec-sysadm-kernel-upgrade" /><div class="sect2">
<h3 class="sect2">7.4.1. Obtaining Kernel Sources</h3>

<p><a name="INDEX-1634" />
<a name="INDEX-1635" />
<a name="INDEX-1636" />
The official kernel is released as a gzipped tar file, containing
the sources along with a series of patch files--one per patch level.
The tar file contains the source for the unpatched revision; for
example, there is a tar file containing the sources for kernel
Version 1.1 with no patches applied. Each subsequent patch level is
released as a patch file (produced using <tt class="command">diff</tt>), which can be applied
using the <tt class="command">patch</tt> program.
In the section "<a href="ch14_02.htm">Section 14.2.9, "Patching Files"</a>" in

<a href="ch14_01.htm">Chapter 14, "Tools for
 Programmers"</a>, we describe the use of <tt class="command">patch</tt> in
detail.</p>

<p><a name="INDEX-1637" />
<a name="INDEX-1638" />
<a name="INDEX-1639" />
Let's say you're upgrading to kernel Version 1.1 patch level 15. 
You'll need the sources for 1.1 (the file might be named
<em class="filename">v1.1.0.tar.gz</em>) and the patches for patch levels 1 through 15. 
These files would be named <em class="filename">patch1</em>, <em class="filename">patch2</em>, and so forth.
(You need <em class="emphasis">all</em> of the patch files up to the version you're
upgrading to. Usually, these patch files are rather small, and are
gzipped on the archive sites.) All these files can be found in the 
<em class="filename">kernel</em> directory of the Linux <span class="acronym">FTP</span> archive sites; for example, 
on ftp://ftp.kernel.org, the directory containing the 2.2 sources 
and patches is <em class="filename">/pub/linux/kernel/v2.2</em>. You will
find the kernel sources here as tar archives, both
compressed with <tt class="command">gzip</tt> and <tt class="command">bzip2</tt>.</p>

<p>If you are already at some patch level of the kernel (such as 2.1 patch level
15) and want to upgrade to a newer patch level, you can simply apply the 
patches from the version you have up to the version you'd like to 
upgrade to. If you're upgrading from, say, 2.1 patch level 15 to 2.1 
patch level 19, you need the patch files for 2.1.16 to 2.1.19 inclusive.</p>

<div class="sect3">
<h3 class="sect3">7.4.1.1. Unpacking the sources</h3>

<p>First, you need to unpack the source tar file from <em class="filename">/usr/src</em>. 
You do this with commands such as:
<blockquote><pre class="code">rutabaga# <tt class="userinput"><b>cd /usr/src</b></tt> 
rutabaga# <tt class="userinput"><b>mv linux linux.old</b></tt> 
rutabaga# <tt class="userinput"><b>tar xzf v1.1.0.tar.gz</b></tt></pre></blockquote>

This saves your old kernel source tree as <em class="filename">/usr/src/linux.old</em>
and creates <em class="filename">/usr/src/linux</em>, containing the new sources. Note that
the tar file containing the sources includes the <em class="filename">linux</em>
subdirectory.</p>

<p>You should keep your current kernel sources in the directory 
<em class="filename">/usr/src/linux</em>, because there are two symbolic 
links--<em class="filename">/usr/include/linux</em> and <em class="filename">/usr/include/asm</em>--that
point into the current kernel source tree to provide certain header
files when compiling programs. (You should always
have your kernel sources available so that programs using these
include files can be compiled.) If you want to keep several kernel
source trees around, be sure that <em class="filename">/usr/src/linux</em> points
to the most recent one.</p>
</div>


<div class="sect3">
<h3 class="sect3">7.4.1.2. Applying patches</h3>

<p><a name="INDEX-1640" />
<a name="INDEX-1641" />
<a name="INDEX-1642" />
<a name="INDEX-1643" />
If you are applying any patch files, you use the <tt class="command">patch</tt> program.
Let's say that you have the files <em class="filename">patch1.gz</em> through
<em class="filename">patch15.gz</em>, which are gzipped. These patches should be applied from
<em class="filename">/usr/src</em>. That doesn't mean the patch files themselves should
be located there, but rather that <tt class="command">patch</tt> should be executed
from <em class="filename">/usr/src</em>. For each patch file, use the command:
<blockquote><pre class="code">gunzip -c <em class="replaceable">patchfile</em> | patch -p0</pre></blockquote>

from <em class="filename">/usr/src</em>. The <span class="option">-p0</span> option tells <tt class="command">patch</tt> it 
shouldn't strip any part of the filenames contained within the patch file.</p>

<p>You must apply each patch in numerical order by patch level. This is
very important. Note that using a wildcard such as <em class="filename">patch*</em> will
not work because the <tt class="literal">*</tt> wildcard uses ASCII order,
not numeric order. (Otherwise you'd get <em class="filename">patch1</em>
followed by <em class="filename">patch10</em> and <em class="filename">patch11</em>, as opposed to <em class="filename">patch2</em>
and <em class="filename">patch3</em>.) It is best to run the previous command
for each patch file in succession, by hand. This way you can ensure
you're doing things in the right order.</p>

<p>You shouldn't encounter problems when patching your source tree in this
way unless you try to apply patches out of order or apply a patch more
than once. Check the <tt class="command">patch</tt> manual page if you do encounter trouble.
If all else fails, remove the new kernel source tree and start over
from the original tar file.</p>

<p>To double-check that the patches were applied successfully, use the
commands:
<blockquote><pre class="code">find /usr/src/linux -follow -name "*.rej" -print  
find /usr/src/linux -follow -name "*#" -print</pre></blockquote>

This lists any files that are "rejected" portions of the patch
process. If any such files exist, they contain sections of the patch file
that could not be applied for some reason. Look into these, and if
there's any doubt start over from scratch. You cannot expect
your kernel to compile or work correctly if the patch process did not
complete successfully and without rejections.</p>

<a name="INDEX-1644" /><a name="INDEX-1645" /><a name="INDEX-1646" /><a name="INDEX-1647" /><a name="INDEX-1648" />
</div>
</div>




<a name="x-100-3-sec-sysadm-kernel-build" /><div class="sect2">
<h3 class="sect2">7.4.2. Building the Kernel</h3>

<p><a name="INDEX-1649" />
<a name="INDEX-1650" />
Whether or not you've upgraded your kernel sources, you're ready to build
a new kernel. The primary reason to do this is either to simply upgrade
or to trim down your current kernel, excluding unneeded device drivers.</p>

<p>There are six steps to building the kernel, and they should be quite
painless.  All of these steps are described in more detail in the
following pages.</p>

<ol><li><p>Run <tt class="command">make config</tt>, which asks you various questions about
which drivers you wish to include. You could also use the more
comfortable variants <tt class="command">make menuconfig</tt> or (only when 
you are running the X Window System) <tt class="command">make xconfig</tt>.</p></li><li><p>Run <tt class="command">make dep</tt> to gather dependencies for each source file
and include them in the various makefiles.</p></li><li><p>If you have built a kernel from this source tree before, run
<tt class="command">make clean</tt> to clear out old object files and force a
complete rebuild.</p></li><li><p>Run <tt class="command">make zImage</tt> to build the kernel itself.</p></li><li><p>Go have a coffee (or two, depending on the speed of your machine
and amount of available memory).</p></li><li><p>Install the new kernel image, either on a boot floppy or via <span class="acronym">LILO</span>.</p></li></ol><p>
All these commands are executed from <em class="filename">/usr/src/linux</em>, except for 
Step 5, which you can do anywhere.</p>

<p>There is a <em class="filename">README</em> included in the kernel sources, which should
be located at <em class="filename">/usr/src/linux/README</em> on your system. Read it. 
It contains up-to-date notes on kernel compilation, which may be more
current than the information presented here. Be sure to follow the steps
described there, using the descriptions given later in this section as a guide.</p>

<p><a name="INDEX-1651" />
The first step is to run <tt class="command">make config</tt>. This executes a script that
asks you a set of yes/no questions about which drivers to include in the
kernel. There are defaults for each question, but be careful: the defaults
probably don't correspond to what you want. (When several options are
available, the default will be shown as a capital letter, as in
<tt class="literal">[Y/n]</tt>.)
Your answers to each question will become the default the next time
you build the kernel from this source tree.</p>

<p>Simply answer each question, either by pressing Enter for
the default, or pressing y or n (followed by 
Enter). Not all of the questions have a yes/no answer; 
you may be asked to enter a number or some other value. 
A number of the configuration questions allow an answer of 
m in addition to y or 
n. This option allows the corresponding kernel
feature to be compiled as a loadable kernel module, as opposed to 
building it into the kernel image itself. Loadable modules, covered
in the following section, "<a href="ch07_05.htm">Section 7.5, "Loadable Device Drivers"</a>," allow portions of the kernel (such as device drivers) to be loaded and
unloaded as needed on a running system. If you are unsure about an
option, type <tt class="literal">?</tt> at the prompt; for most options, a
message will be shown that tells you more about the option.</p>

<p><a name="INDEX-1652" />
An alternative to running <em class="emphasis">make config</em> is 
<em class="emphasis">make xconfig</em>, which compiles and runs an
X-Window-based kernel configuration program. In order for this to work,
you must have the X Window System running, have the appropriate X11
and Tcl/Tk libraries installed, and so forth. Instead of asking a series
of questions, the X-based configuration utility allows you to
use checkboxes to select which kernel options you want to enable. 
The system remembers your configuration options each time you run <em class="emphasis">make config</em>,
so if you're only adding or removing a few features from your kernel,
you need not reenter all the options.</p>

<p><a name="INDEX-1653" />
Also available is <tt class="literal">make menuconfig</tt>, which uses the 
text-based <em class="emphasis">curses</em> library, providing a similar menu-based 
kernel configuration if you don't have X installed. <tt class="command">make
menuconfig</tt> and <tt class="command">make xconfig</tt> are much more 
comfortable than <tt class="command">make config</tt>, especially because
you can go back to an option and change your mind until you save your configuration.</p>

<p>The following is part of a session with <tt class="command">make
config</tt>. When using <tt class="command">make menuconfig</tt> or
<tt class="command">make xconfig</tt>, you will encounter the same options,
only presented more user-friendly:</p>

<blockquote><pre class="code">*
* Code maturity level options
*
Prompt for development and/or incomplete code/drivers\
(CONFIG_EXPERIMENTAL) [N/y/?]
*
* Processor type and features
*
Processor family (386, 486/Cx486, 586/K5/5x86/6x86,Pentium/K6/TSC,\ 
PPro/6x86MX) [PPro/6x86MX]
  defined CONFIG_M686
Math emulation (CONFIG_MATH_EMULATION) [N/y/?]
MTRR (Memory Type Range Register) support (CONFIG_MTRR) [N/y/?]
Symmetric multi-processing support (CONFIG_SMP) [Y/n/?]
*
* Loadable module support
*
Enable loadable module support (CONFIG_MODULES) [Y/n/?]
Set version information on all symbols for modules\
(CONFIG_MODVERSIONS) [N/y/?]
Kernel module loader (CONFIG_KMOD) [N/y/?]
*
* General setup
*
<?troff .ne 10?>
Networking support (CONFIG_NET) [Y/n/?] 
The linux kernel is now hopefully configured for your setup. 
Check the top-level Makefile for additional configuration, 
and do a 'make dep ; make clean' if you want to be sure all 
the files are correctly re-made</pre></blockquote>

<p>If you understand the 
hardware present on your machine, the questions should be
straightforward. The following questions are found
in the kernel configuration for version 2.2. If you have applied other
patches, additional questions might appear. The same is true for
later versions of the kernel. Note that in the following list we don't
show all of the kernel configuration options; there are simply too many
of them, and most are self-explanatory. We have highlighted only those
that may require further explanation. Remember that if you're not sure
how to answer a particular question, the default answer is often the best
choice. When in doubt, it is also a good idea to type
<tt class="literal">?</tt> and check the help message.</p>

<p>It should be noted here that not all Linux device drivers are actually
built into the kernel. Instead, some drivers are available only as loadable
modules, distributed separately from the kernel sources. (As mentioned
earlier, some drivers can be either built into the kernel or compiled as
modules.) One notable kernel driver available only as a module is the
"floppy tape" driver for <span class="acronym">QIC</span>-117 tape drives that connect
to the floppy controller.</p>

<p>If you can't find support for your favorite hardware device
in the list presented by <em class="emphasis">make config</em>, it's quite
possible that the driver is available as a module or a separate kernel
patch. Scour the <span class="acronym">FTP</span> sites and archive
<span class="acronym">CD-ROMs</span> if you can't find what
you're looking for. In the section "<a href="ch07_05.htm">Section 7.5, "Loadable Device Drivers"</a>" later in this chapter, kernel modules
are covered in detail.
<a name="INDEX-1654" />
<a name="INDEX-1655" />
<a name="INDEX-1656" /></p>

<dl>
<dt><b><tt class="literal">Prompt for development and/or incomplete code/drivers</tt></b></dt><dd><p>Answer yes for this item if you want to try new
				features that aren't considered stable enough by the
				developers. You do not want this option unless you
				want to help test new features.</p></dd>


<dt><b><tt class="literal">Processor family (386, 486/Cx486, 586/K5/5x86/6x86,</tt></b></dt><dt><b><tt class="literal">Pentium/K6/TSC, PPro/6x86MX)</tt></b></dt><dd><p>Here, you have to specify the CPU type that you
<a name="INDEX-1657" />
				have. The kernel will then be compiled with
				optimizations especially geared towards your
				machine. Note that if you specify a higher processor 
				here than you actually have, the kernel might not
				work. Also, the Pentium II MMX is a 686, not a
				586 chip.</p></dd>


<dt><b><tt class="literal">Math emulation</tt></b></dt><dd><p><a name="INDEX-1658" />

Answer no if you have a Pentium or better. 
Answer yes to this item if you do not have a floating-point
coprocessor in your machine. This is necessary for the kernel to 
emulate the presence of a math coprocessor.</p></dd>


<dt><b><tt class="literal">MTRR (Memory Type Range Register) support</tt></b></dt><dd><p>This enables special support for a feature
<a name="INDEX-1659" />
<a name="INDEX-1660" />
				present only on Pentium II and Pentium Pro systems. If you
				do not have these CPUs, you do not need this option,
				but it will not hurt you if you do (it will only make
				your kernel larger).</p></dd>


<dt><b><tt class="literal">Symmetric multi-processing support</tt></b></dt><dd><p>This enables kernel support
<a name="INDEX-1661" />
				for more than one CPU. If your machine has more than
				one CPU, say yes here; if not, say no.</p></dd>


<dt><b><tt class="literal">Enable loadable module support</tt></b></dt><dd><p>This enables the support for dynamically loading 
<a name="INDEX-1662" />
				additional modules. You definitely want to enable
				this.</p></dd>


<dt><b><tt class="literal">Set version information on all symbols for modules</tt></b></dt><dd><p>This is a special option that makes it possible
				to use a module compiled for one kernel version with
<a name="INDEX-1663" />
				another kernel version. There are a number of problems 
				attached to this; say no here unless you know exactly
				what you are doing.</p></dd>


<dt><b><tt class="literal">Kernel module loader</tt></b></dt><dd><p>If you enable this option, you can--with
				the help of a program called
				<tt class="command">kerneld</tt>, described later--automatically load and unload dynamically loadable
				modules as needed.</p></dd>


<dt><b><tt class="literal">Networking support</tt></b></dt><dd><p>
Answer yes to this option if you want any sort of networking support in
your kernel (including <span class="acronym">TCP/IP</span>, <span class="acronym">SLIP</span>, <span class="acronym">PPP</span>, <span class="acronym">NFS</span>, and so on).</p></dd>


<dt><b><tt class="literal">PCI support</tt></b></dt><dd><p><a name="INDEX-1664" />
Enable this option if your motherboard includes the
<span class="acronym">PCI</span> bus and you have <span class="acronym">PCI</span>-bus
devices installed in your system. The <span class="acronym">PCI BIOS</span> is
used to detect and enable <span class="acronym">PCI</span> devices; kernel
support for it is necessary for use of any <span class="acronym">PCI</span>
devices in your system.</p></dd>


<dt><b><tt class="literal">System V IPC</tt></b></dt><dd><p><a name="INDEX-1665" />
Answering yes to this option includes kernel support for System V
interprocess communication (<span class="acronym">IPC</span>) functions, such as
<em class="emphasis">msgrcv</em>
and <em class="emphasis">msgsnd</em>. Some programs ported from System V require this; you should answer yes unless you have a strong aversion to these features.</p></dd>


<dt><b><tt class="literal">Sysctl support</tt></b></dt><dd><p>This option instructs the kernel to provide a way to
<a name="INDEX-1666" />
				change kernel parameters on-the-fly, without
				rebooting. It is good idea to enable this unless you
				have very limited memory, because this option makes
				the kernel 8 KB larger.</p></dd>


<dt><b><tt class="literal">Kernel support for ELF binaries</tt></b></dt><dd><p><a name="INDEX-1667" />
Enabling this option allows your system to execute Linux binaries
stored in Executable and Linkable Format (<span class="acronym">ELF</span>)
format. <span class="acronym">ELF</span> is
a standard format for executables, object files, and system libraries.
Such standards are required for the operating system to cooperate with
tools such as compilers and linkers. Most current Linux systems store 
binaries in <span class="acronym">ELF</span> format, so you should answer yes to
this question. Very old
Linux systems use the <em class="emphasis">a.out</em> format for binaries.</p></dd>


<dt><b><tt class="literal">Parallel port support</tt></b></dt><dd><p>Enable this option if you have a parallel port
<a name="INDEX-1668" />
				in your system and want to access it from Linux. Linux 
				can use the parallel port not only for printers, but
				also for <span class="acronym">PLIP</span> (a networking
				protocol for parallel lines), <span class="acronym">ZIP</span>
				drives, scanners, and other things. In most cases, you 
				will need an additional driver to
				attach a device to the parallel port.</p></dd>


<dt><b><tt class="literal">Plug and Play support</tt></b></dt><dd><p>Enable this if you have an ISA Plug-and-Play
<a name="INDEX-1669" />
				card in your system. This option does not apply to PCI
				cards, which are plug and play by nature.</p></dd>


<dt><b><tt class="literal">Normal floppy disk support</tt></b></dt><dd><p><a name="INDEX-1670" />
Answer yes to this option unless you don't want support for floppy
drives (this can save some memory on systems where floppy support isn't
required).</p></dd>


<dt><b><tt class="literal">Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support</tt></b></dt><dd><p><a name="INDEX-1671" />
Answer yes to this option unless you don't need
<span class="acronym">MFM</span>/<span class="acronym">RLL</span>/<span class="acronym">IDE</span>
drive support. After answering yes, you will be prompted for types of devices (hard disks,
CD-ROM drives, tape drives, and floppy drives) you want to access over
the IDE driver.
If you have no <span class="acronym">IDE</span> hardware (only
<span class="acronym">SCSI</span>), it may be safe to disable this option.</p></dd>


<dt><b><tt class="literal">XT harddisk support</tt></b></dt><dd><p><a name="INDEX-1672" />
Answer yes to this only if you have an older XT disk controller and
plan to use it with your Linux system.</p></dd>


<dt><b><tt class="literal">Parallel port IDE device support</tt></b></dt><dd><p>This option enables support for IDE devices that 
				are attached to the parallel port,
				such as portable CD-ROM drives.</p></dd>


<dt><b><tt class="literal">Networking options</tt></b></dt><dd><p><a name="INDEX-1673" />
If you previously selected networking support, you will be asked a series
of questions about which networking options you want enabled in your
kernel. Unless you have special networking needs (in which case you'll
know how to answer the questions appropriately), answering the defaults
for these questions should suffice. A number of the questions are esoteric
in nature (such as <tt class="literal">IP: Disable Path MTU Discovery</tt>) and
you should select the defaults for these in almost all cases.</p></dd>


<dt><b><tt class="literal">SCSI support</tt></b></dt><dd><p><a name="INDEX-1674" />
If you have a <span class="acronym">SCSI</span> controller of any kind, answer
yes to this option.  You will be asked a series of questions about the
specific <span class="acronym">SCSI</span> devices on your system; be sure you
know what type of hardware you have installed.  All of these questions
deal with specific <span class="acronym">SCSI</span> controller chips and
boards; if you aren't sure what sort of <span class="acronym">SCSI</span>
controller you have, check the hardware documentation or consult the
Linux <span class="acronym">HOWTO</span> documents.</p>

<p>You will also be asked if you want support for <span class="acronym">SCSI</span>
disks, tapes, <span class="acronym">CD-ROM</span>s, and other devices; be sure
to enable the options appropriate for your hardware.</p>

<p>If you don't have any <span class="acronym">SCSI</span> hardware, you should
answer no to this option; it greatly reduces the size of your kernel.</p></dd>


<dt><b><tt class="literal">Network device support</tt></b></dt><dd><p><a name="INDEX-1675" />
This is a series of questions about the specific
networking controllers Linux supports. If you plan to use an Ethernet
card (or some other networking controller), be sure to enable the
options for your hardware.  As with <span class="acronym">SCSI</span> devices,
you should consult your hardware documentation or the Linux
<span class="acronym">HOWTO</span> documents (such as the Ethernet
<span class="acronym">HOWTO</span>) to determine which driver is appropriate for
your network controller.</p></dd>


<dt><b><tt class="literal">Amateur Radio support</tt></b></dt><dd><a name="INDEX-1676" /><p>This option enables basic support for networking over
				public radio frequencies like CB. If you have the
				equipment to use the feature, enable this option and read the 
				AX25 and the HAM <span class="acronym">HOWTO</span>.</p></dd>


<dt><b><tt class="literal">ISDN subsystem</tt></b></dt><dd><p>If you have ISDN hardware in your system, enable 
<a name="INDEX-1677" />
				this option and select the ISDN hardware driver
				suitable for your hardware. You will most probably
				also want to select <tt class="literal">Support synchronous
				PPP</tt> (see <a href="ch15_03.htm">Section 15.3, "PPP over ISDN"</a>).</p></dd>


<dt><b><tt class="literal">Old CD-ROM drivers</tt></b></dt><dd><p><a name="INDEX-1678" />
This is a series of questions dealing with the specific
<span class="acronym">CD-ROM</span> drivers supported by the kernel, such as the
Sony <span class="acronym">CDU</span>31A/33A, Mitsumi, or SoundBlaster Pro
<span class="acronym">CD-ROM</span>, and so on. If you have a
<span class="acronym">SCSI</span> or <span class="acronym">IDE</span>
<span class="acronym">CD-ROM</span> controller (and have selected support for it
earlier), you need not enable any of these options. Some
<span class="acronym">CD-ROM</span> drives have their own interface boards, and
these options enable drivers for them.</p></dd>


<dt><b><tt class="literal">Character devices</tt></b></dt><dd><p><a name="INDEX-1679" />
Linux supports a number of special "character" devices, such
as serial and parallel port controllers, QIC-02 tape drives, and mice with 
their own proprietary interfaces (not mice that connect to the serial port, 
such as the Microsoft serial mouse). This section also includes the
joystick support and the "Video for Linux" drivers that
support video and frame-grabbing hardware. Be sure to enable the options
corresponding to your hardware.</p></dd>


<dt><b><tt class="literal">Filesystems</tt></b></dt><dd><p><a name="INDEX-1680" />
This is a series of questions for each filesystem type supported by the
kernel. As discussed in the section "<a href="ch06_01.htm">Section 6.1, "Managing Filesystems"</a>," in Chapter 6, 
there are a number of filesystem types supported by the system, and
you can pick and choose which to include in the kernel. Nearly all
systems should include support for the Second Extended and
<em class="filename">/proc</em> filesystems. You should include support for the <span class="acronym">MS-DOS</span>
filesystem if you want to access your <span class="acronym">MS-DOS</span> files directly from
Linux, and the <span class="acronym">ISO</span> 9660 filesystem to access files
on a <span class="acronym">CD-ROM</span> (most of which are encoded in this way).</p></dd>


<dt><b><tt class="literal">Console drivers</tt></b></dt><dd><p>Make sure that you select at least <tt class="literal">VGA
<a name="INDEX-1681" />
				text console</tt> in this section, or you won't
				be able to use your Linux system from the console.</p></dd>


<dt><b><tt class="literal">Sound card support</tt></b></dt><dd><p><a name="INDEX-1682" />

Answering yes to this option presents you with several questions
about your sound card, which drivers you wish to have installed,
and other details, such as the IRQ and address of the sound hardware.</p></dd>


<dt><b><tt class="literal">Kernel hacking</tt></b></dt><dd><p><a name="INDEX-1683" />
This section contains options that are useful only if you plan on hacking
the Linux kernel yourself. If you do not want to do this, answer no.</p></dd>

</dl>

<p> 
After running <tt class="command">make config</tt> or its equivalent, you'll be
asked to edit 
"the top-level Makefile," which means
<em class="filename">/usr/src/linux/Makefile</em>. In most cases, it's not
necessary to do this. If you wanted to alter some of the compilation
options for the kernel, or change the default root device or
<span class="acronym">SVGA</span> mode, you could edit the makefile to
accomplish this.  Setting the root device and <span class="acronym">SVGA</span>
mode can easily be done by running <tt class="command">rdev</tt> on a
compiled kernel image, as

we saw in the section "<a href="ch05_02.htm">Section 5.2.1, "Using a Boot Floppy"</a>" in <a href="ch05_01.htm">Chapter 5, "Essential System Management"</a>.</p>

<p><a name="INDEX-1684" />
The next step is to run <tt class="command">make dep</tt>. This issues a series of commands
that walk through the directory tree and gather dependencies for
source files, adding information to the various makefiles for them.
(If you really want to know what's going on here: <tt class="command">make dep</tt> adds rules for
the makefile so that certain code will be recompiled if, say, a header
file included by a source file changes.) This step should take five or
ten minutes at most to complete.</p>

<p><a name="INDEX-1685" />
If you wish to force a complete recompilation of the kernel, you should
issue <tt class="command">make clean</tt> at this point. This removes all object files
produced from a previous build from this source tree. If you have never
built the kernel from this tree, you're probably safe skipping this step
(although it can't hurt). If you are tweaking minor parts of the kernel,
you might want to avoid this step so that only those files that have
changed will be recompiled. At any rate, running <tt class="command">make clean</tt> simply
ensures the entire kernel will be recompiled "from scratch," and
if you're in any doubt, use this command to be on the safe side.</p>

<p><a name="INDEX-1686" />
Now you're ready to compile the kernel. This is done with the command
<tt class="command">make zImage</tt>. It is best to build your kernel on a 
lightly loaded system, with most of your memory free for the compilation.
If other users are accessing the system, or if you're trying to run
any large applications yourself (such as the X Window System, or another
compilation), the build may slow to a crawl. The key here is memory. 
A slower processor completes the kernel compilation just as
rapidly as a faster one, given enough <span class="acronym">RAM</span> for the task.</p>

<p>The kernel compilation can take anywhere from a few minutes to many hours,
depending on your hardware. There is a great deal of code--well over
10 MB--in the entire kernel, so this should come as no surprise.
Slower systems with 4 MB (or less) of <span class="acronym">RAM</span> can expect to take
several hours for a complete rebuild; faster machines with more memory
can complete in less than half an hour. Your mileage will most assuredly
vary.</p>

<p>If any errors or warnings occur while compiling, you cannot expect
the resulting kernel to work correctly; in most cases, the build will halt if an error occurs. Such errors can be the
result of incorrectly applying patches, problems with the <tt class="command">make config</tt>
and <tt class="command">make dep</tt> steps, or actual bugs in the code.
In the "stock" kernels, this latter case is rare,
but is more common if you're working with development code or new
drivers under testing. If you have any doubt, remove the kernel source
tree altogether and start over.</p>

<p>When the compilation is complete, you will be left with the file
<em class="filename">zImage</em> in the directory <em class="filename">/usr/src/linux/arch/i386/boot</em>. 
(Of course, if you're attempting to build Linux on a platform other
than the Intel x86, the kernel image will be found in the corresponding
subdirectory under <em class="filename">arch</em>.)
The kernel is so named because
it is the executable image of the kernel, and it has been internally
compressed using the <tt class="command">gzip</tt> algorithm. When the kernel boots, it
uncompresses itself into memory: don't attempt to use <tt class="command">gzip</tt> or
<tt class="command">gunzip</tt> on <em class="filename">zImage</em> yourself! The kernel requires much less 
disk space when compressed in this way, allowing kernel images
to fit on a floppy.</p>

<p>If you pick too much kernel functionality, it can happen 
<a name="INDEX-1687" />
		that you get a <tt class="literal">kernel too big</tt> error at the
		end of the kernel compilation. This happens rarely, because
		you only need a very limited amount of hardware
		support for one machine, but it can happen. In this case, you
		have two options: Compile some kernel functionality as modules 
		(see the next section, "Loadable Device
		Drivers") or use <tt class="command">make bzImage</tt> instead 
		of <tt class="command">make zImage</tt>. This will create a kernel
		that loads itself into high memory but works only with 
not-so-old Intel machines. You will then find the kernel image in the same
		directory but with the name
		<em class="filename">bzImage</em>. Don't worry if it took you a lot 
		of time to compile the kernel before. Most of the time
		spent during the first compile was creating object
		files that remain on your system and are still
		usable. So running <tt class="command">make
		bzImage</tt> will pick up most of the compiled objects
		from the earlier run, and this build should go much
		faster.</p>

<?troff .Nd 10?><p><a name="INDEX-1688" />
You should now run <tt class="command">rdev</tt> on the new kernel image to verify
that the root filesystem device, console <span class="acronym">SVGA</span> mode, and other

parameters have been set correctly. This is described in the section
"<a href="ch05_02.htm">Section 5.2.1, "Using a Boot Floppy"</a>" in
<a href="ch05_01.htm">Chapter 5, "Essential System Management"</a>.</p>

<p>With your new kernel in hand, you're ready to configure it for booting.
This involves either placing the kernel image on a boot floppy, or
configuring LILO to boot the kernel from the hard drive. These topics
are discussed in the section
"<a href="ch05_02.htm">Section 5.2, "Booting the System"</a>" in
<a href="ch05_01.htm">Chapter 5, "Essential System Management"</a>. To use the
new kernel, configure it for booting in one of these ways, and reboot
the system.</p>

<a name="INDEX-1689" /><a name="INDEX-1690" /><a name="INDEX-1691" /><a name="INDEX-1692" /><a name="INDEX-1693" />
</div>


<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch07_03.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch07_05.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">7.3. Using RPM</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">7.5. Loadable Device Drivers</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="index.htm" coords="172,2,252,105" shape="rect" /><area href="../apache/index.htm" coords="238,2,334,95" shape="rect" /><area href="../sql/index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="../cgi/index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>