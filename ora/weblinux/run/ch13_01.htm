<?label 13. Programming
 Languages?><html><head><title>Programming
 Languages (Running Linux)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="Running Linux" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch12_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm" /></td><td width="172" valign="top" align="right"><a href="ch13_02.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<h1 class="chapter">Chapter 13. Programming
 Languages</h1>
<div class="htmltoc"><h4 class="tochead">Contents:</h4><p>
<a href="ch13_01.htm">Programming with gcc</a><br />
<a href="ch13_02.htm">Makefiles</a><br />
<a href="ch13_03.htm">Shell Programming</a><br />
<a href="ch13_04.htm">Using Perl</a><br />
<a href="ch13_05.htm">Programming in Tcl and Tk</a><br />
<a href="ch13_06.htm">Java</a><br />
<a href="ch13_07.htm">Other Languages</a><br /></p></div>

<p><a name="INDEX-2616" />
There's much more to Linux than simply using the system. One of the
benefits of free software is that it can be modified to suit the
user's needs. This applies equally to the many free applications
available for Linux and to the Linux kernel itself.</p>

<p>Linux supports an advanced programming interface, using
<span class="acronym">GNU</span> compilers and tools, such as the
<tt class="command">gcc</tt> compiler, the <tt class="command">gdb</tt> debugger,
and so on. A number of other programming languages, including Perl,
Tcl/Tk, and <span class="acronym">LISP</span>, are also supported. Whatever your
programming needs, Linux is a great choice for developing
Unix applications. Because the complete source code
for the libraries and Linux kernel are provided, those programmers who
need to delve into the system internals are able to do so.<a href="#FOOTNOTE-46">[46]</a></p><blockquote>

<a name="FOOTNOTE-46" /><p>[46]On a variety of Unix
systems, the authors have repeatedly found available documentation to be
insufficient. With Linux, you can explore the very source code for the
kernel, libraries, and system utilities. Having access to source code
is more important than most programmers would think.</p>

</blockquote>

<p>Linux is an ideal platform for developing software to run under the X
Window System. The Linux X distribution, as described

in <a href="ch10_01.htm">Chapter 10, "Installing the X
 Window System"</a>, is a
complete implementation with 
everything you need to develop and support X applications.
Programming for X itself is portable across applications, so the
X-specific portions of your application should compile cleanly on other
Unix systems.</p>

<p>In this chapter, we'll explore the Linux programming environment and
give you a five-cent tour of the many facilities it provides. Half of the
trick to Unix programming is knowing what tools are
available and how to use them effectively. Often the most useful
features of these tools are not obvious to new users.</p>

<p>Since C programming has been the basis of most large projects (even
though it is nowadays being replaced more and more by C++) and is the
language common to most modern programmers--not only on
Unix, but on many other systems as
well--we'll start out telling you what tools are
available for that.  The first few sections of the chapter assume you
are already a C programmer.</p>

<p>But several other tools are emerging as important resources,
especially for system administration.  We'll examine two in this
chapter: Perl and Tcl/Tk.  They are both scripting languages like the
Unix shells, taking care of grunt work like memory allocation, so you
can concentrate on your task.  But both Perl and Tcl/Tk offer a degree
of sophistication that makes them more powerful than shell scripts
and appropriate for many programming tasks.</p>

<p><a name="INDEX-2617" />
<a name="INDEX-2618" />
Lots of programmers are excited about trying out Java, the new
language from Sun Microsystems.  While most people associate Java with
interactive programs (applets) on web pages, it is actually
a general-purpose language with many potential Internet uses. In a
later section, we'll
explore what Java offers above and beyond older programming languages
and how to get started.</p>

<div class="sect1"><a name="x-100-3-sec-prog-gcc" />
<h2 class="sect1">13.1. Programming with gcc</h2>

<p><a name="INDEX-2619" />
<a name="INDEX-2620" />
<a name="INDEX-2621" />
The C programming language is by far the most used in
Unix software development. Perhaps this is because
the Unix system itself was originally developed in
C; it is the native tongue of Unix.
Unix C compilers have traditionally defined the
interface standards for other languages and tools, such as linkers,
debuggers, and so on. Conventions set forth by the original C
compilers have remained fairly consistent across the
Unix programming board. To know the C compiler is
to know the Unix system itself.  Before we get too
abstract, let's get to details.</p>

<p><a name="INDEX-2622" />
The <span class="acronym">GNU</span> C compiler, <tt class="command">gcc</tt>, is one
of the most versatile and advanced compilers around. Unlike other C
compilers (such as those shipped with the original AT&amp;T or
<span class="acronym">BSD</span> distributions or from various third-party
vendors), <tt class="command">gcc</tt> supports all the modern C standards
currently in use--such as the <span class="acronym">ANSI</span> C
standard--as well as many extensions specific to
<tt class="command">gcc</tt> itself. Happily, however,
<tt class="command">gcc</tt> provides features to make it compatible with
older C compilers and older styles of C programming. There is even a
tool called <tt class="command">protoize</tt> that can help you write
function prototypes for old-style C programs.</p>

<p><a name="INDEX-2623" />
<a name="INDEX-2624" />
<tt class="command">gcc</tt> is also a C++ compiler. For those of you who
prefer the obscure object-oriented environment, C++ is supported with
all of the bells and whistles--including <span class="acronym">AT&amp;T</span> 3.0 C++ features, such as method
templates. Complete C++ class libraries are provided as well, such as
the <em class="filename">iostream</em> library familiar to many
programmers.</p>

<p>For those with a taste for the particularly esoteric,
<tt class="command">gcc</tt> also supports Objective-C, an object-oriented C
spinoff that never gained much popularity. But the fun doesn't stop
there, as we'll see.</p>

<p>There's also a new kid on the block,
<tt class="command">egcs</tt>. <tt class="command">egcs</tt> is not a completely
new compiler, but is based on
<tt class="command">gcc</tt>. <tt class="command">egcs</tt> has some advanced
optimization features and is especially strong when it comes to newer
C++ features like templates and namespaces. If you are going to do
serious C++ programming, you will probably want to check it out. Alas, 
there is a problem with Version
2.0.<em class="emphasis">x</em> kernels that prevents them from being compiled
with <tt class="command">egcs</tt>. Newer kernels from the
2.1.<em class="emphasis">x</em> and those from the
2.2.<em class="emphasis">x</em> don't have this problem. But because 
of this, some distributors have opted to include the traditional
<tt class="command">gcc</tt> for C compilation and <tt class="command">egcs</tt>
for C++. You can read more about <tt class="command">egcs</tt> at
<a href="../../../../../../egcs.cygnus.com/">http://egcs.cygnus.com</a>.</p>

<p>The Free Software Foundation has recently announced that
<tt class="command">egcs</tt> will become their default compiler, thus
replacing <tt class="command">egcs</tt>' own ancestor <tt class="command">gcc</tt>.</p>

<p>In this section, we're going to cover the use of <tt class="command">gcc</tt> to
compile and link programs under Linux. We assume you are
familiar with programming in C/C++, but we don't assume you're
accustomed to the Unix programming
environment. That's what we'll introduce here.</p>

<div class="sect2">
<h3 class="sect2">13.1.1. Quick Overview</h3>

<p>Before imparting all of the gritty details of <tt class="command">gcc</tt> itself,
we're going to present a simple example and walk through the steps
of compiling a C program on a Unix
<?troff \p?> system.</p>

<p>Let's say you have the following
bit of code, an encore of the much-overused "Hello, World!" program 
(not that it bears repeating):
<?troff-ps_indent0?>
<blockquote><pre class="code">#include &lt;stdio.h&gt;
int main() {
  (void)printf("Hello, World!\n");
  return 0; /* Just to be nice */
}</pre></blockquote>

To compile this program into a living, breathing executable, there are
several steps. Most of these steps can be accomplished
through a single <tt class="command">gcc</tt> command, but the specifics are left for
later in the chapter.</p>

<p><a name="INDEX-2625" />
<a name="INDEX-2626" />
<a name="INDEX-2627" />
First, the <tt class="command">gcc</tt> compiler must generate an <em class="emphasis">object file</em> from
this <em class="emphasis">source code</em>. The object file is essentially the 
machine-code equivalent of the C source. It contains code to
set up the <em class="emphasis">main(
<?troff \|?>)</em> calling stack, a call to the mysterious
<em class="emphasis">printf(&hairsp;)</em> function, and code to return the value of 0.</p>

<p><a name="INDEX-2628" /> 
The next step is to <em class="emphasis">link</em> the object file to produce an executable.
As you might guess, this is done by the <em class="emphasis">linker</em>. 
The job of the linker is to take object files, merge them with code from
libraries, and spit out an executable. The object code from the previous
source does not make a complete executable. First and foremost, the
code for <em class="emphasis">printf()</em> must be linked in. Also, various initialization
routines, invisible to the mortal programmer, must be appended to the
executable.</p>

<p><a name="INDEX-2629" />
Where does the code for <em class="emphasis">printf()</em> come
from? Answer: the libraries. It
is impossible to talk for long about <tt class="command">gcc</tt> without making mention
of them. A library is essentially a collection of many object files,
including an index. When searching for the code for <em class="emphasis">printf()</em>, 
the linker looks at the index for each library it's been told to link
against. It finds the object file containing the <em class="emphasis">printf()</em> function 
and extracts that object file (the entire object file, which
may contain much more than just the <em class="emphasis">printf()</em> function) and links
it to the executable.</p>

<p><a name="INDEX-2630" />
In reality, things are more complicated than this. As we have said, Linux
supports two kinds of libraries: <em class="emphasis">static</em> and <em class="emphasis">shared</em>. What we have
described in this example are static libraries: libraries where the actual code
for called subroutines is appended to the executable. However, the code for 
subroutines such as <em class="emphasis">printf()</em> can be quite lengthy. Because many
programs use common subroutines from the libraries, it doesn't make sense
for each executable to contain its own copy of the library code. That's
where shared libraries come in.</p>

<p><a name="INDEX-2631" />
<a name="INDEX-2632" />
With shared libraries, all of the common subroutine code is contained
in a single library "image file" on disk. When a program is linked
with a shared library, <em class="emphasis">stub code</em>
is appended to the executable, instead of
actual subroutine code. This stub code tells the program loader
where to find the library code on disk, in the image file,
at runtime. Therefore, when our friendly "Hello, World!"
program is
executed, the program loader notices that the program has been linked 
against a shared library. It then finds the shared library image and 
loads code for library routines, such as
<em class="emphasis">printf()</em>, along with the
code for the program itself. The stub code tells the loader where
to find the code for <em class="emphasis">printf()</em> in the image file.</p>

<p><a name="INDEX-2633" />
Even this is an oversimplification of what's really going on. Linux shared 
libraries use <em class="emphasis">jump tables</em> that allow the libraries to be upgraded 
and their contents to be jumbled around, without requiring the executables
using these libraries to be relinked. The stub code in the executable actually looks up another reference in the library itself--in 
the jump table. In this way, the library contents and the corresponding
jump tables can be changed, but the executable stub code can remain the
same.</p>

<p>But don't allow yourself to be befuddled by all this abstract 
information. In time, we'll approach a real-life example and show you
how to compile, link, and debug your programs. It's actually very
simple; most of the details are taken care of for you by the <tt class="command">gcc</tt>
compiler itself. However, it helps to have an understanding of what's
going on behind the scenes.</p>
</div>




<div class="sect2">
<h3 class="sect2">13.1.2. gcc Features</h3>

<p><tt class="command">gcc</tt> has more features than we could possibly enumerate here.
Later, we present a short list and refer the curious
to the <tt class="command">gcc</tt> manual page and Info document, which will undoubtedly give you 
an eyeful of interesting information about this compiler. Later in this 
section, we'll give you a comprehensive overview of the most useful <tt class="command">gcc</tt>
features to get you started. This in hand, you should be able to
figure out for yourself how to get the many other facilities to work to
your advantage.</p>

<p><a name="INDEX-2634" />
For starters, <tt class="command">gcc</tt> supports the "standard" C syntax currently
in use, specified for the most part by the <span class="acronym">ANSI</span> C standard. The most
important feature of this standard is function prototyping. That is,
when defining a function <em class="emphasis">foo()</em>, which returns an <tt class="literal">int</tt> and
takes two arguments, <tt class="literal">a</tt> (of type <tt class="literal">char *</tt>) and <tt class="literal">b</tt> (of
type <tt class="literal">double</tt>),
the function may be defined like this:
<blockquote><pre class="code">int foo(char *a, double b) {  
  /* your code here... */  
}</pre></blockquote>

This is in contrast to the older, nonprototype function definition
syntax, which looks like:
<blockquote><pre class="code">int foo(a, b) 
char *a;  
double b;  
{ 
  /* your code here... */  
}</pre></blockquote>


which is also supported by <tt class="command">gcc</tt>. 
Of course, <span class="acronym">ANSI</span> C defines many other conventions, but this is the
one most obvious to the new programmer. Anyone familiar with

C programming style in modern books, such as the second edition of
Kernighan and Ritchie's <em class="emphasis">The C Programming Language</em>,
can program using <tt class="command">gcc</tt> with no problem. (C compilers shipped
on some other Unix systems do not support <span class="acronym">ANSI</span> features such as prototyping.)</p>

<p><a name="INDEX-2635" />
<a name="INDEX-2636" />
The <tt class="command">gcc</tt> compiler boasts quite an impressive optimizer. Whereas most
C compilers allow you to use the single switch <span class="option">-O</span> to specify
optimization, <tt class="command">gcc</tt> supports multiple levels of optimization.
At the highest level of optimization, <tt class="command">gcc</tt> pulls tricks out of
its sleeve such as allowing code and static data to be shared. That is,
if you have a static string in your program such as <tt class="literal">Hello, World!</tt>,
and the ASCII encoding of that string happens to coincide with a sequence
of instruction code in your program, <tt class="command">gcc</tt> allows the string
data and the corresponding code to share the same storage. How's that for
clever?</p>

<p><a name="INDEX-2637" />
<a name="INDEX-2638" />
Of course, <tt class="command">gcc</tt> allows you to compile debugging information into
object files, which aids a debugger (and hence, the programmer) in tracing 
through the program. The compiler inserts
markers in the object file, allowing the debugger to locate specific
lines, variables, and functions in the compiled program. Therefore, when
using a debugger, such as <tt class="command">gdb</tt> (which we'll talk about later in the
chapter), you can step through the compiled
program and view the original source text simultaneously.</p>

<p><a name="INDEX-2639" />
Among the other tricks offered by <tt class="command">gcc</tt> is the ability to generate assembly
code with the flick of a switch (literally). Instead of telling
<tt class="command">gcc</tt> to compile your source to machine code, you can ask it to
stop at the assembly-language level, which is much easier for humans
to comprehend. This happens to be a nice way to learn the intricacies
of protected-mode assembly programming under Linux: write some C
code, have <tt class="command">gcc</tt> translate it into assembly language
for you, and study
that.</p>

<p><tt class="command">gcc</tt> includes its own assembler (which can be used independently of
<tt class="command">gcc</tt>), just in case you're wondering
how this assembly-language code might get assembled. In fact, you can
include inline assembly code in your C source, in case you need to
invoke some particularly nasty magic but don't want to write exclusively
in assembly.</p>
</div>




<div class="sect2">
<h3 class="sect2">13.1.3. Basic gcc Usage</h3>

<p>By now, you must be itching to know how to invoke all these wonderful
features. It is important, especially to novice Unix and C programmers, 
to know how to use <tt class="command">gcc</tt> effectively.
Using a command-line compiler such as <tt class="command">gcc</tt> is quite different from,
say, using a development system such as Borland C under <span class="acronym">MS-DOS</span>.
Even though the language syntax itself is similar, the methods used to
compile and link programs are not at all the same.</p>

<p>Let's return to our innocent-looking "Hello, World!" example.
How would you go about compiling and linking this program?</p>

<p>The first step, of course, is to enter the source code. This is 
accomplished with a text editor, such as Emacs or <tt class="command">vi</tt>. 
The would-be programmer should enter the source code and save it
in a file named something like <em class="filename">hello.c</em>. (As with most C compilers,
<tt class="command">gcc</tt> is picky about the filename extension; that is, how it
can distinguish C source from assembly source from object files, and
so on. The <em class="filename">.c</em> extension should be used for standard C source.)</p>

<p>To compile and link the program to the executable <em class="filename">hello</em>, the
programmer would use the command:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -o hello hello.c</b></tt></pre></blockquote>

and (barring any errors), in one fell swoop, <tt class="command">gcc</tt>
compiles the 
source into an object file, links against the appropriate libraries, and 
spits out the executable <em class="filename">hello</em>, ready to run. In fact, the wary 
programmer might want to test it:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>./hello</b></tt> 
Hello, World! 
papaya$</pre></blockquote>

As friendly as can be expected.</p>

<p>Obviously, quite a few things took place behind the scenes when
executing this single <tt class="command">gcc</tt> command. First of all, <tt class="command">gcc</tt>
had to compile your source file, <em class="filename">hello.c</em>, into an object file,
<em class="filename">hello.o</em>. Next, it had to link <em class="filename">hello.o</em> against the
standard libraries and produce an executable.</p>

<p>By default, <tt class="command">gcc</tt> assumes that not only do you want to compile the
source files you specify but also that you want them linked
together (with each other and with the standard libraries) to
produce an executable.
First, <tt class="command">gcc</tt> compiles any source files into object files.
Next, it automatically invokes the linker to glue all
the object files and libraries into an executable.
(That's right, the linker is a separate program,
called <tt class="command">ld</tt>, not part of <tt class="command">gcc</tt> itself--although it can be said
that <tt class="command">gcc</tt> and <tt class="command">ld</tt> are close friends.) <tt class="command">gcc</tt> also knows
about the "standard" libraries used by most programs and tells 
<tt class="command">ld</tt> to link against them. You can, of course, override these defaults 
in various ways.</p>

<p>You can pass multiple filenames in one <tt class="command">gcc</tt> command, but on
large projects you'll find it more natural to compile a few files at a
time and keep the <em class="filename">.o</em> object files around.
If you want only to compile a source file into an object file and 
forego the linking process, use the <span class="option">-c</span> switch with <tt class="command">gcc</tt>, as
in:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -c hello.c</b></tt></pre></blockquote>

This produces the object file <em class="filename">hello.o</em> and nothing else.</p>

<p><a name="INDEX-2640" />
By default, the linker produces an executable
named, of all things, <em class="filename">a.out</em>. By using the <span class="option">-o</span> switch with 
<tt class="command">gcc</tt>, you can force the resulting executable to be named something
different, in this case, <em class="filename">hello</em>. This is just a bit of left-over 
gunk from early implementations of Unix, and nothing to write home about.</p>
</div>




<div class="sect2">
<h3 class="sect2">13.1.4. Using Multiple Source Files</h3>

<p><a name="INDEX-2641" />
The next step on your path to <tt class="command">gcc</tt> enlightenment is to understand
how to compile programs using multiple source files. 
Let's say you have a program consisting of two source files,
<em class="filename">foo.c</em> and <em class="filename">bar.c</em>. Naturally, you would use one or more
header files (such as <em class="filename">foo.h</em>) containing function declarations
shared between the two programs. In this way, code in <em class="filename">foo.c</em>
knows about functions in <em class="filename">bar.c</em>, and vice versa.</p>

<p>To compile these two source files and link them together (along with the
libraries, of course) to produce the executable <em class="filename">baz</em>, you'd
use the command:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -o baz foo.c bar.c</b></tt></pre></blockquote></p>

<p>This is roughly equivalent to the three commands:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -c foo.c</b></tt> 
papaya$ <tt class="userinput"><b>gcc -c bar.c</b></tt> 
papaya$ <tt class="userinput"><b>gcc -o baz foo.o bar.o</b></tt></pre></blockquote>

<tt class="command">gcc</tt> acts as a nice frontend to the linker and other
"hidden" utilities invoked during compilation.</p>

<p>Of course, compiling a program using multiple source files in one command
can be time consuming. If you had, say, five or more source files in
your program, the <tt class="command">gcc</tt> command in the previous example would
recompile each
source file in turn before linking the executable. This can be a large waste
of time, especially if you only made modifications to a single source file
since last compilation. There would be no reason to recompile the other
source files, as their up-to-date object files are still intact.</p>

<p>The answer to this problem is to use a project manager such as
<tt class="command">make</tt>.  We'll talk about <tt class="command">make</tt> later in the chapter,
in the section "<a href="ch13_02.htm">Section 13.2, "Makefiles"</a>."</p>
</div>




<div class="sect2">
<h3 class="sect2">13.1.5. Optimizing</h3>

<p><a name="INDEX-2642" />
<a name="INDEX-2643" />
Telling <tt class="command">gcc</tt> to optimize your code as it compiles is a simple matter;
just use the <span class="option">-O</span> switch on the <tt class="command">gcc</tt> command
line:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -O -o fishsticks fishsticks.c</b></tt></pre></blockquote></p>

<p>As we mentioned not long ago, <tt class="command">gcc</tt> supports different levels of
optimization. Using <span class="option">-O2</span> instead of <span class="option">-O</span> will turn on 
several "expensive" optimizations that may cause compilation to 
run more slowly but will (hopefully) greatly enhance performance of
your code.</p>

<p>You may notice in your dealings with Linux that a number of
programs are compiled using the switch <span class="option">-O6</span> (the Linux kernel being
a good example). The current version of <tt class="command">gcc</tt> does not support 
optimization up to <span class="option">-O6</span>, so this defaults to (presently)
the equivalent of <span class="option">-O2</span>. However, <span class="option">-O6</span> is sometimes
used for compatibility with future versions of <tt class="command">gcc</tt> to ensure that
the greatest level of optimization is used.</p>
</div>




<a name="x-100-3-sec-prog-gcc-debug" /><div class="sect2">
<h3 class="sect2">13.1.6. Enabling Debugging Code</h3>

<p><a name="INDEX-2644" />
The <span class="option">-g</span> switch to <tt class="command">gcc</tt> turns on debugging code in your compiled
object files. That is, extra information is added to the object file,
as well as the resulting executable, allowing the program to be 
traced with a debugger such as <tt class="command">gdb</tt> (which we'll get to later in
the chapter--no worries). The downside to using debugging code is that it
greatly increases the size of the resulting object files. It's usually
best to use <span class="option">-g</span> only 
while developing and testing your programs and to leave it out for the
"final" compilation.</p>

<p>Happily, debug-enabled code is not incompatible with code optimization.
This means that you can safely use
the command:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -O -g -o mumble mumble.c</b></tt></pre></blockquote>



However, certain optimizations enabled by <span class="option">-O</span> or <span class="option">-O2</span> may cause
the program to appear to behave erratically while under the guise of a 
debugger. It is usually best to use either <span class="option">-O</span> or <span class="option">-g</span>, not both.</p>
</div>




<a name="x-100-3-sec-prog-libraries" /><div class="sect2">
<h3 class="sect2">13.1.7. More Fun with Libraries</h3>

<p><a name="INDEX-2645" />
Before we leave the realm of <tt class="command">gcc</tt>, a few words on linking and
libraries are in order. For one thing, it's easy for you to create your
own libraries. If you have a set of routines you use often, you
may wish to group them into a set of source files, compile each
source file into an object file, and then create a library from the object
files. This saves you having to compile these routines 
individually for each program you use them in.</p>

<p>Let's say you have a set of source files containing oft-used 
routines, such as:
<blockquote><pre class="code">float square(float x) { 
  /* Code for square()... */
}

int factorial(int x, int n) {
  /* Code for factorial()... */
}</pre></blockquote>

and so on (of course, the <tt class="command">gcc</tt> standard libraries provide analogs
to these common routines, so don't be misled by our choice of example). 
Furthermore, let's say that the code for <em class="emphasis">square()</em> is in the file
<em class="filename">square.c</em> and that the code for <em class="emphasis">factorial()</em> is in 
<em class="filename">factorial.c</em>. Simple enough, right?</p>

<p>To produce a library containing these routines, all that you
do is compile each source file, as so:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -c square.c factorial.c</b></tt></pre></blockquote>

which leaves you with <em class="filename">square.o</em> and <em class="filename">factorial.o</em>.
Next, create a library from the object files. As it turns out,
a library is just an archive file created using <tt class="command">ar</tt> (a close
counterpart to <tt class="command">tar</tt>).
Let's call our library <em class="filename">libstuff.a</em> and create it this way:
<a name="INDEX-2646" />
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>ar r libstuff.a square.o factorial.o</b></tt></pre></blockquote>

When updating a library such as this, you may need to delete the old
<em class="filename">libstuff.a</em>, if it exists. 
The last step is to generate an index for the library, which enables the
linker to find routines within the library. To do this, use the 
<tt class="command">ranlib</tt> command, as so:
<a name="INDEX-2647" />
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>ranlib libstuff.a</b></tt></pre></blockquote>

This command adds information to the library itself; no separate index
file is created. You could also combine the two steps of running
<tt class="command">ar</tt> and <tt class="command">ranlib</tt> by using the
<tt class="literal">s</tt> command to <tt class="command">ar</tt> :</p>

<blockquote><pre class="code">papaya$ <tt class="userinput"><b>ar rs libstuff.a square.o factorial.o</b></tt></pre></blockquote>

<p>Now you have <em class="filename">libstuff.a</em>, a static library containing your routines.
Before you can link programs against it, you'll need to create a header
file describing the contents of the library. For example, we could create
<em class="filename">libstuff.h</em> with the contents:
<blockquote><pre class="code">/* libstuff.h: routines in libstuff.a */
extern float square(float);
extern int factorial(int, int);</pre></blockquote>

Every source file that uses routines from
<em class="filename">libstuff.a</em> should contain an
<tt class="literal">#include "libstuff.h"</tt> line, as you would do with
standard header files.
<a name="INDEX-2648" /></p>

<p>Now that we have our library and header file, how do we compile programs
to use them? First of all, we need to put the library and header file
somewhere the compiler can find them. Many users place personal
libraries in the directory <em class="filename">lib</em> in their home directory, and 
personal include files under <em class="filename">include</em>. Assuming we have done
so, we can compile the mythical program <em class="filename">wibble.c</em> using the command:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -I..
<?troff \/?>/include -L..
<?troff \/?>/lib -o wibble wibble.c -lstuff</b></tt></pre></blockquote>

 
<a name="INDEX-2649" />
<a name="INDEX-2650" />
The <span class="option">-I</span> option tells <tt class="command">gcc</tt> to add the 
directory <em class="filename">..
<?troff \/?>/include</em>
to the <em class="emphasis">include path</em> it uses to search for include files.
<span class="option">-L</span> is similar, in that it tells <tt class="command">gcc</tt> to add the directory
<em class="filename">..
<?troff \/?>/lib</em> to the <em class="emphasis">library path</em>.</p>

<p>The last argument on the command line is <span class="option">-lstuff</span>, which tells
the linker to link against the library <em class="filename">libstuff.a</em> (wherever it
may be along the library path). The <em class="filename">lib</em> at the beginning of the 
filename is assumed for libraries.</p>

<p>Any time you wish to link against libraries other than the standard
ones, you should use the <span class="option">-l</span> switch on the <tt class="command">gcc</tt> command line.
For example, if you wish to use math routines (specified in <em class="filename">math.h</em>),
you should add <span class="option">-lm</span> to the end of the
<tt class="command">gcc</tt> command, which links against
<em class="filename">libm</em>. Note, however, that the
<em class="emphasis">order</em> of
<span class="option">-l</span> options is significant. 
For example, if our <em class="filename">libstuff</em> library
used routines found in <em class="filename">libm</em>, you must include 
<span class="option">-lm</span> after <span class="option">-lstuff</span> on the
command line:
<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -Iinclude -Llib -o wibble wibble.c -lstuff -lm</b></tt></pre></blockquote>

This forces the linker to link <em class="filename">libm</em> after <em class="filename">libstuff</em>,
allowing those unresolved references in <em class="filename">libstuff</em> to be taken
care of.</p>

<p><a name="INDEX-2651" />
Where does <tt class="command">gcc</tt> look for libraries? By default, libraries are
searched for in a number of locations, the most important of which is
<em class="filename">/usr/lib</em>. If you take a glance at the contents of <em class="filename">/usr/lib</em>,
you'll notice it contains many library files--some of which have filenames
ending in <em class="filename">.a</em>, others ending in <em class="filename">.so.version</em>.
<a name="INDEX-2652" />
<a name="INDEX-2653" />
The <em class="filename">.a</em> files are static libraries, as is the case with our 
<em class="filename">libstuff.a</em>. The <em class="filename">.so</em> files are shared libraries, which contain code to be linked at runtime, as well as the stub
code required for the runtime linker (<em class="filename">ld.so</em>) to locate
the shared library.</p>

<p>At runtime, the program loader looks for shared 
library images in several places, including <em class="filename">/lib</em>. If you look at 
<em class="filename">/lib</em>, you'll see files such as <em class="filename">libc.so.5.4.47</em>. This is the image 
file containing the code for the <em class="filename">libc</em> shared library (one of the 
standard libraries, which most programs are linked against).</p>

<p>By default, the linker attempts to link against shared libraries.
However, there are several cases in which static libraries are used.
If you enable debugging code with <span class="option">-g</span>, the program will be linked
against the static libraries. You can also specify that static libraries
should be linked by using the <span class="option">-static</span> switch
with <tt class="command">gcc</tt>.</p>

<div class="sect3">
<h3 class="sect3">13.1.7.1. Creating shared libraries</h3>

<p>Now that you know how to create
<a name="INDEX-2654" />
<a name="INDEX-2655" />
<a name="INDEX-2656" />
<a name="INDEX-2657" />
		  and use static libraries, it's very easy to make the step to 
		  shared libraries. Shared libraries have a number of
		  advantages. They reduce memory consumption if used by more
		  than one process, and they reduce the size of the
		  executable. Furthermore, they make developing easier: when
		  you
		  use shared libraries and change some things in a library,
		  you do not need to recompile and relink your application
		  each time. You need to relink only if you make incompatible
		  changes, such as adding arguments to a call or changing the
		  size of a struct.</p>

<p>Before you start doing all your development work with
		  shared libraries, though, be warned that debugging with
		  them is slightly more difficult than with static 
		  libraries, because the debugger usually used on Linux,
<a name="INDEX-2658" />
<a name="INDEX-2659" />
		  <tt class="command">gdb</tt>, has some problems with shared
		  libraries.</p>

<p>Code that goes into a shared library needs to be
		  <em class="firstterm">position independent</em>. This is a just
		  a convention for object code that makes it possible
		  to use the code in shared libraries. You make
		  <tt class="command">gcc</tt> emit 
		  position-independent code by passing it one of the command-line
		  switches <span class="option">-fpic</span> or
<a name="INDEX-2660" />
		  <span class="option">-fPIC</span> (the former is preferred,
		  unless the modules have grown so large that the relocatable
		  code table is simply too small in which case the compiler
		  will emit an error message, and you have to use
		  <span class="option">-fPIC</span>. To repeat our example
		  from the last section:</p>

<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -c -fPIC square.c factorial.c</b></tt></pre></blockquote>

<p>This being done, it is just a simple step to generate
		  a shared library:<a href="#FOOTNOTE-47">[47]</a></p><blockquote>

<a name="FOOTNOTE-47" /><p>[47]In the ancient days of Linux, creating a shared
			  library was a daunting task that even wizards were
			  afraid of. The advent of the ELF object-file format a
			  few years ago has reduced this task to picking the right 
			  compiler switch. Things sure have improved!</p>

</blockquote>

<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -shared -o libstuff.so square.o factorial.o</b></tt></pre></blockquote>

<p>Note the compiler switch
<a name="INDEX-2661" />
		  <span class="option">-shared</span>. There is no indexing step
		  as with static libraries.</p>

<p>Using our newly created shared library is even
		  simpler. The shared library doesn't require any change to
		  the compile command:</p>

<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -I../include -L../lib -o wibble wibble.c -lstuff -lm</b></tt></pre></blockquote>

<p>You might wonder what the linker does if there is a 
		  shared library <em class="filename">libstuff.so</em> and a static 
		  library <em class="filename">llibstuff.a</em> available. In this
		  case, the linker always picks the shared library. To make it 
		  use the 
<?troff .ne 10?>static one, you will have to name it explicitly on
		  the command line:</p>

<blockquote><pre class="code">papaya$ <tt class="userinput"><b>gcc -I../include -L../lib -o wibble wibble.c libstuff.a -lm</b></tt></pre></blockquote>

<p>Another very useful tool for working 
<a name="INDEX-2662" />
		  with shared libraries is <tt class="command">ldd</tt>. It tells you
		  which shared libraries an executable program uses. Here's an 
		  example:</p>

<blockquote><pre class="code">papaya$ <tt class="userinput"><b>ldd wibble</b></tt>
        libstuff.so =&gt; libstuff.so (0x400af000)
        libm.so.5 =&gt; /lib/libm.so.5 (0x400ba000)
        libc.so.5 =&gt; /lib/libc.so.5 (0x400c3000)</pre></blockquote>

<p>The three fields in each line are the name of the
		  library, the full path to the instance of the library that
		  is used, and where in the virtual address space the library
		  is mapped to.</p>

<p>If <tt class="command">ldd</tt> outputs <tt class="literal">not
		  found</tt> for a certain library, you are in trouble
		  and won't be able to run the program in question. You will
		  have to search for a copy of that library. Perhaps it is a
		  library shipped with your distribution that you opted not to 
		  install, or it is already on your hard
		  disk, but the loader (the part of the system that loads
		  every executable program) cannot find it.</p>

<p>In the latter situation, try locating the libraries yourself and
find out whether they're in a nonstandard directory. By default,
the loader looks only in <em class="filename">/lib</em> and
<em class="filename">/usr/lib</em>. If you have libraries in
another directory, create an environment variable
<a name="INDEX-2663" />
<tt class="literal">LD_LIBRARY_PATH</tt> and add the
directories separated by colons.</p>
</div>
</div>




<div class="sect2">
<h3 class="sect2">13.1.8. Using C++</h3>

<p><a name="INDEX-2664" />
<a name="INDEX-2665" />
<a name="INDEX-2666" />
If you prefer object-oriented programming, <tt class="command">gcc</tt> provides complete
support for C++ as well as Objective-C. There are only a few considerations
you need to be aware of when doing C++ programming with <tt class="command">gcc</tt>.</p>

<p>First of all, C++ source filenames should end in the extension <em class="filename">.C</em> 
or <em class="filename">.cc</em>. This distinguishes them from regular C source filenames,
which end in <em class="filename">.c</em>.</p>

<p><a name="INDEX-2667" />
Second, the <tt class="command">g++</tt> shell script should be used in lieu of <tt class="command">gcc</tt>
when compiling C++ code. <tt class="command">g++</tt> is simply a shell script that invokes
<tt class="command">gcc</tt> with a number of additional arguments, specifying a link against
the C++ standard libraries, for example. <tt class="command">g++</tt> takes the same arguments
and options as <tt class="command">gcc</tt>.</p>

<p>If you do not use <tt class="command">g++</tt>, you'll
need to be sure to link against the C++ libraries in order to use any of
the basic C++ classes, such as the <tt class="literal">cout</tt> and <tt class="literal">cin</tt> I/O objects.
Also be sure you have actually installed the C++ libraries and 
include files. Some distributions contain only the standard C libraries.
<tt class="command">gcc</tt> will be able to compile your C++ programs fine, but without
the C++ libraries, you'll end up with linker errors whenever you attempt
to use standard objects.</p>

<a name="INDEX-2668" /><a name="INDEX-2669" /><a name="INDEX-2670" />
</div>
</div>
























































<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch12_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch13_02.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">12.2. Sharing Programs</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">13.2. Makefiles</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="index.htm" coords="172,2,252,105" shape="rect" /><area href="../apache/index.htm" coords="238,2,334,95" shape="rect" /><area href="../sql/index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="../cgi/index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>