<?label 21.3. 
Msql.pm API?><html><head><title>
Msql.pm API (MySQL &amp; mSQL)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="Randy Jay Yarger, George Reese and Tim King" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="1565924347L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="MySQL &amp; mSQL" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="MySQL and mSQL" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch21_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm">MySQL &amp; mSQL</a></td><td width="172" valign="top" align="right"><a href="ch21_04.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<a name="INDEX-1979" /><h2 class="sect1">21.3. <em class="filename" </></em>
Msql.pm API</h2>






<a name="INDEX-1980" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>use Msql</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>use Msql;</pre></td><td align="right" /></tr></table><blockquote><pre class="code">This must be declared in every Perl program that uses the Msql.pm module.</pre></blockquote></div>

<a name="INDEX-1981" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::connect</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$db = Msql-&gt;connect;
$db = Msql-&gt;connect($host);
$db = Msql-&gt;connect($host, $database);</pre></td><td align="right" /></tr></table>
<p></em>Establishes a connection between your Perl program and the Msql
server. There are three versions of the function. With no arguments,
a connection is made to the Msql Unix socket on the local host with
no database defined. This is the most efficient connection. If one
scalar argument is present, that argument is taken to be the hostname
or IP address of the mSQL server. A connection is then made to that
server with no database set. If two scalar arguments are present, the
first is taken to be the host of the mSQL server and the second is
the name of the desired database. The program then makes a connection
to the given server and selects the given database. The value
returned is a reference to an object called the "database
handle." All communication with the database server itself
takes places through this object. If the connection fails for any of
the above cases, <tt class="literal">undef</tt> is returned and the error
is placed in <tt class="literal">$Msql::db_errstr</tt>.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;

# Connect to the localhost Unix socket
my $db = Msql-&gt;connect;

# Or...
# Connect to host 'www.myserver.com' with no database defined
my $db = Msql-&gt;connect('www.myserver.com');

# Or...
# Connect to host 'www.myserver.com' and select database 'mydata'
my $db = Msql-&gt;connect('www.myserver.com','mydata');</pre></blockquote>





</div>

<a name="INDEX-1982" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::createdb</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$result = $db-&gt;createdb($database);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::createdb</tt> takes as its argument the name of a
database to create. It then sends the creation request to the mSQL
server. The command is sent as the same user running the CGI program.
Thus, to work in a CGI program, the program must be run as a user
with the right to create a new database. The function returns -1 on
failure and
on success.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
my $my_new_database = 'mynewdata';
my $result = $db-&gt;createdb($my_new_database);
die "Database was not created!" if $result == -1;
print "$my_new_database has been created.\n";</pre></blockquote>





</div>

<a name="INDEX-1983" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::database</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$database = $db-&gt;database;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::database</tt> returns the name of the current
database as a scalar. The function returns <tt class="literal">undef</tt>
if no database has been selected.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect('www.myserver.com','mydata');

my $database = $db-&gt;database;

print "This should say 'mydata': $database\n";</pre></blockquote>





</div>

<a name="INDEX-1984" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::dropdb</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$result = $db-&gt;dropdb($database);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::dropdb</tt> takes as its argument the name of a
database to destroy. It then sends the destruction request to the
mSQL server. The command is sent as the same user running the CGI
program. Thus, to work in a CGI program, the program must be run as a
user with the right to destroy the database. The function returns -1
on failure and
on success. This function does not ask for any confirmation and the
results are permanent. Thus, this function should be used with the
most extreme caution.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
my $result = $db-&gt;dropdb('mydata');
die "Command failed!" if result == -1;
print "'mydata' is now gone forever.\n";</pre></blockquote>





</div>

<a name="INDEX-1985" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::errmsg</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$error = $db-&gt;errmsg;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::errmsg</tt><b class="function"> </b> returns the last
error encountered by your session with the mSQL server. The value
remains until the next error occurs, at which time it is replaced. If
no error has occurred during your session, the function returns
<tt class="literal">undef</tt>.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
...
my $error = $db-&gt;errmsg;
warn("This is your most recent mSQL error: $error");</pre></blockquote>





</div>

<a name="INDEX-1986" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::getsequenceinfo</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>($step, $value) = $db-&gt;getsequenceinfo($table);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::getsequenceinfo</tt> takes the name of a table as
its argument. It returns the step and value of the sequence defined
on the table, if any. If there is no sequence defined on the given
table, an undefined value <tt class="literal">undef </tt>is returned and an
error is placed in <tt class="literal">Msql::errmsg</tt>.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
my ($step, $value) = $db-&gt;getsequenceinfo('mytable');
die "There is no sequence on mytable" if not $step;
print "mystep has a sequence with a value of $value and a step of $step\n";</pre></blockquote>





</div>

<a name="INDEX-1987" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::host</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$host = $db-&gt;host;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::host</tt> returns the hostname of the database
server as a scalar. There is no guarantee that the function will
return the canonical name of the server or even a fully qualified
domain name. In fact, although not documented, it appears that
<tt class="literal">Msql::host</tt> returns the same string given to the
server in the <tt class="literal">Msql::connect</tt> call. This is true
even to the point that <tt class="literal">Msql::host</tt> returns
<tt class="literal">undef</tt> if you use the no-argument form of
<tt class="literal">Msql::connect</tt>.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect('www.myserver.com');

my $host = $db-&gt;host;

print "You'll probably see 'www.myserver.com': $host\n";</pre></blockquote>





</div>

<a name="INDEX-1988" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::listdbs</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@databases = $db-&gt;listdbs;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::listdbs</tt> returns an
array of the databases available on the server. If there are no
databases on the server, it returns an empty array.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;

my @databases = $db-&gt;listdbs;
print "Available databases:\n\n" . join("\n",@databases);</pre></blockquote>





</div>

<a name="INDEX-1989" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i> </i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$fields = $db-&gt;listfields($table);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::listfields</tt> takes as an argument the name of
a table in the current database. It returns a reference to an object
which contains the names of all of the fields, as well as some other
information. This reference is known as a statement handle. You can
access the information in a statement handle using any of the
following functions: <tt class="literal">Msql::Statement::as_string</tt>,
<tt class="literal">Msql::Statement::listindices</tt> (mSQL 2.0 only),
<tt class="literal">Msql::Statement::numfields</tt>, <tt class="literal">
Msql::Statement::table</tt>,
<tt class="literal">Msql::Statement::name</tt>,
<tt class="literal">Msql::Statement::type</tt>,
<tt class="literal">Msql::Statement::isnotnull</tt>,
<tt class="literal">Msql::Statement::isprikey</tt>,
<tt class="literal">Msql::Statement::isnum</tt>, and
<tt class="literal">Msql::Statement::length</tt>. If the table does not
exist, the function returns an undefined value
<tt class="literal">undef</tt>, and the error is placed in
<tt class="literal">Msql::errmsg</tt>. See <a href="ch21_03.htm">Reference 21.21</a> for a technique that makes this
function somewhat obsolete.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');

my $fields = $db-&gt;listfields('mytable');
warn ("Problem with 'mytable': " . $db-&gt;errmsg) if (not $fields);
# $fields is now a reference to all of the fields in the table 'mytable'.
print "mytable contains the following fields:\n";
print $fields-&gt;as_string;</pre></blockquote>





</div>

<a name="INDEX-1990" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::listindex</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@index_handles = $db-&gt;listindex($table,$index);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::listindex</tt> accepts the names of a table and
the name of an index as its arguments and returns an array of
statement handles containing information about each of the indices.
Although this function is documented as returning an array of
statement handles, we can find no case where more than one statement
handle would be returned. Therefore it is probably safe to treat this
function as returning a scalar statement handle. The statement handle
is of the same style as a statement handle returned by
<tt class="literal">Msql::query</tt> and can be accessed by the same
functions. If the index does not exist, an undefined value
<tt class="literal">undef</tt> is returned. The table of data returned
about the index has one column, which has the title
"Index". The first row is the type of index, which in
mSQL 2.0 is always "avl". The other rows are the names of
the fields that comprise the index. This function is valid only with
mSQL 2.0 or greater database servers.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $mytable_fields = $db-&gt;listfields('mytable');
my @indices = $mytable_fields-&gt;listindices;
# I now know the names of all of the indices.

foreach (@indices) {
   my $index_info_handle = $db-&gt;listindex('mytable',$_);
   my (@index_info) = $index_info_handle-&gt;fetchcol(0);
   my $type_of_index = shift(@index_info);
   # $type_of_index now contains the type of the index (probably 'avl')
   # and @index_info now contains a list of the fields in the index.</pre></blockquote>





</div>

<a name="INDEX-1991" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::listtables</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@tables = $db-&gt;listtables;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::listtables</tt><b class="function"> </b> returns an
array of the tables available in the current database. If the
database has no tables, the function returns an empty array.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;

my @tables = $db-&gt;listtables;
my $database = $db-&gt;database;
print "$database has the following tables:\n\n"
				. join("\n",@tables);</pre></blockquote>





</div>

<a name="INDEX-1992" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::query</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$query_output = $db-&gt;query($sql_statement);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::query</tt> is the most important and most
frequently used function in the Msql.pm API. It is through this
function that you actually send the SQL queries to the database
server. The function takes a scalar string containing an SQL query as
an argument. If the query is a <tt class="literal">SELECT</tt> statement,
the function returns a statement handle containing the results of the
query. Otherwise, the function returns the number of rows that were
affected by the query. The statement handle can be accessed by the
same functions listed for <tt class="literal">Msql::listfields</tt> (except
for <tt class="literal">Msql::Statement::listindices</tt>) as well as the
following: <tt class="literal">Msql::Statement::fetchrow</tt>,
<tt class="literal">Msql::Statement::fetchcol</tt>,
<tt class="literal">Msql::Statement::fetchhash</tt>,
<tt class="literal">Msql::Statement::numrows</tt>,
<tt class="literal">Msql::Statement::maxlength</tt>, and
<tt class="literal">Msql::Statement::dataseek</tt>. If the query is
unsuccessful for any reason, an undefined value
<tt class="literal">undef</tt> is returned and the error is placed in
<tt class="literal">Msql::errmsg</tt>. Each statement handle contains the
output of a separate query. Therefore, you can send as many queries
as your system can handle and then deal with each of the statement
handles at your leisure.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');

my $query1 = "SELECT * FROM mytable";
my $query2 = "SELECT name, date FROM myothertable WHERE name LIKE 'Bob%'";
my $query3 = "UPDATE myothertable SET name='Bob' WHERE name='Joe'";

my $mytable_output = $db-&gt;query($query1);
my $myothertable_output = $db-&gt;query($query2);
my $myothertable_input = $db-&gt;query($query3);

# $mytable_output contains the results of the query on 'mytable'
# $myothertable_output contains the results of the query on 'myothertable'
print "The update on 'myothertable' affected $myothertable_input names\n";</pre></blockquote>





</div>

<a name="INDEX-1993" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>$Msql::QUIET</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left" /><td align="right" /></tr></table>The <tt class="literal">$Msql::QUIET</tt> variable, when true, turns off
error reporting when the <em class="emphasis">-</em>' option is used
in Perl. Otherwise, all MsqlPerl errors will be automatically sent to
<tt class="literal">STDERR</tt>. The variable can be reset at any time. The
<em class="emphasis">-w</em> error reporting feature is so useful that
setting <tt class="literal">$Msql::QUIET</tt> is not recommended.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;

# Turn off error reporting. This has an effect only if the script is being
# run with '-w'.
$Msql::QUIET = 1;

# Do noisy section...

# Turn error reporting back on.
$Msql::QUIET = undef;</pre></blockquote>





</div>

<a name="INDEX-1994" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::quote</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$quoted_string = $db-&gt;quote($string);
$truncated_quoted_string = $db-&gt;quote($string,$length);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::quote</tt> takes as its argument a scalar string.
It returns the same string quoted so that it is safe for insertion
into a <tt class="literal">CHAR</tt> or <tt class="literal">TEXT</tt> field in
the database. More specifically, it surrounds the string with single
quotes, and uses backslashes to escape any single quotes already in
the string. If a second argument is present, the result is truncated
to be that many characters long.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;

my $string = "This is a field's value";

my $qstring = $db-&gt;quote($string);

print qq%This now says "'This is a field\\'s value'" : $qstring\n%;</pre></blockquote>





</div>

<a name="INDEX-1995" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::selectdb</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$db-&gt;selectdb($database);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::selectdb</tt> selects a database from the
database server. If the selection fails, the error is placed in
<tt class="literal">Msql::errmsg</tt>. The only effective way to test for
the success of this function is to examine the value of
<tt class="literal">$db-&gt;database</tt> and compare it to the database to
which you intended to connect. You may switch databases at any time
during your program.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;

$db-&gt;selectdb('mydata');
# The database is now 'mydata'
if ($db-&gt;database ne 'mydata') {
				warn('AWOOOGA! The database wasn't properly selected!');
}
...
$db-&gt;selectdb('myotherdata');
# The database is now 'myotherdata'</pre></blockquote>





</div>

<a name="INDEX-1996" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::shutdown</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$result = $db-&gt;shutdown;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::shutdown</tt> sends a shutdown command to the
mSQL server. The command is sent as the user is running the program.
Thus, to work in a CGI program, the program must be run as a user
with the right to shutdown the database. The function returns -1 on
failure and
on success.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
# Time to shutdown the database...
my $result = $db-&gt;shutdown;
die "Command failed!" if $result == -1;
print "The server has been stopped.\n";</pre></blockquote>





</div>

<a name="INDEX-1997" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::as_string</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$formatted_table = $statement_handle-&gt;as_string;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::as_string</tt> returns the data
contained in the statement handle in a neatly formatted ASCII table.
The table is similar to the ones used by the
<em class="filename">msql</em> monitor. The <em class="filename">pmsql</em>
program supplied with the <em class="emphasis">Msql.pm</em> module uses
this function to generate its tables.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $query = "SELECT * FROM mytable";
my $mytable_output = $db-&gt;query($query);

print "My Table:\n", $mytable_output-&gt;as_string;
# This prints the entire table in a fashion much cleaner than the
# Msql::Statement::fetchhash example.</pre></blockquote>





</div>

<a name="INDEX-1998" /><a name="INDEX-1999" /><a name="INDEX-2000" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>
Msql::Statement::dataseek</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$statement_handle-&gt;dataseek($row_number);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::dataseek</tt> takes the number of a
row as its argument. The function resets the data so that the next
call to <tt class="literal">Msql::Statement::fetchrow</tt> or
<tt class="literal">Msql::Statement::fetchhash</tt> will return the
information in that row. If a row number is supplied that is beyond
the range of the table, the pointer is placed at the end of the table
so that the next access will return an undefined value
<tt class="literal">undef</tt>. The first row of the table is row number 0.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $query = "SELECT name, date FROM myothertable";
my $myothertable_output = $db-&gt;query($query);

my @names = $myothertable_output-&gt;fetchcol(0);
my @dates = $myothertable_output-&gt;fetchcol(1);
# The pointer is now at the end of the table.

$myothertable_output-&gt;dataseek(0);
# The pointer is now reset to the beginning of the table.

print "This is the first row of data: ", $myothertable_output-&gt;fetchrow, "\n".</pre></blockquote>





</div>

<a name="INDEX-2001" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::fetchcol</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@column_of_data = $statement_handle-&gt;fetchcol($column_number);</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::fetchcol</tt> takes the number of a
column as its argument and returns an array of all of the values in
that column. Multiple calls return all columns in the same order, so
that all of the values with a certain element number refer to the
same row. The first output column is numbered 0. To perform this
call, the module must read the entire table. Therefore, if you want
to continue examining the table after using this function you have to
reset the data using <tt class="literal">Msql::Statement::dataseek</tt>. An
undefined value is returned. The function returns
<tt class="literal">undef</tt> if an invalid column number is provided.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $query = "SELECT name, date FROM myothertable WHERE name LIKE 'Bob%'";
my $myothertable_output = $db-&gt;query($query);

my @names = $myothertable_output-&gt;fetchcol(0);
# @names now contains all of the names.
my @dates = $myothertable_output-&gt;fetchcol(1);
# @dates now contains all of the dates.
for (0..$#names) {
   print "Row $_: $names[$_], $dates[$_]\n";
}</pre></blockquote>





</div>
<a name="fetchhash">
<a name="INDEX-2002" /><div class="refentry">
<table cellpadding="5" border="0" width="515">
<tr><td align="left"><font size="+1"><b><i>Msql::Statement::fetchhash</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>%hash = $statement_handle-&gt;fetchhash;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::fetchhash</tt> 
ow
of the statement handle as an associative array (or hash). The keys
of the hash are the names of the fields and the values are the data
values for the current row. Each successive call to the function
returns the next row of data. When there is no more data, the
function returns an undefined value <tt class="literal">undef</tt>.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $query = "SELECT * FROM mytable";
my $mytable_output = $db-&gt;query($query);
my %first_data_row = $mytable_output-&gt;fetchhash;

my @fields = keys %first_data_row;
# @fields now contains all of the field names. Therefore there is never really
# any need to use Msql::listfields, since we can get that information along
# with a lot more through the statement handle returned from Msql::query.

my (%data_row);
print join("", @fields), "\n';
print "-"x70;
print join("", values(%first_data_row);
print join("", values(%data_row)) while %data_row = $mytable_output-&gt;fetchhash;
# This prints a complete dump of the table. (Albeit in a very misaligned format.</pre></blockquote>





</div>

<a name="INDEX-2003" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::fetchrow</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@row_of_data = $statement_handle-&gt;fetchrow;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::fetchrow</tt> returns the next row of
data from a statement handle generated by
<em class="emphasis">Msql::query</em>. Each successive call to<em class="emphasis">
</em><tt class="literal">Msql::Statement::fetchrow</tt><em class="emphasis">
</em>returns the next row of data. When there is no more data,
the function returns an undefined value <tt class="literal">undef</tt>. The
elements in the resultant array are in the order specified in the
original query. If the query was of the form
<tt class="literal">SELECT</tt> * <tt class="literal">FROM </tt>. . ., the
elements are ordered in the same sequence that the fields were
defined in the table.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $query1 = "SELECT * FROM mytable";
my $query2 = "SELECT name, date FROM myothertable WHERE name LIKE 'Bob%'";
my $mytable_output = $db-&gt;query($query1);
my $myothertable_output = $db-&gt;query($query2);
my $i = 0;

# This will keep reading the rows of data until there
# are no more left.
while (my(@mytable_rows)=$mytable_output-&gt;fetchrow) {
   print "Row ".$i++.": ".join(', ',@mytable_rows)."\n";
   # Unless I know something about the structure of 'mytable'
   # I have no idea how many elements are in @mytable_rows or
   # what order they are in.
}

my ($name, $date);

# This is the first row of data from $myothertable_output.
($name, $date) = $myothertable_output-&gt;fetchrow;
# This is the next row...
($name, $date) = $myothertable_output-&gt;fetchrow;
# And the next...
my @name_and_date = $myothertable_output-&gt;fetchrow;
# etc...</pre></blockquote>





</div>

<a name="INDEX-2004" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::isnotnull</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@not_null  = $statement_handle-&gt;isnotnull;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::isnotnull</tt> returns a list of
boolean values indicating if each of the columns of data contained in
the statement handle have been defined as `<tt class="literal">NOT
NULL</tt>'. When called in a scalar context the function
returns a reference to an array.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query("select * from mydata");
my @names = $output-&gt;name;

my @not_null = $output-&gt;isnotnull;
for (0..$#not_null) {
				print "$names[$_] is not null\n" if $not_null[$_];
}</pre></blockquote>





</div>

<a name="INDEX-2005" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::isnum</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@numbers  = $statement_handle-&gt;isnum;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::isnum</tt> returns a list of boolean
values indicating if each of the columns of data contained in the
statement handle is a numerical value. When called in a scalar
context, the function returns a reference to an array. Numerical
values include types, such as `<tt class="literal">INT</tt>'
and `<tt class="literal">REAL</tt>', but do not include a
`<tt class="literal">CHAR</tt>' or
`<tt class="literal">TEXT</tt>' field that contains numbers.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query("select name, date from myothertable");

print "Name is a number" if $output-&gt;isnum-&gt;[0];
print "Date is a number" if $output-&gt;isnum-&gt;[1];</pre></blockquote>





</div>

<a name="INDEX-2006" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::isprikey</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@primary_key  = $statement_handle-&gt;isprikey;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::isprikey</tt> returns a list of
boolean values indicating if each of the columns of data contained in
the statement handle is a primary key. When called in a scalar
context, the function returns a reference to an array. This function
will always return a list of 0's when connected to a mSQL 2
server because mSQL 2 does not use primary keys. However, this
function is useful with mSQL 1 servers, which do implement primary
keys.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query("select * from mytable");

my @prikeys = $output-&gt;isprikey;
my $number_of_prikeys = scalar @prikeys;
print "There are $number_of_prikeys primary keys in this statement handle. ".
      "There are at least this many different tables in the query as each table".
      "can have only one primary key.\n";</pre></blockquote>





</div>

<a name="INDEX-2007" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::length</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@lengths  = $statement_handle-&gt;length;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::length</tt> returns a list of the
maximum possible length of each of the columns of data contained in
the statement handle. These values are the maximums defined when the
table was created. When called in a scalar context, the function
returns a reference to an array.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query("select * from mytable");
my @types = $output-&gt;type;

my @lengths = $output-&gt;length;
for (0..$#types) {
   if ($types[$_] == &amp;Msql::CHAR_TYPE and $lengths[$_] &gt; 1000000) {
      print "You've got one mighty big CHAR field in that table!\";
   }
}</pre></blockquote>





</div>

<a name="INDEX-2008" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::listindices</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@indices = $statement_handle-&gt;listindices;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::listindices</tt> returns the indices
associated with any of the fields found in the statement handle.
Because the function looks for field names directly, it is useful
only with names returned from <tt class="literal">Msql::listfields</tt>. If
no indices are found, an undefined value <tt class="literal">undef</tt> is
returned. This function can only be used with mSQL 2.0, or greater,
database servers.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $mytable_fields = $db-&gt;listfields('mytable');

my @indices = $mytable_fields-&gt;listindices;
print "'mytable' contains these indices: " . join(", ",@indices) . "\n";</pre></blockquote>





</div>

<a name="INDEX-2009" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::maxlength</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@max_lengths  = $statement_handle-&gt;maxlength;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::maxlength</tt> returns a list of the
actual maximum length of each field contained in the table. When
called in a scalar context, the function returns a reference to an
array. Since the mSQL server does not provide this information
directly, this function is implemented by reading the entire table
and searching for the maximum value of each field. Thus, with mSQL
this function can be resource heavy when used with queries that
return large amounts of information.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
$db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query('select name, date from myothertable');

print "The longest name is " . $ouput-&gt;maxlength-&gt;[0] . " characters long.\n";</pre></blockquote>





</div>

<a name="INDEX-2010" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::name</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@column_names  = $statement_handle-&gt;name;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::name</tt> returns the names of the
columns of data contained in the statement handle. When called in a
scalar context the function returns a reference to an array. As with
<tt class="literal">Msql::Statement::table</tt>, the scalar value of this
list (as opposed to the value of the function when called in a scalar
context) is identical to the value of
<tt class="literal">Msql::Statement::numfields</tt>.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query("select * from mytable");

my @column_names = $output-&gt;names;
# @column_names is now a list of the columns in 'mytable'</pre></blockquote>





</div>

<a name="INDEX-2011" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::numfields</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$number_of_fields = $statement_handle-&gt;numfields;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::numfields</tt> returns the number of
fields contained in a single row of the output stored in the
statement handle. All output has at least one field, so this function
will return a positive integer for any defined statement handle.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query("select * from mytable");

my $numfields = $output-&gt;numfields;
my $numrows = $output-&gt;numrows;
print "There are $numfields field in each row of 'mytable'\n";
print "And there are $numrows rows of data. Thus, 'mytable'\n";
print "contains " . ($numfields*$numrows) . " cells of data.\n";</pre></blockquote>





</div>

<a name="INDEX-2012" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::numrows</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$number_of_rows = $statement_handle-&gt;numrows;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::numrows</tt> returns the number of
rows contained in the statement handle. If run on a statement handle
that cannot contain any rows, such as one returned by
<tt class="literal">Msql::listfields</tt>, the function returns the string
`N/A.' If the statement handle could contain rows but
does not, such as one returned by a <tt class="literal">SELECT</tt> that
does not match any fields, the function returns 0.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query("select * from mytable");

my $numrows = $output-&gt;numrows;
print "There are $numrows rows of data in 'mytable'\n";</pre></blockquote>





</div>

<a name="INDEX-2013" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::table</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@tables  = $statement_handle-&gt;table;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::table</tt> returns a list of the
tables associated with each of the columns of data contained in the
statement handle. When called in a scalar context, the function
returns a reference to an array. (See
<tt class="literal">Msql::Statement::isnum</tt> for an example of how to
use the array reference.) One entry is present for each column of
data even if only one table was used in the query. As a side effect,
the scalar value of the array returned by
<tt class="literal">$statement_handle-&gt;table</tt> is the same value as
<tt class="literal">$statement_handle-&gt;numfields</tt>.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query('select myothertable.name, myothertable.date,
   mythirdtable.name from myothertable, mythirdtable where myothertable.name
   = mythirdtable.name');

my @tables = $output-&gt;table;
# @tables now contains ('myothertable', 'myothertable', 'mythirdtable')</pre></blockquote>





</div>

<a name="INDEX-2014" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::Statement::type</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>@column_types  = $statement_handle-&gt;type;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::Statement::type</tt> returns the types of the
columns of data contained in the statement handle. When called in a
scalar context the function returns a reference to an array. The pure
value of this array is not of much use to most users (in the current
implementation it is a list of integers). Rather, the values can be
compared to the built-in values defined in Msql.pm such as
<tt class="literal">&amp;Msql::CHAR_TYPE</tt> and
<tt class="literal">&amp;Msql::INT_TYPE</tt>. One method of accessing this
data is to build an array matching readable names to the predefined
types. This method was demonstrated in <a href="ch10_01.htm">Chapter 10, "Perl"</a>.
Another method is demonstrated below.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;
$db-&gt;selectdb('mydata');
my $output = $db-&gt;query("select name, date from myothertable");

my ($name_type, $date_type) = $output-&gt;type;
for ($name_type) {
   $_ eq &amp;Msql::CHAR_TYPE and do { print 'name is a CHAR'; last; }
   $_ eq &amp;Msql::INT_TYPE and do { print 'name is an INT'; last; }
   # etc...
}
# repeat for $date_type</pre></blockquote>





</div>

<a name="INDEX-2015" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::sock</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>$sock = $db-&gt;sock;</pre></td><td align="right" /></tr></table><tt class="literal">Msql::sock </tt>returns a scalar containing the number
of the socket used to connect with the mSQL server. This is generally
useful only for real nuts and bolts programming.</p>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;
my $db = Msql-&gt;connect;

my $sock = $db-&gt;sock;

print "I am connected on socket $sock.\n";</pre></blockquote>





</div>

<a name="INDEX-2016" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>Msql::*_TYPE</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>Msql.pm provides the following defined functions
that correspond to the mSQL datatypes:
</pre></td><td align="right" /></tr></table><blockquote class="simplelist">

<p><tt class="literal">&amp;Msql::CHAR_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::INT_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::REAL_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::IDENT_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::TEXT_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::IDX_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::NULL_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::DATE_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::UINT_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::MONEY_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::TIME_TYPE</tt></p>

<p><tt class="literal">&amp;Msql::SYSVAR_TYPE</tt></p>

</blockquote>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;

%types = (
				'CHAR' =&gt; &amp;Msql::CHAR_TYPE,
				'INT' =&gt; &amp;Msql::INT_TYPE,
				'REAL' =&gt; &amp;Msql::REAL_TYPE,
				'SYSVAR' =&gt; &amp;Msql::SYSVAR_TYPE,
				'TIME' =&gt; &amp;Msql::TIME_TYPE,
				'MONEY' =&gt; &amp;Msql::MONEY_TYPE,
				'UINT' =&gt; &amp;Msql::UINT_TYPE,
				'TEXT' =&gt; &amp;Msql::TEXT_TYPE,
				'NULL' =&gt; &amp;Msql::NULL_TYPE,
				'DATE' =&gt; &amp;Msql::DATE_TYPE,
				'IDENT' =&gt; &amp;Msql::IDENT_TYPE,
				'IDX' =&gt; &amp;Msql::IDX_TYPE,
);
# $types{'CHAR'} is now an easily accessible alias for 
# &amp;Msql::CHAR_TYPE. Having the values in %types gives you access to all of the
# handy hash functions such as keys() and values().</pre></blockquote>





</div>

<a name="INDEX-2017" /><div class="refentry"><table cellpadding="5" border="0" width="515"><tr><td align="left"><font size="+1"><b><i>$Msql::VERSION</i></b></font></td><td align="right"><i /></td></tr></table><hr color="black" align="left" noshade="true" size="3" width="515" /><table cellpadding="5" border="0" width="515"><tr><td align="left"><pre>The $Msql::VERSION variable contains the version
of the Msql.pm module.
</pre></td><td align="right" /></tr></table>
<h4 class="refsect1">Example</h4>





<blockquote><pre class="code">use Msql;

print "You are using Msql.pm version $Msql::VERSION.\n";</pre></blockquote>





</div>


<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch21_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch21_04.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">21.2. 
DBI.pm API</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">21.4. 
Mysql.pm API</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="../run/index.htm" coords="172,2,252,105" shape="rect" /><area href="../apache/index.htm" coords="238,2,334,95" shape="rect" /><area href="index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="../cgi/index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>
