<?label 10.3. Msql.pm?><html><head><title>Msql.pm (MySQL &amp; mSQL)</title><link href="../style/style1.css" type="text/css" rel="stylesheet" />

<meta name="DC.Creator" content="Randy Jay Yarger, George Reese and Tim King" /><meta scheme="MIME" content="text/xml" name="DC.Format" /><meta content="en-US" name="DC.Language" /><meta content="O'Reilly & Associates, Inc." name="DC.Publisher" /><meta scheme="ISBN" name="DC.Source" content="1565924347L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="MySQL &amp; mSQL" /><meta content="Text.Monograph" name="DC.Type" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" alt="Book Home" usemap="#banner-map" border="0" /><map name="banner-map"><area alt="MySQL and mSQL" href="index.htm" coords="0,0,466,65" shape="rect" /><area alt="Search this book" href="jobjects/fsearch.htm" coords="467,0,514,18" shape="rect" /></map>

<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch10_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm">MySQL &amp; mSQL</a></td><td width="172" valign="top" align="right"><a href="ch10_04.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>
<hr align="left" width="515" />


<h2 class="sect1">10.3. Msql.pm</h2>





<p>The <em class="emphasis">Msql.pm</em>
<a name="INDEX-690" /> module is the original Perl interface
to mSQL. While it has been replaced by the DBI modules, there are
still many sites that depend on this old interface. To illustrate the
use of <em class="emphasis">Msql.pm</em>, we will continue the
teacher's aide example.</p>





<p>Since we need classes in which to give the tests, let's examine
the table of subjects. The table structure looks like this:</p>





<blockquote><pre class="code">CREATE TABLE subject (
  id INT NOT NULL,
  name CHAR(500),
  teacher CHAR(100)
) 

CREATE UNIQUE  INDEX idx1 ON subject (
        id,
        name,
        teacher
) 

CREATE SEQUENCE ON subject</pre></blockquote>





<p>The <tt class="literal">id</tt> number is a unique identifier for the
class, while the name and teacher fields are the name of the course
and the name of the teacher respectively. There is also an index of
all three of the fields that speeds up queries. Finally, we define a
sequence for the table. The ID numbers are generated by this
sequence.</p>





<p>The CGI program to access and manipulate this data must to several
things.</p>




<ul><li><p>Search for a subject in the database.</p></li><li><p>Show the subject that is the result of a search.</p></li><li><p>Add a new subject to the database.</p></li><li><p>Change the values of a subject in the database.</p></li></ul>

<p>With the power of Perl and mSQL, we can easily consolidate all of
these functions into one file, <em class="emphasis">subject.cgi</em>. We
can do this by separating each operation into its own function. The
main portion of the program will be a switchboard of sorts that
directs incoming requests to the proper function. We will describe
the actions themselves later.</p>





<blockquote><pre class="code"># Each of the different parts of the script is selected via the 
# 'action'
# parameter. If no 'action' is supplied, the default() function is
# called.
# Otherwise the appropriate function is called.
&amp;default if not param('action');
# This trick comes from Camel 2 and approximates the 'switch'
# feature of C.
foreach[AO4] (param('action')) {
   /view/ and do { &amp;view; last; };
   /add$/ and do { &amp;add; last; };
   /add2/ and do { &amp;add2; last; };
   /add3/ and do { &amp;add3; last; };
   /add4/ and do { &amp;add4; last; };
   /schange$/ and do { &amp;schange; last; };
   /schange2/ and do { &amp;schange2; last; };
   /lchange$/ and do { &amp;lchange; last; };
   /lchange2/ and do { &amp;lchange2; last; };
   /lchange3/ and do { &amp;lchange3; last; };
   /delete/ and do { &amp;delete; last; };
   &amp;default;
}</pre></blockquote>





<a name="ch10-5-fm2xml" /><blockquote><h4 class="objtitle">NOTE</h4>

<p>The "add," "schange," and
"lchange" entries must have an anchoring "$"
in the regular expression so that they do not match the other
functions similar to them. Without the "$",
"add" would also match <tt class="literal">add2</tt>,
<tt class="literal">add3</tt> and <tt class="literal">add4</tt>. An alternative
method would be to place "add," "schange,"
and "lchange" after the other functions. That way they
would only be called if none of the others matched. However, this
method could cause trouble if other entries are added later. A third
method would be to completely disambiguate all of the entries using
/^view$/, /^add$/, etc. This involves slightly more typing but
removes all possibility of error.<a name="INDEX-691" />
<a name="INDEX-692" /></p>
</blockquote>





<p>Now all we have to do is fill in the details by implementing each
function.</p>





<p>The <tt class="literal">default</tt> function prints out the initial form
seen by the user. This is the form that allows the user to choose
which action to perform. This function is called if the CGI program
is accessed without any parameters, as with
<em class="emphasis">http://www.myserver.com/teach/subject.cgi</em>, or if
the <tt class="literal">ACTION</tt> parameter does not match any of the
existing functions. An alternative method would be to create a
function that prints out an error if the <tt class="literal">ACTION</tt>
parameter is unknown.</p>





<blockquote><pre class="code">sub default {
   print header, start_html('title'=&gt;'Subjects','BGCOLOR'=&gt;'white');
   print &lt;&lt;END_OF_HTML;
&lt;h1&gt;Subjects&lt;/h1&gt;
&lt;p&gt;Select an action and a subject (if applicable).
&lt;FORM ACTION="subject.cgi" METHOD=POST&gt;
&lt;p&gt;&lt;SELECT NAME="action"&gt;
&lt;OPTION VALUE="view"&gt;View a Subject
&lt;OPTION value="add"&gt;Add a Subject
&lt;OPTION value="schange"&gt;Modify a Subject
&lt;OPTION value="lchange" SELECTED&gt;Modify a Class List
&lt;OPTION value="delete"&gt;Delete a Subject
&lt;/select&gt; 
END_OF_HTML
   # See 'sub print_subjects' below.
   &amp;print_subjects;
   print &lt;&lt;END_OF_HTML;
&lt;p&gt;
&lt;INPUT TYPE=SUBMIT VALUE=" Perform Action "&gt; 
&lt;INPUT TYPE=RESET&gt;
&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
HTML

}</pre></blockquote>





<p>There are five main actions: "view," "add,"
"schange" (change the information about a subject),
"lchange" (change the class list for a subject), and
"delete". For illustration, we will examine the
"add" action in detail here. The "add" action
is broken up into four separate functions because interaction with
the user is required up to four times. Hidden variables are used to
pass information from form to form until the class is finally
created.</p>





<p>The first add function generates the form used to enter the initial
information about the class, including its name, the teacher's
name, and the number of students in the class.</p>





<blockquote><pre class="code">sub add {
   my (%fields);
   foreach ('name','size','teacher') {
      if (param($_)) { $fields{$_} = param($_); }
      else { $fields{$_} = ""; }
   }

   print header, start_html('title'=&gt;'Add a Subject','BGCOLOR'=&gt;'white');
   print &lt;&lt;END_OF_HTML;
&lt;H1&gt;Add a Subject&lt;/h1&gt;
&lt;form METHOD=POST ACTION="subject.cgi"&gt;
&lt;p&gt;
Subject Name: &lt;input size=40 name="name" value="$fields{'name'}"&gt;&lt;br&gt;
Teacher's Name: &lt;input size=40 name="teacher" value="$fields{'teacher'}"&gt;&lt;br&gt;
Number of Students in Class: &lt;input size=5 name="size" value="$fields{'size'}"&gt;
&lt;p&gt;
&lt;INPUT TYPE=HIDDEN NAME="action" VALUE="add2"&gt;
&lt;INPUT TYPE=SUBMIT VALUE=" Next Page "&gt; 
&lt;INPUT TYPE=RESET&gt;
&lt;/form&gt;
&lt;p&gt;
&lt;A HREF="subject.cgi"&gt;Go&lt;/a&gt; back to the main Subject page.&lt;br&gt;
&lt;A HREF="."&gt;Go&lt;/a&gt; to the Teacher's Aide Home Page.
&lt;/body&gt;&lt;/html&gt;
END_OF_HTML

}</pre></blockquote>





<p>The function checks to see if any of the fields have preassigned
values. This adds extra versatility to the function in that it can
now be used as a template for classes with default
values -- perhaps generated by another CGI program somewhere.</p>





<p>The values from the first part of the add process are passed back to
CGI program into the <tt class="literal">add2</tt> function. The first
thing that <tt class="literal">add2</tt> does is check whether the class
already exists. If it does, an error message is sent to the user and
he or she can change the name of the class.</p>





<p>If the class does not already exist, the function checks how many
students were entered for the class. If none were entered, the class
is created without any students. The students can be added later. If
the number of students was specified, the class is created and a form
is displayed where the user can enter the information about each
student.</p>





<blockquote><pre class="code">sub add2 {
   ...
   my $name = param('name');
   # We need one copy of the name that is encoded for the URL.
   my $enc_name = &amp;cgi_encode($name);
   # We also need a copy of the name that is quoted safely for insertion
   # into the database. Msql provides the Msql::quote() function for that
   # purpose.
   my $query_name = $dbh-&gt;quote($name);

   # We now build a query to see if the subject entered already exists.
   my $query = 
      "select id, name, teacher from subject where name=$query_name";

   # If the user supplied a teacher's name, we check for that teacher
   # specifically, since there can be two courses with the same name but
   # different teachers.
   if (param('teacher')) {
      $teacher = param('teacher');
      $enc_teacher = &amp;cgi_encode($teacher);
      my $query_teacher = $dbh-&gt;quote($teacher);
      $query .= " and teacher=$query_teacher";
   }

   # Now we send the query to the mSQL server.
   my $out = $dbh-&gt;query($query);
   # We check $out-&gt;numrows to see if any rows were returned. If
   # there were any, and the user didn't supply an 'override'
   # parameter, then we exit with a message that the class already
   # exists, and giving the user a change to enter the class anyway
   # (by resubmitting the form with the 'override' parameter set. 
    if ($out-&gt;numrows and not param('override')) {
      # Print 'Class already exists' page.
      ...
   } else {
      # Now we enter the information into the database.
      # First, we need to select the next number from the
      # table's sequence.
      $out = $dbh-&gt;query("select _seq from subject");
      my ($id) = $out-&gt;fetchrow;

      # Then we insert the information into the database, using
      # the sequence number we just obtained as the ID.
      $query = "INSERT INTO subject (id, name, teacher) 
         VALUES ($id, '$name', '$teacher')";
      $dbh-&gt;query($query);

      # If the user did not specify a class size, we exit with
      # a message letting the user know that he or she can add
      # students later.
      if (not param('size')) {
         # Print success page.
         ...
      } else {
         # Now we print a form, allowing the user to enter the
         # names of each of the students in the class.
         print header, start_html('title'=&gt;'Create Class List',
            'BGCOLOR'=&gt;'white');
         print &lt;&lt;END_OF_HTML;
&lt;H1&gt;Create Class List&lt;/h1&gt;
&lt;P&gt;
&lt;B&gt;$name&lt;/b&gt; has been added to the database. You can
now enter the names of the students in the class. 
You may add or drop students later from the 
&lt;a href="subject.cgi"&gt;main
Subject page&lt;/a&gt;.
&lt;p&gt;
&lt;FORM METHOD=POST ACTION="subject.cgi"&gt;
&lt;INPUT TYPE=HIDDEN NAME="action" VALUE="add3"&gt;
&lt;INPUT TYPE=HIDDEN NAME="id" VALUE="$id"&gt;
&lt;TABLE BORDER=0&gt;
&lt;TR&gt;&lt;TH&gt;&lt;TH&gt;First Name&lt;TH&gt;Middle Name/Initial
&lt;TH&gt;Last Name&lt;TH&gt;Jr.,Sr.,III,etc
&lt;/tr&gt;
END_OF_HTML
         for $i (1..$size) {
         print &lt;&lt;END_OF_HTML;
&lt;TR&gt;&lt;TD&gt;$i&lt;TD&gt;&lt;INPUT SIZE=15 NAME="first$i"&gt;&lt;TD&gt;&lt;INPUT SIZE=15 
NAME="middle$i"&gt;
        &lt;TD&gt;&lt;INPUT SIZE=15 NAME="last$i"&gt;&lt;TD&gt;&lt;INPUT SIZE=5 
NAME="ext$i"&gt;&lt;/tr&gt;
END_OF_HTML

         }
         print &lt;&lt;END_OF_HTML;
&lt;/table&gt;
&lt;INPUT TYPE=SUBMIT VALUE=" Submit Class List "&gt;
&lt;INPUT TYPE=RESET&gt;
&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
END_OF_HTML

      }
   }
}</pre></blockquote>





<p>Note that the function used three copies of the name parameter. To
use a variable as part of a URL, all special characters must be
URL-escaped. A function called
<tt class="literal">cgi_encode</tt>
<a name="INDEX-693" />
<a name="INDEX-694" />
<a name="INDEX-695" /> is
provided with the code for this example which performs this
operation. Secondly, to insert a string into the mSQL database,
certain characters must be escaped. The MsqlPerl interface provides
the function quote -- accessible through any database
handle -- to do this. Finally, an unescaped version of the
variable is used when displaying output to the user.</p>





<p>When adding the class to the database, mSQL's sequence feature
comes in handy. Remember that a sequence was defined on the class
table. The values of this sequence are used as the unique identifiers
for each class. In this way two classes can have the same name (or
same teacher, etc.) and still be distinct. This also comes in handy
when modifying the class later. As long as the unique ID is passed
from form to form, any other information about the class can safely
be changed.</p>





<p>Finally, notice that the student entry form displayed by this
function is dynamically generated. The number of students entered for
the class is used to print out a form with exactly the right number
of entries. Always remember that the CGI program has complete control
over the generated HTML. Any part, including the forms, can be
programmatically created.</p>





<p>If the user did not enter any students for the class, we are now
finished. The user can use the change feature to add students later.
However, if students were requested, the information about those
students is passed onto the stage in the <tt class="literal">add3</tt>
function, as shown in the following:</p>





<blockquote><pre class="code">sub add3 {
   if (not param('id')) { &amp;end("An ID number is required"); }
   my $id = param('id');

   my @list = &amp;find_last_student;
   my ($ref_students,$ref_notstudents) = 
&amp;find_matching_students(@list);

   @students = @$ref_students if $ref_students;
   @notstudents = @$ref_notstudents if $ref_notstudents;

   if (@notstudents) {
      # Print form telling the user that there are nonexisting 
      # students in the list. The user can then automatically create 
      # the students or go back and fix any typos.
      ...
   } else {
      &amp;update_students($id,@students);
      # Print success page.
      ...
   }
}</pre></blockquote>





<p>The bulk of this function's work is performed by other
functions. This is because other parts of the CGI program have
similar needs so it is efficient to factor the common code into
shared functions. The first such function is
<tt class="literal">find_last_student</tt>, which examined the form data
and returns a list of the form numbers -- the form numbers are not
related to the ID numbers in the database -- of each student
entered by the user. This is necessary because, as mentioned earlier,
the previous form is dynamically generated and there is no way to
immediately know how many students are included.</p>





<blockquote><pre class="code">sub find_last_student {
   my @params = param;
   my @list = ();
   foreach (@params) {
      next if not param($_); # Skip any 'empty' fields
      if (/^(first|middle|last|ext)(\d+)/) { 
         my $num = $2;
         if (not grep(/^$num$/,@list)) { push(@list,$num); }
      }
   }
   @list = sort { $a &lt;=&gt; $b} @list;
   return @list;
}</pre></blockquote>





<p>Note that the function returns all of the numbers, not just the last
number -- which would presumably be the number of students
entered. Even though the previous form printed out the number of
entries the user requested, there is no guarantee that the user
filled all of them out. He or she may have missed or skipped a row,
which would not be included with the form data. Therefore, it is
necessary to find out each number that was entered. The output of
this function is then sent to the next "helper" function:
<tt class="literal">find_matching_students</tt>, as shown in the following:</p>





<blockquote><pre class="code">sub find_matching_students {
   my @list = @_;
   my ($i,@students,@notstudents);
   @students = ();
   @notstudents = ();
   if (@list) {
      foreach $i (@list) {
         my @query = ();
         # Build a query that looks for a specific student.
         my $query = "select id, subjects from student where ";
         foreach ('first','middle','last','ext') {
            if (param("$_$i")) {
               my $temp = param("$_$i");
               # Single quotes are the field delimiters for mSQL (and MySQL),
               # so they must be preceded with the escape character "\", 
               # which is escaped itself so that it is interpreted literally.
               $temp =~ s/'/\\'/g;
               push(@query,"$_ = '$temp'");
            }
         }
         $query .= join(" and ",@query);
        
         # Send the query to the database.
         my $out = $dbh-&gt;query($query);
         # If the database doesn't return anything, add the
         # student to the @notstudents array.
         if (not $out-&gt;numrows) {
            push(@notstudents,[ param("first$i"), 
            param("middle$i"),
            param("last$i"), param("ext$i") ]);
            # Otherwise add the student to the @students array.
         } else {
            my ($id,$subjects) = $out-&gt;fetchrow;
            push(@students,[$id,$subjects]);
         }
      }
   }
   return(\@students,\@notstudents);
}</pre></blockquote>





<p>This function goes through each of the given student names and checks
the database to see if they already exist. If they do exist their
information is stored in an array called
<tt class="literal">@students</tt>, otherwise they are put in
<tt class="literal">@notstudents</tt>. The information about each student
is kept in an anonymous array, creating a student object of sorts.
Finally the function returns references to both of the arrays. It
cannot return the data as regular arrays because there would be no
way to tell where one array ended and the other began.</p>





<p>The final helper function is <tt class="literal">update_students</tt>,
which adds the class to each existing student's list of
classes.</p>





<blockquote><pre class="code">sub update_students {
   my $id = shift;
   my @students = @_;
   foreach (@students) {
      my($sid,$subjects)=@$_;
      if (not $subjects) { $subjects = ":$id:"; }
      elsif ($subjects !~ /:$id:/) { $subjects .= "$id:"; }
      my $query = "update student set subjects='$subjects'
         where id=$id";
      $dbh-&gt;query($query);
   }
}</pre></blockquote>





<p>This function queries the <tt class="literal">student</tt> table, which is
entirely separate from the <tt class="literal">subject</tt> table. Within a
single CGI program, you can interact with any number of different
tables within a database. You can even switch between databases, but
you can only have one database selected at a time. This function
retrieves the subject list for each given student and adds the new
subject to their list if it is not there already.</p>





<p>At this point all contingencies are taken care of except for the case
where the subject has students that do not already exist in the
<tt class="literal">student</tt> table. For this case, the list of new
students are sent to the <tt class="literal">add4</tt> function as shown in
the following:</p>





<blockquote><pre class="code">sub add4 {
        # Get list of @students and @notstudents
        &amp;update_students($id,@students) if @students;
        &amp;insert_students($id,@notstudents) if @notstudents;

        # Print success page.
}</pre></blockquote>





<p>This function separates the list of students into existing and
nonexisting students using the same method as
<tt class="literal">add3</tt>. It then updates the existing students using
<tt class="literal">update_students</tt> shown earlier. Nonexisting
students, shown in the following, are sent to the new helper function
<tt class="literal">insert_students</tt>:</p>





<blockquote><pre class="code">sub insert_students {
   foreach $i (@list) {
      # This selects the next number in the sequence defined on the
      # table. We then use this number as the ID of the student.
      my $out = $dbh-&gt;query('select _seq from student');
      my($sid) = $out-&gt;fetchrow;

      # We have to quote all of the text strings for inclusion
      # in the database.
      my ($first, $middle, $last, $ext) = ( 
         $dbh-&gt;quote(param("first$i")),
         $dbh-&gt;quote(param("middle$i")), 
         $dbh-&gt;quote(param("last$i")), 
         $dbh-&gt;quote(param("ext$i"))
      );
      my $query = "insert into student (id, first, middle, last, 
         ext, subjects) VALUES ($sid, $first, $middle, 
         $last, $ext, ':$id:')";
      $dbh-&gt;query($query);
   }
}</pre></blockquote>





<p>This function again accesses the <tt class="literal">student</tt> table
rather than the <tt class="literal">subject</tt> table. An ID number for
the new students is retrieved from the sequence defined on the
<tt class="literal">student</tt> table, and then the student is inserted
into the table using that ID.<a name="INDEX-696" /></p>


<hr align="left" width="515" />
<div class="navbar"><table border="0" width="515"><tr><td width="172" valign="top" align="left"><a href="ch10_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td width="171" valign="top" align="center"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td width="172" valign="top" align="right"><a href="ch10_04.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td width="172" valign="top" align="left">10.2. An Example DBI Application</td><td width="171" valign="top" align="center"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td width="172" valign="top" align="right">10.4. MysqlPerl</td></tr></table></div>
<hr align="left" width="515" />

<img src="../gifs/navbar.gif" alt="Library Navigation Links" usemap="#library-map" border="0" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="1,1,83,102" shape="rect" /><area href="../lnut/index.htm" coords="81,0,152,95" shape="rect" /><area href="../run/index.htm" coords="172,2,252,105" shape="rect" /><area href="../apache/index.htm" coords="238,2,334,95" shape="rect" /><area href="index.htm" coords="336,0,412,104" shape="rect" /><area href="../dbi/index.htm" coords="415,0,507,101" shape="rect" /><area href="../cgi/index.htm" coords="511,0,601,99" shape="rect" /></map>

</body></html>