<html><head><title>Classes and Object-Oriented Programming (ActionScript: The Definitive Guide)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Colin Moock" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="1565928520L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="ActionScript: The Definitive Guide" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="ActionScript: The Definitive Guide" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch12_04.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm">ActionScript: The Definitive Guide</a></td><td align="right" valign="top" width="228"><a href="ch12_06.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>
<hr width="684" align="left" />


<h2 class="sect1">12.5. Classes and Object-Oriented Programming</h2>


<p>It's not <a name="INDEX-1503" /> <a name="INDEX-1504" />uncommon
to create dozens of complex objects that store rich information about
everything from products in a shopping-cart system to bad guys with
artificial intelligence in a video game. To expedite the creation of
objects and to define object hierarchies (relationships between
objects), we use object <em class="emphasis">classes</em>. A
<em class="emphasis">class</em> is a template-style definition of an
entire category of objects. As we learned in the introduction,
classes describe the general features of a specific breed of objects,
such as "all dogs have four legs."</p>


<a name="ch12-15-fm2xml" /><div class="sect2">
<h3 class="sect2">12.5.1. Object Classes</h3>


<p>Before <a name="INDEX-1505" />we
<a name="INDEX-1506" />see how to use classes, let's see
how things work when we <em class="emphasis">don't</em> use them.
Suppose we want a <tt class="literal">ball</tt> object, but instead of
using a class to generate it, we simply adapt a generic object of the
built-in <em class="filename">Object</em> class. We give the object these
properties: <tt class="literal">radius</tt>, <tt class="literal">color</tt>,
<tt class="literal">xPosition</tt>, and <tt class="literal">yPosition</tt>. Then
we add two methods -- <em class="filename">moveTo( )</em> and
<em class="filename">area( ) -- </em>used to reposition the object and
to determine the amount of space it occupies.</p>


<p>Here's the code:</p>


<blockquote><pre class="code">var ball = new Object( );
ball.radius = 10;
ball.color = 0xFF0000;
ball.xPosition = 59;
ball.yPosition = 15;
ball.moveTo = function (x, y) { this.xPosition = x; this.yPosition = y; };
ball.area = function ( ) { return Math.PI * (this.radius * this.radius); };</pre></blockquote>


<p>That approach gets the job done but has limitations; every time we
want a new ball-like object, we have to repeat the
<tt class="literal">ball</tt>-initializing code, which is tedious and
error-prone. In addition, creating many ball objects in this way
redundantly duplicates the identical <em class="filename">moveTo( )</em>
and <em class="filename">area( )</em> function code on each object,
unnecessarily taking up memory.</p>


<p>To efficiently create a series of objects that have common
properties, we should create a <em class="emphasis">class</em>. Using a
class, we can define the properties that all <tt class="literal">ball</tt>
objects should possess. Furthermore, we can share any properties with
fixed values across all instances of the <tt class="literal">ball</tt>
class. In natural language our <em class="filename">Ball</em> class would
be described to the interpreter as follows:</p>


<blockquote>
<p>A <em class="filename">Ball</em> is a type of object. All
<tt class="literal">ball</tt> object instances have the properties
<tt class="literal">radius</tt>, <tt class="literal">color</tt>,
<tt class="literal">xPosition</tt>, <tt class="literal">yPosition</tt>, which are
set individually for each <tt class="literal">ball</tt>. All
<tt class="literal">ball</tt> objects also share the methods
<em class="filename">moveTo( )</em> and <em class="filename">area( )</em>,
which are identical across all members of the
<em class="filename">Ball</em> class.</p>
</blockquote>


<p>Let's see how this theory works in practice.</p>
</div>




<a name="ch12-16-fm2xml" /><div class="sect2">
<h3 class="sect2">12.5.2. Making a Class</h3>


<p>There <a name="INDEX-1507" />
<a name="INDEX-1508" />is no
specific "class declaration" device in ActionScript;
there is no "class" statement that creates a new class
akin to the <em class="filename">var</em> statement, which creates new
variables. Instead, we define a special type of function, called a
<em class="emphasis">constructor</em> function, that will generate a new
instance of our class. By defining the constructor function, we are
effectively creating our class template or class definition.</p>


<p>Syntactically, constructor functions (or simply,
<em class="emphasis">constructors</em>) are formed just like normal
functions. For example:</p>


<blockquote><pre class="code">function <em class="replaceable">Constructor</em> ( ) { 
  <em class="replaceable">statements</em>
}</pre></blockquote>


<p>The name of a class's constructor function may be any valid
function name, but it is capitalized by convention to indicate that
it is a class constructor. A constructor's name should describe
the class of objects it creates, as in <em class="filename">Ball</em>,
<em class="filename">Product</em>, or <em class="filename">Vector2d</em>. The
<em class="replaceable">statements</em> of a constructor function
initialize the objects it creates.</p>


<p>We'll make our <em class="filename">Ball</em> constructor function
as simple as possible to start. All we want it to do so far is create
empty objects for us:</p>


<blockquote><pre class="code">// Make a <em class="replaceable">Ball</em> constructor
function Ball ( ) {
  // Do something here
}</pre></blockquote>


<p>That didn't hurt much. Now let's see how to generate
<tt class="literal">ball</tt> objects using our <em class="filename">Ball</em>
constructor function.</p>


<a name="ch12-17-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.2.1. Creating members of a class</h3>


<p>A <a name="INDEX-1509" />
<a name="INDEX-1510" />constructor <a name="INDEX-1511" />
<a name="INDEX-1512" /> <a name="INDEX-1513" />function both defines our class and
is used to instantiate new instances of the class. As we learned
earlier, when invoked in combination with the
<em class="filename">new</em> operator, a constructor function creates
<em class="emphasis">and then returns</em> an object instance. Recall the
general syntax for creating a new object based on a constructor
function:</p>


<blockquote><pre class="code">new <em class="replaceable">Constructor</em>( );    // Returns an instance of the <em class="replaceable">Constructor</em> class</pre></blockquote>


<p>So, to create a <tt class="literal">ball</tt> object (an
<em class="emphasis">instance</em>) using our <em class="filename">Ball</em>
class, we write:</p>


<blockquote><pre class="code">myBall = new Ball( );  // Stores an instance of the <em class="replaceable">Ball</em> class in <em class="replaceable">myBall</em></pre></blockquote>


<p>Our <em class="filename">Ball</em> class still doesn't add
properties or methods to the objects it creates. Let's take
care of that next.</p>
</div>



<a name="ch12-18-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.2.2. Assigning custom properties to the objects of a class</h3>


<p>To <a name="INDEX-1514" /> <a name="INDEX-1515" />customize
an object's properties during the object-creation stage, we
again turn to the special <tt class="literal">this</tt><a name="INDEX-1516" /> keyword. Within a constructor
function, the <tt class="literal">this</tt> keyword stores a reference to
the object currently being generated. Using that reference, we can
assign whatever properties we like to the embryonic object. The
following syntax shows the general technique:</p>


<blockquote><pre class="code">function <em class="replaceable">Constructor</em> ( ) {
  this.<em class="replaceable">propertyName</em> = <em class="replaceable">value</em>;
}</pre></blockquote>


<p>where <tt class="literal">this</tt> is the object being created,
<em class="replaceable">propertyName</em> is the property we want to
attach to that object, and <em class="replaceable">value</em> is the
data value we're assigning to that property.</p>


<p>Let's apply this technique to our <em class="filename">Ball</em>
example. Earlier, we proposed that the properties of the
<em class="filename">Ball</em> class should be <tt class="literal">radius</tt>,
<tt class="literal">color</tt>, <tt class="literal">xPosition</tt>, and
<tt class="literal">yPosition</tt>. Here's how the
<em class="filename">Ball</em> class constructor might assign those
properties to its instances (note the use of the
<tt class="literal">this</tt> keyword):</p>


<blockquote><pre class="code">function Ball ( ) {
  this.radius = 10;
  this.color = 0xFF0000;
  this.xPosition = 59;
  this.yPosition = 15;
}</pre></blockquote>


<p>With the <em class="filename">Ball</em> constructor thus prepared, we can
create object instances (i.e., members of the class) bearing the
predefined properties -- <tt class="literal">radius</tt>,
<tt class="literal">color</tt>, <tt class="literal">xPosition</tt>, and
<tt class="literal">yPostion</tt> -- by invoking <em class="filename">Ball(
)</em> with the <em class="filename">new</em> operator, just as we
did earlier. For example:</p>


<blockquote><pre class="code">// Make a new instance of <em class="replaceable">Ball</em>
bouncyBall = new Ball( );

// Now access the properties of <em class="replaceable">bouncyBall</em> that were set when it was
// made by the <em class="replaceable">Ball( )</em> constructor.
trace(bouncyBall.radius);     // Displays: 10
trace(bouncyBall.color);      // Displays: 16711680
trace(bouncyBall.xPosition);  // Displays: 59
trace(bouncyBall.yPosition);  // Displays: 15</pre></blockquote>


<p>Now wasn't that fun?</p>


<p>Unfortunately, our <em class="filename">Ball( )</em> constructor uses
fixed values when it assigns properties to the objects it creates
(e.g., <tt class="literal">this.radius</tt> <tt class="literal">=</tt>
<tt class="literal">10</tt>). Every object of the <em class="filename">Ball</em>
class, therefore, would have the same property values, which is
antithetical to the goal of object-oriented programming (we have no
need for a class that generates a bunch of identical objects; it is
their differences that make them interesting).</p>


<p>To <a name="INDEX-1517" />dynamically assign property values to
instances of a class, we adjust our constructor function so that it
accepts arguments. Let's consider the general syntax, then get
back to the <em class="filename">Ball</em> example:</p>


<blockquote><pre class="code">function <em class="replaceable">Constructor</em> (<em class="replaceable">value1</em>, <em class="replaceable">value2</em>, <em class="replaceable">value3</em>) {
  this.<em class="replaceable">property1</em> = <em class="replaceable">value1</em>;
  this.<em class="replaceable">property2</em> = <em class="replaceable">value2</em>;
  this.<em class="replaceable">property3</em> = <em class="replaceable">value3</em>;
}</pre></blockquote>


<p>Inside the <em class="replaceable">Constructor</em> function, we refer
to the object being created with the <tt class="literal">this</tt> keyword,
just as we did earlier. This time, however, we don't hardcode
the object properties' values. Instead, we assign the values of
the arguments <em class="replaceable">value1</em>,
<em class="replaceable">value2</em>, and
<em class="replaceable">value3</em> to the object's properties.
When we want to create a new, unique member of our class, we pass our
class constructor function the initial property values for our new
instance:</p>


<blockquote><pre class="code">myObject = new <em class="replaceable">Constructor</em> (<em class="replaceable">value1</em>, <em class="replaceable">value2</em>, <em class="replaceable">value3</em>);</pre></blockquote>


<p>Let's see how this applies to our <em class="filename">Ball</em>
class, shown in <a href="ch12_05.htm">Example 12-5</a>.</p>


<a name="ch12-87303" /><div class="example">
<h4 class="objtitle">Example 12-5. A Generalized Ball Class </h4>

<blockquote><pre class="code">// Make the <em class="replaceable">Ball( )</em> constructor accept property values as arguments
function Ball (radius, color, xPosition, yPosition) {
  this.radius = radius;
  this.color = color;
  this.xPosition = xPosition;
  this.yPosition = yPosition;
}

// Invoke our constructor, passing it arguments to use as
// our object's property values
myBall = new Ball(10, 0x00FF00, 59, 15);

// Now let's see if it worked...
trace(myBall.radius);  // Displays: 10,  :) Pretty cool...</pre></blockquote>
</div>


<p>We're almost done building our <em class="filename">Ball</em> class.
But you'll notice that we're still missing the
<em class="filename">moveTo( )</em> and <em class="filename">area( )</em>
methods discussed earlier. There are actually two ways to attach
methods to a class's objects. We'll learn the simple,
less efficient way now and come back to the topic of method creation
later when we <a name="INDEX-1518" /> <a name="INDEX-1519" />cover <a name="INDEX-1520" /><em class="emphasis">inheritance</em>.</p>
</div>



<a name="ch12-19-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.2.3. Assigning methods to objects of a class</h3>


<p>The <a name="INDEX-1521" />
<a name="INDEX-1522" />simplest way to add a method to a class is
to assign a property that contains a function within the constructor.
Here's the generic syntax:</p>


<blockquote><pre class="code">function <em class="replaceable">Constructor</em>( ) {
  this.<em class="replaceable">methodName</em> = <em class="replaceable">function</em>;
}</pre></blockquote>


<p>The <em class="replaceable">function</em> may be supplied in several
ways, which we'll examine by adding the <em class="filename">area(
)</em> method to our <em class="filename">Ball</em> class. Note that
we've removed the <tt class="literal">color</tt>,
<tt class="literal">xPosition</tt>, and <tt class="literal">yPosition</tt>
properties from the class for the sake of clarity.</p>


<p>The <em class="replaceable">function</em> can be a
<a name="INDEX-1523" />
<a name="INDEX-1524" />function literal, as in:</p>


<blockquote><pre class="code">function Ball (radius) {
  this.radius = radius;
  // Add the <em class="replaceable">area</em> method...
  this.area = function ( ) { return Math.PI * this.radius * this.radius; };
}</pre></blockquote>


<p>Alternatively, <a name="INDEX-1525" />the
<em class="replaceable">function</em> can be declared
<em class="emphasis">inside</em> the constructor:</p>


<blockquote><pre class="code">function Ball (radius) {
  this.radius = radius;
  // Add the <em class="replaceable">area</em> method...
  this.area = getArea;
  function getArea ( ) {
    return Math.PI * this.radius * this.radius; 
  }
}</pre></blockquote>


<p>Finally, the <em class="replaceable">function</em> can be declared
<em class="emphasis">outside</em> the constructor but assigned
<em class="emphasis">inside</em> the constructor:</p>


<blockquote><pre class="code">// Declare the <em class="replaceable">getArea( )</em> function
function <em class="replaceable">getArea</em> ( ) {
  return Math.PI * this.radius * this.radius; 
}

function Ball (radius) {
  this.radius = radius;
  // Add the <em class="replaceable">area</em> method...
  this.area = getArea;
}</pre></blockquote>


<p>There's no real difference between the three
approaches -- all are perfectly valid. Function literals often
prove the most convenient to use but are perhaps not as reusable as
defining a function outside of the constructor so that it can also be
used in other constructors. Regardless, all three approaches lack
efficiency.</p>


<p>So far we've been attaching unique property values to each
object of our <em class="filename">Ball</em> class. Each
<tt class="literal">ball</tt> object needs its own
<tt class="literal">radius</tt> and <tt class="literal">color</tt> property
values to distinguish one <tt class="literal">ball</tt> from the next. But
when we assign a fixed method to the objects of a class using the
techniques we've just seen, we are unnecessarily duplicating
the method on <em class="emphasis">every object</em> of our class. The
<em class="filename">area</em> formula is the same for every
<tt class="literal">ball</tt>, and hence the code that performs this task
should be centralized and generalized.</p>


<p>To more efficiently attach any property or method with a fixed value
to a class, we use <em class="emphasis">inheritance</em>, our next topic
of study.</p>
</div>
</div>




<a name="ch12-20-fm2xml" /><div class="sect2">
<h3 class="sect2">12.5.3. Object Property Inheritance</h3>


<p><em class="filename">Inherited</em> <a name="INDEX-1526" />properties <a name="INDEX-1527" />are <a name="INDEX-1528" />not attached to the individual object
instances of a class. They are attached once to the class constructor
and borrowed by the objects as necessary. These properties are said
to be <em class="emphasis">inherited</em> because they are<em class="emphasis">
</em>passed down to<em class="emphasis"> </em>objects instead of
being defined within each object. An inherited property appears to
belong to the object through which it is referenced but is actually
part of the object's class constructor.</p>


<p><a href="ch12_05.htm">Figure 12-2</a> demonstrates the general model for
inherited properties using our <em class="filename">Ball</em> class as an
example. Because the <em class="filename">moveTo( )</em> and
<em class="filename">area( )</em> methods of <em class="filename">Ball</em> do
not vary among its instances, those methods are best implemented as
inherited methods. They belong to the class itself, and each
<tt class="literal">ball</tt> object accesses them only by reference. On
the other hand, the <tt class="literal">radius</tt>,
<tt class="literal">color</tt>, <tt class="literal">xPosition</tt>, and
<tt class="literal">yPosition</tt> properties of our
<em class="filename">Ball</em> class are assigned to each object as normal
properties because each <tt class="literal">ball</tt> needs its own value
for those properties.</p>


<a name="ch12-24928" /><div class="figure"><img alt="Figure 12-2" src="figs/act.1202.gif" /></div><h4 class="objtitle">Figure 12-2. Inherited and normal properties</h4>

<p>Inheritance works in a hierarchical chain, like a family tree. When
we invoke a method of an individual object, the interpreter checks to
see if that object implements the method. If the method isn't
found, the interpreter then looks at the class for the method.</p>


<p>For example, if we execute <tt class="literal">ball1.area( )</tt>, the
interpreter checks whether <tt class="literal">ball1</tt> defines an
<em class="filename">area( )</em> method. If the <tt class="literal">ball1</tt>
object lacks an <em class="filename">area( )</em> method, the interpreter
checks whether the <em class="filename">Ball</em> class defines an
<em class="filename">area( )</em> method. If it does, the interpreter then
invokes <em class="filename">area( )</em> as though it were a method of
the <tt class="literal">ball1</tt> object, not the
<em class="filename">Ball</em> class. This allows the method to operate on
the <tt class="literal">ball1</tt> object (rather than the class),
retrieving or setting <tt class="literal">ball1</tt>'s properties as
necessary. This is one of the key benefits of OOP; we
<em class="emphasis">define</em> the function in one place (the
<em class="filename">Ball</em> class) but <em class="emphasis">use</em> it from
many places (any <tt class="literal">ball</tt> object).</p>


<p>Unlike normal properties, inherited properties may only be
<em class="emphasis">retrieved</em> through an object, not set.</p>


<p>Time for a little code to breathe some life into these principles.</p>


<a name="ch12-21-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.3.1. Creating inherited properties with the prototype property</h3>


<p>We <a name="INDEX-1529" /> <a name="INDEX-1530" />start the process of creating
inherited properties by creating a class constructor function, such
as that of our <em class="emphasis">Ball</em> class in <a href="ch12_05.htm">Example 12-5</a>:</p>


<blockquote><pre class="code">function Ball (radius, color, xPosition, yPosition) {
  this.radius = radius;
  this.color = color;
  this.xPosition = xPosition;
  this.yPosition = yPosition;
}</pre></blockquote>


<p>Remember from <a href="ch09_01.htm">Chapter 9, "Functions"</a>, that functions double as
objects and can therefore take properties.</p>




<a name="ch12-23-fm2xml" /><blockquote><h4>TIP</h4>
<p><a name="INDEX-1531" />When a
constructor function is created, the interpreter automatically
assigns it a property called <tt class="literal">prototype</tt>. In the
<tt class="literal">prototype</tt> property, the interpreter places a
generic object. Any properties attached to the
<tt class="literal">prototype</tt> object are inherited by all instances of
the constructor function's class.</p>

</blockquote>

<p>To create a property that will be inherited by all the objects of a
class, we simply assign that property to the prefabricated
<tt class="literal">prototype</tt> object of the class's constructor
function. Here's the general syntax:</p>


<blockquote><pre class="code"><em class="replaceable">Constructor</em>.prototype.<em class="replaceable">propName</em> = <em class="replaceable">value</em>;</pre></blockquote>


<p>where <em class="replaceable">Constructor</em> is our class's
constructor function (<em class="filename">Ball </em>in our example);
<tt class="literal">prototype</tt> is the automatically generated property
we use to house inherited properties;
<em class="replaceable">propName</em> is the inherited property name,
and <em class="replaceable">value</em> is that inherited
property's value. For example, here's how we would add a
global <tt class="literal">gravity</tt> property to our entire class of
<em class="emphasis">Ball</em> objects:</p>


<blockquote><pre class="code">Ball.prototype.gravity = 9.8;</pre></blockquote>


<p>With the <tt class="literal">gravity</tt> property in place, we can then
access <tt class="literal">gravity</tt> from any member of the
<em class="filename">Ball</em> class:</p>


<blockquote><pre class="code">// Create a new instance of the <em class="replaceable">Ball</em> class
myBall = new Ball(5, 0x003300, 34, 220);

// Now display the value of the inherited <em class="replaceable">gravity</em> property
trace(myBall.gravity);  // Displays: 9.8</pre></blockquote>


<p>The <tt class="literal">gravity</tt> property is accessible through
<tt class="literal">myBall</tt> because <tt class="literal">myBall</tt> inherits
the properties of <em class="filename">Ball </em>'s
<tt class="literal">prototype</tt> object.</p>


<p>Because the same methods are ordinarily shared by every instance of a
class, they are typically stored in inherited properties. Let's
add an inherited <em class="filename">area( )</em> method to our
<em class="filename">Ball</em> class:</p>


<blockquote><pre class="code">Ball.prototype.area = function ( ) {
  return Math.PI * this.radius * this.radius; 
};  // Semicolon required because this is a function literal</pre></blockquote>


<p>That was so much fun, let's add an inherited <em class="filename">moveTo(
)</em> method, this time using a predefined function instead of
a function literal:</p>


<blockquote><pre class="code">function moveTo (x, y) {
  this.xPosition = x;
  this.yPosition = y;
}

Ball.prototype.moveTo = moveTo;</pre></blockquote>


<p>Once a function is defined as an inherited property, we can invoke it
like any other method:</p>


<blockquote><pre class="code">// Make a new ball
myBall = new Ball(15, 0x33FFCC, 100, 50);

// Now invoke <em class="replaceable">myBall</em><tt class="userinput"><b>'</b></tt><em class="replaceable">s</em> inherited <em class="replaceable">area( )</em> method
trace(myBall.area( ));  // Displays: 706.858347057703</pre></blockquote>


<p>Note that it's also possible to replace a constructor's
<tt class="literal">prototype</tt> object entirely with a new object,
thereby adding many inherited properties in a single gesture. Doing
so, however, alters the inheritance chain, which we'll learn
about later <a name="INDEX-1532" /> <a name="INDEX-1533" />under "Superclasses and
Subclasses."</p>
</div>



<a name="ch12-24-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.3.2. Overriding inherited properties</h3>


<p>To <a name="INDEX-1534" />customize
an inherited property for a single object, we can set a property on
that object using the same name as the inherited property. For
example, we might want to give one ball lower gravity than all other
balls:</p>


<blockquote><pre class="code">// Create our <em class="replaceable">Ball</em> class constructor
function Ball ( radius, color, xPosition, yPosition ) { ... } // Not shown

// Assign an inherited <em class="replaceable">gravity</em> property
Ball.prototype.gravity = 9.8

// Create a Ball object
lowGravBall = new Ball ( 200, 0x22DD99, 35, 100 );

// Override the inherited <em class="replaceable">gravity</em> property
lowGravBall.gravity = 4.5;</pre></blockquote>


<p>A property set on an object always overrides any inherited property
by the same name. This is simply a result of the way the inheritance
chain works. Likewise, method definitions local to an object will
override those in its class. If we execute <tt class="literal">ball1.area(
)</tt> and <tt class="literal">ball1</tt> defines an <em class="filename">area(
)</em> method, that method is used; the interpreter never
bothers looking at the <em class="filename">Ball</em> class's
<tt class="literal">prototype</tt> to see if it also defines an
<em class="filename">area( )</em> method.</p>
</div>



<a name="ch12-91912" /><div class="sect3">
<h3 class="sect3">12.5.3.3. The constructor property</h3>


<p>When <a name="INDEX-1535" /> <a name="INDEX-1536" />a
<a name="INDEX-1537" />constructor's
<tt class="literal">prototype</tt> object is created, the interpreter
automatically assigns it a special property called
<tt class="literal">constructor</tt>. The <tt class="literal">constructor</tt>
property is a reference to the <tt class="literal">prototype</tt>'s
class constructor function. For example, the following expressions
both yield a reference to the <em class="filename">Ball</em> constructor
function:</p>


<blockquote><pre class="code">trace(Ball);                        // Displays: [Function]
trace(Ball.prototype.constructor);  // Also displays: [Function]
                                    // Same reference as above</pre></blockquote>


<p>Note that the <tt class="literal">constructor</tt> property contains a
<em class="emphasis">reference</em> to a constructor function, not a
string representing the function's name.</p>
</div>



<a name="ch12-88236" /><div class="sect3">
<h3 class="sect3">12.5.3.4. The _ _ proto_ _ property</h3>


<p>When <a name="INDEX-1538" />
<a name="INDEX-1539" />any <a name="INDEX-1540" />object is created, the interpreter
automatically assigns it a special property called <tt class="literal">_ _
proto_ _</tt> (note the <em class="emphasis">two</em> underscores on
either side of the name). The <tt class="literal">_ _ proto_ _</tt>
property of an object is a reference to the
<tt class="literal">prototype</tt> property of that object's
constructor function. For example, when we create an instance of
<em class="filename">Ball</em> called <tt class="literal">myBall</tt>,
<tt class="literal">myBall._ _ proto_ _</tt> is set to
<tt class="literal">Ball.prototype</tt>:</p>


<blockquote><pre class="code">myBall = new Ball(6, 0x00FF00, 145, 200);
trace(myBall._    _    proto_    _ == Ball.prototype);  // Displays: true</pre></blockquote>


<p>The <tt class="literal">_ _ proto_ _</tt> property is used primarily by the
ActionScript interpreter to look up an object's inherited
properties. For example, when we invoke the inherited method
<em class="filename">area( )</em> through <tt class="literal">myBall</tt>, as in
<em class="filename">myBall.area( )</em>, ActionScript accesses the
<em class="filename">Ball.prototype.area</em> method via <tt class="literal">myBall._
_ proto_ _</tt>.</p>


<p>We may also use <tt class="literal">_ _ proto_ _</tt> directly to check
whether an object belongs to a specified class, as <a name="INDEX-1541" />shown <a name="INDEX-1542" />in <a href="ch12_05.htm">Example 12-6</a>.</p>


<a name="ch12-70755" /><div class="example">
<h4 class="objtitle">Example 12-6. Determining the Class of an Object </h4>

<blockquote><pre class="code">function MyClass (prop) {
  this.prop = prop;
}
myObj = new MyClass( );
if (myObj._    _    proto_    _ == MyClass.prototype) {
  trace("myObj is an instance of MyClass");
}</pre></blockquote>
</div>
</div>
</div>




<a name="ch12-40468" /><div class="sect2">
<h3 class="sect2">12.5.4. Superclasses and Subclasses</h3>


<p>One <a name="INDEX-1543" /> <a name="INDEX-1544" />of <a name="INDEX-1545" /> <a name="INDEX-1546" />the crucial features of classes in
advanced object-oriented programming is their ability to share
properties. That is, an entire class may inherit properties from, and
pass properties on to, other classes. In complex situations,
multiclass inheritance can be indispensable. (Even if you don't
use multiclass inheritance yourself, understanding it will help you
work with the built-in ActionScript classes.)</p>


<p>We've seen how objects inherit properties from the
<tt class="literal">prototype</tt> object of their class constructors.
Inheritance is not limited to that single object/class relationship.
A class itself may inherit properties from other classes. For
example, we may have a class called <em class="filename">Circle</em> that
defines a general method, <em class="filename">area( )</em>, used to find
the area of all circular objects. Instead of defining a separate
<em class="filename">area( )</em> method in a class like
<em class="filename">Ball</em>, we may simply make
<em class="filename">Ball</em> inherit the <em class="filename">area( )</em>
method already available from <em class="filename">Circle</em>. Instances
of <em class="filename">Ball</em>, hence, inherit the
<em class="filename">Circle</em>'s <em class="filename">area( )</em>
method through <em class="filename">Ball</em>. Notice the
hierarchy -- the simplest class, <em class="filename">Circle</em>,
defines the most general methods and properties. Another class,
<em class="filename">Ball</em>, builds on that simple
<em class="filename">Circle</em> class, adding features specific to
<em class="filename">Ball</em>-class instances but relying on
<em class="filename">Circle</em> for the basic attributes that all
circular objects share. In traditional object-oriented programming,
the <em class="filename">Ball</em> class would be said to
<em class="emphasis">extend</em> the <em class="filename">Circle</em> class.
That is, <em class="filename">Ball</em> is a <em class="emphasis">subclass</em>
of <em class="filename">Circle</em>, while <em class="filename">Circle</em> is
a <em class="emphasis">superclass</em> of <em class="filename">Ball</em>.</p>


<a name="ch12-25-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.4.1. Making a superclass</h3>


<p>Earlier <a name="INDEX-1547" />we
learned to define inherited properties on the
<tt class="literal">prototype</tt> object of a class's constructor
function. To create a <em class="emphasis">superclass</em> for a given
class, we completely <em class="emphasis">replace</em> the class's
<tt class="literal">prototype</tt> object with a new instance of the
desired superclass. Here's the general syntax:</p>


<blockquote><pre class="code"><em class="replaceable">Constructor</em>.prototype = new <em class="replaceable">SuperClass</em>( );</pre></blockquote>


<p>By replacing <em class="replaceable">Constructor</em>'s
<tt class="literal">prototype</tt> object with an instance of
<em class="replaceable">SuperClass</em>, we force all instances of
<em class="replaceable">Constructor</em> to inherit the properties
defined on instances of <em class="replaceable">SuperClass</em>. In
<a href="ch12_05.htm">Example 12-7</a>, we first create a class,
<em class="filename">Circle</em>, which assigns an <em class="filename">area(
)</em> method to all its instances. Then we assign an instance
of <em class="filename">Circle</em> to <tt class="literal">Ball.prototype</tt>,
causing all <tt class="literal">ball</tt> objects to inherit
<em class="filename">area( )</em> from <em class="filename">Circle</em>.</p>


<a name="ch12-25746" /><div class="example">
<h4 class="objtitle">Example 12-7.  Creating a Superclass </h4>

<blockquote><pre class="code">// Create a <em class="replaceable">Circle</em> (superclass) constructor
function Circle( ) {
  this.area = function ( ) { return Math.PI * this.radius * this.radius; };
}

// Create our usual <em class="replaceable">Ball</em> class constructor
function Ball ( radius, color, xPosition, yPosition ) {
  this.radius = radius;
  this.color = color;
  this.xPosition = xPosition;
  this.yPosition = yPosition;
}

// Here we make the superclass by assigning an instance of <em class="replaceable">Circle</em> to
// the <em class="replaceable">Ball</em> class constructor's <em class="replaceable">prototype</em>
Ball.prototype = new Circle( );

// Now let's make an instance of <em class="replaceable">Ball</em> and check its properties
myBall = new Ball ( 16, 0x445599, 34, 5);
trace(myBall.xPosition);   // 34, a normal property of <em class="replaceable">Ball</em>
trace(myBall.area( ));      // 804.24..., <em class="replaceable">area( )</em> was inherited from <em class="replaceable">Circle</em></pre></blockquote>
</div>


<p>However, our class hierarchy now has poor
structure -- <em class="filename">Ball</em> defines
<tt class="literal">radius</tt>, but <tt class="literal">radius</tt> is actually
a property common to all circles, so it belongs in our
<em class="filename">Circle</em> class. The same is true of
<tt class="literal">xPosition</tt> and <tt class="literal">yPosition</tt>. To fix
the structure, we'll move <tt class="literal">radius</tt>,
<tt class="literal">xPosition</tt>, and <tt class="literal">yPosition</tt> to
<em class="filename">Circle</em>, leaving only <tt class="literal">color</tt> in
<em class="filename">Ball</em>. (For the sake of the example, we'll
treat <tt class="literal">color</tt> as a property only balls can have.)</p>


<p>Conceptually, here's the setup of our revised
<em class="filename">Circle</em> and <em class="filename">Ball</em>
constructors:</p>


<blockquote><pre class="code">// Create the <em class="replaceable">Circle</em> (superclass) constructor
function Circle ( radius, xPosition, yPosition ) {
  this.area = function ( ) { return Math.PI * this.radius * this.radius; };
  this.radius = radius;
  this.xPosition = xPosition;
  this.yPosition = yPosition;
}

// Create the <em class="replaceable">Ball</em> class constructor
function Ball ( color ) {
  this.color = color;
}</pre></blockquote>


<p>Having moved the properties around, we're faced with a new
problem. How can we provide values for <tt class="literal">radius</tt>,
<tt class="literal">xPosition</tt>, and <tt class="literal">yPosition</tt> when
we're creating objects using <em class="filename">Ball</em> and not
<em class="filename">Circle </em>? We have to make one more adjustment to
our <em class="filename">Ball</em> constructor code. First, we set up
<em class="filename">Ball</em> to receive all the required properties as
parameters:</p>


<blockquote><pre class="code">function Ball ( color, radius, xPosition, yPosition ) {</pre></blockquote>


<p>Next, within our <em class="filename">Ball</em> constructor, we define the
<em class="filename">Circle</em> constructor as a method of the
<tt class="literal">ball</tt> object being instantiated:</p>


<blockquote><pre class="code">this.superClass = Circle;</pre></blockquote>


<p>Finally, we invoke the <em class="filename">Circle</em> constructor on the
<tt class="literal">ball</tt> object, and pass it values for
<tt class="literal">radius</tt>, <tt class="literal">xPosition</tt>, and
<tt class="literal">yPosition</tt>:</p>


<blockquote><pre class="code">this.superClass(radius, xPosition, yPosition);</pre></blockquote>


<p>Our completed class/superclass code is shown in <a href="ch12_05.htm">Example 12-8</a>.</p>


<a name="ch12-76106" /><div class="example">
<h4 class="objtitle">Example 12-8.  A Class and Its Superclass </h4>

<blockquote><pre class="code">// Create a <em class="replaceable">Circle</em> (superclass) constructor
function Circle ( radius, xPosition, yPosition) {
  this.area = function ( ) { return Math.PI * this.radius * this.radius; };
  this.radius = radius;
  this.xPosition = xPosition;
  this.yPosition = yPosition;
}

// Create our <em class="replaceable">Ball</em> class constructor
function Ball ( color, radius, xPosition, yPosition ) {
  // Define the Circle superclass as a method of the ball being instantiated
  this.superClass = Circle;
  // Invoke the Circle constructor on the ball object, passing values
  // supplied as arguments to the <em class="replaceable">Ball</em> constructor
  this.superClass(radius, xPosition, yPosition);
  // Set the color of the ball object
  this.color = color;
}

// Assign an instance of our <em class="replaceable">Circle</em> superclass to our 
// Ball class constructor's prototype
Ball.prototype = new Circle( );

// Now let's make an instance of <em class="replaceable">Ball</em> and check its properties
myBall = new Ball ( 0x445599, 16, 34, 5);
trace(myBall.xPosition);   // 34
trace(myBall.area( ));      // 804.24...
trace(myBall.color);       // 447836</pre></blockquote>
</div>


<p>Note that the word <tt class="literal">superClass</tt> in
<em class="filename">Ball</em> is not reserved or special. It's
simply an apt name for the superclass constructor function.
Furthermore, <em class="emphasis">Circle </em>'s <em class="emphasis">area( )
</em>method could have been defined on
<tt class="literal">Circle.prototype</tt>. When you start programming with
classes and objects in the real world, you'll undoubtedly
notice that there's a certain amount of flexibility in the
tools ActionScript provides for building class hierarchies and
implementing inheritance. You'll likely need to adapt the
approaches described in this chapter to suit the subtleties of your
specific <a name="INDEX-1548" />application.</p>
</div>



<a name="ch12-26-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.4.2. Polymorphism</h3>


<p>Inheritance <a name="INDEX-1549" />
<a name="INDEX-1550" />makes
<a name="INDEX-1551" />another key OOP concept,
<em class="emphasis">polymorphism</em>, possible. Polymorphism is a fancy
word meaning "many forms." It simply means that you tell
an object what to do, but leave the details up to the object (a.k.a.
"Different strokes for different folks"). It is best
illustrated with an example. Suppose you are creating a cops and
robbers game. There are multiple cops, robbers, and innocent
bystanders displayed on the screen simultaneously, all moving
independently according to different rules. The cops chase the
robbers, the robbers run away from the cops, and the innocent
bystanders move randomly, confused and frightened. In the code for
this game, suppose we create an object class to represent each
category of person:</p>


<blockquote><pre class="code">function Cop( ) { ... }
function Robber( ) { ... }
function Bystander( ) { ... }</pre></blockquote>


<p>In addition, we create a superclass, <em class="filename">Person</em>,
that classes <em class="filename">Cop</em>, <em class="filename">Robber</em>,
and <em class="filename">Bystander</em> all inherit from:</p>


<blockquote><pre class="code">function Person( ) { ... }
Cop.prototype       = new Person( );
Robber.prototype    = new Person( );
Bystander.prototype = new Person( );</pre></blockquote>


<p>On each frame of the Flash movie, every person on the screen should
move according to the rules for their class. To make this happen, we
define a method <em class="filename">move( )</em> on every object (the
<em class="filename">move( )</em> method is customized for each class):</p>


<blockquote><pre class="code">Person.prototype.move = function ( ) { ... <em class="replaceable">default move behavior</em> ... }
Cop.prototype.move = function ( ) { ... <em class="replaceable">move to chase robber</em> ... }
Robber.prototype.move = function ( ) { ... <em class="replaceable">move to run away from cop</em> ... }
Bystander.prototype.move = function ( ) { ... <em class="replaceable">confused, move randomly</em> ... }</pre></blockquote>


<p>On each frame of the Flash movie, we want every person on the screen
to move. To manage all the people, we create a master array of
<em class="filename">Person</em> objects. Here's an example of how
the <tt class="literal">persons</tt> array might be populated:</p>


<blockquote><pre class="code">// Create our cops
cop1 = new Cop( );
cop2 = new Cop( );

// Create our robbers
robber1 = new Robber( );
robber2 = new Robber( );
robber3 = new Robber( );

// Create our bystanders
bystander1 = new Bystander( );
bystander2 = new Bystander( );

// Create an array populated with cops, robbers, and bystanders
persons = [cop1, cop2, robber1, robber2, robber3, bystander1, bystander2];</pre></blockquote>


<p>In every frame of the Flash movie, we call the function
<em class="filename">moveAllPersons( )</em>, which is defined as follows:</p>


<blockquote><pre class="code">function moveAllPersons( ) {
  for (var i=0; i &lt; persons.length; i++) {
    persons[i].move( );
  }
}</pre></blockquote>


<p>When <em class="filename">moveAllPersons( )</em> is invoked, all of the
cops, robbers, and bystanders will move according to the individual
rules associated with their class as defined by its <em class="filename">move(
)</em> method. This is polymorphism in action -- objects
with common characteristics can be organized together, but they
retain their individual identities. The cops, robbers, and bystanders
have much in common, embodied by the superclass
<em class="filename">Person</em>. They have operations in common, like
knowing how to move. However, they may implement the common
operations differently and may support other class-specific
operations and data. Polymorphism permits dissimilar objects to be
treated uniformly. We use the <em class="filename">move( )</em> function
to cause all the people to move, even though the <em class="filename">move(
)</em> function for each class <a name="INDEX-1552" />is <a name="INDEX-1553" /> <a name="INDEX-1554" />unique.</p>
</div>



<a name="ch12-27-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.4.3. Determining whether an object belongs to a superclass</h3>


<p>Suppose <a name="INDEX-1555" />
<a name="INDEX-1556" />we have a
<em class="filename">Shape</em> class and a <em class="filename">Rectangle</em>
class that has <em class="filename">Shape</em> as its superclass. To check
whether an object is a descendant of <em class="filename">Shape</em>, we
must refine the method in <a href="ch12_05.htm">Example 12-6</a>, to walk the
chain of prototype objects (called the <em class="emphasis">prototype
chain</em><a name="INDEX-1557" />). <a href="ch12_05.htm">Example 12-9</a> shows the
technique.</p>


<a name="ch12-63444" /><div class="example">
<h4 class="objtitle">Example 12-9.  Walking the Prototype Chain </h4>

<blockquote><pre class="code">// This function checks if <em class="replaceable">theObj</em> is a descendant of <em class="replaceable">theClass</em>
function objectInClass(theObj, theClass) {
  while (theObj.__proto_  _ != null) {
    if (theObj.__proto_  _ == theClass.prototype) {
      return true;
    }
    theObj = theObj.__proto_  _;
  }
  return false;
}

// Make a new instance of <em class="replaceable">Rectangle</em>
myObj = new Rectangle( );

// Now check if <em class="replaceable">myRect</em> inherits from <em class="replaceable">Shape</em>
trace (objectInClass(myRect, Shape)); // Displays: true</pre></blockquote>
</div>
</div>



<a name="ch12-16522" /><div class="sect3">
<h3 class="sect3">12.5.4.4. The end of the inheritance chain</h3>


<p>All <a name="INDEX-1558" />objects descend from the
top-level <em class="filename">Object</em> class. Hence, all objects
inherit the properties defined in the <em class="filename">Object</em>
constructor -- namely the <em class="filename">toString( )</em> and
<em class="filename">valueOf( )</em> methods. We can, therefore, add new
properties to <em class="emphasis">every</em> object in a movie by adding
new properties to the <em class="filename">Object</em> class. Properties
attached to <tt class="literal">Object.prototype</tt> will proliferate
throughout the entire class hierarchy, including all internal objects
and even <em class="filename">movieclip</em> objects! This approach can
generate a type of truly global <a name="INDEX-1559" /> <a name="INDEX-1560" />
<a name="INDEX-1561" />variable
or method. In the following code, for example, we hardcode a stage
width and height dimension into the <em class="filename">Object</em> class
<tt class="literal">prototype</tt>. We can then access that information
from any movie clip:</p>


<blockquote><pre class="code">Object.prototype.mainstageWidth = 550;
Object.prototype.mainstageHeight = 400;
trace(anyClip.mainstageWidth);  // Displays: 550</pre></blockquote>


<p><tt class="literal">Object.prototype</tt> properties are inherited not only
by movie clips but by every object, so even our own custom objects
and instances of other built-in classes such as
<em class="filename">Date</em> and <em class="filename">Sound</em> will inherit
properties assigned to <tt class="literal">Object.prototype</tt>.</p>


<p>Reader Exercise: We can attach new properties and methods to any
built-in class. Try adding the case-insensitive alphabetical sort
function from <a href="ch11_09.htm">Example 11-6</a> to the
<em class="filename">Array</em> class as an inherited method.</p>
</div>



<a name="ch12-28-fm2xml" /><div class="sect3">
<h3 class="sect3">12.5.4.5. Comparing Java terminology</h3>


<p>In <a name="INDEX-1562" />
<a name="INDEX-1563" />our survey of classes
and class hierarchies, we've come across properties defined on
objects, class constructors, and class prototypes. In Java and C++,
there are specific names for the various types of class and object
properties. For the benefit of Java programmers, <a href="ch12_05.htm">Table 12-1</a> outlines the rough equivalencies between Java
and ActionScript.</p>


<a name="ch12-51765" /><h4 class="objtitle">Table 12-1. Java and ActionScript Property Equivalencies </h4><table border="1">





<tr>
<th>
<p>Java</p></th>
<th>
<p>Description</p></th>
<th>
<p>ActionScript</p></th>
<th>
<p>ActionScript Example</p></th>
</tr>




<tr>
<td>
<p><a name="INDEX-1564" />Instance variables</p></td>
<td>
<p>Variables local to an object instance</p></td>
<td>
<p>Properties defined in a class constructor function and copied to
objects</p></td>
<td>
<blockquote><pre class="code">function Square (side) {
  this.side = side;
}</pre></blockquote></td>
</tr>

<tr>
<td>
<p><a name="INDEX-1565" />Instance methods</p></td>
<td>
<p>Methods invoked on an object instance</p></td>
<td>
<p>Methods defined on the <tt class="literal">prototype</tt> object of a class
constructor function, and accessed automatically through
<tt class="literal">prototype</tt> when invoked on an instance</p></td>
<td>
<blockquote><pre class="code">Square.prototype.area = squareArea;

mySquare.area( );</pre></blockquote></td>
</tr>

<tr>
<td>
<p><a name="INDEX-1566" />Class variables</p></td>
<td>
<p>Variables with the same value across all object instances of a class</p></td>
<td>
<p>Properties defined as function properties on a class constructor
function</p></td>
<td>
<blockquote><pre class="code">Square.numSides = 4;</pre></blockquote></td>
</tr>

<tr>
<td>
<p><a name="INDEX-1567" />Class methods</p></td>
<td>
<p>Methods invoked through a class</p></td>
<td>
<p>Methods defined as function properties on a class constructor function</p></td>
<td>
<blockquote><pre class="code">Square.findSmaller = <a name="INDEX-1568" />
<a name="INDEX-1569" />function (square1, square2) { ... }<a name="INDEX-1570" />
<a name="INDEX-1571" /></pre></blockquote></td>
</tr>


</table>
</div>
</div>




<a name="ch12-29-fm2xml" /><div class="sect2">
<h3 class="sect2">12.5.5. Object-Oriented Programming Summary</h3>


<p>Classes <a name="INDEX-1572" />and
inheritance open up a world of potential for sharing common
information among many objects. Object-oriented programming is the
basis of all ActionScript. Whether or not you use every aspect of
classes and objects in your scripts, understanding the general
concepts involved is an essential part of understanding the Flash
programming environment. As we'll see in the last section of
this chapter, our confidence with object-oriented programming greatly
influences our confidence with ActionScript in general.</p>


<p>For <a name="INDEX-1573" />further advanced reading on
object-oriented programming with ECMA-262-derived languages, see
Netscape's documentation for JavaScript, <em class="emphasis">Details of
the Object Model</em>:</p>


<blockquote class="simplelist">

<p><a href="../../../../../../developer.netscape.com/docs/manuals/js/core/jsguide/obj2.htm">http://developer.netscape.com/docs/manuals/js/core/jsguide/obj2.htm</a></p>

</blockquote>


<p>David Flanagan's canonical text, <em class="emphasis">JavaScript: The
Definitive Guide</em> (O'Reilly &amp; Associates, Inc.)
also provides valuable information on OOP in JavaScript. For a
general introduction to OOP from a Java perspective, see <a name="INDEX-1574" /> <a name="INDEX-1575" />Sun's
<em class="emphasis">Object Oriented Programming Concepts</em> (from The
Java<sup class="superscript">tm</sup> Tutorial):</p>


<blockquote class="simplelist">

<p><a href="../../../../../../java.sun.com/docs/books/tutorial/java/concepts">http://java.sun.com/docs/books/tutorial/java/concepts</a></p>

</blockquote>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch12_04.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch12_06.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">12.4. Methods</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">12.6. Built-in ActionScript Classes and Objects </td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="0,1,78,93" shape="rect" /><area href="../wdesign/index.htm" coords="80,2,155,96" shape="rect" /><area href="../xhtml/index.htm" coords="158,0,263,97" shape="rect" /><area href="../audio/index.htm" coords="265,1,335,97" shape="rect" /><area href="../css/index.htm" coords="338,1,434,93" shape="rect" /><area href="index.htm" coords="439,0,540,102" shape="rect" /><area href="../infoarch/index.htm" coords="544,0,685,102" shape="rect" /></map>

</body></html>
