<html><head><title>Positioning (Cascading Style Sheets: The Definitive Guide)</title><link rel="stylesheet" type="text/css" href="style/style.css" />

<meta name="DC.Creator" content="Eric A. Meyer" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="1565926226L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Cascading Style Sheets: The Definitive Guide" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Cascading Style Sheets: The Definitive Guide" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch08_05.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm">Cascading Style Sheets: The Definitive Guide</a></td><td align="right" valign="top" width="228"><a href="ch09_02.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>
<hr width="684" align="left" />



<h1 class="chapter">Chapter 9. Positioning</h1>
<div class="htmltoc"><h4 class="tochead">Contents:</h4><p>
<a href="ch09_01.htm">General Concepts</a><br />
<a href="ch09_02.htm">Relative Positioning</a><br />
<a href="ch09_03.htm">Absolute Positioning</a><br />
<a href="ch09_04.htm">Fixed Positioning</a><br />
<a href="ch09_05.htm">Stacking Positioned Elements</a><br />
<a href="ch09_06.htm">Summary</a><br /></p></div>

<p><a name="INDEX-1027" />The
idea behind positioning is fairly simple. It allows you to define
exactly where element boxes will appear relative to where they would
ordinarily be -- or relative to a parent element, or another
element, or even to the browser window itself. The power of this
feature is both obvious and surprising. It shouldn't be too
surprising to learn that this is the part of CSS2 that user agents
usually first attempt to support. Given that there were some very
good positioning implementations on the horizon as the book was being
completed, we felt it worthwhile to give readers a glimpse of
what's coming soon -- or, if you're reading this book
a year or three after its publication, what can be done.
</p>

<p>You may notice that, unlike other chapters, almost none of the
figures in this chapter was generated with a web browser. This is
something of a statement about the reliability and consistency of
positioning implementations at the time of this writing: not one of
them was solid enough to trust completely. It was actually easier to
draw theoretical examples by hand than to take screenshots in web
browsers and then retouch them in Photoshop.
</p>

<p>This is also why this chapter is largely (but not entirely) free of
browser warnings and caveats. Rather than drown the explanatory text
in side notes, we have chosen to simply describe positioning as it is
given by the CSS2 specification and leave things there. Perhaps the
second edition of this book will contain more practical advice, but
at this time, the only practical advice we can give is this: test
your positioning code thoroughly, and be prepared for inconsistencies
between positioning implementations.
</p>

<div class="sect1"><a name="css-CHP-9-SECT-1" />
<h2 class="sect1">9.1. General Concepts</h2>

<p>Before delving into the specific mechanisms of positioning, we need
to establish a number of concepts. These concepts actually form the
foundation of CSS layout in general since every displayed element can
be described in terms of its positioning. After all, any element that
is placed onscreen, or printed on a piece of paper, has a position
and must therefore be positioned -- by the user agent, if nothing
else.
</p>

<p>The <em class="emphasis">containing
block</em><a name="INDEX-1028" /> is the context in which formatting takes
place. For example, the containing block of a boldface element could
be the paragraph in which it occurs, as demonstrated in <a href="ch09_01.htm">Figure 9-1</a>.
</p>

<a name="css-CHP-9-FIG-1" /><div class="figure"><img height="138" alt="Figure 9-1" src="figs/css.0901.gif" width="246" /></div><h4 class="objtitle">Figure 9-1. An example of a containing block</h4>

<p>Not every element in CSS generates a containing block for its
descendant elements. The rules for the establishment of a containing
block are as follows:
</p>

<ol><li>
<p>The containing block of the "root element" (also called
the <em class="filename">initial containing
block</em><a name="INDEX-1029" />) is established by the user agent. In
HTML, the root element is the <tt class="literal">HTML</tt> element,
although some browsers may incorrectly use <tt class="literal">BODY</tt>.
</p>
</li><li>
<p>For nonroot elements that are not absolutely positioned, the
containing block for an element is set as the content edge of the
nearest block-level ancestor. This is true even in relative
positioning, although it might not seem so at first.
</p>
</li><li>
<p>For nonroot elements that are absolutely positioned using a
<tt class="literal">position</tt> of <tt class="literal">absolute</tt>, the
containing block is set to the nearest ancestor (of any kind) that
has a <tt class="literal">position</tt> other than
<tt class="literal">static</tt>. This happens as follows:
</p>
<ol><li>
<p>If the ancestor is block-level, the containing block is set to be
that element's padding edge; in other words, the area that
would be bounded by a border.
</p>
</li>
<li>
<p>If the ancestor is inline-level, the containing block is set to the
content edge of the ancestor. In left-to-right languages, the top and
left of the containing block are the top and left content edges of
the first box in the ancestor, and the bottom and right edges are the
bottom and right content edges of the last box. In right-to-left
languages, the right edge of the containing block corresponds to the
right content edge of the first box, and the left is taken from the
last box. The top and bottom are the same.
</p>
</li></ol>
<p>If there is no such ancestor, then the content edge of the root
element is used to establish a containing block.
</p>
</li></ol>
<p>The main thing to remember about the containing block is that it
establishes a formatting context for all of its descendant elements.
For example, if margins are declared as percentages, the percentages
are calculated with respect to the containing block. This gives us
rule #2, which says that the containing block is usually equivalent
to the content area of an element.
</p>

<p>Another important thing about the containing block is this: elements
can be positioned outside of their containing block. This is very
similar to the way in which floated elements can use negative margins
to float outside of their parent's content area. It also makes
it seem like the term "containing block" should really be
"positioning context," but since the specification uses
"containing block," so will this text. (We do try to
minimize confusion. Really!)
</p>

<a name="css-CHP-9-SECT-1.1" /><div class="sect2">
<h3 class="sect2">9.1.1. Positioning Schemes</h3>

<p><a name="INDEX-1030" />You can
choose one of four different types of positioning by using the
<tt class="literal">position</tt><a name="INDEX-1031" /> property.
</p>

<a name="css-CHP-9-SIDEBAR-1" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">position</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p><tt class="literal">static</tt> | <tt class="literal">relative</tt> |
<tt class="literal">absolute</tt> | <tt class="literal">fixed</tt> |
<tt class="literal">inherit</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">static</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>all elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>
</td></tr></table></blockquote>

<p>The values of <tt class="literal">position</tt> have the following meanings:</p>

<dl>
<dt><b><tt class="literal">static</tt></b></dt>
<dd>
<p>The element's box is generated as normal. Block-level elements
generate a rectangular box that is part of the document's flow,
and inline-level boxes are generated in the context of one or more
line boxes that are flowed within their parent element.
</p>
</dd>

<dt><b><tt class="literal">relative</tt></b></dt>
<dd>
<p>The element's box is offset by some distance. Its containing
block is the area that the element would occupy if it were not
positioned. The element retains the shape it would have had were it
not positioned, and the space that the element would ordinarily have
occupied is preserved. Relative positioning is accomplished by
generating the element as though it were set to
<tt class="literal">static</tt>, and then simply shifting the
element's box (or boxes, in the case of an inline element that
crosses multiple lines). It is possible that the positioned element
will overlap other content. The direction and magnitude of the offset
are specified using some combination of the properties
<tt class="literal">top</tt>, <tt class="literal">right</tt>,
<tt class="literal">bottom</tt>, and <tt class="literal">left</tt>.
</p>
</dd>

<dt><b><tt class="literal">absolute</tt></b></dt>
<dd>
<p>The element's box is completely removed from the flow of the
document and positioned with respect to its containing block.
Whatever space the element might have occupied in the normal document
flow is closed up, as though the element did not exist. The size and
position of the element are defined by a combination of the
properties <tt class="literal">height</tt>, <tt class="literal">width</tt>,
<tt class="literal">top</tt>, <tt class="literal">right</tt>,
<tt class="literal">bottom</tt>, and <tt class="literal">left</tt>, plus any
margins, padding, and borders set for the element. Absolutely
positioned elements can have margins, but these margins do not
collapse.
</p>
</dd>

<dt><b><tt class="literal">fixed</tt></b></dt>
<dd>
<p>The element's box is positioned as though it were set to
<tt class="literal">absolute</tt>, but its containing block is the viewport
itself. In screen media such as web browsers, the element will not
move within the browser window when the document is scrolled. This
allows for frame-style layouts, for example. In paged media such as
printouts, a fixed element will appear in the same place on every
page. This potentially can be used to create running heads or
footers.
</p>
</dd>

<dt><b><tt class="literal">inherit</tt></b></dt>
<dd>
<p>The value is inherited from the parent element. See <a href="ch10_01.htm">Chapter 10, "CSS2: A Look Ahead"</a>, for more details.
</p>
</dd>

</dl>

</div>
<a name="css-CHP-9-SECT-1.2" /><div class="sect2">
<h3 class="sect2">9.1.2. Side Offsets</h3>

<p><a name="INDEX-1032" /> <a name="INDEX-1033" />Three of the positioning schemes
described in the previous section -- <tt class="literal">relative</tt>,
<tt class="literal">absolute</tt>, and <tt class="literal">fixed</tt> -- use
four distinct properties to describe the offset of a positioned
element's sides with respect to its containing block. These
four properties, which we will refer to as the
<em class="emphasis">side-offset</em><em class="filename"> </em>properties, are
a big part of what makes positioning work.
</p>

<a name="css-CHP-9-SIDEBAR-2" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle"> top, right, bottom, left</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p>&lt;length&gt; | &lt;percentage&gt; |
<tt class="literal">static-position</tt> | <tt class="literal">auto</tt> |
<tt class="literal">inherit</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">auto</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>positioned elements (that is, elements for which the value of
<tt class="literal">position</tt> is something other than
<tt class="literal">static</tt>)
</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>

<a name="ch09-7-fm2xml" /><blockquote><h4>WARNING</h4>
<p>Percentages refer to the width of the containing block
(<tt class="literal">right</tt>, <tt class="literal">left</tt>) or the height of
the containing block (<tt class="literal">top</tt>, <tt class="literal">bottom</tt>
).
</p>
</blockquote>
</td></tr></table></blockquote>

<p>These properties describe an offset from the nearest side of the
containing block (thus the term <em class="filename">side-offset </em>).
For example, <tt class="literal">top</tt><a name="INDEX-1034" /> <a name="INDEX-1035" /> describes how far the outer top edge
of the positioned element should be placed from the top of its
containing block. In the case of <tt class="literal">top</tt>, positive
values move the top edge of the positioned element
<em class="emphasis">downward</em>, while negative values move it
<em class="emphasis">above</em> the top of its containing block.
Similarly, <tt class="literal">left</tt><a name="INDEX-1036" /> <a name="INDEX-1037" /> describes how far to the right (for
positive values) or left (for negative values) the outer left edge of
the positioned element is from the left edge of its containing block.
Another way to look at it is that positive values cause inward
offsets, moving the edges toward the center of the containing block,
and negative values cause outward offsets.
</p>

<a name="ch09-8-fm2xml" /><blockquote><h4>TIP</h4>
<p>The description of offsetting the outer edges is based on an erratum.
The original <a name="INDEX-1038" />CSS2 specification actually
says that the content edges are offset, but it has been widely agreed
that this is a serious error, and in fact, readings of other parts of
the specification show that it is the outer edges that are offset.
</p>
</blockquote>

<p>The implication of offsetting the outer edges of a positioned element
is that everything about an element -- margins, borders, padding,
and content -- is moved in the process of positioning the element.
In other words, it is possible to set margins, borders, and padding
for a positioned element. These will be preserved and kept with the
positioned element, and will be contained within the area defined by
the side-offset properties.
</p>

<p>There are two other side-offset property values that should be
mentioned here. The first, <tt class="literal">static-position</tt>, causes
the user agent to place the given side of a positioned element where
it would have been if the element had not been positioned. For
example, consider a nonpositioned element whose top edge is 3 ems
from the top of its containing block. If the element is then
positioned and given a <tt class="literal">top</tt> of
<tt class="literal">static-position</tt>, then the top of the positioned
element will be 3 ems from the top of the containing block. Later in
the chapter, we'll see how this can be useful.
</p>

<p>The other value, <tt class="literal">auto</tt>, allows for some even more
interesting effects. It acts much the same as setting
<tt class="literal">auto</tt> on margins, but in positioning, this can
permit the creation of elements that are only as wide or tall as they
need to be in order to display their content, without having to
exactly specify how high or wide that will be. We'll explore
this in detail later in the chapter as well.
</p>

<p>It is important to remember that the side-offset properties define
offset from the analogous side (e.g., <tt class="literal">left</tt> defines
the offset from the left side) of the containing block, not from the
upper-left corner of the containing block. That's why, for
example, one way to fill up the lower-right corner of a containing
block would use these values:
</p>

<blockquote><pre class="code">top: 50%; bottom: 0; left: 50%; right: 0;</pre></blockquote>

<p>In this example, the outer left edge of the positioned element is
placed halfway across the containing block. This is its offset from
the left edge of the containing block. The outer right edge of the
positioned element, however, is not offset from the right edge of the
containing block, so the two are coincident. Similar reasoning holds
true for the top and bottom of the positioned element: the outer top
edge is placed halfway down the containing block, but the outer
bottom edge is not moved up from the bottom. This leads to
what's shown in <a href="ch09_01.htm">Figure 9-2</a>.
</p>

<a name="ch09-9-fm2xml" /><blockquote><h4>TIP</h4>
<p>What's depicted in <a href="ch09_01.htm">Figure 9-2</a>, and in most of
the examples in this chapter, will only work if the containing block
was established by an element with an explicitly defined height. This
is because a line in the specification says that if the height of the
containing block is not explicitly specified -- say, for example,
that it's dependent on the content of the element, as in a
normal paragraph -- then both <tt class="literal">top</tt> and
<tt class="literal">bottom</tt> for any positioned element within that
containing block are treated as <tt class="literal">auto</tt>.
</p>


<p>In addition, even though they don't explicitly say so, the
examples in this section (and the next few sections) are all based
around absolute positioning. Since absolute positioning is the
simplest scheme in which to demonstrate how <tt class="literal">top</tt>,
<tt class="literal">right</tt>, <tt class="literal">bottom</tt>, and
<tt class="literal">left</tt> work, we'll stick to that for now.
</p>
</blockquote>

<a name="css-CHP-9-FIG-2" /><div class="figure"><img height="200" alt="Figure 9-2" src="figs/css.0902.gif" width="300" /></div><h4 class="objtitle">Figure 9-2. Positioning an element within its containing block</h4>

<p>Note that the positioned element has padding, a double border, and a
slightly different background color. In <a href="ch09_01.htm">Figure 9-2</a>,
it has no margins, but if it did, they would create blank space
between the borders and the offset edges. This would make the
positioned element appear as though it did not completely fill the
lower-right quarter of the containing block. In truth, it would do
so, but this would not be immediately apparent to the eye. In other
words, the following two sets of styles would have the same visual
appearance, assuming the containing block to be 100 ems high by 100
ems wide:
</p>

<blockquote><pre class="code">top: 50%; bottom: 0; left: 50%; right: 0; margin: 10em;
top: 60%; bottom: 10%; left: 60%; right: 10%; margin: 0;</pre></blockquote>

<p>Again, the similarity would be only visual in nature.</p>

<p>By using negative values, it is possible to position an element
outside its <a name="INDEX-1039" />containing block. For example, the
following values will lead to the result shown in <a href="ch09_01.htm">Figure 9-3</a>:
</p>

<blockquote><pre class="code">top: -5em; bottom: 50%; left: 75%; right: -3em;</pre></blockquote>

<a name="css-CHP-9-FIG-3" /><div class="figure"><img height="252" alt="Figure 9-3" src="figs/css.0903.gif" width="331" /></div><h4 class="objtitle">Figure 9-3. Positioning an element beyond its containing block</h4>

<p>Now let's see why leaving out <tt class="literal">width</tt> and
<tt class="literal">height</tt> isn't always a bad thing in
positioning, as well as how declaring them can work to your
advantage.<a name="INDEX-1040" />
</p>

</div>
<a name="css-CHP-9-SECT-1.3" /><div class="sect2">
<h3 class="sect2">9.1.3. Width and Height</h3>

<p><a name="INDEX-1041" /> <a name="INDEX-1042" />There <a name="INDEX-1043" />will be many cases when, having determined
where you're going to position an element, you will want to go
ahead and declare how wide and how high that element should be. In
addition, there will likely be conditions where you'll want to
limit how high or wide a positioned element gets, not to mention
cases where you want the browser to go ahead and automatically
calculate the width, or the height, or both.
</p>

<a name="css-CHP-9-SECT-1.3.1" /><div class="sect3">
<h3 class="sect3">9.1.3.1. Setting width and height</h3>

<p>If you want to give your positioned element a specific width, then
the obvious property to turn to is
<tt class="literal">width</tt><a name="INDEX-1044" />. Similarly,
<tt class="literal">height</tt><a name="INDEX-1045" /> will let you declare a specific height
for a positioned element.
</p>

<a name="css-CHP-9-SIDEBAR-3" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">width</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p>&lt;length&gt; | &lt;percentage&gt; | <tt class="literal">auto</tt></p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">auto</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>block-level and replaced elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>

<a name="ch09-14-fm2xml" /><blockquote><h4>WARNING</h4>
<p>Percentage values refer to the width of the containing block.</p>
</blockquote>
</td></tr></table></blockquote>

<a name="css-CHP-9-SIDEBAR-4" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">height</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p>&lt;length&gt; | <tt class="literal">auto</tt></p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">auto</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>block-level and replaced elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>
</td></tr></table></blockquote>

<p>Although it is sometimes important to set the width and height of an
element, this is not always necessary when positioning elements. For
example, if the placement of the four sides of the element is
described using <tt class="literal">top</tt>, <tt class="literal">right</tt>,
<tt class="literal">bottom</tt>, and <tt class="literal">left</tt>, then the
height and width of the element are determined by the placement of
the sides. Assume that you want an element to fill the left half of
its containing block, from top to bottom. You could use these styles,
with the result depicted in <a href="ch09_01.htm">Figure 9-4</a>:
</p>

<blockquote><pre class="code">top: 0; bottom: 0; left: 0; right: 50%;</pre></blockquote>

<a name="css-CHP-9-FIG-4" /><div class="figure"><img height="200" alt="Figure 9-4" src="figs/css.0904.gif" width="300" /></div><h4 class="objtitle">Figure 9-4. Filling the left half of the containing block</h4>

<p>Since the default value of both <tt class="literal">width</tt> and
<tt class="literal">height</tt> is <tt class="literal">auto</tt>, the result
shown in <a href="ch09_01.htm">Figure 9-4</a> is exactly the same as if you
had used these styles:
</p>

<blockquote><pre class="code">top: 0; bottom: 0; left: 0; right: 50%; width: auto; height: auto;</pre></blockquote>

<p>Now let's say you want to position an element that is in the
upper-right corner of its containing block and is one-third as wide
as its containing block, but only as tall as necessary to display its
content, as shown in <a href="ch09_01.htm">Figure 9-5</a>.
</p>

<a name="css-CHP-9-FIG-5" /><div class="figure"><img height="200" alt="Figure 9-5" src="figs/css.0905.gif" width="300" /></div><h4 class="objtitle">Figure 9-5. "Shrink-wrapping" a positioned element</h4>

<p>This is where <tt class="literal">auto</tt> really comes into its own. The
styles needed to get the result shown in <a href="ch09_01.htm">Figure 9-5</a>
is:
</p>

<blockquote><pre class="code">top: 0; bottom: auto; left: auto; right: 0; width: 33%; height: auto;</pre></blockquote>

<p>Because <tt class="literal">top</tt> is set to <tt class="literal">0</tt>, and
<tt class="literal">bottom</tt> and <tt class="literal">height</tt> are set to
<tt class="literal">auto</tt>, the user agent is free to size the element
so that it's just tall enough to display its own content, and
no taller. This happens thanks to the revised rules for calculating
the height and width of absolutely positioned elements, which were
published in an errata to the original specification.
</p>

<p>Note that the fact that we set an explicit width helped matters.
Since the user agent knew how wide the element should be, it was a
trivial matter to calculate the height of the element based on its
content. If width has also been set to <tt class="literal">auto</tt>, then
the user agent would have had to assign some value to it. This value
is likely to vary by user agent, so it's usually better to
declare a width that you like.
</p>

<p>Of course, this is not always the case: you could set an explicit
height and let the width scale to fit the content. Thus:
</p>

<blockquote><pre class="code">top: 0; bottom: auto; left: auto; right: 0; width: auto; height: 10em;</pre></blockquote>

<p>Here the element will be 10 ems tall no matter what, but its width
can vary to exactly fit the content. This is sometimes called
<a name="INDEX-1046" />"shrink-wrapping" the
content, since it mimics the act of applying shrink-wrap to a box or
other product. In the same way the plastic shrink-wrap precisely hugs
the contents of the package, so too does a positioned
element -- given the right styles, of course.
</p>

<p>If <tt class="literal">bottom</tt> is set to an actual
value -- percentage or length -- then the height of the
positioned element is constrained. As a demonstration, let's
set <tt class="literal">bottom</tt> to be a specific value, with the result
shown in <a href="ch09_01.htm">Figure 9-6</a>:
</p>

<blockquote><pre class="code">top: 0; bottom: 10%; left: auto; right: 0; width: 33%; height: auto;</pre></blockquote>

<a name="css-CHP-9-FIG-6" /><div class="figure"><img height="200" alt="Figure 9-6" src="figs/css.0906.gif" width="300" /></div><h4 class="objtitle">Figure 9-6. Defining a height by using an explicit bottom</h4>

<p>In this case, the <tt class="literal">height</tt> of the element must be
90% the height of the containing block, since 100% -
- 10% = 90%. This assumes, of course, that there have been no
margins, borders, or padding set for the positioned element;
otherwise, the effective <tt class="literal">height</tt> would be
decreased, although the entire element (content, padding, borders,
and margins) would still be 90% as tall as the containing block.
</p>

<p>Similarly, if we specifically declare a height but leave
<tt class="literal">bottom</tt> as <tt class="literal">auto</tt>, then something
like <a href="ch09_01.htm">Figure 9-7</a> will occur:
</p>

<blockquote><pre class="code">top: 0; bottom: auto; left: auto; right: 0; width: 33%; height: 45%;</pre></blockquote>

<a name="css-CHP-9-FIG-7" /><div class="figure"><img height="200" alt="Figure 9-7" src="figs/css.0907.gif" width="300" /></div><h4 class="objtitle">Figure 9-7. Defining a height by using an explicit height</h4>

<p>In this case, the placement of the bottom of the positioned element
is the same as if we'd declared <tt class="literal">bottom:</tt>
<tt class="literal">55%</tt>, because 100% -
- 45% = 55%.
</p>

<p>Many of the same principles hold true for widths, of course. For
example:
</p>

<blockquote><pre class="code">top: 100px; bottom: 200px; left: 30%; right: 10%; height: auto; width: auto;</pre></blockquote>

<p>Here, the width of the element is effectively 60% the width of its
containing block.
</p>

<p>As wonderful as all of this is, there arises a serious question.
Suppose you have a positioned element that you don't want to be
any smaller than a certain size? Consider the following styles:
</p>

<blockquote><pre class="code">top: 10%; bottom: 20%; left: 50%; right: 10%;</pre></blockquote>

<p>Thus the height is 70%, and the width 40% of the containing
block's height and width. That's fine as far as it
goes -- but what happens if the containing block is only 50 pixels
tall by 200 pixels wide? That gives you an element only 35 pixels
wide by 80 pixels tall. That doesn't leave much room to show
the content, but if you use <tt class="literal">auto</tt> for the width or
height, the element might fill its entire containing block, obscuring
the containing block's contents.
</p>

<p>As we'll see later in the chapter, you have the option to force
your content to overflow the element. For now, however, let's
concentrate on ways to deal with its width and height. You could try
explicitly assigning a width and height, like this:
</p>

<blockquote><pre class="code">top: 10%; bottom: 20%; left: 50%; right: 10%; width: 30em; height: 15em;</pre></blockquote>

<p>However, this approach seems a little heavy-handed, and could have
disastrous consequences in small browsing environments like handheld
devices. Furthermore, it forces you to declare a specific height and
width, which gives up a lot of flexibility. Wouldn't it be
better to define certain limits for the size of the height and width?
</p>

</div>

<a name="css-CHP-9-SECT-1.3.2" /><div class="sect3">
<h3 class="sect3">9.1.3.2. Limiting width and height</h3>

<p><a name="INDEX-1047" /> <a name="INDEX-1048" /> <a name="INDEX-1049" />Should it become necessary or
desirable, you can place limits on an element's width and
height by using the following CSS2 properties, which I'll refer
to as the <em class="emphasis">min-max properties</em>.
</p>

<a name="css-CHP-9-SIDEBAR-5" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">min-width</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p>&lt;length&gt; | &lt;percentage&gt; | <tt class="literal">inherit</tt></p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p>UA specific</p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>all elements except nonreplaced inline elements and table elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>

<a name="ch09-18-fm2xml" /><blockquote><h4>WARNING</h4>
<p><a name="INDEX-1050" />Percentages refer to the width of the
containing block.
</p>
</blockquote>
</td></tr></table></blockquote>

<a name="css-CHP-9-SIDEBAR-6" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">max-width</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p>&lt;length&gt; | &lt;percentage&gt; | <tt class="literal">none</tt> |
<tt class="literal">inherit</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p>UA specific</p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>all elements except nonreplaced inline elements and table elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>
<a name="ch09-20-fm2xml" /><blockquote><h4>WARNING</h4>
<p><a name="INDEX-1051" />Percentages refer to the width of the
containing block.
</p>
</blockquote>
</td></tr></table></blockquote>

<a name="css-CHP-9-SIDEBAR-7" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">min-height</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p>&lt;length&gt; | &lt;percentage&gt; | <tt class="literal">inherit</tt></p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">0</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>all elements except nonreplaced inline elements and table elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>

<a name="ch09-22-fm2xml" /><blockquote><h4>WARNING</h4>
<p><a name="INDEX-1052" />Percentages refer to the height of the
containing block.
</p>
</blockquote>
</td></tr></table></blockquote>

<a name="css-CHP-9-SIDEBAR-8" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">max-height</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p>&lt;length&gt; | &lt;percentage&gt; | <tt class="literal">none</tt> |
<tt class="literal">inherit</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p>none</p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>all elements except nonreplaced inline elements and table elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>
<a name="ch09-24-fm2xml" /><blockquote><h4>WARNING</h4>
<p><a name="INDEX-1053" />Percentages refer to the height of the
containing block.
</p>
</blockquote>
</td></tr></table></blockquote>

<p>The names of these properties make them fairly self-explanatory. Here
we have one possible solution for the example given in the previous
section:
</p>

<blockquote><pre class="code">top: 10%; bottom: 20%; left: 50%; right: 10%; 
  min-width: 20em; min-height: 30em;</pre></blockquote>

<p>Of course, this still isn't a very good solution, since it
forces the element to be at least <tt class="literal">20em</tt> wide by
<tt class="literal">30em</tt> tall. Here's a better one:
</p>

<blockquote><pre class="code">top: 10%; bottom: auto; left: 50%; right: 10%; height: auto; min-width: 15em;</pre></blockquote>

<p>Here we have a case where the element should be 40% as wide as the
containing block but can never be less than <tt class="literal">15em</tt>
wide. We've also changed the <tt class="literal">bottom</tt> and
<tt class="literal">height</tt> so that they're automatically
determined. This will let the element be as tall as necessary to
display its content, no matter how narrow it gets (never less than
<tt class="literal">15em</tt>, of course!).
</p>

<p>We can turn this around to keep elements from getting too wide or
tall by using <tt class="literal">max-width</tt> and
<tt class="literal">max-height</tt>. Let's consider a situation
where, for some strange reason, we want an element to have
three-quarters the width of its containing block, but to stop getting
wider when it hits 400 pixels. The appropriate styles are:
</p>

<blockquote><pre class="code">left: 0%; right: auto; width: 75%; max-width: 400px;</pre></blockquote>

<p>The great advantage of the min-max properties is that they let you
mix units with relative safety. You can set percentage-based sizes
while setting length-based limits, or vice versa.
</p>

<a name="ch09-25-fm2xml" /><blockquote><h4>TIP</h4>
<p>These min-max properties can be very useful in conjunction with
<a name="INDEX-1054" />
<a name="INDEX-1055" />floated elements as well. For example, you
can allow a floated element's width to be relative to the width
of its parent element (which is its containing block), while also
making sure that the float's width never goes below
<tt class="literal">10em</tt>. The reverse approach is also possible:
</p>

<blockquote><pre class="code">P.aside {float: left; width: 40em; max-width: 40%;}</pre></blockquote>


<p>This will set the float to be <tt class="literal">40em</tt> wide, unless
that would be more than 40% the width of the containing block, in
which case the float will be narrowed.
</p>
</blockquote>

<p>Of course, it's still possible to use these properties to keep
an element from exceeding a certain size, as in this:
</p>

<blockquote><pre class="code">max-height: 30em; max-width: 20em;</pre></blockquote>

<p>The question here, though, is what happens if the content of the
element doesn't all fit into the specified element size. Does
it get cut off at the boundaries, or does it spill outside the
positioned element? That's what the next section<a name="INDEX-1056" /> will<a name="INDEX-1057" /> <a name="INDEX-1058" /> <a name="INDEX-1059" />
explore.<a name="INDEX-1060" /> <a name="INDEX-1061" />
</p>

</div>
</div>
<a name="css-CHP-9-SECT-1.4" /><div class="sect2">
<h3 class="sect2">9.1.4. Content Overflow and Clipping</h3>

<p><a name="INDEX-1062" />
<a name="INDEX-1063" />Should the content
of an element be too much for the element's size, it will be in
danger of overflowing the element itself. There are a few
alternatives in such situations, and CSS lets you select between
them. It will also allow you to define a clipping region to determine
the area of the element outside which these sorts of things become an
issue, as well as give a way to clip off parts of an element.
</p>

<a name="css-CHP-9-SECT-1.4.1" /><div class="sect3">
<h3 class="sect3">9.1.4.1. Overflow</h3>

<p>So let's say that you have, for whatever reason, an element
that has been pinned to a specific size, and the content
doesn't fit. You can take control of the situation with the
<tt class="literal">overflow</tt><a name="INDEX-1064" /> property.
</p>

<a name="css-CHP-9-SIDEBAR-9" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">overflow</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p><tt class="literal">visible</tt> | <tt class="literal">hidden</tt> |
<tt class="literal">scroll</tt> | <tt class="literal">auto</tt> |
<tt class="literal">inherit</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">visible</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>block-level and replaced elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>
</td></tr></table></blockquote>

<p>This property only applies in one (or more) the following cases:</p>

<ul><li>
<p>When an element has negative margins.</p>
</li><li>
<p>When a line box must be wider than its parent's content area,
perhaps due to the existence of an unusually long word, nonwrapped
text such as <tt class="literal">PRE</tt> text, or another circumstance
where line-wrapping cannot occur.
</p>
</li><li>
<p>When a block-level box is wider than its parent's content area.</p>
</li><li>
<p>When an element's box is taller than the height explicitly set
for its parent.
</p>
</li><li>
<p>When an element has been absolutely positioned.</p>
</li></ul>
<p>The default value of <tt class="literal">visible</tt> means that the
content may be visible outside the element's box. Typically,
this would lead to the content simply running outside its own element
box, but not altering the shape of that box. The following styles
would result in <a href="ch09_01.htm">Figure 9-8</a>:
</p>

<blockquote><pre class="code">DIV#sidebar {position: absolute; top: 0; left: 0; width: 25%; height: 7em;
  overflow: visible;}</pre></blockquote>

<a name="css-CHP-9-FIG-8" /><div class="figure"><img height="200" alt="Figure 9-8" src="figs/css.0908.gif" width="300" /></div><h4 class="objtitle">Figure 9-8. Overflowing the content area of an element</h4>

<a name="ch09-30-fm2xml" /><blockquote><h4>TIP</h4>
<p>The specification does not say whether or not visible overflowed
content can overlap the content of other elements, but it is
reasonable to infer that this is possible. Since positioned elements
can overlap other elements, it stands to reason that the content of a
positioned element should be treated no differently.
</p>
</blockquote>

<p>If the <tt class="literal">overflow</tt> is set to
<tt class="literal">scroll</tt>, the element's content is
clipped -- that is, cannot be seen -- but some way is provided
to make the extra content available to the user. In a web browser,
this would mean a scrollbar (or set of them) or another method of
accessing the content without altering the shape of the element
itself. One possibility is depicted in <a href="ch09_01.htm">Figure 9-9</a>,
which could result from the following styles:
</p>

<blockquote><pre class="code">DIV#sidebar {position: absolute; top: 0; left: 0; width: 15%; height: 7em;
  overflow: scroll;}</pre></blockquote>

<a name="css-CHP-9-FIG-9" /><div class="figure"><img height="200" alt="Figure 9-9" src="figs/css.0909.gif" width="300" /></div><h4 class="objtitle">Figure 9-9. Invoking a scrollbar with overflow</h4>

<p>If <tt class="literal">scroll</tt> is used, the <a name="INDEX-1065" />panning mechanisms (e.g., scrollbars)
should always be rendered. To quote the specification, "this
avoids any problems with
<a name="INDEX-1066" />scrollbars
appearing or disappearing in a dynamic environment." Thus, even
if the element has sufficient space to display all of its content,
the scrollbars would still appear. In addition, when printing a page
or otherwise displaying the document in a paged medium, the content
should be displayed as though the value of
<tt class="literal">overflow</tt> were declared to be
<tt class="literal">visible</tt>.
</p>

<p>If the <tt class="literal">overflow</tt> is set to
<tt class="literal">hidden</tt>, the element's content is clipped,
but no mechanism should be provided to make the content accessible to
the user. Consider the following styles:
</p>

<blockquote><pre class="code">DIV#sidebar {position: absolute; top: 0; left: 0; width: 15%; height: 7em;
  overflow: hidden;}</pre></blockquote>

<p>In such an instance, the clipped content would not be accessible to
the user. This would lead to a situation like that illustrated by
<a href="ch09_01.htm">Figure 9-10</a>.
</p>

<a name="css-CHP-9-FIG-10" /><div class="figure"><img height="200" alt="Figure 9-10" src="figs/css.0910.gif" width="300" /></div><h4 class="objtitle">Figure 9-10. Clipping content with overflow</h4>

<p>Finally, there is <tt class="literal">overflow:</tt>
<tt class="literal">auto</tt>. This allows user agents to determine what
behavior to use, although they are encouraged to provide a scrolling
mechanism when necessary. This is a potentially useful way to use
<tt class="literal">overflow</tt>, since user agents could interpret it to
mean "provide scrollbars only when needed." (They may
not, but they certainly could, and probably should.)
</p>

<p>In the simplest case, the clipping region for any positioned element
is the content area of the element itself, as depicted in <a href="ch09_01.htm">Figure 9-10</a>. However, you may wish to change the clipping
area. That's what we'll do in the next section.<a name="INDEX-1067" />
</p>

</div>

<a name="css-CHP-9-SECT-1.4.2" /><div class="sect3">
<h3 class="sect3">9.1.4.2. Overflow clipping</h3>

<p><a name="INDEX-1068" /> <a name="INDEX-1069" />In
situations where the content of an element overflows its element box,
and <tt class="literal">overflow</tt> has been set such that the content
should in fact be clipped, it is possible to alter the shape of the
clipping region by using the property
<tt class="literal">overflow-clip</tt><a name="INDEX-1070" />.
</p>

<a name="css-CHP-9-SIDEBAR-10" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">overflow-clip</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p><tt class="literal">rect(&lt;</tt>top&gt;<tt class="literal">,</tt>
&lt;right&gt;<tt class="literal">,</tt> &lt;bottom&gt;<tt class="literal">,</tt>
&lt;left&gt;<tt class="literal">)</tt> | <tt class="literal">auto</tt> |
<tt class="literal">inherit</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">auto</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>block-level and replaced elements with an <tt class="literal">overflow</tt>
value other than <tt class="literal">visible</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>
</td></tr></table></blockquote>

<p>The default value, <tt class="literal">auto</tt>, means that the clipping
region should have the same size and location as the element's
content area. The other possibility is to define a clipping shape
that is relative to the element's content area. This does not
alter the shape of the content area, but instead alters the area in
which content may be rendered.
</p>

<a name="ch09-33-fm2xml" /><blockquote><h4>TIP</h4>
<p>While the only clipping shape available in CSS2 is a rectangle, the
specification does offer the possibility that other shapes will be
included in future specifications.
</p>
</blockquote>

<p>This is done with the shape value
<tt class="literal">rect(</tt><em class="replaceable">top</em><tt class="literal">,</tt>
<em class="replaceable">right</em><tt class="literal">,</tt>
<em class="replaceable">bottom</em><tt class="literal">,</tt>
<em class="replaceable">left</em><tt class="literal">)</tt>. We could specify
no change in the clipping region like this:
</p>

<blockquote><pre class="code">overflow-clip: rect(0, auto, auto, 0);</pre></blockquote>

<p>This would be no different than declaring
<tt class="literal">overflow-clip:</tt> <tt class="literal">auto</tt>. It's
more interesting to shift the clipping area, of course. For example:
</p>

<blockquote><pre class="code">DIV#sidebar {position: absolute; top: 0; left: 0; width: 5em; height: 7em;
  overflow: hidden; overflow-clip: rect(0.5em, 4em, 6.5em, 1em);}</pre></blockquote>

<p>This sets the clipping area inward half an em from the top and
bottom, and one em from the right and left. This would cause a result
something like that shown in <a href="ch09_01.htm">Figure 9-11</a>, where a
dashed line has been added to illustrate the edges of the clipping
region. This line would not actually appear in a user agent
attempting to render the document.
</p>

<a name="css-CHP-9-FIG-11" /><div class="figure"><img height="200" alt="Figure 9-11" src="figs/css.0911.gif" width="300" /></div><h4 class="objtitle">Figure 9-11. Contracting the clipping region</h4>

<p>The syntax of <tt class="literal">rect</tt> is an interesting case.
Technically, it can be
<tt class="literal">rect(</tt><em class="replaceable">top</em><tt class="literal">,</tt>
<em class="replaceable">right</em><tt class="literal">,</tt>
<em class="replaceable">bottom</em><tt class="literal">,</tt>
<em class="replaceable">left</em><tt class="literal">)</tt> -- note the
<a name="INDEX-1071" />
<a name="INDEX-1072" />commas -- but
the CSS2 specification contains examples both with and without commas
and defines <tt class="literal">rect</tt> as accepting both the comma and
noncomma versions. This text will stick to the comma version mostly
because it makes things easier to read.
</p>

<p>It is extremely important to note that the values for
<tt class="literal">rect(...)</tt> are <em class="emphasis">not</em>
 side-offsets. They are, instead, distances from the
upper-left corner of the element. Thus, a clipping rectangle which
encloses a square 20 pixels by 20 pixels in the upper-left corner of
the element would be defined as:
</p>

<blockquote><pre class="code">rect(0, 20px, 20px, 0)</pre></blockquote>

<p>The only values permitted with <tt class="literal">rect(...)</tt> are
length values and <tt class="literal">auto</tt>, which is the same as
"set the clipping edge to the appropriate content edge."
Thus, the following two statements mean the same thing:
</p>

<blockquote><pre class="code">overflow-clip: rect(auto, auto, 10px, 1cm);
overflow-clip: rect(0, 0, 10px, 1cm);</pre></blockquote>

<p>It is possible to set negative lengths, though, which will expand the
clipping area outside the element's box. If you wanted to push
the clipping area up and left by a quarter-inch, it would be done
with the following styles (illustrated by <a href="ch09_01.htm">Figure 9-12</a>):
</p>

<blockquote><pre class="code">overflow-clip: rect(-0.25in, auto, auto, -0.25in);</pre></blockquote>

<a name="css-CHP-9-FIG-12" /><div class="figure"><img height="213" alt="Figure 9-12" src="figs/css.0912.gif" width="313" /></div><h4 class="objtitle">Figure 9-12. Expanding the clipping area</h4>

<p>This doesn't do much good, as you can see. The clipping
rectangle extends up and to the left, but since there isn't any
content there, the visual effect is the same as if the author had
declared <tt class="literal">overflow-clip:</tt> <tt class="literal">auto</tt>.
</p>

<p>On the other hand, it might be okay to go beyond the bottom and right
edges, but not the top or left. <a href="ch09_01.htm">Figure 9-13</a> shows
the results of these styles (and remember, the dashed lines are only
for illustrative purposes):
</p>

<blockquote><pre class="code">DIV#sidebar {position: absolute; top: 0; left: 0; width: 5em; height: 7em;
overflow: hidden; overflow-clip: rect(0, 6em, 9em, 0);}</pre></blockquote>

<a name="css-CHP-9-FIG-13" /><div class="figure"><img height="200" alt="Figure 9-13" src="figs/css.0913.gif" width="300" /></div><h4 class="objtitle">Figure 9-13. Expanding the clipping region</h4>

<p>This extends the area in which content can be seen. However, it
doesn't change the flow of the content, so the only visual
effect is that more content can be seen below the element. The text
does not flow out to the right, because the width of its line boxes
is still constrained by the width of the positioned element. If there
had been an image wider than the positioned element, or preformatted
text with a long line, this might have been visible to the right of
the positioned element, up to the point where the clipping rectangle
ends.
</p>

<p>The syntax of <tt class="literal">rect(...)</tt> is, as you may have
already realized, rather unfortunate. It is based on an early draft
of the positioning section, which used the top-left-offset scheme.
<a name="INDEX-1073" />Internet Explorer implemented this
before CSS2 was made a full Recommendation, and so came into conflict
with a last-minute change that made <tt class="literal">rect(...)</tt> use
side-offsets, just like the rest of CSS2. This was done, reasonably
enough, because it would make positioning consistent with itself.
</p>

<p>By then, however, it was too late: there was an implementation in the
marketplace, and rather than force Microsoft to change the browser
and thus potentially cause existing pages to break, the standard was
changed to reflect implementation. This means, sadly, that it is
impossible to set a consistent clipping rectangle in situations where
the height and width are not precisely defined. For example, there is
no way to create a clipping rectangle that is 1 em larger than this
element's content area:
</p>

<blockquote><pre class="code">position: absolute; top: 0; bottom: 50%; right: 50%; left: 0;</pre></blockquote>

<p>Since there is no way to know how many ems tall or wide the element
will be, there is no way to make a clipping rectangle that ends 1 em
to the right, or 1 em below, the content area of the element.
</p>

<p>Further compounding the problem is that <tt class="literal">rect(...)</tt>
only accepts length units and <tt class="literal">auto</tt>. The addition
of percentage units as valid <tt class="literal">rect(...)</tt> values
would go a long way toward improving things, and hopefully a future
version of CSS will add this capability.<a name="INDEX-1074" />
</p>

</div>

<a name="css-CHP-9-SECT-1.4.3" /><div class="sect3">
<h3 class="sect3">9.1.4.3. Element clipping</h3>

<p><a name="INDEX-1075" />There is
another way to clip in CSS, but this is very different from what
we've just seen.
</p>

<a name="css-CHP-9-SIDEBAR-11" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">clip</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p><tt class="literal">rect(</tt>&lt;top&gt;<tt class="literal">,</tt>
&lt;right&gt;<tt class="literal">,</tt> &lt;bottom&gt;<tt class="literal">,</tt>
&lt;left&gt;<tt class="literal">)</tt> | <tt class="literal">auto</tt> |
<tt class="literal">inherit</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">auto</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>block-level and replaced elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>
</td></tr></table></blockquote>

<p>This property can be used to clip the element with a simple
intersection operation. The area of the element contained within the
<tt class="literal">clip</tt><a name="INDEX-1076" /> rectangle is displayed, and any part
of it outside that rectangle is not. In addition, the
<tt class="literal">clip</tt> rectangle is set in relation to the outer
edge of the element -- not its content edge. Thus, let's say
you wanted (for whatever reason) to clip the top 10 pixels of an
image:
</p>

<blockquote><pre class="code">&lt;IMG SRC="foo.gif" STYLE="clip: rect(10px, auto, auto, 0);"&gt;</pre></blockquote>

<p>The <tt class="literal">auto</tt> values will set the clipping
rectangle's bottom to align with the bottom of the image, and
the right edge to the right edge of the image. The value of
<tt class="literal">0</tt> for <tt class="literal">left</tt> keeps the left edge
of the clipping rectangle against the left edge of the image, but the
<tt class="literal">10px</tt> for <tt class="literal">top</tt> moves the top edge
of the clipping rectangle downward 10 pixels. This will cause the top
10 pixels of the image to become effectively invisible.
</p>

<p><tt class="literal">clip</tt> can be applied to any element. Thus, you
could display only the top left corner of a paragraph using something
like this:
</p>

<blockquote><pre class="code">&lt;P STYLE="clip: rect(0, 10em, 10em, 0);"&gt;</pre></blockquote>

<p>This will display a square 10 ems wide by 10 ems high. This square is
drawn from the top left outer corner, so any margins, borders, and
padding will influence how much of the element is visible and how
much is clipped out.<a name="INDEX-1077" />
</p>

</div>
</div>
<a name="css-CHP-9-SECT-1.5" /><div class="sect2">
<h3 class="sect2">9.1.5. Element Visibility</h3>

<p><a name="INDEX-1078" />
<a name="INDEX-1079" />In addition to all the clipping and
overflowing, you can also control the visibility of an entire
element.
</p>

<a name="css-CHP-9-SIDEBAR-12" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">visibility</h4>

<dl>
<dt><b>Values</b></dt>
<dd>
<p><tt class="literal">visible</tt> | <tt class="literal">hidden</tt> |
<tt class="literal">collapse</tt> | <tt class="literal">inherit</tt>
</p>
</dd>

</dl>

<dl>
<dt><b>Initial Value</b></dt>
<dd>
<p><tt class="literal">inherit</tt></p>
</dd>

</dl>

<dl>
<dt><b>Applies to</b></dt>
<dd>
<p>all elements</p>
</dd>

</dl>

<dl>
<dt><b>Inherited</b></dt>
<dd>
<p>no</p>
</dd>

</dl>
</td></tr></table></blockquote>

<p>This one is pretty easy. If an element is set to have
<tt class="literal">visibility:</tt><a name="INDEX-1080" /> <tt class="literal">visible</tt>, then it is
visible. Of course.
</p>

<p>However, if an element is set to <tt class="literal">visibility:</tt>
<tt class="literal">hidden</tt>, it is made "invisible" (to use
the wording in the specification). In its invisible state, the
element still affects the document's layout as though it were
visible. In other words, the element is still there: you just
can't see it. Note the difference between this and
<tt class="literal">display:</tt> <tt class="literal">none</tt>. In the latter
case, the element is not displayed and is removed from the document
altogether so that it doesn't have any effect on document
layout. <a href="ch09_01.htm">Figure 9-14</a> shows a document in which an
<tt class="literal">EM</tt> element has been set to be
<tt class="literal">hidden</tt>, based on the following styles and markup:
</p>

<blockquote><pre class="code">EM.trans {visibility: hidden; border: 3px solid gray; background: silver;
  padding: 1em;}

&lt;P&gt;
This is a paragraph which should be visible. Lorem ipsum, dolor sit amet, 
&lt;EM CLASS="trans"&gt;consectetuer adipiscing elit, sed diam nonummy nibh &lt;/EM&gt;
euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
&lt;/P&gt;</pre></blockquote>

<a name="css-CHP-9-FIG-14" /><div class="figure"><img height="107" alt="Figure 9-14" src="figs/css.0914.gif" width="331" /></div><h4 class="objtitle">Figure 9-14. Hiding an element</h4>

<p>Everything visible about an element -- such as content,
background, and borders -- will be made invisible. Note that the
space is still there because the element is still part of the
document's layout. We just can't see it.
</p>

<p>Note too that it's possible to set the descendant element of a
<tt class="literal">hidden</tt> element to be <tt class="literal">visible</tt>.
This would cause the element to appear wherever it normally would,
despite the fact that the ancestor (and possibly the siblings) is
invisible. In order to do so, you would need to explicitly declare
the descendant element to be <tt class="literal">visible</tt>, since
<tt class="literal">visibility</tt> is inherited. Thus:
</p>

<blockquote><pre class="code">P.clear {visibility: hidden;}
P.clear EM {visibility: visible;}</pre></blockquote>

<p>As for <tt class="literal">visbility:</tt> <tt class="literal">collapse</tt>,
this value is used in CSS table rendering, which isn't covered
in this book because it wasn't well implemented as the book was
being written. According to the CSS2 specification,
<tt class="literal">collapse</tt> has the same meaning as
<tt class="literal">hidden</tt> if it is used on nontable elements. From a
semantic standpoint, this seems somewhat confusing (since
<tt class="literal">collapse</tt> sounds like it should trigger the kind of
behavior you'd see with <tt class="literal">display:</tt>
<tt class="literal">none</tt>), but there it is nonetheless.<a name="INDEX-1081" /> <a name="INDEX-1082" />
</p>

</div>
</div>












<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch08_05.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch09_02.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">8.5. Summary</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">9.2. Relative Positioning</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area href="../index.htm" coords="0,1,78,93" shape="rect" /><area href="../wdesign/index.htm" coords="80,2,155,96" shape="rect" /><area href="../xhtml/index.htm" coords="158,0,263,97" shape="rect" /><area href="../audio/index.htm" coords="265,1,335,97" shape="rect" /><area href="index.htm" coords="338,1,434,93" shape="rect" /><area href="../action/index.htm" coords="439,0,540,102" shape="rect" /><area href="../infoarch/index.htm" coords="544,0,685,102" shape="rect" /></map>

</body></html>
