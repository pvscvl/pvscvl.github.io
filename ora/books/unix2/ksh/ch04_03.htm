<html><head>
<title>[Chapter 4] 4.3 String Operators</TITLE>
<meta name="DC.title" content="Learning the Korn Shell"><meta name="DC.creator" content="Bill Rosenblatt"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-03T21:04:52Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-054-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch04_01.htm" webstripperlinkwas="ch04_01.htm" title="4. Basic Shell Programming"><link rel="prev" href="ch04_02.htm" webstripperlinkwas="ch04_02.htm" title="4.2 Shell Variables"><link rel="next" href="ch04_04.htm" webstripperlinkwas="ch04_04.htm" title="4.4 Command Substitution"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="Learning the Korn Shell" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,66" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch04_02.htm" webstripperlinkwas="ch04_02.htm" title="4.2 Shell Variables"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 4.2 Shell Variables" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 4<br>Basic Shell Programming</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch04_04.htm" webstripperlinkwas="ch04_04.htm" title="4.4 Command Substitution"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 4.4 Command Substitution" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="KSH-CH-4-SECT-3">4.3 String Operators</A
></H2
><p class="para"><a class="indexterm" name="AUTOID-5845"></A
><a class="indexterm" name="KSH-CH-4-IX-STRING-OPERATORS"></A
>The curly-bracket syntax allows for the shell's <em class="emphasis">string operators</EM
>.
String operators allow you to manipulate values of
variables in various useful ways without having to write full-blown
programs or resort to external UNIX utilities.
You can do a lot with string-handling operators even if
you haven't yet mastered the programming features
we'll see in later chapters.</P
><p class="para"><a class="indexterm" name="AUTOID-5853"></A
>In particular, string operators let you
do the following:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Ensure that variables exist (i.e., are defined and have non-null values)</P
></LI
><li class="listitem"><p class="para">Set default values for variables</P
></LI
><li class="listitem"><p class="para">Catch errors that result from variables not being set</P
></LI
><li class="listitem"><p class="para">Remove portions of variables' values that match patterns</P
></LI
></UL
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-4-SECT-3.1">4.3.1 Syntax of String Operators</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-4-IX-STRING-OPERATORS-SYNTAX"></A
>The basic idea behind the syntax of string operators
is that special characters that denote operations are inserted
between the variable's name and the right curly brackets.
Any argument that the operator may need is inserted to the operator's right.</P
><p class="para">The first group of string-handling operators tests
for the existence of variables and allows substitutions of
default values under certain conditions.  These 
are listed in 
<a class="xref" href="#KSH-CH-4-TAB-0" title="Substitution Operators">Table 4.1</A
>.
[6]<a class="indexterm" name="AUTOID-5876"></A
><a class="indexterm" name="AUTOID-5879"></A
><a class="indexterm" name="AUTOID-5882"></A
><a class="indexterm" name="AUTOID-5885"></A
><a class="indexterm" name="AUTOID-5888"></A
><a class="indexterm" name="AUTOID-5891"></A
><a class="indexterm" name="AUTOID-5894"></A
><a class="indexterm" name="AUTOID-5897"></A
></P
><blockquote class="footnote"><p class="para">[6] The colon (<code class="literal">:</CODE
>) in each of these operators is actually optional.
If the colon is omitted, then change &quot;exists and isn't null&quot;
to &quot;exists&quot; in each definition, i.e., the
operator tests for existence only. </P
></BLOCKQUOTE
><table class="table"><caption class="table"><a class="title" name="KSH-CH-4-TAB-0">Table 4.1: Substitution Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Operator</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Substitution</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">${</B
><em class="emphasis">varname</EM
><b class="emphasis.bold">:-</B
><em class="emphasis">word</EM
><b class="emphasis.bold">}</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If <em class="emphasis">varname</EM
> exists and isn't null, return its value;
otherwise return <em class="emphasis">word</EM
>.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">Purpose</B
>:</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returning a default value if the variable is undefined.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">Example</B
>:</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><b class="emphasis.bold">${count:-0}</B
> evaluates to 0 if 
<b class="emphasis.bold">count</B
> is undefined.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">${</B
><em class="emphasis">varname</EM
><b class="emphasis.bold">:=</B
><em class="emphasis">word}</EM
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If <em class="emphasis">varname</EM
> exists and isn't null, return its value;
otherwise set it to <em class="emphasis">word</EM
> and then return its value.[7]</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">Purpose</B
>:</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Setting a variable to a default value if it is undefined.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">Example</B
>:</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><code class="literal">$</CODE
><b class="emphasis.bold">{count:=0}</B
> sets <b class="emphasis.bold">count</B
> to 0 if it is undefined.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">${</B
><em class="emphasis">varname</EM
><code class="literal">:?</CODE
><em class="emphasis">message</EM
><b class="emphasis.bold">}</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If <em class="emphasis">varname</EM
> exists and isn't null, return its value;
otherwise print <em class="emphasis">varname</EM
><b class="emphasis.bold">:</B
> followed 
by <em class="emphasis">message</EM
>,
and abort the current command or script.
Omitting <em class="emphasis">message</EM
> produces the default message
<b class="emphasis.bold">parameter null or not set</B
>.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">Purpose</B
>:</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Catching errors that result from variables being undefined.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">Example</B
>:</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><b class="emphasis.bold">{count</B
><code class="literal">:?&quot;</CODE
>
<b class="emphasis.bold">undefined!</B
><code class="literal">&quot;</CODE
>
<b class="emphasis.bold">}</B
> 
 prints <b class="emphasis.bold">&quot;count: undefined!&quot;</B
>
and exits if <b class="emphasis.bold">count</B
> is undefined.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">${</B
><em class="emphasis">varname</EM
><code class="literal">:+</CODE
><em class="emphasis">word</EM
><b class="emphasis.bold">}</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If <em class="emphasis">varname</EM
> exists and isn't null, 
return <em class="emphasis">word</EM
>;
otherwise return null.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">Purpose</B
>:</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Testing for the existence of a variable.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">Example</B
>:</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><b class="emphasis.bold">${count:+1}</B
> returns 1 (which could mean 
&quot;true&quot;) if <b class="emphasis.bold">count</B
> is defined.</P
></TD
></TR
></TBODY
></TABLE
><blockquote class="footnote"><p class="para">[7] <a class="indexterm" name="AUTOID-5943"></A
><a class="indexterm" name="AUTOID-5945"></A
><a class="indexterm" name="AUTOID-5947"></A
>Pascal, Modula, and Ada programmers may find it helpful to recognize the
similarity of this to the assignment operators in those languages.</P
></BLOCKQUOTE
><p class="para">The first two of these operators are ideal for setting defaults for
command-line arguments in case the user omits them.  We'll use
the first one in our first programming task.<a class="indexterm" name="AUTOID-6018"></A
></P
><div class="task"><h4>Task 4.1</H4
><blockquote class="taskinfo"><p class="para">You have a large album collection, and you want to write some
software to keep track of it.  Assume that you have a file of data on
how many albums you have by each artist.  Lines in the file look
like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">14	Bach, J.S.
1	Balachander, S.
21	Beatles
6	Blakey, Art</PRE
></BLOCKQUOTE
></P
><p class="para">Write a program that prints the <em class="emphasis">N</EM
> highest lines, 
i.e., the <em class="emphasis">N</EM
> artists
by whom you have the most albums.  The default for <em class="emphasis">N</EM
> should be 10.
The program should take one argument for the name of the input file
and an optional second argument for how many lines to print.</P
></BLOCKQUOTE
><p class="para">By far the best approach to this type of script is to
use built-in UNIX utilities, combining them with I/O redirectors
and pipes.  This is the classic &quot;building-block&quot; philosophy
of UNIX that is another reason for its great popularity with
programmers.  The building-block technique lets us write a first 
version of the script that is only one line long:<a class="indexterm" name="KSH-CH-4-IX-BACKSLASH-DASH"></A
><a class="indexterm" name="KSH-CH-4-IX-STRING-OPERATORS-COLON"></A
></P
><p class="para"><blockquote class="screen"><pre class="screen">sort -nr $1 | head -${2:-10}</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-6038"></A
><a class="indexterm" name="AUTOID-6040"></A
>Here is how this works:
the <em class="emphasis">sort</EM
>(1) program sorts the data in the file whose name
is given as the first argument (<b class="emphasis.bold">$1</B
>). 
The <b class="emphasis.bold">-n</B
> option tells <em class="emphasis">sort</EM
>
to interpret the first word on each line as a number
(instead of as a character string);
the <b class="emphasis.bold">-r</B
> tells it to reverse the comparisons, so as to sort in
descending order.</P
><p class="para">The output
of <em class="emphasis">sort</EM
> is piped into the <em class="emphasis">head</EM
>(1) utility, which, when
given the argument <b class="emphasis.bold">-</B
><em class="emphasis">N</EM
>, prints the first <em class="emphasis">N</EM
> lines of its input on
the standard output.  The expression <b class="emphasis.bold">-${2:-10}</B
> evaluates to a dash 
(<b class="emphasis.bold">-</B
>)
followed by the second argument if it is given, or to -10 if it's not;
notice that the variable in this expression is <b class="emphasis.bold">2</B
>, which is
the second positional parameter.</P
><p class="para">Assume the script we want to write is called <em class="emphasis">highest</EM
>.  
Then if the user types
<b class="emphasis.bold">highest myfile</B
>, the line that actually runs is:</P
><p class="para"><blockquote class="screen"><pre class="screen">sort -nr myfile | head -10</PRE
></BLOCKQUOTE
></P
><p class="para">Or if the user types <b class="emphasis.bold">highest myfile 22</B
>, the line that runs is:</P
><p class="para"><blockquote class="screen"><pre class="screen">sort -nr myfile | head -22</PRE
></BLOCKQUOTE
></P
><p class="para">Make sure you understand how the <b class="emphasis.bold">:-</B
> string operator provides
a default value.</P
><p class="para">This is a perfectly good, runnable script-but it has a few
problems.  First, its one line is a bit cryptic.  While this
isn't much of a problem for such a tiny script, it's not
wise to write long, elaborate scripts in this manner.  A few minor
changes will make the code more readable.  </P
><p class="para"><a class="indexterm" name="AUTOID-6069"></A
><a class="indexterm" name="AUTOID-6072"></A
><a class="indexterm" name="AUTOID-6074"></A
>First, we can add
comments to the code; anything between # and the end of
a line is a comment.  At a minimum,
the script should start with a few comment lines that indicate
what the script does and what arguments it accepts.  Second, we
can improve the variable names by assigning the values of the
positional parameters to regular variables with mnemonic names.
Finally, we can add blank lines to space things out; blank lines,
like comments, are ignored.  Here is a more readable version:</P
><p class="para"><blockquote class="screen"><pre class="screen">#
#	highest filename [howmany]
#
#	Print howmany highest-numbered lines in file filename.
#	The input file is assumed to have lines that start with
#	numbers.  Default for howmany is 10.
#

filename=$1

howmany=${2:-10}
sort -nr $filename | head -$howmany</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-6080"></A
><a class="indexterm" name="AUTOID-6081"></A
><a class="indexterm" name="AUTOID-6082"></A
>The square brackets around <b class="emphasis.bold">howmany</B
> in the comments
adhere to the convention in UNIX documentation
that square brackets denote optional arguments.</P
><p class="para">The changes we just made improve the code's readability but not how it runs.
What if the user were to invoke the script without any arguments?
Remember that positional parameters default
to null if they aren't defined.  
If there are no arguments, then <b class="emphasis.bold">$1</B
> and <b class="emphasis.bold">$2</B
> are both null.
The variable <b class="emphasis.bold">howmany</B
> (<b class="emphasis.bold">$2</B
>) is set up to default to 10, but there is
no default for <b class="emphasis.bold">filename</B
> (<b class="emphasis.bold">$1</B
>).  
The result would be that this command runs:</P
><p class="para"><blockquote class="screen"><pre class="screen">sort -nr | head -10</PRE
></BLOCKQUOTE
></P
><p class="para">As it happens, if <em class="emphasis">sort</EM
> is called without a filename argument,
it expects input to come from standard input, e.g.,  
a pipe (|) or a user's terminal.  Since it doesn't have the pipe,
it will expect the terminal.  This means that the script will appear to hang!
Although you could always type <kbd class="keycap">[CTRL-D]</KBD
> or 
<kbd class="keycap">[CTRL-C]</KBD
> to get out of the script, a naive
user might not know this.</P
><p class="para"><a class="indexterm" name="KSH-CH-4-IX-BACKSLASH-QUERY"></A
><a class="indexterm" name="KSH-CH-4-IX-STRING-OPERATORS-BSLASH-QUERY"></A
>Therefore we need to make sure that the user supplies at least
one argument.  There are a few ways of doing this; one of them
involves another string operator.  We'll replace the line:</P
><p class="para"><blockquote class="screen"><pre class="screen">filename=$1</PRE
></BLOCKQUOTE
></P
><p class="para">with:</P
><p class="para"><blockquote class="screen"><pre class="screen">filename=${1:?&quot;filename missing.&quot;}</PRE
></BLOCKQUOTE
></P
><p class="para">This will cause two things to happen if a user invokes the
script without any arguments: first the shell will print
the somewhat unfortunate message:</P
><p class="para"><blockquote class="screen"><pre class="screen">highest: 1: filename missing.</PRE
></BLOCKQUOTE
></P
><p class="para">to the standard error output. 
Second, the script will exit without running the remaining code.</P
><p class="para">With a somewhat &quot;kludgy&quot; modification, we can
get a slightly better error message.  Consider this code:</P
><p class="para"><blockquote class="screen"><pre class="screen">filename=$1
filename=${filename:?&quot;missing.&quot;}</PRE
></BLOCKQUOTE
></P
><p class="para">This results in the message:</P
><p class="para"><blockquote class="screen"><pre class="screen">highest: filename: missing.</PRE
></BLOCKQUOTE
></P
><p class="para">(Make sure you understand why.)  Of course, there are ways of printing
whatever message is desired; we'll find out how in <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
>.<a class="indexterm" name="AUTOID-6123"></A
><a class="indexterm" name="AUTOID-6124"></A
></P
><p class="para">Before we move on, we'll look more closely at the two remaining
operators in 
<a class="xref" href="#KSH-CH-4-TAB-0" title="Substitution Operators">Table 4.1</A
>
and see how we can incorporate them into
our task solution.  <a class="indexterm" name="KSH-CH-4-IX-BACKSLASH-EQUALS"></A
><a class="indexterm" name="KSH-CH-4-IX-STRING-OPERATORS-EQUALS"></A
>
The <b class="emphasis.bold">:=</B
> operator does roughly the
same thing as <b class="emphasis.bold">:-</B
>, except that it has the &quot;side effect&quot;
of setting the
value of the variable to the given word if the variable doesn't exist.</P
><p class="para"><a class="indexterm" name="AUTOID-6136"></A
><a class="indexterm" name="AUTOID-6139"></A
>Therefore we would like to use <b class="emphasis.bold">:=</B
> in our script in place of <b class="emphasis.bold">:-</B
>,
but we can't; we'd be trying to set the
value of a positional parameter, which is not allowed.  But
if we replaced:</P
><p class="para"><blockquote class="screen"><pre class="screen">howmany=${2:-10}</PRE
></BLOCKQUOTE
></P
><p class="para">with just:</P
><p class="para"><blockquote class="screen"><pre class="screen">howmany=$2</PRE
></BLOCKQUOTE
></P
><p class="para">and moved the substitution down to the actual command line (as we
did at the start), then we could use the <b class="emphasis.bold">:=</B
> operator:</P
><p class="para"><blockquote class="screen"><pre class="screen">sort -nr $filename | head -${howmany:=10}</PRE
></BLOCKQUOTE
></P
><p class="para">Using <b class="emphasis.bold">:=</B
> has the added benefit of setting the value of <b class="emphasis.bold">howmany</B
>
to 10 in case we need it afterwards in later versions of the script.<a class="indexterm" name="AUTOID-6156"></A
><a class="indexterm" name="AUTOID-6157"></A
></P
><p class="para"><a class="indexterm" name="KSH-CH-4-IX-BACKSLASH-PLUS"></A
><a class="indexterm" name="KSH-CH-4-IX-STRING-OPERATORS-BSLASH-PLUS"></A
>The final substitution operator is <b class="emphasis.bold">:+</B
>.  Here is how we can use it
in our example:  Let's say we want to give the user the option of
adding a header line to the script's output.  If he or she types
the option <b class="emphasis.bold">-h</B
>, then the output will be preceded by the line:</P
><p class="para"><blockquote class="screen"><pre class="screen">ALBUMS  ARTIST</PRE
></BLOCKQUOTE
></P
><p class="para">Assume further that this option ends up in the variable <b class="emphasis.bold">header</B
>,
i.e., <b class="emphasis.bold">$header</B
> is <b class="emphasis.bold">-h</B
> if the option is set or null if not.
(Later we will see how to do this without disturbing the other
positional parameters.)</P
><p class="para">The expression: </P
><p class="para"><blockquote class="screen"><pre class="screen">${header:+&quot;ALBUMS  ARTIST\n&quot;}</PRE
></BLOCKQUOTE
></P
><p class="para">yields null if the variable <b class="emphasis.bold">header</B
> is null,
or <b class="emphasis.bold"><span class="acronym">ALBUMS  ARTIST</SPAN
>\n</B
> if it is non-null.  <a class="indexterm" name="AUTOID-6180"></A
>
This means that we can put the line:</P
><p class="para"><blockquote class="screen"><pre class="screen">print -n ${header:+&quot;ALBUMS  ARTIST\n&quot;}</PRE
></BLOCKQUOTE
></P
><p class="para">right before the command line that does the actual work.   
The <b class="emphasis.bold">-n</B
> option to <b class="emphasis.bold">print</B
>
causes it <em class="emphasis">not</EM
> to print a LINEFEED after printing its
arguments.  Therefore this <b class="emphasis.bold">print</B
> statement will print 
nothing-not even a blank line-if 
<b class="emphasis.bold">header</B
> is null; otherwise it will print the header line
and a LINEFEED (\n).<a class="indexterm" name="AUTOID-6192"></A
><a class="indexterm" name="AUTOID-6193"></A
><a class="indexterm" name="AUTOID-6194"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-4-SECT-3.2">4.3.2 Patterns and Regular Expressions</A
></H3
><p class="para">We'll continue refining our solution to Task 4-1 later in this chapter.
The next type of string operator is used to match portions of a
variable's string value against <em class="emphasis">patterns</EM
>.  
Patterns, as we saw in <a class="xref" href="ch01_01.htm" webstripperlinkwas="ch01_01.htm" title="Korn Shell Basics">Chapter 1</A
> are strings that can contain
wildcard characters (<code class="literal">*</CODE
>, <code class="literal">?</CODE
>, and <b class="emphasis.bold">[]</B
> for character sets and ranges).</P
><p class="para"><a class="indexterm" name="AUTOID-6204"></A
><a class="indexterm" name="AUTOID-6208"></A
>Wildcards have been standard features of all UNIX shells going
back (at least) to the Version 6 Bourne shell.  But the Korn shell
is the first shell to add to their capabilities.  <a class="indexterm" name="KSH-CH-4-IX-REGULAR-EXPRESSIONS"></A
><a class="indexterm" name="AUTOID-6212"></A
><a class="indexterm" name="AUTOID-6214"></A
><a class="indexterm" name="AUTOID-6216"></A
><a class="indexterm" name="AUTOID-6218"></A
><a class="indexterm" name="AUTOID-6220"></A
><a class="indexterm" name="AUTOID-6222"></A
>
It adds a set
of operators, called <em class="emphasis">regular expression</EM
> (or <em class="emphasis">regexp</EM
> for short)
operators,
that give it much of the string-matching power of advanced UNIX utilities
like <em class="emphasis">awk</EM
>(1),
<em class="emphasis">egrep</EM
>(1) (extended <em class="emphasis">grep</EM
>(1)) and the <em class="emphasis">emacs</EM
> editor,
albeit with a different syntax.  These capabilities go beyond 
those
that you may be used to in other UNIX utilities like <em class="emphasis">grep</EM
>,
<em class="emphasis">sed</EM
>(1) and <em class="emphasis">vi</EM
>(1).</P
><p class="para">Advanced UNIX users will find the Korn shell's regular expression
capabilities occasionally useful for script writing, although they 
border on overkill.  (Part of the problem is the inevitable
syntactic clash with the shell's myriad other special characters.)
Therefore we won't go into great detail about regular expressions here.
For more comprehensive information, the &quot;last word&quot;
on practical regular expressions in UNIX is <em class="emphasis">sed &amp; awk</EM
>, 
an O'Reilly Nutshell Handbook by Dale Dougherty.
If you are already comfortable with <em class="emphasis">awk</EM
> or <em class="emphasis">egrep</EM
>, you
may want to skip the following introductory section and go to 
&quot;Korn Shell Versus awk/egrep Regular Expressions&quot; below,
where we explain the shell's regular expression mechanism by
comparing it with the syntax used in those two utilities.
Otherwise, read on.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-4-SECT-3.2.1">4.3.2.1 Regular expression basics</A
></H4
><p class="para">Think of regular expressions as strings that match patterns
more powerfully than the standard shell wildcard schema.
Regular expressions began as an idea in theoretical computer
science, but they have found their way into many nooks and crannies of
everyday, practical computing.  The syntax used to represent them
may vary, but the concepts are very much the same.</P
><p class="para"><a class="indexterm" name="KSH-CH-4-IX-REGEXPS-SYNTAX"></A
>A shell regular expression can contain regular characters, standard
wildcard characters, and additional 
operators that are more powerful than wildcards.  Each such operator
has the form <em class="emphasis">x</EM
>(<em class="emphasis">exp</EM
><b class="emphasis.bold">)</B
>, where <em class="emphasis">x</EM
> is the particular
operator and <em class="emphasis">exp</EM
> is any regular expression (often simply
a regular string).  The operator determines how many occurrences
of <em class="emphasis">exp</EM
> a string that matches the pattern can contain.
See <a class="xref" href="#KSH-CH-4-TAB-1" title="Regular Expression Operators">Table 4.2</A
> and <a class="xref" href="#KSH-CH-4-TAB-2" title="Regular Expression Operator Examples">Table 4.3</A
>.<a class="indexterm" name="AUTOID-6252"></A
><a class="indexterm" name="AUTOID-6255"></A
><a class="indexterm" name="AUTOID-6258"></A
><a class="indexterm" name="AUTOID-6261"></A
><a class="indexterm" name="AUTOID-6264"></A
><a class="indexterm" name="AUTOID-6267"></A
><a class="indexterm" name="AUTOID-6270"></A
><a class="indexterm" name="AUTOID-6273"></A
><a class="indexterm" name="AUTOID-6276"></A
><a class="indexterm" name="AUTOID-6279"></A
></P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-4-TAB-1">Table 4.2: Regular Expression Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Operator</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">*</CODE
>(<em class="emphasis">exp</EM
>)</TD
><td class="entry" rowspan="1" colspan="1">0 or more occurrences of <em class="emphasis">exp</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">+</CODE
>(<em class="emphasis">exp</EM
>)</TD
><td class="entry" rowspan="1" colspan="1">1 or more occurrences of <em class="emphasis">exp</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">?</CODE
>(<em class="emphasis">exp</EM
>)</TD
><td class="entry" rowspan="1" colspan="1">0 or 1 occurrences of <em class="emphasis">exp</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">@</B
>(<em class="emphasis">exp1</EM
>|<em class="emphasis">exp2</EM
>|...)</TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">exp1</EM
> or <em class="emphasis">exp2</EM
> or...</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">!</B
>(<em class="emphasis">exp</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Anything that doesn't match <em class="emphasis">exp</EM
>
[8]</P
></TD
></TR
></TBODY
></TABLE
><blockquote class="footnote"><p class="para">[8] Actually, <b class="emphasis.bold">!(</B
><em class="emphasis">exp</EM
>) is 
not a regular expression operator by the standard technical definition, 
though it is a handy extension.</P
></BLOCKQUOTE
><a class="indexterm" name="AUTOID-6327"></A
><a class="indexterm" name="AUTOID-6328"></A
><table class="table"><caption class="table"><a class="title" name="KSH-CH-4-TAB-2">Table 4.3: Regular Expression Operator Examples</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Expression</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Matches</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><em class="emphasis">x</EM
></TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">x</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">*</CODE
>(<em class="emphasis">x</EM
>)</TD
><td class="entry" rowspan="1" colspan="1">Null string, <em class="emphasis">x</EM
>, <em class="emphasis">xx</EM
>, <em class="emphasis">xxx</EM
>, ...</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">+</CODE
>(<em class="emphasis">x</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">x</EM
>, <em class="emphasis">xx</EM
>, <em class="emphasis">xxx</EM
>, ...</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">?</CODE
>(<em class="emphasis">x</EM
>)</TD
><td class="entry" rowspan="1" colspan="1">Null string, <em class="emphasis">x</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">!</CODE
>(<em class="emphasis">x</EM
>)</TD
><td class="entry" rowspan="1" colspan="1">Any string except <em class="emphasis">x</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">@</CODE
>(<em class="emphasis">x</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">x</EM
> (see below)</TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-6379"></A
>Regular expressions are extremely useful when dealing with arbitrary
text, as you already know if you have used <em class="emphasis">grep</EM
> or the
regular-expression capabilities of any UNIX editor.  They aren't
nearly as useful for matching filenames and other simple
types of information with which shell users typically work.<a class="indexterm" name="AUTOID-6382"></A
>
Furthermore, most things you can do with the shell's regular
expression operators can also be done (though possibly with more
keystrokes and less efficiency) by piping the output of a shell
command through <em class="emphasis">grep</EM
> or <em class="emphasis">egrep</EM
>.</P
><p class="para">Nevertheless, here are a few examples of how shell regular
expressions can solve filename-listing problems.  Some of
these will come in handy in later chapters as pieces of solutions
to larger tasks.</P
><ol class="orderedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6390"></A
>The <em class="emphasis">emacs</EM
> editor supports customization files whose names
end in <em class="emphasis">.el</EM
> (for Emacs LISP) or <em class="emphasis">.elc</EM
> (for Emacs LISP Compiled).
List all <em class="emphasis">emacs</EM
> customization files in the current directory.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6398"></A
>In a directory of C source code, list all files that are not
necessary.  Assume that &quot;necessary&quot; files end in <em class="emphasis">.c</EM
> or <em class="emphasis">.h</EM
>, or
are named <em class="emphasis">Makefile</EM
> or <em class="emphasis">README</EM
>.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6406"></A
>Filenames in the VAX/VMS operating system
end in a semicolon followed by a version
number, e.g., <em class="emphasis">fred.bob;23</EM
>.  List all VAX/VMS-style
filenames in the current directory.</P
></LI
></OL
><p class="para">Here are the solutions:</P
><ol class="orderedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6413"></A
><a class="indexterm" name="AUTOID-6416"></A
>In the first of these, we are looking for files that end in <em class="emphasis">.el</EM
>
with an optional <em class="emphasis">c</EM
>.  The expression that matches this is 
<b class="emphasis.bold"><code class="literal">*</CODE
>.el<code class="literal">?</CODE
>(c)</B
>.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6426"></A
><a class="indexterm" name="AUTOID-6429"></A
>The second example depends on the four standard subexpressions 
<code class="literal">*</CODE
><b class="emphasis.bold">.c</B
>, 
<code class="literal">*</CODE
><b class="emphasis.bold">.h</B
>, 
<b class="emphasis.bold">Makefile</B
>, and <b class="emphasis.bold">README</B
>.  
The entire expression is 
<b class="emphasis.bold">!(</B
><code class="literal">*</CODE
><b class="emphasis.bold">.c|</B
><code class="literal">*</CODE
><b class="emphasis.bold">.h|Makefile|README)</B
>, which matches anything
that does not match any of the four possibilities.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6445"></A
><a class="indexterm" name="AUTOID-6448"></A
>The solution to the third example starts with 
<code class="literal">*</CODE
>
<b class="emphasis.bold">\</B
><code class="literal">;</CODE
>: the shell
wildcard <code class="literal">*</CODE
> followed by a backslash-escaped semicolon.  
Then, we could use
the regular expression <b class="emphasis.bold">+([0-9])</B
>, 
which matches one or more
characters in the range <b class="emphasis.bold">[0-9]</B
>, i.e., one or more digits.
This is almost correct (and probably close enough), but it doesn't
take into account that the first digit cannot be 0.  <a class="indexterm" name="AUTOID-6457"></A
><a class="indexterm" name="AUTOID-6460"></A
>
Therefore the correct expression is 
<code class="literal">*</CODE
><b class="emphasis.bold">\;[1-9]</B
><code class="literal">*</CODE
><b class="emphasis.bold">([0-9])</B
>, which matches
anything that ends with a semicolon, a digit from 1 to 9, and
<em class="emphasis">zero</EM
> or more digits from 0 to 9.</P
></LI
></OL
><p class="para">Regular expression operators are an interesting addition to the Korn
shell's features, but you can get along well without them-even
if you intend to do a substantial amount of shell programming.</P
><p class="para">In our opinion, the shell's authors missed an opportunity to build
into the wildcard mechanism the ability to match files by <em class="emphasis">type</EM
>
(regular, directory, executable, etc., as in some of the conditional
tests we will see in <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
>) as well as by name component.
We feel that shell programmers would have found this more useful than
arcane regular expression operators.</P
><p class="para"><a class="indexterm" name="KSH-CH-4-IX-REGEXPS-VS-AWK-EGREP"></A
><a class="indexterm" name="KSH-CH-4-IX-AWK"></A
><a class="indexterm" name="KSH-CH-4-IX-EGREP"></A
>The following section compares Korn shell regular expressions to 
analogous features in <em class="emphasis">awk</EM
> and <em class="emphasis">egrep</EM
>.  If you aren't familiar
with these, skip to the section entitled &quot;Pattern-matching Operators.&quot; </P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-4-SECT-3.2.2">4.3.2.2 Korn shell versus awk/egrep regular expressions</A
></H4
><p class="para"><a class="xref" href="#KSH-CH-4-TAB-3" title="Shell Versus egrep/awk Regular Expression Operators">Table 4.4</A
>
is an expansion of 
<a class="xref" href="#KSH-CH-4-TAB-1" title="Regular Expression Operators">Table 4.2</A
>: the middle column shows
the equivalents in <em class="emphasis">awk</EM
>/<em class="emphasis">egrep</EM
> of the shell's regular
expression operators.  <a class="indexterm" name="AUTOID-6489"></A
><a class="indexterm" name="AUTOID-6492"></A
><a class="indexterm" name="AUTOID-6495"></A
><a class="indexterm" name="AUTOID-6498"></A
><a class="indexterm" name="AUTOID-6501"></A
><a class="indexterm" name="AUTOID-6504"></A
><a class="indexterm" name="AUTOID-6507"></A
><a class="indexterm" name="AUTOID-6510"></A
><a class="indexterm" name="AUTOID-6513"></A
><a class="indexterm" name="AUTOID-6516"></A
></P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-4-TAB-3">Table 4.4: Shell Versus egrep/awk Regular Expression Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Korn Shell</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">egrep/awk</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">*</CODE
>(<em class="emphasis">exp</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">exp</EM
><code class="literal">*</CODE
></TD
><td class="entry" rowspan="1" colspan="1">0 or more occurrences of <em class="emphasis">exp</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">+(<em class="emphasis">exp</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">exp</EM
>+</TD
><td class="entry" rowspan="1" colspan="1">1 or more occurrences of <em class="emphasis">exp</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">?</CODE
>(<em class="emphasis">exp</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">exp</EM
><code class="literal">?</CODE
></TD
><td class="entry" rowspan="1" colspan="1">0 or 1 occurrences of <em class="emphasis">exp</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">@(<em class="emphasis">exp1</EM
>|<em class="emphasis">exp2</EM
>|...)</TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">exp1</EM
>|<em class="emphasis">exp2</EM
>|...</TD
><td class="entry" rowspan="1" colspan="1"><em class="emphasis">exp1</EM
> or <em class="emphasis">exp2</EM
> or...</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">!</B
>(<em class="emphasis">exp</EM
>)</TD
><td class="entry" rowspan="1" colspan="1">(none)</TD
><td class="entry" rowspan="1" colspan="1">Anything that doesn't match <em class="emphasis">exp</EM
></TD
></TR
></TBODY
></TABLE
><p class="para">These equivalents are close but not quite exact.
Actually, an <em class="emphasis">exp</EM
> within any of the Korn shell operators can be a series of
<em class="emphasis">exp1</EM
>|<em class="emphasis">exp2</EM
>|... alternates.  But because the shell would interpret
an expression like <b class="emphasis.bold">dave|fred|bob</B
>
as a pipeline of commands, you must use <b class="emphasis.bold">@(dave|fred|bob)</B
>
for alternates by themselves.</P
><p class="para">For example:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><b class="emphasis.bold">@(dave|fred|bob)</B
> matches <b class="emphasis.bold">dave</B
>, <b class="emphasis.bold">fred</B
>, or <b class="emphasis.bold">bob</B
>.</P
></LI
><li class="listitem"><p class="para"><code class="literal">*</CODE
><b class="emphasis.bold">(dave|fred|bob)</B
> means, 
&quot;0 or more occurrences
of <b class="emphasis.bold">dave</B
>, <b class="emphasis.bold">fred</B
>, or <b class="emphasis.bold">bob</B
>&quot;.  This expression matches strings like
the null string, <b class="emphasis.bold">dave</B
>, <b class="emphasis.bold">davedave</B
>, <b class="emphasis.bold">fred</B
>, <b class="emphasis.bold">bobfred</B
>, 
<b class="emphasis.bold">bobbobdavefredbobfred</B
>, etc.  </P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">+(dave|fred|bob)</B
> matches any of the above except the null string.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">?(dave|fred|bob)</B
> matches the null string, <b class="emphasis.bold">dave</B
>, <b class="emphasis.bold">fred</B
>, or <b class="emphasis.bold">bob</B
>.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">!(dave|fred|bob)</B
> matches anything except <b class="emphasis.bold">dave</B
>, <b class="emphasis.bold">fred</B
>, or
<b class="emphasis.bold">bob</B
>.</P
></LI
></UL
><p class="para"><a class="indexterm" name="AUTOID-6612"></A
><a class="indexterm" name="AUTOID-6613"></A
><a class="indexterm" name="AUTOID-6614"></A
></P
><p class="para"><a class="indexterm" name="AUTOID-6616"></A
>It is worth re-emphasizing that shell regular expressions can still
contain standard shell wildcards.  <a class="indexterm" name="AUTOID-6619"></A
><a class="indexterm" name="AUTOID-6622"></A
><a class="indexterm" name="AUTOID-6625"></A
><a class="indexterm" name="AUTOID-6627"></A
>
Thus, the shell wildcard <b class="emphasis.bold">?</B
>
(match any single character) is the equivalent to <b class="emphasis.bold">.</B
> in
<em class="emphasis">egrep</EM
> or <em class="emphasis">awk</EM
>, and the shell's character set operator
<b class="emphasis.bold">[</B
>...<b class="emphasis.bold">]</B
> is the same as in those utilities.
[9]<a class="indexterm" name="AUTOID-6650"></A
><a class="indexterm" name="AUTOID-6653"></A
><a class="indexterm" name="AUTOID-6656"></A
><a class="indexterm" name="AUTOID-6659"></A
>
For example, the expression <b class="emphasis.bold">+([0-9])</B
> matches a number, i.e., 
one or more digits.  The shell wildcard character <code class="literal">*</CODE
> is equivalent
to the shell regular expression <code class="literal">*</CODE
>
(<code class="literal">?)</CODE
>.</P
><blockquote class="footnote"><p class="para">[9] <a class="indexterm" name="AUTOID-6638"></A
><a class="indexterm" name="AUTOID-6640"></A
><a class="indexterm" name="AUTOID-6642"></A
><a class="indexterm" name="AUTOID-6644"></A
>And, for that matter, the same as in
<em class="emphasis">grep</EM
>, <em class="emphasis">sed</EM
>, <em class="emphasis">ed</EM
>, <em class="emphasis">vi</EM
>, etc.</P
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-6667"></A
><a class="indexterm" name="AUTOID-6669"></A
>A few <em class="emphasis">egrep</EM
> and <em class="emphasis">awk</EM
> regexp operators do not have equivalents
in the Korn shell.  These include:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">The beginning- and end-of-line operators <b class="emphasis.bold">^</B
> and <b class="emphasis.bold">$</B
>.</P
></LI
><li class="listitem"><p class="para">The beginning- and end-of-word operators <b class="emphasis.bold">\&lt;</B
> and <b class="emphasis.bold">\&gt;</B
>.</P
></LI
><li class="listitem"><p class="para">Repeat factors like 
<b class="emphasis.bold">\{</B
><em class="emphasis">N</EM
>
<b class="emphasis.bold">\}</B
> and 
<b class="emphasis.bold">\{</B
><em class="emphasis">M</EM
>
<b class="emphasis.bold">,</B
>
<em class="emphasis">N</EM
>
<b class="emphasis.bold">\}</B
>.</P
></LI
></UL
><p class="para">The first two pairs are hardly necessary, since the Korn shell doesn't
normally operate on text files and does parse strings into words itself.<a class="indexterm" name="AUTOID-6693"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-4-SECT-3.3">4.3.3 Pattern-matching Operators</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-4-IX-PATMATCH-OPERATORS"></A
><a class="indexterm" name="AUTOID-6699"></A
><a class="xref" href="#KSH-CH-4-TAB-4" title="Pattern-matching Operators">Table 4.5</A
>
lists the Korn shell's pattern-matching operators.<a class="indexterm" name="KSH-CH-4-IX-PATMATCH-OPERATORS-SYNTAX"></A
><a class="indexterm" name="AUTOID-6707"></A
><a class="indexterm" name="AUTOID-6710"></A
><a class="indexterm" name="AUTOID-6713"></A
><a class="indexterm" name="AUTOID-6716"></A
><a class="indexterm" name="AUTOID-6719"></A
><a class="indexterm" name="AUTOID-6722"></A
><a class="indexterm" name="AUTOID-6725"></A
><a class="indexterm" name="AUTOID-6728"></A
></P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-4-TAB-4">Table 4.5: Pattern-matching Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Operator</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">$</B
>{<em class="emphasis">variable</EM
>#<em class="emphasis">pattern</EM
>}</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If the pattern matches the beginning of the variable's value,
delete the shortest part that matches and return the rest.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">$</B
>{<b class="emphasis.bold">variable</B
>##<em class="emphasis">pattern</EM
>}</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If the pattern matches the beginning of the variable's value,
delete the longest part that matches and return the rest.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">$</B
>{<b class="emphasis.bold">variable</B
>%<em class="emphasis">pattern</EM
>}</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If the pattern matches the end of the variable's value,
delete the shortest part that matches and return the rest.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">$</B
>{<em class="emphasis">variable</EM
>%%<em class="emphasis">pattern</EM
>}</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If the pattern matches the end of the variable's value,
delete the longest part that matches and return the rest.</P
></TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-6768"></A
></P
><p class="para">These can be hard to remember, so here's a handy mnemonic
device: <b class="emphasis.bold">#</B
> matches the front because number signs <em class="emphasis">precede</EM
>
numbers; <b class="emphasis.bold">%</B
> matches the rear because percent signs <em class="emphasis">follow</EM
>
numbers.</P
><p class="para">The classic use for pattern-matching operators is in stripping
off components of pathnames, such as directory prefixes and filename suffixes.
With that in mind,
here is an example that shows how all of the operators work.
Assume that the variable <b class="emphasis.bold">path</B
> has the value
<em class="emphasis">/home /billr/mem/long.file.name</EM
>; then:<a class="indexterm" name="AUTOID-6777"></A
></P
><p class="para"><blockquote class="screen"><pre class="screen"><b class="emphasis.bold">Expression         	  Result</B
>
${path##/*/}                       long.file.name
${path#/*/}              billr/mem/long.file.name
$path              /home/billr/mem/long.file.name
${path%.*}         /home/billr/mem/long.file
${path%%.*}        /home/billr/mem/long</PRE
></BLOCKQUOTE
></P
><p class="para">The two patterns used here are <code class="literal">/*/</CODE
>, which matches anything between
two slashes, and <b class="emphasis.bold">.</B
><code class="literal">*</CODE
>, which matches a dot followed by anything.</P
><p class="para">We will incorporate one of these operators into our next
programming task.</P
><div class="task"><h4>Task 4.2</H4
><blockquote class="taskinfo"><a class="indexterm" name="AUTOID-6790"></A
><p class="para">You are writing a C compiler, and you want to use the Korn shell for
your front-end.[10]</P
><blockquote class="footnote"><p class="para">[10] Don't laugh-many UNIX compilers have shell scripts as front-ends.</P
></BLOCKQUOTE
></BLOCKQUOTE
><p class="para">Think of a C compiler as a pipeline of data processing
components. C source code is input to the beginning of the pipeline,
and object code comes out of the end; there are several steps in between.
The shell script's task, among many other things, is to control the
flow of data through the components and to designate output files.</P
><p class="para">You need to write the part of the script that takes the name of the
input C source file and creates from it the name of the output
object code file. That is, 
you must take a filename ending in <em class="emphasis">.c</EM
>
and create a filename that is similar except that it ends in <em class="emphasis">.o</EM
>.</P
><p class="para">The task at hand is to strip the <em class="emphasis">.c</EM
> off the filename and 
append <em class="emphasis">.o</EM
>. A single shell statement will do it:<a class="indexterm" name="KSH-CH-4-IX-PERCENT-PATMATCH-OPERATOR"></A
><a class="indexterm" name="KSH-CH-4-IX-PATMATCH-OPERATORS-PERCENT"></A
></P
><p class="para"><blockquote class="screen"><pre class="screen">objname=${filename%.c}.o</PRE
></BLOCKQUOTE
></P
><p class="para">This tells the shell to look at the end of <b class="emphasis.bold">filename</B
> for <em class="emphasis">.c</EM
>. If there is a match,
return <b class="emphasis.bold">$filename</B
> with the match deleted. So if <b class="emphasis.bold">filename</B
>
had the value <b class="emphasis.bold">fred.c</B
>, the expression <b class="emphasis.bold">${filename%.c}</B
> would
return <b class="emphasis.bold">fred</B
>. The <em class="emphasis">.o</EM
> is appended to make the desired <b class="emphasis.bold">fred.o</B
>,
which is stored in the variable <b class="emphasis.bold">objname</B
>.</P
><p class="para">If <b class="emphasis.bold">filename</B
> had an inappropriate value (without <em class="emphasis">.c</EM
>)
such as <b class="emphasis.bold">fred.a</B
>,
the above expression would evaluate to <b class="emphasis.bold">fred.a.o</B
>: since there was
no match, nothing is deleted from the value of <b class="emphasis.bold">filename</B
>, 
and <em class="emphasis">.o</EM
> is appended anyway.  <a class="indexterm" name="AUTOID-6828"></A
>
And, if <b class="emphasis.bold">filename</B
> contained more
than one dot-e.g., if it were the <em class="emphasis">y.tab.c</EM
> that is so infamous
among compiler writers-the expression would still produce the desired
<em class="emphasis">y.tab.o</EM
>.<a class="indexterm" name="AUTOID-6833"></A
><a class="indexterm" name="AUTOID-6836"></A
>
Notice that this would not be true if we used <b class="emphasis.bold">%%</B
> in the expression
instead of <b class="emphasis.bold">%</B
>.  <a class="indexterm" name="AUTOID-6841"></A
><a class="indexterm" name="AUTOID-6842"></A
>
The former operator uses the longest match
instead of the shortest, so it would match <em class="emphasis">.tab.o</EM
> and
evaluate to <b class="emphasis.bold">y.o</B
> rather than
<b class="emphasis.bold">y.tab.o</B
>. So the single <b class="emphasis.bold">%</B
> is correct in this case.  </P
><p class="para">A longest-match deletion would be preferable, however, in the following task.</P
></DIV
><div class="task"><h4>Task 4.3</H4
><blockquote class="taskinfo"><p class="para">You are implementing a filter that prepares a text file for 
printer output. You want to put the file's name-without
any directory prefix-on the &quot;banner&quot; page.
Assume that, in your script, you have the pathname of the file
to be printed stored in the variable <b class="emphasis.bold">pathname</B
>.</P
></BLOCKQUOTE
><a class="indexterm" name="KSH-CH-4-IX-POUNDS-PATMATCH-OPERATOR"></A
><a class="indexterm" name="KSH-CH-4-IX-PATMATCH-OPERATORS-POUNDS"></A
><p class="para">Clearly the objective is to remove the directory prefix from the pathname.
The following line will do it:</P
><p class="para"><blockquote class="screen"><pre class="screen">bannername=${pathname##*/}</PRE
></BLOCKQUOTE
></P
><p class="para">This solution is similar to the first line in the examples shown before.
If <b class="emphasis.bold">pathname</B
> were just a filename, the pattern <code class="literal">*</CODE
><b class="emphasis.bold">/</B
> (anything
followed by a slash) would not match and the value of the expression
would be <b class="emphasis.bold">pathname</B
> untouched. If <b class="emphasis.bold">pathname</B
> were something like
<em class="emphasis">fred/bob</EM
>, the prefix <em class="emphasis">fred/</EM
> would match the pattern and be deleted,
leaving just <b class="emphasis.bold">bob</B
> as the expression's value. The same thing would
happen if <b class="emphasis.bold">pathname</B
> were something like <em class="emphasis">/dave/pete/fred/bob</EM
>:
since the <b class="emphasis.bold">##</B
> deletes the longest match, it deletes the 
entire <em class="emphasis">/dave/pete/fred/</EM
>.</P
><p class="para"><a class="indexterm" name="AUTOID-6875"></A
><a class="indexterm" name="AUTOID-6878"></A
>If we used 
<b class="emphasis.bold">#</B
><code class="literal">*</CODE
><b class="emphasis.bold">/</B
> 
instead of <b class="emphasis.bold">##</B
><code class="literal">*</CODE
><b class="emphasis.bold">/</B
>, the expression
would have the incorrect value <em class="emphasis">dave/pete/fred/bob</EM
>, because the
shortest instance of &quot;anything followed by a slash&quot; at the beginning
of the string is just a slash (<b class="emphasis.bold">/</B
>).</P
><p class="para"><a class="indexterm" name="AUTOID-6890"></A
>The construct 
<b class="emphasis.bold">$</B
>{<em class="emphasis">variable</EM
><b class="emphasis.bold">##</B
><code class="literal">*</CODE
><b class="emphasis.bold">/}</B
> is actually equivalent
to the UNIX utility <em class="emphasis">basename</EM
>(1).  <a class="indexterm" name="AUTOID-6898"></A
><a class="indexterm" name="AUTOID-6899"></A
>
<em class="emphasis">basename</EM
> takes a pathname
as argument and returns the filename only; it is meant to be used
with the shell's command substitution mechanism (see below). <em class="emphasis">basename</EM
> is
less efficient than 
<b class="emphasis.bold">$</B
>{<em class="emphasis">variable</EM
><b class="emphasis.bold">##/</B
><code class="literal">*</CODE
><b class="emphasis.bold">}</B
> because it runs in its own separate process rather than
within the shell.  <a class="indexterm" name="AUTOID-6907"></A
><a class="indexterm" name="AUTOID-6909"></A
><a class="indexterm" name="AUTOID-6912"></A
>
Another utility, <em class="emphasis">dirname</EM
>(1), does essentially
the opposite of <em class="emphasis">basename</EM
>: it returns the directory prefix only.
It is equivalent to the Korn shell expression 
<b class="emphasis.bold">$</B
>{<em class="emphasis">variable</EM
><b class="emphasis.bold">%/</B
><code class="literal">*</CODE
><b class="emphasis.bold">}</B
>
and is less efficient for the same reason.</P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-4-SECT-3.4">4.3.4 Length Operator</A
></H3
><p class="para">There are two remaining operators on variables.  <a class="indexterm" name="AUTOID-6925"></A
><a class="indexterm" name="AUTOID-6928"></A
>
One is 
<b class="emphasis.bold">$</B
>{#<em class="emphasis">varname</EM
>}, which
returns the length of the value of the variable as a character
string. (In <a class="xref" href="ch06_01.htm" webstripperlinkwas="ch06_01.htm" title="Command-line Options and Typed Variables">Chapter 6</A
> we will see how to treat this
and similar values as actual numbers so they can be used 
in arithmetic expressions.) For example,
if <b class="emphasis.bold">filename</B
> has the value <b class="emphasis.bold">fred.c</B
>, then 
<b class="emphasis.bold">${#filename}</B
> would have the value <b class="emphasis.bold">6</B
>.  
The other operator 
(<b class="emphasis.bold">$</B
>{#<em class="emphasis">array</EM
><b class="emphasis.bold">[</B
><code class="literal">*</CODE
><b class="emphasis.bold">]}</B
>) has to do with array variables, which are also discussed 
in <a class="xref" href="ch06_01.htm" webstripperlinkwas="ch06_01.htm" title="Command-line Options and Typed Variables">Chapter 6</A
>.</P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch04_02.htm" webstripperlinkwas="ch04_02.htm" title="4.2 Shell Variables"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 4.2 Shell Variables" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" title="Learning the Korn Shell"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Learning the Korn Shell" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch04_04.htm" webstripperlinkwas="ch04_04.htm" title="4.4 Command Substitution"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 4.4 Command Substitution" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">4.2 Shell Variables</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">4.4 Command Substitution</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="../upt/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="../sedawk/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
