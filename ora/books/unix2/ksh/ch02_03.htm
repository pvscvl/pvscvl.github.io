<html><head>
<title>[Chapter 2] 2.3 Emacs Editing Mode</TITLE>
<meta name="DC.title" content="Learning the Korn Shell"><meta name="DC.creator" content="Bill Rosenblatt"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-03T20:56:30Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-054-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch02_01.htm" webstripperlinkwas="ch02_01.htm" title="2. Command-line Editing"><link rel="prev" href="ch02_02.htm" webstripperlinkwas="ch02_02.htm" title="2.2 The History File"><link rel="next" href="ch02_04.htm" webstripperlinkwas="ch02_04.htm" title="2.4 Vi Editing Mode"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="Learning the Korn Shell" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,66" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch02_02.htm" webstripperlinkwas="ch02_02.htm" title="2.2 The History File"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 2.2 The History File" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 2<br>Command-line Editing</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch02_04.htm" webstripperlinkwas="ch02_04.htm" title="2.4 Vi Editing Mode"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 2.4 Vi Editing Mode" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="KSH-CH-2-SECT-2">2.3 Emacs Editing Mode</A
></H2
><p class="para"><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE"></A
><a class="indexterm" name="AUTOID-2219"></A
>If you are an <em class="emphasis">emacs</EM
> user, you will find it most useful to
think of emacs editing mode as a simplified, non-customizable
[5]
<em class="emphasis">emacs</EM
> with a single, one-line window. 
All of the basic commands are available for cursor motion, cut and paste, 
and search.</P
><blockquote class="footnote"><p class="para">[5] The public domain Korn shell and <em class="emphasis">bash</EM
> have emacs-modes
that are customizable. See <a class="xref" href="appa_01.htm" webstripperlinkwas="appa_01.htm" title="Related Shells">Appendix A, Related Shells</A
>.</P
></BLOCKQUOTE
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-2-SECT-2.1">2.3.1 Basic Commands</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-BASIC-CMNDS"></A
>Emacs-mode uses control keys for the most basic editing functions.<a class="indexterm" name="AUTOID-2233"></A
><a class="indexterm" name="AUTOID-2236"></A
>
If you aren't familiar with <em class="emphasis">emacs</EM
>,
you can think of these as extensions of the rudimentary
&quot;erase&quot; character (usually backspace or <span class="acronym">DEL</SPAN
>) that UNIX provides 
through its interface to users' terminals.
In fact, emacs-mode figures out what
your erase character is and uses that as its delete-backward key.
For the sake of consistency, we'll assume your erase character is
<span class="acronym">DEL</SPAN
> from now on; if it is <kbd class="keycap">[CTRL-H]</KBD
> or something else, you will need to
make a mental substitution.
The most basic control-key commands are shown in 
<a class="xref" href="#KSH-CH-2-TAB-0" title="Basic emacs-mode Commands">Table 2.1</A
>.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> (<em class="emphasis">Important:</EM
> remember that typing <kbd class="keycap">[CTRL-D]</KBD
> when your command line is
empty may log you off!)</P
></BLOCKQUOTE
><p class="para">The basic finger habits of emacs-mode are easy to learn, but
they do require that you assimilate a couple of concepts that
are peculiar to the <em class="emphasis">emacs</EM
> editor.</P
><p class="para">The first of these is the use of <kbd class="keycap">[CTRL-B]</KBD
> and <kbd class="keycap">[CTRL-F]</KBD
> for backward 
and forward cursor motion. These keys have the advantage of being
obvious mnemonics, but many people would rather use the arrow
keys that are on just about every keyboard nowadays.<a class="indexterm" name="AUTOID-2252"></A
></P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-2-TAB-0">Table 2.1: Basic emacs-mode Commands</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Command</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-B]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Move backward one character (without deleting)</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-F]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Move forward one character </TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">DEL</TD
><td class="entry" rowspan="1" colspan="1">Delete one character backward</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-D]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Delete one character forward</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-Y]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Retrieve (&quot;yank&quot;) last item deleted</TD
></TR
></TBODY
></TABLE
><p class="para">Unfortunately,
emacs-mode doesn't use the arrow keys, because the codes that they
transmit to the computer aren't completely standardized;
emacs-mode was designed to work on the widest variety
of terminals possible without needing to do the kind of heavy-duty
customization that the full <em class="emphasis">emacs</EM
> does.<a class="indexterm" name="AUTOID-2283"></A
>
Just about the only hardware requirement of emacs-mode
is that the SPACE character overwrite the character
on top of which it is typed.  </P
><p class="para"><a class="indexterm" name="AUTOID-2287"></A
>In emacs-mode, 
the <em class="emphasis">point</EM
> (sometimes
also called <em class="emphasis">dot</EM
>) is an imaginary place just to
the left of the character the cursor is on.  
In the command descriptions
in <a class="xref" href="#KSH-CH-2-TAB-0" title="Basic emacs-mode Commands">Table 2.1</A
>,
some say &quot;forward&quot; while others say &quot;backward.&quot;
Think of forward as &quot;to the right of point&quot; and backward as
&quot;to the left of point.&quot;</P
><p class="para">For example, let's say you type in a line and, instead of typing
<b class="emphasis.bold">RETURN</B
>, you type <kbd class="keycap">[CTRL-B]</KBD
> and hold it down so that it repeats.
The cursor will move to the left
until it is over the first character on the line, like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold"><u class="cursor">f</U
>grep -l Bob &lt; ~pete/wk/names</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Now the cursor is on the <b class="emphasis.bold">f</B
>, and point is at the beginning of the
line, just before the <b class="emphasis.bold">f</B
>.
If you type <span class="acronym">DEL</SPAN
>, nothing will happen because there are no characters
to the left of point. However, if you press <kbd class="keycap">[CTRL-D]</KBD
> (the &quot;delete character
forward&quot; command) you will delete the first letter:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold"><u class="cursor">g</U
>rep -l Bob &lt; ~pete/wk/names</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Point is still at the beginning of the line.  
If this were the desired command, you could
hit <b class="emphasis.bold">RETURN</B
> now and run it; you don't need to move the cursor
back 
to the end of the line. However, if you wanted to, you could type
<kbd class="keycap">[CTRL-F]</KBD
> repeatedly to get there:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">grep -l Bob &lt; ~pete/wk/names<u class="cursor"> </U
></B
></PRE
></BLOCKQUOTE
></P
><p class="para">At this point, typing <kbd class="keycap">[CTRL-D]</KBD
> wouldn't do anything, but hitting <span class="acronym">DEL</SPAN
> would erase
the final <b class="emphasis.bold">s</B
>. If you type <span class="acronym">DEL</SPAN
> and decide you want the <b class="emphasis.bold">s</B
>
back again, just press <kbd class="keycap">[CTRL-Y]</KBD
> to yank it back.  
If you think this example is silly, you're right in this particular case, 
but bear in mind that <kbd class="keycap">[CTRL-Y]</KBD
> undoes the last delete command
of any kind, including the delete-word and delete-line
commands that we will see shortly.
[6]<a class="indexterm" name="AUTOID-2328"></A
></P
><blockquote class="footnote"><p class="para">[6] <em class="emphasis">emacs</EM
> users should note that this usage of <kbd class="keycap">[CTRL-Y]</KBD
> is different
from  the full editor, which doesn't save character deletes.</P
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-2-SECT-2.2">2.3.2 Word Commands</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-WORD-CMNDS"></A
>The basic commands are really all you need to get around a
command line, but a set of more advanced commands lets you do
it with fewer keystrokes. These commands operate on <em class="emphasis">words</EM
>
rather than single characters; emacs-mode defines a word to be
a sequence of one or more alphanumeric characters.</P
><p class="para">The word commands are shown in 
<a class="xref" href="#KSH-CH-2-TAB-1" title="Emacs-mode Word Commands">Table 2.2</A
>.
Whereas the basic
commands are all single characters, these consist of two keystrokes,
<span class="acronym">ESC</SPAN
> followed by a letter. You will notice that
the command <span class="acronym">ESC</SPAN
> <em class="emphasis">X</EM
>, where <em class="emphasis">X</EM
> is any letter,
often does for a word what <kbd class="keycap">[CTRL-]</KBD
><em class="emphasis">X</EM
> does for a single character.
The multiplicity of choices for delete-word-backward arises from
the fact that your erase character could be either <kbd class="keycap">[CTRL-H]</KBD
> or DEL.</P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-2-TAB-1">Table 2.2: Emacs-mode Word Commands</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Command</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">ESC b</TD
><td class="entry" rowspan="1" colspan="1">Move one word backward</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">ESC f</TD
><td class="entry" rowspan="1" colspan="1">Move one word forward</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">ESC DEL</TD
><td class="entry" rowspan="1" colspan="1">Delete one word backward</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">ESC h</TD
><td class="entry" rowspan="1" colspan="1">Delete one word backward</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">ESC <kbd class="keycap">[CTRL-H]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Delete one word backward</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">ESC d</TD
><td class="entry" rowspan="1" colspan="1">Delete one word forward</TD
></TR
></TBODY
></TABLE
><p class="para">To return to our example: if we type <span class="acronym">ESC</SPAN
> b, point will move back
a word. Since <b class="emphasis.bold">/</B
> is not an alphanumeric character, 
emacs-mode will
stop there:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">grep -l Bob &lt; ~pete/wk/<u class="cursor">n</U
>ames</B
></PRE
></BLOCKQUOTE
></P
><p class="para">The cursor is on the <b class="emphasis.bold">n</B
> in <em class="emphasis">names</EM
>, and point is between the 
<b class="emphasis.bold">/</B
> and
the <b class="emphasis.bold">n</B
>. Now let's say we want to change the <b class="emphasis.bold">-l</B
> option of this command
from <em class="emphasis">Bob</EM
> to <em class="emphasis">Dave</EM
>. 
We need to move back on the command line,
so we type <span class="acronym">ESC</SPAN
> b two more times. This gets us here:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">grep -l Bob &lt; ~<u class="cursor">p</U
>ete/wk/names</B
></PRE
></BLOCKQUOTE
></P
><p class="para">If we type <span class="acronym">ESC</SPAN
> b again, we end up at the beginning of <em class="emphasis">Bob</EM
>:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">grep -l <u class="cursor">B</U
>ob &lt; ~pete/wk/names</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Why? Remember that a word is defined as a sequence of alphanumeric
characters only; therefore <b class="emphasis.bold">&lt;</B
> is not a word, and the next word
in the backward direction is <em class="emphasis">Bob</EM
>. We are now in the right position
to delete <em class="emphasis">Bob</EM
>, so we type <span class="acronym">ESC</SPAN
> d and get:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">grep -l <u class="cursor"> </U
>&lt; ~pete/wk/names</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Now we can type in the desired argument:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">grep -l Dave<u class="cursor"> </U
>&lt; ~pete/wk/names</B
></PRE
></BLOCKQUOTE
></P
><p class="para">The <kbd class="keycap">[CTRL-Y]</KBD
> &quot;undelete&quot; command will retrieve an entire word, instead of
a character, if the word was the last thing deleted.  <a class="indexterm" name="AUTOID-2415"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-2-SECT-2.3">2.3.3 Line Commands</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-LINE-CMNDS"></A
>There are still more efficient ways of moving around a command
line in emacs-mode. A few commands deal with the entire line;
they are shown in 
<a class="xref" href="#KSH-CH-2-TAB-2" title="Emacs-mode Line Commands">Table 2.3</A
>.</P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-2-TAB-2">Table 2.3: Emacs-mode Line Commands</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Command</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-A]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Move to beginning of line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-E]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Move to end of line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-K]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Delete (&quot;kill&quot;) forward to end of line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-C]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Capitalize character after point</TD
></TR
></TBODY
></TABLE
><p class="para"><kbd class="keycap">[CTRL-C]</KBD
> is often the &quot;interrupt&quot; key that UNIX provides through 
its interface to your terminal. If this is the case, <kbd class="keycap">[CTRL-C]</KBD
> 
in emacs-mode will erase the entire line, as if <kbd class="keycap">[CTRL-A]</KBD
> and 
<kbd class="keycap">[CTRL-K]</KBD
> were pressed.
On systems where the interrupt key is set to something else (often <span class="acronym">DEL</SPAN
>),
<kbd class="keycap">[CTRL-C]</KBD
> capitalizes the current character. </P
><p class="para">Using <kbd class="keycap">[CTRL-A]</KBD
>, <kbd class="keycap">[CTRL-E]</KBD
>, and <kbd class="keycap">[CTRL-K]</KBD
>
should be straightforward. Remember that <kbd class="keycap">[CTRL-Y]</KBD
> will always
undelete the last thing deleted; if you use <kbd class="keycap">[CTRL-K]</KBD
>, that
could be quite a few characters.<a class="indexterm" name="AUTOID-2460"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-2-SECT-2.4">2.3.4 Moving Around in the History File</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-HIST-FILE-CMNDS"></A
>Now we know how to get around the command line efficiently
and make changes. But that doesn't address the original issue
of recalling previous commands by accessing the history
file. Emacs-mode has several commands for doing this, summarized in
<a class="xref" href="#KSH-CH-2-TAB-3" title="Emacs-mode Commands for Moving Through the History File">Table 2.4</A
>.</P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-2-TAB-3">Table 2.4: Emacs-mode Commands for Moving Through the History File</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Command</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-P]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Move to previous line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-N]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Move to next line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-R]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Search backward</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">ESC &lt;</TD
><td class="entry" rowspan="1" colspan="1">Move to first line of history file</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">ESC &gt;</TD
><td class="entry" rowspan="1" colspan="1">Move to last line of history file</TD
></TR
></TBODY
></TABLE
><p class="para"><kbd class="keycap">[CTRL-P]</KBD
> is by far the one you will use most often-it's 
the &quot;I made a mistake, let me go back and fix it&quot; key.
You can use it as many times as you wish to scroll back
through the history file. If you want to get back to the
last command you entered, you can hold down <kbd class="keycap">[CTRL-N]</KBD
> until the Korn shell
beeps at you, or just type <span class="acronym">ESC</SPAN
> &gt;.
As an example, you hit <b class="emphasis.bold">RETURN</B
> to run the command above, but
you get an error message telling you that your option letter
was incorrect. You want to change it without retyping the
whole thing.
First, you would type <kbd class="keycap">[CTRL-P]</KBD
> to recall the bad command. You get it
back with point at the end:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">grep -l Dave &lt; ~pete/wk/names<u class="cursor"> </U
> </B
></PRE
></BLOCKQUOTE
></P
><p class="para">After <kbd class="keycap">[CTRL-A]</KBD
>, <span class="acronym">ESC</SPAN
> f, two <kbd class="keycap">[CTRL-F]</KBD
>s, and <kbd class="keycap">[CTRL-D]</KBD
>, you have:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">grep -<u class="cursor"> </U
>Dave &lt; ~pete/wk/names</B
></PRE
></BLOCKQUOTE
></P
><p class="para">You decide to try <b class="emphasis.bold">-s</B
> instead of <b class="emphasis.bold">-l</B
>, so you type <b class="emphasis.bold">s</B
> and
hit RETURN.
You get the same error message, so you give up and
look it up in the manual.  
You find out that the command you want 
is <em class="emphasis">fgrep</EM
>-not <em class="emphasis">grep</EM
>-after all.  
You sigh heavily and go back
and find the <em class="emphasis">fgrep</EM
> command you typed in an hour ago.  <a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-SEARCH-HIST-FILE"></A
>
To do this, you type <kbd class="keycap">[CTRL-R]</KBD
>; whatever was on the line will disappear
and be replaced by <b class="emphasis.bold">^R</B
>.  Then type <b class="emphasis.bold">fgrep</B
>, and you will see this:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">^Rfgrep</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Hit RETURN, and the shell will search backwards through the history
file for a line containing &quot;fgrep&quot;. If it doesn't find one, it will
beep. But if it finds one, it will 
display it, and your &quot;current line&quot; will be that line (i.e.,
you will be somewhere in the middle of the history file, not
at the end as usual):</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">fgrep -l Bob &lt; ~pete/wk/names<u class="cursor"> </U
></B
></PRE
></BLOCKQUOTE
></P
><p class="para">Typing <kbd class="keycap">[CTRL-R]</KBD
> without an argument (i.e., just <kbd class="keycap">[CTRL-R]</KBD
> followed by RETURN)
causes the shell to repeat your last backward search.
If you try the <em class="emphasis">fgrep</EM
> command by hitting RETURN again, two things
will happen. First, of course, the command will run. Second,
this line will be entered into the history file at the end,
and your &quot;current line&quot; will be at the end as well. You will
no longer be in the middle of the history file.  <a class="indexterm" name="AUTOID-2538"></A
><a class="indexterm" name="AUTOID-2541"></A
><a class="indexterm" name="AUTOID-2545"></A
>
<kbd class="keycap">[CTRL-R]</KBD
> may not work properly on some versions
of UNIX, because it is also the default setting for the &quot;reprint&quot; function
of the terminal interface. (It works correctly on all the versions
we've tried.) If you press <kbd class="keycap">[CTRL-R]</KBD
> and see the
command line reprinted, you may want to consider 
changing the terminal interface's
&quot;reprint&quot; key. See the section on <em class="emphasis">stty</EM
> in <a class="xref" href="ch08_01.htm" webstripperlinkwas="ch08_01.htm" title="Process Handling">Chapter 8</A
>.</P
><p class="para"><kbd class="keycap">[CTRL-P]</KBD
> and <kbd class="keycap">[CTRL-R]</KBD
> are clearly the most important emacs-mode commands
that deal with the history file; you might use <kbd class="keycap">[CTRL-N]</KBD
> occasionally.<a class="indexterm" name="AUTOID-2555"></A
>
The others are less useful, and we suspect that they were mainly
included for compatibility with the full <em class="emphasis">emacs</EM
> editor.</P
><p class="para"><a class="indexterm" name="AUTOID-2558"></A
><a class="indexterm" name="AUTOID-2561"></A
><em class="emphasis">emacs</EM
> users should also note that the full editor's &quot;deluxe&quot;
search capabilities, such as incremental and regular expression
search, are not available in the Korn shell's emacs-mode&nbsp;- with one
minor exception: if you use <kbd class="keycap">[CTRL-R]</KBD
> and precede your search string with
a ^ (caret character), it will match only commands that have the
search string at the beginning of the line.<a class="indexterm" name="AUTOID-2566"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-2-SECT-2.5">2.3.5 Filename Completion and Expansion</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-FILENAME-COMPLETION"></A
><a class="indexterm" name="AUTOID-2573"></A
><a class="indexterm" name="AUTOID-2575"></A
><a class="indexterm" name="AUTOID-2577"></A
>One of the most powerful (and typically underused) features
of emacs-mode is its <em class="emphasis">filename completion</EM
> facility, inspired
by similar features in the full <em class="emphasis">emacs</EM
> editor, the C shell,
and (originally) the old <span class="acronym">DEC TOPS-20</SPAN
> operating system.</P
><p class="para">The premise behind
filename completion is that when you need to type a filename, you
should not have to type more than is necessary to
identify the file unambiguously.  
This is an excellent feature; there is an analogous one in vi-mode.
We recommend that you get it under your fingers, since it will save
you quite a bit of typing.</P
><p class="para">There are three commands in emacs-mode that relate to filename
completion. The most important is <span class="acronym">ESC ESC</SPAN
>.
[7]
When you type in a word of text followed by <span class="acronym">ESC ESC</SPAN
>, the Korn shell
will attempt to complete the name of a file in the current directory.
Then one of four things can happen:</P
><blockquote class="footnote"><p class="para">[7] <em class="emphasis">emacs</EM
> users can think of this as analogous
to minibuffer completion with the TAB key.</P
></BLOCKQUOTE
><ol class="orderedlist"><li class="listitem"><p class="para">If there is no file whose name begins with the word, the shell
will beep and nothing further will happen.</P
></LI
><li class="listitem"><p class="para">If there is exactly one way to complete the filename and the file
is a regular file, the shell will type the rest of the filename and
follow it with a space so you can type in more command arguments.</P
></LI
><li class="listitem"><p class="para">If there is exactly one way to complete the filename and the file
is a directory, the shell will complete the filename and follow
it with a slash.</P
></LI
><li class="listitem"><p class="para">If there is more than one way to complete the filename,
the shell will complete out to the longest common prefix among
the available choices.</P
></LI
></OL
><p class="para">For example, assume you have a directory with 
the files <em class="emphasis">program.c</EM
> and <em class="emphasis">problem.c</EM
>. You want to compile
the first of these by typing <b class="emphasis.bold">cc program.c</B
>. You type
<b class="emphasis.bold">cc pr</B
> followed by <span class="acronym">ESC ESC</SPAN
>. This is not an unambiguous prefix,
since the prefix &quot;pro&quot; is common to both filenames, so the shell
only completes out to <b class="emphasis.bold">cc pro</B
>.  You need to type more letters
to disambiguate, so you type <b class="emphasis.bold">g</B
> and hit <span class="acronym">ESC ESC</SPAN
> again. Then the shell
completes out to &quot;<b class="emphasis.bold">cc program.c</B
> &quot;, leaving the extra space for you
to type in other filenames or options.<a class="indexterm" name="AUTOID-2608"></A
></P
><p class="para"><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-FILENAME-EXPANSION"></A
>A related command is <span class="acronym">ESC</SPAN
> <code class="literal">*</CODE
>, which expands the prefix to all
possible choices. <span class="acronym">ESC</SPAN
> <code class="literal">*</CODE
> acts like the standard 
<code class="literal">*</CODE
> shell wildcard character except that it expands the choices
for you to see and does not execute the command. In the above
example, if you type <span class="acronym">ESC</SPAN
> <code class="literal">*</CODE
> instead of <span class="acronym">ESC ESC</SPAN
>, the shell will expand
to &quot;<b class="emphasis.bold">cc problem.c program.c</B
> &quot;. If you type <span class="acronym">ESC</SPAN
> <code class="literal">=</CODE
> instead of
<span class="acronym">ESC</SPAN
> <code class="literal">*</CODE
>, 
you will see a numbered list of expansions printed to standard error.<a class="indexterm" name="AUTOID-2626"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-2-SECT-2.6">2.3.6 Miscellaneous Commands</A
></H3
><p class="para">Several miscellaneous commands complete emacs editing mode;
they are shown in 
<a class="xref" href="#KSH-CH-2-TAB-4" title="Emacs-mode Miscellaneous Commands">Table 2.5</A
>.</P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-2-TAB-4">Table 2.5: Emacs-mode Miscellaneous Commands</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Command</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-J]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Same as RETURN</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-L]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Redisplay the line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-M]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Same as RETURN</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-O]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Same as RETURN, then display next line in history file</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-T]</KBD
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Transpose two characters to the right of point and move point forward
by one[8]</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-U]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Repeat the following command four times</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-V]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Print the version of the Korn shell</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-W]</KBD
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Delete (&quot;wipe&quot;) all characters between point and &quot;mark&quot;. &quot;Mark&quot; is
discussed later in this section.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-X]</KBD
> <kbd class="keycap">[CTRL-X]</KBD
></TD
><td class="entry" rowspan="1" colspan="1">Exchange point and mark</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-]</KBD
>[</TD
><td class="entry" rowspan="1" colspan="1">Same as ESC (most keyboards)</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="keycap">[CTRL-]</KBD
>] x</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Search forward on current line for x, where x is any character</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><span class="acronym">ESC</SPAN
></TD
><td class="entry" rowspan="1" colspan="1">Change word after point to all capital letters</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><span class="acronym">ESC</SPAN
> l</TD
><td class="entry" rowspan="1" colspan="1">Change word after point to all lowercase letters</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><span class="acronym">ESC</SPAN
> p</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Save all characters between point and mark as if they were deleted</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><span class="acronym">ESC</SPAN
> .</TD
><td class="entry" rowspan="1" colspan="1">Insert last word in previous command line after point</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><span class="acronym">ESC _</SPAN
></TD
><td class="entry" rowspan="1" colspan="1">Same as above</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><span class="acronym">ESC CTRL</SPAN
>-]<em class="emphasis">x</EM
></TD
><td class="entry" rowspan="1" colspan="1">Search backward for <em class="emphasis">x</EM
>, where <em class="emphasis">x</EM
> is any character</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><span class="acronym">ESC SPACE</SPAN
></TD
><td class="entry" rowspan="1" colspan="1">Set mark at point</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><span class="acronym">ESC</SPAN
>#</TD
><td class="entry" rowspan="1" colspan="1">Insert line in history file for future editing</TD
></TR
></TBODY
></TABLE
><blockquote class="footnote"><p class="para">[8] <kbd class="keycap">[CTRL-T]</KBD
> behaves slightly 
differently if you put <b class="emphasis.bold">set -o gmacs</B
> 
(instead of <b class="emphasis.bold">emacs</B
>)
in your <em class="emphasis">.profile</EM
>. In this case, it will transpose
the two characters to the left of point, leaving point unmoved.
This is the only difference between emacs and gmacs modes;
the latter conforms to the James Gosling version 
of the <em class="emphasis">emacs</EM
> editor (a.k.a. Unipress <em class="emphasis">emacs</EM
>).
Note: neither of these behaves like <kbd class="keycap">[CTRL-T]</KBD
> in
GNU <em class="emphasis">emacs</EM
>, which transposes the characters on either side
of point.</P
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-2734"></A
>Several of these commands may clash with terminal interface
control keys on your system. <kbd class="keycap">[CTRL-U]</KBD
> is the default key for
&quot;kill line&quot; on most versions of UNIX.<a class="indexterm" name="AUTOID-2738"></A
><a class="indexterm" name="AUTOID-2742"></A
>
BSD-derived systems use <kbd class="keycap">[CTRL-V]</KBD
> and <kbd class="keycap">[CTRL-W]</KBD
> as default
settings for the &quot;quote next character&quot; and &quot;word erase&quot;
terminal interface functions respectively. <kbd class="keycap">[CTRL-V]</KBD
> is particularly
confusing, since it is meant to override other 
terminal
interface control keys but has no effect on emacs-mode
commands.<a class="indexterm" name="AUTOID-2747"></A
><a class="indexterm" name="AUTOID-2750"></A
><a class="indexterm" name="AUTOID-2753"></A
><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-REPEAT-COUNTS"></A
></P
><p class="para">A few miscellaneous commands are worth discussing, even though they may
not be among the most useful emacs-mode commands.  </P
><p class="para"><kbd class="keycap">[CTRL-O]</KBD
> is useful for repeating a sequence of commands you have
already entered. Just go back to the first command in the sequence
and press <kbd class="keycap">[CTRL-O]</KBD
> instead of RETURN. This will execute the command
and bring up the next command in the history file. Press <kbd class="keycap">[CTRL-O]</KBD
>
again to enter this command and bring up the next one. Repeat this
until you see the last command in the sequence; then just hit RETURN.</P
><p class="para"><a class="indexterm" name="AUTOID-2765"></A
><kbd class="keycap">[CTRL-U]</KBD
>, if it doesn't perform the line-delete function of your
system's terminal interface, repeats the next command
four times.
If you type <kbd class="keycap">[CTRL-U]</KBD
> twice, the repeat factor becomes 16; for 3 <kbd class="keycap">[CTRL-U]</KBD
>s it's
64; and so on. 
<kbd class="keycap">[CTRL-U]</KBD
> is possibly most useful when navigating through your history
file. If you want to recall a command that you entered a while
ago, you could type <kbd class="keycap">[CTRL-U]</KBD
> <kbd class="keycap">[CTRL-P]</KBD
> to go back through the history file 
four lines at a time;
you could think of this as a &quot;fast rewind&quot; through your command
history.  </P
><p class="para">Another possible use of <kbd class="keycap">[CTRL-U]</KBD
> is when you want to 
go from one end of a long pathname to the other. Unlike vi-mode,
emacs-mode does not have a concept of &quot;word&quot; that is flexible enough
to distinguish between pathnames and filename components.
The emacs-mode word
motion commands (<span class="acronym">ESC</SPAN
> b and <span class="acronym">ESC</SPAN
> f) will move through a pathname
only one component at a time, because emacs-mode treats the slash as
a word separator. You can use <kbd class="keycap">[CTRL-U]</KBD
> to help get around this limitation.
If you have a line that looks like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">ls -l /a/very/long/pathname/filename<u class="cursor"> </U
></B
></PRE
></BLOCKQUOTE
></P
><p class="para">and you need to go back and change &quot;very&quot; to &quot;really&quot;
you can type <kbd class="keycap">[CTRL-U]</KBD
> <span class="acronym">ESC</SPAN
> b and your cursor will end up here:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">ls -l /a/<u class="cursor">v</U
>ery/long/pathname/filename</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Then you can make the change:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">ls -l /a/really<u class="cursor">/</U
>long/pathname/filename</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Judicious use of <kbd class="keycap">[CTRL-U]</KBD
> can save you a few keystrokes, but considering
the small amount of information you manipulate when you edit
command lines, it's probably not an incredibly vital feature.
Often, holding down a key to repeat it is just
as effective as <kbd class="keycap">[CTRL-U]</KBD
>. Because you'll probably have to 
redefine the
terminal driver's line erase key before you can use <kbd class="keycap">[CTRL-U]</KBD
>, it's
probably better to do without <kbd class="keycap">[CTRL-U]</KBD
>.<a class="indexterm" name="AUTOID-2799"></A
></P
><p class="para"><a class="indexterm" name="AUTOID-2801"></A
><a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-MARK"></A
>The mark mentioned in the explanation of <kbd class="keycap">[CTRL-W]</KBD
> should be familiar
to <em class="emphasis">emacs</EM
> editor users, but its function in emacs-mode is
a subset of that in the full editor.
Emacs-mode keeps track of the place at which the last delete
was performed (whether a delete character, word, line, or whatever);
this place is called the <em class="emphasis">mark</EM
>. If nothing has been deleted
on the current line, mark defaults to the beginning of the line.
You can also set the mark to where your cursor is by typing <span class="acronym">ESC</SPAN
> SPACE.<a class="indexterm" name="KSH-CH-2-IX-EMACS-MODE-EXCH-POINT-AND-MARK"></A
>
<kbd class="keycap">[CTRL-X]</KBD
> <kbd class="keycap">[CTRL-X]</KBD
> (<kbd class="keycap">[CTRL-X]</KBD
> hit twice) causes the Korn shell to swap point and mark,
i.e., to move your cursor to where the mark is and reset mark to 
where your cursor was before you typed <kbd class="keycap">[CTRL-X]</KBD
> <kbd class="keycap">[CTRL-X]</KBD
>.</P
><p class="para">The mark concept is not extremely useful because
of the small amount of &quot;distance&quot; to travel in command lines.
But if you ever have to make a series of changes in the same
place in a line, <kbd class="keycap">[CTRL-X]</KBD
> <kbd class="keycap">[CTRL-X]</KBD
> will take you back there. In 
the previous example, if you wanted to change &quot;really&quot; to
&quot;monumentally&quot;, one way would be to type <kbd class="keycap">[CTRL-X]</KBD
> <kbd class="keycap">[CTRL-X]</KBD
> to return
to the beginning of &quot;really&quot;:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">ls -l /a/<u class="cursor">r</U
>eally/long/pathname/filename</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Then you could type <span class="acronym">ESC</SPAN
> d to delete &quot;really&quot; and make the change.
Of course, you could do this faster by typing <span class="acronym">ESC</SPAN
> <span class="acronym">DEL</SPAN
>
instead of <kbd class="keycap">[CTRL-X]</KBD
> <kbd class="keycap">[CTRL-X]</KBD
> and <span class="acronym">ESC</SPAN
> d.<a class="indexterm" name="AUTOID-2834"></A
><a class="indexterm" name="AUTOID-2835"></A
></P
><p class="para"><a class="indexterm" name="AUTOID-2837"></A
>Of the case-changing commands,
<span class="acronym">ESC</SPAN
> l is useful when you hit the CAPS LOCK key by accident and
don't notice it immediately. Since all-caps words aren't used
too often in the UNIX world, you may not use <span class="acronym">ESC</SPAN
> c very often.</P
><p class="para">If it seems like there are too many synonyms for RETURN,
bear in mind that <kbd class="keycap">[CTRL-M]</KBD
> is actually the same (ASCII) character as
RETURN, and that <kbd class="keycap">[CTRL-J]</KBD
> is actually the same as LINEFEED, which UNIX
usually accepts in lieu of RETURN anyway.</P
><p class="para"><span class="acronym">ESC</SPAN
> <code class="literal">.</CODE
> and <span class="acronym">ESC</SPAN
> _ are useful if you want to run several commands
on a given file. The usual UNIX convention is that a filename
is the last argument to a command. Therefore you can save typing
by just entering each command followed by SPACE and then typing
<span class="acronym">ESC</SPAN
> <code class="literal">.</CODE
> or <span class="acronym">ESC</SPAN
> _.  For example, say you want to examine a file
using <em class="emphasis">more</EM
>, so you type:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">more myfilewithaverylongname</B
></PRE
></BLOCKQUOTE
></P
><p class="para">Then you decide you want to print it, so you type the print command
<em class="emphasis">lp</EM
>. You can avoid typing the very long name by typing
<b class="emphasis.bold">lp</B
> followed by a space and then 
<span class="acronym">ESC</SPAN
> <code class="literal">.</CODE
> or <span class="acronym">ESC</SPAN
> _; the Korn shell will
insert <em class="emphasis">myfilewithaverylongname</EM
> for you.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-2-SECT-2.7">2.3.7 Keyboard Shortcuts with Aliases</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-2866"></A
><a class="indexterm" name="AUTOID-2869"></A
>Finally, emacs-mode has an interesting way of defining keyboard shortcuts for
commonly used commands by interacting
with the Korn shell's alias facility, as described in the next
chapter. Here's how it works: if you define an alias
called _<em class="emphasis">x</EM
>, where <em class="emphasis">x</EM
> is a letter, then emacs-mode will expand the alias
when you hit <span class="acronym">ESC</SPAN
> <em class="emphasis">x</EM
>. The expansion will appear on your screen, but
the Korn shell will not run the command, leaving you free to type more or
just hit RETURN to run it. We don't find this particularly useful,
since you can just define an alias in the normal way instead.<a class="indexterm" name="AUTOID-2875"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch02_02.htm" webstripperlinkwas="ch02_02.htm" title="2.2 The History File"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 2.2 The History File" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" title="Learning the Korn Shell"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Learning the Korn Shell" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch02_04.htm" webstripperlinkwas="ch02_04.htm" title="2.4 Vi Editing Mode"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 2.4 Vi Editing Mode" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">2.2 The History File</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">2.4 Vi Editing Mode</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="../upt/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="../sedawk/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
