<html><head>
<title>[Chapter 5] 5.5 while and until</TITLE>
<meta name="DC.title" content="Learning the Korn Shell"><meta name="DC.creator" content="Bill Rosenblatt"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-03T21:09:52Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-054-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="5. Flow Control"><link rel="prev" href="ch05_04.htm" webstripperlinkwas="ch05_04.htm" title="5.4 select"><link rel="next" href="ch06_01.htm" webstripperlinkwas="ch06_01.htm" title="6. Command-line Options and Typed Variables"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="Learning the Korn Shell" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,66" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_04.htm" webstripperlinkwas="ch05_04.htm" title="5.4 select"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 5.4 select" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 5<br>Flow Control</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="CHAPTER" href="ch06_01.htm" webstripperlinkwas="ch06_01.htm" title="6. Command-line Options and Typed Variables"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 6. Command-line Options and Typed Variables" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="KSH-CH-5-SECT-5">5.5 while and until</A
></H2
><p class="para"><a class="indexterm" name="KSH-CH-5-IX-WHILE"></A
><a class="indexterm" name="KSH-CH-5-IX-UNTIL"></A
>The remaining two flow control constructs the Korn shell provides
are <b class="emphasis.bold">while</B
> and <b class="emphasis.bold">until</B
>.  
These are similar; they
both allow a section of code to be run repetitively while (or until)
a certain condition holds true.  <a class="indexterm" name="AUTOID-9143"></A
><a class="indexterm" name="AUTOID-9145"></A
>
They also resemble
analogous constructs in Pascal (<b class="emphasis.bold">while</B
>/<b class="emphasis.bold">do</B
>
and <b class="emphasis.bold">repeat</B
>/<b class="emphasis.bold">until</B
>) and C (<b class="emphasis.bold">while</B
> and <b class="emphasis.bold">do</B
>/<b class="emphasis.bold">until</B
>).</P
><p class="para"><b class="emphasis.bold">while</B
> and <b class="emphasis.bold">until</B
> are actually most useful when combined
with features we will see in the next chapter, such as integer
arithmetic, input/output of variables, and command-line processing.
Yet we can show a useful example even with the machinery we have
covered so far.</P
><p class="para"><a class="indexterm" name="AUTOID-9158"></A
>The syntax for <b class="emphasis.bold">while</B
> is:</P
><p class="para"><blockquote class="screen"><pre class="screen">while <em class="emphasis">condition</EM
>
do
    <em class="emphasis">statements...</EM
>
done</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-9167"></A
>For <b class="emphasis.bold">until</B
>, just substitute <b class="emphasis.bold">until</B
> for <b class="emphasis.bold">while</B
> in the above example.<a class="indexterm" name="AUTOID-9173"></A
>
As with <b class="emphasis.bold">if</B
>, the <em class="emphasis">condition</EM
> is really a list of
<em class="emphasis">statements</EM
> that are run;
the exit status of the last one is used as the value of
the condition. You can use a conditional with <b class="emphasis.bold">[[</B
> and <b class="emphasis.bold">]]</B
>
here, just as you can with <b class="emphasis.bold">if</B
>.</P
><p class="para"><a class="indexterm" name="AUTOID-9183"></A
><a class="indexterm" name="AUTOID-9186"></A
>Note that the <em class="emphasis">only</EM
> difference between
<b class="emphasis.bold">while</B
> and <b class="emphasis.bold">until</B
> is the way the condition is handled.
In <b class="emphasis.bold">while</B
>, the loop executes as long as the condition is true;
in <b class="emphasis.bold">until</B
>, it runs as long as the condition is false.
So far, so familiar. <a class="indexterm" name="AUTOID-9194"></A
><a class="indexterm" name="AUTOID-9196"></A
>
<b class="emphasis.bold">BUT</B
>: the <b class="emphasis.bold">until</B
> condition is checked
at the <em class="emphasis">top</EM
> of the loop, <em class="emphasis">not</EM
> at the bottom as it is
in analogous constructs in C and Pascal.</P
><p class="para">The result is that you can convert any <b class="emphasis.bold">until</B
> into a <b class="emphasis.bold">while</B
>
by simply negating the condition. The only place where <b class="emphasis.bold">until</B
>
might be better is something like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">until <em class="emphasis">command</EM
>; do
    <em class="emphasis">statements...</EM
>
done</PRE
></BLOCKQUOTE
></P
><p class="para">The meaning of this is essentially, &quot;Do <em class="emphasis">statements</EM
> until
<em class="emphasis">command</EM
> runs correctly.&quot; This is not, in our opinion, a likely
contingency.  <a class="indexterm" name="AUTOID-9213"></A
>
Therefore we will use <b class="emphasis.bold">while</B
> throughout the rest of this book.</P
><p class="para">Here is a task that is a good candidate for <b class="emphasis.bold">while</B
>.</P
><div class="task"><h4>Task 5.5</H4
><blockquote class="taskinfo"><p class="para"><a class="indexterm" name="AUTOID-9220"></A
>Implement a simplified version of the shell's built-in
<b class="emphasis.bold">whence</B
> command.</P
></BLOCKQUOTE
><a class="indexterm" name="KSH-CH-5-IX-PATH"></A
><a class="indexterm" name="KSH-CH-5-IX-ENVVARS-PATH"></A
><p class="para">By &quot;simplified,&quot; we mean that we will implement only the part
that checks all of the directories in your <b class="emphasis.bold">PATH</B
> for the command
you give as argument (we won't implement checking for aliases,
built-in commands, etc.).</P
><p class="para">We can do this by picking off the directories in <b class="emphasis.bold">PATH</B
> one by
one, using one of the shell's pattern-matching operators, and
seeing if there is a file with the given name in the directory
that you have permission to execute. Here is the code:</P
><p class="para"><blockquote class="screen"><pre class="screen">path=$PATH:
dir=${path%%:*}
while [[ -n $path ]]; do
    if [[ -x $dir/$1 &amp;&amp; ! -d $dir/$1 ]]; then
        print &quot;$dir/$1&quot;
        return
    fi
    path=${path#*:}
    dir=${path%%:*}
done
return 1</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-9235"></A
><a class="indexterm" name="AUTOID-9238"></A
><a class="indexterm" name="AUTOID-9241"></A
><a class="indexterm" name="AUTOID-9244"></A
><a class="indexterm" name="AUTOID-9247"></A
><a class="indexterm" name="AUTOID-9251"></A
><a class="indexterm" name="AUTOID-9255"></A
>The first line of this code saves <b class="emphasis.bold">$PATH</B
> in <b class="emphasis.bold">path</B
>, our own temporary
copy. We append a colon to the end so that every directory in <b class="emphasis.bold">$path</B
>
ends in a colon (in <b class="emphasis.bold">$PATH</B
>, colons are used only <em class="emphasis">between</EM
>
directories); subsequent code depends on this being the case.</P
><p class="para">The next line picks the first directory off of <b class="emphasis.bold">$path</B
>
by using the operator that deletes the longest match to the pattern
given. In this case, we delete the longest match to the pattern
<code class="literal">:*</CODE
>, i.e., a colon followed by anything. This gives us the first
directory in <b class="emphasis.bold">$path</B
>, which we store in the variable <b class="emphasis.bold">dir</B
>.</P
><p class="para">The condition in the <b class="emphasis.bold">while</B
> loop checks if <b class="emphasis.bold">$path</B
> is non-null.
If it is not null, it constructs the full pathname <b class="emphasis.bold">$dir/$1</B
> and sees if
there is a file by that name for which you have execute permission
(and that is not a directory).
If so, it prints the full pathname and exits the routine with
a 0 (&quot;OK&quot;) exit status.</P
><p class="para">If a file is not found, then this code is run:</P
><p class="para"><blockquote class="screen"><pre class="screen">path=${path#*:}
dir=${path%%:*}</PRE
></BLOCKQUOTE
></P
><p class="para">The first of these uses another shell string operator: this one
deletes the shortest match to the pattern given
from the front of the string. By now, this type of operator should
be familiar. This line deletes the front directory from <b class="emphasis.bold">$path</B
>
and assigns the result back to <b class="emphasis.bold">path</B
>.
The second line is the same as before the <b class="emphasis.bold">while</B
>: it finds
the (new) front directory in <b class="emphasis.bold">$path</B
> and assigns it to <b class="emphasis.bold">dir</B
>.
This sets up the loop for another iteration.</P
><p class="para">Thus, the code loops through all of the directories in <b class="emphasis.bold">PATH</B
>.
It exits when it finds a matching executable file or when it has
&quot;eaten up&quot; the entire <b class="emphasis.bold">PATH</B
>.
If no matching executable file is found, it prints nothing
and exits with an error status.<a class="indexterm" name="AUTOID-9285"></A
><a class="indexterm" name="AUTOID-9286"></A
></P
><p class="para"><a class="indexterm" name="KSH-CH-5-IX-FILE-COMMAND"></A
>We can enhance this script a bit by taking advantage of the UNIX
utility <em class="emphasis">file</EM
>(1). <em class="emphasis">file</EM
> examines files given as arguments
and determines what type they are, based on the file's <em class="emphasis">magic
number</EM
> and various heuristics (educated guesses). A magic number
is a field in the header of an executable file that the linker sets
to identify what type of executable it is.</P
><p class="para"><a class="indexterm" name="AUTOID-9294"></A
><a class="indexterm" name="AUTOID-9297"></A
>If <em class="emphasis">filename</EM
> is an executable program (compiled from C or some other
language), then typing <b class="emphasis.bold">file</B
> <em class="emphasis">filename</EM
> produces output similar to this:</P
><p class="para"><blockquote class="screen"><pre class="screen"><em class="emphasis">filename</EM
>: ELF 32-bit LSB executable 80386 Version 1</PRE
></BLOCKQUOTE
></P
><p class="para">However, if <em class="emphasis">filename</EM
> is not an executable program, it will examine
the first few lines and try to guess what kind of information the
file contains.  <a class="indexterm" name="AUTOID-9307"></A
><a class="indexterm" name="AUTOID-9309"></A
>
If the file contains text (as opposed to binary data),
<em class="emphasis">file</EM
> will look for indications that it is English, shell
commands, C, FORTRAN, <em class="emphasis">troff</EM
>(1) input, and various other things.
<em class="emphasis">file</EM
> is wrong sometimes, but it is mostly correct.</P
><p class="para">We can just substitute <em class="emphasis">file</EM
> for <em class="emphasis">print</EM
>
to print a more informative message in our script:</P
><p class="para"><blockquote class="screen"><pre class="screen">path=$PATH
dir=${path%%:*}
while [[ -n $path ]]; do
    if [[ -x $dir/$1 &amp;&amp; ! -d $dir/$1 ]]; then
	  file $dir/$1
	  return
    fi
    path=${path#*:}
    dir=${path%%:*}
done
return 1</PRE
></BLOCKQUOTE
></P
><p class="para">Assume that <em class="emphasis">fred</EM
> is an executable file in the directory
<em class="emphasis">/usr/bin</EM
>, and that <em class="emphasis">bob</EM
> is a shell script in <em class="emphasis">/usr/local/bin</EM
>.
Then typing <b class="emphasis.bold">file fred</B
> produces this output:</P
><p class="para"><blockquote class="screen"><pre class="screen">/usr/bin/fred: ELF 32-bit LSB executable 80386 Version 1</PRE
></BLOCKQUOTE
></P
><p class="para">And typing <b class="emphasis.bold">file bob</B
> has this result:</P
><p class="para"><blockquote class="screen"><pre class="screen">/usr/local/bin/bob: commands text</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-9332"></A
><a class="indexterm" name="AUTOID-9333"></A
><a class="indexterm" name="AUTOID-9336"></A
>Before we end this chapter, we have two final notes. First, 
notice that the statement
<b class="emphasis.bold">dir=${path%%:*}</B
> appears in two places, before the start
of the loop and as the last statement in the loop's body.<a class="indexterm" name="AUTOID-9340"></A
><a class="indexterm" name="AUTOID-9342"></A
>
Some diehard C hackers are offended by this Pascal-like coding
technique. Certain features of the C language allow programmers
to create loops of the form:</P
><p class="para"><blockquote class="screen"><pre class="screen">while <em class="emphasis">iterative-step</EM
>; <em class="emphasis">condition</EM
>; do
    ...
done</PRE
></BLOCKQUOTE
></P
><p class="para">This is the same as the form of the script above: the 
<em class="emphasis">iterative-step</EM
> runs just before the <em class="emphasis">condition</EM
>
each time around the loop. </P
><p class="para"><a class="indexterm" name="AUTOID-9352"></A
>We can write our script this way:</P
><p class="para"><blockquote class="screen"><pre class="screen">path=$PATH
while dir=${path%%:*}; [[ -n $path ]]; do
    if [[ -x $dir/$1 &amp;&amp; ! -d $dir/$1 ]]; then
	file $dir/$1
	return
    fi
    path=${path#*:}
done
return 1</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-9358"></A
>Although this example doesn't show great programming style, it does make the
code smaller-hence its popularity with C programmers. 
Make sure you understand that our script is functionally identical
to the previous script.</P
><p class="para"><a class="indexterm" name="AUTOID-9361"></A
>Finally, just to show how little difference there is between
<b class="emphasis.bold">while</B
> and <b class="emphasis.bold">until</B
>, we note that the line</P
><p class="para"><blockquote class="screen"><pre class="screen">until [[ ! -n $path ]]; do</PRE
></BLOCKQUOTE
></P
><p class="para">can be used in place of</P
><p class="para"><blockquote class="screen"><pre class="screen">while [[ -n $path ]]; do</PRE
></BLOCKQUOTE
></P
><p class="para">with identical results.</P
><p class="para">We'll see additional examples of <b class="emphasis.bold">while</B
> in the next chapter.<a class="indexterm" name="AUTOID-9373"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_04.htm" webstripperlinkwas="ch05_04.htm" title="5.4 select"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 5.4 select" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" title="Learning the Korn Shell"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Learning the Korn Shell" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="CHAPTER" href="ch06_01.htm" webstripperlinkwas="ch06_01.htm" title="6. Command-line Options and Typed Variables"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 6. Command-line Options and Typed Variables" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">5.4 select</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">6. Command-line Options and Typed Variables</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="../upt/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="../sedawk/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
