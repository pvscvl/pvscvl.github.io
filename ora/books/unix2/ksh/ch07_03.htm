<html><head>
<title>[Chapter 7] 7.3 Command-line Processing</TITLE>
<meta name="DC.title" content="Learning the Korn Shell"><meta name="DC.creator" content="Bill Rosenblatt"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-03T21:13:38Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-054-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch07_01.htm" webstripperlinkwas="ch07_01.htm" title="7. Input/Output and Command-line Processing"><link rel="prev" href="ch07_02.htm" webstripperlinkwas="ch07_02.htm" title="7.2 String I/O"><link rel="next" href="ch08_01.htm" webstripperlinkwas="ch08_01.htm" title="8. Process Handling"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="Learning the Korn Shell" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,66" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch07_02.htm" webstripperlinkwas="ch07_02.htm" title="7.2 String I/O"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 7.2 String I/O" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 7<br>Input/Output and Command-line Processing</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="CHAPTER" href="ch08_01.htm" webstripperlinkwas="ch08_01.htm" title="8. Process Handling"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 8. Process Handling" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="KSH-CH-7-SECT-3">7.3 Command-line Processing</A
></H2
><p class="para"><a class="indexterm" name="AUTOID-12368"></A
><a class="indexterm" name="AUTOID-12371"></A
><a class="indexterm" name="KSH-CH-7-IX-COMMAND-LINE-PROCESSING"></A
>We've seen how the shell uses
<b class="emphasis.bold">read</B
> to process input lines: it deals with single
quotes (<code class="literal">' '</CODE
>), double quotes (<code class="literal">&quot; &quot;</CODE
>), and backslashes
(<code class="literal">\</CODE
>); it separates lines into
words, according to delimiters in the environment variable <b class="emphasis.bold">IFS</B
>;
and it assigns the words to shell variables. We can think of this
process as a subset of the things the shell does when processing
<em class="emphasis">command lines</EM
>.</P
><p class="para">We've touched upon command-line processing (see <a class="xref" href="#KSH-CH-7-FIG-0" title="Steps in Command-line Processing">Figure 7.1</A
>) throughout this book; now is a good
time to make the whole thing explicit.
[7]<a class="indexterm" name="AUTOID-12390"></A
><a class="indexterm" name="AUTOID-12392"></A
>
Each line that the shell
reads from the standard input or a script is called a <em class="emphasis">pipeline</EM
>;
it contains one or more <em class="emphasis">commands</EM
> separated by zero or more pipe
characters (<b class="emphasis.bold">|</B
>). For each pipeline it reads, the shell 
breaks it up into commands, sets up the I/O for the
pipeline, then does the following for each command:<a class="indexterm" name="AUTOID-12398"></A
></P
><blockquote class="footnote"><p class="para">[7] Even this explanation is slightly simplified to elide the most petty details,
e.g., &quot;middles&quot; and &quot;ends&quot; of compound commands, special characters 
within <b class="emphasis.bold">[[</B
>...<b class="emphasis.bold">]]</B
> and <b class="emphasis.bold">((</B
>...<b class="emphasis.bold">))</B
> constructs, etc.
The last word on this subject is the reference book, 
<em class="emphasis">The KornShell Command and Programming Language</EM
>,
by Morris Bolsky and David Korn, published by Prentice-Hall.</P
></BLOCKQUOTE
><ol class="orderedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12404"></A
><a class="indexterm" name="AUTOID-12407"></A
>Splits the command into <em class="emphasis">tokens</EM
> that are separated by
the fixed set of <em class="emphasis">metacharacters</EM
>: SPACE, <span class="acronym">TAB</SPAN
>, NEWLINE, <code class="literal">;</CODE
>, 
<b class="emphasis.bold">(</B
><code class="literal">,</CODE
> <b class="emphasis.bold">)</B
>,
<b class="emphasis.bold">&lt;</B
>, <b class="emphasis.bold">&gt;</B
>, <b class="emphasis.bold">|</B
>, and <b class="emphasis.bold">&amp;</B
>. Types of tokens include <em class="emphasis">words</EM
>, <em class="emphasis">keywords</EM
>,
I/O redirectors, and semicolons.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12424"></A
>Checks the first token of each command to see if it is a <em class="emphasis">keyword</EM
>
with no quotes or backslashes. If it's an opening
keyword (<b class="emphasis.bold">if</B
> and other control-structure openers, <b class="emphasis.bold">function</B
>,
<b class="emphasis.bold">{</B
>, <b class="emphasis.bold">(</B
>, <b class="emphasis.bold">((</B
>, or <b class="emphasis.bold">[[</B
>), then the command is actually
a <em class="emphasis">compound command</EM
>. The shell sets things up internally
for the compound command, reads the next command, and starts
the process again. If the keyword isn't a compound command opener
(e.g., is a control-structure &quot;middle&quot; like <b class="emphasis.bold">then</B
>, <b class="emphasis.bold">else</B
>, or <b class="emphasis.bold">do</B
>,
an &quot;end&quot; like <b class="emphasis.bold">fi</B
> or <b class="emphasis.bold">done</B
>, or a logical operator), the shell
signals a syntax error.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12442"></A
>Checks the first word of each command against the list of <em class="emphasis">aliases</EM
>.
If a match is found, it substitutes the alias' definition and <em class="emphasis">goes back to
Step 1</EM
>; otherwise it goes on to Step 4.<a class="indexterm" name="AUTOID-12447"></A
>
This scheme allows <em class="emphasis">recursive</EM
> aliases; see <a class="xref" href="ch03_01.htm" webstripperlinkwas="ch03_01.htm" title="Customizing Your Environment">Chapter 3</A
>.
It also allows aliases for keywords to be defined, e.g.,
<b class="emphasis.bold">alias aslongas=while</B
> or <b class="emphasis.bold">alias procedure=function</B
>.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12456"></A
><a class="indexterm" name="AUTOID-12458"></A
><a class="indexterm" name="AUTOID-12460"></A
><a class="indexterm" name="AUTOID-12462"></A
>Substitutes the user's home directory (<b class="emphasis.bold">$HOME</B
>) for <em class="emphasis">tilde</EM
> if
it is at the beginning of a word.  Substitutes <em class="emphasis">user</EM
>'s home
directory for <code class="literal">~</CODE
><em class="emphasis">user</EM
><b class="emphasis.bold"></B
>.
[8]</P
><blockquote class="footnote"><p class="para">[8] <a class="indexterm" name="AUTOID-12473"></A
><a class="indexterm" name="AUTOID-12475"></A
><a class="indexterm" name="AUTOID-12478"></A
><a class="indexterm" name="AUTOID-12481"></A
><a class="indexterm" name="AUTOID-12484"></A
><a class="indexterm" name="AUTOID-12487"></A
><a class="indexterm" name="AUTOID-12489"></A
>Two obscure variations on this: the shell substitutes the current directory (<b class="emphasis.bold">$PWD</B
>) for <b class="emphasis.bold">~+</B
> and the previous directory
(<b class="emphasis.bold">$OLDPWD</B
>) for <b class="emphasis.bold">~-</B
>.</P
></BLOCKQUOTE
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12497"></A
>Performs <em class="emphasis">parameter (variable) substitution</EM
> for any expression 
that starts with a dollar sign (<b class="emphasis.bold">$</B
>).</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12504"></A
>Does <em class="emphasis">command substitution</EM
> for any expression of the form
<b class="emphasis.bold">$(</B
><em class="emphasis">string</EM
><b class="emphasis.bold">)</B
>.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12513"></A
>Evaluates <em class="emphasis">arithmetic expressions</EM
> of the 
form <b class="emphasis.bold">$((</B
><em class="emphasis">string</EM
><b class="emphasis.bold">))</B
>.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12522"></A
><a class="indexterm" name="AUTOID-12525"></A
>Takes the parts of the line that resulted from parameter, command,
and arithmetic substitution and splits them
into words again. This time it uses the
characters in <b class="emphasis.bold">$IFS</B
> as delimiters instead
of the set of metacharacters in Step 1.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12532"></A
>
Performs <em class="emphasis">filename generation</EM
>, a.k.a. 
<em class="emphasis">wildcard expansion</EM
>,
for any occurrences of <code class="literal">*</CODE
>, <code class="literal">?</CODE
>, 
and <b class="emphasis.bold">[/]</B
> pairs.  
<a class="indexterm" name="AUTOID-12540"></A
>

It also processes the regular
expression operators that we saw in <a class="xref" href="ch04_01.htm" webstripperlinkwas="ch04_01.htm" title="Basic Shell Programming">Chapter 4</A
>.

<h4 class="figure"><a class="title" name="KSH-CH-7-FIG-0">Figure 7.1: Steps in Command-line Processing</A
></H4
><img class="graphic" src="figs/korn0701.gif" webstripperlinkwas="figs/korn0701.gif" alt="Figure 7.1">&#13;</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12549"></A
><a class="indexterm" name="AUTOID-12552"></A
><a class="indexterm" name="AUTOID-12555"></A
><a class="indexterm" name="AUTOID-12558"></A
><a class="indexterm" name="AUTOID-12562"></A
><a class="indexterm" name="AUTOID-12564"></A
>Uses the first word as a command by looking up its source according
to the rest of the list in <a class="xref" href="ch04_01.htm" webstripperlinkwas="ch04_01.htm" title="Basic Shell Programming">Chapter 4</A
>, i.e., as a <em class="emphasis">built-in</EM
> command, 
then as a <em class="emphasis">function</EM
>, then
as a file in any of the directories in <b class="emphasis.bold">$PATH</B
>.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-12573"></A
>Runs the command after setting up I/O redirection and other such things.</P
></LI
></OL
><p class="para">That's a lot of steps&nbsp;- and it's not even the whole story!
But before we go on, an example should make this process clearer.<a class="indexterm" name="AUTOID-12578"></A
>
Assume that the following command has been run:</P
><p class="para"><blockquote class="screen"><pre class="screen">alias ll=&quot;ls -l&quot;</PRE
></BLOCKQUOTE
></P
><p class="para">Further assume that a file exists called <em class="emphasis">.hist537</EM
>
in user <b class="emphasis.bold">fred</B
>'s home directory, which is <em class="emphasis">/home/fred</EM
>,
and that there is a double-dollar-sign variable <b class="emphasis.bold">$$</B
> whose value is <b class="emphasis.bold">2537</B
> (we'll see what this special variable is in the next chapter).</P
><p class="para">Now let's see how the shell processes the following command:</P
><p class="para"><blockquote class="screen"><pre class="screen">ll $(whence cc) ~fred/.*$(($$%1000))</PRE
></BLOCKQUOTE
></P
><p class="para">Here is what happens to this line:</P
><ol class="orderedlist"><li class="listitem"><p class="para"><b class="emphasis.bold">ll $(whence cc) ~fred/.*$(($$%1000))</B
></P
><p class="para">Splitting the input into words.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">ll</B
> is not a keyword, so step 2 does nothing.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">ls -l $(whence cc) ~fred/.*$(($$%1000))</B
></P
><p class="para">Substituting <b class="emphasis.bold">ls -l</B
> for its alias &quot;ll&quot;.  The shell then repeats steps
1 through 3; step 2 splits the <b class="emphasis.bold">ls -l</B
> into two words.
[9]</P
><blockquote class="footnote"><p class="para">[9] Some of the shell's built-in aliases, however, seem to make
it through single quotes: <b class="emphasis.bold">true</B
>
(an alias for <b class="emphasis.bold">:</B
>, a &quot;do-nothing&quot; command that always returns
exit status 0), <b class="emphasis.bold">false</B
>
(an alias for <b class="emphasis.bold">let 0</B
>, which always returns exit status 1), 
and <b class="emphasis.bold">stop</B
> (an alias for <b class="emphasis.bold">kill -STOP</B
>).</P
></BLOCKQUOTE
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">ls -l $(whence cc) /home/fred/.*$(($$%1000))</B
></P
><p class="para">Expanding <b class="emphasis.bold">~fred</B
> into <em class="emphasis">/home/fred</EM
>.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">ls -l $(whence cc) /home/fred/.*$((2537%1000))</B
></P
><p class="para">Substituting <b class="emphasis.bold">2537</B
> for <b class="emphasis.bold">$$</B
>.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">ls -l 
/usr/bin/cc /home/fred/.*$((2537%1000))</B
></P
><p class="para">Doing command substitution on &quot;whence cc&quot;.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">ls -l /usr/bin/cc /home/fred/.*537</B
></P
><p class="para">Evaluating the arithmetic expression <b class="emphasis.bold">2537%1000</B
>.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">ls -l /usr/bin/cc /home/fred/.*537</B
></P
><p class="para">This step does nothing.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">ls -l /usr/bin/cc /home/fred/.hist537</B
></P
><p class="para">Substituting the filename for the wildcard expression .*<b class="emphasis.bold">537</B
>.</P
></LI
><li class="listitem"><p class="para">The command <b class="emphasis.bold">ls</B
> is found in <em class="emphasis">/usr/bin</EM
>.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">/usr/bin/ls</EM
> is run with the option -l and the two arguments.</P
></LI
></OL
><p class="para">Although this list of steps is fairly straightforward, it is not the 
whole story. There are still two ways to <em class="emphasis">subvert</EM
> the process:  
by quoting and by using the advanced command <b class="emphasis.bold">eval</B
>.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-7-SECT-3.1">7.3.1 Quoting</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-12658"></A
><a class="indexterm" name="AUTOID-12661"></A
><a class="indexterm" name="AUTOID-12664"></A
>You can think of quoting as a way of getting the shell to skip
some of the 11 steps above. In particular:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><b class="emphasis.bold">Single quotes</B
> (<code class="literal"> '&nbsp; '</CODE
>) bypass <em class="emphasis">everything</EM
> through 
Step 9&nbsp;- including aliasing.
[10]
All characters inside a pair of single quotes are untouched.
You can't have single quotes inside single quotes&nbsp;- not even 
if you precede them with backslashes.</P
><blockquote class="footnote"><p class="para">[10] However, as we saw in <a class="xref" href="ch01_01.htm" webstripperlinkwas="ch01_01.htm" title="Korn Shell Basics">Chapter 1</A
> <code class="literal">'\''</CODE
> 
(i.e., single quote, backslash, single quote, single quote)
acts pretty much like a single quote in the middle of a
single-quoted string; e.g., 
<code class="literal">'</CODE
><b class="emphasis.bold">abc</B
><code class="literal">'\''</CODE
><b class="emphasis.bold">def</B
><code class="literal">'</CODE
> evaluates 
to <b class="emphasis.bold">abc</B
><code class="literal">'</CODE
><b class="emphasis.bold">def</B
>.</P
></BLOCKQUOTE
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">Double quotes</B
> (<code class="literal">&quot; &quot;</CODE
>) bypass steps 1 through 4, plus steps 8 and 9. That is, they
ignore pipe characters, aliases, tilde substitution, wildcard expansion,
and splitting into words via delimiters (e.g., blanks)
inside the double quotes. Single quotes inside double quotes have
no effect. But double quotes do allow parameter substitution, 
command substitution, and arithmetic
expression evaluation. You can include a double quote inside a
double-quoted string by preceding it with a backslash
(<code class="literal">\</CODE
>). You must
also backslash-escape <b class="emphasis.bold">$</B
>, <code class="literal">`</CODE
> (the archaic
command substitution delimiter), and <b class="emphasis.bold">\</B
> itself.</P
></LI
></UL
><p class="para"><a class="xref" href="#KSH-CH-7-TAB-4" title="Examples of Quoting Rules">Table 7.5</A
>
contains some simple examples that show how these work; 
they assume that the statement <b class="emphasis.bold">dave=bob</B
> was run and that
user <b class="emphasis.bold">fred</B
>'s home directory is <em class="emphasis">/home/fred</EM
>.  </P
><p class="para">If you are wondering whether to use single or double quotes in 
a particular shell programming situation, it is safest to use single
quotes unless you specifically need parameter, command, 
or arithmetic substitution.<a class="indexterm" name="AUTOID-12699"></A
></P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-7-TAB-4">Table 7.5: Examples of Quoting Rules</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Expression</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Value</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">$dave</TD
><td class="entry" rowspan="1" colspan="1">bob</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">&quot;$dave&quot;</TD
><td class="entry" rowspan="1" colspan="1">bob</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">\\$dave</TD
><td class="entry" rowspan="1" colspan="1">$dave</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">'</CODE
>$dave<code class="literal">'</CODE
></TD
><td class="entry" rowspan="1" colspan="1">$dave</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">'</CODE
>$dave<code class="literal">'</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">'</CODE
>bob<code class="literal">'</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">~fred</TD
><td class="entry" rowspan="1" colspan="1">/home/fred</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">&quot;</CODE
>~fred<code class="literal">&quot;</CODE
></TD
><td class="entry" rowspan="1" colspan="1">~fred</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">'</CODE
>~fred<code class="literal">'</CODE
></TD
><td class="entry" rowspan="1" colspan="1">~fred</TD
></TR
></TBODY
></TABLE
><p class="para">Here's a more advanced example of command-line processing
that should give you deeper insight into the overall process.<a class="indexterm" name="KSH-CH-7-IX-PROMPTS-CUSTOM-CURRENT-DIRECTORY"></A
></P
><div class="task"><h4>Task 7.5</H4
><blockquote class="taskinfo"><p class="para">Customize your primary prompt string so that it contains
the current directory with tilde (<b class="emphasis.bold">~</B
>) notation.</P
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-PS1"></A
><a class="indexterm" name="KSH-CH-7-IX-ENVIRONMENT-VARIABLES-PS1"></A
>Recall from <a class="xref" href="ch04_01.htm" webstripperlinkwas="ch04_01.htm" title="Basic Shell Programming">Chapter 4</A
> that we found a simple way to set up
the prompt string <b class="emphasis.bold">PS1</B
> so that it always contains the
current directory:</P
><p class="para"><blockquote class="screen"><pre class="screen">PS1='($PWD)-&gt; '</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-TILDE-NOTATION"></A
><a class="indexterm" name="KSH-CH-7-IX-TILDE"></A
>One problem with this setup is that the resulting prompt strings
can get very long. One way to shorten them is to substitute tilde
notation for users' home directories.  
This cannot be done with a simple string expression analogous
to the above. The solution is somewhat complicated and takes
advantage of the command-line processing rules.</P
><p class="para">The basic idea is to create a &quot;wrapper&quot; around the <b class="emphasis.bold">cd</B
>
command, as we did in <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
>,
that installs the current directory with tilde notation
as the prompt string. Because <b class="emphasis.bold">cd</B
> is a built-in command,
the wrapper must be an alias in order to override it. But 
the code we need to insert tilde notation is too complicated
for an alias, so we'll use a function and then alias the function
as <b class="emphasis.bold">cd</B
>.  </P
><p class="para">We'll start with a function that, given a pathname
as argument, prints its equivalent in tilde notation if possible:</P
><p class="para"><blockquote class="screen"><pre class="screen">function tildize {
    if [[ $1 = $HOME* ]]; then
        print &quot;\~/${1#$HOME}&quot;
        return 0
    fi
    awk '{FS=&quot;:&quot;; print $1, $6}' /etc/passwd | 
        while read user homedir; do
            if [[ $homedir != / &amp;&amp; $1 = ${homedir}?(/*) ]]; then
                print &quot;\~$user/${1#$homedir}&quot;
                return 0
            fi
        done
    print &quot;$1&quot;
    return 1
}</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12777"></A
>The first <b class="emphasis.bold">if</B
> clause checks if the given pathname is under
the user's home directory. If so, it substitutes tilde (<b class="emphasis.bold">~</B
>) for
the home directory in the pathname and returns.</P
><p class="para"><a class="indexterm" name="AUTOID-12782"></A
><a class="indexterm" name="AUTOID-12784"></A
><a class="indexterm" name="AUTOID-12786"></A
>If not, we use the <em class="emphasis">awk</EM
> utility to extract the
first and sixth fields of the file <em class="emphasis">/etc/passwd</EM
>, which contain
users IDs and home directories, respectively. In this case,
<em class="emphasis">awk</EM
> acts like <em class="emphasis">cut</EM
>.  
The <b class="emphasis.bold">FS=</B
><code class="literal">&quot;</CODE
><b class="emphasis.bold">:</B
><code class="literal">&quot;</CODE
> is analogous to
<b class="emphasis.bold">-d:</B
>, which we saw in <a class="xref" href="ch04_01.htm" webstripperlinkwas="ch04_01.htm" title="Basic Shell Programming">Chapter 4</A
>, except that it prints the
values on each line separated by blanks, not colons (<code class="literal">:</CODE
>). </P
><p class="para"><a class="indexterm" name="AUTOID-12800"></A
><em class="emphasis">awk</EM
>'s output is fed into a <b class="emphasis.bold">while</B
> loop that checks
the pathname given as argument to see if it contains some user's
home directory. (The first part of the conditional expression
eliminates &quot;users&quot; like <b class="emphasis.bold">daemon</B
> and <b class="emphasis.bold">root</B
>, whose 
home directories are root and therefore are contained in every
full pathname.The second part matches home directories by themselves or
with some other directory appended (the <b class="emphasis.bold">?(/*)</B
> part.)) 
If a user's home directory is found, then 
<b class="emphasis.bold">~</B
><em class="emphasis">user</EM
><b class="emphasis.bold"></B
> is substituted for the full home directory in the
given pathname, the result is printed, and the function exits.<a class="indexterm" name="AUTOID-12810"></A
><a class="indexterm" name="AUTOID-12811"></A
></P
><p class="para">Finally, if the <b class="emphasis.bold">while</B
> loop exhausts all users without finding
a home directory that is a prefix of the given pathname, then
<b class="emphasis.bold">tildize</B
> simply echoes back its input.</P
><p class="para">Now that we have this function, you might think we could use
it in a command substitution expression like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">PS1='$(tildize $PWD)'</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12819"></A
>But this won't work, because the shell doesn't do command
substitution when it evaluates the prompt string after every command.
That's why we have to incorporate it into an
alias that supersedes <b class="emphasis.bold">cd</B
>. The following code should go
into your <em class="emphasis">.profile</EM
> or environment file, along with the 
definition of <b class="emphasis.bold">tildize</B
>:</P
><p class="para"><blockquote class="screen"><pre class="screen">PS1=$(tildize $PWD)

function _cd {
    &quot;cd&quot; &quot;$@&quot;
    es=$?
    PS1=$(tildize $PWD)
    return $es
}

alias cd=_cd</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12828"></A
>When you log in, this code will set <b class="emphasis.bold">PS1</B
> to the initial
current directory (presumably your home directory).
Then, whenever you enter a <b class="emphasis.bold">cd</B
> command, the alias
runs the function <b class="emphasis.bold">_cd</B
>, which looks a lot like the
&quot;wrapper&quot; in <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
>.<a class="indexterm" name="AUTOID-12834"></A
><a class="indexterm" name="AUTOID-12835"></A
></P
><p class="para">The first line in <b class="emphasis.bold">_cd</B
> runs the &quot;real&quot; <b class="emphasis.bold">cd</B
> by
surrounding it in quotes&nbsp;- which makes the shell bypass
alias expansion (Step 3 in the list).
Then the shell resets the prompt string
to the new current directory, or the old one if the <b class="emphasis.bold">cd</B
>
failed for some reason.</P
><p class="para">Of course, the function <b class="emphasis.bold">tildize</B
> can be any code that
formats the directory string. See the exercises at the end
of this chapter for a couple of suggestions.<a class="indexterm" name="AUTOID-12842"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-7-SECT-3.2">7.3.2 eval</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-EVAL"></A
><a class="indexterm" name="AUTOID-12848"></A
><a class="indexterm" name="AUTOID-12851"></A
>We have seen that quoting lets you skip steps in command-line processing.  Then there's the eval command, which lets you go through the process again.
Performing command-line processing twice may seem strange, but it's actually very powerful: 
it lets you write scripts that create command strings
on the fly and then pass them to the shell for execution.   
This means that you can give scripts &quot;intelligence&quot; to modify their
own behavior as they are running.</P
><p class="para">The <b class="emphasis.bold">eval</B
> statement tells the shell to
take <b class="emphasis.bold">eval</B
>'s arguments
and run them through the command-line processing steps all over again.
To help you understand the implications of <b class="emphasis.bold">eval</B
>,
we'll start with a trivial example and work our way up to a situation
in which we're constructing and running commands on the fly.</P
><p class="para"><b class="emphasis.bold">eval ls</B
> passes the string <b class="emphasis.bold">ls</B
> to the shell to execute;
the shell prints list of files in the current directory.
Very simple; there is nothing about the string <b class="emphasis.bold">ls</B
> that needs to be 
sent through the command-processing steps twice. But consider this:</P
><p class="para"><blockquote class="screen"><pre class="screen">listpage=&quot;ls | more&quot;
$listpage</PRE
></BLOCKQUOTE
></P
><p class="para">Instead of producing a paginated file listing, the shell will 
treat <b class="emphasis.bold">|</B
> and <b class="emphasis.bold">more</B
> as arguments to <em class="emphasis">ls</EM
>, and <em class="emphasis">ls</EM
> will
complain that no files of those names exist. Why? Because
the pipe character &quot;appears&quot; in step 5 when the shell 
evaluates the variable, <em class="emphasis">after</EM
> it has actually looked
for pipe characters (in step 2). The variable's expansion isn't even parsed
until step 8. As a result, the shell will treat <b class="emphasis.bold">|</B
>
and <b class="emphasis.bold">more</B
> as arguments to <em class="emphasis">ls</EM
>, so that <em class="emphasis">ls</EM
> will try to 
find files called <b class="emphasis.bold">|</B
> and <em class="emphasis">more</EM
> in the current directory!</P
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-EVAL-FOR-CONSTRUCTING-PIPELINES"></A
>Now consider <b class="emphasis.bold">eval $listpage</B
> instead of just <b class="emphasis.bold">$listpage</B
>.
When the shell gets to the last step, it will run the command
<b class="emphasis.bold">eval</B
> with arguments <b class="emphasis.bold">ls</B
>, <b class="emphasis.bold">|</B
>, and <b class="emphasis.bold">more</B
>.  This causes the
shell to go back to Step 1 with a line that consists of these arguments.
It finds <b class="emphasis.bold">|</B
> in Step 2
and splits the line into two commands,
<em class="emphasis">ls</EM
> and <em class="emphasis">more</EM
>. Each command is processed in the normal
(and in both cases trivial) way. The result is a paginated list
of the files in your current directory.</P
><p class="para">Now you may start to see how powerful <b class="emphasis.bold">eval</B
> can be.
It is an advanced feature that requires considerable programming
cleverness to be used most effectively. It even has a bit of the
flavor of artificial intelligence, in that it enables you to
write programs that can &quot;write&quot; and execute other programs.
[11]
You probably won't use <b class="emphasis.bold">eval</B
> for everyday shell programming,
but it's worth taking the time to understand what it can do.</P
><blockquote class="footnote"><p class="para">[11] <a class="indexterm" name="AUTOID-12893"></A
>You could actually do this without
<b class="emphasis.bold">eval</B
>, by <b class="emphasis.bold">print</B
>ing commands to a temporary file and then
&quot;sourcing&quot; that file with <b class="emphasis.bold">.</B
> <em class="emphasis">filename</EM
>. But that is <em class="emphasis">much</EM
>
less efficient.</P
></BLOCKQUOTE
><p class="para">As a more interesting example, we'll revisit Task 4-1, the very first
task in the book. In it, we constructed a simple pipeline that sorts a file
and prints out the first <em class="emphasis">N</EM
> lines, where <em class="emphasis">N</EM
> defaults to
10. The resulting pipeline was:</P
><p class="para"><blockquote class="screen"><pre class="screen">sort -nr $1 | head -${2:-10}</PRE
></BLOCKQUOTE
></P
><p class="para">The first argument specified the file to sort; <b class="emphasis.bold">$2</B
> is the number
of lines to print.</P
><p class="para">Now suppose we change the task just a bit so that the default is to print
the <em class="emphasis">entire file</EM
> instead of 10 lines.  <a class="indexterm" name="AUTOID-12911"></A
>
This means that we don't
want to use <em class="emphasis">head</EM
> at all in the default case. We could do this
in the following way:</P
><p class="para"><blockquote class="screen"><pre class="screen">if [[ -n $2 ]]; then
    sort -nr $1 | head -$2
else
    sort -nr $1
fi</PRE
></BLOCKQUOTE
></P
><p class="para">In other words, we decide which pipeline to run according to whether
or not <b class="emphasis.bold">$2</B
> is null. But here is a more compact solution:</P
><p class="para"><blockquote class="screen"><pre class="screen">eval sort -nr \$1 ${2:+&quot;| head -\$2&quot;}</PRE
></BLOCKQUOTE
></P
><p class="para">The last expression in this line evaluates to the string <b class="emphasis.bold">| head -\$2</B
> if 
<b class="emphasis.bold">$2</B
> exists (is not null); if <b class="emphasis.bold">$2</B
> is null, then the expression
is null too.  
We backslash-escape dollar signs (<b class="emphasis.bold">\$</B
>) before variable names to
prevent unpredictable results if the variables' values contain
special characters like <b class="emphasis.bold">&gt;</B
> or <b class="emphasis.bold">|</B
>. The backslash 
effectively puts off the variables' evaluation until the <b class="emphasis.bold">eval</B
> command
itself runs.
So the entire line is either:</P
><p class="para"><blockquote class="screen"><pre class="screen">eval sort -nr \$1 | head -\$2</PRE
></BLOCKQUOTE
></P
><p class="para">if <b class="emphasis.bold">$2</B
> is given or:</P
><p class="para"><blockquote class="screen"><pre class="screen">eval sort -nr \$1</PRE
></BLOCKQUOTE
></P
><p class="para">if <b class="emphasis.bold">$2</B
> is null.  
Once again, we can't just run this command without
<b class="emphasis.bold">eval</B
> because the pipe is &quot;uncovered&quot; after the shell tries to
break the line up into commands. <b class="emphasis.bold">eval</B
> causes the shell to
run the correct pipeline when <b class="emphasis.bold">$2</B
> is given.<a class="indexterm" name="AUTOID-12939"></A
></P
><p class="para">Next, we'll revisit Task 7-3 from earlier in this chapter,
the <em class="emphasis">start</EM
> script that lets you start a command in the background and
save its standard output and standard
error in a logfile. Recall that the one-line solution
to this task had the restriction that the command could not contain
output redirectors or pipes. Although the former doesn't make sense
when you think about it, you certainly would want the ability to
start a pipeline in this way.</P
><p class="para"><b class="emphasis.bold">eval</B
> is the obvious way to solve this problem:</P
><p class="para"><blockquote class="screen"><pre class="screen">eval &quot;$@&quot; &gt; logfile 2&gt;&amp;1 &amp;</PRE
></BLOCKQUOTE
></P
><p class="para">The only restriction that this imposes on the user is that pipes
and other such special characters be quoted (surrounded by quotes
or preceded by backslashes).</P
><p class="para">Here's a way to apply <b class="emphasis.bold">eval</B
> in conjunction
with various other interesting shell programming concepts.<a class="indexterm" name="KSH-CH-7-IX-MAKE"></A
></P
><div class="task"><h4>Task 7.6</H4
><blockquote class="taskinfo"><p class="para">Implement the guts of the <em class="emphasis">make(1)</EM
> utility as a
shell script.</P
></BLOCKQUOTE
><p class="para"><em class="emphasis">make</EM
> is known primarily as a programmer's tool,
but it seems as though someone finds a new use for it
every day. Without going into too much extraneous detail,
<em class="emphasis">make</EM
> basically keeps track of multiple files in a particular
project, some of which depend on others (e.g., a document
depends on its word processor input file(s)).
It makes sure that when you change a file, all of 
the other files that depend on it are processed.</P
><p class="para">For example, assume you're using the <em class="emphasis">troff</EM
> word processor
to write a book. You have files for the book's chapters
called <em class="emphasis">ch1.t</EM
>, <em class="emphasis">ch2.t</EM
>, and so on; the <em class="emphasis">troff</EM
>
output for these files are <em class="emphasis">ch1.out</EM
>, <em class="emphasis">ch2.out</EM
>, etc.
You run commands like 
<b class="emphasis.bold">troff ch</B
><em class="emphasis">N</EM
><b class="emphasis.bold">.t &gt; 
ch</B
><em class="emphasis">N</EM
><b class="emphasis.bold">.out</B
>
to do the processing. While you're working on the book,
you tend to make changes to several files at a time.</P
><p class="para">In this situation, you can use <em class="emphasis">make</EM
> to keep track of which files need
to be reprocessed, so that all you need to do is type <b class="emphasis.bold">make</B
>,
and it will figure out what needs to be done. You don't need
to remember to reprocess the files that have changed.</P
><p class="para">How does <em class="emphasis">make</EM
> do this?  <a class="indexterm" name="AUTOID-12975"></A
>
Simple: it compares the
<em class="emphasis">modification times</EM
> of the input and output files
(called <em class="emphasis">sources</EM
> and <em class="emphasis">targets</EM
> in <em class="emphasis">make</EM
> terminology), 
and if the input file is newer, then <em class="emphasis">make</EM
> reprocesses it.</P
><p class="para">You tell <em class="emphasis">make</EM
> which files to check by building a file called
<em class="emphasis">makefile</EM
> that has constructs like this:</P
><p class="para"><blockquote class="screen"><pre class="screen"><em class="emphasis">target</EM
><code class="literal"> :</CODE
> <em class="emphasis">source1 source2 ...</EM
>
	<em class="emphasis">commands to make target</EM
></PRE
></BLOCKQUOTE
></P
><p class="para">This essentially says, &quot;For <em class="emphasis">target</EM
> to be up to date, it must be
newer than all of the <em class="emphasis">source</EM
>s. If it's not, run
the <em class="emphasis">commands</EM
> to bring it up to date.&quot;
The <em class="emphasis">commands</EM
> are on one or more lines that must start
with TABs: e.g., to make <em class="emphasis">ch7.out</EM
>:</P
><p class="para"><blockquote class="screen"><pre class="screen">ch7.out : ch7.t
	troff ch7.t &gt; ch7.out</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-13001"></A
>Now suppose that we write a shell function called
<b class="emphasis.bold">makecmd</B
> that reads and executes a single construct
of this form. Assume that the <em class="emphasis">makefile</EM
> is read
from standard input. The function would look like the following code.</P
><p class="para"><blockquote class="screen"><pre class="screen">function makecmd {
    read target colon sources
    for src in $sources; do
        if [[ $src -nt $target ]]; then
            while read cmd &amp;&amp; [[ $cmd = \t* ]]; do
                print &quot;$cmd&quot;
                eval ${cmd#\t}
            done
            break
        fi
    done
}</PRE
></BLOCKQUOTE
></P
><p class="para">This function reads the line with the target and sources;
the variable <b class="emphasis.bold">colon</B
> is just a placeholder for the <b class="emphasis.bold">:</B
>.<a class="indexterm" name="AUTOID-13009"></A
>
Then it checks each source to see if it's newer than the target,
using the <b class="emphasis.bold">-nt</B
> file attribute test operator that we saw
in <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
>.
If the source is newer, it reads, prints, and executes the commands until 
it finds a line that doesn't start with a TAB or it reaches end-of-file.
(The real <em class="emphasis">make</EM
> does more than this; see the exercises
at the end of this chapter.)
After running the commands (which are stripped of the initial TAB), 
it breaks out of the <b class="emphasis.bold">for</B
> loop, so that it doesn't run the 
commands more than once.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-7-SECT-3.2.1">7.3.2.1 The C Compiler as Pipeline</A
></H4
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-C-COMPILERS-AS-PIPELINES"></A
>As a final example of <b class="emphasis.bold">eval</B
>, we'll revisit our old friend <em class="emphasis">occ</EM
>, 
the C compiler from the previous three chapters. Recall that the compiler
does its work by calling separate programs to do the actual 
<em class="emphasis">compile</EM
> from C to object code (the <em class="emphasis">ccom</EM
> program),
<em class="emphasis">optimization</EM
> of object code (<em class="emphasis">optimize</EM
>),
<em class="emphasis">assembly</EM
> of assembler code files (<em class="emphasis">as</EM
>),
and final <em class="emphasis">linking</EM
> of object code files into an executable program
(<em class="emphasis">ld</EM
>). These separate programs use temporary files to store
their outputs.</P
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-EVAL-FOR-CONSTRUCTING-PIPELINES2"></A
>Now we'll assume that these components (except the linker)
pass information in a <em class="emphasis">pipeline</EM
> to the final object code output.
In other words, each component takes standard input and produces
standard output instead of taking filename arguments.
We'll also change an earlier assumption:
instead of compiling a C source file directly 
to object code, <em class="emphasis">occ</EM
> compiles C to assembler code, which the
assembler then assembles to object code. This lets us suppose
that <em class="emphasis">occ</EM
> works like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">ccom &lt; filename.c | as | optimize &gt; filename.o</PRE
></BLOCKQUOTE
></P
><p class="para">Or, if you prefer:</P
><p class="para"><blockquote class="screen"><pre class="screen">cat <em class="emphasis">filename</EM
><code class="literal">.c | ccom | as | optimize &gt; </CODE
><em class="emphasis">filename</EM
>.o</PRE
></BLOCKQUOTE
></P
><p class="para">To get this in the proper framework for <b class="emphasis.bold">eval</B
>, 
let's assume that the variables
<b class="emphasis.bold">srcname</B
> and <b class="emphasis.bold">objname</B
> contain the names of the source
and object files, respectively. Then our pipeline becomes:</P
><p class="para"><blockquote class="screen"><pre class="screen">cat $srcname | ccom | as | optimize &gt; $objname</PRE
></BLOCKQUOTE
></P
><p class="para">As we've already seen, this is equivalent to:</P
><p class="para"><blockquote class="screen"><pre class="screen">eval cat \$srcname | ccom | as | optimize &gt; \$objname</PRE
></BLOCKQUOTE
></P
><p class="para">Knowing what we do about <b class="emphasis.bold">eval</B
>, we can transform this into:</P
><p class="para"><blockquote class="screen"><pre class="screen">eval cat \$srcname &quot; | ccom&quot; &quot; | as&quot; &quot; | optimize&quot; &gt; \$objname</PRE
></BLOCKQUOTE
></P
><p class="para">and from that into:</P
><p class="para"><blockquote class="screen"><pre class="screen">compile=&quot; | ccom&quot;
assemble=&quot; | as&quot;
optimize=&quot; | optimize&quot;

eval cat \$srcname \$compile \$assemble \$optimize &gt; \$objname</PRE
></BLOCKQUOTE
></P
><p class="para">Now, consider what happens if you don't want
to invoke the optimizer&nbsp;- which is the default case anyway.
(Recall that the <b class="emphasis.bold">-O</B
> option invokes the optimizer.)
We can do this:</P
><p class="para"><blockquote class="screen"><pre class="screen">optimize=&quot;&quot;
if -O given then
    optimize=&quot; | optimize&quot;
fi</PRE
></BLOCKQUOTE
></P
><p class="para">In the default case, <b class="emphasis.bold">$optimize</B
> evaluates to the empty string,
causing the final pipeline to &quot;collapse&quot; into:</P
><p class="para"><blockquote class="screen"><pre class="screen">eval cat $srcname | ccom | as &gt; $objname</PRE
></BLOCKQUOTE
></P
><p class="para">Similarly, if you pass <b class="emphasis.bold">occ</B
> a file of assembler code 
(<em class="emphasis">filename.s</EM
>), you can collapse the compile step:
[12]</P
><blockquote class="footnote"><p class="para">[12] Astute readers will notice that, according to this rationale,
we would handle object-code input files (<em class="emphasis">filename.o</EM
>)
with the pipeline <b class="emphasis.bold">eval cat $srcname &gt; $objname</B
>, where the
two names are the same. This will cause UNIX to destroy
<em class="emphasis">filename.o</EM
> by truncating it to zero length.
We won't worry about this here.</P
></BLOCKQUOTE
><p class="para"><blockquote class="screen"><pre class="screen">assemble=&quot;| as&quot;
if $srcname ends in .s then
    compile=&quot;&quot;
fi</PRE
></BLOCKQUOTE
></P
><p class="para">That results in this pipeline:</P
><p class="para"><blockquote class="screen"><pre class="screen">eval cat \$srcname | as &gt; \$objname</PRE
></BLOCKQUOTE
></P
><p class="para">Now we're ready to show the full &quot;pipeline&quot; version of <b class="emphasis.bold">occ</B
>.  
It's similar to the previous version, except that for each 
input file, it constructs and runs a pipeline as above. It processes
the <b class="emphasis.bold">-g</B
> (debug) option and the link step in the same way as
before. Here is the code:</P
><p class="para"><blockquote class="screen"><pre class="screen"># initialize option-related variables
do_link=true
debug=&quot;&quot;
link_libs=&quot;-l c&quot;
exefile=&quot;&quot;

# initialize pipeline components
compile=&quot; | ccom&quot;
assemble=&quot; | as&quot;
optimize=&quot;&quot;

# process command-line options
while getopts &quot;:cgl:o:O&quot; opt; do
    case $opt in 
        c )    do_link=false ;;
        g )    debug=&quot;-g&quot; ;;
        l )    link_libs=&quot;$link_libs -l $OPTARG&quot; ;;
        o )    exefile=&quot;-o $OPTARG&quot; ;;
        O )    optimize=&quot; | optimize&quot; ;;
        \? )   print 'usage: occ [-cgO] [-l lib] [-o file] files...'
               return 1 ;;
    esac
done
shift $(($OPTIND - 1))

# process the input files
for filename in &quot;$@&quot;; do
    case $filename in
	*.c )
	    objname=${filename%.c}.o ;;
	*.s )
	    objname=${filename%.s}.o
	    compile=&quot;&quot; ;;
	*.o )
	    compile=&quot;&quot;
	    assemble=&quot;&quot; ;;
	*   )
        print &quot;error: $filename is not a source or object file.&quot;
        return 1 ;;
    esac

# run a pipeline for each input file
eval cat \$filename \$compile \$assemble \$optimize &gt; \$objname
    objfiles=$objfiles&quot; &quot;$objname
done

if [[ $do_link = true ]]; then
    ld $exefile $link_libs $objfiles
fi</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-13091"></A
><a class="indexterm" name="AUTOID-13092"></A
><a class="indexterm" name="AUTOID-13093"></A
><a class="indexterm" name="AUTOID-13094"></A
>We could go on forever with increasingly complex examples of <b class="emphasis.bold">eval</B
>,
but we'll settle for concluding the chapter with a few exercises.
The last two are really more like items on the menu of food for thought;
the very last one is particularly difficult.</P
><ol class="orderedlist"><li class="listitem"><p class="para">Here are a couple of ways to enhance <b class="emphasis.bold">occ</B
>, our C compiler:
<ol class="orderedlist"><li class="listitem"><p class="para">Real-world C compilers accept the option <b class="emphasis.bold">-S</B
>,
which tells the compiler to suppress the assembly step and leave
the output in files of assembler code whose names end in <em class="emphasis">.s</EM
>.
Modify <b class="emphasis.bold">occ</B
> so that it recognizes this option.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-13108"></A
>The language C++ is an evolutionary successor to C; it includes
advanced features like operator overloading, function argument
type checking, and class definitions. (Don't worry
if you don't know what these are.) Some C++ compilers use C
as an &quot;assembly language&quot;, i.e., they compile C++ source files
to C code and then pass them to a C compiler for further processing.
Assume that C++ source files have names ending in <em class="emphasis">.cc</EM
>,
and that <em class="emphasis">/lib/cfront</EM
> is the C++ compiler &quot;front-end&quot; that produces
C code on its standard output. Modify <em class="emphasis">occ</EM
> so that
it accepts C++ as well as C, assembler, and object code files.</P
></LI
></OL
></P
></LI
><li class="listitem"><p class="para">The possibilities for customizing your prompt string are practically endless.  
Here are two enhancements to customization schemes that we've seen already:
<ol class="orderedlist"><li class="listitem"><p class="para">Enhance the current-directory-in-the-prompt scheme by
limiting the prompt string's length to a number of characters
that the user can define with an environment variable.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-13120"></A
>On some UNIX systems, it's not possible to get a list of all users
by looking at <em class="emphasis">/etc/passwd</EM
>.  <a class="indexterm" name="AUTOID-13123"></A
>
For example, networks of Suns use
the Network Information Service (NIS, a.k.a. &quot;Yellow Pages&quot;),
which stores a protected password file for the entire network on 
one server machine, instead of having separate <em class="emphasis">/etc/passwd</EM
>
files on each machine.</P
><p class="para">If such a machine is set up so that all login directories are
under a common directory (e.g., <em class="emphasis">/users</EM
>),  you can get
a list of all users by simply <em class="emphasis">ls</EM
>-ing that directory.
Modify the <b class="emphasis.bold">tildize</B
> function so that it uses this technique;
pay particular attention to execution speed.</P
></LI
></OL
></P
></LI
><li class="listitem"><p class="para">The function <b class="emphasis.bold">makecmd</B
> in the solution to Task 7-6 
represents an oversimplification of the real <em class="emphasis">make</EM
>'s functionality. 
<em class="emphasis">make</EM
> actually checks file dependencies <em class="emphasis">recursively</EM
>,
meaning that a <em class="emphasis">source</EM
> on one line in a <em class="emphasis">makefile</EM
> can be a
<em class="emphasis">target</EM
> on another line. For example, the book chapters in
the example
could themselves depend on some figures in separate files
that were made with a graphics package.
<ol class="orderedlist"><li class="listitem"><p class="para">Write a function called <b class="emphasis.bold">readtargets</B
> that goes through the
<em class="emphasis">makefile</EM
> and stores all of the targets in a variable or temp file.</P
></LI
><li class="listitem"><p class="para">Instead of reading the <em class="emphasis">makefile</EM
> from standard input, read it into
an array variable called <b class="emphasis.bold">lines</B
>. Use the variable <b class="emphasis.bold">curline</B
>
as the &quot;current line&quot; index. Modify <b class="emphasis.bold">makecmd</B
> so that it reads lines
from the array starting with the current line.</P
></LI
><li class="listitem"><p class="para"><b class="emphasis.bold">makecmd</B
> merely checks to see if any of the sources
are newer than the given target. It should really be a recursive
routine that looks like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">function makecmd {
    target=$1
    get sources for $target
    for each source src; do
        if $src is also a target in this makefile then
            makecmd $src
        fi
        if [[ $src -nt $target ]]; then
            run commands to make target
            return
        fi
    done
}</PRE
></BLOCKQUOTE
></P
><p class="para">Implement this. </P
></LI
><li class="listitem"><p class="para">Write the &quot;driver&quot; script that turns the <b class="emphasis.bold">makecmd</B
> function into a full
<em class="emphasis">make</EM
> program. This should make the target given as argument,
or if none is given, the first target listed in the makefile.</P
></LI
><li class="listitem"><p class="para">The above <b class="emphasis.bold">makecmd</B
> still doesn't do one important thing
that the real <em class="emphasis">make</EM
> does: allow for &quot;symbolic&quot; targets that
aren't files. These give <em class="emphasis">make</EM
> much of the power that makes
it applicable to such an incredible variety of situations.
Symbolic targets always have a modification time 
of 0, so that <em class="emphasis">make</EM
> always runs the commands to make them.
Modify <b class="emphasis.bold">makecmd</B
> so that it allows for symbolic targets.
(Hint: the crux of this problem is to figure out how to get a file's 
modification time. This is quite difficult.)</P
></LI
></OL
>&#13;</P
></LI
><li class="listitem"><p class="para">Finally, here are some problems that really test your knowledge of 
<b class="emphasis.bold">eval</B
> and the shell's command-line processing rules. Solve these and 
you're a true Korn shell hacker!

<ol class="orderedlist"><li class="listitem"><p class="para">Advanced shell programmers sometimes use a little trick that includes
<b class="emphasis.bold">eval</B
>: using the <em class="emphasis">value</EM
> of a variable
as the <em class="emphasis">name</EM
> of another variable. In other words, you can give
a shell script control over the <em class="emphasis">names</EM
> of variables to which it
assigns values. How would you do this?  
(Hint: if <b class="emphasis.bold">$fred</B
> equals &quot;dave&quot;, and <b class="emphasis.bold">$dave</B
> is
&quot;bob&quot;, then you might think that you could type <b class="emphasis.bold">print $$fred</B
>
and get the response <b class="emphasis.bold">bob</B
>. This
doesn't actually work, but it's on the right track.)</P
></LI
><li class="listitem"><p class="para">You could use the above technique together with other <b class="emphasis.bold">eval</B
> tricks
to implement new control structures for the shell.  <a class="indexterm" name="AUTOID-13184"></A
><a class="indexterm" name="AUTOID-13186"></A
>
For example, see if you can write a script that emulates the behavior
of a <b class="emphasis.bold">for</B
> loop in a conventional language like C or Pascal, i.e.,
a loop that iterates a fixed number of times, with a loop variable
that steps from 1 to the number of iterations (or, for C fans,
0 to iterations-1). Call your script <b class="emphasis.bold">loop</B
> to avoid clashes with 
the keywords <b class="emphasis.bold">for</B
> and <b class="emphasis.bold">do</B
>.</P
></LI
></OL
>&#13;</P
></LI
></OL
></DIV
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch07_02.htm" webstripperlinkwas="ch07_02.htm" title="7.2 String I/O"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 7.2 String I/O" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" title="Learning the Korn Shell"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Learning the Korn Shell" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="CHAPTER" href="ch08_01.htm" webstripperlinkwas="ch08_01.htm" title="8. Process Handling"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 8. Process Handling" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">7.2 String I/O</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">8. Process Handling</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="../upt/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="../sedawk/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
