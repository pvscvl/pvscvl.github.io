<html><head>
<title>[Chapter 7] 7.2 String I/O</TITLE>
<meta name="DC.title" content="Learning the Korn Shell"><meta name="DC.creator" content="Bill Rosenblatt"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-03T21:12:19Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-054-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch07_01.htm" webstripperlinkwas="ch07_01.htm" title="7. Input/Output and Command-line Processing"><link rel="prev" href="ch07_01.htm" webstripperlinkwas="ch07_01.htm" title="7.1 I/O Redirectors"><link rel="next" href="ch07_03.htm" webstripperlinkwas="ch07_03.htm" title="7.3 Command-line Processing"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="Learning the Korn Shell" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,66" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch07_01.htm" webstripperlinkwas="ch07_01.htm" title="7.1 I/O Redirectors"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 7.1 I/O Redirectors" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 7<br>Input/Output and Command-line Processing</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch07_03.htm" webstripperlinkwas="ch07_03.htm" title="7.3 Command-line Processing"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 7.3 Command-line Processing" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="KSH-CH-7-SECT-2">7.2 String I/O</A
></H2
><p class="para"><a class="indexterm" name="AUTOID-11616"></A
><a class="indexterm" name="AUTOID-11619"></A
>Now we'll zoom back in to the string I/O level and examine
the <b class="emphasis.bold">print</B
> and <b class="emphasis.bold">read</B
> statements, which give the shell
I/O capabilities that are more analogous to those of conventional
programming languages.  </P
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-7-SECT-2.1">7.2.1 print</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-PRINT"></A
>As we've seen countless times in this book, <b class="emphasis.bold">print</B
> simply
prints its arguments to standard output.  <a class="indexterm" name="AUTOID-11631"></A
>
You should use it
instead of the <b class="emphasis.bold">echo</B
> command, whose functionality differs from
system to system.
[3]
Now we'll explore the command in greater detail.</P
><blockquote class="footnote"><p class="para">[3] <a class="indexterm" name="AUTOID-11636"></A
>Specifically, there is a difference between System V and BSD
versions.  <a class="indexterm" name="AUTOID-11639"></A
>
The latter accepts options similar to those of
<b class="emphasis.bold">print</B
>, while the former accepts C language-style escape
sequences.</P
></BLOCKQUOTE
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-7-SECT-2.1.1">7.2.1.1 print escape sequences</A
></H4
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-PRINT-ESCAPE-SEQUENCES"></A
><b class="emphasis.bold">print</B
> accepts a number of options, as well as several
<em class="emphasis">escape sequences</EM
> that start with a backslash.
[4]<a class="indexterm" name="AUTOID-11653"></A
>
These are similar to the escape sequences
recognized by <b class="emphasis.bold">echo</B
> and the C language; they are listed
in <a class="xref" href="#KSH-CH-7-TAB-1" title="print Escape Sequences">Table 7.2</A
>.</P
><blockquote class="footnote"><p class="para">[4] You must use a double backslash if you don't surround
the string that contains them with quotes; otherwise, the
shell itself &quot;steals&quot; a backslash before
passing the arguments to <b class="emphasis.bold">print</B
>.</P
></BLOCKQUOTE
><p class="para">These sequences exhibit fairly predictable behavior, except for <b class="emphasis.bold">\f</B
>
on some displays, it causes a screen clear, while on others
it causes a line feed. It ejects the page on most printers.
<b class="emphasis.bold">\v</B
> is somewhat obsolete; it usually causes a line feed.</P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-7-TAB-1">Table 7.2: print Escape Sequences</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Sequence</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Character printed</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\a</B
></TD
><td class="entry" rowspan="1" colspan="1"><span class="acronym">ALERT</SPAN
> or <kbd class="keycap">[CTRL-G]</KBD
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\b</B
></TD
><td class="entry" rowspan="1" colspan="1"><span class="acronym">BACKSPACE</SPAN
> or <kbd class="keycap">[CTRL-H]</KBD
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\c</B
></TD
><td class="entry" rowspan="1" colspan="1">Omit final <span class="acronym">NEWLINE</SPAN
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\f</B
></TD
><td class="entry" rowspan="1" colspan="1"><span class="acronym">FORMFEED</SPAN
> or <kbd class="keycap">[CTRL-L]</KBD
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\n</B
></TD
><td class="entry" rowspan="1" colspan="1"><span class="acronym">NEWLINE</SPAN
> (not at end of command) or <kbd class="keycap">[CTRL-J]</KBD
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\r</B
></TD
><td class="entry" rowspan="1" colspan="1"><span class="acronym">RETURN</SPAN
> (<span class="acronym">ENTER</SPAN
>) or <kbd class="keycap">[CTRL-M]</KBD
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\t</B
></TD
><td class="entry" rowspan="1" colspan="1"><span class="acronym">TAB</SPAN
> or <kbd class="keycap">[CTRL-I]</KBD
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\v</B
></TD
><td class="entry" rowspan="1" colspan="1"><span class="acronym">VERTICAL TAB</SPAN
> or <kbd class="keycap">[CTRL-K]</KBD
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\0</B
><em class="emphasis">n</EM
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><span class="acronym">ASCII</SPAN
> character with octal (base-8) value <em class="emphasis">n</EM
>, 
where <em class="emphasis">n</EM
> is 1 to 3 digits</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">\\</B
></TD
><td class="entry" rowspan="1" colspan="1">Single backslash</TD
></TR
></TBODY
></TABLE
><p class="para">The \0<em class="emphasis">n</EM
> sequence is even more device-dependent and can
be used for complex I/O, such as cursor control and special
graphics characters.<a class="indexterm" name="AUTOID-11731"></A
></P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-7-SECT-2.1.2">7.2.1.2 Options to print</A
></H4
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-PRINT-OPTIONS"></A
><b class="emphasis.bold">print</B
> also accepts a few dash options; we've already seen
<b class="emphasis.bold">-n</B
> for omitting the final NEWLINE. The options
are listed in <a class="xref" href="#KSH-CH-7-TAB-2" title="print Options">Table 7.3</A
>.<a class="indexterm" name="AUTOID-11741"></A
><a class="indexterm" name="AUTOID-11745"></A
><a class="indexterm" name="AUTOID-11749"></A
><a class="indexterm" name="KSH-CH-7-IX-PRINT-OPTIONS--S"></A
><a class="indexterm" name="AUTOID-11757"></A
></P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-7-TAB-2">Table 7.3: print Options</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Option</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Function</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-n</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Omit the final newline (same as the \c escape sequence)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-r</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Raw; ignore the escape sequences listed above</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-p</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Print on pipe to coroutine; see next chapter</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-s</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Print to command history file. See <a class="xref" href="ch02_01.htm" webstripperlinkwas="ch02_01.htm" title="Command-line Editing">Chapter 2, Command-line Editing</A
>.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-u</B
><em class="emphasis">n</EM
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Print to file descriptor <em class="emphasis">n</EM
></P
></TD
></TR
></TBODY
></TABLE
><p class="para">Notice that some of these are redundant:
<b class="emphasis.bold">print -n</B
> is the same as <b class="emphasis.bold">print</B
> with
<b class="emphasis.bold">c</B
> at the end of a line; <b class="emphasis.bold">print -u</B
><em class="emphasis">n</EM
><b class="emphasis.bold"> ...</B
> is
equivalent to <b class="emphasis.bold">print ... &gt;&amp;</B
><em class="emphasis">n</EM
> (though the former is
more efficient).</P
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-HISTORY-FILE-PRINTING-TO"></A
>However, <b class="emphasis.bold">print -s</B
> is <em class="emphasis">not</EM
> 
the same as <b class="emphasis.bold">print ... 
&gt;&gt; $HISTFILE</B
>.
The latter command renders the 
<b class="emphasis.bold">vi</B
> and <b class="emphasis.bold">emacs</B
> editing 
modes temporarily inoperable; 
you must use <b class="emphasis.bold">print -s</B
> if you
want to print to your history file.  </P
><p class="para">Printing to your history file is useful if you want to edit something
that the shell expands when it processes a command line; for example,
a complex environment variable such as <b class="emphasis.bold">PATH</B
>.  <a class="indexterm" name="AUTOID-11818"></A
><a class="indexterm" name="AUTOID-11820"></A
><a class="indexterm" name="AUTOID-11822"></A
><a class="indexterm" name="AUTOID-11824"></A
>
If you enter the command <b class="emphasis.bold">print -s PATH=$PATH</B
> and then press 
<b class="emphasis.bold"><kbd class="keycap">[CTRL-P]</KBD
></B
> in emacs-mode (or <b class="emphasis.bold">ESC k</B
> in vi-mode), you will see something
like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ PATH=/bin:/usr/bin:/etc:/usr/ucb:/usr/local/bin:/home/billr/bin</PRE
></BLOCKQUOTE
></P
><p class="para">That is, the shell expands the variable (and would expand anything
else, like command substitutions, wildcards, etc.) before it writes
the line to the history file.
Your cursor will be at the end of the line (or at the beginning of the 
line in vi-mode), and you can edit your <b class="emphasis.bold">PATH</B
> without having
to type in the whole thing again.<a class="indexterm" name="AUTOID-11835"></A
><a class="indexterm" name="AUTOID-11836"></A
><a class="indexterm" name="AUTOID-11837"></A
><a class="indexterm" name="AUTOID-11838"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="KSH-CH-7-SECT-2.2">7.2.2 read</A
></H3
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-READ"></A
>The other half of the shell's string I/O facilities is
the <b class="emphasis.bold">read</B
> command, which 
allows you to read values <em class="emphasis">into</EM
> shell variables.
The basic syntax is:<a class="indexterm" name="AUTOID-11846"></A
></P
><p class="para"><blockquote class="screen"><pre class="screen">read <em class="emphasis">var1 var2...</EM
></PRE
></BLOCKQUOTE
></P
><p class="para">There are a few options, which we will cover in the section &quot;Options to read,&quot; below.<a class="indexterm" name="AUTOID-11853"></A
><a class="indexterm" name="AUTOID-11856"></A
>
This statement takes a line from the standard input and
breaks it down into words delimited by any of the characters in the
value of the environment variable <b class="emphasis.bold">IFS</B
> (see <a class="xref" href="ch04_01.htm" webstripperlinkwas="ch04_01.htm" title="Basic Shell Programming">Chapter 4, Basic Shell Programming</A
>;
these are usually a space, a TAB, and NEWLINE).  
The words are assigned to variables
<em class="emphasis">var1</EM
>, <em class="emphasis">var2</EM
>, etc. For example:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>read fred bob</B
></CODE
>
dave pete
$ <code class="userinput"><b>print &quot;$fred&quot;</B
></CODE
>
dave
$ <code class="userinput"><b>print &quot;$bob&quot;</B
></CODE
>
pete</PRE
></BLOCKQUOTE
></P
><p class="para">If there are more words than variables,
then excess words are assigned to the last variable.  <a class="indexterm" name="AUTOID-11868"></A
><a class="indexterm" name="AUTOID-11872"></A
>
If you
omit the variables altogether, the entire line of input is assigned
to the variable <b class="emphasis.bold">REPLY</B
>.</P
><p class="para">You may have identified this as the &quot;missing ingredient&quot; in
the shell programming capabilities we have seen thus far.
It resembles input statements in conventional languages, like its
namesake in Pascal. So why did we wait this long to introduce it?</P
><p class="para"><a class="indexterm" name="AUTOID-11878"></A
><a class="indexterm" name="AUTOID-11880"></A
><a class="indexterm" name="AUTOID-11882"></A
>Actually, <b class="emphasis.bold">read</B
> is sort of an &quot;escape hatch&quot; from traditional shell
programming philosophy, which dictates that the most important unit
of data to process is a <em class="emphasis">text file</EM
>, and that UNIX
utilities such as <em class="emphasis">cut</EM
>, <em class="emphasis">grep</EM
>, 
<em class="emphasis">sort</EM
>,
etc., should be used as building blocks for writing programs.</P
><p class="para"><b class="emphasis.bold">read</B
>, on the other hand, implies line-by-line processing.
You could use it to write a shell script that does what a pipeline
of utilities would normally do, but such a script
would inevitably look like:</P
><p class="para"><blockquote class="screen"><pre class="screen">while (read a line) do
    process the line
    print the processed line
end</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-11894"></A
>This type of script is usually much slower than a pipeline; furthermore, it has the same
form as a program someone might write in C (or some similar language)
that does the same thing much <em class="emphasis">much</EM
> faster. In other words,
if you are going to write it in this line-by-line way, there is no point in
writing a shell script.
(The author has gone for years without writing a script with
<b class="emphasis.bold">read</B
> in it.)</P
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-7-SECT-2.2.1">7.2.2.1 Reading lines from files</A
></H4
><p class="para">Nevertheless, shell scripts with
<b class="emphasis.bold">read</B
> are useful for certain kinds of tasks. One is when
you are reading data from a file
small enough so that efficiency isn't a concern
(say a few hundred lines or less),
and it's <em class="emphasis">really necessary</EM
> to get bits of input into shell variables.</P
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-TERM"></A
><a class="indexterm" name="KSH-CH-7-IX-ENVIRONMENT-VARIABLES-TERM"></A
>One task that we have already seen fits this description: Task 5-4, 
the script that a system administrator could use to set
a user's <b class="emphasis.bold">TERM</B
> environment variable according to which terminal line
he or she is using.  <a class="indexterm" name="AUTOID-11910"></A
>
The code in <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5, Flow Control</A
> used a <b class="emphasis.bold">case</B
> statement
to select the correct value for <b class="emphasis.bold">TERM</B
>.</P
><p class="para"><a class="indexterm" name="AUTOID-11916"></A
><a class="indexterm" name="AUTOID-11918"></A
>This code would presumably reside in <em class="emphasis">/etc/profile</EM
>, the
system-wide initialization file that the Korn shell runs before running
a user's <em class="emphasis">.profile</EM
>. If the terminals on the system change
over time&nbsp;- as surely they must&nbsp;- then the code would have to
be changed. It would be better to store the information in a file
and change just the file instead.</P
><p class="para">Assume we put the information in a file whose format is typical
of such UNIX &quot;system configuration&quot; files: each line contains
a device name, a TAB, and a <b class="emphasis.bold">TERM</B
> value.
If the file, which we'll call
<em class="emphasis">/etc/terms</EM
>, contained the same data as the <b class="emphasis.bold">case</B
> statement
in <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
>, <em class="emphasis">Flow Control</EM
>, it would look like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">console	s531
tty01	gl35a
tty03	gl35a
tty04	gl35a
tty07	t2000
tty08	s531</PRE
></BLOCKQUOTE
></P
><p class="para">We can use <b class="emphasis.bold">read</B
> to get the data from this file, but first we
need to know how to test for the end-of-file condition.<a class="indexterm" name="AUTOID-11932"></A
>
Simple: <b class="emphasis.bold">read</B
>'s exit status is 1 (i.e., non-0) when there is
nothing to read.  <a class="indexterm" name="AUTOID-11936"></A
>
This leads to a clean <b class="emphasis.bold">while</B
> loop:</P
><p class="para"><blockquote class="screen"><pre class="screen">TERM=vt99       # assume this as a default
line=$(tty)
while read dev termtype; do
    if [[ $dev = $line ]]; then
        TERM=$termtype
        print &quot;TERM set to $TERM.&quot;
        break
    fi
done</PRE
></BLOCKQUOTE
></P
><p class="para">The <b class="emphasis.bold">while</B
> loop reads each line of the input into the variables
<b class="emphasis.bold">dev</B
> and <b class="emphasis.bold">termtype</B
>.  <a class="indexterm" name="AUTOID-11945"></A
>
In each pass through the loop,
the <b class="emphasis.bold">if</B
> looks for a match between <b class="emphasis.bold">$dev</B
> and the user's
tty (<b class="emphasis.bold">$line</B
>, obtained by command substitution from the <em class="emphasis">tty</EM
>
command). If a match is found, <b class="emphasis.bold">TERM</B
> is set, a message is printed,
and the loop
exits; otherwise <b class="emphasis.bold">TERM</B
> remains at the default setting of <b class="emphasis.bold">vt99</B
>.<a class="indexterm" name="AUTOID-11954"></A
><a class="indexterm" name="AUTOID-11955"></A
></P
><p class="para">We're not quite done, though: this code reads from the standard
input, not from <em class="emphasis">/etc/terms</EM
>! We need to know how to redirect
input to <em class="emphasis">multiple commands</EM
>. It turns out that there are
a few ways of doing this.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-7-SECT-2.2.2">7.2.2.2 I/O Redirection and multiple commands</A
></H4
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-READ-FROM-FILES"></A
>One way to solve the problem is with
a <em class="emphasis">subshell</EM
>, as we'll see in the next chapter.
This involves creating a separate process to do the reading.
However, it is usually more efficient to do it in the same process;
the Korn shell gives us three ways of doing this.</P
><p class="para">The first, which we have seen already, is with a function:</P
><p class="para"><blockquote class="screen"><pre class="screen">function findterm {
    TERM=vt99       # assume this as a default
    line=$(tty)
    while read dev termtype; do
        if [[ $dev = $line ]]; then
            TERM=$termtype
            print &quot;TERM set to $TERM.&quot;
            break;
        fi
    done
}

findterm &lt; /etc/terms</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-11970"></A
>A function acts like a script in that it has its own set of
standard I/O descriptors, which can be redirected in the line of code that
calls the function.
In other words, you can think of this code as if <em class="emphasis">findterm</EM
>
were a script and you 
typed 
<b class="emphasis.bold">findterm &lt; /etc/terms</B
> on the
command line. The <b class="emphasis.bold">read</B
> statement 
takes input from <em class="emphasis">/etc/terms</EM
>
a line at a time, and the function runs correctly.</P
><p class="para"><a class="indexterm" name="AUTOID-11979"></A
><a class="indexterm" name="AUTOID-11983"></A
>The second way is by putting the I/O redirector at the end
of the loop, like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">TERM=vt99       # assume this as a default
line=$(tty)
while read dev termtype; do
    if [[ $dev = $line ]]; then
        TERM=$termtype
        print &quot;TERM set to $TERM.&quot;
        break;
    fi
done &lt; /etc/terms</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-11989"></A
><a class="indexterm" name="AUTOID-11992"></A
><a class="indexterm" name="AUTOID-11995"></A
><a class="indexterm" name="AUTOID-11998"></A
>You can use this technique with any flow-control construct,
including <b class="emphasis.bold">if</B
>...<b class="emphasis.bold">fi</B
>, <b class="emphasis.bold">case</B
>...<b class="emphasis.bold">esac</B
>,
<b class="emphasis.bold">select</B
>...<b class="emphasis.bold">done</B
>, and <b class="emphasis.bold">until</B
>...<b class="emphasis.bold">done</B
>.<a class="indexterm" name="AUTOID-12009"></A
><a class="indexterm" name="AUTOID-12011"></A
>
This makes sense because these are all <em class="emphasis">compound
statements</EM
> that the shell treats as single commands
for these purposes.
This technique works fine&nbsp;- the <b class="emphasis.bold">read</B
> command reads a 
line at a time&nbsp;- as long
as all of the input is done within the compound statement.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-7-SECT-2.2.3">7.2.2.3 Code blocks</A
></H4
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-CODE-BLOCKS"></A
>But if you want to redirect I/O to or from an arbitrary group
of commands without creating a separate process, you need to
use a construct that we haven't seen yet.
If you surround some code with <b class="emphasis.bold">{</B
> and <b class="emphasis.bold">}</B
>, the code
will behave like a function that has no name.
This is another type of compound statement.<a class="indexterm" name="AUTOID-12023"></A
>
In accordance with the equivalent concept in the C
language, we'll call this a <em class="emphasis">block</EM
> of code.
[5]</P
><blockquote class="footnote"><p class="para">[5] LISP programmers may prefer to think of this as an <em class="emphasis">anonymous
function</EM
> or <em class="emphasis">lambda-
function</EM
>.</P
></BLOCKQUOTE
><p class="para">What good is a block?<a class="indexterm" name="AUTOID-12031"></A
><a class="indexterm" name="AUTOID-12034"></A
>
In this case, it means that the code within the curly brackets (<b class="emphasis.bold">{}</B
>) will
take standard I/O descriptors just as we described in the last
block of code.
This construct is appropriate for the current example
because the code needs
to be called only once, and the entire script is not really large
enough to merit breaking down into functions. Here is how
we use a block in the example:</P
><p class="para"><blockquote class="screen"><pre class="screen">{
    TERM=vt99       # assume this as a default
    line=$(tty)
    while read dev termtype; do
        if [[ $dev = $line ]]; then
            TERM=$termtype
            print &quot;TERM set to $TERM.&quot;
            break;
        fi
    done
} &lt; /etc/terms</PRE
></BLOCKQUOTE
></P
><p class="para">To help you understand how this works, think of
the curly brackets and the code inside them as if they were one command, i.e.:</P
><p class="para"><blockquote class="screen"><pre class="screen">{ TERM=vt99; line=$(tty); while ... } &lt; /etc/terms</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12045"></A
></P
><p class="para"><a class="indexterm" name="AUTOID-12047"></A
><a class="indexterm" name="AUTOID-12049"></A
>Configuration files for system administration tasks
like this one are actually fairly common; a prominent example is
<em class="emphasis">/etc/hosts</EM
>, which lists machines that are accessible
in a TCP/IP network. We can make <em class="emphasis">/etc/terms</EM
> more like these
standard files by allowing comment lines in
the file that start with <b class="emphasis.bold">#</B
>, just as in shell scripts. This way
<em class="emphasis">/etc/terms</EM
> can look like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">#
# System Console is a Shande 531s
console	s531
#
# Prof. Subramaniam's line has a Givalt GL35a
tty01	gl35a
...</PRE
></BLOCKQUOTE
></P
><p class="para">We can handle comment lines in two ways. First, we could modify the <b class="emphasis.bold">while</B
>
loop so that it ignores lines beginning with <b class="emphasis.bold">#</B
>.  <a class="indexterm" name="AUTOID-12060"></A
>
We would
take advantage of the fact that the equal sign (<b class="emphasis.bold">=</B
>) under <b class="emphasis.bold">[[</B
>/<b class="emphasis.bold">]]</B
>
does pattern matching, not just equality testing:</P
><p class="para"><blockquote class="screen"><pre class="screen">if [[ $dev != \#* &amp;&amp; $dev = $line ]]; then
    ...</PRE
></BLOCKQUOTE
></P
><p class="para">The pattern is <b class="emphasis.bold">#</B
><code class="literal">*</CODE
>, 
which matches any string beginning with <b class="emphasis.bold">#</B
>.
We must precede <b class="emphasis.bold">#</B
> with a backslash so 
that the shell doesn't
treat the rest of the line as a comment.  <a class="indexterm" name="AUTOID-12074"></A
>
Also, remember
from <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
> that the <b class="emphasis.bold">&amp;&amp;</B
> combines the two
conditions so that <em class="emphasis">both</EM
> must be true for the entire condition
to be true.</P
><p class="para"><a class="indexterm" name="AUTOID-12081"></A
>This would certainly work, but the more usual way to filter out
comment lines is to use a pipeline with <em class="emphasis">grep</EM
>. We give
<em class="emphasis">grep</EM
> the regular expression <b class="emphasis.bold">^[^#]</B
>, which matches anything except
lines beginning with <b class="emphasis.bold">#</B
>.  Then we change the call to the block
so that it reads from the output of the pipeline instead of directly
from the file.
[6]</P
><blockquote class="footnote"><p class="para">[6] Unfortunately, using <b class="emphasis.bold">read</B
> with input from a pipe is
often very inefficient, because of issues in the design of the
shell that aren't relevant here.</P
></BLOCKQUOTE
><p class="para"><blockquote class="screen"><pre class="screen">grep &quot;^[^#]&quot; /etc/terms | {
    TERM=vt99
    ...
}</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12093"></A
>We can also use <b class="emphasis.bold">read</B
> to improve our solution to Task 6-2,
in which we emulate the multicolumn output of <em class="emphasis">ls</EM
>.<a class="indexterm" name="AUTOID-12097"></A
><a class="indexterm" name="AUTOID-12101"></A
>
In the solution in the previous chapter, 
we assumed that (as in System V-derived
versions of UNIX) filenames are limited to 14 characters,
and we used 14 as a fixed column width.<a class="indexterm" name="AUTOID-12104"></A
><a class="indexterm" name="AUTOID-12108"></A
>
We'll improve the solution so that it allows <em class="emphasis">any</EM
> filename
length (as in BSD-derived UNIX versions) and uses the length of the
longest filename (plus 2) as the column width.</P
><p class="para">We will need to pass the output of <em class="emphasis">ls</EM
> twice
through the list of files we
want to display in multicolumn format. In the first pass, we will find
the longest filename and use that to set the number of columns as
well as their width; the second pass will do the actual output.
Here is a block of code for the first pass:<a class="indexterm" name="AUTOID-12114"></A
><a class="indexterm" name="AUTOID-12117"></A
></P
><p class="para"><blockquote class="screen"><pre class="screen">ls &quot;$@&quot; | {
    let width=0
    while read fname; do
        if (( ${#fname} &gt; $width )); then
            let width=${#fname}
        fi
    done
    let width=&quot;$width + 2&quot;
    let numcols=&quot;${COLUMNS:-80} / $width&quot;
}</PRE
></BLOCKQUOTE
></P
><p class="para">This code looks a bit like an exercise from a first-semester
programming class.  <a class="indexterm" name="AUTOID-12123"></A
>
The <b class="emphasis.bold">while</B
> loop goes through the input looking for files
with names that are longer than the longest found so far;
if a longer one is found, its length is saved as the new longest length.</P
><p class="para">After the loop finishes, we add 2 to the width to allow for space
between columns. Then we divide the width of the terminal
by the column width to get the number of columns; the shell's integer
division operator truncates remainders, which is just what we want.<a class="indexterm" name="AUTOID-12127"></A
><a class="indexterm" name="AUTOID-12130"></A
>
Recall from <a class="xref" href="ch03_01.htm" webstripperlinkwas="ch03_01.htm" title="Customizing Your Environment">Chapter 3</A
> that the built-in variable <b class="emphasis.bold">COLUMNS</B
>
often contains the display width; the construct 
<b class="emphasis.bold">${COLUMNS</B
><code class="literal">:</CODE
><b class="emphasis.bold">-80}</B
>
gives a default of 80 if this variable is not set.</P
><p class="para">The results of the block are the variables <b class="emphasis.bold">width</B
> and <b class="emphasis.bold">numcols</B
>.
These are global variables, so they are accessible by the rest of
the code inside our (eventual) script. In particular, we need them
in our second pass through the filenames. The code for this resembles
the code to our original solution; all we need to do is
replace the fixed column width and number of columns with the variables:</P
><p class="para"><blockquote class="screen"><pre class="screen">set -A filenames $(ls $@)
typeset -L$width fname
let count=0

while (( $count &lt; ${#filenames[*]} )); do
    fname=${filenames[$count]}
    print &quot;$fname  \\&quot;
    let count=&quot;count + 1&quot;
    if [[ $((count % numcols)) = 0 ]]; then
         print		# output a NEWLINE
    fi
done

if [[ $((count % numcols)) != 0 ]]; then
    print
fi</PRE
></BLOCKQUOTE
></P
><p class="para">The entire script consists of both pieces of code.<a class="indexterm" name="AUTOID-12143"></A
></P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-7-SECT-2.2.4">7.2.2.4 Reading User Input</A
></H4
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-READ-FROM-USER-INPUT"></A
>The other type of task to which <b class="emphasis.bold">read</B
> is suited is
prompting a user for input. Think about it: we have hardly
seen any such scripts so far in this book.  <a class="indexterm" name="AUTOID-12151"></A
>
In fact, the only
ones were the modified solutions to Task 5-4, which involved
<b class="emphasis.bold">select</B
>.</P
><p class="para">As you've probably figured out, <b class="emphasis.bold">read</B
> can be used to get
user input into shell variables.  <a class="indexterm" name="AUTOID-12156"></A
>
We can use <b class="emphasis.bold">print</B
> to prompt the user, like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">print -n 'terminal? '
read TERM
print &quot;TERM is $TERM&quot;</PRE
></BLOCKQUOTE
></P
><p class="para">Here is what this looks like when it runs:</P
><p class="para"><blockquote class="screen"><pre class="screen">terminal? <b class="emphasis.bold">vt99</B
> 
TERM is vt99</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12166"></A
><a class="indexterm" name="AUTOID-12170"></A
>However, shell convention dictates that prompts should go
to standard <em class="emphasis">error</EM
>, not standard output.
(Recall that <b class="emphasis.bold">select</B
> prompts to standard error.)
We could just use file descriptor 2 with the output
redirector we saw earlier in this chapter:</P
><p class="para"><blockquote class="screen"><pre class="screen">print -n 'terminal? ' &gt;&amp;2
read TERM
print TERM is $TERM</PRE
></BLOCKQUOTE
></P
><p class="para">However, this has various disadvantages.
The shell provides a better way of doing the same thing:<a class="indexterm" name="AUTOID-12178"></A
><a class="indexterm" name="AUTOID-12182"></A
>
if you follow the first variable name
in a <b class="emphasis.bold">read</B
> statement with a question mark (<code class="literal">?</CODE
>) and a string,
the shell will use that string as a prompt. In other words:</P
><p class="para"><blockquote class="screen"><pre class="screen">read TERM?'terminal? '
print &quot;TERM is $TERM&quot;</PRE
></BLOCKQUOTE
></P
><p class="para">does the same as the above. This looks a bit nicer;
also, the shell knows not to generate the prompt if the input
is redirected to come from a file, and this scheme allows
you to use vi- or emacs-mode on your input line.</P
><p class="para"><a class="indexterm" name="AUTOID-12191"></A
>We'll flesh out this simple example by showing how Task 5-4
would be done if <b class="emphasis.bold">select</B
> didn't exist. Compare this with
the code in <a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
>:</P
><p class="para"><blockquote class="screen"><pre class="screen">print 'Select your terminal type:'
done=false
while [[ $done = false ]]; do
    done=true		# assume user will make a valid choice
    {
        print '1) gl35a'
        print '2) t2000'
        print '3) s531'
        print '4) vt99'
    } &gt;&amp;2
    read REPLY?'terminal? '

    case $REPLY in
        1 ) TERM=gl35a ;;
        2 ) TERM=t2000 ;;
        3 ) TERM=s531 ;;
        4 ) TERM=vt99 ;;
        * ) print 'invalid.'
	          done=false ;;
    esac
done
print 'TERM is $TERM'</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12198"></A
>The <b class="emphasis.bold">while</B
> loop is necessary so that the code repeats if
the user makes an invalid choice.<a class="indexterm" name="AUTOID-12201"></A
></P
><p class="para">This is roughly twice as many lines of code as the first solution in
<a class="xref" href="ch05_01.htm" webstripperlinkwas="ch05_01.htm" title="Flow Control">Chapter 5</A
>&nbsp;- but exactly as many as the later, more user-friendly version!
This shows that <b class="emphasis.bold">select</B
> saves you
code only if you don't mind using the same strings to <em class="emphasis">display</EM
>
your menu choices as you use inside your script.</P
><p class="para">However, <b class="emphasis.bold">select</B
> has other advantages, including the ability
to construct multicolumn menus if there are many choices,
and better handling of null user input.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="KSH-CH-7-SECT-2.2.5">7.2.2.5 Options to read</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-12211"></A
><b class="emphasis.bold">read</B
> takes a set of options that are similar to those
for <b class="emphasis.bold">print</B
>. 
<a class="xref" href="#KSH-CH-7-TAB-3" title="read Options">Table 7.4</A
>
lists them.<a class="indexterm" name="KSH-CH-7-IX-READ-OPTIONS-R"></A
><a class="indexterm" name="AUTOID-12221"></A
><a class="indexterm" name="AUTOID-12225"></A
><a class="indexterm" name="AUTOID-12229"></A
></P
><table class="table"><caption class="table"><a class="title" name="KSH-CH-7-TAB-3">Table 7.4: read Options</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Option</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Function</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-r</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Raw; do not use <b class="emphasis.bold">\\</B
> as 
line continuation character.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-p</B
></TD
><td class="entry" rowspan="1" colspan="1">Read from pipe to coroutine; see next chapter.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-s</B
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Save input in command history file.  See 
<a class="xref" href="ch01_01.htm" webstripperlinkwas="ch01_01.htm" title="Korn Shell Basics">Chapter 1</A
>.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><b class="emphasis.bold">-u</B
><em class="emphasis">n</EM
></TD
><td class="entry" rowspan="1" colspan="1">Read from file descriptor <em class="emphasis">n</EM
>.</TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-12264"></A
><b class="emphasis.bold">read</B
> lets you input lines that are longer than the width of
your display device by providing backslash (\) as a continuation
character, just as in shell scripts. The <b class="emphasis.bold">-r</B
> option to <b class="emphasis.bold">read</B
>
overrides this, in case your script reads from a file that may
contain lines that happen to end in backslashes.  </P
><p class="para"><b class="emphasis.bold">read -r</B
> also preserves any other escape sequences 
the input might contain. For example, if the file <em class="emphasis">fred</EM
>
contains this line:</P
><p class="para"><blockquote class="screen"><pre class="screen">A line with a\n escape sequence</PRE
></BLOCKQUOTE
></P
><p class="para">Then <b class="emphasis.bold">read -r fredline</B
> will include the backslash in the
variable <b class="emphasis.bold">fredline</B
>, whereas without the <b class="emphasis.bold">-r</B
>, <b class="emphasis.bold">read</B
>
will &quot;eat&quot; the backslash. As a result:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">read -r fredline &lt; fred</B
> 
$ <b class="emphasis.bold">print &quot;$fredline&quot;</B
> 
A line with a
 escape sequence
$</PRE
></BLOCKQUOTE
></P
><p class="para">However:</P
><p class="para"><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">read fredline &lt; fred</B
> 
$ <b class="emphasis.bold">print &quot;$fredline&quot;</B
> 
A line with an escape sequence
$</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12291"></A
></P
><p class="para"><a class="indexterm" name="AUTOID-12293"></A
>The <b class="emphasis.bold">-s</B
> option helps you if you are writing a highly interactive
script and you want to provide the same command-history
capability as the shell itself has.  <a class="indexterm" name="AUTOID-12298"></A
>
For example, say you are 
writing a new version of <em class="emphasis">mail</EM
> as a shell script. Your
basic command loop might look like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">while read -s cmd; do
    # process the command
done</PRE
></BLOCKQUOTE
></P
><p class="para">Using <b class="emphasis.bold">read -s</B
> allows the user to retrieve
previous commands to <em class="emphasis">your program</EM
> with the emacs-mode 
<kbd class="keycap">[CTRL-P]</KBD
> command or the vi-mode <span class="acronym">ESC</SPAN
> k command. The <em class="emphasis">kshdb</EM
> debugger in <a class="xref" href="ch09_01.htm" webstripperlinkwas="ch09_01.htm" title="Debugging Shell Programs">Chapter 9, Debugging Shell Programs</A
>
uses this feature.<a class="indexterm" name="AUTOID-12310"></A
></P
><p class="para"><a class="indexterm" name="KSH-CH-7-IX-I-O-REDIRECTION-FILE-DESCRIPTORS"></A
><a class="indexterm" name="KSH-CH-7-IX-READ-OPTIONS-U"></A
>Finally, the <b class="emphasis.bold">-u</B
><em class="emphasis">N</EM
> option is useful in scripts that
read from more than one file at the same time.
Here's an example of this that also uses 
the <em class="emphasis">n</EM
><b class="emphasis.bold">&lt;</B
> 
I/O redirector that we saw earlier in this chapter.</P
><div class="task"><h4>Task 7.4</H4
><blockquote class="taskinfo"><p class="para">Write a script that prints the contents of two files
side by side.</P
></BLOCKQUOTE
><p class="para">We'll format the output so the two output columns 
are fixed at 30 characters wide.
Here is the code:</P
><p class="para"><blockquote class="screen"><pre class="screen">typeset -L30 f1 f2
while read -u3 f1 &amp;&amp; read -u4 f2; do
    print &quot;$f1$f2&quot;
done 3&lt;$1 4&lt;$2</PRE
></BLOCKQUOTE
></P
><p class="para"><b class="emphasis.bold">read -u3</B
> reads from file descriptor 3, and <b class="emphasis.bold">3&lt;$1</B
>
directs the file given as first argument to be input on
that file descriptor; the same is true for the second argument
and file descriptor 4.<a class="indexterm" name="AUTOID-12336"></A
><a class="indexterm" name="AUTOID-12337"></A
>
Remember that file descriptors 0, 1, and 2 are already used
for standard I/O. We use file descriptors 3 and 4 for
our two input files; it's best to start from 3 and work
upwards to the shell's limit, which is 9.</P
><p class="para"><a class="indexterm" name="AUTOID-12339"></A
><a class="indexterm" name="AUTOID-12343"></A
>The <b class="emphasis.bold">typeset</B
> command and the quotes around the argument
to <b class="emphasis.bold">print</B
> ensure that the output columns are 30 characters
wide and that all whitespace in the lines from the file is
preserved.  <a class="indexterm" name="AUTOID-12347"></A
>
The <b class="emphasis.bold">while</B
> loop reads one line from each
file until at least one of them runs out of input.</P
><p class="para">Assume the file <em class="emphasis">dave</EM
> contains the following:</P
><p class="para"><blockquote class="screen"><pre class="screen">DAVE
Height: 5'10&quot;
Weight: 175 lbs.
Hair: brown
Eyes: brown</PRE
></BLOCKQUOTE
></P
><p class="para">And the file <em class="emphasis">shirley</EM
> contains this:</P
><p class="para"><blockquote class="screen"><pre class="screen">SHIRLEY
Height: 5'6&quot;
Weight: 142 lbs.
Hair: blonde
Eyes: blue</PRE
></BLOCKQUOTE
></P
><p class="para">If the script is called <em class="emphasis">twocols</EM
>, then <b class="emphasis.bold">twocols dave shirley</B
>
produces this output:</P
><p class="para"><blockquote class="screen"><pre class="screen">DAVE                          SHIRLEY
Height: 5'10&quot;                 Height: 5'6&quot;                  
Weight: 175 lbs.              Weight: 142 lbs.              
Hair: brown                   Hair: blonde                  
Eyes: brown                   Eyes: blue</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-12364"></A
></P
></DIV
></DIV
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch07_01.htm" webstripperlinkwas="ch07_01.htm" title="7.1 I/O Redirectors"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 7.1 I/O Redirectors" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" title="Learning the Korn Shell"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Learning the Korn Shell" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch07_03.htm" webstripperlinkwas="ch07_03.htm" title="7.3 Command-line Processing"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 7.3 Command-line Processing" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">7.1 I/O Redirectors</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">7.3 Command-line Processing</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="../upt/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="../sedawk/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
