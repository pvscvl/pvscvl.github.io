<html><head><title>[Chapter 13] 13.5 adj&nbsp;- Adjust Lines for Text Files</TITLE
><meta name="DC.title" content="sed &amp; awk"><meta name="DC.creator" content="Dale Dougherty &amp; Arnold Robbins"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-03T21:05:33Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-225-5" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch13_01.htm" webstripperlinkwas="ch13_01.htm" title="13. A Miscellany of Scripts"><link rel="prev" href="ch13_04.htm" webstripperlinkwas="ch13_04.htm" title="13.4 mailavg&nbsp;- Check Size of Mailboxes"><link rel="next" href="ch13_06.htm" webstripperlinkwas="ch13_06.htm" title="13.6 readsource&nbsp;- Format Program Source Files for troff"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="sed &amp; awk" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch13_04.htm" webstripperlinkwas="ch13_04.htm" title="13.4 mailavg&nbsp;- Check Size of Mailboxes"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 13.4 mailavg&nbsp;- Check Size of Mailboxes" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 13<br>A Miscellany of Scripts</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch13_06.htm" webstripperlinkwas="ch13_06.htm" title="13.6 readsource&nbsp;- Format Program Source Files for troff"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 13.6 readsource&nbsp;- Format Program Source Files for troff" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="AUTOID-11336">13.5 adj&nbsp;- Adjust Lines for Text Files</A
></H2
><p class="para"><em class="emphasis">Contributed by Norman Joseph</EM
></P
><p class="para"><a class="indexterm" name="CH13.B"></A
>[Because the author used his program to format his mail message
before sending it, we're preserving the linebreaks and
indented paragraphs in presenting it here as the program's example.
This program is similar to the BSD <kbd class="command">fmt</KBD
> program.]</P
><blockquote class="literallayout"><p class="literallayout">        Well, I decided to take you up on your offer.  I'm sure there are<br>more sophisticated gurus out there than me, but I do have a nawk script<br>that I'm kind of fond of, so I'm sending it in.<br><br>        Ok, here's the low down.  When I'm writing e-mail, I often make a<br>lot of changes to the text (especially if I'm going to post on the net).<br>So what starts out as a nicely adjusted letter or posting usually ends up<br>looking pretty sloppy by the time I'm done adding and deleting lines.  So<br>I end up spending a lot of time joining and breaking lines all through my<br>document so as to get a nice right-hand margin.  So I say to myself,<br>&quot;This is just the kind of tedious work a program would be good for.&quot;<br><br>        Now, I know I can use <kbd class="command">nroff</KBD
> to filter my document through and<br>adjust the lines, but it has lousy defaults (IMHO) for simple text like<br>this.  So, with a view to sharpening my nawk skills I wrote <kbd class="command">adj.nawk</KBD
><br>and the accompanying shell script wrapper <kbd class="command">adj</KBD
>.  <br><br>Here's the syntax for the nawk filter <kbd class="command">adj</KBD
>:<br><br><kbd class="command">adj </KBD
>[<i class="option">-l|c|r|b</I
>] [<i class="option">-w</I
> <code class="replaceable"><i>n</I
></CODE
>] [<i class="option">-i</I
> <code class="replaceable"><i>n</I
></CODE
>] [<code class="replaceable"><i>files ...</I
></CODE
>]<br><br>The options are:</P
></BLOCKQUOTE
><dl class="variablelist"><dt class="term"><i class="option">-l</I
></DT
><dd class="listitem"><p class="para">Lines are left adjusted, right ragged (default).</P
></DD
><dt class="term"><i class="option">-c</I
></DT
><dd class="listitem"><p class="para">Lines are centered.</P
></DD
><dt class="term"><i class="option">-r</I
></DT
><dd class="listitem"><p class="para">Lines are right adjusted, left ragged.</P
></DD
><dt class="term"><i class="option">-b</I
></DT
><dd class="listitem"><p class="para">Lines are left and right adjusted.</P
></DD
><dt class="term"><i class="option">-w</I
> <code class="replaceable"><i>n</I
></CODE
></DT
><dd class="listitem"><p class="para">Sets line width to <code class="replaceable"><i>n</I
></CODE
> characters (default is 70).</P
></DD
><dt class="term"><i class="option">-i</I
> <code class="replaceable"><i>n</I
></CODE
></DT
><dd class="listitem"><p class="para">Sets initial indent to <code class="replaceable"><i>n</I
></CODE
> characters (default is 0).</P
></DD
></DL
><blockquote class="literallayout"><p class="literallayout">        So, whenever I'm finished with this letter (I'm using <kbd class="command">vi</KBD
>) I will<br>give the command <kbd class="command">:%!adj -w73</KBD
> (I like my lines a little longer) and<br>all the breaking and joining will be done by a program (the way the Good<br>Lord intended :-).  Indents and blank lines are preserved, and two spaces<br>are given after any end-of-sentence punctuation.<br><br>        The program is naive about tabs, and when computing line lengths,<br>it considers a tab character to be one space wide.<br><br>        The program is notable for its use of command-line parameter<br>assignment, and some of the newer features of awk (nawk), such as the<br>match and split built-in functions, and for its use of support functions.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">#! /bin/sh
#
# adj - adjust text lines
#
# usage: adj [-l|c|r|b] [-w n] [-i n] [files ...]
#
# options:
#    -l    - lines are left adjusted, right ragged (default)
#    -c    - lines are centered
#    -r    - lines are right adjusted, left ragged
#    -b    - lines are left and right adjusted
#    -w n  - sets line width to &lt;n&gt; characters (default: 70)
#    -i n  - sets initial indent to &lt;n&gt; characters (default: 0)
#
# note:
#    output line width is -w setting plus -i setting
#
# author:
#    Norman Joseph (amanue!oglvee!norm)

adj=l
wid=70
ind=0

set -- `getopt lcrbw:i: $*`
if test $? != 0
then
    printf 'usage: %s [-l|c|r|b] [-w n] [-i n] [files ...]' $0
    exit 1
fi

for arg in $*
do
    case $arg in
    -l) adj=l;  shift;;
    -c) adj=c;  shift;;
    -r) adj=r;  shift;;
    -b) adj=b;  shift;;
    -w) wid=$2;  shift 2;;
    -i) ind=$2;  shift 2;;
    --) shift;  break;;
    esac
done

exec nawk -f adj.nawk type=$adj linelen=$wid indent=$ind $*</PRE
></BLOCKQUOTE
><blockquote class="literallayout"><p class="literallayout">Here's the <kbd class="command">adj.nawk</KBD
> script that's called by the shell script <kbd class="command">adj</KBD
>.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen"># adj.nawk -- adjust lines of text per options
#
# NOTE:  this nawk program is called from the shell script &quot;adj&quot;
#    see that script for usage &amp; calling conventions
#
# author:
#    Norman Joseph (amanue!oglvee!norm)

BEGIN  {
    FS = &quot;\n&quot;
    blankline  = &quot;^[ \t]*$&quot;
    startblank = &quot;^[ \t]+[^ \t]+&quot;
    startwords = &quot;^[^ \t]+&quot;
}

$0 ~ blankline {
    if ( type == &quot;b&quot; )
        putline( outline &quot;\n&quot; )
    else
        putline( adjust( outline, type ) &quot;\n&quot; )
    putline( &quot;\n&quot; )
    outline = &quot;&quot;
}

$0 ~ startblank {
    if ( outline != &quot;&quot; ) {
        if ( type == &quot;b&quot; )
            putline( outline &quot;\n&quot; )
        else
            putline( adjust( outline, type ) &quot;\n&quot; )
    }

    firstword = &quot;&quot;
    i = 1
    while ( substr( $0, i, 1 ) ~ &quot;[ \t]&quot; ) {
        firstword = firstword substr( $0, i, 1 )
        i++
    }
    inline = substr( $0, i )
    outline = firstword

    nf = split( inline, word, &quot;[ \t]+&quot; )

    for ( i = 1;  i &lt;= nf;  i++ ) {
        if ( i == 1 ) {
            testlen = length( outline word[i] )
        } else {
            testlen = length( outline &quot; &quot; word[i] )
            if ( match( &quot;.!?:;&quot;, &quot;\\&quot; substr( outline,
                    length( outline ), 1 )) )
                testlen++
        }

        if ( testlen &gt; linelen ) {
            putline( adjust( outline, type ) &quot;\n&quot; )
            outline = &quot;&quot;
        }

        if ( outline == &quot;&quot; )
            outline = word[i]
        else if ( i == 1 )
            outline = outline word[i]
        else {
            if ( match( &quot;.!?:;&quot;, &quot;\\&quot; substr( outline,
                   length( outline ), 1 )) )
                outline = outline &quot;  &quot; word[i]     # 2 spaces
            else
                outline = outline &quot; &quot; word[i]      # 1 space
        }
    }
}

$0 ~ startwords  {
    nf = split( $0, word, &quot;[ \t]+&quot; )

    for ( i = 1;  i &lt;= nf;  i++ ) {
        if ( outline == &quot;&quot; )
            testlen = length( word[i] )
        else {
            testlen = length( outline &quot; &quot; word[i] )
            if ( match( &quot;.!?:;&quot;, &quot;\\&quot; substr( outline,
                   length( outline ), 1 )) )
                testlen++
        }

        if ( testlen &gt; linelen ) {
            putline( adjust( outline, type ) &quot;\n&quot; )
            outline = &quot;&quot;
        }

        if ( outline == &quot;&quot; )
            outline = word[i]
        else {
            if ( match( &quot;.!?:;&quot;, &quot;\\&quot; substr( outline,
                   length( outline ), 1 )) )
                outline = outline &quot;  &quot; word[i]     # 2 spaces
            else
                outline = outline &quot; &quot; word[i]      # 1 space
        }
    }
}

END  {
    if ( type == &quot;b&quot; )
        putline( outline &quot;\n&quot; )
    else
        putline( adjust( outline, type ) &quot;\n&quot; )
}


#
# -- support functions --
#

function putline( line,    fmt )
{
    if ( indent ) {
        fmt = &quot;%&quot; indent &quot;s%s&quot;
        printf( fmt, &quot; &quot;, line )
    } else
        printf( &quot;%s&quot;, line )
}


function adjust( line, type,    fill, fmt )
{
    if ( type != &quot;l&quot; )
        fill = linelen - length( line )

    if ( fill &gt; 0 ) {
        if        ( type == &quot;c&quot; ) {
            fmt = &quot;%&quot; (fill+1)/2 &quot;s%s&quot;
            line = sprintf( fmt, &quot; &quot;, line )
        } else if ( type == &quot;r&quot; ) {
            fmt = &quot;%&quot; fill &quot;s%s&quot;
            line = sprintf( fmt, &quot; &quot;, line )
        } else if ( type == &quot;b&quot; ) {
            line = fillout( line, fill )
        }
    }

    return line
}


function fillout( line, need,    i, newline, nextchar, blankseen )
{
    while ( need ) {
        newline = &quot;&quot;
        blankseen = 0

        if ( dir == 0 ) {
            for ( i = 1;  i &lt;= length( line );  i++ ) {
                nextchar = substr( line, i, 1 )
                if ( need ) {
                    if ( nextchar == &quot; &quot; ) {
                        if ( ! blankseen ) {
                            newline = newline &quot; &quot;
                            need--
                            blankseen = 1
                        }
                    } else {
                        blankseen = 0
                    }
                }
                newline = newline nextchar
            }

        } else if ( dir == 1 ) {
            for ( i = length( line );  i &gt;= 1;  i-- ) {
                nextchar = substr( line, i, 1 )
                if ( need ) {
                    if ( nextchar == &quot; &quot; ) {
                        if ( ! blankseen ) {
                            newline = &quot; &quot; newline
                            need--
                            blankseen = 1
                        }
                    } else {
                        blankseen = 0
                    }
                }
                newline = nextchar newline
            }
        }

        line = newline
        dir = 1 - dir
    }

    return line
}</PRE
></BLOCKQUOTE
><div class="sect2"><h3 class="sect2"><a class="title" name="SEDAWK-CH-13-SECT-0.0.0.5">13.5.1 Program Notes for adj</A
></H3
><p class="para">This small text formatter is a nifty program for those of us
who use text editors.  It allows you to set the maximum line width
and justify paragraphs and thus can be used to format mail
messages or simple letters. </P
><p class="para">The <kbd class="command">adj</KBD
> shell script does all the option setting,
although it could have been done by reading <b class="emphasis.bold">ARGV</B
> 
in the <b class="emphasis.bold">BEGIN</B
> action.  Using the shell to establish command-line
parameters is probably easier
for those who are already familiar with the shell. </P
><p class="para">The lack of comments in the <kbd class="command">adj.awk</KBD
> script makes this
script more difficult to read than some of the others. 
The <kbd class="command">BEGIN</KBD
> procedure assigns three regular expressions to
variables:  <b class="emphasis.bold">blankline</B
>, <b class="emphasis.bold">startblank</B
>,
<b class="emphasis.bold">startwords</B
>.  This is a good technique
(one that you'll see used in <kbd class="command">lex</KBD
> specifications)
because regular expressions can be difficult to read
and the name of the variable makes it clear what it matches.
Remember that modern awks lets you supply a regular expression as
a string, in a variable.</P
><p class="para">There are three main procedures, which can be named by the variable
they match.  The first is <b class="emphasis.bold">blankline</B
>, a procedure
which handles collected
text once a blank line is encountered.  The second is <b class="emphasis.bold">startblank</B
>,
which handles lines that begin with whitespace (spaces or tabs).  The third
is <b class="emphasis.bold">startwords</B
>, which handles a line of text. 
The basic procedure is to read a line of text and determine how many
of the words in that line will fit, given the line width, outputting
those that will fit and saving those that will not in the variable
<b class="emphasis.bold">outline</B
>.  When the next input line is read, the contents of
<b class="emphasis.bold">outline</B
> must be output before that line is output. </P
><p class="para">The <kbd class="command">adjust()</KBD
> function does the work of justifying the text
based on a command-line option specifying the format type.
All types except &quot;l&quot; (left-adjusted, right-ragged) need
to be filled.  Therefore, the first thing this function does
is figure out how much &quot;fill&quot; is needed by subtracting
the length of the current line from the specified line length. 
It makes excellent use of the <kbd class="command">sprintf()</KBD
> function
to actually do the positioning of the text.  For instance,
to center text, the value of <b class="emphasis.bold">fill</B
> (plus 1) is divided by
2 to determine the amount of padding needed on each side of the
line.  This amount is passed through the <b class="emphasis.bold">fmt</B
> variable
as the argument to <kbd class="command">sprintf()</KBD
>:</P
><blockquote class="screen"><pre class="screen">            fmt = &quot;%&quot; (fill+1)/2 &quot;s%s&quot;
            line = sprintf( fmt, &quot; &quot;, line )</PRE
></BLOCKQUOTE
><p class="para">Thus, the space will be used to pad a field that is
the length of half the amount of fill needed.</P
><p class="para">If text is right-justified, the value of <b class="emphasis.bold">fill</B
> itself is used
to pad the field.  Finally, if the format type is &quot;b&quot; (block),
then the function <kbd class="command">fillout</KBD
> is called to determine
where to add spaces that will fill out the line.</P
><p class="para">In looking over the design of the program,
you can see, once again, how the use of functions helps
to clarify what a program is doing. 
It helps to think of the main procedure 
as controlling the flow of input through the program
while procedures handle
the operations performed on the input.
Separating the &quot;operations&quot; from the flow control makes
the program readable and more easily maintained.</P
><p class="para">In passing, we're not sure why <b class="emphasis.bold">FS</B
>, the field separator, is set
to newline
in the <kbd class="command">BEGIN</KBD
> procedure.  This means that the field and record 
separators are the same (i.e., $0 and $1 are the same). 
The <b class="emphasis.bold">split()</B
> function is
called to break the line into fields using tabs or spaces
as the delimiter.</P
><blockquote class="screen"><pre class="screen">nf = split( $0, word, &quot;[ \t]+&quot; )</PRE
></BLOCKQUOTE
><p class="para">It would seem that the field separator could have been set 
to the same regular expression, as follows: </P
><blockquote class="screen"><pre class="screen">FS = &quot;[ \t]+&quot;</PRE
></BLOCKQUOTE
><p class="para">It would be more efficient to use the default field parsing.</P
><p class="para">Finally, using the <b class="emphasis.bold">match()</B
> function to find punctuation is inefficient;
it would have been better to use <b class="emphasis.bold">index()</B
>.</P
></DIV
><a class="indexterm" name="AUTOID-11442"></A
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch13_04.htm" webstripperlinkwas="ch13_04.htm" title="13.4 mailavg&nbsp;- Check Size of Mailboxes"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 13.4 mailavg&nbsp;- Check Size of Mailboxes" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" title="sed &amp; awk"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="sed &amp; awk" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch13_06.htm" webstripperlinkwas="ch13_06.htm" title="13.6 readsource&nbsp;- Format Program Source Files for troff"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 13.6 readsource&nbsp;- Format Program Source Files for troff" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">13.4 mailavg&nbsp;- Check Size of Mailboxes</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">13.6 readsource&nbsp;- Format Program Source Files for troff</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="../upt/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="../ksh/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
