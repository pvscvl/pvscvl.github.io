<html><head><title>[Chapter 7] 7.8 Relational and Boolean Operators</TITLE
><meta name="DC.title" content="sed &amp; awk"><meta name="DC.creator" content="Dale Dougherty &amp; Arnold Robbins"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-03T20:57:36Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-225-5" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch07_01.htm" webstripperlinkwas="ch07_01.htm" title="7. Writing Scripts for awk"><link rel="prev" href="ch07_07.htm" webstripperlinkwas="ch07_07.htm" title="7.7 System Variables"><link rel="next" href="ch07_09.htm" webstripperlinkwas="ch07_09.htm" title="7.9 Formatted Printing"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="sed &amp; awk" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch07_07.htm" webstripperlinkwas="ch07_07.htm" title="7.7 System Variables"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 7.7 System Variables" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 7<br>Writing Scripts for awk</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch07_09.htm" webstripperlinkwas="ch07_09.htm" title="7.9 Formatted Printing"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 7.9 Formatted Printing" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="SEDAWK-CH-7-SECT-8">7.8 Relational and Boolean Operators</A
></H2
><p class="para"><a class="indexterm" name="CH07.RELAT1"></A
><a class="indexterm" name="CH07.RELAT3"></A
><a class="indexterm" name="CH07.RELAT4"></A
><a class="indexterm" name="CH07.RELAT5"></A
>Relational and Boolean operators allow you to make comparisons
between two expressions.
The relational operators are found in <a class="xref" href="#SEDAWK-CH-7-TAB-4" title="Relational Operators">Table 7.4</A
>.</P
><table class="table"><caption class="table"><a class="title" name="SEDAWK-CH-7-TAB-4">Table 7.4: Relational Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Operator</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">&lt;</TD
><td class="entry" rowspan="1" colspan="1">Less than<a class="indexterm" name="AUTOID-5670"></A
><a class="indexterm" name="AUTOID-5673"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">&gt;</TD
><td class="entry" rowspan="1" colspan="1">Greater than<a class="indexterm" name="AUTOID-5679"></A
><a class="indexterm" name="AUTOID-5682"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">&lt;=</TD
><td class="entry" rowspan="1" colspan="1">Less than or equal to<a class="indexterm" name="AUTOID-5688"></A
><a class="indexterm" name="AUTOID-5691"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">&gt;=</TD
><td class="entry" rowspan="1" colspan="1">Greater than or equal to<a class="indexterm" name="AUTOID-5697"></A
><a class="indexterm" name="AUTOID-5700"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">==</TD
><td class="entry" rowspan="1" colspan="1">Equal to<a class="indexterm" name="AUTOID-5706"></A
><a class="indexterm" name="AUTOID-5709"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">!=</TD
><td class="entry" rowspan="1" colspan="1">Not equal to<a class="indexterm" name="AUTOID-5715"></A
><a class="indexterm" name="AUTOID-5718"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">~</TD
><td class="entry" rowspan="1" colspan="1">Matches<a class="indexterm" name="AUTOID-5724"></A
><a class="indexterm" name="AUTOID-5726"></A
><a class="indexterm" name="AUTOID-5728"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">!~</TD
><td class="entry" rowspan="1" colspan="1">Does not match<a class="indexterm" name="AUTOID-5733"></A
><a class="indexterm" name="AUTOID-5736"></A
></TD
></TR
></TBODY
></TABLE
><p class="para">A relational expression can be used in place of a pattern
to control a particular action.
For instance, if we wanted to limit
the records selected
for processing to those that have five fields, we could
use the following expression:</P
><blockquote class="screen"><pre class="screen">NF == 5</PRE
></BLOCKQUOTE
><p class="para">This relational expression compares 
the value of <b class="emphasis.bold">NF</B
> (the number of fields for each input
record) to five.  If it is true, the action will be executed;
otherwise, it will not.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> Make sure you notice that the relational operator &quot;==&quot; (&quot;is equal to&quot;) 
is not the same as the assignment operator &quot;=&quot; (&quot;equals&quot;).  
It is a common error to use &quot;=&quot; instead of &quot;==&quot; to test for equality.</P
></BLOCKQUOTE
><p class="para">We can use a relational expression to validate the <i class="filename">phonelist</I
>
database before attempting to print out the record. </P
><blockquote class="screen"><pre class="screen">NF == 6 { print $1, $6 }</PRE
></BLOCKQUOTE
><p class="para">Then only lines with six fields will be printed.</P
><p class="para">The opposite of &quot;==&quot; is &quot;!=&quot; (&quot;is not equal to&quot;).
Similarly, you can compare one expression to another
to see if it is greater than (&gt;) or less than (&lt;)
or greater than or equal to (&gt;=) or less than or equal
to (&lt;=).
The expression</P
><blockquote class="screen"><pre class="screen">NR &gt; 1</PRE
></BLOCKQUOTE
><p class="para">tests whether the number of the current record is greater than 1.
As we'll see in the next chapter, relational expressions are typically
used in conditional (<kbd class="command">if</KBD
>) statements and
are evaluated to
determine whether or not a particular statement should be executed.  </P
><p class="para"><a class="indexterm" name="AUTOID-5754"></A
>Regular expressions are usually written enclosed in slashes.  These
can be thought of as regular expression <em class="emphasis">constants</EM
>, much as
<b class="emphasis.bold">&quot;hello&quot;</B
> is a string constant.  We've seen many examples
so far:</P
><blockquote class="screen"><pre class="screen">/^$/ { print &quot;This is a blank line.&quot; }</PRE
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-5761"></A
><a class="indexterm" name="AUTOID-5763"></A
><a class="indexterm" name="AUTOID-5765"></A
><a class="indexterm" name="AUTOID-5767"></A
><a class="indexterm" name="AUTOID-5770"></A
>However, you are not limited to regular expression constants.
When used with the relational operators
<kbd class="command">~</KBD
> (&quot;match&quot;) and <kbd class="command">!~</KBD
> (&quot;no match&quot;),
the right-hand side of the expression can be any awk expression;
awk treats it as a string that
specifies a regular expression.[9]
We've already seen an example of the <kbd class="command">~</KBD
> operator used in a
pattern-matching rule for the phone database:</P
><blockquote class="footnote"><p class="para">[9] You may also use strings instead of regular expression constants
when calling the <kbd class="command">match()</KBD
>, <kbd class="command">split()</KBD
>, <kbd class="command">sub()</KBD
>,
and <kbd class="command">gsub()</KBD
> functions.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">$5 ~ /MA/   { print $1 &quot;, &quot; $6 }</PRE
></BLOCKQUOTE
><p class="para">where the value of field 5 is compared against the regular expression
&quot;MA.&quot;</P
><p class="para">Since any expression can be used with <kbd class="command">~</KBD
> and <kbd class="command">!~</KBD
>,
regular expressions can be supplied through variables.
For instance, in the <i class="filename">phonelist</I
>
script, we could replace &quot;/MA/&quot; with <b class="emphasis.bold">state</B
>
and have a procedure that defines the value of state. </P
><blockquote class="screen"><pre class="screen">$5 ~ state  { print $1 &quot;, &quot; $6 }</PRE
></BLOCKQUOTE
><p class="para">This makes the script much more general to use because
<em class="emphasis">a pattern can change dynamically</EM
> during execution of the
script.  For instance, it allows us to get the value of <b class="emphasis.bold">state</B
> 
from a command-line parameter.
We will talk about passing command-line parameters
into a script later in this chapter.<a class="indexterm" name="AUTOID-5793"></A
><a class="indexterm" name="AUTOID-5794"></A
><a class="indexterm" name="AUTOID-5795"></A
><a class="indexterm" name="AUTOID-5796"></A
></P
><p class="para"><a class="indexterm" name="AUTOID-5798"></A
><a class="indexterm" name="AUTOID-5800"></A
>Boolean operators allow you to combine a series of comparisons.  
They are listed in <a class="xref" href="#SEDAWK-CH-7-TAB-5" title="Boolean Operators">Table 7.5</A
>.</P
><table class="table"><caption class="table"><a class="title" name="SEDAWK-CH-7-TAB-5">Table 7.5: Boolean Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Operator</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">||</TD
><td class="entry" rowspan="1" colspan="1">Logical OR<a class="indexterm" name="AUTOID-5815"></A
><a class="indexterm" name="AUTOID-5818"></A
><a class="indexterm" name="AUTOID-5820"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">&amp;&amp;</TD
><td class="entry" rowspan="1" colspan="1">Logical AND<a class="indexterm" name="AUTOID-5825"></A
><a class="indexterm" name="AUTOID-5828"></A
><a class="indexterm" name="AUTOID-5831"></A
><a class="indexterm" name="AUTOID-5833"></A
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">!</TD
><td class="entry" rowspan="1" colspan="1">Logical NOT<a class="indexterm" name="AUTOID-5838"></A
><a class="indexterm" name="AUTOID-5841"></A
><a class="indexterm" name="AUTOID-5844"></A
><a class="indexterm" name="AUTOID-5846"></A
></TD
></TR
></TBODY
></TABLE
><p class="para">Given two or more expressions, <kbd class="command">||</KBD
> specifies that
one of them must evaluate to true (non-zero or non-empty)
for the whole expression to be true.  
<kbd class="command">&amp;&amp;</KBD
> specifies that <em class="emphasis">both</EM
> of the expressions must be true to 
return true.</P
><p class="para">The following expression:</P
><blockquote class="screen"><pre class="screen">NF == 6 &amp;&amp; NR &gt; 1</PRE
></BLOCKQUOTE
><p class="para">states that the number of fields must be equal to 6 <em class="emphasis">and</EM
> that
the number of the record must be greater than 1.</P
><p class="para"><kbd class="command">&amp;&amp;</KBD
> has higher precedence than <kbd class="command">||</KBD
>.  Can you
tell how the following expression will be evaluated?</P
><blockquote class="screen"><pre class="screen">NR &gt; 1 &amp;&amp; NF &gt;= 2 || $1 ~ /\t/</PRE
></BLOCKQUOTE
><p class="para">The parentheses in the next example show which expression would
be evaluated first based on the rules of precedence.</P
><blockquote class="screen"><pre class="screen">(NR &gt; 1 &amp;&amp; NF &gt;= 2) || $1 ~ /\t/</PRE
></BLOCKQUOTE
><p class="para">In other words, both of the expressions in parentheses must be
true <em class="emphasis">or</EM
> the 
right hand side must be true.  You can use parentheses to override
the rules of precedence, as in the following example which
specifies that two conditions must be true.</P
><blockquote class="screen"><pre class="screen">NR &gt; 1 &amp;&amp; (NF &gt;= 2 || $1 ~ /\t/)</PRE
></BLOCKQUOTE
><p class="para">The first condition must be true <em class="emphasis">and</EM
> either of two other conditions
must be true.</P
><p class="para">Given an expression that is either true or false, the
<kbd class="command">!</KBD
> operator inverts the sense of the expression.</P
><blockquote class="screen"><pre class="screen">! (NR &gt; 1 &amp;&amp; NF &gt; 3)</PRE
></BLOCKQUOTE
><p class="para">This expression is true if the parenthesized expression is false.
This operator is most useful with awk's <kbd class="command">in</KBD
> operator to see if
an index is not in an array (as we shall see later), although it has
other uses as well.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="SEDAWK-CH-7-SECT-8.1">7.8.1 Getting Information About Files</A
></H3
><p class="para"><a class="indexterm" name="CH07.FILE1"></A
><a class="indexterm" name="CH07.FILE2"></A
>Now we are going to look at a couple of
scripts that process the output
of a UNIX command, <kbd class="command">ls</KBD
>.   The following
is a sample of the long listing produced by the command <kbd class="command">ls -l</KBD
>:[10]</P
><blockquote class="footnote"><p class="para">[10] Note that on a Berkeley 4.3BSD-derived UNIX system
such as Ultrix or SunOS 4.1.x, <kbd class="command">ls -l</KBD
> produces
an eight-column report; use <kbd class="command">ls -lg</KBD
> to get the same
report format shown here.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>ls -l</B
></CODE
>
-rw-rw-rw-   1 dale     project   6041 Jan  1 12:31 com.tmp
-rwxrwxrwx   1 dale     project   1778 Jan  1 11:55 combine.idx
-rw-rw-rw-   1 dale     project   1446 Feb 15 22:32 dang
-rwxrwxrwx   1 dale     project   1202 Jan  2 23:06 format.idx</PRE
></BLOCKQUOTE
><p class="para">This listing is a report in which data is presented in rows
and columns.  Each file is presented across a single row.
The file listing consists of nine columns.
The file's permissions appear in the first column,
the size of the file in bytes in
the fifth column, and the filename is found in
the last column.  Because
one or more spaces separate the data in columns,
we can treat each column as a field.</P
><p class="para">In our first example,
we're going to pipe the output of this command to an awk
script that prints selected fields from the
file listing.  
To do this, we'll create a 
shell script so that we can make the pipe transparent to the user. 
Thus, the structure of the shell script is:</P
><blockquote class="screen"><pre class="screen">ls -l $* | awk '<i class="filename">script</I
>'</PRE
></BLOCKQUOTE
><p class="para">The $* variable is used by the shell and expands to
all arguments passed from the command line.  (We could use
$1 here, which would pass the first argument, but passing
<em class="emphasis">all</EM
> the arguments provides greater flexibility.) 
These arguments can be the names of files or directories
or additional options to the <kbd class="command">ls</KBD
> command.
If no arguments are specified, the &quot;$*&quot; will be empty
and the current directory will be listed.
Thus, the output of the <kbd class="command">ls</KBD
> command will be directed to
awk, which will automatically read standard input, since
no filenames have been given.</P
><p class="para">We'd like our awk script to print the size and name of the file.
That is, print field 5 ($5) and field 9 ($9).</P
><blockquote class="screen"><pre class="screen">ls -l $* | awk '{ 
	print $5, &quot;\t&quot;, $9
}'</PRE
></BLOCKQUOTE
><p class="para">If we put the above lines in a file named <i class="filename">fls</I
>
and make that file executable, we can enter <kbd class="command">fls</KBD
>
as a command.</P
><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>fls</B
></CODE
>
6041     com.tmp
1778     combine.idx
1446     dang
1202     format.idx
$ <code class="userinput"><b>fls com*</B
></CODE
>
6041     com.tmp
1778     combine.idx</PRE
></BLOCKQUOTE
><p class="para">So what our program does is take the long listing and reduce it
to two fields.  Now, let's add new functionality to our report
by producing some information that the <kbd class="command">ls -l</KBD
> listing does not provide. 
We add each file's size to a running total, to produce
the total number of bytes used by all files in the listing.
We can also keep track of the number of files and produce
that total.
There are two parts to adding this functionality.  The first is
to accumulate the totals for each input line.  We create the variable
<b class="emphasis.bold">sum</B
> to accumulate the size of files and the variable
<b class="emphasis.bold">filenum</B
> to accumulate the number of files in the listing.</P
><blockquote class="screen"><pre class="screen">{
	sum += $5
	++filenum
	print $5, &quot;\t&quot;, $9 
}</PRE
></BLOCKQUOTE
><p class="para">The first expression uses the assignment operator
<kbd class="command">+=</KBD
>.  It adds the value of field 5 to the present value of the variable
<b class="emphasis.bold">sum</B
>.  
The second expression increments the present value of 
the variable <b class="emphasis.bold">filenum</B
>.
This variable is used as a <em class="emphasis">counter</EM
>, and each 
time the expression is evaluated, 
1 is added to the count.  </P
><p class="para">The action we've written will be applied to all input lines.
The totals that are accumulated in this action must
be printed after awk has read all the input lines.
Therefore, we write an action that is controlled by the
<kbd class="command">END</KBD
> rule.</P
><blockquote class="screen"><pre class="screen">END { print &quot;Total: &quot;, sum, &quot;bytes (&quot; filenum &quot; files)&quot; }</PRE
></BLOCKQUOTE
><p class="para">We can also use the <kbd class="command">BEGIN</KBD
> rule to add column headings to the
report.  </P
><blockquote class="screen"><pre class="screen">BEGIN { print &quot;BYTES&quot;, &quot;\t&quot;, &quot;FILE&quot; }</PRE
></BLOCKQUOTE
><p class="para">Now we can put this script in an executable file named <i class="filename">filesum</I
>
and execute it as a single-word command.</P
><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>filesum c* </B
></CODE
>
BYTES    FILE
882      ch01
1771     ch03
1987     ch04
6041     com.tmp
1778     combine.idx
Total:  12459 bytes (5 files)</PRE
></BLOCKQUOTE
><p class="para">What's nice about this command is that it allows you to determine
the size of all files in a directory or any group of files.  </P
><p class="para">While the basic mechanism works, there are a few problems to
be taken care of.
The first problem occurs when you list the entire directory
using the <kbd class="command">ls -l</KBD
> command.  
The listing contains
a line that specifies the total number of blocks in the directory.
The partial listing (all files beginning with &quot;c&quot;) in the previous
example does not have this line.
But the following line would be included in the output if the
full directory was listed:</P
><blockquote class="screen"><pre class="screen">total 555</PRE
></BLOCKQUOTE
><p class="para">The block total does not interest us because
the program displays the total file size in bytes.
Currently, <kbd class="command">filesum</KBD
> does not print this line; however,
it does read this line and cause the <kbd class="command">filenum</KBD
> counter to be incremented.</P
><p class="para">There is also a problem with this script in how
it handles subdirectories.  Look at the following
line from an <kbd class="command">ls -l</KBD
>: </P
><blockquote class="screen"><pre class="screen">drwxrwxrwx   3 dale     project         960 Feb  1 15:47 sed</PRE
></BLOCKQUOTE
><p class="para">A &quot;d&quot; as the first character in column 1 (file permissions) indicates that
the file is a subdirectory.  The size of this file (960 bytes) does not
indicate the size of files in that subdirectory and therefore, it
is slightly misleading to add it to the file size totals.  Also, it might be
helpful to indicate that it is a directory.</P
><p class="para">If you want to list the
files in subdirectories, supply the <i class="option">-R</I
> (recursive)
option on the command line. 
It will be passed to the <kbd class="command">ls</KBD
> command.
However, the listing is slightly different as it
identifies each directory.   
For instance, to identify the subdirectory <i class="filename">old</I
>, the
<kbd class="command">ls -lR</KBD
> listing produces a blank line followed
by:</P
><blockquote class="screen"><pre class="screen">./old:</PRE
></BLOCKQUOTE
><p class="para">Our script ignores that
line and a blank line preceding it but nonetheless they increment
the file counter.
Fortunately, we can devise rules 
to handle these cases. 
Let's look at the revised, commented script:</P
><blockquote class="screen"><pre class="screen">ls -l $* | awk '
# filesum: list files and total size in bytes
# input: long listing produced by &quot;ls -l&quot;

#1 output column headers
BEGIN { print &quot;BYTES&quot;, &quot;\t&quot;, &quot;FILE&quot; }

#2 test for 9 fields; files begin with &quot;-&quot;
NF == 9 &amp;&amp; /^-/ {
        sum += $5       # accumulate size of file
        ++filenum       # count number of files
        print $5, &quot;\t&quot;, $9       # print size and filename
}

#3 test for 9 fields; directory begins with &quot;d&quot;
NF == 9 &amp;&amp; /^d/ {
        print &quot;&lt;dir&gt;&quot;, &quot;\t&quot;, $9  # print &lt;dir&gt; and name
}

#4 test for ls -lR line ./dir:
$1 ~ /^\..*:$/ {
        print &quot;\t&quot; $0 # print that line preceded by tab
}

#5 once all is done,
END {
	# print total file size and number of files
	print &quot;Total: &quot;, sum, &quot;bytes (&quot; filenum &quot; files)&quot;
}'</PRE
></BLOCKQUOTE
><p class="para">The rules and their associated actions have been numbered
to make it easier to discuss them.  The listing
produced by <kbd class="command">ls -l</KBD
> contains nine fields for
a file.  Awk supplies the number of fields
for a record in the system variable <b class="emphasis.bold">NF</B
>.  
Therefore, rules 2 and 3 test that <b class="emphasis.bold">NF</B
> is equal to 9.
This helps us avoid matching odd blank lines 
or the line stating the block total. 
Because we want to handle directories and files differently,
we use another pattern to match the first character of
the line.  In rule 2 we test for &quot;-&quot; in the first position
on the line, which indicates a file.
The associated action increments
the file counter and adds the file size to the previous
total.  In rule 3, we test for a directory, indicated by &quot;d&quot; as
the first character.  The associated action
prints &quot;&lt;dir&gt;&quot; in place of the file size.   
Rules 2 and 3 are <em class="emphasis">compound</EM
> expressions, 
specifying two patterns that are
combined using the <kbd class="command">&amp;&amp;</KBD
> operator. 
Both patterns must be matched for the expression to
be true. </P
><p class="para">Rule 4 tests for the special case produced by the <kbd class="command">ls -lR</KBD
>
listing (&quot;./old:&quot;).
There are a number of patterns that we can write to match
that line, using regular expressions or relational expressions:</P
><blockquote class="screen"><pre class="screen">NF == 1			<i class="lineannotation">If the number of fields equals 1 ...</I
>
/^\..*:$/		<i class="lineannotation">If the line begins with a period followed by any number of
                                                   characters and ends in a colon...</I
>
$1 ~ /^\..*:$/		<i class="lineannotation">If field 1 matches the regular expression...</I
></PRE
></BLOCKQUOTE
><p class="para">We used the latter expression because it seems to be the most
specific.  It employs the match operator (~) to test the first
field against a regular expression.  The associated action
consists of only a <kbd class="command">print</KBD
> statement.</P
><p class="para">Rule 5 is the <b class="emphasis.bold">END</B
> pattern and its action is only executed once, 
printing the sum of file sizes as well as the number of files.</P
><p class="para">The <kbd class="command">filesum</KBD
> program demonstrates many of the
basic constructs used in awk.  What's more, it gives
you a pretty good idea of the process of developing a
program (although syntax errors produced by typos
and hasty thinking have been gracefully omitted).
If you wish to tinker with this program, you might add a counter
for a directories, or a rule that handles symbolic links.</P
><a class="indexterm" name="AUTOID-5961"></A
><a class="indexterm" name="AUTOID-5962"></A
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch07_07.htm" webstripperlinkwas="ch07_07.htm" title="7.7 System Variables"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 7.7 System Variables" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" title="sed &amp; awk"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="sed &amp; awk" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch07_09.htm" webstripperlinkwas="ch07_09.htm" title="7.9 Formatted Printing"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 7.9 Formatted Printing" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">7.7 System Variables</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">7.9 Formatted Printing</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="../upt/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="../ksh/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
