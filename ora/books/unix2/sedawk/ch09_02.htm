<html><head><title>[Chapter 9] 9.2 String Functions</TITLE
><meta name="DC.title" content="sed &amp; awk"><meta name="DC.creator" content="Dale Dougherty &amp; Arnold Robbins"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-03T21:00:25Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-225-5" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch09_01.htm" webstripperlinkwas="ch09_01.htm" title="9. Functions"><link rel="prev" href="ch09_01.htm" webstripperlinkwas="ch09_01.htm" title="9.1 Arithmetic Functions"><link rel="next" href="ch09_03.htm" webstripperlinkwas="ch09_03.htm" title="9.3 Writing Your Own Functions"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="sed &amp; awk" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch09_01.htm" webstripperlinkwas="ch09_01.htm" title="9.1 Arithmetic Functions"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 9.1 Arithmetic Functions" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 9<br>Functions</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch09_03.htm" webstripperlinkwas="ch09_03.htm" title="9.3 Writing Your Own Functions"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 9.3 Writing Your Own Functions" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="SEDAWK-CH-9-SECT-2">9.2 String Functions</A
></H2
><p class="para"><a class="indexterm" name="CH09.FUN5"></A
><a class="indexterm" name="CH09.FUN6"></A
>The built-in string functions are much more significant and
interesting than the numeric functions.  Because awk is essentially
designed as a string-processing language, a lot of its power
derives from these functions. 
<a class="xref" href="#SEDAWK-CH-9-TAB-2" title="Awk's Built-In String Functions">Table 9.2</A
> lists the string functions found in awk.</P
><table class="table"><caption class="table"><a class="title" name="SEDAWK-CH-9-TAB-2">Table 9.2: Awk's Built-In String Functions</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Awk Function</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">gsub</KBD
>(<em class="emphasis">r</EM
>,<em class="emphasis">s</EM
>,<em class="emphasis">t</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Globally substitutes <em class="emphasis">s</EM
> for each match of the regular 
expression <em class="emphasis">r</EM
> in the string <em class="emphasis">t</EM
>.  Returns the number 
of substitutions.  If <em class="emphasis">t</EM
> is not supplied, defaults to <b class="emphasis.bold">$0</B
>.<a class="indexterm" name="AUTOID-7554"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">index</KBD
>(<em class="emphasis">s</EM
>,<em class="emphasis">t</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns position of substring <em class="emphasis">t</EM
> in string <em class="emphasis">s</EM
> or 
zero if not present.  <a class="indexterm" name="AUTOID-7565"></A
><a class="indexterm" name="AUTOID-7567"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">length</KBD
>(<em class="emphasis">s</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns length of string <em class="emphasis">s</EM
> or length of <b class="emphasis.bold">$0</B
> 
if no string is supplied.<a class="indexterm" name="AUTOID-7578"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">match</KBD
>(<em class="emphasis">s</EM
>,<em class="emphasis">r</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns either the position in <em class="emphasis">s</EM
> where the regular expression
<em class="emphasis">r</EM
> begins, or 0 if no occurrences are found.  Sets the values
of <b class="emphasis.bold">RSTART</B
> and <b class="emphasis.bold">RLENGTH</B
>.<a class="indexterm" name="AUTOID-7591"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">split</KBD
>(<em class="emphasis">s</EM
>,<em class="emphasis">a</EM
>,<em class="emphasis">sep</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Parses string <em class="emphasis">s</EM
> into elements of array <em class="emphasis">a</EM
>
using field separator <em class="emphasis">sep</EM
>; returns number of elements.  
If <em class="emphasis">sep</EM
> is not supplied, <b class="emphasis.bold">FS</B
> is used.
Array splitting works the same way as field splitting.<a class="indexterm" name="AUTOID-7606"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">sprintf</KBD
>(&quot;<em class="emphasis">fmt</EM
>&quot;,<em class="emphasis">expr</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Uses <kbd class="command">printf</KBD
> format specification for <b class="emphasis.bold">expr</B
>.<a class="indexterm" name="AUTOID-7617"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">sub</KBD
>(<em class="emphasis">r</EM
>,<em class="emphasis">s</EM
>,<em class="emphasis">t</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Substitutes <em class="emphasis">s</EM
> for first match of the regular expression 
<em class="emphasis">r</EM
> in the string <em class="emphasis">t</EM
>.  Returns 1 if successful; 0 
otherwise.  If <em class="emphasis">t</EM
> is not supplied, defaults to <b class="emphasis.bold">$0</B
>.<a class="indexterm" name="AUTOID-7632"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">substr</KBD
>(<em class="emphasis">s</EM
>,<em class="emphasis">p</EM
>,<em class="emphasis">n</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns substring of string <em class="emphasis">s</EM
> at beginning position 
<em class="emphasis">p</EM
> up to a maximum length of <em class="emphasis">n</EM
>.  If <em class="emphasis">n</EM
> is 
not supplied, the rest of the string from <em class="emphasis">p</EM
> is used. <a class="indexterm" name="AUTOID-7647"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">tolower</KBD
>(<em class="emphasis">s</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Translates all uppercase characters in string <em class="emphasis">s</EM
> to 
lowercase and returns the new string.<a class="indexterm" name="AUTOID-7656"></A
><a class="indexterm" name="AUTOID-7658"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><kbd class="command">toupper</KBD
>(<em class="emphasis">s</EM
>)</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Translates all lowercase characters in string <em class="emphasis">s</EM
> to 
uppercase and returns the new string.<a class="indexterm" name="AUTOID-7667"></A
></P
></TD
></TR
></TBODY
></TABLE
><p class="para">The <kbd class="command">split()</KBD
> function was introduced in the previous chapter
in the discussion on arrays. </P
><p class="para"><a class="indexterm" name="AUTOID-7672"></A
>The <kbd class="command">sprintf()</KBD
> function 
uses the same format specifications as <kbd class="command">printf()</KBD
>, which is 
discussed in <a class="xref" href="ch07_01.htm" webstripperlinkwas="ch07_01.htm" title="Writing Scripts for awk">Chapter 7, Writing Scripts for awk</A
>.  It allows you to apply the format specifications
on a string.  Instead of printing the result, <kbd class="command">sprintf()</KBD
> returns
a string that can be assigned to a variable.  It can do
specialized processing of input records or fields,
such as performing character conversions.
For instance, the following example uses the <kbd class="command">sprintf()</KBD
>
function to convert a number into an ASCII character.   </P
><blockquote class="screen"><pre class="screen">for (i = 97; i &lt;= 122; ++i) {
	nextletter = sprintf(&quot;%c&quot;, i)
	...
}</PRE
></BLOCKQUOTE
><p class="para">A loop supplies numbers from 97 to 122, which produce
ASCII characters from <b class="emphasis.bold">a</B
> to
<b class="emphasis.bold">z</B
>. </P
><p class="para">That leaves us with three basic built-in
string functions to discuss: <kbd class="command">index()</KBD
>,
<kbd class="command">substr()</KBD
>, and <kbd class="command">length()</KBD
>. </P
><div class="sect2"><h3 class="sect2"><a class="title" name="SEDAWK-CH-9-SECT-2.1">9.2.1 Substrings</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-7690"></A
><a class="indexterm" name="AUTOID-7693"></A
>The <kbd class="command">index()</KBD
> and <kbd class="command">substr()</KBD
> functions both deal with
substrings.  
Given a string <em class="emphasis">s</EM
>, 
<kbd class="command">index</KBD
>(<em class="emphasis">s</EM
>,<em class="emphasis">t</EM
>) returns 
the leftmost position where string <em class="emphasis">t</EM
> 
is found in <em class="emphasis">s</EM
>. 
The beginning of the string is position 1 (which is different
from the C language, where the first character in a string is at position 0).
Look at the following example:</P
><blockquote class="screen"><pre class="screen">pos = index(&quot;Mississippi&quot;, &quot;is&quot;)</PRE
></BLOCKQUOTE
><p class="para">The value of <b class="emphasis.bold">pos</B
> is 2.
If the substring is not found, the <kbd class="command">index()</KBD
> function returns
0.</P
><p class="para"><a class="indexterm" name="AUTOID-7708"></A
>Given a string <em class="emphasis">s</EM
>, 
<kbd class="command">substr</KBD
>(<em class="emphasis">s</EM
>,<em class="emphasis">p</EM
>) returns 
the characters beginning at position <em class="emphasis">p</EM
>. 
The following example creates a phone number 
without an area code. </P
><blockquote class="screen"><pre class="screen">phone = substr(&quot;707-555-1111&quot;, 5)</PRE
></BLOCKQUOTE
><p class="para">You can also supply a third argument which is the number of
characters to return.  The next example returns just
the area code:</P
><blockquote class="screen"><pre class="screen">area_code = substr(&quot;707-555-1111&quot;, 1, 3)</PRE
></BLOCKQUOTE
><p class="para">The two functions can be and often are used together, as in the next
example.  This example capitalizes the first letter of the first
word for each input record.</P
><blockquote class="screen"><pre class="screen">awk '# caps - capitalize 1st letter of 1st word
# initialize strings
BEGIN { upper = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
        lower = &quot;abcdefghijklmnopqrstuvwxyz&quot; 
}

# for each input line
{
# get first character of first word
	FIRSTCHAR = substr($1, 1, 1)
# get position of FIRSTCHAR in lowercase array; if 0, ignore
	if (CHAR = index(lower, FIRSTCHAR)) 
		# change $1, using position to retrieve
		# uppercase character 
		$1 = substr(upper, CHAR, 1) substr($1, 2)
# print record
	print $0
}'</PRE
></BLOCKQUOTE
><p class="para">This script creates two variables, <b class="emphasis.bold">upper</B
> and <b class="emphasis.bold">lower</B
>,
consisting of uppercase and lowercase letters.  
Any character that we find in <b class="emphasis.bold">lower</B
> 
can be found at the same position in <b class="emphasis.bold">upper</B
>. 
The first
statement of the main procedure extracts a single character,
the first one, from the first field. 
The conditional statement tests to see if that character can
be found in <b class="emphasis.bold">lower</B
> using the <kbd class="command">index()</KBD
> function.  If
<b class="emphasis.bold">CHAR</B
> is not 0, then <b class="emphasis.bold">CHAR</B
> can be used to 
extract the uppercase character from <b class="emphasis.bold">upper</B
>.
There are two <kbd class="command">substr()</KBD
> function calls:  the first
one retrieves the capitalized letter and the second call
gets the rest of the first field, extracting
all characters, beginning with the second character.
The values returned by both <kbd class="command">substr()</KBD
> functions 
are concatenated and assigned
to $1.  
Making an assignment to a field
as we do here is a new twist, but it has the added benefit 
that the record can be output normally.  (If the assignment
was made to a variable, you'd have to output the variable
and then output the record's remaining fields.) 
The <kbd class="command">print</KBD
> statement prints the changed record.
Let's see it in action:</P
><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>caps</B
></CODE
>
<code class="userinput"><b>root user</B
></CODE
>
Root user
<code class="userinput"><b>dale</B
></CODE
>
Dale
<code class="userinput"><b>Tom</B
></CODE
>
Tom</PRE
></BLOCKQUOTE
><p class="para">In a little bit, we'll see how to
revise this program to change all
characters in a string from lower- to uppercase or vice versa.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="SEDAWK-CH-9-SECT-2.2">9.2.2 String Length</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-7742"></A
><a class="indexterm" name="AUTOID-7744"></A
><a class="indexterm" name="AUTOID-7746"></A
>When presenting the <kbd class="command">awkro</KBD
> program in the previous chapter, we
noted that the program was likely to
produce lines that exceed 80 characters.  
After all, the descriptions are quite
long.  We can find out how many characters are in a string
using the built-in function <kbd class="command">length()</KBD
>.  
For instance, to evaluate the length of the current input
record, we specify <kbd class="command">length($0)</KBD
>.
(As it happens, if <kbd class="command">length()</KBD
> is called without
an argument, it returns the length of $0.)</P
><p class="para">The <kbd class="command">length()</KBD
> function is often used to find
the length of the current input record, in order to determine
if we need to break the line.</P
><p class="para">One way to handle the line break, perhaps
more efficiently, is to use the <kbd class="command">length()</KBD
> function
to get the length of each field.  By accumulating those lengths,
we could specify a line break when a new field causes the total to exceed 
a certain number.</P
><p class="para"><a class="xref" href="ch13_01.htm" webstripperlinkwas="ch13_01.htm" title="A Miscellany of Scripts">Chapter 13, A Miscellany of Scripts</A
>,
contains a script that uses the <kbd class="command">length()</KBD
>
function to break lines greater than 80 columns wide.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="SEDAWK-CH-9-SECT-2.3">9.2.3 Substitution Functions</A
></H3
><p class="para"><a class="indexterm" name="CH09.SUB1"></A
><a class="indexterm" name="CH09.SUB2"></A
><a class="indexterm" name="CH09.SUB3"></A
><a class="indexterm" name="CH09.SUB4"></A
>Awk provides two substitution functions: <kbd class="command">sub()</KBD
> and
<kbd class="command">gsub()</KBD
>.  The difference between them is that <kbd class="command">gsub()</KBD
>
performs its substitution globally on the input string whereas
<kbd class="command">sub()</KBD
> makes only the first possible substitution.
This makes <kbd class="command">gsub()</KBD
> equivalent to the sed substitution
command with the <b class="emphasis.bold">g</B
> (global) flag. </P
><p class="para">Both functions take at least two arguments.  The first is a
regular expression (surrounded by slashes) that matches
a pattern and the second argument is a string that replaces what 
the pattern matches. 
The regular expression
can be supplied by a variable, in which case the slashes
are omitted.  An optional
third argument specifies the string that is the target of
the substitution.  If there is no third
argument, the substitution is made for the current
input record ($0).  </P
><p class="para">The substitution functions change the specified string directly.
You might expect, given the way functions work, that the function returns
the new string created when the substitution is made.
The substitution functions actually return 
the <em class="emphasis">number</EM
> of substitutions made.  <kbd class="command">sub()</KBD
>
will always return 1 if successful; both return 0 if not
successful.  Thus, you can test the result to see if a substitution
was made.</P
><p class="para">For example, the following example uses <kbd class="command">gsub()</KBD
>
to replace all occurrences
of &quot;UNIX&quot; with &quot;POSIX&quot;.  </P
><blockquote class="screen"><pre class="screen">if (gsub(/UNIX/, &quot;POSIX&quot;))
	print</PRE
></BLOCKQUOTE
><p class="para">The conditional statement tests the return
value of <kbd class="command">gsub()</KBD
> such that the current input line is printed
only if a change is made.</P
><p class="para">As with sed, if an &quot;&amp;&quot; appears in the substitution string, it will
be replaced by the string matched by the regular expression.
Use &quot;\&amp;&quot; to output an ampersand.
(Remember that to get a literal &quot;\&quot; into a string, you have
to type two of them.)
Also, note that awk does not &quot;remember&quot; the previous regular
expression, as does sed, so you cannot use the syntax
&quot;//&quot; to refer to the last regular expression.</P
><p class="para">The following example surrounds any occurrence of &quot;UNIX&quot; with 
the <kbd class="command">troff</KBD
> font-change escape sequences.</P
><blockquote class="screen"><pre class="screen">gsub(/UNIX/, &quot;\\fB&amp;\\fR&quot;)</PRE
></BLOCKQUOTE
><p class="para">If the input is &quot;the UNIX operating system&quot;, the
output is &quot;the \fBUNIX\fR operating system&quot;.</P
><p class="para">In <a class="xref" href="ch04_01.htm" webstripperlinkwas="ch04_01.htm" title="Writing sed Scripts">Chapter 4, Writing sed Scripts</A
>, we presented the 
following sed script named <kbd class="command">do.outline</KBD
>:</P
><blockquote class="screen"><pre class="screen">sed -n '
s/&quot;//g
s/^\.Se /Chapter /p
s/^\.Ah /<img src="../chars/bull.gif" webstripperlinkwas="../chars/bull.gif" alt="&#183;">A. /p
s/^\.Bh /<img src="../chars/bull.gif" webstripperlinkwas="../chars/bull.gif" alt="&#183;"><img src="../chars/bull.gif" webstripperlinkwas="../chars/bull.gif" alt="&#183;">B.  /p' $*</PRE
></BLOCKQUOTE
><p class="para">Now here's that script rewritten using the substitution
functions:</P
><blockquote class="screen"><pre class="screen">awk '
{
gsub(/&quot;/, &quot;&quot;)
if (sub(/^\.Se /, &quot;Chapter &quot;)) print
if (sub(/^\.Ah /, &quot;\tA. &quot;)) print
if (sub(/^\.Bh /, &quot;\t\tB.  &quot;)) print
}' $*</PRE
></BLOCKQUOTE
><p class="para">The two scripts are exactly equivalent, printing out
only those lines that are changed.
For the first edition of this book, Dale
compared the run-time of both scripts and, as he expected,
the awk script was slower. 
For the second edition, new timings showed that performance
varies by implementation, and in fact, all tested versions
of new awk were faster than sed!
This is nice, since
we have the capabilities in awk to make
the script do more things.  For instance, instead of
using letters of the alphabet, we could number the headings. 
Here's the revised awk script:</P
><blockquote class="screen"><pre class="screen">awk '# do.outline -- number headings in chapter.
{
gsub(/&quot;/, &quot;&quot;)
}
/^\.Se/ {
	sub(/^\.Se /, &quot;Chapter &quot;) 
	ch = $2
	ah = 0
	bh = 0
	print
	next
}
/^\.Ah/ {
	sub(/^\.Ah /, &quot;\t &quot; ch &quot;.&quot; ++ah &quot; &quot;) 
	bh = 0
	print
	next
}
/^\.Bh/ {
	sub(/^\.Bh /, &quot;\t\t &quot; ch &quot;.&quot;  ah &quot;.&quot; ++bh &quot; &quot;)
	print
}' $*</PRE
></BLOCKQUOTE
><p class="para">In this version, we break out each heading into its own
pattern-matching rule.  This is not necessary but seems
more efficient since we know that once a rule is applied,
we don't need to look at the others.
Note the use of the <kbd class="command">next</KBD
> statement to bypass further
examination of a line that has already been identified.</P
><p class="para">The chapter number 
is read as the first argument to the &quot;.Se&quot; macro
and is thus the second field on that line. 
The numbering scheme is done by incrementing a variable
each time the substitution is made.  
The action associated with the chapter-level heading
initializes the section-heading counters to zero.
The action associated with the top-level heading &quot;.Ah&quot;
zeroes the second-level heading counter.
Obviously, you can create as many levels of heading
as you need.
Note how we can specify a concatenation of 
strings and variables as a single
argument to the <kbd class="command">sub()</KBD
> function. </P
><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>do.outline ch02</B
></CODE
>
Chapter 2 Understanding Basic Operations
         2.1 Awk, by Sed and Grep, out of Ed 
         2.2 Command-line Syntax
                 2.2.1 Scripting
                 2.2.2 Sample Mailing List
         2.3 Using Sed
                 2.3.1 Specifying Simple Instructions
                 2.3.2 Script Files
         2.4 Using Awk
         2.5 Using Sed and Awk Together</PRE
></BLOCKQUOTE
><p class="para">If you wanted the option of choosing either numbers or letters, you
could maintain both programs and construct a shell wrapper that uses 
some flag to determine which program should be invoked.</P
><a class="indexterm" name="AUTOID-7807"></A
><a class="indexterm" name="AUTOID-7808"></A
><a class="indexterm" name="AUTOID-7809"></A
><a class="indexterm" name="AUTOID-7810"></A
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="SEDAWK-CH-9-SECT-2.4">9.2.4 Converting Case</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-7814"></A
><a class="indexterm" name="AUTOID-7817"></A
><a class="indexterm" name="AUTOID-7819"></A
><a class="indexterm" name="AUTOID-7822"></A
><a class="indexterm" name="AUTOID-7824"></A
>POSIX awk provides two functions for converting the case of characters
within a string.  The functions are <kbd class="command">tolower()</KBD
> and <kbd class="command">toupper()</KBD
>.
Each takes a single string argument, and returns a copy of that string,
with all the characters of one case converted to the other (upper to
lower and lower to upper, respectively).
Their use is straightforward:</P
><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>cat test</B
></CODE
>
Hello, World!
Good-bye CRUEL world!
1, 2, 3, and away we GO!
$ <code class="userinput"><b>awk '{ printf(&quot;&lt;%s&gt;, &lt;%s&gt;\n&quot;, tolower($0), toupper($0)) }' test</B
></CODE
>
&lt;hello, world!&gt;, &lt;HELLO, WORLD!&gt;
&lt;good-bye cruel world!&gt;, &lt;GOOD-BYE CRUEL WORLD!&gt;
&lt;1, 2, 3, and away we go!&gt;, &lt;1, 2, 3, AND AWAY WE GO!&gt;</PRE
></BLOCKQUOTE
><p class="para">Note that nonalphabetic characters are left unchanged.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="SEDAWK-CH-9-SECT-2.5">9.2.5 The match() Function</A
></H3
><p class="para"><a class="indexterm" name="CH09.MATCH1"></A
><a class="indexterm" name="CH09.MATCH2"></A
><a class="indexterm" name="CH09.MATCH3"></A
>The <kbd class="command">match()</KBD
> function 
allows you to determine if a regular expression matches a specified
string.  
It takes two arguments, the string and the regular
expression.  (This function is confusing because the regular
expression is in the second position, whereas
it is in the first position for the substitution functions.)</P
><p class="para">The <kbd class="command">match()</KBD
> function returns the starting position
of the substring that was matched by the regular expression.
You might consider it a close relation to the <kbd class="command">index()</KBD
>
function. 
In the following example, the regular expression matches  
any sequence of capital letters in the string &quot;the
UNIX operating system&quot;.</P
><blockquote class="screen"><pre class="screen">match(&quot;the UNIX operating system&quot;, /[A-Z]+/)</PRE
></BLOCKQUOTE
><p class="para">The value returned by this function is 5, the character position
of &quot;U,&quot; the first capital letter in the string.</P
><p class="para">The <kbd class="command">match()</KBD
> function also sets two system variables:
<b class="emphasis.bold">RSTART</B
> and <b class="emphasis.bold">RLENGTH</B
>. 
<b class="emphasis.bold">RSTART</B
> contains the same value returned by the function,
the starting position of the substring.  <b class="emphasis.bold">RLENGTH</B
> 
contains the length of the string in characters (not the ending
position of the substring).
When the pattern does not match, <b class="emphasis.bold">RSTART</B
> is set to 0
and <b class="emphasis.bold">RLENGTH</B
> is set to -1.
In the previous example, <b class="emphasis.bold">RSTART</B
> is equal to 5
and <b class="emphasis.bold">RLENGTH</B
> is equal to 4.  (Adding them together gives
you the position of the first character after the match.)</P
><p class="para">Let's look at a rather simple example 
that prints out 
a string matched by a specified regular expression, demonstrating the
&quot;extent of the match,&quot; as discussed in <a class="xref" href="ch03_01.htm" webstripperlinkwas="ch03_01.htm" title="Understanding Regular Expression Syntax">Chapter 3, Understanding Regular Expression Syntax</A
>.
The following shell script takes 
two command-line arguments:  the regular expression, which should
be specified in quotes, and the name of the file to search.</P
><blockquote class="screen"><pre class="screen">awk '# match -- print string that matches line
# for lines match pattern 
match($0, pattern) {
	# extract string matching pattern using
	# starting position and length of string in $0 
	# print string
	print substr($0, RSTART, RLENGTH)
}' pattern=&quot;$1&quot; $2</PRE
></BLOCKQUOTE
><p class="para">The first command-line parameter is passed as the value
of <b class="emphasis.bold">pattern</B
>. 
Note that $1 is surrounded by quotes, necessary to 
protect any spaces that might appear in the regular expression.
The <kbd class="command">match()</KBD
> function appears in a conditional expression
that controls execution of the only procedure in this awk
script. 
The <kbd class="command">match()</KBD
> function returns 0 if the pattern 
is not found, and a non-zero value (<b class="emphasis.bold">RSTART</B
>) if it is found,
allowing the return value to be used as a condition.
If the current record matches the pattern, then
the string is extracted from $0, using
the values of <b class="emphasis.bold">RSTART</B
> and <b class="emphasis.bold">RLENGTH</B
> in the <kbd class="command">substr()</KBD
>
function to specify the starting position of the substring to be
extracted and its length.  The substring
is printed.  This procedure only matches the first occurrence in $0.</P
><p class="para">Here's a trial run, given a regular expression that matches
&quot;emp&quot; and any number of characters up to a blank space: </P
><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>match &quot;emp[^ ]*&quot; personnel.txt</B
></CODE
>
employees
employee
employee.
employment,
employer
employment
employee's
employee</PRE
></BLOCKQUOTE
><p class="para">The <kbd class="command">match</KBD
> script could be a useful tool in
improving your understanding of regular expressions.</P
><p class="para">The next script uses the <kbd class="command">match()</KBD
> function to locate
any sequence of uppercase letters so that they can be converted
to lowercase.  Compare it to the <kbd class="command">caps</KBD
> program shown
earlier in the chapter.</P
><blockquote class="screen"><pre class="screen">awk '# lower - change upper case to lower case 
# initialize strings
BEGIN { upper = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
        lower = &quot;abcdefghijklmnopqrstuvwxyz&quot; 
}

# for each input line
{
# see if there is a match for all caps 
	 while (match($0, /[A-Z]+/))  
		# get each cap letter
		for (x = RSTART; x &lt; RSTART+RLENGTH; ++x) { 
			CAP = substr($0, x, 1)
			CHAR = index(upper, CAP)
			# substitute lowercase for upper 
			gsub(CAP, substr(lower, CHAR, 1))
		}
		
# print record
       print $0
}' $*</PRE
></BLOCKQUOTE
><p class="para">In this script, the <kbd class="command">match()</KBD
> function appears in
a conditional expression that determines whether
a <kbd class="command">while</KBD
> loop will be executed.
By placing this function in a loop, we apply the body
of the loop as many times as the pattern occurs 
in the current input record.</P
><p class="para">The regular expression matches any sequence of uppercase letters in
$0.  If a match is made,
a <kbd class="command">for</KBD
> loop does the lookup of each character in the
substring that was matched, similar to what we did in
the <kbd class="command">caps</KBD
> sample program, shown earlier in this chapter.  
What's different here is how we use the system variables
<b class="emphasis.bold">RSTART</B
> and <b class="emphasis.bold">RLENGTH</B
>.
<b class="emphasis.bold">RSTART</B
> initializes the counter variable <b class="emphasis.bold">x</B
>.  It
is used in the <kbd class="command">substr()</KBD
> function to extract one character
at a time from $0, beginning with the first character that
matched the pattern.  By
adding <b class="emphasis.bold">RLENGTH</B
> to <b class="emphasis.bold">RSTART</B
>, we get
the position of the first character after the ones that matched the pattern.
That is why the loop uses &quot;&lt;&quot; instead of &quot;&lt;=&quot;.
At the end, we use <kbd class="command">gsub()</KBD
> to replace the uppercase letter
with the corresponding lowercase letter.[2]
Notice that we use <kbd class="command">gsub()</KBD
> instead of <kbd class="command">sub()</KBD
>
because it offers us the advantage of making several substitutions
if there are multiple instances of the same letter
on the line.</P
><blockquote class="footnote"><p class="para">[2] You may be wondering, &quot;why not just use
<b class="emphasis.bold">tolower()</B
>?&quot; Good question.
Some early versions of <b class="emphasis.bold">nawk</B
>,
including the one on SunOS 4.1.x systems, don't have
<b class="emphasis.bold">tolower()</B
> and
<b class="emphasis.bold">toupper()</B
>; thus it's useful
to know how to do it yourself.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">$ <code class="userinput"><b>cat test</B
></CODE
>
Every NOW and then, a WORD I type appears in CAPS.
$ <code class="userinput"><b>lower test</B
></CODE
>
every now and then, a word i type appears in caps.</PRE
></BLOCKQUOTE
><p class="para">Note that you could change the regular expression to avoid
matching individual capital letters by matching
a sequence of two or more uppercase characters, by using:  &quot;/[A-Z][A-Z]+/.&quot;  
This would also require revising the way the lowercase
conversion was made using <kbd class="command">gsub()</KBD
>, since it matches
a single character on the line.</P
><p class="para">In our discussion of the sed substitution command, you saw
how to save and recall a portion of a string matched by
a pattern, using \( and \) to surround
the pattern to be saved and \<em class="emphasis">n</EM
> to recall the saved string
in the replacement pattern.  Unfortunately, awk's standard substitution
functions offer no equivalent syntax.  The <kbd class="command">match()</KBD
> function can
solve many such problems, though.</P
><p class="para">For instance, if you match a string using the <kbd class="command">match()</KBD
> function,
you can single out characters or a substring at the head
or tail of the string.  
Given the values of <b class="emphasis.bold">RSTART</B
> and <b class="emphasis.bold">RLENGTH</B
>,  
you can use the <kbd class="command">substr()</KBD
> function to extract the characters.
In the following example, we replace the second of
two colons with a semicolon.  We can't use <kbd class="command">gsub()</KBD
> to make the replacement
because &quot;/:/&quot; matches the first colon and &quot;/:[^:]*:/&quot; matches the
whole string of characters. 
We can use <kbd class="command">match()</KBD
> to match the string of characters
and to extract the last character of the string.</P
><blockquote class="screen"><pre class="screen"># replace 2nd colon with semicolon using match, substr
if (match($1, /:[^:]*:/)) {
	before = substr($1, 1, (RSTART + RLENGTH - 2))
	after = substr($1, (RSTART + RLENGTH))
	$1 = before &quot;;&quot; after
}</PRE
></BLOCKQUOTE
><p class="para">The <kbd class="command">match()</KBD
> function is placed within a conditional statement
that tests that a match was found.   
If there is a match, we use the <kbd class="command">substr()</KBD
> function to extract
the substring before the second colon as well as the substring 
after it.  Then we concatenate <b class="emphasis.bold">before</B
>, the literal &quot;;&quot;, and
<b class="emphasis.bold">after</B
>, assigning it to $1.</P
><p class="para">You can see examples of the <kbd class="command">match()</KBD
> function in use
in <a class="xref" href="ch12_01.htm" webstripperlinkwas="ch12_01.htm" title="Full-Featured Applications">Chapter 12, Full-Featured Applications</A
>.</P
><a class="indexterm" name="AUTOID-7925"></A
><a class="indexterm" name="AUTOID-7926"></A
><a class="indexterm" name="AUTOID-7927"></A
></DIV
><a class="indexterm" name="AUTOID-7928"></A
><a class="indexterm" name="AUTOID-7929"></A
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch09_01.htm" webstripperlinkwas="ch09_01.htm" title="9.1 Arithmetic Functions"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 9.1 Arithmetic Functions" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" title="sed &amp; awk"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="sed &amp; awk" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch09_03.htm" webstripperlinkwas="ch09_03.htm" title="9.3 Writing Your Own Functions"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 9.3 Writing Your Own Functions" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">9.1 Arithmetic Functions</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">9.3 Writing Your Own Functions</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="../upt/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="../ksh/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
