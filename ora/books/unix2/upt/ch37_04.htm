<html><head><title>[Chapter 37] 37.4 Why Learn Perl? #2 </TITLE
><meta name="DC.title" content="UNIX Power Tools"><meta name="DC.creator" content="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-04T21:48:53Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-260-3" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch37_01.htm" webstripperlinkwas="ch37_01.htm" title="37. Perl, a Pathologically Eclectic Rubbish Lister"><link rel="prev" href="ch37_03.htm" webstripperlinkwas="ch37_03.htm" title="37.3 Three Great Virtues of a Programmer "><link rel="next" href="ch37_05.htm" webstripperlinkwas="ch37_05.htm" title="37.5 And Now, Perl 5 "></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="UNIX Power Tools" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,58" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch37_03.htm" webstripperlinkwas="ch37_03.htm" title="37.3 Three Great Virtues of a Programmer "><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 37.3 Three Great Virtues of a Programmer " border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 37<br>Perl, a Pathologically Eclectic Rubbish Lister</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch37_05.htm" webstripperlinkwas="ch37_05.htm" title="37.5 And Now, Perl 5 "><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 37.5 And Now, Perl 5 " border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="UPT-ART-5562">37.4 Why Learn Perl? #2 </A
></H2
><p class="para">Donning my vestments as devil's advocate, let me start by saying that
just because you learn something new, you shouldn't entirely forget
the old.  UNIX is a pluralistic environment in which many paths
can lead to the solution, some more circuitously than others.
Different problems can call for different solutions.  If you force
yourself to program in nothing but Perl, you may be short-changing
yourself and taking the more tortuous route for some problems.</P
><p class="para">Now, that being said, I shall now reveal my true colors as Perl
disciple and perhaps not infrequent evangelist.  Perl is without
question the greatest single program to appear in the UNIX
community (although it runs elsewhere, too) in the last ten years.
[Tom wrote this in 1992 or so, but I'd bet his opinion hasn't changed
since then. <code class="literal">;-)</CODE
> <em class="emphasis">-JP</EM
>&nbsp;] It makes programming fun again.
It's simple enough to get a quick start on, but rich enough for some
very complex tasks.  I frequently learn new things about it despite
having used it nearly daily since Larry Wall first released it to the
general public around 1991.  Heck, sometimes even Larry learns
something new about Perl! The Artist is not always aware of the
breadth and depth of his own work.</P
><p class="para">It is indeed the case that Perl is a strict superset of <em class="emphasis">sed</EM
> and
<em class="emphasis">awk</EM
>, so much so that <em class="emphasis">s2p</EM
> and <em class="emphasis">a2p</EM
> translators exist
for these utilities.  You can do anything in Perl that you can do in
the shell, although Perl is, strictly speaking, not a command
interpreter.  It's more of a programming language.</P
><p class="para">Most of us have written, or at least seen, shell scripts from hell.
While often touted as one of UNIX's strengths because they're
conglomerations of small, single-purpose tools, these shell scripts
quickly grow so complex that they're cumbersome and hard to
understand, modify, and maintain.  After a certain point of
complexity, the strength of the UNIX philosophy of having many
programs that each does one thing well becomes its weakness.</P
><p class="para">The big problem with piping tools together is that there is only one
pipe.  This means that several different data streams have to get
multiplexed into a single data stream, then demuxed on the other end
of the pipe.  This wastes processor time as well as human brain power.</P
><p class="para">For example, you might be shuffling a list of filenames through a
pipe, but you also want to indicate that certain files have a
particular attribute, and others don't.  (For example, certain files
are more than ten days old.)  Typically, this information is encoded
in the data stream by appending or prepending some special marker
string to the filename.  This means that both the pipe feeder and the
pipe reader need to know about it.  Not a pretty sight.</P
><p class="para">Because <em class="emphasis">perl</EM
> is one program rather than a dozen others
(<em class="emphasis">sh</EM
>, <em class="emphasis">awk</EM
>, <em class="emphasis">sed</EM
>, <em class="emphasis">tr</EM
>, <em class="emphasis">wc</EM
>, <em class="emphasis">sort</EM
>,
<em class="emphasis">grep</EM
>, and so on), it is usually clearer to express yourself in
<em class="emphasis">perl</EM
> than in <em class="emphasis">sh</EM
> and allies, and often more efficient as
well.  You don't need as many pipes, temporary files, or separate
processes to do the job.  You don't need to go shoving your data
stream out to <em class="emphasis">tr</EM
> and back, and to <em class="emphasis">sed</EM
> and back, and to
<em class="emphasis">awk</EM
> and back, and to <em class="emphasis">sort</EM
> and back, and then back to
<em class="emphasis">sed</EM
>, and back again.  Doing so can often be slow, awkward,
and/or confusing.</P
><p class="para">Anyone who's ever tried to pass command-line arguments into a
<em class="emphasis">sed</EM
> script of moderate complexity or above can attest to the
fact that getting the quoting right is not a pleasant task.  In fact,
quoting in general in the shell is just not a pleasant thing to code
or to read.</P
><p class="para">In a heterogeneous computing environment, the available versions of
many tools vary too much from one system to the next to be utterly
reliable.  Does your <em class="emphasis">sh</EM
> understand functions on all your
machines?  What about your <em class="emphasis">awk</EM
>?  What about local variables?
It is very difficult to do complex programming without being able to
break a problem up into subproblems of lesser complexity.  You're
forced to resort to using the shell to call other shell scripts and
allow UNIX's power of
<span class="link">spawning processes (<a class="linkend" href="ch38_02.htm" webstripperlinkwas="ch38_02.htm" title="fork and exec ">38.2</A
>)</SPAN
>
to serve as your subroutine mechanism, which is inefficient at best.
That means your script will require several separate scripts to run,
and getting all these installed, working, and maintained on all the
different machines in your local configuration is painful.  With
<em class="emphasis">perl</EM
>, all you need to do is get it installed on the
system&nbsp;- which is really pretty easy thanks to Larry's <em class="emphasis">Configure</EM
>
program&nbsp;- and after that you're home free.</P
><p class="para">Perl is even beginning to be included by some software and hardware
vendors' standard software distributions.  I predict we'll see a lot
more of this in the next couple of years.</P
><p class="para">Besides being faster, <em class="emphasis">perl</EM
> is a more powerful tool than
<em class="emphasis">sh</EM
>, <em class="emphasis">sed</EM
>, or <em class="emphasis">awk</EM
>.  I realize these are fighting words
in some camps, but so be it.  There exists a substantial niche between
shell programming and C programming that <em class="emphasis">perl</EM
> conveniently
fills.  Tasks of this nature seem to arise with extreme frequency in
the realm of system administration.  Since system administrators
almost invariably have far too much to do to devote a week to coding
up every task before them in C, <em class="emphasis">perl</EM
> is especially useful for
them.  Larry Wall, Perl's author, has been known to call it &quot;a shell
for C programmers.&quot;  I like to think of it as a &quot;BASIC for
UNIX.&quot;  I realize that this carries both good and bad
connotations.</P
><p class="para">In what ways is <em class="emphasis">perl</EM
> more powerful than the individual tools?
This list is pretty long, so what follows is not necessarily an
exhaustive list.  To begin with, you don't have to worry about
arbitrary and annoying restrictions on string length, input line
length, or number of elements in an array.  These are all virtually
unlimited; i.e., limited to your system's address space and virtual
memory size.</P
><p class="para">Perl's
<span class="link">regular expression (<a class="linkend" href="ch26_04.htm" webstripperlinkwas="ch26_04.htm" title="Using Metacharacters in Regular Expressions ">26.4</A
>)</SPAN
>
handling is far and above the best I've ever seen.  For one thing, you
don't have to remember which tool wants which particular flavor of
regular expressions, or lament the fact that one tool doesn't allow
<code class="literal">(..|..)</CODE
> constructs or <code class="literal">+</CODE
>'s <code class="literal">\b</CODE
>'s or whatever.
With Perl, it's all the same&nbsp;- and, as far as I can tell, a proper
superset of all the others.</P
><p class="para">Perl has a fully functional symbolic debugger (written, of course, in
Perl) that is an indispensable aid in debugging complex programs.
Neither the shell nor <em class="emphasis">sed</EM
>/<em class="emphasis">awk</EM
>/<em class="emphasis">sort</EM
>/<em class="emphasis">tr</EM
>/... have
such a thing.</P
><p class="para">Perl has a loop control mechanism that's more powerful even than C's.
You can do the equivalent of a <em class="emphasis">break</EM
> or <em class="emphasis">continue</EM
>
(<em class="emphasis">last</EM
> and <em class="emphasis">next</EM
> in Perl) of any arbitrary loop, not merely
the nearest enclosing one.  You can even do a kind of <em class="emphasis">continue</EM
>
that doesn't trigger the re-initialization part of a loop, something
you may, from time to time, want to do.</P
><p class="para">Perl's data types and operators are richer than the shells' or
<em class="emphasis">awk</EM
>'s, because you have scalars, numerically-indexed arrays
(lists), and string-indexed (hashed) arrays.  Each of these holds
arbitrary data values, including floating-point numbers, for which
mathematic built-in subroutines and power operators are available.  It
can handle binary data of arbitrary size.</P
><p class="para">Speaking of LISP, you can generate strings, perhaps with
<em class="emphasis">sprintf</EM
>&nbsp;(&nbsp;), and then <em class="emphasis">eval</EM
> them.  That way you can
generate code on the fly.  You can even do lambda-type functions that
return newly created functions that you can call later. The scoping of
variables is dynamic; fully recursive subroutines are supported; and
you can pass or return any type of data into or out of your
subroutines.</P
><p class="para">You have a built-in automatic formatter for generating pretty printed
forms with automatic pagination and headers and center-justified and
text-filled fields like <code class="literal">%(|fmt)s</CODE
>, if you can imagine what that
would actually be were it legal.</P
><p class="para">There's a mechanism for writing
<span class="link">SUID (<a class="linkend" href="ch01_23.htm" webstripperlinkwas="ch01_23.htm" title="File Access Permissions ">1.23</A
>)</SPAN
>
programs that can be made more secure than even C programs, thanks to
an elaborate data-tracing mechanism that understands the &quot;taintedness&quot;
of data derived from external sources.  It won't let you do anything
really stupid that you might not have thought of.</P
><p class="para">You have access to just about any system-related function or system
call, like <em class="emphasis">ioctl</EM
>s, <em class="emphasis">fcntl</EM
>, <em class="emphasis">select</EM
>, <em class="emphasis">pipe</EM
> and
<em class="emphasis">fork</EM
>, <em class="emphasis">getc</EM
>, <em class="emphasis">socket</EM
> and <em class="emphasis">bind</EM
>, and <em class="emphasis">connect</EM
>
and <em class="emphasis">attach</EM
>, and indirect <em class="emphasis">syscall</EM
> invocation, as well as
things like <em class="emphasis">getpwuid</EM
>, <em class="emphasis">gethostbyname</EM
>, etc.  You can
read in binary data laid out by a C program or system call using
structure-conversion templates.</P
><p class="para">At the same time you can get at the high-level shell-type operations
like the
<span class="link"><em class="emphasis">-r</EM
> or <em class="emphasis">-w</EM
> tests (<a class="linkend" href="ch44_20.htm" webstripperlinkwas="ch44_20.htm" title="test: Testing Files and Strings ">44.20</A
>)</SPAN
>
on files or
<span class="link"><code class="literal">`backquote`</CODE
> (<a class="linkend" href="ch09_16.htm" webstripperlinkwas="ch09_16.htm" title="Command Substitution ">9.16</A
>)</SPAN
>
command interpolation.  You can do file-globbing with the
<span class="link"><code class="literal">&lt;*.[</CODE
><code class="replaceable"><i>ch</I
></CODE
><code class="literal">]&gt;</CODE
> (<a class="linkend" href="ch15_01.htm" webstripperlinkwas="ch15_01.htm#UPT-ART-1480" title="File Naming Wildcards ">15.1</A
>)</SPAN
>
notation or do low-level <em class="emphasis">readdir</EM
>s as suits your fancy.</P
><p class="para">DBM files can be accessed using simple array notation.  This is really
nice for dealing with system databases (aliases, news, ...), efficient
access mechanisms over large data sets, and for keeping persistent
data.</P
><p class="para">Don't be dismayed by the apparent complexity of what I've just
discussed.  Perl is actually very easy to learn because so much of it
derives from existing tools.  It's like interpreter C with <em class="emphasis">sh</EM
>,
<em class="emphasis">sed</EM
>, <em class="emphasis">awk</EM
>, and a lot more built into it.  And, finally,
there's a lot of code out there already written in Perl, including
libraries to handle things you don't feel like re-implementing.<a class="indexterm" name="AUTOID-42056"></A
></P
><div class="sect1info"><p class="SECT1INFO">- <span class="authorinitials">TC</SPAN
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch37_03.htm" webstripperlinkwas="ch37_03.htm" title="37.3 Three Great Virtues of a Programmer "><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 37.3 Three Great Virtues of a Programmer " border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" title="UNIX Power Tools"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="UNIX Power Tools" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch37_05.htm" webstripperlinkwas="ch37_05.htm" title="37.5 And Now, Perl 5 "><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 37.5 And Now, Perl 5 " border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">37.3 Three Great Virtues of a Programmer </TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">37.5 And Now, Perl 5 </TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="../sedawk/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="../ksh/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
