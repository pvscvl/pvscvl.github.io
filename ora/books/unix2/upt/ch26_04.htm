<html><head><title>[Chapter 26] 26.4 Using Metacharacters in Regular Expressions </TITLE
><meta name="DC.title" content="UNIX Power Tools"><meta name="DC.creator" content="Jerry Peek, Tim O'Reilly &amp; Mike Loukides"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1998-08-04T21:44:01Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-260-3" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch26_01.htm" webstripperlinkwas="ch26_01.htm" title="26. Regular Expressions (Pattern Matching)"><link rel="prev" href="ch26_03.htm" webstripperlinkwas="ch26_03.htm" title="26.3 Understanding Expressions "><link rel="next" href="ch26_05.htm" webstripperlinkwas="ch26_05.htm" title="26.5 Getting Regular Expressions Right "></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" alt="UNIX Power Tools" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,58" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="jobjects/fsearch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch26_03.htm" webstripperlinkwas="ch26_03.htm" title="26.3 Understanding Expressions "><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 26.3 Understanding Expressions " border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 26<br>Regular Expressions (Pattern Matching)</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch26_05.htm" webstripperlinkwas="ch26_05.htm" title="26.5 Getting Regular Expressions Right "><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 26.5 Getting Regular Expressions Right " border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="UPT-ART-0427">26.4 Using Metacharacters in Regular Expressions </A
></H2
><p class="para"><a class="indexterm" name="UPT-ART-427-IX-REGULAR-EXPRESSIONS-METACHARACTERS-IN"></A
>There are three important parts to a regular expression: </P
><ol class="orderedlist"><li class="listitem"><p class="para"><em class="emphasis">Anchors</EM
><a class="indexterm" name="AUTOID-28439"></A
>
are used to specify the position of the pattern in relation to a line of
text.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">Character sets</EM
><a class="indexterm" name="AUTOID-28444"></A
>
match one or more characters in a single position.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">Modifiers</EM
><a class="indexterm" name="AUTOID-28449"></A
>
specify how many times the previous character set is repeated.</P
></LI
></OL
><p class="para">A simple example that demonstrates all three parts is the regular
expression: </P
><p class="para"><blockquote class="screen"><pre class="screen">^#*</PRE
></BLOCKQUOTE
></P
><p class="para">The caret (<code class="literal">^</CODE
>) is an anchor that indicates the beginning of the line. 
The hash mark 
is a simple character set that matches the
single character
<code class="literal">#</CODE
>.
The asterisk (<code class="literal">*</CODE
>) is a modifier.
In a regular expression it specifies that the previous character set
can appear any number of times, including zero.
As you will see shortly, this is a useless regular expression
(except for demonstrating the syntax!).</P
><p class="para">There are two main types of regular expressions: 
<em class="emphasis">simple</EM
>
regular expressions and 
<em class="emphasis">extended</EM
>
regular expressions.
(As we'll see later in the article, the boundaries between the two
types have become blurred as regular expressions have evolved.)
A few utilities like
<em class="emphasis">awk</EM
>
and
<em class="emphasis">egrep</EM
>
use the extended regular expression.
Most use the 
simple
regular expression.
From now on, if I talk about a 
&quot;regular expression&quot; (without specifying simple or extended),
I am describing a feature common to both types.</P
><p class="para">The commands that understand just simple regular expressions are:
<em class="emphasis">vi</EM
>, <em class="emphasis">sed</EM
>, <em class="emphasis">grep</EM
>, <em class="emphasis">csplit</EM
>, <em class="emphasis">dbx</EM
>,
<em class="emphasis">more</EM
>, <em class="emphasis">ed</EM
>, <em class="emphasis">expr</EM
>, <em class="emphasis">lex</EM
>, and <em class="emphasis">pg</EM
>.
The utilities <em class="emphasis">awk</EM
>, <em class="emphasis">nawk</EM
>, and <em class="emphasis">egrep</EM
>
understand extended regular expressions.</P
><p class="para">[The situation is complicated by the fact that simple regular
expressions have evolved over time, and so there are versions of
&quot;simple regular expressions&quot; that support extensions missing from
extended regular expressions!
Bruce explains the incompatibility at
the end of his article. -<em class="emphasis">TOR</EM
>&nbsp;]</P
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.1">26.4.1 The Anchor Characters: ^ and $ </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28482"></A
><a class="indexterm" name="AUTOID-28485"></A
><a class="indexterm" name="AUTOID-28488"></A
>Most UNIX text facilities are line-oriented. Searching for patterns
that span several lines is not easy to do.
You see, the end-of-line character is not included in the block of
text that is searched.
It is a separator.
Regular expressions examine the text between the separators.
If you want to search for a pattern that is at one end or the other,
you use
<em class="emphasis">anchors</EM
>.
The caret (<code class="literal">^</CODE
>)
is the starting anchor, and the 
dollar sign (<code class="literal">$</CODE
>)
is the end anchor.
The regular expression <code class="literal">^A</CODE
>
will match all lines that start with an uppercase A.
The expression
<code class="literal">A$</CODE
>
will match all lines that end with uppercase A.
If the anchor characters are not used at the proper end of the
pattern, then they no longer act as anchors.
That is, the 
<code class="literal">^</CODE
>
is only an anchor if it is the first character in a regular
expression.
The
<code class="literal">$</CODE
>
is only an anchor if it is the last character.
The expression
<code class="literal">$1</CODE
>
does not have an anchor.
Neither does
<code class="literal">1^</CODE
>.
If you need to match a
<code class="literal">^</CODE
>
at the beginning of the line or a
<code class="literal">$</CODE
>
at the end of a line, you must 
<em class="emphasis">escape</EM
>
the special character by typing a backslash (<code class="literal">\</CODE
>) before it.
<a class="xref" href="#UPT-ART-427-TAB-0" title="Regular Expression Anchor Character Examples">Table 26.1</A
>
has a summary.</P
><table class="table"><caption class="table"><a class="title" name="UPT-ART-427-TAB-0">Table 26.1: Regular Expression Anchor Character Examples</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Pattern</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Matches</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">^A</CODE
></TD
><td class="entry" rowspan="1" colspan="1">An A at the beginning of a line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">A$</CODE
></TD
><td class="entry" rowspan="1" colspan="1">An A at the end of a line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">A</CODE
></TD
><td class="entry" rowspan="1" colspan="1">An A anywhere on a line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$A</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A <code class="literal">$A</CODE
> anywhere on a line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^\^</TD
><td class="entry" rowspan="1" colspan="1">A <code class="literal">^</CODE
> at the beginning of a line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^^</TD
><td class="entry" rowspan="1" colspan="1">Same as <code class="literal">^\^</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">\$$</TD
><td class="entry" rowspan="1" colspan="1">A <code class="literal">$</CODE
> at the end of a line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">$$</TD
><td class="entry" rowspan="1" colspan="1">Same as <code class="literal">\$$</CODE
></TD
></TR
></TBODY
></TABLE
><p class="para">The use of
<code class="literal">^</CODE
>
and
<code class="literal">$</CODE
>
as indicators of the beginning or end of a line is a convention
other utilities use.
The
<em class="emphasis">vi</EM
>
editor uses these two characters as commands to go to the beginning or
end of a line.
The C shell uses
<code class="literal">!^</CODE
>
to specify the first argument of the previous line, and
<code class="literal">!$</CODE
>
is the last argument on the previous line
(article
<a class="xref" href="ch11_07.htm" webstripperlinkwas="ch11_07.htm" title="History Substitutions ">11.7</A
>
explains).</P
><p class="para">It is one of those choices that other utilities go along with to
maintain consistency.
For instance,
<code class="literal">$</CODE
>
can refer to the last line of a file when using
<em class="emphasis">ed</EM
>
and
<em class="emphasis">sed</EM
>.
<span class="link"><em class="emphasis">cat -v -e</EM
> (<a class="linkend" href="ch25_06.htm" webstripperlinkwas="ch25_06.htm" title="What's in That White Space? ">25.6</A
>, <a class="linkend" href="ch25_07.htm" webstripperlinkwas="ch25_07.htm" title="Show Non-Printing Characters with cat -v or od -c ">25.7</A
>)</SPAN
>
marks ends of lines with a
<code class="literal">$</CODE
>.
You might see it in other programs as well.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.2">26.4.2 Matching a Character with a Character Set </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28562"></A
><a class="indexterm" name="AUTOID-28564"></A
>The simplest character set is a character.
The regular expression
<code class="literal">the</CODE
>
contains three character sets:
<code class="literal">t</CODE
>,
<code class="literal">h</CODE
>,
and 
<code class="literal">e</CODE
>.
It will match any line that contains the string
<code class="literal">the</CODE
>,
including the word
<code class="literal">other</CODE
>.
To prevent this, put spaces (<img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" ">) before and after the pattern:
<img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" "><code class="literal">the</CODE
><img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" ">.
You can combine the string with an anchor.
The pattern
<code class="literal">^From:</CODE
><img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" ">
will match the lines of a
<span class="link">mail message (<a class="linkend" href="ch01_33.htm" webstripperlinkwas="ch01_33.htm" title="UNIX Networking and Communications ">1.33</A
>)</SPAN
>
that identify the sender.
Use this pattern with <em class="emphasis">grep</EM
> to print every address in your incoming mailbox:</P
><p class="para"><table class="screen.co" border="1"><tr><th valign="TOP"><pre class="calloutlist">
<a class="co" href="ch06_03.htm" webstripperlinkwas="ch06_03.htm" title="6.3 Predefined Environment Variables ">$USER</A
> </PRE
></TH
><td valign="TOP"><pre class="screen">
% <code class="userinput"><b>grep '^From: ' /usr/spool/mail/$USER</B
></CODE
></PRE
></TD
></TR
></TABLE
></P
><p class="para">Some characters have a special meaning in regular expressions.
If you want to search for such a character as itself, escape it with a
backslash (<code class="literal">\</CODE
>).</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.3">26.4.3 Match any Character with . (Dot) </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28586"></A
>The dot (<code class="literal">.</CODE
>)
is one of those special metacharacters. 
By itself it will match any character, except the end-of-line
character.
The pattern that will match a line with any single character is: 
<code class="literal">^.$</CODE
>.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.4">26.4.4 Specifying a Range of Characters with [...] </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28594"></A
>If you want to match specific characters, you can use 
square brackets, <code class="literal">[]</CODE
>, to identify the exact characters you are searching for.
The pattern that will match any line of text that contains exactly one
digit is: 
<code class="literal">^[0123456789]$</CODE
>.
This is longer than it has to be.
You can use the hyphen between two characters to specify a range:
<code class="literal">^[0-9]$</CODE
>.
You can intermix explicit characters with character ranges.
This pattern will match a single character that is a letter, digit,
or underscore:
<code class="literal">[A-Za-z0-9_]</CODE
>.
Character sets can be combined by placing them next to one another.
If you wanted to search for a word that:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">started with an uppercase T,</P
></LI
><li class="listitem"><p class="para">was the first word on a line,</P
></LI
><li class="listitem"><p class="para">the second letter was a lowercase letter,</P
></LI
><li class="listitem"><p class="para">was three letters long (followed by a space character 
(<img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" ">)), and</P
></LI
><li class="listitem"><p class="para">the third letter was a lowercase vowel,</P
></LI
></UL
><p class="para">the regular expression would be: 
<code class="literal">^T[a-z][aeiou]</CODE
><img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" ">.</P
><p class="para">[To be specific:
A range is a contiguous series of characters, from low to high, in the
<span class="link">ASCII chart (<a class="linkend" href="ch51_03.htm" webstripperlinkwas="ch51_03.htm" title="ASCII Characters: Listing and Getting Values ">51.3</A
>)</SPAN
>.
For example, <code class="literal">[z-a]</CODE
> is <em class="emphasis">not</EM
> a range because it's backwards.
The range <code class="literal">[A-z]</CODE
> does match both uppercase and lowercase letters,
but it also matches the six characters that fall between uppercase
and lowercase letters in the ASCII chart:
<code class="literal">[</CODE
>, <code class="literal">\</CODE
>, <code class="literal">]</CODE
>, <code class="literal">^</CODE
>, <code class="literal">_</CODE
>, and <code class="literal">`</CODE
>.
<em class="emphasis">-JP</EM
>&nbsp;]</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.5">26.4.5 Exceptions in a Character Set </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28629"></A
><a class="indexterm" name="AUTOID-28632"></A
>You can easily search for all characters except those in square
brackets by putting a
caret (<code class="literal">^</CODE
>)
as the first character after the 
left square bracket (<code class="literal">[</CODE
>).
To match all characters except lowercase vowels use: 
<code class="literal">[^aeiou]</CODE
>.</P
><p class="para">Like the anchors in places that can't be considered an anchor, the
right square bracket (<code class="literal">]</CODE
>)
and
dash (<code class="literal">-</CODE
>)
do not have a special meaning if they directly follow 
a&nbsp;<code class="literal">[</CODE
>.
<a class="xref" href="#UPT-ART-427-TAB-1" title="Regular Expression Character Set Examples">Table 26.2</A
>
has some examples.&#13;</P
><table class="table"><caption class="table"><a class="title" name="UPT-ART-427-TAB-1">Table 26.2: Regular Expression Character Set Examples</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Regular Expression</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Matches</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[0-9]</TD
><td class="entry" rowspan="1" colspan="1">Any digit</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[^0-9]</TD
><td class="entry" rowspan="1" colspan="1">Any character other than a digit</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[-0-9]</TD
><td class="entry" rowspan="1" colspan="1">Any digit or a <code class="literal">-</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[0-9-]</TD
><td class="entry" rowspan="1" colspan="1">Any digit or a <code class="literal">-</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[^-0-9]</TD
><td class="entry" rowspan="1" colspan="1">Any character except a digit or a <code class="literal">-</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[]0-9]</TD
><td class="entry" rowspan="1" colspan="1">Any digit or a <code class="literal">]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[0-9]]</TD
><td class="entry" rowspan="1" colspan="1">Any digit followed by a <code class="literal">]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[0-99-z]</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Any digit or any character <span class="link">between 
9 and z (<a class="linkend" href="ch51_03.htm" webstripperlinkwas="ch51_03.htm" title="ASCII Characters: Listing and Getting Values ">51.3</A
>)</SPAN
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">[]0-9-]</TD
><td class="entry" rowspan="1" colspan="1">Any digit, a <code class="literal">-</CODE
>, or a <code class="literal">]</CODE
></TD
></TR
></TBODY
></TABLE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.6">26.4.6 Repeating Character Sets with <code class="literal">*</CODE
> </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28691"></A
>The third part of a regular expression is the modifier.
It is used to specify how many times you expect to see the previous
character set. The special character <code class="literal">*</CODE
>&nbsp;(asterisk)
matches
<em class="emphasis">zero or more</EM
>
copies.
That is, the regular expression
<code class="literal">0*</CODE
>
matches 
zero or more zeros,
while the expression
<code class="literal">[0-9]*</CODE
>
matches zero or more digits.</P
><p class="para">This explains why the pattern
<code class="literal">^#*</CODE
>
is useless, as it matches any number of 
<code class="literal">#</CODE
>'s
at the beginning of the line, including 
<em class="emphasis">zero</EM
>.
Therefore, this will match every line, because every line starts with
zero or more 
<code class="literal">#</CODE
>'s.</P
><p class="para">At first glance, it might seem that starting the count at zero is
stupid.
Not so.
Looking for an unknown number of characters is very important.
Suppose you wanted to look for a digit at the beginning of a line,
and there may or may not be spaces before the digit.
Just use <code class="literal">^</CODE
><img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" "><code class="literal">*</CODE
>
to match zero or more spaces at the beginning of the line.
If you need to match one or more, just repeat the character set.
That is, 
<code class="literal">[0-9]*</CODE
>
matches zero or more digits and
<code class="literal">[0-9][0-9]*</CODE
>
matches one or more digits.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.7">26.4.7 Matching a Specific Number of Sets with \&nbsp;{ and \&nbsp;} </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28711"></A
><a class="indexterm" name="AUTOID-28714"></A
>You cannot specify a maximum number of sets
with the
<code class="literal">*</CODE
>
modifier.
However, 
<span class="link">some programs (<a class="linkend" href="ch26_09.htm" webstripperlinkwas="ch26_09.htm" title="Valid Metacharacters for Different UNIX Programs ">26.9</A
>)</SPAN
>
recognize a 
special pattern you can use to specify the
minimum and maximum number of repeats. 
This is done by putting those two numbers between 
<code class="literal">\{</CODE
>
and
<code class="literal">\}</CODE
>.</P
><p class="para">Having convinced you that 
<code class="literal">\{</CODE
>
isn't a plot to confuse you, an example is in order. The regular
expression to match four, five, six, seven, or eight lowercase letters is:
<code class="literal">[a-z]\{4,8\}</CODE
>.
Any numbers between 0 and 255 can be used.
The second number may be omitted, which removes the upper limit.
If the comma and the second number are omitted, the pattern must be
duplicated the exact number of times specified by the first number.</P
><blockquote class="caution"><p class="para"><strong>CAUTION:</STRONG
> The backslashes deserve a special discussion.
Normally a backslash 
<em class="emphasis">turns off</EM
>
the special meaning for a character.
For example, a literal period is matched by 
<code class="literal">\.</CODE
>
and a literal asterisk is matched by
<code class="literal">\*</CODE
>.

However, if a backslash is placed before a
<code class="literal">&lt;</CODE
>,
<code class="literal">&gt;</CODE
>,
<code class="literal">{</CODE
>,
<code class="literal">}</CODE
>,
<code class="literal">(</CODE
>, or
<code class="literal">)</CODE
>
or before a digit, the backslash
<em class="emphasis">turns on</EM
>
a special meaning.
This was done because these special functions were added late in the
life of regular expressions. 
Changing the meaning of 
<code class="literal">{</CODE
>, <code class="literal">}</CODE
>,
<code class="literal">(</CODE
>, <code class="literal">)</CODE
>,
<code class="literal">&lt;</CODE
>, and <code class="literal">&gt;</CODE
>
would have broken old expressions. (This is a horrible crime punishable
by a year of hard labor writing COBOL programs.)
Instead, adding a backslash added functionality without breaking old
programs. Rather than complain about the change, view it as evolution.&#13;</P
></BLOCKQUOTE
><p class="para">You must remember that modifiers like
<code class="literal">*</CODE
>
and
<code class="literal">\{1,5\}</CODE
>
only act as modifiers if they follow a character set.
If they were at the beginning of a pattern, they would not be modifiers.
<a class="xref" href="#UPT-ART-427-TAB-2" title="Regular Expression Pattern Repetition Examples">Table 26.3</A
>
is a list of examples, and the exceptions.&#13;</P
><table class="table"><caption class="table"><a class="title" name="UPT-ART-427-TAB-2">Table 26.3: Regular Expression Pattern Repetition Examples</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Regular Expression</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Matches</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">*</TD
><td class="entry" rowspan="1" colspan="1">Any line with a <code class="literal">*</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">\*</TD
><td class="entry" rowspan="1" colspan="1">Any line with a <code class="literal">*</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">\\</TD
><td class="entry" rowspan="1" colspan="1">Any line with a <code class="literal">\</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^*</TD
><td class="entry" rowspan="1" colspan="1">Any line starting with a <code class="literal">*</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^A*</TD
><td class="entry" rowspan="1" colspan="1">Any line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^A\*</TD
><td class="entry" rowspan="1" colspan="1">Any line starting with an A<code class="literal">*</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^AA*</TD
><td class="entry" rowspan="1" colspan="1">Any line starting with one A</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^AA*B</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Any line starting with one or more A's followed
by a B</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^A\{4,8\}B</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Any line starting with four, five, six, seven, or eight A's 
followed by a B</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^A\{4,\}B</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Any line starting with four or more A's followed
by a B</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">^A\{4\}B</TD
><td class="entry" rowspan="1" colspan="1">Any line starting with an AAAAB</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">\{4,8\}</TD
><td class="entry" rowspan="1" colspan="1">Any line with a {4,8}</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">A{4,8}</TD
><td class="entry" rowspan="1" colspan="1">Any line with an A{4,8}</TD
></TR
></TBODY
></TABLE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.8">26.4.8 Matching Words with \&nbsp;&lt; and \&nbsp;&gt; </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28804"></A
><a class="indexterm" name="AUTOID-28807"></A
>Searching for a word isn't quite as simple as it at first appears.
The string
<code class="literal">the</CODE
>
will match the word 
<code class="literal">other</CODE
>.
You can put spaces before and after the letters and use this regular
expression:
<img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" "><code class="literal">the</CODE
><img src="../chars/squ.gif" webstripperlinkwas="../chars/squ.gif" alt=" ">.
However, this does not match words at the beginning or the end of the line.
And it does not match the case where there is a punctuation mark
after the word. </P
><p class="para">There is an easy solution&nbsp;- at least in many versions of <em class="emphasis">ed</EM
>, <em class="emphasis">ex</EM
>, and
<em class="emphasis">vi</EM
>.
The characters 
<code class="literal">\&lt;</CODE
>
and
<code class="literal">\&gt;</CODE
>
are similar to the
<code class="literal">^</CODE
>
and
<code class="literal">$</CODE
>
anchors,
as they don't occupy a position of a character.
They do 
<em class="emphasis">anchor</EM
>
the expression between to match only if it is on a word boundary.
The pattern to search for the words
<code class="literal">the</CODE
> and <code class="literal">The</CODE
>
would be:
<code class="literal">\&lt;[tT]he\&gt;</CODE
>.</P
><p class="para">Let's define a &quot;word boundary.&quot;
The character before the
<code class="literal">t</CODE
> or <code class="literal">T</CODE
>
must be either a newline character or anything except a letter,
digit, or underscore (&nbsp;<code class="literal">_</CODE
>&nbsp;).
The character after the
<code class="literal">e</CODE
>
must

also be a character other than a digit, letter, or underscore,
or it could be the end-of-line character.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.9">26.4.9 Remembering Patterns with \&nbsp;(, \&nbsp;), and \1 </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28833"></A
><a class="indexterm" name="AUTOID-28836"></A
><a class="indexterm" name="AUTOID-28839"></A
>Another pattern that requires a special mechanism is searching for
repeated words.
The expression
<code class="literal">[a-z][a-z]</CODE
>
will match any two lowercase letters.
If you wanted to search for lines that had two adjoining identical
letters, the above pattern wouldn't help.
You need a way to remember what you found and see if 
the same pattern occurs again.
In some programs, 
you can mark part of a pattern using
<code class="literal">\(</CODE
>
and
<code class="literal">\)</CODE
>.
You can recall the remembered pattern with
<code class="literal">\</CODE
> 
followed by a single digit.
Therefore, to search for two identical letters, use:
<code class="literal">\([a-z]\)\1</CODE
>.
You can have nine different remembered patterns. 
Each occurrence of 
<code class="literal">\(</CODE
>
starts a new pattern.
The regular expression to match a five-letter palindrome 
(e.g., &quot;radar&quot;) is:
<code class="literal">\([a-z]\)\([a-z]\)[a-z]\2\1</CODE
>.
[Some versions of some programs can't handle <code class="literal">\(&nbsp;\)</CODE
> in the same
regular expression as <code class="literal">\</CODE
><code class="replaceable"><i>1</I
></CODE
>, etc.
In all versions of <em class="emphasis">sed</EM
>, you're safe if you use
<span class="link"> <code class="literal">/( /)</CODE
> on the pattern side of an <em class="emphasis">s</EM
> command-and<code class="literal">/</CODE
><code class="replaceable"><i>1</I
></CODE
>, etc., on the replacement side . (<a class="linkend" href="ch34_10.htm" webstripperlinkwas="ch34_10.htm" title="Referencing Portions of a Search String ">34.10</A
>)</SPAN
>
<em class="emphasis">-JP</EM
> ]</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.10">26.4.10 Potential Problems </A
></H3
><p class="para">That completes a discussion of simple regular expressions.
Before I discuss the extensions that extended expressions offer, I
want to mention two potential problem areas.</P
><p class="para">The 
<code class="literal">/&lt;</CODE
>
and
<code class="literal">/&gt;</CODE
>
characters were introduced in the
<em class="emphasis">vi</EM
>
editor. The other programs didn't have this ability at that time.
Also, the
<code class="literal">/{</CODE
><code class="replaceable"><i>min</I
></CODE
><code class="literal">,</CODE
><code class="replaceable"><i>max</I
></CODE
><code class="literal">/}</CODE
>
modifier is new, and earlier utilities didn't have this ability.
This makes it difficult for the novice user of regular expressions,
because it seems as if each utility has a different convention.
Sun has retrofitted the newest regular expression library to all of
their programs, so they all have the same ability.
If you try to use these newer features on other vendors' machines, you
might find they don't work the same way.</P
><p class="para">The other potential point of confusion is the 
<span class="link">extent of the pattern matches (<a class="linkend" href="ch26_06.htm" webstripperlinkwas="ch26_06.htm" title="Just What Does a Regular Expression Match? ">26.6</A
>)</SPAN
>.
Regular expressions match the longest possible pattern.
That is, the regular expression
<code class="literal">A.*B</CODE
>
matches 
<code class="literal">AAB</CODE
>
as well as 
<code class="literal">AAAABBBBABCCCCBBBAAAB</CODE
>.
This doesn't cause many problems using
<em class="emphasis">grep</EM
>,
because an oversight in a regular expression will just match more
lines than desired.
If you use 
<em class="emphasis">sed</EM
>,
and your patterns get carried away, you may end up deleting or
changing more than you want to.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="UPT-ART-427-SECT-1.11">26.4.11 Extended Regular Expressions </A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28881"></A
><a class="indexterm" name="AUTOID-28883"></A
><a class="indexterm" name="AUTOID-28886"></A
><a class="indexterm" name="AUTOID-28888"></A
><a class="indexterm" name="AUTOID-28891"></A
>Two programs use extended regular expressions:
<em class="emphasis">egrep</EM
>
and 
<em class="emphasis">awk</EM
>.
[<em class="emphasis">perl</EM
> uses expressions that are even more extended. <em class="emphasis">-JP</EM
> ]
With these extensions, those special characters preceded by a backslash
no longer have special meaning:
<code class="literal">/{</CODE
>,
<code class="literal">/}</CODE
>,
<code class="literal">/&lt;</CODE
>,
<code class="literal">/&gt;</CODE
>,
<code class="literal">/(</CODE
>,
<code class="literal">/)</CODE
>,
as well as 
<code class="literal">/</CODE
><code class="replaceable"><i>digit</I
></CODE
>.
There is a very good reason for this, which I will
delay explaining to build up suspense.</P
><p class="para"><a class="indexterm" name="AUTOID-28906"></A
>The 
question mark (<code class="literal">?</CODE
>) 
matches zero or one instances of the character set before it, and the<a class="indexterm" name="AUTOID-28910"></A
>
plus sign (<code class="literal">+</CODE
>)
matches one or more copies of the character set.
You can't use <code class="literal">/{</CODE
> and <code class="literal">/}</CODE
> in extended regular expressions,
but if you could, you might consider
<code class="literal">?</CODE
>
to be the same as
<code class="literal">/{0,1/}</CODE
>
and 
<code class="literal">+</CODE
>
to be the same as
<code class="literal">/{1,/}</CODE
>.</P
><p class="para">By now, you are wondering why the extended regular expressions 
are even worth using. Except for two abbreviations, there seem to be no
advantages and a lot of disadvantages.
Therefore, examples would be useful.</P
><p class="para">The three important characters in the expanded regular expressions are
<code class="literal">(</CODE
>,
<code class="literal">|</CODE
>,
and 
<code class="literal">)</CODE
>.<a class="indexterm" name="AUTOID-28925"></A
><a class="indexterm" name="AUTOID-28928"></A
>
Parentheses are used to group expressions; the vertical bar acts an
an OR operator.
Together, they let you match a
<em class="emphasis">choice</EM
>
of patterns.
As an example, you can 
use <em class="emphasis">egrep</EM
>
to print all 
<code class="literal">From:</CODE
> 
and 
<code class="literal">Subject:</CODE
>
lines from your incoming mail:</P
><p class="para"><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>egrep '^(From|Subject): ' /usr/spool/mail/$USER</B
></CODE
></PRE
></BLOCKQUOTE
></P
><p class="para">All lines starting with 
<code class="literal">From:</CODE
>
or
<code class="literal">Subject:</CODE
>
will be printed. There is no easy way to do this with simple
regular expressions. You could try something like
<code class="literal">^[FS][ru][ob][mj]e*c*t*:</CODE
>
and hope you don't have any lines that start with
<code class="literal">Sromeet:</CODE
>.
Extended expressions don't have
the 
<code class="literal">/&lt;</CODE
>
and
<code class="literal">/&gt;</CODE
>
characters.
You can compensate by using the alternation mechanism.
Matching the word
&quot;the&quot;
in the beginning, middle, or end of a sentence or at the end of a line can be
done with the extended regular expression:
<code class="literal">(^| )the([^a-z]|$)</CODE
>.
There are two choices before the word: a space or the beginning of a
line.
Following the word, there must be something besides a lowercase letter or
else the end of the line.
One extra bonus with extended regular expressions is the ability to
use the
<code class="literal">*</CODE
>,
<code class="literal">+</CODE
>,
and 
<code class="literal">?</CODE
>
modifiers after a 
<code class="literal">(...)</CODE
>
grouping.
Here are two ways to match
&quot;a simple problem&quot;,
&quot;an easy problem&quot;,
as well as
&quot;a problem&quot;;
the second expression is more exact:</P
><p class="para"><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>egrep &quot;a[n]? (simple|easy)? ?problem&quot; data</B
></CODE
>
% <code class="userinput"><b>egrep &quot;a[n]? ((simple|easy) )?problem&quot; data</B
></CODE
></PRE
></BLOCKQUOTE
></P
><p class="para">I promised to explain why the backslash characters don't work in
extended regular expressions.
Well, perhaps the
<code class="literal">/{.../}</CODE
>
and
<a class="indexterm" name="AUTOID-28956"></A
><a class="indexterm" name="AUTOID-28959"></A
>
<a class="indexterm" name="AUTOID-28962"></A
><a class="indexterm" name="AUTOID-28965"></A
>

<code class="literal">/&lt;.../&gt;</CODE
>
could be added to the extended expressions, but 
it might confuse people if those characters are added and the
<code class="literal">/(.../)</CODE
>
are not. And there is no way to add that functionality to the extended
expressions without changing the current usage. Do you see why?
It's quite simple. If
<code class="literal">(</CODE
>
has a special meaning, then 
<code class="literal">/(</CODE
>
must be the ordinary character.
This is the opposite of the simple regular expressions,
where
<code class="literal">(</CODE
>
is ordinary and
<code class="literal">/(</CODE
>
is special.
The usage of the parentheses is incompatible, and any change could
break old programs.</P
><p class="para">If the extended expression used 
<code class="literal">(...|...)</CODE
>
as regular characters, and
<code class="literal">/(.../|.../)</CODE
>
for specifying alternate patterns, then it is possible to have one set
of regular expressions that has full functionality.
This is exactly
what
<span class="link">GNU Emacs (<a class="linkend" href="ch32_01.htm" webstripperlinkwas="ch32_01.htm#UPT-ART-5540" title="Emacs: The Other Editor ">32.1</A
>)</SPAN
>
does, by the way-it combines
all of the features of regular and
extended expressions with one syntax.<a class="indexterm" name="AUTOID-28978"></A
></P
></DIV
><div class="sect1info"><p class="SECT1INFO">- <span class="authorinitials">BB</SPAN
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch26_03.htm" webstripperlinkwas="ch26_03.htm" title="26.3 Understanding Expressions "><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous: 26.3 Understanding Expressions " border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" title="UNIX Power Tools"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="UNIX Power Tools" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch26_05.htm" webstripperlinkwas="ch26_05.htm" title="26.5 Getting Regular Expressions Right "><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next: 26.5 Getting Regular Expressions Right " border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">26.3 Understanding Expressions </TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" webstripperlinkwas="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">26.5 Getting Regular Expressions Right </TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#map" border="0" alt="The UNIX CD Bookshelf Navigation"><map name="map"><area shape="RECT" coords="0,0,73,21" href="../index.html" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/index.html" alt="The UNIX CD Bookshelf"><area shape="RECT" coords="74,0,163,21" href="index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/upt/index.htm" alt="UNIX Power Tools"><area shape="RECT" coords="164,0,257,21" href="../unixnut/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/unixnut/index.htm" alt="UNIX in a Nutshell"><area shape="RECT" coords="258,0,321,21" href="../vi/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/vi/index.htm" alt="Learning the vi Editor"><area shape="RECT" coords="322,0,378,21" href="../sedawk/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/sedawk/index.htm" alt="sed &amp; awk"><area shape="RECT" coords="379,0,438,21" href="../ksh/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/ksh/index.htm" alt="Learning the Korn Shell"><area shape="RECT" coords="439,0,514,21" href="../lrnunix/index.htm" webstripperlinkwas="http://www.ms.itb.ac.id/buku/unix-bookshelf/lrnunix/index.htm" alt="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
