<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 5] 5.5 Interface Declarations</TITLE>
<meta name="author" content="Mark Grand">
<meta name="date" content="Thu Jul 31 13:13:09 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="java">
<meta name="title" content="Java Language Reference">
<meta http-equiv="index.htmlContent-Script-Type" content="text/javascript">
</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><a href='index.htm'><img src="gifs/smbanner.gif" alt="Java Language Reference" border=0></a></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 5<br>Declarations</FONT></B></TD>
<td width=172 align=right valign=top><a href="ch06_01.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>

&nbsp;
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="JLR2-CH-5-SECT-5">5.5 Interface Declarations</A></h2>

<p class=para>
<a name="CH05.INTER1"></A><a name="CH05.INTER2"></A>An interface declaration creates a reference type in Java. An
interface declaration is similar to a class declaration, with the
following two very important differences.

<p>
<ul class=itemizedlist>
<li class=listitem>All of the methods in an interface are implicitly <tt class=literal>abstract</tt>.
Every method declaration in an interface specifies the formal parameters
and return type of the method, but it does not include an implementation
of the method.

<p>
<li class=listitem>All of the variables in an interface
are implicitly <tt class=literal>static</tt> and <tt class=literal>final</tt>.

<p>
</UL>
<p class=para>
Interfaces are most useful for declaring that an otherwise unrelated
set of classes have a common set of methods. For example, if you want
to store a variety of objects in a database, you might want all of
those objects to have fetch and store methods. The fetch and store
methods of each object require different implementations, so it makes
sense to declare the fetch and store methods in an interface
declaration. Then any class that needs fetch and store methods can
implement the interface.

<p class=para>
The formal definition for an interface declaration is:


<p>
<img align=middle src="figs/jlr0514.gif" alt="[Graphic: Figure from the text]" width=450 height=110 border=0>


<p>
<img align=middle src="figs/jlr0515.gif" alt="[Graphic: Figure from the text]" width=450 height=213 border=0>

<p class=para>
While the above diagram may seem complicated, an interface declaration
is really made up of five distinct things:

<p>
<ul class=itemizedlist>
<li class=listitem>Optional modifiers that specify attributes of the class

<p>
<li class=listitem> 
The keyword <tt class=literal>interface</tt>

<p>
<li class=listitem> 
An identifier that names the interface

<p>
<li class=listitem>An optional <tt class=literal>extends</tt>
clause that specifies the super interfaces of the declared interface

<p>
<li class=listitem>Any number of interface member declarations, which can
include variables and methods

<p>
</UL>
<p class=para>
Here are some sample interface declarations:

<div class=screen>
<p>
<pre>
interface Dyn {
    double squeeze();
}
interface Press extends Dyn {
    double squeeze(double theta);
}
</PRE>
</DIV>

<p class=para>
Here is an example of a class
that implements <tt class=literal>Press</tt>:

<div class=screen>
<p>
<pre>
class Clamp implements Press {
      ...
    double squeeze() {
        return squeeze(0);
    }
    double squeeze(double theta) {
        return force*Math.cos(theta);
    }
      ...
}
</PRE>
</DIV>

<p class=para>
Since the <tt class=literal>Press</tt> interface extends the
<tt class=literal>Dyn</tt> interface, the <tt class=literal>Clamp</tt> class
must implement the methods declared in both <tt class=literal>Dyn</tt> and
<tt class=literal>Press</tt>.

<p class=para>
<b>References</b>
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Class Declarations</A>;
<i class=emphasis>ClassOrInterfaceName</I> 4.1.6;
<a href="ch02_02.htm#JLR2-CH-2-SECT-2.3.4">Identifiers</A>;
<a href="ch05_03.htm">Interfaces</A>;
<a href="#JLR2-CH-5-SECT-5.4">Interface Members</A>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="JLR2-CH-5-SECT-5.1">Interface Modifiers</A></h3>

<p class=para>
<a name="CH05.INTMOD"></A><a name="CH05.INTMOD2"></A>The keywords <tt class=literal>public</tt> and
<tt class=literal>abstract</tt> can appear
as modifiers at the beginning of an interface declaration.  In this
situation, these modifiers have the following meanings:

<p>
<dl class=variablelist>
<dt class=varlistentry><tt class=literal>public</tt><br>
<dd>

<p class=para>
If an interface is declared <tt class=literal>public</tt>, it can be
referenced by any class or interface. If the <tt class=literal>public</tt>
modifier is not used, however, the interface can only be referenced by
classes and interfaces in the same package. A single source file, or
compilation unit, can only declare one <tt class=literal>public</tt> class
or interface (see <a href="ch07_01.htm">Compilation Units</A> for an
exception to this rule).

<p>
<dt class=varlistentry><tt class=literal>abstract</tt><br>
<dd>

<p class=para>
An interface is implicitly <tt class=literal>abstract</tt>; so
all of the methods in an interface are implicitly
<tt class=literal>abstract</tt>. Including the <tt class=literal>abstract</tt>
modifier in an interface declaration is permitted, but it does not
change the meaning of the interface declaration.</DL>
<p class=para>
<b>References</b>
<a href="ch07_01.htm">Compilation Units</A>;
<a href="#JLR2-CH-5-SECT-5.4.3.1">Inner interface modifiers</A>;
<a href="#JLR2-CH-5-SECT-5.4.2.1">Interface method modifiers</A>;
<a href="#JLR2-CH-5-SECT-5.4.1.1">Interface variable modifiers</A>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="JLR2-CH-5-SECT-5.2">Interface Name</A></h3>

<p class=para>
The identifier that follows the keyword <tt class=literal>interface</tt>
is the name of the interface.  This identifier can be used as a
reference type wherever the interface is accessible.

<p class=para>
<b>References</b>
<a href="ch03_02.htm#JLR2-CH-3-SECT-2.3">Interface Types</A>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="JLR2-CH-5-SECT-5.3">Interface Inheritance</A></h3>

<p class=para>
The <tt class=literal>extends</tt> clause specifies any super-interfaces
of the interface being declared; the <tt class=literal>extends</tt>
keyword can be followed by the names of one or more interfaces. If an
interface has an <tt class=literal>extends</tt> clause, the clause can
only name other interfaces.

<p class=para>
Including an interface in the <tt class=literal>extends</tt> clause of
another interface means that the declared interface inherits the
variables and methods declared in the super-interface. A class that
implements the declared interface must implement all of the methods in
the declared interface, as well as all of the methods inherited from
the super-interface.

<p class=para>
If an interface declaration does not include an
<tt class=literal>extends</tt> clause, the interface does not extend any
other interfaces.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="JLR2-CH-5-SECT-5.4">Interface Members</A></h3>

<p class=para>
The members of an interface can be variables or methods; an interface
cannot have constructors, static initializers, instance initializers,
nested top-level classes or interfaces, or member classes:


<p>
<img align=middle src="figs/jlr0516.gif" alt="[Graphic: Figure from the text]" width=450 height=59 border=0>

<p class=para>
<b>References</b>
<a href="#JLR2-CH-5-SECT-5.4.2">Interface Methods</A>;
<a href="#JLR2-CH-5-SECT-5.4.1">Interface Variables</A>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="JLR2-CH-5-SECT-5.4.1">Interface Variables</A></h3>

<p class=para>
<a name="CH05.INTVAR1"></A><a name="CH05.INTVAR2"></A>Any field variables declared in an interface are implicitly
<tt class=literal>static</tt> and <tt class=literal>final</tt>. In other
words, field variables in an interface are named constants. Every
field variable declaration in an interface must contain an initializer
that sets the value of the named constant:


<p>
<img align=middle src="figs/jlr0517.gif" alt="[Graphic: Figure from the text]" width=450 height=230 border=0>

<p class=para>
A variable declaration in an interface is made up of three distinct
things:

<p>
<ul class=itemizedlist>
<li class=listitem>Optional modifiers that specify attributes of the variable.

<p>
<li class=listitem>A type, which can be either a primitive type or a reference type.

<p>
<li class=listitem>Any number of identifiers that name variables. Each name must be
followed by an initializer that sets the value of the constant.

<p>
</UL>
<p class=para>
<b>References</b>
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Variable initializers</A>;
<i class=emphasis>Expression</I> 4;
<a href="ch02_02.htm#JLR2-CH-2-SECT-2.3.4">Identifiers</A>;
<i class=emphasis>Type</I> 3

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.1.1">Interface variable modifiers</A></h4>

<p class=para>
Variables in an interface are implicitly <tt class=literal>static</tt> and
<tt class=literal>final</tt>.  Including these modifiers in a variable
declaration is permitted, but it is not necessary and it does not
change the meaning of the variable declaration. Thus, by definition,
all variables in an interface are named constants.

<p class=para>
If an interface is declared <tt class=literal>public</tt>, a field
variable declared in the interface is <tt class=literal>public</tt>, even
if it is declared with the <tt class=literal>private</tt> or
<tt class=literal>protected</tt> modifier. If an interface is not declared
<tt class=literal>public</tt>, however, any field variables in the
interface have the default accessibility, which means that they are
only accessible in classes and interfaces in the same package.

<p class=para>
It is an error to declare a field variable in an interface with the
<tt class=literal>transient</tt> or <tt class=literal>volatile</tt> modifier.

<p class=para>
<b>References</b>
<a href="#JLR2-CH-5-SECT-5.1">Interface Modifiers</A>;
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Variable modifiers</A>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.1.2">Interface variable type</A></h4>

<p class=para>
If the interface variable declaration uses a primitive type, the
variable contains a constant value of the specified primitive type. If
the declaration uses a reference type, the variable contains a
constant reference to the specified type of object. The presence of
square brackets in a variable declaration, after either the type or
variable name, indicates that the variable contains a reference to an
array.

<p class=para>
<b>References</b>
<a href="ch03_02.htm#JLR2-CH-3-SECT-2.3">Array Types</A>;
<a href="ch03_01.htm">Primitive Types</A>;
<a href="ch03_02.htm#JLR2-CH-3-SECT-2.3">Reference Types</A>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.1.3">Interface variable name</A></h4>

<p class=para>
<a name="CH05.BOGUS"></A>The identifier that follows the variable type is the name of the
variable. This identifier can be used anywhere that the variable is
accessible.

<p class=para>
It is an error to declare two field variables with the same name in
the same interface. It is also an error to declare a field variable
with the same name as a method declared in the same interface or any
of its super-interfaces.

<p class=para>
An interface that extends another interface inherits all of the
variables in its super-interface.  Any class that implements an
interface has access to all of the variables defined in that
interface, as well as the variables inherited from super-interfaces.

<p class=para>
If a field variable is declared with the same name as a variable
declared in a super-interface, the variable in the super-interface is
considered to be shadowed. If a variable is shadowed in an interface,
it cannot be accessed as a field of that interface. However, a
shadowed variable can be accessed by casting a reference to an object
that implements the interface to a reference to the appropriate
super-interface in which the variable is not shadowed. For example:

<div class=screen>
<p>
<pre>
interface A {
    int x = 4;
}
interface B extends A {
    int x = 7;
}
class Z implements B {
    Z() {
        int i = x;              // i gets the value of B's x
        int h = ((A)this).x;    // h gets the value of A's x
    }
}
</PRE>
</DIV>

<p class=para>
The variable <tt class=literal>x</tt> in interface <tt class=literal>A</tt> is
shadowed by the variable <tt class=literal>x</tt> in interface
<tt class=literal>B</tt>. Class <tt class=literal>Z</tt> implements interface
<tt class=literal>B</tt>, so a reference to <tt class=literal>x</tt> produces
the value 7, as defined in interface <tt class=literal>B</tt>. However, it
is possible to access the shadowed variable by casting
<tt class=literal>this</tt> to a reference to interface
<tt class=literal>A</tt>.

<p class=para>
In some situations, an interface may inherit multiple field variables
with the same name. This leads to a single, ambiguous variable
name. For example:

<div class=screen>
<p>
<pre>
interface A {
    int x = 4;
}
interface B {
    int x = 43;
}
interface C extends A, B {
    int y = 22;
}
class Z implements C {
    public static void main (String[] argv) {
        System.out.println(x);        // Ambiguous
    }
}
</PRE>
</DIV>

<p class=para>
In this example, the interface <tt class=literal>C</tt> inherits two
variables named <tt class=literal>x</tt>.  This is fine, as long as
<tt class=literal>C</tt> does not refer to the variable
<tt class=literal>x</tt> by its simple name in any of its declarations. If
<tt class=literal>C</tt> needs to use <tt class=literal>x</tt>, it must
qualify the name with the appropriate interface name (e.g.,
<tt class=literal>A.x</tt>). Class <tt class=literal>Z</tt> implements
interface <tt class=literal>C</tt>, so it also has access to two variables
named <tt class=literal>x</tt>. As a result, the use of
<tt class=literal>x</tt> in <tt class=literal>main()</tt> is ambiguous. This
problem can be resolved by qualifying the variable name with the
appropriate interface name (e.g., <tt class=literal>B.x</tt>).

<p class=para>
A class that implements multiple interfaces can also inherit multiple
field variables with the same name. Again, this leads to a single,
ambiguous variable name:

<div class=screen>
<p>
<pre>
interface A {
    int x = 4;
}
interface B {
    int x = 43;
}
class Z implements A, B {
    public static void main (String[] argv) {
        System.out.println(x);        // Ambiguous
    }
}
</PRE>
</DIV>

<p class=para>
The class <tt class=literal>Z</tt> implements both interface
<tt class=literal>A</tt> and interface <tt class=literal>B</tt>, so it
inherits two variables named <tt class=literal>x</tt>. As a result, the
use of <tt class=literal>x</tt> in <tt class=literal>main()</tt> is
ambiguous. This problem can again be resolved by qualifying the
variable name with the appropriate interface name (e.g.,
<tt class=literal>B.x</tt>).

<p class=para>
<b>References</b>
<a href="ch04_01.htm">Field Expressions</A>;
<a href="ch02_02.htm#JLR2-CH-2-SECT-2.3.4">Identifiers</A>;
<a href="#JLR2-CH-5-SECT-5.4.2.3">Interface method name</A>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.1.4">Interface variable initializers</A></h4>

<p class=para>
Every variable declaration in an interface must include an
initializer that sets the value of the constant. The initializer does
not, however, have to be a constant expression. If the variable is of
a non-array type, the expression in the initializer is evaluated and
the variable is set to the result of the expression, as long as the
result is assignment-compatible with the variable. If the variable is
of an array type, the initializer must be an array initializer.

<p class=para>
The initializer for a variable in an interface cannot refer to any
variables that are declared after its own declaration.

<p class=para>
<b>References</b>
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Variable initializers</A>;
<a href="ch03_02.htm#JLR2-CH-3-SECT-2.3">Array Types</A>;
<a href="ch04_13.htm#JLR2-CH-4-SECT-13">Assignment Operators</A>;
<a href="ch04_16.htm">Constant Expressions</A>;
<i class=emphasis>Expression</I> 4

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="JLR2-CH-5-SECT-5.4.2">Interface Methods</A></h3>

<p class=para>
<a name="CH05.METH9"></A><a name="CH05.METH8"></A>Any methods declared in an interface are implicitly
<tt class=literal>abstract</tt>. In other words, methods in an interface
do not have a specified implementation:


<p>
<img align=middle src="figs/jlr0518.gif" alt="[Graphic: Figure from the text]" width=450 height=267 border=0>

<p class=para>
A method declaration in an interface is made up of six distinct things:

<p>
<ul class=itemizedlist>
<li class=listitem>Optional modifiers that specify attributes of the method

<p>
<li class=listitem>A type that specifies the type of value returned by
the method

<p>
<li class=listitem>An identifier that names the method

<p>
<li class=listitem>A list of formal parameters that specifies the values that are passed
to the method

<p>
<li class=listitem>An optional <tt class=literal>throws</tt> clause that specifies any exceptions that can be
thrown by the method

<p>
<li class=listitem>A semicolon, since the method declaration does not include an
implementation

<p>
</UL>
<p class=para>
<b>References</b>
<i class=emphasis>ClassOrInterfaceName</I> 4.1.6;
Exception Handling 9;
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Method formal parameters</A>;
<a href="ch02_02.htm#JLR2-CH-2-SECT-2.3.4">Identifiers</A>;
<i class=emphasis>Type</I> 3

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.2.1">Interface method modifiers</A></h4>

<p class=para>
Methods in an interface are implicitly
<tt class=literal>abstract</tt>. Including this modifier in a method
declaration is permitted, but it is not necessary and it does not
change the meaning of the method declaration.  Thus, by definition,
none of the methods in an interface has a specified implementation.

<p class=para>
If an interface is declared <tt class=literal>public</tt>, a method
declared in the interface is <tt class=literal>public</tt>, even if it is
declared with the <tt class=literal>private</tt> or
<tt class=literal>protected</tt> modifier. If the interface is not
declared <tt class=literal>public</tt>, however, any methods in the
interface have the default accessibility, which means that they are
only accessible in classes and interfaces in the same package.

<p class=para>
It is an error to declare a method in an interface with the
<tt class=literal>static</tt>, <tt class=literal>final</tt>,
<tt class=literal>native</tt>, or <tt class=literal>synchronized</tt>
modifier.  These modifiers are not allowed because defining a method
in an interface is not meant to imply anything about the nature of the
implementation, other than the return type of the method and the types
of the formal parameters. A class that implements the interface has
control over the implementation of the methods and can use any of
these modifiers when they are appropriate for the implementation.

<p class=para>
<b>References</b>
<a href="#JLR2-CH-5-SECT-5.1">Interface Modifiers</A>;
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Method modifiers</A>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.2.2">Interface method return type</A></h4>

<p class=para>
A method declaration in an interface must specify the type of value
returned by the method. The return value can be of a primitive type or
of a reference type. The presence of square brackets in a method
declaration, after either the return type or the formal parameters,
indicates that the method returns a reference to the specified type of
array.  If the method does not return a value, the declaration uses
<tt class=literal>void</tt> to indicate that. The return type comes before
the name of the method in the method declaration.

<p class=para>
<b>References</b>
<a href="ch03_02.htm#JLR2-CH-3-SECT-2.3">Array Types</A>;
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Method return type</A>;
<a href="ch03_01.htm">Primitive Types</A>;
<a href="ch03_02.htm#JLR2-CH-3-SECT-2.3">Reference Types</A>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.2.3">Interface method name</A></h4>

<p class=para>
The identifier that follows the return type is the name of the
method. This identifier can be used anywhere that the method is
accessible.

<p class=para>
It is an error to declare two methods that have the same name, the
same number of parameters, and the same type for each corresponding
parameter in the same interface. It is also an error to declare a
method with the same name as a variable declared in the same interface
or any of its super-interfaces.

<p class=para>
An interface that extends another interface inherits all of the
methods in its super-interface.  Any class that implements an
interface must provide an implementation for each of the methods
defined in that interface, as well as each of the methods inherited
from super-interfaces.

<p class=para>
If an interface inherits methods from multiple super-interfaces that
have the same name, formal parameters, and return type, there is no
problem. The various super-interfaces are in agreement about the
method. The interface can also override the inherited methods by
declaring a method with the same name, formal parameters, and return
type. In any case, a class that implements the interface has to
provide a single implementation for the method.

<p class=para>
However, if an interface inherits methods from multiple
super-interfaces that have the same name and same formal parameters,
but different return types, a compile-time error results. By the same
token, if the interface attempts to override an inherited method with
a method that has the same name and same formal parameters, but a
different return type, a compile-time error results.

<p class=para>
If an interface inherits methods from multiple super-interfaces that
have the same name but different formal parameters, there is no
problem. The methods are simply considered overloaded in the
interface. The interface can even declare additional methods that have
the same name but different formal parameters. A class that implements
the interface simply has to provide an implementation for each of the
overloaded methods.

<p class=para>
<b>References</b>
<a href="ch02_02.htm#JLR2-CH-2-SECT-2.3.4">Identifiers</A>;
<a href="#JLR2-CH-5-SECT-5.4.1.3">Interface variable name</A>;
<a href="ch04_01.htm">Method Call Expression</A>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.2.4">Interface method formal parameters</A></h4>

<p class=para>
The formal parameters in a method declaration specify a list of
variables to which values are assigned when the method is called. If a
method has no formal parameters, the parentheses must still appear in
the method declaration. The presence of square brackets in a formal
parameter declaration, either as part of a reference type or after the
name of a formal parameter, indicates that the formal parameter is an
array type.

<p class=para>
<b>References</b>
<a href="ch03_02.htm#JLR2-CH-3-SECT-2.3">Array Types</A>;
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Method formal parameters</A>;
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Method formal parameters</A>;
<i class=emphasis>Type</I> 3

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.2.5">Interface method throws clause</A></h4>

<p class=para>
If a method is expected to throw any exceptions, the method
declaration must declare that fact in a <tt class=literal>throws</tt>
clause. If the declaration of a method in an interface contains a
<tt class=literal>throws</tt> clause, any method in a sub-interface that
overrides that method cannot include any classes in its
<tt class=literal>throws</tt> clause that are not declared in the
overridden method.

<p class=para>
<b>References</b>
Exception Handling 9;
<a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6">Method throws clause</A>

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="JLR2-CH-5-SECT-5.4.3">Nested Top-Level Interfaces</A></h3>

<p class=para>
Nested top-level interfaces are interfaces that
are declared inside of another class. Just as with a top-level
interface declaration, the declaration of a nested top-level interface
creates a reference type in Java. Here's the formal definition of
a nested top-level interface:


<p>
<img align=middle src="figs/jlr0519.gif" alt="[Graphic: Figure from the text]" width=450 height=132 border=0>

<p class=para>
A nested top-level interface 
can be accessed outside of its enclosing class by
qualifying its name with the name of its enclosing class, as follows:

<div class=screen>
<p>
<pre>
<i class=emphasis>EnclosingClass</I>.<i class=emphasis>InnerInterface</I>
</PRE>
</DIV>

<p class=para>
The syntax for declaring nested top-level interfaces 
is not supported prior to Java 1.1.

<p class=para>
<b>References</b>
<a href="ch05_03.htm">Nested top-level classes and interfaces</A>;
<i class=emphasis>SimpleInterfaceDeclaration</I> 5.5

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.3.1">Inner interface modifiers</A></h4>

<p class=para>
The keywords <tt class=literal>public</tt>, <tt class=literal>abstract</tt>, 
and <tt class=literal>static</tt> can be used in the declaration of a
nested top-level interface. In this situation, these 
modifiers have the following meanings:

<p>
<dl class=variablelist>
<dt class=varlistentry><tt class=literal>public</tt><br>
<dd>

<p class=para>
If a nested top-level interface is declared
<tt class=literal>public</tt>, it is accessible from any class or
interface that can access the enclosing class. If the
<tt class=literal>public</tt> modifier is not used, however, the nested
top-level interface can only be referenced by classes and interfaces
in the same package as the enclosing class.

<p>
<dt class=varlistentry><tt class=literal>abstract</tt><br>
<dd>

<p class=para>
A nested top-level interface is implicitly <tt class=literal>abstract</tt>; thus,
all of the methods in the interface are implicitly
<tt class=literal>abstract</tt>. Including the <tt class=literal>abstract</tt>
modifier in a nested top-level interface declaration is permitted, 
but it does not change the meaning of the interface declaration.

<p>
<dt class=varlistentry><tt class=literal>static</tt><br>
<dd>

<p class=para>
A nested top-level interface is implicitly <tt class=literal>static</tt>. 
Including the <tt class=literal>static</tt>
modifier in a nested top-level interface declaration is permitted, 
but it does not change the meaning of the interface declaration.</DL>
<p class=para>
<b>References</b>
<a href="#JLR2-CH-5-SECT-5.1">Interface Modifiers</A>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="JLR2-CH-5-SECT-5.4.3.2">Inner interface members</A></h4>

<p class=para>
The remainder of a nested top-level interface 
declaration is the same as that for a top-level 
interface declaration, which is described 
in <a href="#JLR2-CH-5-SECT-5">Interface Declarations</A>.

<p class=para>
<b>References</b>
<a href="#JLR2-CH-5-SECT-5">Interface Declarations</A>;
<a href="#JLR2-CH-5-SECT-5.4.2">Interface Methods</A>;
<a href="#JLR2-CH-5-SECT-5.4.1">Interface Variables</A>

</DIV>

</DIV>

</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch05_04.htm#JLR2-CH-5-SECT-4.4.2.6"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src='gifs/txthome.gif' border=0 alt='Home'></a></td>
<td width=172 align=right valign=top><a href="ch06_01.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Class Declarations</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm"><img src='gifs/index.gif' alt='Book Index' border=0></a></td>
<td width=172 align=right valign=top>Statements and Control Structures</td>
</tr>
</table>
<hr align=left width=515>

<img src="gifs/smnavbar.gif" usemap="#map" border=0> 
<map name="map"> 
<area shape=RECT coords="0,0,108,15" href="../javanut/index.htm" alt="Java in a Nutshell"> 
<area shape=RECT coords="109,0,200,15" href="index.htm" alt="Java Language Reference"> 
<area shape=RECT coords="203,0,290,15" href="../awt/index.htm" alt="Java AWT"> 
<area shape=RECT coords="291,0,419,15" href="../fclass/index.htm" alt="Java Fundamental Classes"> 
<area shape=RECT coords="421,0,514,15" href="../exp/index.htm" alt="Exploring Java"> 
</MAP>
</DIV>

</BODY>
</HTML>
