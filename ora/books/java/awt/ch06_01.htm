<html>
<head>
<title>[Chapter 6] Containers</TITLE>
<meta name="author" content="John Zukowski">
<meta name="date" content="Thu Jul 31 14:36:31 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="Java AWT">
<meta name="title" content="Java AWT">
<meta http-equiv="Content-Script-Type" content="text/javascript">
</HEAD>
<body bgcolor="#FFFFFF" text="#000000">

<div class=htmlnav>
<h1><a href='index.htm'><img src="gifs/smbanner.gif" alt="Java AWT" border=0></a></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch05_07.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 6</FONT></B></TD>
<td width=172 align=right valign=top><a href="ch06_02.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>

&nbsp;
<hr align=left width=515>
</DIV>
<h1 class=chapter><a class="TITLE" name="JAWT-CH-6">6. Containers</A></H1>

<div class=htmltoc>

<p>
<b>Contents:</b><br>
Container<br>
<a href="ch06_02.htm">Panel</A><br>
<a href="ch06_03.htm">Insets</A><br>
<a href="ch06_04.htm">Window</A><br>
<a href="ch06_05.htm">Frames</A><br>
<a href="ch06_06.htm">Dialogs</A><br>
<a href="ch06_07.htm">FileDialog</A><br>

<p>
</DIV>

<p class=para>
This chapter covers a special type of <tt class=literal>Component</tt>
called <tt class=literal>Container</tt>. A <tt class=literal>Container</tt> is
a subclass of <tt class=literal>Component</tt> that can contain other
components, including other containers. <tt class=literal>Container</tt>
allows you to create groupings of objects on the screen. This chapter
covers the methods in the <tt class=literal>Container</tt> class and its
subclasses: <tt class=literal>Panel</tt>, <tt class=literal>Window</tt>,
<tt class=literal>Frame</tt>, <tt class=literal>Dialog</tt>, and
<tt class=literal>FileDialog</tt>.  It also covers the
<tt class=literal>Insets</tt> class, which provides an internal border
area for the <tt class=literal>Container</tt> classes.  <a name="CH06.CONT2"></A>

<p class=para>
Every container has a layout associated with it that controls how the container 
organizes the components in it. The layouts are described in <a href="ch07_01.htm">Chapter 7, <i>Layouts</i></A>. 

<p class=para>
Java 1.1 introduces a special <tt class=literal>Container</tt> called
<tt class=literal>ScrollPane</tt>. Because of the similarities between
scrolling and <tt class=literal>ScrollPane</tt>, the new
<tt class=literal>ScrollPane</tt> container is covered with the
<tt class=literal>Scrollbar</tt> class in <a href="ch11_01.htm">Chapter 11, <i>Scrolling</i></A>.

<div class=sect1>
<h2 class=sect1><a class="TITLE" name="JAWT-CH-6-SECT-1">6.1 Container</A></h2>

<p class=para>
<a name="CH06.CONT"></A><tt class=literal>Container</tt> is an abstract class 
that serves as a general purpose holder of other <tt class=literal>Component</tt> 
objects. The <tt class=literal>Container</tt> class 
holds the methods for grouping the components together, laying out the 
components inside it, and dealing with events occurring within it. Because 
<tt class=literal>Container</tt> is an abstract class, 
you never see a pure <tt class=literal>Container</tt> 
object; you only see subclasses that add specific behaviors to a generic 
container. 

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="JAWT-CH-6-SECT-1.1">Container Methods</A></h3>Constructors

<p class=para>
The abstract <tt class=literal>Container</tt> class 
contains a single constructor to be called by its children. Prior to Java 
1.1, the constructor was package private. 

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>protected Container() <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The constructor for <tt class=literal>Container</tt> 
creates a new component without a native peer. Since you no longer have 
a native peer, you must rely on your container to provide a display area. 
This allows you to create containers that require fewer system resources. 
For example, if you are creating panels purely for layout management, you 
might consider creating a <tt class=literal>LightweightPanel</tt> 
class to let you assign a layout manager to a component group. Using <tt class=literal>LightweightPanel</tt> 
will speed things up since events do not have to propagate through the 
panel and you do not have to get a peer from the native environment. The following code creates the <tt class=literal>LightweightPanel</tt> class: 

<div class=screen>
<p>
<pre>
import java.awt.*;
public class LightweightPanel extends Container {
    LightweightPanel () {}
    LightweightPanel (LayoutManager lm) {
        setLayout(lm);
    }
}
</PRE>
</DIV>

</DL>
Grouping

<p class=para>
A <tt class=literal>Container</tt> holds a set of objects within itself. This set of methods describes 
how to examine and add components to the set. 

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public int getComponentCount () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br><i class=emphasis>public int countComponents () <img src="gifs/wstar.gif" alt="(Deprecated)" border=0></I><br>
<dd>

<p class=para>
The <tt class=literal>getComponentCount()</tt> method 
returns the number of components within the container at this level. <tt class=literal>getComponentCount()</tt> 
does not count components in any child <tt class=literal>Container</tt> 
(i.e., containers within the current container). 

<p class=para>
<tt class=literal>countComponents()</tt> is the Java 
1.0 name for this method. 

<p>
<dt class=varlistentry><i class=emphasis>public Component getComponent (int position) </I><br>
<dd>

<p class=para>
The <tt class=literal>getComponent()</tt> method returns 
the component at the specific <tt class=literal>position</tt> 
within it. If <tt class=literal>position</tt> is invalid, 
this method throws the run-time exception <tt class=literal>ArrayIndexOutOfBoundsException</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public Component[] getComponents () </I><br>
<dd>

<p class=para>
<tt class=literal>getComponents()</tt> returns an 
array of all the components held within the container. Since these are 
references to the actual objects on the screen, any changes made to the 
components returned will be reflected on the display. 

<p>
<dt class=varlistentry><i class=emphasis>public Component add (Component component, int position) </I><br>
<dd>

<p class=para>
<a name="CH06.ADD"></A>The <tt class=literal>add()</tt> method adds <tt class=literal>component</tt> 
to the container at <tt class=literal>position</tt>. 
If <tt class=literal>position</tt> is -1, <tt class=literal>add()</tt> 
inserts <tt class=literal>component</tt> as the last 
object within the container. What the container does with <tt class=literal>position</tt> 
depends upon the <tt class=literal>LayoutManager</tt> 
of the container. If <tt class=literal>position</tt> 
is invalid, the <tt class=literal>add()</tt> method throws the 
run-time exception <tt class=literal>IllegalArgumentException</tt>. 
If you try to add <tt class=literal>component</tt>'s 
container to itself (anywhere in the containment tree), this method throws 
an <tt class=literal>IllegalArgumentException</tt>. 
In Java 1.1, if you try to add a <tt class=literal>Window</tt> 
to a container, <tt class=literal>add()</tt> throws 
the run-time exception <tt class=literal>IllegalArgumentException</tt>. 
If you try to add <tt class=literal>component</tt> 
to a container that already contains it, the container is removed and re-added, 
probably at a different position. 

<p class=para>
Assuming that nothing goes wrong, the parent of <tt class=literal>component</tt> 
is set to the container, and the container is invalidated. <tt class=literal>add()</tt> 
returns the <tt class=literal>component</tt> just 
added. 

<p class=para>
Calling this method generates a <tt class=literal>ContainerEvent</tt> 
with the id <tt class=literal>COMPONENT_ADDED</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public Component add (Component component) </I><br>
<dd>

<p class=para>
The <tt class=literal>add()</tt> method adds <tt class=literal>component</tt> 
to the container as the last object within the container. This is done 
by calling the earlier version of <tt class=literal>add()</tt> 
with a <tt class=literal>position</tt> of -1. If you 
try to add <tt class=literal>component</tt>'s 
container to itself (anywhere in the containment tree), this method throws 
the run-time exception <tt class=literal>IllegalArgumentException</tt>. 
In Java 1.1, if you try to add a <tt class=literal>Window</tt> 
to a container, <tt class=literal>add()</tt> throws 
the run-time exception <tt class=literal>IllegalArgumentException</tt>. 

<p class=para>
Calling this method generates a <tt class=literal>ContainerEvent</tt> 
with the id <tt class=literal>COMPONENT_ADDED</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public void add (Component component, Object constraints) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br><i class=emphasis>public Component add (String name, Component component)</I><br>
<dd>

<p class=para>
This next version of <tt class=literal>add()</tt> 
is necessary for layouts that require additional information in order to 
place components. The additional information is provided by the <tt class=literal>constraints</tt> 
parameter. This version of the <tt class=literal>add()</tt> 
method calls the <tt class=literal>addLayoutComponent()</tt> 
method of the <tt class=literal>LayoutManager</tt>. 
What the container does with <tt class=literal>constraints</tt> depends upon the actual <tt class=literal>LayoutManager</tt>. 
It can be used for naming containers within a <tt class=literal>CardLayout</tt>, 
specifying a screen area for <tt class=literal>BorderLayout</tt>, 
or providing a set of <tt class=literal>GridBagConstraints</tt> 
for a <tt class=literal>GridBagLayout</tt>. In the 
event that this <tt class=literal>add()</tt> is called 
and the current <tt class=literal>LayoutManager</tt> 
does not take advantage of <tt class=literal>constraints</tt>, 
<tt class=literal>component</tt> is added at the end with a position 
of -1. If you try to add <tt class=literal>component</tt>'s 
container to itself (anywhere in the containment tree), this method throws 
the run-time exception <tt class=literal>IllegalArgumentException</tt>. 
In Java 1.1, if you try to add a <tt class=literal>Window</tt> 
to a container, <tt class=literal>add()</tt> throws 
the run-time exception <tt class=literal>IllegalArgumentException</tt>. 

<p class=para>
The <tt class=literal>add(String</tt>, <tt class=literal>Component)</tt> 
method was changed to <tt class=literal>add(component, object)</tt> 
in Java 1.1 to accommodate the <tt class=literal>LayoutManager2</tt> 
interface (discussed in <a href="ch07_01.htm">Chapter 7, <i>Layouts</i></A>) and to provide greater flexibility. 
In all cases, you can just flip the parameters to bring the code up to 
1.1 specs. The string used as an identifier in Java 1.0 is just treated 
as a particular kind of constraint. 

<p class=para>
Calling this method generates a <tt class=literal>ContainerEvent</tt> 
with the id <tt class=literal>COMPONENT_ADDED</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public void add (Component component, Object constraints, int index) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
This final version of <tt class=literal>add()</tt> 
is necessary for layouts that require an <tt class=literal>index</tt> 
and need additional information to place components. The additional information 
is provided by the <tt class=literal>constraints</tt> 
parameter. This version of <tt class=literal>add()</tt> 
also calls the <tt class=literal>addLayoutComponent()</tt> 
method of the <tt class=literal>LayoutManager</tt>. 
<tt class=literal>component</tt> is added with a position 
of <tt class=literal>index</tt>. If you try to add 
<tt class=literal>component</tt>'s container 
to itself (anywhere in the containment tree), this method throws the run-time 
exception <tt class=literal>IllegalArgumentException</tt>. 
In Java 1.1, if you try to add a <tt class=literal>Window</tt> 
to a <tt class=literal>Container</tt>, <tt class=literal>add()</tt> throws 
the run-time exception <tt class=literal>IllegalArgumentException</tt>. 

<p class=para>
Some layout managers ignore any index. For example, if you call <tt class=literal>add(aButton, 
BorderLayout.NORTH, 3)</tt> to add a <tt class=literal>Button</tt> to a <tt class=literal>BorderLayout</tt> 
panel, the <tt class=literal>Button</tt> appears in the north region of the layout, no matter 
what the index. 

<p class=para>
Calling this method generates a <tt class=literal>ContainerEvent</tt> 
with the id <tt class=literal>COMPONENT_ADDED</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>protected void addImpl(Component comp, Object constraints, int index) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The protected <tt class=literal>addImpl()</tt> method 
is the helper method that all the others call. It deals with synchronization 
and enforces all the restrictions on adding components to containers. 

<p class=para>
The <tt class=literal>addImpl()</tt> method tracks the container's components in an 
internal list. The index with which each component is added determines its 
position in the list. The lower the component's index, the higher it appears in the 
stacking order. In turn, the stacking order determines how components are displayed 
when sufficient space isn't available to display all of them. Components that are 
added without indices are placed at the end of the list (i.e., at the end of the 
stacking order) and therefore displayed behind other components. If all components 
are added without indices, the first component added to the container is first in 
the stacking order and therefore displayed in front.

<p class=para>
You could override <tt class=literal>addImpl()</tt> 
to track when components are added to a container. However, the proper 
way to find out when components are added is to register a <tt class=literal>ContainerListener</tt> 
and watch for the <tt class=literal>COMPONENT_ADDED</tt> 
and the <tt class=literal>COMPONENT_REMOVED</tt> events. 

<p>
<dt class=varlistentry><i class=emphasis>public void remove (int index) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>remove()</tt> method deletes 
the <tt class=literal>component</tt> at position <tt class=literal>index</tt> 
from the container. If <tt class=literal>index</tt> 
is invalid, the <tt class=literal>remove()</tt> method throws 
the run-time exception <tt class=literal>IllegalArgumentException</tt>. 
This method calls the <tt class=literal>removeLayoutComponent()</tt> 
method of the container's <tt class=literal>LayoutManager</tt>. 

<p class=para>
<tt class=literal>removeAll()</tt> generates a <tt class=literal>ContainerEvent</tt> 
with the id <tt class=literal>COMPONENT_REMOVED</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public void remove (Component component) </I><br>
<dd>

<p class=para>
The <tt class=literal>remove()</tt> method deletes 
<tt class=literal>component</tt> from the container, 
if the container directly contains <tt class=literal>component</tt>. 
<tt class=literal>remove()</tt> does not look through 
nested containers trying to find <tt class=literal>component</tt>. 
This method calls the <tt class=literal>removeLayoutComponent()</tt> 
method of the container's <tt class=literal>LayoutManager</tt>. 

<p class=para>
When you call this method, it generates a <tt class=literal>ContainerEvent</tt> 
with the id <tt class=literal>COMPONENT_REMOVED</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public void removeAll () </I><br>
<dd>

<p class=para>
The <tt class=literal>removeAll()</tt> method removes 
all components from the container. This is done by looping through all 
the components, setting each component's parent to <tt class=literal>null</tt>, 
setting the container's reference to the component to <tt class=literal>null</tt>, 
and invalidating the container. 

<p class=para>
When you call this method, it generates a <tt class=literal>ContainerEvent</tt> 
with the id <tt class=literal>COMPONENT_REMOVED</tt> 
for each component removed. 

<p>
<dt class=varlistentry><i class=emphasis>public boolean isAncestorOf(Component component) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>isAncestorOf()</tt> method checks 
to see if <tt class=literal>component</tt> is a parent 
(or grandparent or great grandparent) of this container. It could be 
used as a helper method for <tt class=literal>addImpl()</tt> 
but is not. If <tt class=literal>component</tt> is 
an ancestor of the container, <tt class=literal>isAncestorOf()</tt> 
returns <tt class=literal>true</tt>; otherwise, it 
returns <tt class=literal>false</tt>. </DL>
Layout and sizing

<p class=para>
<a name="CH06.LAYOUT1"></A><a name="CH06.LAYOUT2"></A>Every container has a <tt class=literal>LayoutManager</tt>. 
The <tt class=literal>LayoutManager</tt> is responsible 
for positioning the components inside the container. The <tt class=literal>Container</tt> 
methods listed here are used in sizing the objects within the container 
and specifying a layout. 

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public LayoutManager getLayout () </I><br>
<dd>

<p class=para>
The <tt class=literal>getLayout()</tt> method returns 
the container's current <tt class=literal>LayoutManager</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public void setLayout (LayoutManager manager) </I><br>
<dd>

<p class=para>
The <tt class=literal>setLayout()</tt> method changes 
the container's <tt class=literal>LayoutManager</tt> 
to <tt class=literal>manager</tt> and invalidates 
the container. This causes the components contained inside to be repositioned 
based upon <tt class=literal>manager</tt>'s 
rules. If <tt class=literal>manager</tt> is <tt class=literal>null</tt>, 
there is no layout manager, and you are responsible for controlling the 
size and position of all the components within the container yourself. 

<p>
<dt class=varlistentry><i class=emphasis>public Dimension getPreferredSize () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br><i class=emphasis>public Dimension preferredSize () <img src="gifs/wstar.gif" alt="(Deprecated)" border=0></I><br>
<dd>

<p class=para>
The <tt class=literal>getPreferredSize()</tt> method 
returns the <tt class=literal>Dimension</tt> (<tt class=literal>width</tt> 
and <tt class=literal>height</tt>) for the preferred size of the components within the container. 
The container determines its preferred size by calling the 
<tt class=literal>preferredLayoutSize()</tt> method of the current <tt class=literal>LayoutManager</tt>, 
which says how much space the layout manager needs to arrange the components. 
If you override this method, you are overriding the default preferred size. 

<p class=para>
<tt class=literal>preferredSize()</tt> is the Java 
1.0 name for this method. 

<p>
<dt class=varlistentry><i class=emphasis>public Dimension getMinimumSize () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br><i class=emphasis>public Dimension minimumSize () <img src="gifs/wstar.gif" alt="(Deprecated)" border=0></I><br>
<dd>

<p class=para>
The <tt class=literal>getMinimumSize()</tt> method 
returns the minimum <tt class=literal>Dimension</tt> 
(<tt class=literal>width</tt> and <tt class=literal>height</tt>) for the size of the components within the container. 
This container determines its minimum size by calling the 
<tt class=literal>minimumLayoutSize()</tt> method of the current <tt class=literal>LayoutManager</tt>, 
which computes the minimum amount of space the layout manager needs to 
arrange the components. It is possible for <tt class=literal>getMinimumSize()</tt> 
and <tt class=literal>getPreferredSize()</tt> to return 
the same dimensions. There is no guarantee that you will get this amount 
of space for the layout. 

<p class=para>
<tt class=literal>minimumSize()</tt> is the Java 
1.0 name for this method. 

<p>
<dt class=varlistentry><i class=emphasis>public Dimension getMaximumSize () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>getMaximumSize()</tt> method 
returns the maximum <tt class=literal>Dimension</tt> 
(<tt class=literal>width</tt> and <tt class=literal>height</tt>) for the size of the components within the container. 
This container determines its maximum size by calling the <tt class=literal>maximumLayoutSize()</tt> method of the current <tt class=literal>LayoutManager2</tt>, 
which computes the maximum amount of space the layout manager needs to 
arrange the components. If the layout manager is not an instance of <tt class=literal>LayoutManager2</tt>, 
this method calls the 
<tt class=literal>getMaximumSize()</tt> method of the <tt class=literal>Component</tt>, which returns 
<tt class=literal>Integer.MAX_VALUE</tt> for both 
dimensions. None of the <tt class=literal>java.awt</tt> 
layout managers use the concept of maximum size yet. 

<p>
<dt class=varlistentry><i class=emphasis>public float getAlignmentX () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>getAlignmentX()</tt> method 
returns the alignment of the components within the container along the 
x axis. This container determines its alignment by calling the current 
<tt class=literal>LayoutManager2</tt>'s <tt class=literal>getLayoutAlignmentX()</tt> 
method, which computes it based upon its children. The return value is 
between 0.0 and 1.0. Values nearer 0 indicate that the component should 
be placed closer to the left edge of the area available. Values nearer 
1 indicate that the component should be placed closer to the right. The value 0.5 
means the component should be centered. If the layout manager is not an 
instance of <tt class=literal>LayoutManager2</tt>, 
this method calls <tt class=literal>Component</tt>'s 
<tt class=literal>getAlignmentX()</tt> method, which 
returns the constant <tt class=literal>Component.CENTER_ALIGNMENT</tt>. 
None of the <tt class=literal>java.awt</tt> layout 
managers use the concept of alignment yet. 

<p>
<dt class=varlistentry><i class=emphasis>public float getAlignmentY () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>getAlignmentY()</tt> method 
returns the alignment of the components within the container along the 
y axis. This container determines its alignment by calling the current 
<tt class=literal>LayoutManager2</tt>'s <tt class=literal>getLayoutAlignmentY()</tt> 
method, which computes it based upon its children. The return value is 
between 0.0 and 1.0. Values nearer 0 indicate that the component should 
be placed closer to the top of the area available. Values nearer 1 indicate 
that the component should be placed closer to the bottom. The value 0.5 means the 
component should be centered. If the layout manager is not an instance 
of <tt class=literal>LayoutManager2</tt>, this method 
calls <tt class=literal>Component</tt>'s <tt class=literal>getAlignmentY()</tt> 
method, which returns the constant <tt class=literal>Component.CENTER_ALIGNMENT</tt>. 
None of the <tt class=literal>java.awt</tt> layout 
managers use the concept of alignment yet. 

<p>
<dt class=varlistentry><i class=emphasis>public void doLayout () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br><i class=emphasis>public void layout () <img src="gifs/wstar.gif" alt="(Deprecated)" border=0></I><br>
<dd>

<p class=para>
The <tt class=literal>doLayout()</tt> method of <tt class=literal>Container</tt> 
instructs the <tt class=literal>LayoutManager</tt> 
to lay out the container. This is done by calling the  
<tt class=literal>layoutContainer()</tt> method of the current <tt class=literal>LayoutManager</tt>. 

<p class=para>
<tt class=literal>layout()</tt>is the Java 1.0 name 
for this method. 

<p>
<dt class=varlistentry><i class=emphasis>public void validate () </I><br>
<dd>

<p class=para>
The <tt class=literal>validate()</tt> method sets 
the container's valid state to <tt class=literal>true</tt> 
and recursively validates all of its children. If a child is a <tt class=literal>Container</tt>, 
its children are in turn validated. Some components are not completely 
initialized until they are validated. For example, you cannot ask a <tt class=literal>Button</tt> 
for its display dimensions or position until it is validated. 

<p>
<dt class=varlistentry><i class=emphasis>protected void validateTree () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>validateTree()</tt> method is 
a helper for <tt class=literal>validate()</tt> that 
does all the work. 

<p>
<dt class=varlistentry><i class=emphasis>public void invalidate () <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>invalidate()</tt> method invalidates 
the container and recursively invalidates the children. If the layout manager 
is an instance of <tt class=literal>LayoutManager2</tt>, 
its <tt class=literal>invalidateLayout()</tt> method 
is called to invalidate any cached values. </DL>
Event delivery

<p class=para>
The event model for Java is described in <a href="ch04_01.htm">Chapter 4, <i>Events</i></A>. These 
methods help in the handling of the various system events at the container 
level. 

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public void deliverEvent (Event e) <img src="gifs/wstar.gif" alt="(Deprecated)" border=0></I><br>
<dd>

<p class=para>
The <tt class=literal>deliverEvent()</tt> method is 
called by the system when the Java 1.0 <tt class=literal>Event</tt> 
<tt class=literal>e</tt> happens. <tt class=literal>deliverEvent()</tt> 
tries to locate a component contained in the container that should receive 
it. If one is found, the x and y coordinates of <tt class=literal>e</tt> 
are translated for the new target, and <tt class=literal>Event</tt> 
<tt class=literal>e</tt> is delivered to this by calling 
its <tt class=literal>deliverEvent()</tt>. If <tt class=literal>getComponentAt()</tt> 
fails to find an appropriate target, the event is just posted to the container 
with <tt class=literal>postEvent()</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public Component getComponentAt (int x, int y) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br><i class=emphasis>public Component locate (int x, int y) <img src="gifs/wstar.gif" alt="(Deprecated)" border=0></I><br>
<dd>

<p class=para>
The container's <tt class=literal>getComponentAt()</tt> 
method calls each component's <tt class=literal>contains()</tt> 
method to see if the <tt class=literal>x</tt> and 
<tt class=literal>y</tt> coordinates are within it. 
If they are, that component is returned. If the coordinates are not in 
any child component of this container, the container is returned. It is 
possible for <tt class=literal>getComponentAt()</tt> 
to return <tt class=literal>null</tt> if the <tt class=literal>x</tt> 
and <tt class=literal>y</tt> coordinates are not within 
the container. The method <tt class=literal>getComponentAt()</tt> 
can return another <tt class=literal>Container</tt> 
or a lightweight component. 

<p class=para>
<tt class=literal>locate()</tt>is the Java 1.0 name 
for this method. 

<p>
<dt class=varlistentry><i class=emphasis>public Component getComponentAt (Point p)  <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
This <tt class=literal>getComponentAt()</tt> method 
is identical to the previous method, with the exception that the location is passed 
as a single point, rather than as separate <tt class=literal>x</tt> and <tt class=literal>y</tt> coordinates. </DL>
Listeners and 1.1 event handling

<p class=para>
With the 1.1 event model, you register listeners, which are told when events 
occur. Container events occur when a component is added or removed. 

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public synchronized void addContainerListener(ContainerListener listener) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>addContainerListener()</tt> 
method registers <tt class=literal>listener</tt> as 
an object interested in receiving notifications when an <tt class=literal>ContainerEvent</tt> 
passes through the <tt class=literal>EventQueue</tt> 
with this <tt class=literal>Container</tt> as its 
target. The <tt class=literal>listener.componentAdded()</tt> 
or <tt class=literal>listener.componentRemoved()</tt> 
method is called when these events occur. Multiple listeners can be registered. 
The following code demonstrates how to use a <tt class=literal>ContainerListener</tt> 
to register action listeners for all buttons added to an applet. It is 
similar to the <tt class=literal>ButtonTest11</tt> 
example in <a href="ch05_03.htm">Button Events</A>. The trick that makes this 
code work is the call to <tt class=literal>enableEvents()</tt> 
in <tt class=literal>init()</tt>. This method makes 
sure that container events are delivered in the absence of listeners. In 
this applet, we know there won't be any container listeners, so we 
must enable container events explicitly before adding any components. </DL>
<div class=screen>
<p>
<pre>
// Java 1.1 only
import java.awt.*;
import java.applet.*;
import java.awt.event.*; 
public class NewButtonTest11 extends Applet implements ActionListener { 
    Button b; 
    public void init () { 
        enableEvents (AWTEvent.CONTAINER_EVENT_MASK); 
        add (b = new Button ("One")); 
        add (b = new Button ("Two")); 
        add (b = new Button ("Three")); 
        add (b = new Button ("Four")); 
    } 
    protected void processContainerEvent (ContainerEvent e) { 
        if (e.getID() == ContainerEvent.COMPONENT_ADDED) { 
            if (e.getChild() instanceof Button) { 
                Button b = (Button)e.getChild(); 
                b.addActionListener (this); 
            } 
        } 
    } 
    public void actionPerformed (ActionEvent e) { 
        System.out.println ("Selected: " + e.getActionCommand()); 
    } 
} 
</PRE>
</DIV>

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public void removeContainerListener(ContainerListener listener) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>removeContainerListener()</tt> 
method removes <tt class=literal>listener</tt> as 
an interested listener. If <tt class=literal>listener</tt> 
is not registered, nothing happens. 

<p>
<dt class=varlistentry><i class=emphasis>protected void processEvent(AWTEvent e) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>processEvent()</tt> method receives 
all <tt class=literal>AWTEvent</tt>s with this <tt class=literal>Container</tt> 
as its target. <tt class=literal>processEvent()</tt> 
then passes them along to any listeners for processing. When you subclass 
<tt class=literal>Container</tt>, overriding <tt class=literal>processEvent()</tt> 
allows you to process all events yourself, before sending them to any listeners. 
There is no equivalent under the 1.0 event model. 

<p class=para>
If you override <tt class=literal>processEvent()</tt>, 
remember to call <tt class=literal>super.processEvent(e)</tt> 
last to ensure that regular event processing can occur. If you want to 
process your own events, it's a good idea to call <tt class=literal>enableEvents()</tt> 
(inherited from <tt class=literal>Component</tt>) 
to ensure that events are delivered even in the absence of registered listeners. 

<p>
<dt class=varlistentry><i class=emphasis>protected void processContainerEvent(ContainerEvent e) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>processContainerEvent()</tt> 
method receives all <tt class=literal>ContainerEvent</tt>s 
with this <tt class=literal>Container</tt> as its 
target. <tt class=literal>processContainerEvent()</tt> 
then passes them along to any listeners for processing. When you subclass 
<tt class=literal>Container</tt>, overriding the <tt class=literal>processContainerEvent()</tt> 
method allows you to process all container events yourself, before sending them 
to any listeners. There is no equivalent under the 1.0 event model. 

<p class=para>
If you override the <tt class=literal>processContainerEvent()</tt> method, 
remember to call <tt class=literal>super.processContainerEvent(e)</tt> 
last to ensure that regular event processing can occur. If you want to 
process your own events, it's a good idea to call <tt class=literal>enableEvents()</tt> 
(inherited from <tt class=literal>Component</tt>) 
to ensure that events are delivered even in the absence of registered listeners. </DL>
Painting

<p class=para>
The following methods are early vestiges of an approach to painting 
and printing. They are not responsible for anything that couldn't 
be done with a call to <tt class=literal>paintAll()</tt> 
or <tt class=literal>printAll()</tt>. However, they 
are available if you wish to call them. 

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public void paintComponents (Graphics g) </I><br>
<dd>

<p class=para>
The <tt class=literal>paintComponents()</tt> method 
of <tt class=literal>Container</tt> paints the different 
components it contains. It calls each component's <tt class=literal>paintAll()</tt> 
method with a clipped graphics context <tt class=literal>g</tt>, 
which is eventually passed to <tt class=literal>paint()</tt>. 

<p>
<dt class=varlistentry><i class=emphasis>public void printComponents (Graphics g) </I><br>
<dd>

<p class=para>
The <tt class=literal>printComponents()</tt> method 
of <tt class=literal>Container</tt> prints the different 
components it contains. It calls each component's <tt class=literal>printAll()</tt> 
method with a clipped graphics context <tt class=literal>g</tt>, 
which is passed to <tt class=literal>print()</tt>, 
and eventually works its way to <tt class=literal>paint()</tt>. </DL>
<p class=para>
Since it is the container's responsibility to deal with painting 
lightweight peers, the <tt class=literal>paint()</tt> 
and <tt class=literal>print()</tt> methods are overridden 
in Java 1.1. 

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public void paint(Graphics g) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>paint()</tt> method of <tt class=literal>Container</tt> 
paints the different lightweight components it contains. </DL>
<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public void print(Graphics g) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>print()</tt> method of <tt class=literal>Container</tt> 
prints the different lightweight components it contains.</DL>
<div class=note>
<p class=note><blockquote><p><b>NOTE:</B> 
</blockquote><p>
</DIV>

<p class=para>
If you override <tt class=literal>paint()</tt> or <tt class=literal>print()</tt> in your containers (especially applets), call <tt class=literal>super.paint(g)</tt> 
or <tt class=literal>super.print(g)</tt>, respectively, to make sure that lightweight components are rendered. This is a good practice 
even if you don't currently use any lightweight components; you don't 
want your code to break mysteriously if you add a lightweight component 
later. 
</blockquote><p>
</DIV>

Peers

<p class=para>
The container is responsible for creating and destroying all the peers 
of the components within it. 

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>public void addNotify ()  </I><br>
<dd>

<p class=para>
The <tt class=literal>addNotify()</tt> method of <tt class=literal>Container</tt> 
creates the peer of all the components within it. After <tt class=literal>addNotify()</tt> 
is called, the <tt class=literal>Container</tt> is 
invalid. It is useful for top-level containers to call this method explicitly 
before calling the method <tt class=literal>setVisible(true)</tt> 
to guarantee that the container is laid out before it is displayed. 

<p>
<dt class=varlistentry><i class=emphasis>public void removeNotify ()  </I><br>
<dd>

<p class=para>
The <tt class=literal>removeNotify()</tt> method destroys 
the peer of all the top-level objects contained within it. This in effect 
destroys the peers of all the components within the container. </DL>
Miscellaneous methods

<p>
<dl class=variablelist>
<dt class=varlistentry><i class=emphasis>protected String paramString () </I><br>
<dd>

<p class=para>
When you call the <tt class=literal>toString()</tt> 
method of a container, the default <tt class=literal>toString()</tt> 
method of <tt class=literal>Component</tt> is called. 
This in turn calls <tt class=literal>paramString()</tt> 
which builds up the string to display. At the <tt class=literal>Container</tt> 
level, <tt class=literal>paramString()</tt> appends 
the layout manager name, like <tt class=literal>layout=java.awt.BorderLayout</tt>, 
to the output. 

<p>
<dt class=varlistentry><i class=emphasis>public Insets getInsets () <img src="gifs/bstar.gif" alt="(New)" border=0>  </I><br><i class=emphasis>public Insets insets () <img src="gifs/wstar.gif" alt="(Deprecated)" border=0> </I><br>
<dd>

<p class=para>
The <tt class=literal>getInsets()</tt> method gets 
the container's current insets. An inset is the amount of space reserved 
for the container to use between its edge and the area actually available 
to hold components. For example, in a <tt class=literal>Frame</tt>, 
the inset for the top would be the space required for the title bar and 
menu bar. Insets exist for top, bottom, right, and left. When you override 
this method, you are providing an area within the container that is reserved 
for free space. If the container has insets, they would be the default. 
If not, the default values are all zeroes. 

<p class=para>
The following code shows how to override <tt class=literal>insets()</tt> 
to provide values other than the default. The top and bottom have 20 pixels 
of inset. The left and right have 50. <a href="ch06_03.htm">Insets</A> 
describes the <tt class=literal>Insets</tt> class 
in more detail. 

<div class=screen>
<p>
<pre>
public Insets insets () {            // getInsets() for Java 1.1
        return new Insets (20, 50, 20, 50);
}
</PRE>
</DIV>

<p class=para>
To find out the current value, just call the method and look at the results. 
For instance, for a <tt class=literal>Frame</tt> the 
results could be the following in the format used by <tt class=literal>toString()</tt>:

<div class=screen>
<p>
<pre>
java.awt.Insets[top=42,left=4,right=4,bottom=4]
</PRE>
</DIV>

<p class=para>
The <tt class=literal>42</tt> is the space required for the title and menu bar, while the <tt class=literal>4</tt> around 
the edges are for the window decorations. These results are platform specific 
and allow you to position items based upon the user's run-time environment. 

<p class=para>
When drawing directly onto the graphics context of a container with a large 
inset such as <tt class=literal>Frame</tt>, remember 
to work around the insets. If you do something like <tt class=literal>g.drawString("Hello 
World", 5, 5)</tt> onto a <tt class=literal>Frame</tt>, 
the user won't see the text. It will be under the title bar and menu 
bar. 

<p class=para>
<tt class=literal>insets()</tt> is the Java 1.0 name 
for this method. 

<p>
<dt class=varlistentry><i class=emphasis>public void list (PrintWriter output, int indentation) <img src="gifs/bstar.gif" alt="(New)" border=0> </I><br><i class=emphasis>public void list (PrintStream output, int indentation) </I><br>
<dd>

<p class=para>
The <tt class=literal>list()</tt> method is very helpful 
if you need to find out what is inside a container. It recursively calls 
itself for each container level of objects inside it, increasing the <tt class=literal>indentation</tt> 
at each level. The results are written to the <tt class=literal>PrintStream</tt> 
or <tt class=literal>PrintWriter</tt> <tt class=literal>output</tt>. </DL>
</DIV>

</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch05_07.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src='gifs/txthome.gif' border=0 alt='Home'></a></td>
<td width=172 align=right valign=top><a href="ch06_02.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Cursor</td>
<td width=171 align=center valign=top><a href="index/idx_a.htm"><img src='gifs/index.gif' alt='Book Index' border=0></a></td>
<td width=172 align=right valign=top>Panel</td>
</tr>
</table>
<hr align=left width=515>

<img src="gifs/smnavbar.gif" usemap="#map" border=0> 
<map name="map"> 
<area shape=RECT coords="0,0,108,15" href="../javanut/index.htm" alt="Java in a Nutshell"> 
<area shape=RECT coords="109,0,200,15" href="../langref/index.htm" alt="Java Language Reference"> 
<area shape=RECT coords="203,0,290,15" href="index.htm" alt="Java AWT"> 
<area shape=RECT coords="291,0,419,15" href="../fclass/index.htm" alt="Java Fundamental Classes"> 
<area shape=RECT coords="421,0,514,15" href="../exp/index.htm" alt="Exploring Java"> 
</MAP>
</DIV>

</BODY>
</HTML>
