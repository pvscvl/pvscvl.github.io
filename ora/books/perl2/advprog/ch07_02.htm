<HTML
><HEAD
>
<TITLE>7.2 Objects in Perl (Advanced Perl Programming)</TITLE>
<META
NAME="DC.title"
CONTENT="Advanced Perl Programming"><META
NAME="DC.creator"
CONTENT="Sriram Srinivasan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:33:46Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-220-4"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch07_01.htm"
TITLE="7. Object-Oriented Programming"><LINK
REL="prev"
HREF="ch07_01.htm"
TITLE="7.1 OO: An Introduction"><LINK
REL="next"
HREF="ch07_03.htm"
TITLE="7.3 UNIVERSAL"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Perl Programming"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Advanced Perl Programming"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_01.htm"
TITLE="7.1 OO: An Introduction"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.1 OO: An Introduction"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch07_01.htm"
TITLE="7. Object-Oriented Programming"
>Chapter 7<BR>Object-Oriented Programming</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_03.htm"
TITLE="7.3 UNIVERSAL"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.3 UNIVERSAL"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch07-23061"
>7.2 Objects in Perl</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969712-0"
></A
>Let us define a few preliminary terms before we start implementing objects in Perl. </P
><P
CLASS="para"
>An <EM
CLASS="emphasis"
>object</EM
> (also called an <EM
CLASS="emphasis"
>instance</EM
>), like a given car, has the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch07-pgfId-966491"
></A
><I
CLASS="firstterm"
>Attributes</I
> or properties (color: red; seating capacity: 4; power: 180 HP) </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch07-pgfId-966480"
></A
><I
CLASS="firstterm"
>Identity</I
> (my car is different from your car)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch07-pgfId-966484"
></A
><I
CLASS="firstterm"
>Behavior</I
> (it can be steered and moved forward and backward)</P
></LI
></UL
><P
CLASS="para"
>Objects of a certain type are said to belong to a <EM
CLASS="emphasis"
>class</EM
>. My car and your car belong to the class called Car or, if you are not too worried about specific details, to a class called Vehicle. All objects of a class have the same functionality.</P
><P
CLASS="para"
>In this section, we study how to create objects and how to enrich basic designs using inheritance and polymorphism.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-pgfId-951417"
>7.2.1 Attributes</A
></H3
><P
CLASS="para"
>An object is a collection of <A
CLASS="indexterm"
NAME="ch07-idx-969714-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969714-1"
></A
>attributes. An array or a hash can be used to represents this set, as we discussed in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="Implementing Complex Data Structures"
>Chapter 2, <CITE
CLASS="chapter"
>Implementing Complex Data Structures</CITE
></A
>. For example, if you need to keep track of an employee's particulars, you might choose one of these approaches:</P
><PRE
CLASS="programlisting"
># Use a hash table to store Employee attributes
%employee = (&quot;name&quot;     =&gt; &quot;John Doe&quot;,
             &quot;age&quot;      =&gt; 32,
             &quot;position&quot; =&gt; &quot;Software Engineer&quot;);
print &quot;Name: &quot;, $employee{name};

# Or use an array
$name_field = 0; $age_field = 1; $position_field = 2;
@employee = (&quot;John Doe&quot;, 32, &quot;Software Engineer&quot;);
print &quot;Name: &quot;, $employee[$name_field];</PRE
><P
CLASS="para"
>The section <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="Efficient Attribute Storage"
>"Efficient Attribute Storage"</A
> in <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="Object Orientation: The Next Few Steps"
>Chapter 8, <CITE
CLASS="chapter"
>Object Orientation: The Next Few Steps</CITE
></A
> describes a more efficient approach for storing attributes. Meanwhile, we will use a hash table for all our examples.<A
CLASS="indexterm"
NAME="ch07-idx-969716-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969716-1"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-pgfId-951421"
>7.2.2 Unique Identity</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969718-0"
></A
>Clearly, one <KBD
CLASS="command"
>%employee</KBD
> won't suffice. Each employee requires a unique identity and his or her own collection of attributes. You can either allocate this structure dynamically or return a reference to a local data structure, as shown below:</P
><PRE
CLASS="programlisting"
># Using an anonymous hash
sub new_employee {
    my ($name, $age, $starting_position) = @_;
    my $r_employee = {                  # Create a unique object 
        &quot;name&quot;     =&gt; $name,            # using an anonymous hash
        &quot;age&quot;      =&gt; $age,
        &quot;position&quot; =&gt; $starting_position
    };
    return $r_employee;                 # Return &quot;object&quot;
}

# OR, returning a reference to a local variable
sub new_employee {
    my ($name, $age, $starting_position) = @_;
    my %employee = (
        &quot;name&quot;     =&gt; $name,
        &quot;age&quot;      =&gt; $age,
        &quot;position&quot; =&gt; $starting_position
    );
    return \%employee;  # return a reference to a local object
}
# Use it to create two employees
$emp1 = new_employee(&quot;John Doe&quot;,   32, &quot;Software Engineer&quot;);
$emp2 = new_employee(&quot;Norma Jean&quot;, 25, &quot;Vice President&quot;);</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>new_employee()</KBD
> returns a reference to a unique data structure in both cases. </P
><P
CLASS="para"
>As a <EM
CLASS="emphasis"
>user</EM
> of this subroutine, you are not expected to know whether this scalar contains a reference to a Perl data structure or whether it contains a string (for example, it could just contain a database primary key, while the rest of the details are in a corporate database). The employee details are hence well encapsulated. Not that encapsulation should not be confused with enforced privacy.</P
><P
CLASS="para"
>In the preceding example, the hash table is the object, and the reference to the hash table is termed the <EM
CLASS="emphasis"
>object reference</EM
><A
CLASS="indexterm"
NAME="ch07-idx-969719-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969719-1"
></A
>. Keep in mind that we have not introduced any new syntax since the last chapter. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-pgfId-951422"
>7.2.3 Behavior</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969720-0"
></A
>All functions that access or update one or more attributes of the object constitute the behavior of the object. </P
><P
CLASS="para"
>Consider </P
><PRE
CLASS="programlisting"
>sub promote_employee {
   my $r_employee = shift;
   $r_employee-&gt;{&quot;position&quot;} = 
       lookup_next_position($r_employee-&gt;{&quot;position&quot;});
}

# To use it
promote_employee($emp1);</PRE
><P
CLASS="para"
>Such functions are also called <EM
CLASS="emphasis"
>instance methods</EM
><A
CLASS="indexterm"
NAME="ch07-idx-969722-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969722-1"
></A
> in OO circles because they require a specific <I
CLASS="firstterm"
>instance</I
> of the an object; an employee, in this case. </P
><P
CLASS="para"
>To avoid having to suffix every method with the suffix "_employee," we put all these functions in a package of their own, called Employee:</P
><PRE
CLASS="programlisting"
>package Employee;
sub new {   # No need for the suffix.
    ....
}
sub promote {
    ....
}</PRE
><P
CLASS="para"
>To use this module, you need to say:</P
><PRE
CLASS="programlisting"
>$emp = Employee::new(&quot;John Doe&quot;, 32, &quot;Software Engineer&quot;);
Employee::promote($emp); </PRE
><P
CLASS="para"
>As you can see, this code is beginning to encapsulate a class called <KBD
CLASS="command"
>Employee</KBD
>: the user of this code invokes only the <EM
CLASS="emphasis"
>interface functions</EM
><A
CLASS="indexterm"
NAME="ch07-idx-969721-0"
></A
> <KBD
CLASS="command"
>new</KBD
> and <KBD
CLASS="command"
>promote</KBD
> and does not know or care about the type of data structure used to store employee details, or, as we mentioned earlier, whether a database is being used behind the scenes.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-pgfId-951496"
>7.2.4 The Need for Polymorphism</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969723-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969723-1"
></A
>What we have seen thus far is the kind of stuff that a C programmer would do, except that he or she would likely use a <EM
CLASS="emphasis"
>struct</EM
> to keep track of the attributes. This is precisely the way the <KBD
CLASS="command"
>stdio</KBD
> library works, for example. <KBD
CLASS="command"
>fopen()</KBD
> is a constructor that returns a pointer to a unique <KBD
CLASS="command"
>FILE</KBD
> structure, allocated dynamically. The pointer (the object reference) is supplied to other methods like <KBD
CLASS="command"
>fgets()</KBD
> and <KBD
CLASS="command"
>fprintf()</KBD
>.</P
><P
CLASS="para"
>Unfortunately, complications arise when the problem gets more involved. Let us say we have to keep information about hourly and regular employees. Hourly employees get paid by the hour and are eligible for overtime pay, while regular employees get a monthly salary. One way to approach it is to create a <KBD
CLASS="command"
>new</KBD
> function per type of employee:</P
><PRE
CLASS="programlisting"
>package Employee;
# Creating Regular Employees
sub <B
CLASS="emphasis.bold"
>new_regular</B
> {
    my ($name, $age, $starting_position, $monthly_salary) = @_;
    my $employee = {
        &quot;name&quot;           =&gt; $name,
        &quot;age&quot;            =&gt; $age,
        &quot;position&quot;       =&gt; $starting_position,
        &quot;monthly_salary&quot; =&gt; $monthly_salary,
    };
    return $employee;  # return the object reference
}
# Hourly Employees
sub <B
CLASS="emphasis.bold"
>new_hourly</B
> {
    my ($name, $age, $starting_position, 
        $hourly_rate, $overtime_rate) = @_;
    my $employee = {
        &quot;name&quot;          =&gt; $name,
        &quot;age&quot;           =&gt; $age,
        &quot;position&quot;      =&gt; $starting_position,
        &quot;hourly_rate&quot;   =&gt; $hourly_rate,
        &quot;overtime_rate&quot; =&gt; $overtime_rate
    };
    return $employee;  # return the object reference
}</PRE
><P
CLASS="para"
>Now, if we want to get an employee's year-to-date salary, we have to make a distinction between the two types of employees. We could provide the two subroutines <KBD
CLASS="command"
>compute_hourly_ytd_income()</KBD
> and <KBD
CLASS="command"
>compute_regular_ytd_income()</KBD
>, but of course the story doesn't end there. Other differences between hourly and regular employees (such as allowed vacation, medical benefits, and so on) or the introduction of other <EM
CLASS="emphasis"
>types</EM
> of employees (such as temporary employees) results in a combinatorial explosion of functions. Worse, the interface requires the <EM
CLASS="emphasis"
>user</EM
> of this package to make a distinction between types of employees to be able to call the right function. </P
><P
CLASS="para"
>To get us out of this bind, we put different types of employees in different packages. Then we use the <KBD
CLASS="command"
>bless</KBD
><A
CLASS="indexterm"
NAME="ch07-idx-969724-0"
></A
> keyword to tag objects internally with a pointer to the packages they belong to. The boldface lines in the following example show the changes from the code presented above (explanations follow): </P
><PRE
CLASS="programlisting"
>#-------------------------------------------------------------
<B
CLASS="emphasis.bold"
>package RegularEmployee</B
>;
sub new {
    my ($name, $age, $starting_position, $monthly_salary) = @_;
    my $r_employee = {                        
        &quot;name&quot;           =&gt; $name,            
        &quot;age&quot;            =&gt; $age,
        &quot;position&quot;       =&gt; $starting_position,
        &quot;monthly_salary&quot; =&gt; $monthly_salary,
        &quot;months_worked&quot;  =&gt; 0,
    };
    <B
CLASS="emphasis.bold"
>bless $r_employee, 'RegularEmployee';</B
>   # Tag object with pkg name
    return $r_employee;                     # Return object
}
sub promote {
   #...
}
sub <B
CLASS="emphasis.bold"
>compute_ytd_income</B
>{
   my $r_emp = shift;
   # Assume the months_worked attribute got modified at some point
   return $r_emp-&gt;{'monthly_salary'} * $r_emp-&gt;{'months_worked'};
}

#-------------------------------------------------------------
<B
CLASS="emphasis.bold"
>package HourlyEmployee</B
>;
sub new {
    my ($name, $age, $starting_position, 
        $hourly_rate, $overtime_rate) = @_;
    my $r_employee = {
        &quot;name&quot;          =&gt; $name,
        &quot;age&quot;           =&gt; $age,
        &quot;position&quot;      =&gt; $starting_position,
        &quot;hourly_rate&quot;   =&gt; $hourly_rate,
        &quot;overtime_rate&quot; =&gt; $overtime_rate
    };
<B
CLASS="emphasis.bold"
>    bless $r_employee, 'HourlyEmployee';</B
>
    return $r_employee;
}
sub promote {
   #...
}
sub <B
CLASS="emphasis.bold"
>compute_ytd_income</B
> {
   my ($r_emp) = $_[0];
   return $r_emp-&gt;{'hourly_rate'} * $r_emp-&gt;{'hours_worked'}
      + $r_emp-&gt;{'overtime_rate'} * $r_emp-&gt;{'overtime_hours_worked'};
}
</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>bless</KBD
> is given an ordinary reference to a data structure. It tags that data structure (note: not the <EM
CLASS="emphasis"
>reference</EM
>[<A
CLASS="footnote"
HREF="#ch07-pgfId-952128"
>1</A
>]) as belonging to a specific package and thus bestows on it some more powers, as we shall soon see. <KBD
CLASS="command"
>bless</KBD
> is to our hash table what baptism is to a child. It doesn't change the data structure in any way (which still remains a hash table), just as baptism doesn't really alter a person except to give them an additional identity.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch07-pgfId-952128"
>[1]</A
> The reference is like a <CODE
CLASS="literal"
>void *</CODE
> in C. The object is typed, not the C pointer or Perl reference.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The nice thing about <KBD
CLASS="command"
>bless</KBD
> is that it gives us a direct way of using this object. Here's how:</P
><PRE
CLASS="programlisting"
># First create two objects as before.
$emp1 = RegularEmployee::new('John Doe', 32,    # Polymorphism
                                'Software Engineer', 5000);
$emp2 = HourlyEmployee::new('Jane Smith', 35,   # Polymorphism
                               'Auditor', 65, 90);<A
CLASS="indexterm"
NAME="ch07-idx-969726-0"
></A
>
</PRE
><P
CLASS="para"
>Now use the <I
CLASS="firstterm"
>arrow notation</I
><A
CLASS="indexterm"
NAME="ch07-idx-969725-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969725-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969725-2"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969725-3"
></A
> to directly invoke instance methods, or, as they say in OO-land, invoke methods <I
CLASS="firstterm"
>on the object</I
>: </P
><PRE
CLASS="programlisting"
># Direct invocation
<B
CLASS="emphasis.bold"
>$emp1-&gt;promote(); </B
>
<B
CLASS="emphasis.bold"
>$emp2-&gt;compute_ytd_income();</B
>      </PRE
><P
CLASS="para"
>When Perl sees <KBD
CLASS="command"
>$emp1-&gt;promote()</KBD
>, it determines the class to which <KBD
CLASS="command"
>$emp1</KBD
> belongs (the one under which it has been blessed). In this case, it is the <KBD
CLASS="command"
>Regular-Employee</KBD
>. Perl then calls this function as follows: <CODE
CLASS="literal"
>RegularEmployee::promote($emp1)</CODE
>. In other words, the object on the left side of the arrow is simply given as the first parameter of the appropriate subroutine.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969739-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969739-1"
></A
>Both the <KBD
CLASS="command"
>::</KBD
> and <KBD
CLASS="command"
>-&gt;</KBD
> notations are in fact permissible, unlike in C++. The first one is more flexible because Perl figures out the class at run time, while the latter is faster because the function to be called is known at compile time. There is nothing magical about an instance method in Perl. It is an ordinary subroutine whose first parameter simply happens to be an object reference. (You might have noticed that the <KBD
CLASS="command"
>promote</KBD
> method did not change from the previous section.)</P
><P
CLASS="para"
>So is this mere syntactic sugar? Finally, all we seem to have achieved is the ability to call an instance method of an object through an alternate notation. </P
><P
CLASS="para"
>No, we have gained an important advantage. The module user doesn't have to discriminate between types of objects using an <KBD
CLASS="command"
>if</KBD
> statement but instead lets Perl take care of routing a call to the appropriate function. That is, instead of saying something like</P
><PRE
CLASS="programlisting"
>if (ref($emp) eq &quot;HourlyEmployee&quot;) {
    $income = HourlyEmployee::compute_ytd_income($emp);
} else {
    $income = RegularEmployee::compute_ytd_income($emp);
}</PRE
><P
CLASS="para"
>we can simply say,</P
><PRE
CLASS="programlisting"
>$income = $emp-&gt;compute_ytd_income();</PRE
><P
CLASS="para"
>This ability of Perl to call the appropriate module's function is called <I
CLASS="firstterm"
>run-time binding</I
><A
CLASS="indexterm"
NAME="ch07-idx-969737-0"
></A
>. Incidentally, recall from <A
CLASS="xref"
HREF="ch01_01.htm"
TITLE="Data References and Anonymous Storage"
>Chapter 1, <CITE
CLASS="chapter"
>Data References and Anonymous Storage</CITE
></A
>, that the <KBD
CLASS="command"
>ref</KBD
><A
CLASS="indexterm"
NAME="ch07-idx-969738-0"
></A
> function returns a string indicating the type of the entity pointed to by the reference; in the case of a blessed object reference, it returns the name of the corresponding class.</P
><P
CLASS="para"
>Note that while processing payroll records, <KBD
CLASS="command"
>$emp</KBD
> can be a regular employee in one iteration and an hourly employee in another. This feature is called <I
CLASS="firstterm"
>polymorphism</I
> (poly + morph = the ability of an object to take on many forms).</P
><P
CLASS="para"
>Polymorphism and run-time binding are the chief contributions of object-oriented languages. They give a system an enormous amount of flexibility because you can now add a new type of employee (with the same <I
CLASS="firstterm"
>interface</I
> as the other types) without having to change the payroll-processing code. This is possible because each object "knows" how to compute its own year-to-date income. It pays to remember this cardinal rule:</P
><BLOCKQUOTE
CLASS="blockquote"
><P
CLASS="para"
><EM
CLASS="emphasis"
>It is indicative of inflexible procedural design if you find yourself using conditional statements to distinguish between object types.</EM
></P
></BLOCKQUOTE
><P
CLASS="para"
>The design is flexible also because you can add new methods to any of the packages without hurting what is already present.<A
CLASS="indexterm"
NAME="ch07-idx-969728-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969728-1"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-39918"
>7.2.5 Class Methods and Attributes</A
></H3
><P
CLASS="para"
><EM
CLASS="emphasis"
>Class attributes</EM
><A
CLASS="indexterm"
NAME="ch07-idx-969740-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969740-1"
></A
> are properties that pertain to all instances of a class, but don't vary on a per-employee basis. For example, one insurance company might provide health coverage for all employees, so it doesn't make sense to store the name of this company in each and every employee. </P
><P
CLASS="para"
><EM
CLASS="emphasis"
>Class methods</EM
> (also known as <I
CLASS="firstterm"
>static methods</I
><A
CLASS="indexterm"
NAME="ch07-idx-969741-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969741-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969741-2"
></A
>) are functions that are relevant to that class but don't need a specific object instance to work with. For example, a subroutine called <KBD
CLASS="command"
>get_employee_names()</KBD
> doesn't require an employee object as input to figure out what it has to do. </P
><P
CLASS="para"
>Perl has no specific syntax for class attributes and methods, unlike C++ or Java. Class attributes are simply package global variables, and class methods are ordinary subroutines that don't work on any specific instance. Perl supports polymorphism and run-time binding for these ordinary subroutines (not just instance methods), which can be leveraged to produce a truly flexible design. Consider</P
><PRE
CLASS="programlisting"
>$record = &lt;STDIN&gt;; # Tab delimited record containing employee details
($type, $name, $age, $position) = split(/\t/, $details);

# Create an employee object of the appropriate class
$emp = <B
CLASS="emphasis.bold"
>$type-&gt;</B
>new($name, $age, $position);

# Now use the object as before
$emp-&gt;compute_ytd_income();</PRE
><P
CLASS="para"
>In this example, <KBD
CLASS="command"
>$type</KBD
> can contain either of these two strings: "HourlyEmployee" or "RegularEmployee." Note that this variable is not an object; it is simply the name of a class. This approach improves on the example in the previous section by avoiding having to hardcode the name of the package. Why is that an improvement? Well, if you <EM
CLASS="emphasis"
>didn't</EM
> have this facility, you would have had to say something like this to create an appropriately typed object:</P
><PRE
CLASS="programlisting"
>if ($type eq &quot;HourlyEmployee&quot;) {
     $emp = HourlyEmployee-&gt;new(....);
} else {
     $emp = RegularEmployee-&gt;new(....);
}</PRE
><P
CLASS="para"
>Any piece of code that explicitly depends upon checking the class or type of an object requires too much maintenance. If you introduce a new type of employee tomorrow, you'll have to go back and add the new type to all such pieces of code.</P
><P
CLASS="para"
>Recall that in the case of an instance method, the object to the left of the arrow is passed as the first parameter to the subroutine. It is no different here. The procedure <KBD
CLASS="command"
>HourlyEmployee::new</KBD
> must be rewritten to expect this:</P
><PRE
CLASS="programlisting"
><B
CLASS="emphasis.bold"
>package HourlyEmployee</B
>;
sub new {
    my (<B
CLASS="emphasis.bold"
>$pkg,</B
> $name, $age, $starting_position, 
        $hourly_rate, $overtime_rate) = @_;</PRE
><P
CLASS="para"
>Given that both instance and class methods are ordinary subroutines, you can always write a subroutine that can function as either, by checking the type of the first parameter supplied to it. Consider the following constructor, which creates a new object or a clone of an existing one, depending on how it is invoked:</P
><PRE
CLASS="programlisting"
>package Employee;
sub new {
    $arg = shift;
    if (ref($arg)) { 
        # Called as $emp-&gt;new(): Clone the Employee given to it
        #....
    } else {
        # Called as Employee-&gt;new():  Create a new employee
        #...
    }
}</PRE
><P
CLASS="para"
>You can now use this method as follows:</P
><PRE
CLASS="programlisting"
># Using new() as a class method
$emp1 = Employee-&gt;new(&quot;John Doe&quot;, 20, &quot;Vice President&quot;);

# Using new() as an instance method to clone the employee details
$emp2 = $emp1-&gt;new();</PRE
><P
CLASS="para"
>I'll leave it up to you to answer why you might want to clone an employee!</P
><P
CLASS="para"
>What have we learned in this section? If we write all our class methods to expect the name of the module as the first parameter, we make it possible for the module's user to employ run-time binding and polymorphism. We will follow this practice from now on. <A
CLASS="indexterm"
NAME="ch07-idx-969755-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969755-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969755-2"
></A
></P
><P
CLASS="para"
>You might be curious why a class method needs to be supplied the name of its own module. We'll answer this shortly when we deal with inheritance.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch07-pgfId-967404"
>7.2.5.1 Detour: The indirect notation</A
></H4
><P
CLASS="para"
>Perl wouldn't be Perl if there weren't a couple of alternatives to suit everyone's fancy. It supports an alternative to the arrow notation, called the <I
CLASS="firstterm"
>indirect</I
><A
CLASS="indexterm"
NAME="ch07-idx-969756-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969756-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969756-2"
></A
> <I
CLASS="firstterm"
>notation</I
>, in which the function name precedes the object or class name. An example should make this clear:</P
><PRE
CLASS="programlisting"
>$emp = <B
CLASS="emphasis.bold"
>new Employee</B
> (&quot;John Doe&quot;, 20, &quot;Vice President&quot;);</PRE
><P
CLASS="para"
>C++ folks will identify with this notation. This approach can be used for objects too:</P
><PRE
CLASS="programlisting"
>promote $emp &quot;Chairman&quot;, 100000; # Give him a promotion and a raise</PRE
><P
CLASS="para"
>Notice that there is no comma between <KBD
CLASS="command"
>$emp</KBD
> and the first argument (<CODE
CLASS="literal"
>&quot;Chairman&quot;</CODE
>). This is how Perl knows that you are calling a method using the indirect notation and not calling a subroutine in the current package. Perhaps you will identify more with the following example:</P
><PRE
CLASS="programlisting"
>use FileHandle;
$fh = new FileHandle(&quot;&gt; foo.txt&quot;);
<B
CLASS="emphasis.bold"
>print $fh</B
> &quot;foo bar\n&quot;;</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>print</KBD
> is a method on the FileHandle module. </P
><P
CLASS="para"
>While the indirect notation has the same effect as the arrow notation, it cannot be used in a chain of calls. The following is possible only with the arrow notation:</P
><PRE
CLASS="programlisting"
>use FileHandle;
$fh = FileHandle-&gt;new(&quot;&gt; foo.txt&quot;)-&gt;autoflush(1); # Chain of calls</PRE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-pgfId-967277"
>7.2.6 The Need for Inheritance</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969757-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969757-1"
></A
>Perl allows a module to specify a list of other module names, in a special array called <KBD
CLASS="command"
>@ISA</KBD
><A
CLASS="indexterm"
NAME="ch07-idx-969768-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969768-1"
></A
>. When it does not find a particular class or instance method in a module, it looks to see if that module's <KBD
CLASS="command"
>@ISA</KBD
> has been initialized. If so, it checks to see if any of those modules support the missing function, picks the first one it can find, and passes control to it. This feature is called <EM
CLASS="emphasis"
>inheritance</EM
>. Consider </P
><PRE
CLASS="programlisting"
>package Man;
@ISA = qw(Mammal Social_Animal);</PRE
><P
CLASS="para"
>This allows us to specify that <KBD
CLASS="command"
>Man</KBD
> is-a <KBD
CLASS="command"
>Mammal</KBD
> and is-a <KBD
CLASS="command"
>Social_Animal</KBD
>. All traits (read: methods) common to mammals are supported in the <KBD
CLASS="command"
>Mammal</KBD
> class and don't have to be implemented in <KBD
CLASS="command"
>Man</KBD
> too. Let us look at a more practical example. </P
><P
CLASS="para"
>In our attempts to distinguish between hourly and regular employees, we have gone to the other extreme and made them completely independent. Clearly, there are a number of common attributes (name, age, and position) and behavior (<KBD
CLASS="command"
>promote</KBD
>, say) that they all share as employees. We can thus use inheritance to "pull out" the common aspects into a <EM
CLASS="emphasis"
><A
CLASS="indexterm"
NAME="ch07-idx-969769-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969769-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969769-2"
></A
>superclass</EM
> (or <EM
CLASS="emphasis"
>base</EM
> <EM
CLASS="emphasis"
>class</EM
>) called <KBD
CLASS="command"
>Employee</KBD
>:</P
><PRE
CLASS="programlisting"
>#---------------------------------------------------------
<B
CLASS="emphasis.bold"
>package Employee</B
>; #Base class
#---------------------------------------------------------
sub allocate{
    my ($pkg, $name, $age, $starting_position) = @_;
    my $r_employee = bless {
        &quot;name&quot;           =&gt; $name,            
        &quot;age&quot;            =&gt; $age,
        &quot;position&quot;       =&gt; $starting_position
    }<B
CLASS="emphasis.bold"
>, $pkg</B
>; 
    return $r_employee;
}
sub promote {
   my $r_employee            = shift;
   my $current_position      = $r_employee-&gt;{&quot;position&quot;};
   my $next_position         = lookup_next_position($current_position);
   $r_employee-&gt;{&quot;position&quot;} = $next_position;
}
#---------------------------------------------------------
package HourlyEmployee;
#---------------------------------------------------------
<B
CLASS="emphasis.bold"
>@ISA = (&quot;Employee&quot;); # Inherits from Employee</B
>
sub new {
    my ($pkg, $name, $age, $starting_position, 
        $hourly_rate, $overtime_rate) = @_;
    # Let the Employee package create and bless the object
    my $r_employee = <B
CLASS="emphasis.bold"
>$pkg-&gt;allocate</B
>($name, $age, 
                                    $starting_position);
    # Add HourlyEmployee-specific attributes and we are done.
    $r_employee-&gt;{&quot;hourly_rate&quot;}   = $hourly_rate;
    $r_employee-&gt;{&quot;overtime_rate&quot;} = $overtime_rate;
    return $r_employee; # return the object reference
}
sub compute_ytd_income { 
    .... 
}
# ... And similarly for package RegularEmployee </PRE
><P
CLASS="para"
>Whatever is common to all employees is implemented in the base class. Since both <KBD
CLASS="command"
>HourlyEmployee</KBD
> and <KBD
CLASS="command"
>RegularEmployee</KBD
> need a class method called <KBD
CLASS="command"
>new()</KBD
> to allocate a hash table, to bless it, and to insert common attributes into this table, we factor this functionality out into a inheritable subroutine called <KBD
CLASS="command"
>allocate</KBD
><A
CLASS="indexterm"
NAME="ch07-idx-969770-0"
></A
> in module Employee .</P
><P
CLASS="para"
>Notice how <KBD
CLASS="command"
>allocate</KBD
> avoids hardcoding the name of a class, thus ensuring maximum reusability. <KBD
CLASS="command"
>HourlyEmployee::new()</KBD
> calls <KBD
CLASS="command"
>$pkg-&gt;allocate</KBD
>, which means that the first parameter to <KBD
CLASS="command"
>allocate</KBD
>, <KBD
CLASS="command"
>$pkg</KBD
>, has the value HourlyEmployee. <KBD
CLASS="command"
>allocate</KBD
> uses this to bless the object directly into the inherited class. <KBD
CLASS="command"
>HourlyEmployee::new</KBD
> doesn't need to create the object anymore; it just has to insert its own specific attributes. </P
><P
CLASS="para"
>Nothing has changed from the user's point of view. You still say,</P
><PRE
CLASS="programlisting"
>$emp = HourlyEmployee-&gt;new(....);</PRE
><P
CLASS="para"
>But we have now managed to eliminate redundant code in the modules and left them open for future enhancements.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch07-36839"
>7.2.6.1 Overriding base classes</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969776-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969776-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969776-2"
></A
>Let us say we wanted to ensure that hourly employees should never rise above the level of a manager. The example shows how to <EM
CLASS="emphasis"
>override</EM
> the base class's <KBD
CLASS="command"
>promote()</KBD
> method to do this check. Here's how:</P
><PRE
CLASS="programlisting"
>package HourlyEmployee;
sub promote {
    my $obj = shift;
    die &quot;Hourly Employees cannot be promoted beyond 'Manager'&quot;
           if ($obj-&gt;{position} eq 'Manager');
    # call base class's promote
    $obj-&gt;Employee::promote(); #Specify the package explicitly
}</PRE
><P
CLASS="para"
>This syntax tells Perl to start the search for <KBD
CLASS="command"
>promote()</KBD
> in the <KBD
CLASS="command"
>@ISA</KBD
> hierarchy, starting from <KBD
CLASS="command"
>Employee</KBD
>. A small problem here is that by hardcoding the name of a class (<KBD
CLASS="command"
>Employee</KBD
>), we make it difficult for us to change our mind about the inheritance hierarchy. To avoid this, Perl provides a pseudoclass called <KBD
CLASS="command"
>SUPER</KBD
><A
CLASS="indexterm"
NAME="ch07-idx-969781-0"
></A
>, like Smalltalk, so that you can say,</P
><PRE
CLASS="programlisting"
>    $obj-&gt;SUPER::promote();</PRE
><P
CLASS="para"
>This searches the <KBD
CLASS="command"
>@ISA</KBD
> hierarchy for the appropriate <KBD
CLASS="command"
>promote</KBD
> subroutine. Now, if we interpose another package between <KBD
CLASS="command"
>Employee</KBD
> and <KBD
CLASS="command"
>HourlyEmployee</KBD
> in the inheritance hierarchy, we just need to update <KBD
CLASS="command"
>HourlyEmployee</KBD
>'s <KBD
CLASS="command"
>@ISA</KBD
> array.<A
CLASS="indexterm"
NAME="ch07-idx-969779-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969779-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969779-2"
></A
></P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> We have now gradually eliminated the need for the <KBD
CLASS="command"
>::</KBD
> notation to call a module's subroutines. A subroutine either is imported directly into your namespace, in which case you don't need to fully qualify its name, or is invoked by using the <KBD
CLASS="command"
>-&gt;</KBD
> notation. You still need to use "<KBD
CLASS="command"
>::</KBD
>" to access a foreign package's <EM
CLASS="emphasis"
>variables</EM
>.<A
CLASS="indexterm"
NAME="ch07-idx-969759-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969759-1"
></A
></P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-16028"
>7.2.7 Object Destruction</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969782-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969782-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969782-2"
></A
>Perl automatically garbage collects a data structure when its reference count drops to zero. If a data structure has been blessed into a module, Perl allows that module to perform some clean-up before it destroys the object, by calling a special procedure in that module called <KBD
CLASS="command"
>DESTROY</KBD
><A
CLASS="indexterm"
NAME="ch07-idx-969783-0"
></A
> and passing it the reference to the object to be destroyed:</P
><PRE
CLASS="programlisting"
>package Employee;
sub DESTROY {
     my ($emp) = @_;
     print &quot;Alas, &quot;, $emp-&gt;{&quot;name&quot;}, &quot; is now no longer with us \n&quot;;
}</PRE
><P
CLASS="para"
>This is similar to C++'s destructor or the <KBD
CLASS="command"
>finalize()</KBD
> method in Java in that Perl does the memory management automatically, but you get a chance to do something before the object is reclaimed. (Unlike Java's <CODE
CLASS="literal"
>finalize</CODE
>, Perl's garbage collection is deterministic; <CODE
CLASS="literal"
>DESTROY</CODE
> is called as soon as the object is not being referred to any more.)</P
><P
CLASS="para"
>Note that you are not compelled to declare this subroutine; you do so only if you have some clean-up work to be done. In a module such as Socket, you would close the corresponding connection, but in something like Employee, where no external system resources are being held up, you don't have to provide a <CODE
CLASS="literal"
>DESTROY</CODE
> method. But recall that <CODE
CLASS="literal"
>AUTOLOAD</CODE
><A
CLASS="indexterm"
NAME="ch07-idx-969784-0"
></A
> is called if a function is not found. In the case in which you supply <CODE
CLASS="literal"
>AUTOLOAD</CODE
> but not the <CODE
CLASS="literal"
>DESTROY</CODE
> method, you might want to ensure that <CODE
CLASS="literal"
>AUTOLOAD</CODE
> checks for this possibility:</P
><PRE
CLASS="programlisting"
>sub AUTOLOAD {
    my $obj = $_[0];
    # $AUTOLOAD contains the name of the missing method

    # Never propagate DESTROY methods
    return if $AUTOLOAD =~ /::DESTROY$/;
    # ....
}</PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-17774"
>7.2.8 Accessor Methods</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969785-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969785-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969785-2"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969785-3"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969785-4"
></A
>According to Rumbaugh et al. [<A
CLASS="xref"
HREF="ch07_06.htm"
TITLE=""
>15</A
>]:</P
><BLOCKQUOTE
CLASS="blockquote"
><P
CLASS="para"
>Encapsulation can be violated when code associated with one class directly accesses the attributes of another class. Direct access makes assumptions about storage format and location of the data. These details must be hidden within the class....The proper way to access an attribute of another object is to "ask for it" by invoking an operation on the object, rather than simply "taking it." </P
></BLOCKQUOTE
><P
CLASS="para"
>This is as true for classes related by inheritance as for unrelated classes.</P
><P
CLASS="para"
>To discourage direct access to an object's attributes, we provide "accessor methods." These two methods read and update the "position" attribute of an employee:</P
><PRE
CLASS="programlisting"
>$pos = $emp-&gt;get_position();                 # read attribute
$emp-&gt;set_position(&quot;Software Engineer&quot;);     # write attribute</PRE
><P
CLASS="para"
>The more popular convention is to have one method to handle both read and write access:</P
><PRE
CLASS="programlisting"
>$pos = $emp-&gt;position();                     # read attribute
$emp-&gt;position(&quot;Software Engineer&quot;);         # write attribute</PRE
><P
CLASS="para"
>This is how the module might implement it:</P
><PRE
CLASS="programlisting"
>package Employee;
sub position {
    my $obj = shift;
    @_ ? $obj-&gt;{position} = shift            # modify attribute
       : $obj-&gt;{position};                   # retrieve attribute
}</PRE
><P
CLASS="para"
>Note that the method returns the latest value of the position attribute in both cases, because in both cases (get and set), the expression <KBD
CLASS="command"
>$obj-&gt;{position}</KBD
> is the last to be evaluated.</P
><P
CLASS="para"
>It might seem a complete waste of time to call a method every time you need to touch an attribute. But, as it happens, accessor methods are absolutely necessary in <EM
CLASS="emphasis"
>designing for change.</EM
> Consider the following advantages:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Encapsulation</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969789-0"
></A
>Accessor methods hide how object attributes are stored. If you change the way this layout is done, only these methods need to be modified; the rest of the code, including derived classes, remain untouched. In Perl, as in other OO scripting languages, in which reengineering may be necessary for performance or space efficiency, accessor methods are a good thing. Smalltalk, CORBA (Common Object Request Broker Architecture), and ActiveX are other well-known cases in which the only way to an attribute is through an accessor. </P
></DD
><DT
CLASS="term"
>Side effects</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Accessor methods are sometimes used for triggering actions in addition to retrieving or updating the attribute. GUI toolkits use this idiom routinely. For example: </P
><PRE
CLASS="programlisting"
>     $button-&gt;foreground_color('yellow');
</PRE
><P
CLASS="para"
>This not only changes the value of the foreground color attribute, but updates the screen too. </P
></DD
><DT
CLASS="term"
>Access checking</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Accessor methods can be made to disallow updates. For example, primary key attributes such as an employee's name should not be updatable once created; an accessor can easily enforce this.</P
></DD
><DT
CLASS="term"
>Computed attributes</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-969793-0"
></A
>An employee's income can be seen as an attribute, though internally it needs to be computed. Instead of writing a method like <KBD
CLASS="command"
>compute_ytd_income()</KBD
>, you simply call it <KBD
CLASS="command"
>income()</KBD
>. This makes it look like an attribute accessor, and it can disallow updates to this attribute.</P
></DD
></DL
><P
CLASS="para"
>Moral of the story: Get in the habit of writing accessor methods. In the next chapter, we will study a module called ObjectTemplate, a standard library called Class::Template, and a module on CPAN called MethodMaker, all of which automatically create accessor methods for you, so there is really no reason not to use such methods.</P
><P
CLASS="para"
>Caveat: Even if your attributes are wrapped in accessor methods, you should be wary of unrelated classes using these methods. When reviewing a piece of code, always look for the real intention behind these accesses; sometimes it may be better to provide other methods that make this access unnecessary. For example, a user should always use <KBD
CLASS="command"
>$emp-&gt;promote()</KBD
> instead of directly updating the <KBD
CLASS="command"
>position</KBD
> attribute.<A
CLASS="indexterm"
NAME="ch07-idx-969791-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969791-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969791-2"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969791-3"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969791-4"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-969791-5"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_01.htm"
TITLE="7.1 OO: An Introduction"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.1 OO: An Introduction"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Perl Programming"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Perl Programming"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_03.htm"
TITLE="7.3 UNIVERSAL"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.3 UNIVERSAL"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>7.1 OO: An Introduction</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>7.3 UNIVERSAL</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
