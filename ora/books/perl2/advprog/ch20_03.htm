<HTML
><HEAD
>
<TITLE>20.3 Perl Value Types (Advanced Perl Programming)</TITLE>
<META
NAME="DC.title"
CONTENT="Advanced Perl Programming"><META
NAME="DC.creator"
CONTENT="Sriram Srinivasan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:41:32Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-220-4"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch20_01.htm"
TITLE="20. Perl Internals"><LINK
REL="prev"
HREF="ch20_02.htm"
TITLE="20.2 Architecture"><LINK
REL="next"
HREF="ch20_04.htm"
TITLE="20.4 Stacks and Messaging Protocol"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Perl Programming"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Advanced Perl Programming"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_02.htm"
TITLE="20.2 Architecture"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 20.2 Architecture"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch20_01.htm"
TITLE="20. Perl Internals"
>Chapter 20<BR>Perl Internals</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_04.htm"
TITLE="20.4 Stacks and Messaging Protocol"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 20.4 Stacks and Messaging Protocol"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch20-14792"
>20.3 Perl Value Types</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-972925-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972925-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972925-2"
></A
>In this section, we'll study the functions and macros for manipulating the internal value types. We will also examine each object's internal makeup in sections entitled "Inside SV," "Inside AV," and so on. Although they will help you in making seasoned judgments about memory overhead and performance, you can skip these sections if the detail weighs you down.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-946839"
>20.3.1 Scalar Values</A
></H3
><P
CLASS="para"
>A <A
CLASS="indexterm"
NAME="ch20-idx-972935-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972935-1"
></A
>scalar value (SV) contains the value of the scalar, a reference count, and a bitmask to describe the state of the scalar. The scalar may be an <A
CLASS="indexterm"
NAME="ch20-idx-972936-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972936-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972936-2"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972936-3"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972936-4"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972936-5"
></A
>integer value ("IV"), a double ("NV"), a string ("PV" for pointer value), a reference ("RV"), or a special-purpose object ("magical"). We'll discuss magical variables separately. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="API for Scalar Values"
>Table 20.1</A
> shows the functions and macros to create, delete, and modify SVs. They are listed in <I
CLASS="filename"
>sv.h</I
> and implemented in <I
CLASS="filename"
>sv.c</I
>. Macros, by convention, have their first letter capitalized. All the tables in this chapter make use of two important typedefs, <KBD
CLASS="command"
>I32</KBD
> and <KBD
CLASS="command"
>U32,</KBD
> which represent signed and unsigned integral quantities that are <EM
CLASS="emphasis"
>at least</EM
> 32 bits wide and big enough to hold a pointer (it will be 64 bits on a 64-bit machine).</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch20-22597"
>Table 20.1: API for Scalar Values</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Function/Macro</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* newSViv(I32);
SV* newSVnv(double);
SV* newSVpv(char* str,
            int   len);</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Create a new SV from an integer, double, or string respectively. <KBD
CLASS="command"
>newSVpv</KBD
> calculates the length of the string if <KBD
CLASS="command"
>len</KBD
> is 0.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* newSVsv(SV *);</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Create a clone of an existing SV. To create an empty SV, use the global scalar <KBD
CLASS="command"
>sv_undef</KBD
>, instead of NULL, like this:</P
><PRE
CLASS="programlisting"
>   newSVsv(&amp;sv_undef);</PRE
><P
CLASS="para"
>This is true of all functions that expect an SV as an argument.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* newSVrv
     (SV*  rv, 
      char *pkgname);</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Creates a new SV and points <CODE
CLASS="literal"
>rv</CODE
> to it. Additionally, if <CODE
CLASS="literal"
>pkgname</CODE
> is nonnull, it blesses <CODE
CLASS="literal"
>rv</CODE
> into that package.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV *newRV (SV* other)
SV* newRV_inc (SV* other)
SV* newRV_noinc(SV *)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Create a reference pointing to any type of value, not just SVs. You can cast other values to an SV*, as will be evident when we examine AVs, HVs, and CVs.</P
><P
CLASS="para"
><KBD
CLASS="command"
>newRV_inc</KBD
> increments the reference count of the entity referred to (and is an alias for <KBD
CLASS="command"
>newRV</KBD
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SvIOK(SV*), SvNOK(SV*),
SvPOK(SV*), SvROK(SV*),
SvOK (SV*), SvTRUE(SV*)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>These macros check whether the SV has a value of the corresponding type and, if so, return 1. They do not trigger a conversion. <KBD
CLASS="command"
>SvOK</KBD
> returns 1 if the value is not <KBD
CLASS="command"
>undef</KBD
>. <KBD
CLASS="command"
>SvTRUE</KBD
> returns 1 if the scalar is true.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>IV     SvIV(SV*)
double SvNV(SV*)
char*  SvPV(SV*,int len)
SV*    SvRV(SV*)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>These macros retrieve the values inside an SV and, except for <KBD
CLASS="command"
>SvRV</KBD
>, force an implicit conversion to the appropriate values if necessary. <KBD
CLASS="command"
>SvIV</KBD
> yields 0 if the scalar contains a nonnumeric string. <KBD
CLASS="command"
>SvPV</KBD
> returns a pointer to a string and updates <KBD
CLASS="command"
>len</KBD
> with its length. The scalar owns that string, so don't free it. Before invoking <KBD
CLASS="command"
>SvRV</KBD
>, make sure that it is indeed a reference, using <CODE
CLASS="literal"
>SvROK</CODE
>. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>sv_setiv (SV*, int)
sv_setnv (SV*, double)
sv_setsv (SV* dest,
          SV* src)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Modifies an SV's values. The SV automatically gets rid of its old value and morphs to the new type. </P
><P
CLASS="para"
><KBD
CLASS="command"
>sv_setsv</KBD
> copies the <CODE
CLASS="literal"
>src</CODE
> SV to the <CODE
CLASS="literal"
>dest</CODE
> SV after checking that the two pointers are different.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>sv_setpv (SV*, char *)
sv_setpvn(SV*, char *,
          int  len
sv_catpv (SV*, char*);
sv_catpvn(SV*, char*,
          int);
sv_catsv (SV*, SV*);</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>String functions, which force the scalar to be a string if necessary. <KBD
CLASS="command"
>sv_setpv</KBD
> assumes a null-terminated string, while <KBD
CLASS="command"
>sv_setpvn</KBD
> takes the length. Both functions make a copy of the given string.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>cat</KBD
> series of functions does string concatenation.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SVTYPE(SV*)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns an enum value, and is equivalent to the <KBD
CLASS="command"
>ref</KBD
> function. These are the common values listed in <I
CLASS="filename"
>sv.h:</I
></P
><P
CLASS="para"
><CODE
CLASS="literal"
>SVt_IV</CODE
>       (Integer)   <CODE
CLASS="literal"
>SVt_NV</CODE
>         (Double)</P
><P
CLASS="para"
><CODE
CLASS="literal"
>SVt_PV</CODE
>       (String) <CODE
CLASS="literal"
>  SVt_RV</CODE
>         (Reference)</P
><P
CLASS="para"
><CODE
CLASS="literal"
>SVt_PVAV </CODE
>(Array)  <CODE
CLASS="literal"
>  SVt_PVHV</CODE
>    (Hash)</P
><P
CLASS="para"
><CODE
CLASS="literal"
>SVt_PVCV </CODE
>(Code)       <CODE
CLASS="literal"
>SVt_PVGV</CODE
>    (Glob)</P
><P
CLASS="para"
><CODE
CLASS="literal"
>SVt_PVMG </CODE
>(Blessed or magical scalar)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>sv_setref_iv(
     SV* rv, 
     char* classname,
     int i)
(and similarly for nv and pv)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Creates a new SV, sets it to the value <CODE
CLASS="literal"
>i</CODE
>, and makes <CODE
CLASS="literal"
>rv</CODE
> refer to this new SV. The other two functions are similar.</P
><P
CLASS="para"
>Note that <KBD
CLASS="command"
>sv_setref_pv</KBD
> stores the pointer; it does not make a copy of the string.</P
><P
CLASS="para"
>If <CODE
CLASS="literal"
>classname </CODE
>is nonnull, these functions bless the reference under that package.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>svREFCNT_dec(SV *)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Decrements the reference count and calls <KBD
CLASS="command"
>sv_free</KBD
> if this count is 0. You should <EM
CLASS="emphasis"
>never</EM
> call <KBD
CLASS="command"
>sv_free</KBD
> yourself.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* sv_bless (
   SV *rv, HV* stash);
int sv_isa(
   SV *, char *pkgname);
int sv_isobject(SV*);</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>sv_bless</KBD
> blesses <CODE
CLASS="literal"
>rv</CODE
>  under a package represented by <CODE
CLASS="literal"
>stash</CODE
>. Please refer to the section  <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Glob Values and Symbol Tables"
>Section 20.3.4</A
>" for an explanation of stashes. sv_isa returns 1 if it inherits from a class <CODE
CLASS="literal"
>pkgname</CODE
>. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* sv_newmortal()
SV* sv_2mortal(SV*)
SV* sv_mortalcopy(SV*)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>By default, if you create an SV, you are responsible for deleting it. If you create a <I
CLASS="firstterm"
>mortal</I
> or temporary variable, Perl automatically deletes it the end of the current scope (unless someone else holds a reference to it). </P
><P
CLASS="para"
><KBD
CLASS="command"
>sv_2mortal</KBD
> tags an existing SV as a mortal, and <KBD
CLASS="command"
>sv_2mortalcopy</KBD
> creates a mortal clone.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* perl_get_sv(
      char* varname,
      int   create)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>To get a scalar variable as you are used to seeing in script space, you have to explicitly bind an SV to a name. <CODE
CLASS="literal"
>create</CODE
>, if TRUE, forces it to create a variable if it didn't exist earlier. <CODE
CLASS="literal"
>varname</CODE
> must always be qualified by the name of the package. To create <KBD
CLASS="command"
>$Foo::a</KBD
>, for example:</P
><PRE
CLASS="programlisting"
>   SV *s = perl_get_av(&quot;Foo::a&quot;, 1);</PRE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>sv_dump(SV*)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name is a misnomer, since it is capable of pretty-printing the contents of all Perl value types (casting them to SV* if necessary). This is extremely useful if you have Perl under a debugger: for example, inside <KBD
CLASS="command"
>gdb</KBD
>, use </P
><PRE
CLASS="programlisting"
>    <KBD
CLASS="command"
>call sv_dump(sv)</KBD
></PRE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The <KBD
CLASS="command"
>mortal</KBD
><A
CLASS="indexterm"
NAME="ch20-idx-972937-0"
></A
> series of calls in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="API for Scalar Values"
>Table 20.1</A
> create a temporary SV or tag an existing value as temporary. These calls essentially tell Perl to shove the SV onto a stack called <KBD
CLASS="command"
>tmps_stack</KBD
> and call <KBD
CLASS="command"
>svREFCNT_dec</KBD
> on the SV at the end of the current scope. (More on this in the section <A
CLASS="xref"
HREF="ch20_04.htm"
TITLE="Inside Other Stacks"
>"Inside Other Stacks</A
>.") Typically, all parameters passed between functions are tagged mortal, because neither the caller nor the called function wants to worry about the appropriate time to delete the SV and its contents; Perl automatically takes care of the memory management.<A
CLASS="indexterm"
NAME="ch20-idx-972939-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972939-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972939-2"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972939-3"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972939-4"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972939-5"
></A
></P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-963949"
>20.3.1.1 Using this API</A
></H4
><P
CLASS="para"
>Perhaps your eyes are somewhat glazed and your mind is numbed, so we will relieve the tedium by writing a custom interpreter using the API we have seen so far. (For now, this is our idea of fun!) <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Creating Scalars for Environment Variables&nbsp- the Hard Way!"
>Example 20.2</A
> shows a function called <KBD
CLASS="command"
>create_envt_vars</KBD
> that creates a scalar variable for every environment variable.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="ch20-18685"
>Example 20.2: Creating Scalars for Environment Variables&nbsp;- the Hard Way!</A
></H4
><PRE
CLASS="programlisting"
>#include &lt;EXTERN.h&gt;
#include &lt;perl.h&gt;
void create_envt_vars (char **environ)
{
    /* 
     * Each element in environ is in the form &lt;envt. var name&gt;=&lt;value&gt;&quot;
     */
    SV * sv = NULL;
    char **env = environ; /* for iterating through environ */
    char buf[1000];       /* will contain a copy of an envt variable */
    char *envt_var_name;  /* Name of the envt. variable, like PATH */
    char *envt_var_value; /* Its corresponding value */
    char var_name[100];   /* Fully qualified name of environment var */
    while (*env) {
        strcpy (buf, *env);
        /* Search for &quot;=&quot;, replace it with '\0', thus splitting it into
         *  logical parts - envt variable name and the value 
         */
        envt_var_name = buf; envt_var_value = buf;
        while (*envt_var_value != '=') envt_var_value++;
        *envt_var_value++ = '\0';
        /* Qualify the environment var with the package name. 
         * PATH becomes $main::PATH 
         */
        strcpy (var_name, &quot;main::&quot;); strcat(var_name, envt_var_name);
        sv = perl_get_sv (var_name, TRUE); /* TRUE =&gt; Force Create */
        /* Set the string value for the sv);
        sv_setpv(sv, envt_var_value);
        env++;  /* On to the next environ variable */
    }
}

static PerlInterpreter *my_perl;  
main(int argc, char **argv, char **env) {
    my_perl = perl_alloc();
    perl_construct(my_perl);
    perl_parse(my_perl, NULL, argc, argv, env);
    create_envt_vars();
    perl_run(my_perl);
    perl_destruct(my_perl);
    perl_free(my_perl);
}</PRE
></DIV
><P
CLASS="para"
>On a DEC Alpha box, you might compile and link it as follows:</P
><PRE
CLASS="programlisting"
><B
CLASS="emphasis.bold"
>% cc -o ex  -I/usr/local/lib/perl5/alpha-dec_osf/5.004/CORE \</B
>
<B
CLASS="emphasis.bold"
>            -L/usr/local/lib/perl5/alpha-dec_osf/5.004/CORE \</B
>
<B
CLASS="emphasis.bold"
>             ex.c -lperl -lsocket -lm</B
></PRE
><P
CLASS="para"
>Now for the big test:</P
><PRE
CLASS="programlisting"
><B
CLASS="emphasis.bold"
>% ./ex -e 'print $USER'</B
>
sriram</PRE
><P
CLASS="para"
>Amazing, it works&nbsp;- try doing that with your regular Perl! Okay, so it's not a big deal, but you are definitely on your way to dirtying your hands more than you thought you could. Or would!</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-951083"
>20.3.1.2 Inside SVs</A
></H4
><P
CLASS="para"
>An SV has the potential of being large, to accommodate the worst case of it morphing to any one of its subtypes. To avoid this, Perl keeps track of the information in two parts, as illustrated in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="An inside view of scalars. Each shaded box represents one SV."
>Figure 20.3</A
>: a generic structure called "<KBD
CLASS="command"
>sv</KBD
>", which contains a bitmask flag, a reference count, and a pointer, <KBD
CLASS="command"
>sv_any</KBD
>, which refers to a "specific part." </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch20-15791"
>Figure 20.3: An inside view of scalars. Each shaded box represents one SV.</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_2003.gif"
ALT="Figure 20.3"><P
CLASS="para"
>The specific part is a structure of the appropriate type and is one of several structures called <KBD
CLASS="command"
>xpv</KBD
>, <KBD
CLASS="command"
>xpviv</KBD
>, <KBD
CLASS="command"
>xpvnv</KBD
>, and so on, depending on what the bitmask flag says is contained by the scalar. A scalar may start life as a number, but the moment it is used in a string context, it morphs to a structure containing both the number and a string. <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="An inside view of scalars. Each shaded box represents one SV."
>Figure 20.3</A
> shows an example of the SV (the middle one) containing a double and a string at the same time. If you modify its value with, say, <KBD
CLASS="command"
>sv_setnv</KBD
>, it sets a bit flag in <KBD
CLASS="command"
>sv_flags</KBD
> to indicate that the string part of it is not valid any more. Perl doesn't morph a structure unless absolutely necessary. </P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch20-idx-972941-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972941-1"
></A
>Devel::Peek module gives you script-level access to the internal information discussed previously:</P
><PRE
CLASS="programlisting"
>use Devel::Peek 'Dump';  # Import the Dump subroutine
$a = 15602;
Dump ($a);</PRE
><P
CLASS="para"
>This outputs</P
><PRE
CLASS="programlisting"
>SV = IV(0x663f1c)
  REFCNT = 1
  FLAGS = (IOK,pIOK)
  IV = 15602</PRE
><P
CLASS="para"
>Modify <KBD
CLASS="command"
>$a</KBD
> to a string and see what happens to it:</P
><PRE
CLASS="programlisting"
>use Devel::Peek 'Dump';
$a = 10;           # Start off with an integer value
$a .= &quot; Ten&quot;;      # Convert to a string
Dump ($a);</PRE
><P
CLASS="para"
>Its output is as follows: </P
><PRE
CLASS="programlisting"
>SV = PVIV(0x7b2ef0)
  REFCNT = 1
  FLAGS = (POK,pPOK)
  IV = 10
  PV = 0x7b2f00 &quot;10 Ten&quot;
  CUR = 6
  LEN = 11<A
CLASS="indexterm"
NAME="ch20-idx-972948-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972948-1"
></A
></PRE
><P
CLASS="para"
>Note that the SV still contains the old integer value (10) but that field will be ignored because the <CODE
CLASS="literal"
>FLAGS</CODE
> field indicates that only its string contents are valid.</P
><P
CLASS="para"
>A basic integer value costs you at least 28 bytes on a typical workstation (<KBD
CLASS="command"
>sizeof(SV)</KBD
> + <KBD
CLASS="command"
>sizeof(XPVIV)</KBD
> + <KBD
CLASS="command"
>malloc</KBD
> overhead). Strings and arrays are more expensive than what you might infer from the length or count alone. The dump above shows that Perl allocated 11 bytes for the string (the <KBD
CLASS="command"
>xpv_len</KBD
> field) instead of the minimum 6 bytes (the length of the string, as stored in the <KBD
CLASS="command"
>xpv_cur</KBD
> field); this means that you can append 5 more bytes to the string without triggering a reallocation. Because it is geared for performance and convenience (being able to treat numbers and strings as one entity), it is not frugal with space at all. In fact, Perl applies this strategy of trading off space for performance for practically all data structures.[<A
CLASS="footnote"
HREF="#ch20-pgfId-961521"
>6</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch20-pgfId-961521"
>[6]</A
> One notable exception being hashes, which share their key strings in one string table, thus minimizing space requirements but taking a small hit in performance.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>There are no simple <KBD
CLASS="command"
>xiv</KBD
> or <KBD
CLASS="command"
>xnv</KBD
> structures that contain just an integer or a floating-point number. I do not know the reason for this, and idly speculate that it's so because a typical script requires numbers to morph into strings (while doing a <KBD
CLASS="command"
>print</KBD
>, for example) or vice versa (reading from files). </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="An inside view of scalars. Each shaded box represents one SV."
>Figure 20.3</A
> also shows the reference counts of the three scalars. The reference count of the middle scalar is 2 because of two arrows pointing to it; the arrows coming from the left imply a symbol table entry (for global and local variables) or a scratchpad for lexical variables, as we saw in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Typeglobs and Symbol Tables"
>Chapter 3</A
>. Note that all pointers to an SV (to any Perl value, actually) refer to the outer structure, never to the "specific" part.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-37480"
>20.3.1.3 SVs and object pointers</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-972954-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972954-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972954-2"
></A
>As an extension writer, you are often interested in storing a pointer to a C or C++ object returned from an XSUB. Recall that the integer (IV) slot of a scalar is guaranteed to be big enough to hold a pointer. We use this facility as follows:</P
><PRE
CLASS="programlisting"
>Matrix *m = new_matrix();
sv_setiv(sv, (IV) m);          # Cast pointer to an IV.  Ugh!</PRE
><P
CLASS="para"
>Crufty, to say the least, but that's the way it is. </P
><P
CLASS="para"
>In practice, C/C++ objects are always associated with <A
CLASS="indexterm"
NAME="ch20-idx-972955-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972955-1"
></A
>blessed references because it allows the Perl programmer to use the arrow notation (<KBD
CLASS="command"
>$matrix-&gt;transpose()</KBD
>). Consider </P
><PRE
CLASS="programlisting"
>RV *rv = newRV();
sv_setref_iv(rv, &quot;Matrix&quot;, (IV) m);</PRE
><P
CLASS="para"
>This creates a new integer SV internally, sets it to the "integer" <KBD
CLASS="command"
>m</KBD
>, and makes <KBD
CLASS="command"
>rv</KBD
> point to this freshly allocated SV. It also blesses <KBD
CLASS="command"
>rv</KBD
> under the module Matrix. This is exactly as if you had said, in Perl space,</P
><PRE
CLASS="programlisting"
>my $m = 0xfffa34a;     # Some pointer value, converted to an int
bless \$m, &quot;Matrix&quot;;   # Return a blessed reference to $m.</PRE
><P
CLASS="para"
>We will use this snippet when discussing typemaps for objects, in the section <A
CLASS="xref"
HREF="ch20_05.htm"
TITLE="Object Interface Using XS Typemaps"
>"Object Interface Using XS Typemaps</A
>."<A
CLASS="indexterm"
NAME="ch20-idx-973070-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973070-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-947553"
>20.3.2 Array Values (AV)</A
></H3
><P
CLASS="para"
>An <A
CLASS="indexterm"
NAME="ch20-idx-972956-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972956-1"
></A
>AV is a dynamic, contiguous array of pointers to SVs, and as we are used to seeing in script space, storing a value at an index beyond its current capacity triggers an automatic expansion of the array. <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="API for Array Values"
>Table 20.2</A
> shows the API for manipulating an AV as a whole and for accessing its elements individually. Take note that unless you clear or undef an AV, it does not touch the reference counts of its constituent SVs.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch20-23948"
>Table 20.2: API for Array Values</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Function/Macro</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>AV * newAV()
AV * av_make(int num,
             SV  **ptr)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Creates an empty AV or a clone of another array of SV*.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>I32  av_len(AV*);</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the highest index of the array (such as <KBD
CLASS="command"
>$#array</KBD
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV** av_fetch (AV*, 
               I32 index,
               I32 lval)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Retrieves the SV* from the given index. If <CODE
CLASS="literal"
>lval</CODE
> is non-zero, it replaces the existing value (at that location) with an <KBD
CLASS="command"
>undef</KBD
>. Note that <KBD
CLASS="command"
>av_fetch</KBD
> returns an SV**  (not SV*); this is the pointer to the position in the array where the SV was stored. This way you can not only make changes to the SV, but also modify the array itself (splice the array at that location, for example).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV** av_store(AV*, 
              I32 index, 
              SV* val)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Stores an SV* at that index and returns an SV**  just like <KBD
CLASS="command"
>av_fetch</KBD
>. Neither function updates the reference counts of the indexed element.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>void av_clear (AV*)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Decrements the reference counts of its constituent scalars and replaces those positions with <KBD
CLASS="command"
>undef</KBD
>. It leaves the array intact. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>void av_undef (AV*)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Decrements ref counts of all its scalars as well as of the array itself. In the typical case, this function deallocates the array. This is different from SVs in that they are deleted implicitly by decrementing the ref count (<KBD
CLASS="command"
>SvREFCNT_dec</KBD
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>void av_extend(AV*,
               int num) </PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Extends the array to <CODE
CLASS="literal"
>num</CODE
> elements. Even though the other functions automatically extend the array, they can only heuristically determine how much to extend it. If you expect to store a lot of entries, you'll save time and many potential reallocations by preextending the array.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>void av_push (AV*, SV*)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Pushes <EM
CLASS="emphasis"
>one</EM
> SV at the end of an AV. You have to write more code if you want to append an entire list. This and the following functions do not touch the SV's reference count.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* av_pop (AV* )</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Pops an SV from the end but doesn't touch its reference count, so you must call <KBD
CLASS="command"
>SvREFCNT_dec</KBD
> or tag it as a temporary variable with <KBD
CLASS="command"
>sv_2mortal</KBD
>, in which case Perl deletes it at the end of the scope.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* av_shift(AV*) </PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Like <KBD
CLASS="command"
>av_pop</KBD
>  but pops an SV from the front of the AV.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>void av_unshift(AV*, 
                I32 num) </PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Creates <CODE
CLASS="literal"
>num</CODE
> empty spaces in front of the list (fills them with <KBD
CLASS="command"
>undef</KBD
>). You have to call <KBD
CLASS="command"
>av_store()</KBD
> to set each element's value.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>AV *perl_get_av (
      char* varname, 
      int   create)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Gets the AV corresponding to <CODE
CLASS="literal"
>varname</CODE
>. Create the variable if <CODE
CLASS="literal"
>create</CODE
> is TRUE.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-947920"
>20.3.2.1 Inside AVs</A
></H4
><P
CLASS="para"
>AVs, like SVs, are split into a generic part and a specific part. As it happens, this is true for the other value types also.</P
><P
CLASS="para"
>As shown in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="AV internal structure. The shaded squares contain real data."
>Figure 20.4</A
>, the <KBD
CLASS="command"
>xav_alloc</KBD
> field points to a dynamically allocated array of SV*s, the real meat of the AV. <KBD
CLASS="command"
>av_fill</KBD
> contains the last valid (or filled) index in this array, and <KBD
CLASS="command"
>av_max</KBD
> contains the total number of SV*s allocated for the array. Perl always strives to make sure it allocates memory in some "reasonable" quantities so that it doesn't have to <KBD
CLASS="command"
>realloc</KBD
> every time you push an element into this array. <KBD
CLASS="command"
>xav_array</KBD
> points to the first valid element. It starts off by pointing to <KBD
CLASS="command"
>xav_alloc[0]</KBD
>, and gets incremented on an <KBD
CLASS="command"
>unshift</KBD
> to avoid having to move the rest of the elements to the left. In other words, the real contents of the AV are bounded by <KBD
CLASS="command"
>xav_array</KBD
> and <KBD
CLASS="command"
>av_fill</KBD
>. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch20-41970"
>Figure 20.4: AV internal structure. The shaded squares contain real data.</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_2004.gif"
ALT="Figure 20.4"><P
CLASS="para"
>The <KBD
CLASS="command"
>xmg_magic</KBD
> pointer is typically NULL but refers to a "magic" structure if the array is special (such as <KBD
CLASS="command"
>@ISA)</KBD
>, represents a blessed object, or is tied to a package.[<A
CLASS="footnote"
HREF="#ch20-pgfId-948029"
>7</A
>] <KBD
CLASS="command"
>xav_arylen</KBD
> is an SV* that starts off being <KBD
CLASS="command"
>NULL</KBD
> but springs into existence as a magical scalar when you use the <KBD
CLASS="command"
>$#</KBD
> notation on the array (to get or set the array length). </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch20-pgfId-948029"
>[7]</A
> You don't have to understand this paragraph until we have covered magical variables.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-972957-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972957-1"
></A
>Devel::Dump gives you script-level access to the internal details of an array and of all its constituent scalars. Dump expects nonscalar values to be passed by reference:</P
><PRE
CLASS="programlisting"
>use Devel::Dump;
@l = (1,2,3,4);
Dump(\@l);  # Pass @l by reference<A
CLASS="indexterm"
NAME="ch20-idx-972959-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972959-1"
></A
></PRE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-947918"
>20.3.3 Hash Values (HVs)</A
></H3
><P
CLASS="para"
>An <A
CLASS="indexterm"
NAME="ch20-idx-972961-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972961-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972961-2"
></A
>HV is a table of hash entries (HEs), each representing a pair consisting of a string key and an SV*. No two hash entries in a hash table can have the same key. The API listed in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="API for Hash Values"
>Table 20.3</A
> allows you to act on the HV as a whole, to fetch or store single elements, or to iterate through it one entry at a time.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch20-24447"
>Table 20.3: API for Hash Values</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Function/Macro</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>HV * newHV()</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Creates a hash value.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV**  
hv_store( 
    HV *hash,
    char* key, U32 klen, 
    SV* val,   U32 hash)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Stores the key-value pair. It doesn't assume the key is a <EM
CLASS="emphasis"
>text</EM
> string, so you <EM
CLASS="emphasis"
>have</EM
> to supply the key length, <CODE
CLASS="literal"
>klen</CODE
>. If <CODE
CLASS="literal"
>hash</CODE
> is 0, Perl computes the hash automatically, which works very well for normal ASCII keys.</P
><P
CLASS="para"
>Like AVs, these functions do not touch the reference count of the value <CODE
CLASS="literal"
>val</CODE
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV**
hv_fetch(
   HV *hash,     
   char* key, U32 klen,
   I32 lval)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>As with AVs, an SV** is returned for efficiency, not for your convenience. When storing an entry, the interpreter has to call<KBD
CLASS="command"
> hv_fetch</KBD
> to see whether an entry corresponding to that key already exists. If so, it can simply replace the value part of the entry without having to traverse the structure all over again.</P
><P
CLASS="para"
>Typically, you should dereference the result and dispose of the returned SV* (call <KBD
CLASS="command"
>SvREFCNT_dec</KBD
>) or arrange to have it disposed of (<KBD
CLASS="command"
>sv_2mortal</KBD
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV*   
hv_delete(
   HV *hash, 
   char* key, U32 klen,
   I32 flags)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Deletes an entry and decrements the ref count of the value. If you don't want the deleted value, pass <KBD
CLASS="command"
>G_DISCARD</KBD
> for the flags; otherwise, it returns a mortal copy of that value. </P
><P
CLASS="para"
>Since the entry is removed from the hash's data structures, it needs to return only an SV*, instead of SV**.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>void hv_clear(HV *hash)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Equal to <KBD
CLASS="command"
>%h=()</KBD
>. Like <KBD
CLASS="command"
>av_clear()</KBD
>, it retains the outer array but gets rid of the hash entries, keys, and values. It also decrements the reference count of each value (not the hash itself).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>void hv_undef(HV *hash)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Clears the HV and decrements its reference count.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>I32 hv_iterinit(HV *hash)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Prepares to iterate through its list of entries and returns the number of elements in the HV. <KBD
CLASS="command"
>hv_iterinit</KBD
> and <KBD
CLASS="command"
>hv_iternextsv</KBD
> are used by the operators <KBD
CLASS="command"
>each</KBD
>, <KBD
CLASS="command"
>keys</KBD
>, and <KBD
CLASS="command"
>values</KBD
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>SV* 
hv_iternextsv(
     HV *hash,
     char** key, 
     I32* pkeylen)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Get the next key and value. The key is returned by reference (along with its length). Unlike <KBD
CLASS="command"
>hv_fetch()</KBD
>, this function returns only an SV*. This is similar to calling <KBD
CLASS="command"
>each()</KBD
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>HV *
perl_get_hv (
    char * varname, 
    int create)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Gets the HV corresponding to varname. Creates the variable if <CODE
CLASS="literal"
>create</CODE
> is TRUE. <CODE
CLASS="literal"
>varname</CODE
> must be qualified with the name of a package.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The iterating functions (<CODE
CLASS="literal"
>hv_iter*</CODE
> ) are safe for deletion but not for insertion. That is, you can invoke <KBD
CLASS="command"
>hv_delete</KBD
> on the current entry while iterating on a hash value using <KBD
CLASS="command"
>hv_iternextsv</KBD
>, but you should not call <KBD
CLASS="command"
>hv_store</KBD
>, because that might trigger a complete reorganization of the hash table.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-948426"
>20.3.3.1 Inside HVs</A
></H4
><P
CLASS="para"
>The HV is a straightforward implementation of a hashing technique called <EM
CLASS="emphasis"
>collision chaining</EM
><A
CLASS="indexterm"
NAME="ch20-idx-972965-0"
></A
>. The basic idea is to reduce a string key to an integer and use this number as an index into an ordinary dynamic array. Clearly, we cannot expect to reduce all possible string keys to unique array indices, so each element of this dynamic array points instead to a linked list of all hash entries that reduced to that index. <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Hash value, containing hash entries"
>Figure 20.5</A
> shows this arrangement.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch20-19195"
>Figure 20.5: Hash value, containing hash entries</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_2005.gif"
ALT="Figure 20.5"><P
CLASS="para"
><KBD
CLASS="command"
>xhv_array</KBD
> is the dynamic array we mentioned above, <KBD
CLASS="command"
>xhv_fill</KBD
> indicates the number of elements that have linked lists hanging off them, and <KBD
CLASS="command"
>xhv_keys</KBD
> contains the total number of hash entries. Given a string, <KBD
CLASS="command"
>hv_fetch()</KBD
> computes the appropriate index and traverses the corresponding linked list, comparing the key to each hash entry's key value.</P
><P
CLASS="para"
>The translation of a string to an array index is a two-step process (for reasons to be discussed soon). First the string is run through an algorithm called a <EM
CLASS="emphasis"
>hash function</EM
><A
CLASS="indexterm"
NAME="ch20-idx-972966-0"
></A
>, which computes an integer from a string without worrying about whether or not that number is practical to use as an array index. Perl's hash function is implemented as follows:</P
><PRE
CLASS="programlisting"
>int i = klen;
unsigned int hash = 0;
char *s = key;
while (i--)
    hash = hash * 33 + *s++;</PRE
><P
CLASS="para"
>The resulting number is known as a <EM
CLASS="emphasis"
>hash</EM
>. There is no guarantee that different strings hash to different hash values. Note that if you have a different hash algorithm, you can compute the hash yourself and supply it to <KBD
CLASS="command"
>hv_store</KBD
> (refer to <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="API for Hash Values"
>Table 20.3</A
>).</P
><P
CLASS="para"
>To convert the hash to a practical array index, Perl folds it into the array's maximum size:</P
><PRE
CLASS="programlisting"
>index = hash &amp; xhv_max;</PRE
><P
CLASS="para"
>Ideally, we want the entries to spread out evenly around the array to keep the linked lists short. Perl's hashing algorithm does this surprisingly well for typical ASCII strings, but as we mentioned earlier, there's no guarantee that a given set of strings disperses well. So if <KBD
CLASS="command"
>xhv_keys</KBD
> exceeds <KBD
CLASS="command"
>xhv_fill</KBD
>, Perl takes it as an indication that one or more linked lists are unnecessarily long and that <KBD
CLASS="command"
>hv_fetch</KBD
> is likely to spend a considerable amount of time traversing these lists. Therefore, when such a condition occurs, Perl immediately reorganizes the hash table: the dynamic array <KBD
CLASS="command"
>xhv_array</KBD
> is doubled in size, and the entries are reindexed. Each hash entry stores its hash value, so it doesn't have to be hashed again when the table is reorganized.</P
><P
CLASS="para"
>You can get an idea of the hash efficiency by printing an associative array in a scalar context, as follows:</P
><PRE
CLASS="programlisting"
># Create a hash
for (1 .. 1000) {$h{'foo' . $_} = 1;} # Create 1000 entries
print scalar(%h);</PRE
><P
CLASS="para"
>This prints "406/1024" on my machine, which is simply a ratio of <KBD
CLASS="command"
>xhv_fill</KBD
> and <KBD
CLASS="command"
>xhv_max</KBD
>. The lower the ratio, the faster the hash access, because, on average, the linked lists are short. </P
><P
CLASS="para"
>If you know you are going to be performing a large number of insert operations on a hash, you can improve its efficiency in script space by telling it to preallocate a certain-sized dynamic array, like this:</P
><PRE
CLASS="programlisting"
>keys %h = 400; # set xhv_max</PRE
><P
CLASS="para"
>Perl rounds it up to the next higher power of two: 512.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>xhv_riter</KBD
> and <KBD
CLASS="command"
>xhv_eiter</KBD
> fields are used by the iterator functions, <KBD
CLASS="command"
>hv_iterinit</KBD
> and <KBD
CLASS="command"
>hv_iternextsv</KBD
>, and constitute a cursor over the hash entries. <KBD
CLASS="command"
>xhv_riter</KBD
> contains the current row index, and <KBD
CLASS="command"
>xhv_eiter</KBD
> contains the pointer to the current entry.</P
><P
CLASS="para"
>Most object-oriented Perl implementations use hash tables for storing object attributes, which means that all instances of a given class would typically have the same set of key strings. To prevent unnecessary duplication, the actual key strings are maintained in a systemwide <A
CLASS="indexterm"
NAME="ch20-idx-972967-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972967-1"
></A
>shared string table (<KBD
CLASS="command"
>strtab</KBD
> in <I
CLASS="filename"
>strtab.h</I
>). <KBD
CLASS="command"
>strtab</KBD
> is a simplified HV: each value here keeps a reference count of the number of uses of that string. When you say "<KBD
CLASS="command"
>$h{'foo'}</KBD
>", the string <KBD
CLASS="command"
>foo</KBD
> is first entered into <KBD
CLASS="command"
>strtab</KBD
> if it is not already present. Then the hash entry for <KBD
CLASS="command"
>$h{foo}</KBD
> is created in the HV for <KBD
CLASS="command"
>%h</KBD
>. It turns out that performance suffers very little; if there are lots of duplicates, shared storage saves time because the key is <KBD
CLASS="command"
>malloc</KBD
>'ed only once. Also, since the hash algorithm needs to be executed only once, the performance is pretty good even when there aren't too many duplicates.</P
><P
CLASS="para"
>The shared string table is used only for immutable strings (remember that hash key strings cannot be changed). User-defined SVs containing strings do not get to use this table.<A
CLASS="indexterm"
NAME="ch20-idx-972963-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972963-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972963-2"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-17700"
>20.3.4 Glob Values and Symbol Tables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-972968-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972968-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972968-2"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972968-3"
></A
>We saw in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Typeglobs and Symbol Tables"
>Chapter 3</A
> that typeglobs, also known as glob values, or GVs, connect other value types with a symbol table entry. An identifier name, such as "foo", is linked by the GV to <KBD
CLASS="command"
>$foo</KBD
>, <KBD
CLASS="command"
>@foo</KBD
>, <KBD
CLASS="command"
>%foo</KBD
>, <KBD
CLASS="command"
>&amp;foo</KBD
>, a filehandle called <KBD
CLASS="command"
>foo</KBD
>, and a format called <KBD
CLASS="command"
>foo</KBD
>. </P
><P
CLASS="para"
>GVs and symbol tables work so much in cahoots that all symbol table manipulation code is also lumped into <I
CLASS="filename"
>gv.c</I
>. Symbol tables are internally implemented as hash tables (HVs) and hence are referred to as <EM
CLASS="emphasis"
>stashes</EM
><A
CLASS="indexterm"
NAME="ch20-idx-972969-1"
></A
> (short for symbol table hash). Each package has its own stash and contains pointers to nested packages' stashes. The main stash, available from a global variable[<A
CLASS="footnote"
HREF="#ch20-pgfId-970099"
>8</A
>] called <KBD
CLASS="command"
>defstash</KBD
>, contains pointers to other "top-level" packages' stashes. <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="API for Glob Values and Stashes"
>Table 20.4</A
> shows the important functions for accessing GVs and the symbol table.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch20-pgfId-970099"
>[8]</A
> Or per-interpreter variable if MULTIPLICITY is defined.</P
></DIV
></BLOCKQUOTE
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch20-40443"
>Table 20.4: API for Glob Values and Stashes</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Function/Macro</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>GvSV, GvAV, GvHV, 
GvIO, GvFORM</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return the appropriate value pointers hanging off the GV. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>HV *gv_stashpv(
         char *name, 
         int create)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Given a package name, get the corresponding HV.</P
><P
CLASS="para"
>The names don't need the trailing "::", unlike in script space.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>HV *gv_stashsv(
    SV *, int create)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Same as above. SV* contains the name of the package.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>HV *SvSTASH (SV* sv)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Get the stash from a blessed object. If <CODE
CLASS="literal"
>sv</CODE
> is a reference, dereference it first: <KBD
CLASS="command"
>SvSTASH (SvRV(sv)).</KBD
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>char* HvNAME(HV* stash)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Given a stash, return the package name.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Standard variables in script space such as <KBD
CLASS="command"
>$_</KBD
>, <KBD
CLASS="command"
>$@</KBD
>, <KBD
CLASS="command"
>$&amp;</KBD
>, <KBD
CLASS="command"
>$`</KBD
>, and <KBD
CLASS="command"
>$'</KBD
> are available as global variables in C space: <KBD
CLASS="command"
>defgv</KBD
>, <KBD
CLASS="command"
>errgv</KBD
>, <KBD
CLASS="command"
>ampergv</KBD
>, <KBD
CLASS="command"
>leftgv</KBD
>, and <KBD
CLASS="command"
>rightgv</KBD
>, respectively. For example, if you know that <KBD
CLASS="command"
>$_</KBD
> contains a number, you can extract it in C as follows:</P
><PRE
CLASS="programlisting"
>int i = SvIV(GvSV(defgv)); /* $_ and @_ are represented by defgv */</PRE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-955982"
>20.3.4.1 Inside glob values and symbol tables</A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Glob value structure"
>Figure 20.6</A
> shows most of the interesting components of a GV. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch20-38386"
>Figure 20.6: Glob value structure</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_2006.gif"
ALT="Figure 20.6"><P
CLASS="para"
>The <KBD
CLASS="command"
>xgv_name</KBD
> field stores the name of the variable (without the prefix). The pointers to the contained values (<KBD
CLASS="command"
>$foo</KBD
>, <KBD
CLASS="command"
>@foo</KBD
>, and so on) are encapsulated in a separate structure called <KBD
CLASS="command"
>gp</KBD
> to enable fast aliasing. In the typical case in which you don't reuse the same name for different types of variables, all but one of the value pointers are <KBD
CLASS="command"
>NULL</KBD
>.</P
><P
CLASS="para"
>Symbol tables are HVs that map variable names to GVs. But aren't HVs supposed to store SVs only? Well, you may have noticed that all value types have identical- looking wrapper structures that maintain the reference count, flags, and the pointer to an internal structure. Because they are identical, you can cast an <KBD
CLASS="command"
>AV*</KBD
>, <KBD
CLASS="command"
>HV*</KBD
>, <KBD
CLASS="command"
>CV*</KBD
> to an <KBD
CLASS="command"
>SV*</KBD
> and thus fool the HV into storing anything you want. If you were to do this yourself, be careful of the HV calls that decrement the reference count of a contained "SV" (<KBD
CLASS="command"
>hv_delete</KBD
>, for example). This is because they will trigger an <KBD
CLASS="command"
>sv_free()</KBD
> if the reference count becomes 0, and if it is not an SV, you are in trouble. <A
CLASS="indexterm"
NAME="ch20-idx-972971-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972971-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-948980"
>20.3.5 Code Values</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-972973-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972973-1"
></A
>We have now finished studying all the fundamental data types used in Perl. Next we study code values, which represent subroutines, eval blocks, and format declarations. This explanation will enable you to call Perl subroutines efficiently from C and also give you a visceral understanding of how lexical variables and closures are implemented. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="API for Code Value"
>Table 20.5</A
> shows the API for CVs; there's not much you can do with CVs except call them. Except for <KBD
CLASS="command"
>perl_call_sv</KBD
>, all the other API functions accept the name of a procedure rather than the CV itself. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch20-27761"
>Table 20.5: API for Code Value</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Function/Macro</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>CV*
perl_get_cv(char *name,
            int create)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Get the CV for a given name. You should always set <KBD
CLASS="command"
>create</KBD
> to FALSE, because a TRUE value automatically creates a blank CV, which is useless to an application writer.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>int 
perl_call_sv(SV* cv,
            int flags)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Call a subroutine indicated by the <CODE
CLASS="literal"
>cv</CODE
> parameter. (Yes, you'll need to cast the CV to an SV.) It returns the number of return parameters pushed onto the stack. <CODE
CLASS="literal"
>flags</CODE
> is explained below.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>perl_call_argv(
    char *sub,
    I32  flags,
    char **argv);</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Discussed in <A
CLASS="xref"
HREF="ch19_02.htm"
TITLE="Perl API Calls for Easy Embedding"
>Table 19.1</A
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>perl_call_va (
    char *sub,
    [char *type, arg],*
    [&quot;OUT&quot;,]
    [char *type, arg,]*
);</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Discussed in <A
CLASS="xref"
HREF="ch19_02.htm"
TITLE="Perl API Calls for Easy Embedding"
>Table 19.1</A
>. We will implement this convenience function later in the section <A
CLASS="xref"
HREF="ch20_06.htm"
TITLE="Easy Embedding API"
>"Easy Embedding API</A
>."</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>int perl_call_pv (
        char* sub_name,
        int flags)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Call a subroutine by name. A thin wrapper over <KBD
CLASS="command"
>perl_call_sv</KBD
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>int perl_call_method(
       char *method_name,
      int flags)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Call a method of a class by name. The first parameter on the stack must be either an SV containing the name of the class or a blessed reference of the class.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>There are other ways of calling Perl subroutines, such as <KBD
CLASS="command"
>perl_call_argv</KBD
> and <KBD
CLASS="command"
>perl_call_va</KBD
>, which we saw in the last chapter. All these functions are wrappers around <KBD
CLASS="command"
>perl_call_sv</KBD
> and attempt to hide the messaging protocol details to some extent. The <EM
CLASS="emphasis"
>flags</EM
> parameter is a combination of any of the following bitmasks defined in <I
CLASS="filename"
>perl.h</I
>:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><KBD
CLASS="command"
>G_DISCARD</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Discards all return parameters from the function.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>G_SCALAR</KBD
>, <KBD
CLASS="command"
>G_ARRAY</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Specifies a scalar or array context, scalar being the default. The called subroutine can use <KBD
CLASS="command"
>wantarray</KBD
> to find out the caller's intention. These flags can also be used in conjunction with <KBD
CLASS="command"
>G_DISCARD</KBD
>. This is useful when you want to affect the way a function invoking <KBD
CLASS="command"
>wantarray</KBD
> works, even if you are not interested in the results.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>G_EVAL</KBD
>, <KBD
CLASS="command"
>G_KEEPERR</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Wraps an <KBD
CLASS="command"
>eval</KBD
> block around the call. <KBD
CLASS="command"
>perl_eval_sv()</KBD
> assumes this flag automatically. When an <KBD
CLASS="command"
>eval</KBD
>'d block dies, Perl assigns <KBD
CLASS="command"
>die</KBD
>'s string argument to <KBD
CLASS="command"
>errgv</KBD
> (<KBD
CLASS="command"
>$@</KBD
>) and clears all temporary variables created in that block. Perl checks to see whether any of these variables is a blessed object and, if so, calls its <KBD
CLASS="command"
>DESTROY</KBD
> routine. There's a chance that this routine might invoke <KBD
CLASS="command"
>die</KBD
> (after all, it is user-defined code). Here we have a situation in which <KBD
CLASS="command"
>errgv</KBD
> is already computed and an additional exception is thrown. Using <KBD
CLASS="command"
>G_KEEPERR</KBD
>, you instruct Perl to concatenate this new exception string to <KBD
CLASS="command"
>errgv</KBD
> instead of overwriting it.</P
></DD
></DL
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-949140"
>20.3.5.1 Inside CV</A
></H4
><P
CLASS="para"
>A CV has the same overall structure as the other value types: a generic part and a specific part. Consider the following piece of code, which defines a function in another package (by fully qualifying the name) and examines the function using Devel::Peek:</P
><PRE
CLASS="programlisting"
>package Foo;
sub main::bar {   #Introduce a function in a different package
   my $a = 10;
}
use Devel::Peek;
Dump(\&amp;main::bar);</PRE
><P
CLASS="para"
>The dump looks like this:</P
><PRE
CLASS="programlisting"
>SV = PVCV(0x774300)
  REFCNT = 2
  FLAGS = ()
  IV = 0
  NV = 0
  COMP_STASH = 0x6635f0 &quot;Foo&quot;
  START = 0x7744d0
  ROOT = 0x774650
  XSUB = 0x0
  XSUBANY = 0
  GVGV::GV = 0x66365c   &quot;main&quot; :: &quot;bar&quot;
  FILEGV = 0x660418     &quot;_&lt;foo.pl&quot;
  DEPTH = 0
  PADLIST = 0x66362c</PRE
><P
CLASS="para"
>The <KBD
CLASS="command"
>COMP_STASH</KBD
> field indicates that the "Foo" stash would be active when <KBD
CLASS="command"
>bar()</KBD
> executes, although this subroutine is defined in package <KBD
CLASS="command"
>main</KBD
>. The <KBD
CLASS="command"
>ROOT</KBD
> field indicates the root opcode of the syntax subtree for the CV, and <KBD
CLASS="command"
>START</KBD
> is the address of the opcode to get control when the function starts. The <KBD
CLASS="command"
>XSUB</KBD
> field either is NULL or contains a pointer to a C subroutine. The <KBD
CLASS="command"
>DEPTH</KBD
> field indicates the depth of recursion, and <KBD
CLASS="command"
>PADLIST</KBD
> refers to a list of <EM
CLASS="emphasis"
>scratchpads</EM
> for storing lexical variables defined inside that subroutine. More on this next.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-963171"
>20.3.5.2 How local and my work</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-972974-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972974-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972974-2"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972974-3"
></A
>Perl variables, as we are well aware, can be global, dynamic (tagged with <KBD
CLASS="command"
>local</KBD
>), or lexical (<KBD
CLASS="command"
>my</KBD
>). Global variables are accessible via the stash and the corresponding typeglob. When Perl encounters the global variable <KBD
CLASS="command"
>$a</KBD
>, it produces the opcode <KBD
CLASS="command"
>gvsv</KBD
>, which places the corresponding GV's scalar value on the stack, at run-time.</P
><P
CLASS="para"
>When Perl parses "<KBD
CLASS="command"
>local</KBD
> <KBD
CLASS="command"
>$a</KBD
>," it still outputs the same <KBD
CLASS="command"
>gvsv</KBD
> opcode, but this time it sets a special flag in that opcode to "localize" the scalar. At run-time, the corresponding opcode function <KBD
CLASS="command"
>pp_gvsv</KBD
> checks this flag and, if it is set, replaces the GV's scalar value with a new scalar value and pushes this new value onto the argument stack. Meanwhile, the old SV sits safely in something called a savestack (discussed later, in the section <A
CLASS="xref"
HREF="ch20_04.htm"
TITLE="Inside Other Stacks"
>"Inside Other Stacks</A
>"). Subsequent accesses of <KBD
CLASS="command"
>$a</KBD
> within that scope (or a nested scope) lead you, via <KBD
CLASS="command"
>a</KBD
>'s GV, to the newly allocated scalar value.</P
><P
CLASS="para"
><KBD
CLASS="command"
>my</KBD
> variables are stored and treated very differently. We mentioned earlier that each CV contains a <I
CLASS="firstterm"
>padlist</I
><A
CLASS="indexterm"
NAME="ch20-idx-972986-0"
></A
>, a list of scratchpads, as illustrated in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Inside look at my variables"
>Figure 20.7</A
>.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch20-29820"
>Figure 20.7: Inside look at my variables</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_2007.gif"
ALT="Figure 20.7"><P
CLASS="para"
>The padlist is an ordinary AV. Its 0th element points to an AV containing all lexical variable names <EM
CLASS="emphasis"
>used</EM
> within that subroutine (not just <EM
CLASS="emphasis"
>declared</EM
> within that subroutine). The names contain their prefix symbols, so <KBD
CLASS="command"
>$a</KBD
> and <KBD
CLASS="command"
>%a</KBD
> have their own unique entries. The padlist's first element points to a <I
CLASS="firstterm"
>scratchpad</I
> array (also an AV), whose elements contain the values corresponding to the lexical variables named in the 0th row. As you can see, the padlist is an alternative symbol table because it contains a logical pairing of variable names and values.</P
><P
CLASS="para"
>When the subroutine recurses, a new scratchpad is allocated for that recursion level. You'll notice that a CV requires at least three AVs (one for <KBD
CLASS="command"
>xcv_padlist</KBD
>, one for storing the names, and one or more for storing values).</P
><P
CLASS="para"
>When <A
CLASS="indexterm"
NAME="ch20-idx-972987-0"
></A
>multithreading is introduced into Perl (Version 5.005 onward), each thread will get its own scratchpad,[<A
CLASS="footnote"
HREF="#ch20-pgfId-963310"
>9</A
>] which means that lexical variables will continue to be completely private to a recursion level and thread. (Package global variables will continue to be global, of course.)</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch20-pgfId-963310"
>[9]</A
> This is according to Malcolm Beattie's current prototype patches for supporting POSIX threads.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><KBD
CLASS="command"
>my</KBD
> variables are a shade faster than <KBD
CLASS="command"
>local</KBD
> variables. The reason is that <KBD
CLASS="command"
>local</KBD
> allocates a new value at run-time to temporarily occlude the global value. In contrast, <KBD
CLASS="command"
>my</KBD
> variables are already unique to a CV, so they are typically allocated once, at parse time. The only reason to create a fresh <KBD
CLASS="command"
>my</KBD
> value is in case of recursion, which is not a typical occurrence. In future releases of Perl, multiple threads executing the same CV will also require run-time allocation of lexical variables.</P
><P
CLASS="para"
>When you access a lexical variable, Perl's code generator outputs an opcode called <KBD
CLASS="command"
>padsv</KBD
>, equivalent to <KBD
CLASS="command"
>gvsv</KBD
> (which is used for global or local variables). <KBD
CLASS="command"
>padsv</KBD
> remembers the offset of the variable inside the scratchpad (1 for <KBD
CLASS="command"
>%a</KBD
> in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Inside look at my variables"
>Figure 20.7</A
>). At run-time, Perl wastes no time at all fetching the corresponding value and pushing it on the stack.<A
CLASS="indexterm"
NAME="ch20-idx-972989-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972989-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972989-2"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972989-3"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-957759"
>20.3.5.3 Closures</A
></H4
><P
CLASS="para"
>This brief introduction to CVs and lexical variables leads us to the subject of <A
CLASS="indexterm"
NAME="ch20-idx-972991-0"
></A
>closures. When a closure is created, Perl allocates a CV, points it to the starting opcode for the subroutine, and supplies it with its own private padlist. The padlist contains pointers to all lexical variables <EM
CLASS="emphasis"
>used</EM
> by that closure, whether or not they were created within that block, as illustrated by <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Scratchpad picking up lexicals from containing CVs' scratchpads"
>Figure 20.8</A
>.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch20-26153"
>Figure 20.8: Scratchpad picking up lexicals from containing CVs' scratchpads</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_2008.gif"
ALT="Figure 20.8"><P
CLASS="para"
>For those lexicals picked up from the CV containing the closure (<KBD
CLASS="command"
>$a</KBD
> in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Scratchpad picking up lexicals from containing CVs' scratchpads"
>Figure 20.8</A
>), the scratchpad contains direct pointers to the appropriate values, and the reference count of those values is incremented. Lexicals such as <KBD
CLASS="command"
>$b</KBD
>, created within the closure, are freshly allocated. Either way, the space allocated for a lexical variable is not deallocated as long as any subroutine using it can be called.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-957760"
>20.3.5.4 Objects versus closures</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-972992-0"
></A
>In <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="Subroutine References and Closures"
>Chapter 4, <CITE
CLASS="chapter"
>Subroutine References and Closures</CITE
></A
>, we noted the similarity between objects and closures: both represent a binding between code and data. In other words, an object with three member functions can instead be represented as three closures acting on private variables borrowed from their containing environment. </P
><P
CLASS="para"
>Clearly, the closure approach is a lot more expensive in space; to represent 100 objects' worth of information, you require 300 unique closures, which works out to 900 AVs. In contrast, if you use a hash representation for storing object attributes, you need 100 hash tables and 9 AVs (three per subroutine). </P
><P
CLASS="para"
>On the other hand, calling a closure is faster than invoking an object's method. This is because a closure's variables are ready to be used as soon as the procedure is called, whereas an object's method has to dereference the object reference and then make a hash access for each attribute. The following benchmark compares the speed of an object accessor method to an equivalent closure&nbsp;- the latter approach is two to three times faster on my PC:</P
><PRE
CLASS="programlisting"
>#--------------------------------------------------------------
package OBJECT;                    # Pkg for timing object accessors
sub new {
   bless {'abc' =&gt; 10};
}
sub abc {                          # Fetch the abc attribute
    $_[0]-&gt;{'abc'};
    }
sub increment {                    # Increment the abc attribute
    $_[0]-&gt;{'abc'}++;
}
#--------------------------------------------------------------
package CLOSURE;                   # Pkg for timing closures
sub new {
  my $abc = 10;                    # member data.
  $rs_increment = sub {$abc++};    # equivalent of OBJECT::increment
  $rs_abc       = sub {$abc}  ;    # equivalent of OBJECT::abc
  ($rs_increment, $rs_abc);
}
#--------------------------------------------------------------
package main;
use Benchmark;
$a = OBJECT-&gt;new();                # Create a new object
($inc, $fetch) = CLOSURE-&gt;new();   # Create two closures
timethese(1000000, {
   Object  =&gt;  '$a-&gt;increment',    # call an object method
   Closure =&gt;  '&amp;$inc'             # call a closure
});</PRE
><P
CLASS="para"
>On my PC, this prints</P
><PRE
CLASS="programlisting"
>Benchmark: timing 1000000 iterations of Closure, Object...
   Closure: 13 secs (14.39 usr  0.00 sys = 14.39 cpu)
    Object: 45 secs (45.14 usr  0.00 sys = 45.14 cpu)<A
CLASS="indexterm"
NAME="ch20-idx-972981-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972981-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972981-2"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972981-3"
></A
></PRE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-956415"
>20.3.6 Magic Variables[<A
CLASS="footnote"
HREF="#ch20-pgfId-964958"
>10</A
>]</A
></H3
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch20-pgfId-964958"
>[10]</A
> This section can be skipped on a first reading.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-972993-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972993-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972993-2"
></A
>There are ordinary user-defined variables containing strings, numbers, and references; then there are <EM
CLASS="emphasis"
>magical</EM
> variables, those that have one or more special properties. A tied variable, for example, is magical because it contains pointers to a tied object and invokes that object's <KBD
CLASS="command"
>FETCH</KBD
> and <KBD
CLASS="command"
>STORE</KBD
> methods when read from and written to, as we saw in <A
CLASS="xref"
HREF="ch09_01.htm"
TITLE="Tie"
>Chapter 9, <CITE
CLASS="chapter"
>Tie</CITE
></A
>. Built-in variables such as <KBD
CLASS="command"
>$!</KBD
> and <KBD
CLASS="command"
>%SIG</KBD
> are also special: when <KBD
CLASS="command"
>$!</KBD
> is read from, Perl implicitly reads the C variable <KBD
CLASS="command"
>errno</KBD
>; when <KBD
CLASS="command"
>%SIG</KBD
> is written to, Perl resets the signal handler. </P
><P
CLASS="para"
>A magical scalar variable is shown in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="Magical scalar"
>Figure 20.9</A
>. It contains the normal scalar fields that you saw earlier and, in addition, points to a linked list of properties. A structure called <KBD
CLASS="command"
>MAGIC</KBD
> represents each property and provides a semblance of uniformity over the different types of properties, as we shall soon see. Let us look at this structure in some detail before we use this facility to our advantage.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch20-16201"
>Figure 20.9: Magical scalar</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_2009.gif"
ALT="Figure 20.9"><P
CLASS="para"
>A property, as seen in <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="MAGIC: Uniform interface for representing special properties"
>Figure 20.10</A
>, is an object containing a property type, a pointer to some data private to that property, and a pointer to a <I
CLASS="firstterm"
>virtual table</I
><A
CLASS="indexterm"
NAME="ch20-idx-972994-0"
></A
> (or <EM
CLASS="emphasis"
>vtbl</EM
>, a table of pointers to functions, in C++ parlance). When a variable is read from, written to, cleared, or destroyed, or if its length is accessed, Perl first updates the variable's value (the string, integer, or double fields) and then calls the accessor function responsible for the appropriate action (reading, writing, clearing, and so on; refer to <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="MAGIC: Uniform interface for representing special properties"
>Figure 20.10</A
>). If the variable has more than one property, the corresponding accessor function from each property is called, to give all of them a chance to affect the value of that variable as they please. An accessor can have side-effects too. For example, when you modify <KBD
CLASS="command"
>%SIG</KBD
>, each of its properties' <KBD
CLASS="command"
>svt_set</KBD
> function is invoked. One of these functions updates the signal handler. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch20-30593"
>Figure 20.10: MAGIC: Uniform interface for representing special properties</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_2010.gif"
ALT="Figure 20.10"><P
CLASS="para"
>Perl comes with a set of prebuilt virtual tables associated with unique <I
CLASS="firstterm"
>property types</I
><A
CLASS="indexterm"
NAME="ch20-idx-972995-0"
></A
>, which are simply unique characters. For example, the virtual table to handle tied arrays is indicated by the character "P." Please take a look at the <I
CLASS="filename"
>perlguts</I
> document if you are interested in the other built-in types. A value can have at most one property of a given type in its list. There's one property type, identified by the character <KBD
CLASS="command"
>~</KBD
>, which is a hook for an extension writer to supply a custom virtual table. Let us see how to use this particular type.</P
><P
CLASS="para"
>To attach special properties to a scalar, use the <KBD
CLASS="command"
>sv_magic</KBD
> function, like this:</P
><PRE
CLASS="programlisting"
>sv_magic(sv, obj, '~', &quot;foo&quot;, 3);</PRE
><P
CLASS="para"
>This function upgrades the scalar value to an XPVMG structure internally and tells Perl not to attach any of its predefined virtual tables (because of <KBD
CLASS="command"
>~</KBD
>). In addition, it creates one MAGIC structure and hangs it off the scalar. <KBD
CLASS="command"
>obj</KBD
> is an SV of your choice, containing user-defined data and meant for the accessor functions to distinguish between one magical variable and another. The last two parameters simply give a name to the property: an identifier string and length. Typically, you use the variable's name. </P
><P
CLASS="para"
>To access a certain property structure from a scalar, use the <KBD
CLASS="command"
>mg_find</KBD
> function:</P
><PRE
CLASS="programlisting"
>MAGIC *m = mg_find(sv(,'~'));</PRE
><P
CLASS="para"
>Let us use these two functions to create a low-level tie mechanism: call a custom function when something happens to the variable. The procedure <KBD
CLASS="command"
>foo_tie</KBD
> in the following example shows how to associate a variable <KBD
CLASS="command"
>$foo</KBD
> in Perl space to a C variable <KBD
CLASS="command"
>my_foo</KBD
>:</P
><PRE
CLASS="programlisting"
>int my_foo;  /* to be tied to $foo at script level */
int foo_get (SV *sv, MAGIC *mg)
{
    sv_setiv(sv, my_foo);   /* return my_foo's value */
    printf (&quot;GET foo =&gt; %d\n&quot;, my_foo);
    return 1; /* return value not used */
}
int foo_set (SV *sv, MAGIC *mg)
{
    my_foo = SvIV(sv);     /* set my_foo's value     */
    printf (&quot;SET foo =&gt; %d\n&quot;, my_foo);
    return 1; /* return value not used */
}
MGVTBL foo_accessors = {   /* Custom virtual table */
    foo_get, foo_set, NULL,  NULL,  NULL
};
void foo_tie () 
{
    MAGIC *m;
    /* Create a variable*/
    char *var = &quot;main::foo&quot;;
    SV *sv = perl_get_sv(var,TRUE);
    /* Upgrade the sv to a magical variable*/
    sv_magic(sv, NULL, '~', var, strlen(var));
    /* sv_magic adds a MAGIC structure (of type '~') to the SV. 
       Get it and set the virtual table pointer */
    m = mg_find(sv, '~');
    m-&gt;mg_virtual = &amp;foo_accessors;
    SvMAGICAL_on(sv);
}</PRE
><P
CLASS="para"
>Since <KBD
CLASS="command"
>foo_tie</KBD
> uses the `<KBD
CLASS="command"
>~</KBD
>' property type, Perl does not supply a prebuilt virtual table. <KBD
CLASS="command"
>foo_tie</KBD
> makes up for the omission by supplying its own custom virtual table, <KBD
CLASS="command"
>foo_accessors</KBD
>, which contains pointers to <KBD
CLASS="command"
>foo_get</KBD
> and <KBD
CLASS="command"
>foo_set</KBD
>. Note that these two functions access the integer slot of the scalar given to them. </P
><P
CLASS="para"
>The <KBD
CLASS="command"
>tie</KBD
> mechanism that is available at the scripting level is slightly more involved. It first asks the module to return an object (using TIESCALAR, TIEHASH, etc.) and uses that object as a parameter to <KBD
CLASS="command"
>sv_magic</KBD
>. Later, when the tied variable is read from, the <KBD
CLASS="command"
>sv_get</KBD
> accessor is called, which relays the call to the private object's <KBD
CLASS="command"
>FETCH</KBD
><A
CLASS="indexterm"
NAME="ch20-idx-972997-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972997-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972997-2"
></A
> method.<A
CLASS="indexterm"
NAME="ch20-idx-972932-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972932-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972932-2"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-972932-3"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_02.htm"
TITLE="20.2 Architecture"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 20.2 Architecture"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Perl Programming"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Perl Programming"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_04.htm"
TITLE="20.4 Stacks and Messaging Protocol"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 20.4 Stacks and Messaging Protocol"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>20.2 Architecture</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>20.4 Stacks and Messaging Protocol</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
