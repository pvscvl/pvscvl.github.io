<HTML
><HEAD
>
<TITLE>Object Orientation: The Next Few Steps (Advanced Perl Programming)</TITLE>
<META
NAME="DC.title"
CONTENT="Advanced Perl Programming"><META
NAME="DC.creator"
CONTENT="Sriram Srinivasan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:34:30Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-220-4"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Advanced Perl Programming"><LINK
REL="prev"
HREF="ch07_06.htm"
TITLE="7.6 Resources"><LINK
REL="next"
HREF="ch08_02.htm"
TITLE="8.2 Delegation"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Perl Programming"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Advanced Perl Programming"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_06.htm"
TITLE="7.6 Resources"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.6 Resources"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 8</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.2 Delegation"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.2 Delegation"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch08-24377"
>8. Object Orientation: The Next Few Steps</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch08-40982"
TITLE="8.1 Efficient Attribute Storage"
>Efficient Attribute Storage</A
><BR><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.2 Delegation"
>Delegation</A
><BR><A
CLASS="sect1"
HREF="ch08_03.htm"
TITLE="8.3 On Inheritance"
>On Inheritance</A
><BR><A
CLASS="sect1"
HREF="ch08_04.htm"
TITLE="8.4 Resources"
>Resources</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>No ties bind so strongly as the links of inheritance.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Stephen Jay Gould</P
></DIV
><P
CLASS="para"
>This chapter is essentially a motley collection of ideas, techniques, and opinions related to Perl objects. I have not attempted to weave these threads too closely. The topics are as follows:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Efficient attribute storage</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Search for an alternative way of representing object attributes, instead of hash tables. The two strategies examined in this chapter occupy less space and are faster.</P
></DD
><DT
CLASS="term"
>Delegation</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>How to use <KBD
CLASS="command"
>AUTOLOAD</KBD
> to automatically forward method calls.</P
></DD
><DT
CLASS="term"
>Inheritance and composition</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>What I find objectionable about inheritance, along with alternative ways of structuring classes.</P
></DD
></DL
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch08-40982"
>8.1 Efficient Attribute Storage</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-967979-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967979-1"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967979-2"
></A
>Hash tables have traditionally been used for storing object attributes. There are good reasons for doing this:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-956671"
></A
>Each attribute is self-describing (that is, the name and type of each attribute are easily obtained from the object), which makes it easy to write readable code. It also helps modules that do automatic object persistence or visualization of objects, without the object's explicit cooperation.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-956678"
></A
>Each class in an inheritance hierarchy can add attributes freely and independently.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-961783"
></A
>In fact, each <EM
CLASS="emphasis"
>instance</EM
> (not just the class) can possess a unique set of attributes and can change this set at run time. The artificial intelligence community often uses this <EM
CLASS="emphasis"
>slot-</EM
> or <EM
CLASS="emphasis"
>frame</EM
>-based approach because it adapts itself very well to new pieces of information. </P
></LI
></UL
><P
CLASS="para"
>Of course, not every problem requires this degree of generality. In addition, while Perl's hash tables are fast (within 15% of the speed of arrays) and reasonably compact (key strings are not duplicated), they are not exactly inexpensive. Creating 100 objects means that you have 100 hash tables, each of which tends to optimistically allocate extra space to accommodate future insertions. </P
><P
CLASS="para"
>This section illustrates two alternate approaches, one using arrays and another using typeglobs. Both approaches are less general than the hash table approach but are faster and leaner. The first is a module called ObjectTemplate developed for this book.[<A
CLASS="footnote"
HREF="#ch08-pgfId-966323"
>1</A
>] The other uses typeglobs and has seen limited application in some standard CPAN modules, most notably IO and Net. I hesitate to suggest this as an alternative approach because it is way too "hackish," but I present it here to enable you to understand these standard modules.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch08-pgfId-966323"
>[1]</A
> I originally posted a trial version of this approach to <EM
CLASS="emphasis"
>comp.lang.perl.misc</EM
> as a module called ClassTemplate. The version presented here is a significant improvement.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch08-39245"
>8.1.1 ObjectTemplate: Attribute Storage Using Arrays</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-967989-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967989-1"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967989-2"
></A
>module presented in this section uses arrays to store attributes (but not the array per object approach). Let us briefly see its usage before moving on to the implementation. </P
><P
CLASS="para"
>To implement the <KBD
CLASS="command"
>Employee</KBD
> class, with the attributes "name," "age," and "position," you simply inherit from ObjectTemplate, and supply a list of attribute names to a static method called <I
CLASS="function"
>attributes</I
> (exported by <KBD
CLASS="command"
>ObjectTemplate</KBD
>), as follows:</P
><PRE
CLASS="programlisting"
>package Employee;
use ObjectTemplate;                    # Import ObjectTemplate
@ISA = qw(ObjectTemplate);             # Inherit from it.
attributes qw(name age position);      # Declare your attributes</PRE
><P
CLASS="para"
>That's all. A user of this module can now create <KBD
CLASS="command"
>Employee</KBD
> objects using a dynamically generated method called <KBD
CLASS="command"
>new</KBD
> and retrieve and modify attributes using accessor methods (also created automagically):</P
><PRE
CLASS="programlisting"
>use Employee;
$obj = Employee-&gt;new(
                     &quot;name&quot; =&gt; &quot;Norma Jean&quot;,
                     &quot;age&quot;  =&gt; 25
                    );  # new() created by ObjectTemplate
$obj-&gt;position(&quot;Actress&quot;);
print $obj-&gt;name, &quot;:&quot;, $obj-&gt;age, &quot;\n&quot;;</PRE
><P
CLASS="para"
>Note that Perl permits you to omit the trailing parentheses for any method call in which there is no ambiguity about its usage. Any word following an arrow is automatically treated as a method, as in the preceding case.</P
><P
CLASS="para"
>ObjectTemplate provides the following features for an inherited class: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-964716"
></A
>An allocator function called <KBD
CLASS="command"
>new</KBD
>. This allocates an object blessed into the inherited class. <KBD
CLASS="command"
>new</KBD
> calls <KBD
CLASS="command"
>initialize</KBD
>, which in turn can be overridden in the inherited class, as explained earlier. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-964717"
></A
>Accessor methods with the same name as the attributes. These methods are created in the inherited module, and everyone, <EM
CLASS="emphasis"
>including the object's own methods</EM
>, gains access to the attributes only through these methods. This is because ObjectTemplate is the only module that knows how the attributes are stored. For example, </P
><PRE
CLASS="programlisting"
>package Employee;
sub promote {
   my $emp = shift;                          # $emp is the object
   my $current_position = $emp-&gt;position();  # Get attribute
   my $next_position    = lookup_next_position($current_position);
   $r_employee-&gt;position($next_position);    # Set attribute
}</PRE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-956860"
></A
>The user package can create its own custom accessor methods with the same naming convention as above; in this case, ObjectTemplate does not generate one automatically. If a custom accessor method wants access to the attribute managed by ObjectTemplate, it can use the <KBD
CLASS="command"
>get_attribute</KBD
> and <KBD
CLASS="command"
>set_attribute</KBD
> methods.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-956829"
></A
><KBD
CLASS="command"
>new()</KBD
> takes an initializer list, a sequence of attribute name-value pairs.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-966559"
></A
>ObjectTemplate takes attribute inheritance (<KBD
CLASS="command"
>@ISA</KBD
>) into account, for both the memory layout, and the accessors. Consider</P
><PRE
CLASS="programlisting"
>package Employee;
use ObjectTemplate;
@ISA = qw(ObjectTemplate);
attributes qw(name age);

package HourlyEmployee;
@ISA = qw(Employee);
attributes qw(hourly_wage);</PRE
><P
CLASS="para"
>In this example, an object of the <KBD
CLASS="command"
>HourlyEmployee</KBD
> class contains two inherited attributes, <KBD
CLASS="command"
>name</KBD
> and <KBD
CLASS="command"
>age</KBD
>, that all employees possess, and <KBD
CLASS="command"
>hourly_wage</KBD
>, that only hourly employees possess.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch08-pgfId-960132"
></A
>All attributes are scalar-valued, so a multivalued attribute such as <CODE
CLASS="literal"
>friends</CODE
> has to be stored as a reference:</P
><PRE
CLASS="programlisting"
>attributes qw(friends);
$obj-&gt;friends([J'Joe']); # an array reference to the accessor</PRE
><P
CLASS="para"
>This is of course true of the hash table representation also.</P
></LI
></OL
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-pgfId-960193"
>8.1.1.1 ObjectTemplate internals overview</A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="ObjectTemplate's attribute storage scheme"
>Figure 8.1</A
> shows how ObjectTemplate organizes object attributes.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch08-21796"
>Figure 8.1: ObjectTemplate's attribute storage scheme</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_0801.gif"
ALT="Figure 8.1"><P
CLASS="para"
>The data structure is quite simple. Instead of allocating one array or hash per object, ObjectTemplate creates only as many arrays as there are attributes (the columns shown in the figure). Each object is merely a "horizontal slice" across these attribute columns. When <KBD
CLASS="command"
>new()</KBD
> is called, it allocates a new logical row and inserts each element of the initializer array in the corresponding attribute column at the new row offset. The "object," therefore, is merely a blessed scalar containing that row index. This scheme is more space-efficient than the hash approach,  because it creates so few container arrays (only as many as there are attributes), and it is faster because array accesses are always a little faster than hash accesses.</P
><P
CLASS="para"
>There's a slight hitch when an object is deleted. Although the corresponding row is logically free, we can't really move up the rest of the rows below, because the other object references (which are indices) and their data will get out of sync. ObjectTemplate therefore reuses deallocated (free) rows by maintaining a per-package "free list" called <CODE
CLASS="literal"
>@_free</CODE
>. This is a linked list of all free rows with a scalar <KBD
CLASS="command"
>$_free</KBD
> pointing to the head of this list. Each element of this list contains the row index of the next free row. When an object is deleted, <KBD
CLASS="command"
>$_free</KBD
> points to that row, and the corresponding index in the free list points to the previous entry pointed to by <KBD
CLASS="command"
>$_free</KBD
>. </P
><P
CLASS="para"
>Since the freed and active rows do not overlap, we take the liberty of using one of the attribute columns (the first one) to hold <KBD
CLASS="command"
>@_free</KBD
>. This is done using typeglob aliasing. <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="ObjectTemplate's scheme for managing holes created by deleted objects"
>Figure 8.2</A
> shows a snapshot of this structure. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch08-32061"
>Figure 8.2: ObjectTemplate's scheme for managing holes created by deleted objects</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_0802.gif"
ALT="Figure 8.2"><P
CLASS="para"
>You might have noticed that I'm using the same identifier name, <KBD
CLASS="command"
>_free</KBD
>, for two variables, <KBD
CLASS="command"
>$_free</KBD
> and <KBD
CLASS="command"
>@free</KBD
>. Although I frown on this idea in general, I have used it here for two reasons. First, both are required for the same task; second, one typeglob alias gives us access to both variables in one shot. This is important for performance, as we shall see soon.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-pgfId-966729"
>8.1.1.2 ObjectTemplate implementation</A
></H4
><P
CLASS="para"
>ObjectTemplate uses objects, typeglob aliasing, symbolic references, and <KBD
CLASS="command"
>eval</KBD
> liberally, so if you understand the code below, you can consider yourself a Perl hacker! One way to pore through this code is to read the descriptions supplied in this section while using the debugger to step through a small example that uses this module. Of course, you don't <EM
CLASS="emphasis"
>have</EM
> to understand the code to use it.</P
><PRE
CLASS="programlisting"
>package ObjectTemplate;
require Exporter;
@ObjectTemplate::ISA = qw(Exporter);
@ObjectTemplate::EXPORT = qw(attributes);

my $debugging = 0; # assign 1 to it to see code generated on the fly 

# Create accessor methods, and new()
sub <B
CLASS="emphasis.bold"
>attributes</B
> {
    my ($pkg) = caller;
    @{&quot;${pkg}::_ATTRIBUTES_&quot;} = @_;
    my $code = &quot;&quot;;
    foreach my $attr (get_attribute_names($pkg)) {
        # If a field name is &quot;color&quot;, create a global array in the
        # calling package called @color
        @{&quot;${pkg}::_$attr&quot;} = ();

        # Define accessor only if it is not already present
        unless ($pkg-&gt;can(&quot;$attr&quot;)) {
            $code .= _define_accessor ($pkg, $attr);
        } 
    }
    $code .= _define_constructor($pkg);
    eval $code;
    if ($@) {
       die  &quot;ERROR defining constructor and attributes for '$pkg':&quot; 
            . &quot;\n\t$@\n&quot; 
            . &quot;-----------------------------------------------------&quot;
            . $code;
    }
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>attributes</KBD
> uses symbolic references to create a global array called <KBD
CLASS="command"
>@_ATTRIBUTES</KBD
> that remembers the attribute names. This array is then used by <KBD
CLASS="command"
>get_attribute_names</KBD
> to access all attributes defined in the current package and all its super classes. For each such attribute, <CODE
CLASS="literal"
>attributes</CODE
> creates a global array in the current package, as we saw in <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="ObjectTemplate's attribute storage scheme"
>Figure 8.1</A
>. If an accessor has not been defined for that attribute, it calls <KBD
CLASS="command"
>_define_accessor</KBD
> to generate the method dynamically. Finally, it calls <KBD
CLASS="command"
>_define_constructor</KBD
> to create the subroutine <KBD
CLASS="command"
>new</KBD
> directly into the calling package.</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>_define_accessor</B
> {
    my ($pkg, $attr) = @_;

    # This code creates an accessor method for a given
    # attribute name. This method  returns the attribute value 
    # if given no args, and modifies it if given one arg.
    # Either way, it returns the latest value of that attribute

    # qq makes this block behave like a double-quoted string
    my $code = qq{
        package $pkg;
        sub $attr {                                      # Accessor ...
            \@_ &gt; 1 ? \$_${attr} \[\${\$_[0]}] = \$_[1]  # set
                    : \$_${attr} \[\${\$_[0]}];          # get
        }
        if (!defined \$_free) {
            # Alias the first attribute column to _free
            \*_free = \*_$attr;
            \$_free = 0;
        };

    };
    $code;
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>_define_accessor</KBD
> is called for every field name given to <KBD
CLASS="command"
>attributes</KBD
> and for every attribute found in the module's superclasses. For an attribute called <KBD
CLASS="command"
>age</KBD
> in the Employee module, for example, it generates the following code:</P
><PRE
CLASS="programlisting"
>package Employee;
sub age {                                     # Accessor 
     @_ ? $_age[$$_[0]] = $_[1];              # set
        : $_age[$$_[0]];                      # get
}
if (!defined $_free) {
    *_free = *_age; # Alias the first attribute column 
                    #to _free
    $_free = 0;
};</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>$_[0]</KBD
> contains the object, and <KBD
CLASS="command"
>$_[1]</KBD
> contains the attribute value. Therefore <KBD
CLASS="command"
>$$_[0]</KBD
> contains the row index, and <KBD
CLASS="command"
>$_age[$$_[0]]</KBD
> contains the value of the age attribute of that object. In addition, <KBD
CLASS="command"
>_define_accessor</KBD
> aliases <KBD
CLASS="command"
>_free</KBD
> to <KBD
CLASS="command"
>_age</KBD
> if the aliases don't already exist. </P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>_define_constructor</B
> {
    my $pkg = shift;
    my $code = qq{
        package $pkg;
        sub new {
            my \$class = shift;
            my \$inst_id;
            if (defined(\$_free[\$_free])) {
                \$inst_id = \$_free;
                \$_free = \$_free[\$_free];
                undef \$_free[\$inst_id];
            } else {
                \$inst_id = \$_free++;
            }
            my \$obj = bless \\\$inst_id, \$class;
            \$obj-&gt;set_attributes(\@_) if \@_;
            \$obj-&gt;initialize;
            \$obj;
        }
    };
    $code;
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>_define_constructor</KBD
> generates code for a constructor called <KBD
CLASS="command"
>new</KBD
> to be installed in the calling package. <KBD
CLASS="command"
>new</KBD
> checks the free list, and if it contains rows to spare, it uses the row number from the top of that list. It then <KBD
CLASS="command"
>undef</KBD
>'s the head of the list, because the free list is aliased to the first attribute column, and we don't want that attribute's assessor picking up garbage values. If the free list does not contain any spare rows, the object is assigned the next logical index. </P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>get_attribute_names</B
> {
    my $pkg = shift;
    $pkg = ref($pkg) if ref($pkg);
    my @result = @{&quot;${pkg}::_ATTRIBUTES_&quot;};
    if (defined (@{&quot;${pkg}::ISA&quot;})) {
        foreach my $base_pkg (@{&quot;${pkg}::ISA&quot;}) {
           push (@result, get_attribute_names($base_pkg));
        }
    }
    @result;
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>get_attribute_names</KBD
> recurses through the package's <KBD
CLASS="command"
>@ISA</KBD
> array to fetch all attribute names. This can be used by anyone requiring object meta-data (such as object persistence modules).</P
><PRE
CLASS="programlisting"
># $obj-&gt;set_attributes (name =&gt; 'John', age =&gt; 23);     
# Or, $obj-&gt;set_attributes (['age'], [# sub <B
CLASS="emphasis.bold"
>set_attributes</B
> {
    my $obj = shift;
    my $attr_name;
    if (ref($_[0])) {
       my ($attr_name_list, $attr_value_list) = @_;
       my $i = 0;
       foreach $attr_name (@$attr_name_list) {
            $obj-&gt;$attr_name($attr_value_list-&gt;[$i++]);
       }
    } else {
       my ($attr_name, $attr_value);
       while (@_) {
           $attr_name = shift;
           $attr_value = shift;
           $obj-&gt;$attr_name($attr_value);
       }
    }
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>set_attributes</KBD
> is given a list of attribute name-value pairs and simply calls the accessor method for each attribute. It can also be called with two parameters; an array of names and an array of values.</P
><PRE
CLASS="programlisting"
># @attrs = $obj-&gt;get_attributes (qw(name age));
sub <B
CLASS="emphasis.bold"
>get_attributes</B
> {
    my $obj = shift;
    my (@retval);
    map $obj-&gt;${_}(), @_;
}</PRE
><P
CLASS="para"
><CODE
CLASS="literal"
>get_attributes</CODE
> uses <CODE
CLASS="literal"
>map</CODE
> to iterate through all attribute names, setting <KBD
CLASS="command"
>$_</KBD
> to each name in every iteration. The first part of <KBD
CLASS="command"
>map</KBD
> simply calls the corresponding accessor method using a symbolic reference. Because of some weird precedence issues, you cannot omit the curly braces in <KBD
CLASS="command"
>${_}</KBD
>.</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>set_attribute</B
> {
    my ($obj, $attr_name, $attr_value) = @_;
    my ($pkg) = ref($obj);
    ${&quot;${pkg}::_$attr_name&quot;}[$$obj] = $attr_value;
}

sub <B
CLASS="emphasis.bold"
>get_attribute</B
> {
    my ($obj, $attr_name, $attr_value) = @_;
    my ($pkg) = ref($obj);
    return ${&quot;${pkg}::_$attr_name&quot;}[$$obj];
}</PRE
><P
CLASS="para"
>The <KBD
CLASS="command"
>get/set_attribute</KBD
> pair updates a single attribute. Unlike the earlier pair of methods, this pair does not call an accessor; it updates the attribute directly. We saw earlier that <KBD
CLASS="command"
>attributes</KBD
> does not attempt to create accessor methods for those that already exist. But if the custom accessors still want to use the storage scheme provided by ObjectTemplate, they can use the <KBD
CLASS="command"
>get/set_attribute</KBD
> pair. The expression <KBD
CLASS="command"
>${pkg}::_$attr_name</KBD
> represents the appropriate column attribute, and <KBD
CLASS="command"
>$$obj</KBD
> represents the logical row. (Recall that the object is simply a reference to an array index.) These methods are clearly not as fast as the generated accessor methods, because they use symbolic references (which involve variable interpolation in a string and an extra hash lookup).</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>DESTROY</B
> {
    # release id back to free list
    my $obj = $_[0];
    my $pkg = ref($obj);
    local *_free = *{&quot;${pkg}::_free&quot;};
    my $inst_id = $$obj;
    # Release all the attributes in that row
    local(*attributes) = *{&quot;${pkg}::_ATTRIBUTES_&quot;};
    foreach my $attr (@attributes) {
        undef ${&quot;${pkg}::_$attr&quot;}[$inst_id];
    }
    $_free[$inst_id] = $_free;
    $_free = $inst_id;
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>DESTROY</KBD
> releases all attribute values corresponding to that object. This is necessary because the object is merely a reference to an array index, which, when freed, won't touch the reference counts of any of the attributes. A module defining its own <KBD
CLASS="command"
>DESTROY</KBD
> method must make sure that it always calls <KBD
CLASS="command"
>ObjectTemplate::DESTROY</KBD
>. </P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>initialize</B
> { }; # dummy method, if subclass doesn't define one.</PRE
><P
CLASS="para"
>Modules are expected to override this method if they want to do specific initialization, in addition to what the automatically generated <KBD
CLASS="command"
>new()</KBD
> does.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-pgfId-964885"
>8.1.1.3 Suggested changes to ObjectTemplate</A
></H4
><P
CLASS="para"
>There are (at least) two areas that could use considerable improvement. One is that <KBD
CLASS="command"
>get_attributes</KBD
> and <KBD
CLASS="command"
>set_attributes</KBD
> are slow because they always call accessor methods, even if they know which accessors are artificially provided. Because <KBD
CLASS="command"
>set_attributes</KBD
> is called by the automatically generated <KBD
CLASS="command"
>new</KBD
>, it slows down object construction dramatically. (Using this <KBD
CLASS="command"
>new</KBD
> without arguments is twice as fast as allocating an anonymous hash, but after invoking <KBD
CLASS="command"
>set_attributes</KBD
>, it is around three times slower.)</P
><P
CLASS="para"
>Second, custom accessor methods suffer in speed because they are forced to invoke the other slow pair, <KBD
CLASS="command"
>get_attribute</KBD
> and <KBD
CLASS="command"
>set_attribute</KBD
>. Possibly a better alternative is to dynamically generate accessor methods prefixed with an   "_", so that the developer can write normal accessor methods (without the prefix), and also call these private methods.</P
><P
CLASS="para"
>You might also want to check out the MethodMaker module available on CPAN, and the Class::Template module that is bundled with the standard distribution. These modules also create accessor methods automatically but assume that the object representation is a hash table. If you like the interface these modules provide, you can attempt to merge their interface with the attribute storage scheme of ObjectTemplate.<A
CLASS="indexterm"
NAME="ch08-idx-967991-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967991-1"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967991-2"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch08-33159"
>8.1.2 Attribute Storage Using Typeglobs</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-967993-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967993-1"
></A
>This approach, as we mentioned earlier, is not exactly a paragon of readability and is presented here only because it is used in some freely available libraries on CPAN, like the IO and Net distributions. If you don't wish to understand how these modules work, you can easily skip this section without loss of continuity. </P
><P
CLASS="para"
>We learned from <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Typeglobs and Symbol Tables"
>Chapter 3, <CITE
CLASS="chapter"
>Typeglobs and Symbol Tables</CITE
></A
>, that a typeglob contains pointers to different types of values. If we somehow make a typeglob into an object reference, we can treat these value pointers as attributes and access them very quickly. Consider the following <KBD
CLASS="command"
>foo</KBD
> typeglob:</P
><PRE
CLASS="programlisting"
>${*foo} = &quot;Oh, my!!&quot; ;  # Use the scalar part to store a string
@{*foo} = (10, 20);     # Use the array part to store an array
open (foo, &quot;foo.txt&quot;);  # Use it as a filehandle</PRE
><P
CLASS="para"
>We are able to hang different types of values (at most one of each type) from just one identifier, <KBD
CLASS="command"
>foo</KBD
>. If we want many such objects, we can use the Symbol module in the Perl library to create references to dynamically created typeglobs:</P
><PRE
CLASS="programlisting"
>use Symbol;
$obj = Symbol::gensym(); # ref to typeglob </PRE
><P
CLASS="para"
><KBD
CLASS="command"
>$obj</KBD
> contains a reference to a typeglob. The different parts of a typeglob can be individually accessed (by replacing <KBD
CLASS="command"
>foo</KBD
> with <KBD
CLASS="command"
>$obj</KBD
>):</P
><PRE
CLASS="programlisting"
>${*$obj} = &quot;Oh, my!!&quot; ;  # Use the scalar part to store a string
@{*$obj} = (10, 20);     # Use the array part to store an array
open ($obj, &quot;foo&quot;);      # Use it as a filehandle</PRE
><P
CLASS="para"
>Clearly, this is a hideous approach for most general objects; if you need another scalar-valued attribute, for example, you have no option but to put it in the hash part of this typeglob. The reason why the IO group of modules uses this hack is that an instance of any of these modules can be treated as a filehandle and passed directly (without dereferencing) to the built-in I/O functions such as <KBD
CLASS="command"
>read</KBD
> and <KBD
CLASS="command"
>write</KBD
>. For example:</P
><PRE
CLASS="programlisting"
>$sock = new IO::Socket( ... <CODE
CLASS="replaceable"
><I
>various parameters</I
></CODE
> ...) ;
print $sock &quot;Hello, are you there&quot;;
$message = &lt;$sock&gt;;</PRE
><P
CLASS="para"
>We'll use IO::Socket module extensively in the chapters on networking with sockets.[<A
CLASS="footnote"
HREF="#ch08-pgfId-965390"
>2</A
>] </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch08-pgfId-965390"
>[2]</A
> You don't have to know the following technique, or how the IO::Socket module is built, to use it.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Let us build a small module called File to examine this technique in greater detail. This module allows you to open a file and read the next line; in addition, it allows you to put back a line so that the next attempt to read the file returns that line:</P
><PRE
CLASS="programlisting"
>package main;
$obj = File-&gt;open(&quot;File.pm&quot;);
print $obj-&gt;next_line();
<B
CLASS="emphasis.bold"
>$obj-&gt;put_back</B
>(&quot;------------------------\n&quot;);
print $obj-&gt;next_line(); # Should print the string put back above
print $obj-&gt;next_line();</PRE
><P
CLASS="para"
>Since this code opens the File module itself, it should print the following:</P
><PRE
CLASS="programlisting"
>package File;
------------------------
use Symbol;</PRE
><P
CLASS="para"
>This module uses the scalar part of the typeglob object as a "putback" buffer, the array part of the typeglob to store all the lines read from the file, and the filehandle part of the typeglob to store the filehandle. The implementation of the File module is shown in <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="File Module, Built Using a Typeglob Representation"
>Example 8.1</A
>.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="ch08-11774"
>Example 8.1: File Module, Built Using a Typeglob Representation</A
></H4
><PRE
CLASS="programlisting"
>package File;
use Symbol;
sub open {
   my ($pkg, $filename) = @_;
   $obj = gensym();                         # Allocate a typeglob
   open ($obj, $filename) || return undef;  # Use it as a filehandle
   bless $obj, $pkg;                        # Upgrade to a File &quot;object&quot;
}

sub put_back {
   my ($r_obj, $line) = @_;
   ${*$r_obj} = $line;                      # The scalar part holds the 
}                                           # current line

sub next_line {
   my $r_obj = $_[0]; 
   my $retval;
   if (${*$r_obj}) {                        # Check putback buffer
       $retval = ${*$r_obj};                #   yep, it's got stuff
       ${*$r_obj} = &quot;&quot;;                     #   empty it.
   } else {
       $retval = &lt;$r_obj&gt;;                  #   no. read from file
       push(@{*$r_obj}, $retval);           #   add to history list.
   }
   $retval;
}<A
CLASS="indexterm"
NAME="ch08-idx-968000-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-968000-1"
></A
>
1;<A
CLASS="indexterm"
NAME="ch08-idx-967986-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967986-1"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-967986-2"
></A
></PRE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_06.htm"
TITLE="7.6 Resources"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.6 Resources"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Perl Programming"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Perl Programming"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.2 Delegation"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.2 Delegation"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>7.6 Resources</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.2 Delegation</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
