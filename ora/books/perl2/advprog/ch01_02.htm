<HTML
><HEAD
>
<TITLE>1.2 Using References (Advanced Perl Programming)</TITLE>
<META
NAME="DC.title"
CONTENT="Advanced Perl Programming"><META
NAME="DC.creator"
CONTENT="Sriram Srinivasan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:29:41Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-220-4"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Data References and Anonymous Storage"><LINK
REL="prev"
HREF="ch01_01.htm"
TITLE="1.1 Referring to Existing Variables"><LINK
REL="next"
HREF="ch01_03.htm"
TITLE="1.3 Nested Data Structures"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Perl Programming"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Advanced Perl Programming"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_01.htm"
TITLE="1.1 Referring to Existing Variables"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.1 Referring to Existing Variables"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Data References and Anonymous Storage"
>Chapter 1<BR>Data References and Anonymous Storage</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_03.htm"
TITLE="1.3 Nested Data Structures"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.3 Nested Data Structures"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch01-37692"
>1.2 Using References</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953636-0"
></A
>References are absolutely essential for creating complex data structures. Since the next chapter is devoted solely to this topic, we will not say more here. This section lists the other advantages of Perl's support for indirection and memory management.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-951019"
>1.2.1 Passing Arrays and Hashes to Subroutines</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953660-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953660-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953660-2"
></A
>When you pass more than one array or hash to a subroutine, Perl merges all of them into the <KBD
CLASS="command"
>@_</KBD
> array available within the subroutine. The only way to avoid this merger is to pass references to the input arrays or hashes. Here's an example that adds elements of one array to the corresponding elements of the other:</P
><PRE
CLASS="programlisting"
>@array1 = (1, 2, 3); @array2 = (4, 5, 6, 7);
AddArrays (\@array1, \@array2); # Passing the arrays by reference.
print &quot;@array1 \n&quot;;
    sub AddArrays 
{
        my ($rarray1, $rarray2) = @_;
        $len2 = @$rarray2;  # Length of array2
        for ($i = 0 ; $i  &lt; $len2 ;  $i++) {
            $rarray1-<KBD
CLASS="command"
>&gt;</KBD
>[$i] += $rarray2-<KBD
CLASS="command"
>&gt;</KBD
>[$i];   
        }
}</PRE
><P
CLASS="para"
>In this example, two array references are passed to <KBD
CLASS="command"
>AddArrays</KBD
> which then dereferences the two references, determines the lengths of the arrays, and adds up the individual array elements.<A
CLASS="indexterm"
NAME="ch01-idx-953666-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953666-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953666-2"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-951042"
>1.2.2 Performance Efficiency</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953668-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953668-1"
></A
>Using references, you can efficiently pass large amounts of data to and from a subroutine. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953679-0"
></A
>However, passing references to <EM
CLASS="emphasis"
>scalars</EM
> typically turns out not to be an optimization at all. I have often seen code like this, in which the programmer has intended to minimize copying while reading lines from a file:</P
><PRE
CLASS="programlisting"
>while ($ref_line = GetNextLine()) {
        .....
        .....
}
    sub GetNextLine () {
        my $line = &lt;F&gt; ;
        exit(0) unless defined($line);
        .....
        return \$line;    # Return by reference, to avoid copying
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>GetNextLine</KBD
> returns the line by reference to avoid copying.</P
><P
CLASS="para"
>You might be surprised how little an effect this strategy has on the overall performance, because most of the time is taken by reading the file and subsequently working on <KBD
CLASS="command"
>$line</KBD
>. Meanwhile, the user of <KBD
CLASS="command"
>GetNextLine</KBD
> is forced to deal with indirections (<KBD
CLASS="command"
>$$ref_line</KBD
>) instead of the more straightforward buffer <KBD
CLASS="command"
>$line</KBD
>.[<A
CLASS="footnote"
HREF="#ch01-pgfId-951796"
>4</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-951796"
>[4]</A
> The operative word here is "typically." Most applications deal with lines 60-70 bytes long. </P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Incidentally, you can use the standard library module called Benchmark to time and compare different code implementations, like this:</P
><PRE
CLASS="programlisting"
>use Benchmark;
timethis (100, &quot;GetNextLine()&quot;); # Call ProcessFile 100 times, and 
                                 # time it</PRE
><P
CLASS="para"
>The module defines a subroutine called <KBD
CLASS="command"
>timethis</KBD
> that takes a piece of code, runs it as many times as you tell it to, and prints out the elapsed time. We'll cover the <KBD
CLASS="command"
>use</KBD
> statement in <A
CLASS="xref"
HREF="ch06_01.htm"
TITLE="Modules"
>Chapter 6, <CITE
CLASS="chapter"
>Modules</CITE
></A
>.<A
CLASS="indexterm"
NAME="ch01-idx-953670-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953670-1"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-12670"
>1.2.3 References to Anonymous Storage</A
></H3
><P
CLASS="para"
>So far, we have created references to previously existing variables. Now we will learn to create references to "anonymous" data structures&nbsp;- that is, values that are not associated with a variable. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953684-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953684-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953684-2"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953684-3"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953684-4"
></A
>To create an anonymous array, use square brackets instead of parentheses:</P
><PRE
CLASS="programlisting"
>$ra = <B
CLASS="emphasis.bold"
>[ ]</B
>;         # Creates an empty, anonymous array
                   # and returns a reference to it
$ra = <B
CLASS="emphasis.bold"
>[</B
>1,&quot;hello&quot;<B
CLASS="emphasis.bold"
>]</B
>; # Creates an initialized anonymous array 
                   # and returns a reference to it</PRE
><P
CLASS="para"
>This notation not only allocates anonymous storage, it also returns a reference to it, much as <KBD
CLASS="command"
>malloc(3)</KBD
> returns a pointer in C.</P
><P
CLASS="para"
>What happens if you use <A
CLASS="indexterm"
NAME="ch01-idx-953685-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953685-1"
></A
>parentheses instead of square brackets? Recall again that Perl evaluates the right side as a comma-separated expression and returns the value of the last element; <KBD
CLASS="command"
>$ra</KBD
> contains the value "hello", which is likely not what you are looking for. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953686-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953686-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953686-2"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953686-3"
></A
>To create an anonymous hash, use braces instead of square brackets:</P
><PRE
CLASS="programlisting"
>$rh = <B
CLASS="emphasis.bold"
>{</B
> <B
CLASS="emphasis.bold"
>}</B
>;                       # Creates an empty hash and returns a
                                 # reference to it
$rh = <B
CLASS="emphasis.bold"
>{</B
>&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;<B
CLASS="emphasis.bold"
>}</B
>;  # A populated anonymous hash</PRE
><P
CLASS="para"
>Both these notations are easy to remember since they represent the bracketing characters used by the two datatypes&nbsp;- brackets for arrays and braces for hashes. Contrast this to the way you'd normally create a named hash:</P
><PRE
CLASS="programlisting"
># An ordinary hash uses the prefix and is initialized with a list
# within <B
CLASS="emphasis.bold"
>parentheses</B
>
%hash = (&quot;flock&quot; =&gt; &quot;birds&quot;, &quot;pride&quot; =&gt; &quot;lions&quot;);

# An anonymous hash is a list contained within <B
CLASS="emphasis.bold"
>curly braces</B
>. 
# The result of the expression is a scalar reference to that hash.
$rhash = {&quot;flock&quot; =&gt; &quot;birds&quot;, &quot;pride&quot; =&gt; &quot;lions&quot;};</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953687-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953687-1"
></A
>What about dynamically allocated <EM
CLASS="emphasis"
>scalars</EM
> ? It turns out that Perl doesn't have any notation for doing something like this, presumably because you almost never need it. If you really do, you can use the following trick: Create a reference to an existing variable, and then let the variable pass out of scope. </P
><PRE
CLASS="programlisting"
>{
    my $a = &quot;hello world&quot;;  # 1
    $ra = \$a;              # 2 
}
print &quot;$$ra \n&quot;;            # 3</PRE
><P
CLASS="para"
>The <KBD
CLASS="command"
>my</KBD
><A
CLASS="indexterm"
NAME="ch01-idx-953691-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953691-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953691-2"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953691-3"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953691-4"
></A
> operator tags a variable as private (or <EM
CLASS="emphasis"
>localizes</EM
> it, in Perl-speak). You can use the <KBD
CLASS="command"
>local</KBD
> operator instead, but there is a subtle yet very important difference between the two that we will clarify in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Typeglobs and Symbol Tables"
>Chapter 3</A
>. For this example, both work equally well.</P
><P
CLASS="para"
>Now, <KBD
CLASS="command"
>$ra</KBD
> is a global variable that refers to the local variable <KBD
CLASS="command"
>$a</KBD
> (not the keyword <KBD
CLASS="command"
>local</KBD
>). Normally, <KBD
CLASS="command"
>$a</KBD
> would be deleted at the end of the block, but since <KBD
CLASS="command"
>$ra</KBD
> continues to refer to it, the memory allocated for <KBD
CLASS="command"
>$a</KBD
> is not thrown away. Of course, if you reassign <KBD
CLASS="command"
>$ra</KBD
> to some other value, this space is deallocated before <KBD
CLASS="command"
>$ra</KBD
> is prepared to accept the new value.</P
><P
CLASS="para"
>You can create references to constant scalars like this: </P
><PRE
CLASS="programlisting"
>$r = \10;  $rs = \&quot;hello&quot;;</PRE
><P
CLASS="para"
>Constants are statically allocated and anonymous.<A
CLASS="indexterm"
NAME="ch01-idx-953689-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953689-1"
></A
></P
><P
CLASS="para"
>A reference variable does not care to know or remember whether it points to an anonymous value or to an existing variable's value. This is identical to the way pointers behave in C.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-21585"
>1.2.4 Dereferencing Multiple Levels of Indirection</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953692-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953692-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953692-2"
></A
>We have seen how a reference refers to some other entity, including other references (which are just ordinary scalars). This means that we can have multiple levels of references, like this:</P
><PRE
CLASS="programlisting"
>$a    = 10;
$ra   = \$a;     # reference to $a's value.
$rra  = \$ra;    # reference to a reference to $ra's value
$rrra = \$rra;   # reference to a reference to a reference ...</PRE
><P
CLASS="para"
>Now we'll dereference these. The following statements all yield the same value (that of <KBD
CLASS="command"
>$a</KBD
>):</P
><PRE
CLASS="programlisting"
>print $a;        # prints 10. The following statements print the same.
print $$ra;      # $a seen from one level of indirection. 
print $$$rra;    # replace <CODE
CLASS="replaceable"
><I
>ra</I
></CODE
> with <CODE
CLASS="replaceable"
><I
>{$rra}</I
></CODE
> : still referring
                 # to $a's value
print $$$$rrra;  # ... and so on.</PRE
><P
CLASS="para"
>Incidentally, this example illustrates a convention known to Microsoft Windows programmers as "<A
CLASS="indexterm"
NAME="ch01-idx-953696-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953696-1"
></A
>Hungarian notation."[<A
CLASS="footnote"
HREF="#ch01-pgfId-939475"
>5</A
>] Each variable name is prefixed by its type ("r" for reference, "rh" for reference to a hash, "i" for integer, "d" for double, and so on). Something like the following would immediately trigger some suspicion:<PRE
CLASS="programlisting"
>$$rh_collections[0] = 10;     # RED FLAG : 'rh' being used as an array?</PRE
>You have a variable called <KBD
CLASS="command"
>$rh_collections</KBD
>, which is presumably a reference to a hash because of its naming convention (the prefix <KBD
CLASS="command"
>rh</KBD
>), but you are using it instead as a reference to an array. Sure, Perl will alert you to this by raising a run-time exception ("Not an ARRAY reference at&nbsp;- line 2."). But it is easier to check the code while you are writing it than to painstakingly exercise all the code paths during the testing phase to rule out the possibility of run-time errors.<A
CLASS="indexterm"
NAME="ch01-idx-953694-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953694-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953694-2"
></A
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-939475"
>[5]</A
> After Charles Simonyi who started this convention at Microsoft. This convention is a topic of raging debates on the Internet; people either love it or hate it. Apparently, even at Microsoft, the systems folks use it, while the application folks don't. In a language without enforced type checking such as Perl, I recommend using it where convenient.</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-38999"
>1.2.5 A More General Rule</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953707-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953707-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953707-2"
></A
>Earlier, while discussing precedence, we showed that <KBD
CLASS="command"
>$$rarray[1]</KBD
> is actually the same as <KBD
CLASS="command"
>${$rarray}[1]</KBD
>. It wasn't entirely by accident that we chose braces to denote the grouping. It so happens that there is a more general rule. </P
><P
CLASS="para"
>The braces signify a block of code, and Perl doesn't care what you put in there as long as it yields a reference of the required type. Something like <KBD
CLASS="command"
>{$rarray}</KBD
> is a straightforward expression that yields a reference readily. By contrast, the following example calls a subroutine within the block, which in turn returns a reference:</P
><PRE
CLASS="programlisting"
>sub test {
    return <B
CLASS="emphasis.bold"
>\$a</B
>;      # returns a reference to a scalar variable
}
$a = 10;
$b = <B
CLASS="emphasis.bold"
>${test()}</B
>;      # Calls a subroutine test within the block, which 
                     # yields a reference to $a
                     # This reference is dereferenced
print $b;            # prints &quot;10&quot;</PRE
><P
CLASS="para"
>To summarize, a block that yields a reference can occur wherever the name of a variable can occur. Instead of <KBD
CLASS="command"
>$a</KBD
>, you can have <KBD
CLASS="command"
>${$ra}</KBD
> or <KBD
CLASS="command"
>${$array[1]}</KBD
> (assuming <KBD
CLASS="command"
>$array[1]</KBD
> has a reference to <KBD
CLASS="command"
>$a</KBD
>), for example. </P
><P
CLASS="para"
>Recall that a block can have any number of statements inside it, and the last expression evaluated inside that block represents its result value. Unless you want to be a serious contender for the Obfuscated Perl contest, avoid using blocks containing more than two expressions while using the general dereferencing rule stated above.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-pgfId-946047"
>1.2.5.1 Trojan horses</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953709-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953709-1"
></A
>While we are talking about obfuscation, it is worth talking about a very insidious way of including executable code within strings. Normally, when Perl sees a string such as "<KBD
CLASS="command"
>$a</KBD
>", it does variable interpolation. But you now know that "<KBD
CLASS="command"
>a</KBD
>" can be replaced by a block as long as it returns a reference to a scalar, so something like this is completely acceptable, even within a string:</P
><PRE
CLASS="programlisting"
>print &quot;<B
CLASS="emphasis.bold"
>${foo()}</B
>&quot;; </PRE
><P
CLASS="para"
>Replace <KBD
CLASS="command"
>foo()</KBD
> by <KBD
CLASS="command"
>system (</KBD
>'<KBD
CLASS="command"
>/bin/rm *</KBD
>'<KBD
CLASS="command"
>)</KBD
> and you have an unpleasant Trojan horse:</P
><PRE
CLASS="programlisting"
>print &quot;${system('/bin/rm *')}&quot; </PRE
><P
CLASS="para"
>Perl treats it like any other function and<KBD
CLASS="command"
> </KBD
>trusts <KBD
CLASS="command"
>system</KBD
> to return a reference to a scalar. The parameters given to <KBD
CLASS="command"
>system</KBD
> do their damage before Perl has a chance to figure out that <KBD
CLASS="command"
>system</KBD
> doesn't return a scalar reference. </P
><P
CLASS="para"
>Moral of the story: Be very careful of strings that you get from untrusted sources. Use the <A
CLASS="indexterm"
NAME="ch01-idx-953710-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953710-1"
></A
>taint-mode option (invoke Perl as <KBD
CLASS="command"
>perl</KBD
> <KBD
CLASS="command"
>-T</KBD
>) or the Safe module that comes with the Perl distribution. Please see the Perl documentation for taint checking, and see the index for some pointers to the Safe<A
CLASS="indexterm"
NAME="ch01-idx-953704-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953704-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953704-2"
></A
> module.<A
CLASS="indexterm"
NAME="ch01-idx-953657-0"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_01.htm"
TITLE="1.1 Referring to Existing Variables"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.1 Referring to Existing Variables"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Perl Programming"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Perl Programming"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_03.htm"
TITLE="1.3 Nested Data Structures"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.3 Nested Data Structures"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.1 Referring to Existing Variables</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.3 Nested Data Structures</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
