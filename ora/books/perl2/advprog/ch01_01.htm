<HTML
><HEAD
>
<TITLE>Data References and Anonymous Storage (Advanced Perl Programming)</TITLE>
<META
NAME="DC.title"
CONTENT="Advanced Perl Programming"><META
NAME="DC.creator"
CONTENT="Sriram Srinivasan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:29:20Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-220-4"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Advanced Perl Programming"><LINK
REL="prev"
HREF="prf1_09.htm"
TITLE="Acknowledgments"><LINK
REL="next"
HREF="ch01_02.htm"
TITLE="1.2 Using References"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Perl Programming"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Advanced Perl Programming"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="prf1_09.htm"
TITLE="Acknowledgments"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: Acknowledgments"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 1</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.2 Using References"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.2 Using References"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch01-15962"
>1. Data References and Anonymous Storage</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch01-32988"
TITLE="1.1 Referring to Existing Variables"
>Referring to Existing Variables</A
><BR><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.2 Using References"
>Using References</A
><BR><A
CLASS="sect1"
HREF="ch01_03.htm"
TITLE="1.3 Nested Data Structures"
>Nested Data Structures</A
><BR><A
CLASS="sect1"
HREF="ch01_04.htm"
TITLE="1.4 Querying a Reference"
>Querying a Reference</A
><BR><A
CLASS="sect1"
HREF="ch01_05.htm"
TITLE="1.5 Symbolic References"
>Symbolic References</A
><BR><A
CLASS="sect1"
HREF="ch01_06.htm"
TITLE="1.6 A View of the Internals"
>A View of the Internals</A
><BR><A
CLASS="sect1"
HREF="ch01_07.htm"
TITLE="1.7 References in Other Languages"
>References in Other Languages</A
><BR><A
CLASS="sect1"
HREF="ch01_08.htm"
TITLE="1.8 Resources"
>Resources</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>If I were meta-agnostic, I'd be confused over whether I'm agnostic or not&nbsp;- but I'm not quite sure if I feel that way; hence I must be meta-meta-agnostic (I guess).</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Douglas R. Hofstadter, <CITE
CLASS="citetitle"
>Gödel, Escher, Bach</CITE
></P
></DIV
><P
CLASS="para"
>There are two aspects (among many) that distinguish toy programming languages from those used to build truly complex systems. The more robust languages have:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch01-pgfId-943921"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953579-0"
></A
>The ability to dynamically allocate data structures without having to associate them with variable names. We refer to these as "anonymous" data structures.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch01-pgfId-943922"
></A
>The ability to point to any data structure, independent of whether it is allocated dynamically or statically.</P
></LI
></UL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953580-0"
></A
>COBOL is the one true exception to this; it has been a huge commercial success in spite of lacking these features. But it is also why you'd balk at developing flight control systems in COBOL.</P
><P
CLASS="para"
>Consider the following statements that describe a far simpler problem: a family tree.</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>Marge is 23 years old and is married to John, 24.</TD
></TR
><TR
><TD
CLASS="member"
>Jason, John's brother, is studying computer science at MIT. He is just 19.</TD
></TR
><TR
><TD
CLASS="member"
>Their parents, Mary and Robert, are both sixty and live in Florida.</TD
></TR
><TR
><TD
CLASS="member"
>Mary and Marge's mother, Agnes, are childhood friends.</TD
></TR
></TABLE
><P
CLASS="para"
>Do you find yourself mentally drawing a network with bubbles representing people and arrows representing relationships between them? Think of how you would conveniently represent this kind of information in your favorite programming language. If you were a C (or Algol, Pascal, or C++) programmer, you would use a dynamically allocated data structure to represent each person's data (name, age, and location) and pointers to represent relationships between people.</P
><P
CLASS="para"
>A <A
CLASS="indexterm"
NAME="ch01-idx-953581-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953581-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953581-2"
></A
>pointer is simply a variable that contains the location of some other piece of data. This location can be a machine address, as it is in C, or a higher-level entity, such as a name or an array offset.</P
><P
CLASS="para"
>C supports both aspects extremely efficiently: You use <KBD
CLASS="command"
>malloc(3)</KBD
><A
CLASS="indexterm"
NAME="ch01-idx-953582-0"
></A
>[<A
CLASS="footnote"
HREF="#ch01-pgfId-951914"
>1</A
>] to allocate memory dynamically and a pointer to refer to dynamically and statically allocated memory. While this is as efficient as it gets, you tend to spend enormous amounts of time dealing with memory management issues, carefully setting up and modifying complex interrelationships between data, and then debugging fatal errors resulting from "dangling pointers" (pointers referring to pieces of memory that have been freed or are no longer in scope). The program may be efficient; the programmer isn't.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-951914"
>[1]</A
> The number in parentheses is the Unix convention of referring to the appropriate section of the documentation (man pages). The number 3 represents the section describing the C API.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Perl supports both concepts, and quite well, too. It allows you to create anonymous data structures, and supports a fundamental data type called a "<A
CLASS="indexterm"
NAME="ch01-idx-953583-0"
></A
>reference," loosely equivalent to a C pointer. Just as C pointers can point to data as well as procedures, Perl's references can refer to conventional data types (scalars, arrays, and hashes) and other entities such as subroutines, typeglobs, and filehandles.[<A
CLASS="footnote"
HREF="#ch01-pgfId-951717"
>2</A
>] Unlike C, they don't let you peek and poke at raw memory locations.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-951717"
>[2]</A
> We'll study the latter set in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Typeglobs and Symbol Tables"
>Chapter 3, <CITE
CLASS="chapter"
>Typeglobs and Symbol Tables</CITE
></A
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Perl excels from the standpoint of programmer efficiency. As we saw earlier, you can create complex structures with very few lines of code because, unlike C, Perl doesn't expect you to spell out every thing. A line like this:</P
><PRE
CLASS="programlisting"
>$line[19] = &quot;hello&quot;;</PRE
><P
CLASS="para"
>does in one line what amounts to quite a number of lines in C&nbsp;- allocating a dynamic array of 20 elements and setting the last element to a (dynamically allocated) string. Equally important, you don't spend any time at all thinking about memory management issues. Perl ensures that a piece of data is deleted when no one is pointing at it any more (that is, it ensures that there are no memory leaks) and, conversely, that it is not deleted when someone is still pointing to it (no dangling pointers).</P
><P
CLASS="para"
>Of course, just because all this can be done does not mean that Perl is an automatic choice for implementing complex applications such as aircraft scheduling systems. However, there is no dearth of other, less complex applications (not just throwaway scripts) for which Perl can more easily be used than any other language. </P
><P
CLASS="para"
>In this chapter, you will learn the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch01-pgfId-948840"
></A
>How to create references to scalars, arrays, and hashes and how to access data through them (dereferencing).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch01-pgfId-948841"
></A
>How to create and refer to anonymous data structures.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch01-pgfId-945992"
></A
>What Perl does internally to help you avoid thinking about memory management.</P
></LI
></UL
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch01-32988"
>1.1 Referring to Existing Variables</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953584-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953584-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953584-2"
></A
>If you have a C background (not necessary for understanding this chapter), you know that there are two ways to initialize a pointer in C. You can refer to an existing variable:</P
><PRE
CLASS="programlisting"
>int a, *p;
p = &amp;a;  /* p now has the &quot;address&quot; of a */</PRE
><P
CLASS="para"
>The memory is <I
CLASS="firstterm"
>statically</I
> allocated; that is, it is allocated by the compiler. Alternatively, you can use <KBD
CLASS="command"
>malloc(3)</KBD
> to allocate a piece of memory at run-time and obtain its address:</P
><PRE
CLASS="programlisting"
>p = malloc(sizeof(int));</PRE
><P
CLASS="para"
>This dynamically allocated memory doesn't have a name (unlike that associated with a variable); it can be accessed only indirectly through the pointer, which is why we refer to it as "<A
CLASS="indexterm"
NAME="ch01-idx-953804-0"
></A
>anonymous storage."</P
><P
CLASS="para"
>Perl provides references to both statically and <A
CLASS="indexterm"
NAME="ch01-idx-953802-0"
></A
>dynamically allocated storage; in this section, we'll the study the former in some detail. That allows us to deal with the two concepts&nbsp;- references and anonymous storage&nbsp;- separately.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953590-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953590-1"
></A
>You can create a reference to an existing Perl variable by prefixing it with a backslash, like this:</P
><PRE
CLASS="programlisting"
># Create some variables
$a      = &quot;mama mia&quot;;
@array  = (10, 20);
%hash   = (&quot;laurel&quot; =&gt; &quot;hardy&quot;, &quot;nick&quot; =&gt;  &quot;nora&quot;);

# Now create references to them
$ra     = <B
CLASS="emphasis.bold"
>\$a</B
>;          # $ra now &quot;refers&quot; to (points to) $a
$rarray = <B
CLASS="emphasis.bold"
>\@array</B
>;
$rhash  = <B
CLASS="emphasis.bold"
>\%hash</B
>;    </PRE
><P
CLASS="para"
>You can create references to <A
CLASS="indexterm"
NAME="ch01-idx-953591-0"
></A
>constant scalars in a similar fashion:</P
><PRE
CLASS="programlisting"
>$ra     = \10;
$rs     = \&quot;hello world&quot;;</PRE
><P
CLASS="para"
>That's all there is to it. Since arrays and hashes are collections of scalars, it is possible to take a reference to an individual element the same way: just prefix it with a backslash:</P
><PRE
CLASS="programlisting"
>$r_array_element = \$array[1];       # Refers to the scalar $array[1]

$r_hash_element  = \$hash{&quot;laurel&quot;}; # Refers to the scalar
                                     # $hash{&quot;laurel&quot;}</PRE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-944548"
>1.1.1 A Reference Is Just Another Scalar</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953592-0"
></A
>A reference variable, such as <KBD
CLASS="command"
>$ra</KBD
> or <KBD
CLASS="command"
>$rarray</KBD
>, is an ordinary scalar&nbsp;- hence the prefix `<KBD
CLASS="command"
>$</KBD
>'. A scalar, in other words, can be a number, a string, or a reference and can be freely reassigned to one or the other of these (sub)types. If you print a scalar while it is a reference, you get something like this:</P
><PRE
CLASS="programlisting"
>SCALAR(0xb06c0)</PRE
><P
CLASS="para"
>While a string and a number have direct printed representations, a reference doesn't. So Perl prints out whatever it can: the type of the value pointed to and its memory address. There is rarely a reason to print out a reference, but if you have to, Perl supplies a reasonable default. This is one of the things that makes Perl so productive to use. <EM
CLASS="emphasis"
>Don't just sit there and complain, do something.</EM
> Perl takes this motherly advice seriously.</P
><P
CLASS="para"
>While we are on the subject, it is important that you understand what happens when references are used as keys for hashes. Perl requires hash keys to be strings, so when you use a reference as a key, Perl uses the reference's string representation (which will be unique, because it is a pointer value after all). But when you later retrieve the key from this hash, it will remain a string and will thus be unusable as a reference. It is possible that a future release of Perl may lift the restriction that hash keys have to be strings, but for the moment, the only recourse to this problem is to use the Tie::RefHash module presented in <A
CLASS="xref"
HREF="ch09_01.htm"
TITLE="Tie"
>Chapter 9, <CITE
CLASS="chapter"
>Tie</CITE
></A
>. I must add that this restriction is hardly debilitating in the larger scheme of things. There are few algorithms that require references to be used as hash keys and fewer still that cannot live with this restriction. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-23795"
>1.1.2 Dereferencing</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953593-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953593-1"
></A
>Dereferencing means getting at the value that a reference points to.</P
><P
CLASS="para"
>In C, if <KBD
CLASS="command"
>p</KBD
> is a pointer, <KBD
CLASS="command"
>*p</KBD
> refers to the value being pointed to. In Perl, if <KBD
CLASS="command"
>$r</KBD
> is a reference, then <KBD
CLASS="command"
>$$r</KBD
>, <KBD
CLASS="command"
>@$r</KBD
>, or <KBD
CLASS="command"
>%$r</KBD
> retrieves the value being referred to, depending on whether <KBD
CLASS="command"
>$r</KBD
> is pointing to a scalar, an array, or a hash. It is essential that you use the correct prefix for the corresponding type; if <KBD
CLASS="command"
>$r</KBD
> is pointing to an array, then you must use <KBD
CLASS="command"
>@$r</KBD
>, and not <KBD
CLASS="command"
>%$r</KBD
> or <KBD
CLASS="command"
>$$r</KBD
>. Using the wrong prefix results in a fatal run-time error.</P
><P
CLASS="para"
>Think of it this way: Wherever you would ordinarily use a Perl variable (<KBD
CLASS="command"
>$a</KBD
>, <KBD
CLASS="command"
>@b</KBD
>, or <KBD
CLASS="command"
>%c</KBD
>), you can replace the variable's name (<KBD
CLASS="command"
>a</KBD
>, <KBD
CLASS="command"
>b</KBD
>, or <KBD
CLASS="command"
>c</KBD
>) by a reference variable (as long as the reference is of the right type). A reference is usable in all the places where an ordinary data type can be used. The following examples show how references to different data types are dereferenced.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-943043"
>1.1.3 References to Scalars</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953602-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953602-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953602-2"
></A
>The following expressions involving a scalar, </P
><PRE
CLASS="programlisting"
>$a += 2;
print $a;          # Print $a's contents ordinarily</PRE
><P
CLASS="para"
>can be changed to use a reference by simply replacing the string "<KBD
CLASS="command"
>a</KBD
>" by the string "<KBD
CLASS="command"
>$ra</KBD
>":</P
><PRE
CLASS="programlisting"
>$ra = \$a;         # First take a reference to $a
<B
CLASS="emphasis.bold"
>$$ra</B
>  += 2;        # instead of $a += 2; 
print <B
CLASS="emphasis.bold"
>$$ra</B
>;        # instead of print $a</PRE
><P
CLASS="para"
>Of course, you must make sure that <KBD
CLASS="command"
>$ra</KBD
> is a reference pointing to a scalar; otherwise, Perl dies with the run-time error "Not a SCALAR reference". </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-936789"
>1.1.4 References to Arrays</A
></H3
><P
CLASS="para"
>You can use ordinary arrays in three ways: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch01-pgfId-943062"
></A
>Access the <EM
CLASS="emphasis"
>array as a whole</EM
>, using the <KBD
CLASS="command"
>@array</KBD
> notation. You can print an entire array or push elements into it, for example.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch01-pgfId-943063"
></A
>Access <EM
CLASS="emphasis"
>single elements</EM
> using the <KBD
CLASS="command"
>$array[$i]</KBD
> notation.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch01-pgfId-944529"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953634-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953634-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953634-2"
></A
>Access <EM
CLASS="emphasis"
>ranges of elements</EM
> (slices), using the notation <KBD
CLASS="command"
>@array[index1,index2,...]</KBD
>.</P
></LI
></UL
><P
CLASS="para"
>References to arrays are usable in all three of these situations. The following code shows an example of each, contrasting ordinary array usage to that using references to arrays:</P
><PRE
CLASS="programlisting"
>$rarray = \@array;

push (@array , &quot;a&quot;, 1, 2);   # Using the array as a whole
push (<B
CLASS="emphasis.bold"
>@$rarray</B
>, &quot;a&quot;, 1, 2);  # Indirectly using the ref. to the array

print $array[$i] ;           # Accessing single elements 
print <B
CLASS="emphasis.bold"
>$$rarray[1]</B
>;           # Indexing indirectly through a 
                             # reference:<CODE
CLASS="replaceable"
><I
> array</I
></CODE
> replaced by <CODE
CLASS="replaceable"
><I
>$rarray</I
></CODE
>

@sl =  @array[1,2,3];        # Ordinary array slice
@sl =  <B
CLASS="emphasis.bold"
>@$rarray[1,2,3]</B
>;      # Array slice using a reference
</PRE
><P
CLASS="para"
>Note that in all these cases, we have simply replaced the string <KBD
CLASS="command"
>array</KBD
> with <KBD
CLASS="command"
>$rarray</KBD
> to get the appropriate indirection. </P
><P
CLASS="para"
>Beginners often make the mistake of confusing array variables and enumerated (comma-separated) lists. For example, putting a backslash in front of an enumerated list does <EM
CLASS="emphasis"
>not</EM
> yield a reference to it:</P
><PRE
CLASS="programlisting"
>$s = \('a', 'b', 'c');      # WARNING: probably not what you think</PRE
><P
CLASS="para"
>As it happens, this is identical to</P
><PRE
CLASS="programlisting"
>$s = (\'a', \'b', \'c');    # List of references to scalars</PRE
><P
CLASS="para"
>An enumerated list always yields the last element in a scalar context (as in C), which means that <KBD
CLASS="command"
>$s</KBD
> contains a reference to the constant string <KBD
CLASS="command"
>c</KBD
>. Anonymous arrays, discussed later in the section <A
CLASS="xref"
HREF="ch01_02.htm"
TITLE="References to Anonymous Storage"
>"References to Anonymous Storage</A
>," provide the correct solution.<A
CLASS="indexterm"
NAME="ch01-idx-953605-0"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-936792"
>1.1.5 References to Hashes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953607-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953607-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953607-2"
></A
>References to hashes are equally straightforward:</P
><PRE
CLASS="programlisting"
>$rhash = \%hash;
print $hash{&quot;key1&quot;};        # Ordinary hash lookup
print <B
CLASS="emphasis.bold"
>$$rhash{&quot;key1&quot;}</B
>;      # <CODE
CLASS="replaceable"
><I
>hash</I
></CODE
> replaced by <CODE
CLASS="replaceable"
><I
>$rhash</I
></CODE
></PRE
><P
CLASS="para"
>Hash slices work the same way too:</P
><PRE
CLASS="programlisting"
>@slice = @$rhash{'key1', 'key2'}; # instead of @hash{'key1', 'key2'}</PRE
><P
CLASS="para"
>A word of advice: You must resist the temptation to implement basic data structures such as linked lists and trees just because a pointerlike capability is available. For small numbers of elements, the standard array data type has pretty decent insertion and removal performance characteristics and is far less resource intensive than linked lists built using Perl primitives. (On my machine, a small test shows that inserting up to around 1250 elements at the head of a Perl array is faster than creating an equivalent linked list.) And if you want BTrees, you should look at the Berkeley DB library (described in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Persistence Issues"
>Section 10.1, "Persistence Issues"</A
>) before rolling a Perl equivalent.<A
CLASS="indexterm"
NAME="ch01-idx-953611-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953611-1"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-23992"
>1.1.6 Confusion About Precedence</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953617-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953617-1"
></A
>The expressions involving key lookups might cause some confusion. Do you read <KBD
CLASS="command"
>$$rarray[1]</KBD
> as <KBD
CLASS="command"
>${$rarray[1]}</KBD
> or <KBD
CLASS="command"
>{$$rarray}[1]</KBD
> or <KBD
CLASS="command"
>${$rarray}[1]</KBD
>?</P
><P
CLASS="para"
>(Pause here to give your eyes time to refocus!)</P
><P
CLASS="para"
>As it happens, the last one is the correct answer. Perl follows these two simple rules while parsing such expressions: (1) Key or index lookups are done at the end, and (2) the prefix closest to a variable name binds most closely. When Perl sees something like <KBD
CLASS="command"
>$$rarray[1]</KBD
> or <KBD
CLASS="command"
>$$rhash{&quot;browns&quot;}</KBD
>, it leaves index lookups (<KBD
CLASS="command"
>[1]</KBD
> and <KBD
CLASS="command"
>{&quot;browns&quot;}</KBD
>) to the very end. That leaves <KBD
CLASS="command"
>$$rarray</KBD
> and <KBD
CLASS="command"
>$$rhash</KBD
>. It gives preference to the `<KBD
CLASS="command"
>$</KBD
>' closest to the variable name. So the precedence works out like this: <KBD
CLASS="command"
>${$rarray}</KBD
> and <KBD
CLASS="command"
>${$rhash}</KBD
>. Another way of visualizing the second rule is that the preference is given to the symbols from right to left (the variable is always to the right of a series of symbols).</P
><P
CLASS="para"
>Note that we are not really talking about operator precedence, since <KBD
CLASS="command"
>$</KBD
>, <KBD
CLASS="command"
>@ </KBD
>, and <KBD
CLASS="command"
>%</KBD
> are not operators; the rules above indicate the way an expression is parsed.<A
CLASS="indexterm"
NAME="ch01-idx-953620-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953620-1"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-951068"
>1.1.7 Shortcuts with the Arrow Notation</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953622-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953622-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953622-2"
></A
>Perl provides an alternate and easier-to-read syntax for accessing array or hash elements: the -<KBD
CLASS="command"
>&gt;</KBD
>[ ] notation. For example, given the array's reference, you can obtain the second element of the array like this:</P
><PRE
CLASS="programlisting"
>$rarray = \@array;
print <B
CLASS="emphasis.bold"
>$rarray</B
>-<KBD
CLASS="command"
>&gt;</KBD
><B
CLASS="emphasis.bold"
>[1]</B
> ;    # The &quot;visually clean&quot; way</PRE
><P
CLASS="para"
>instead of the approaches we have seen earlier:</P
><PRE
CLASS="programlisting"
>print $$rarray[1];      # Noisy, and have to think about precedence
print ${$rarray}[1];    # The way to get tendinitis!</PRE
><P
CLASS="para"
>I prefer the arrow notation, because it is less visually noisy. <A
CLASS="xref"
HREF="ch01_01.htm"
TITLE="Visualizing $rarray-&gt;[1]"
>Figure 1.1</A
> shows a way to visualize this notation. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch01-10699"
>Figure 1.1: Visualizing $rarray-&gt;[1]</A
></H4
><IMG
CLASS="graphic"
SRC="figs/wpa_0101.gif"
ALT="Figure 1.1"><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953630-0"
></A
>Similarly, you can use the -<KBD
CLASS="command"
>&gt;{ }</KBD
> notation to access an element of a hash table:</P
><PRE
CLASS="programlisting"
>$rhash = \%hash;
print <B
CLASS="emphasis.bold"
>$rhash-&gt;{&quot;k1&quot;}</B
>;    

#instead of ........
print $$rhash{&quot;k1&quot;};
# or 
print ${$rhash}{&quot;k1&quot;};</PRE
><P
CLASS="para"
>Caution: This notation works only for single indices, not for slices. Consider the following:</P
><PRE
CLASS="programlisting"
>print $rarray-<KBD
CLASS="command"
>&gt;</KBD
>[0,2]; # Warning: This is NOT an indirect array slice.</PRE
><P
CLASS="para"
>Perl treats the stuff within the brackets as a comma-separated expression that yields the last term in the array: 2. Hence, this expression is equivalent to <KBD
CLASS="command"
>$rarray</KBD
>-<KBD
CLASS="command"
>&gt;[2]</KBD
>, which is an index lookup, not a slice. (Recall the rule mentioned earlier: An enumerated or comma-separated list always returns the last element in a scalar context.)<A
CLASS="indexterm"
NAME="ch01-idx-953628-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953628-1"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-947116"
>1.1.8 No Automatic Dereferencing</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-953626-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953626-1"
></A
>Perl does not do any automatic dereferencing for you.[<A
CLASS="footnote"
HREF="#ch01-pgfId-952368"
>3</A
>] You must explicitly dereference using the constructs just described. This is similar to C, in which you have to say <KBD
CLASS="command"
>*p</KBD
> to indicate the object pointed to by <KBD
CLASS="command"
>p</KBD
>. Consider<PRE
CLASS="programlisting"
>$rarray = \@array;
push ($rarray,  1, 2, 3);   # Error: $rarray is a scalar, not an array
push (<B
CLASS="emphasis.bold"
>@$rarray</B
>, 1, 2, 3);   # OK</PRE
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-952368"
>[3]</A
> Except for filehandles, as we will see in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Typeglobs and Symbol Tables"
>Chapter 3</A
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><KBD
CLASS="command"
>push</KBD
> expects an array as the first argument, not a reference to an array (which is a scalar). Similarly, when printing an array, Perl does not automatically dereference any references. Consider<PRE
CLASS="programlisting"
>print &quot;$rarray, $rhash&quot;;</PRE
>This prints<PRE
CLASS="programlisting"
>ARRAY(0xc70858), HASH(0xb75ce8)</PRE
></P
><P
CLASS="para"
>This issue may seem benign but has ugly consequences in two cases. The first is when a reference is used in an arithmetic or conditional expression by mistake; for example, if you said <KBD
CLASS="command"
>$a</KBD
> <KBD
CLASS="command"
>+=</KBD
> <KBD
CLASS="command"
>$r</KBD
> when you really meant to say <KBD
CLASS="command"
>$a</KBD
> <KBD
CLASS="command"
>+=</KBD
> <KBD
CLASS="command"
>$$r</KBD
>, you'll get only a hard-to-track bug. The second common mistake is assigning an array to a scalar (<KBD
CLASS="command"
>$a</KBD
> <KBD
CLASS="command"
>=</KBD
> <KBD
CLASS="command"
>@array</KBD
>) instead of the array reference (<KBD
CLASS="command"
>$a</KBD
> <KBD
CLASS="command"
>=</KBD
> <KBD
CLASS="command"
>\@array</KBD
>). Perl does not warn you in either case, and Murphy's law being what it is, you will discover this problem only when you are giving a demo to a customer.<A
CLASS="indexterm"
NAME="ch01-idx-953586-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953586-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-953586-2"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="prf1_09.htm"
TITLE="Acknowledgments"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: Acknowledgments"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Perl Programming"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Perl Programming"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.2 Using References"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.2 Using References"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>Acknowledgments</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.2 Using References</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
