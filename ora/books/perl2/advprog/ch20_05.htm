<HTML
><HEAD
>
<TITLE>20.5 Meaty Extensions (Advanced Perl Programming)</TITLE>
<META
NAME="DC.title"
CONTENT="Advanced Perl Programming"><META
NAME="DC.creator"
CONTENT="Sriram Srinivasan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:42:30Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-220-4"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch20_01.htm"
TITLE="20. Perl Internals"><LINK
REL="prev"
HREF="ch20_04.htm"
TITLE="20.4 Stacks and Messaging Protocol"><LINK
REL="next"
HREF="ch20_06.htm"
TITLE="20.6 Easy Embedding API"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Perl Programming"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Advanced Perl Programming"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_04.htm"
TITLE="20.4 Stacks and Messaging Protocol"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 20.4 Stacks and Messaging Protocol"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch20_01.htm"
TITLE="20. Perl Internals"
>Chapter 20<BR>Perl Internals</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_06.htm"
TITLE="20.6 Easy Embedding API"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 20.6 Easy Embedding API"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch20-17192"
>20.5 Meaty Extensions</A
></H2
><P
CLASS="para"
>Having armed ourselves to the teeth with information, and having hand-built a few extensions, we are now ready to exploit SWIG and XS to their hilts. In this section, we'll first look at the type of code produced by XS. As it happens, SWIG produces almost identical code, so the explanation should suffice for both tools. Then we will write typemaps and snippets of code to help XS deal with C structures, to wrap C structures with Perl objects, and, finally, to interface with C++ objects. Most of this discussion is relevant to SWIG also, which is why we need study only one SWIG example. That said, take note that the specific XS typemap examples described in the following pages are solved simply and elegantly using SWIG, without the need for user-defined typemaps.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-969360"
>20.5.1 Anatomy of an XS Extension</A
></H3
><P
CLASS="para"
>To understand <A
CLASS="indexterm"
NAME="ch20-idx-973028-0"
></A
>XS typemaps, and the effect of keywords such as <KBD
CLASS="command"
>CODE</KBD
> and <KBD
CLASS="command"
>PPCODE</KBD
>, it pays to take a good look at the glue code generated by <EM
CLASS="emphasis"
>xsubpp.</EM
> Consider the following XS declaration of a module, <CODE
CLASS="literal"
>Test</CODE
>, containing a function that takes two arguments and returns an integer:</P
><PRE
CLASS="programlisting"
>MODULE = Test  PACKAGE = Test
int
func_2_args(a, b)
   int    a
   char*  b</PRE
><P
CLASS="para"
><EM
CLASS="emphasis"
>xsubpp</EM
> translates it to the following (comments in italic have been added):</P
><PRE
CLASS="programlisting"
>XS(XS_Test_func_2_args) <I
CLASS="lineannotation"
>/*  Mangled function name, with package name */</I
>
                        <I
CLASS="lineannotation"
>/* added to make it unique                                 */</I
>
{
    dXSARGS;            <I
CLASS="lineannotation"
>/* declare &quot;items&quot;, and init it with                     */</I
>
    if (items != 2)     <I
CLASS="lineannotation"
>/* the number of items on the stack                    */</I
>
        croak(&quot;Usage: Test::func_2_args(a, b)&quot;);

    {   <I
CLASS="lineannotation"
>/* Start a fresh block to allow variable declarations          */</I
>
        <I
CLASS="lineannotation"
>/* Built-in typemaps translate the stack to C variables       */</I
>
        int      a = (int)SvIV(ST(0));
        char*    b = (char *)SvPV(ST(1),na);
        <I
CLASS="lineannotation"
>/* RETVAL's type matches the function return                    */</I
> 
        int      RETVAL;

        RETVAL = func_2_args(a, b);
        ST(0)  = sv_newmortal();

        <I
CLASS="lineannotation"
>/* Outgoing typemap to translate C var. to stack                */</I
>
        sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1); <I
CLASS="lineannotation"
>/* Let Perl know one return param has been put back */</I
>
}</PRE
><P
CLASS="para"
>This is practically identical to the code we studied in the section <A
CLASS="xref"
HREF="ch20_04.htm"
TITLE="The Called Side: Hand-Coding an XSUB"
>"The Called Side: Hand-Coding an XSUB</A
>." Notice how the arguments on the stack are translated into the two arguments <KBD
CLASS="command"
>a</KBD
> and <KBD
CLASS="command"
>b</KBD
>. The XS function then calls the real C function, <KBD
CLASS="command"
>func_2_args</KBD
>, gets its return value, and packages the result back to the argument stack. </P
><P
CLASS="para"
>Let us now add some of the more common XS keywords to see how they are accommodated by <EM
CLASS="emphasis"
>xsubpp</EM
>. The XS snippet</P
><PRE
CLASS="programlisting"
>int
func_with_keywords(a, b)
    int    a
    char*  b
  PREINIT:
    double c;
  INIT:
    c = a * 20.3;
  CODE:
    if (c &gt; 50) {
        RETVAL = test(a,b,c);
    }
  OUTPUT:
    RETVAL</PRE
><P
CLASS="para"
>gets translated to this:</P
><PRE
CLASS="programlisting"
>XS(XS_Test_func_with_keywords)
{
    dXSARGS;
    if (items != 2)
        croak(&quot;Usage: Test::func_with_keywords(a, b)&quot;);
    {
        int     a = (int)   SvIV(ST(0));
        char*   b = (char *)SvPV(ST(1),na);
        double  c;                   <I
CLASS="lineannotation"
>/* PREINIT section                    */</I
>
        int     RETVAL;
        c = a * 20.3;                <I
CLASS="lineannotation"
>/* INIT section                           */</I
>
        if (c &gt; 50) {                <I
CLASS="lineannotation"
>/* CODE section                        */</I
>
            RETVAL = test(a,b,c);    <I
CLASS="lineannotation"
>/* Call any function                  */</I
>
        }
        ST(0) = sv_newmortal();      <I
CLASS="lineannotation"
>/* generated due to OUTPUT      */</I
>
        sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}</PRE
><P
CLASS="para"
>As you can see, the code supplied in <KBD
CLASS="command"
>PREINIT</KBD
> goes right after the typemaps to ensure that all declarations are complete before the main code starts. The location is important for traditional C compilers, but would not be an issue for ANSI C or C++ compilers, which allow variable declarations anywhere in a block. The <KBD
CLASS="command"
>INIT</KBD
> section is inserted before the automatically generated call to the function or, in this case, before the <KBD
CLASS="command"
>CODE</KBD
> section starts. The <KBD
CLASS="command"
>CODE</KBD
> directive allows us the flexibility of inserting any piece of code; without it, <EM
CLASS="emphasis"
>xsubpp</EM
> would have simply inserted a call to <KBD
CLASS="command"
>func_with_keywords(a,b)</KBD
>, as we saw in the prior example. </P
><P
CLASS="para"
>The <KBD
CLASS="command"
>CODE</KBD
> keyword behaves like a typical C call: you can modify input parameters, and you can return at most one parameter. To deal with a variable number of input arguments or output results, you need the <KBD
CLASS="command"
>PPCODE</KBD
> keyword. To illustrate the implementation of <KBD
CLASS="command"
>PPCODE</KBD
>, consider a C function, <KBD
CLASS="command"
>permute</KBD
>, that takes a string, computes all its permutations and returns a dynamically allocated array of strings (a null-terminated <KBD
CLASS="command"
>char**</KBD
>). Let's say that we want to access it in Perl as follows:</P
><PRE
CLASS="programlisting"
>@list = permute($str); </PRE
><P
CLASS="para"
>We use <KBD
CLASS="command"
>PPCODE</KBD
> here because the function expects to return a variable number of scalars. The following snippet of code shows the XS file:</P
><PRE
CLASS="programlisting"
>void
permute(str)
   char *     str
  PPCODE:
   int i = 0;
  
   /* Call permute. It returns a null-terminated array of strings */
   char ** ret = permute (str);

   /* Copy these parameters to mortal scalars, and push them onto 
    * the stack */
   for ( ; *ret ; ret++, ++i) {
       XPUSHs (sv_2mortal(newSVpv(*ret, 0)));
   }
   free(ret);
   XSRETURN(i);</PRE
><P
CLASS="para"
>This gets translated to the following:</P
><PRE
CLASS="programlisting"
>XS(XS_Test_permute)
{
    dXSARGS;
    if (items != 1)
        croak(&quot;Usage: Test::permute(str)&quot;);

    <I
CLASS="lineannotation"
>/* PPCODE adjusts stack pointer (CODE does not do this) */</I
>
    SP -= items;

    {
       char *  str = (char *)SvPV(ST(0),na);
       int     i   = 0;
       /* Call permute.It returns a null-terminated array of strings */

       char ** ret = permute (str);
       /* Copy these parameters to mortal scalars, and push them onto 
        * the stack */
       for ( ; *ret ; ret++, ++i) {
          XPUSHs (sv_2mortal(newSVpv(*ret, 0)));
       }
       free(ret);
       XSRETURN(i);
       PUTBACK;          <I
CLASS="lineannotation"
>/* These two statements are redundant */</I
>
       return;           <I
CLASS="lineannotation"
>/* because XSRETURN does both            */</I
>
    }
}</PRE
><P
CLASS="para"
>The <KBD
CLASS="command"
>PPCODE</KBD
> directive differs from <KBD
CLASS="command"
>CODE</KBD
> in one small but significant way: it adjusts the stack pointer SP to point to the bottom of the Perl stack frame for this function call (that is, to <KBD
CLASS="command"
>ST(0)</KBD
>), to enable us to use the <KBD
CLASS="command"
>XPUSHs</KBD
> macro to extend and push any number of arguments (recall our discussion in the section <A
CLASS="xref"
HREF="ch20_04.htm"
TITLE="Ensuring that the stack is big enough"
>"Ensuring that the stack is big enough</A
>"). We'll shortly see why we cannot do this using typemaps.<A
CLASS="indexterm"
NAME="ch20-idx-973031-0"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-965761"
>20.5.2 XS Typemaps: An Introduction</A
></H3
><P
CLASS="para"
>A <A
CLASS="indexterm"
NAME="ch20-idx-973033-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973033-1"
></A
>typemap is a snippet of code that translates a scalar value on the argument stack to a corresponding C scalar entity (int, double, pointer), or vice versa. A typemap applies only to one direction. It is important to stress here that both the input and the output for a typemap are scalars in their respective domains. You cannot have a typemap take a scalar value and return a C structure, for example; you can, however, have it return a <EM
CLASS="emphasis"
>pointer</EM
> to the structure. This is the reason why the <KBD
CLASS="command"
>permute</KBD
> example in the preceding section cannot use a typemap. We could write a typemap to convert a <KBD
CLASS="command"
>char**</KBD
> to a <EM
CLASS="emphasis"
>reference</EM
> to an array and then leave it to the script writer to dereference it. In SWIG, which doesn't support a <KBD
CLASS="command"
>PPCODE</KBD
> equivalent, this is the only option.</P
><P
CLASS="para"
>Another constraint of typemaps is that they convert one argument at a time, with blinkers on: you cannot take a decision based on multiple input arguments, as we mentioned in <A
CLASS="xref"
HREF="ch18_01.htm"
TITLE="Extending Perl:A First Course"
>Chapter 18, <CITE
CLASS="chapter"
>Extending Perl:A First Course</CITE
></A
>, ("if argument 1 is `foo', then increase argument 2 by 10"). XS offers the <KBD
CLASS="command"
>CODE</KBD
> and <KBD
CLASS="command"
>PPCODE</KBD
> directives to help you out in this situation, while SWIG doesn't. But recall from the section <A
CLASS="xref"
HREF="ch18_05.htm"
TITLE="Degrees of Freedom"
>"Degrees of Freedom"</A
> that the two SWIG restrictions mentioned are easily and efficiently taken care of in script space.</P
><P
CLASS="para"
>While <EM
CLASS="emphasis"
>xsubpp</EM
> is capable of supplying translations for ordinary C arguments, we have to write custom typemaps for all user-defined types. Assume that we have a C library with the following two functions:</P
><PRE
CLASS="programlisting"
>Car*  new_car();
void  drive(Car *);</PRE
><P
CLASS="para"
>In Perl, we want to access it as</P
><PRE
CLASS="programlisting"
>$car = Car::new_car;
Car::drive($car);</PRE
><P
CLASS="para"
>Let us first write the XS file for this problem:</P
><PRE
CLASS="programlisting"
>/* Car.XS */
#include &lt;EXTERN.h&gt;
#include &lt;perl.h&gt;
#include &lt;XSUB.h&gt;

#include &lt;Car.h&gt;  /* Don't care what Car* looks like */

MODULE = Car  PACKAGE = Car
Car *
new_car ()

void
drive (car)
   Car *   car</PRE
><P
CLASS="para"
>As you can see, we need two typemaps: an output typemap for converting a <KBD
CLASS="command"
>Car*</KBD
> to <KBD
CLASS="command"
>$car</KBD
> and an input typemap for the reverse direction. We start off by editing a typemap file called <I
CLASS="filename"
>typemap</I
>,[<A
CLASS="footnote"
HREF="#ch20-pgfId-968192"
>11</A
>] which contains three sections: <KBD
CLASS="command"
>TYPEMAP</KBD
>, <KBD
CLASS="command"
>INPUT</KBD
>, and <KBD
CLASS="command"
>OUTPUT</KBD
>, as follows:<PRE
CLASS="programlisting"
>TYPEMAP
Car *      CAR_OBJ

INPUT 
CAR_OBJ
           $var = (Car *)SvIV($arg);
OUTPUT
CAR_OBJ
           sv_setiv($arg, (I32) $var);</PRE
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch20-pgfId-968192"
>[11]</A
> We choose this particular name because the <EM
CLASS="emphasis"
>h2xs</EM
>-generated makefile recognizes it and feeds it to <EM
CLASS="emphasis"
>xsubpp</EM
>. It also allows for multiple typemap files to be picked up from different directories.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>TYPEMAP</KBD
> section creates an easy-to-use alias (<KBD
CLASS="command"
>CAR_OBJ</KBD
>, in this case) for your potentially complex C type (<KBD
CLASS="command"
>Car</KBD
> <KBD
CLASS="command"
>*</KBD
>). The <KBD
CLASS="command"
>INPUT</KBD
> and <KBD
CLASS="command"
>OUTPUT</KBD
> sections in the typemap file can now refer to this alias and contain code to transform an object of the corresponding type to a Perl value, or vice versa. When a typemap is used for a particular problem, the marker <KBD
CLASS="command"
>$arg</KBD
> is replaced by the appropriate scalar on the argument stack, and <KBD
CLASS="command"
>$var</KBD
> is replaced by the corresponding C variable name. In this example, the output typemap stuffs a <KBD
CLASS="command"
>Car*</KBD
> into the integer slot of the scalar (recall the discussion in the section <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="SVs and object pointers"
>"SVs and object pointers</A
>").</P
><P
CLASS="para"
>The advantage of the <KBD
CLASS="command"
>TYPEMAP</KBD
> section's aliases is that multiple types can be mapped to the same alias. That is, a <KBD
CLASS="command"
>Car*</KBD
> and a <KBD
CLASS="command"
>Plane*</KBD
> can both be aliased to <KBD
CLASS="command"
>VEHICLE</KBD
>, and because the <KBD
CLASS="command"
>INPUT</KBD
> and <KBD
CLASS="command"
>OUTPUT</KBD
> sections use only the alias, both types end up sharing the same translation code. The Perl distribution comes with a typemap file that supplies all the basic typemaps (see <I
CLASS="filename"
>lib/ExtUtils/typemap</I
>), and you can freely use one of the aliases defined in that file. For example, you can use the alias <KBD
CLASS="command"
>T_PTR</KBD
> (instead of <KBD
CLASS="command"
>CAR_OBJ</KBD
>) and thereby use the corresponding <KBD
CLASS="command"
>INPUT</KBD
> and <KBD
CLASS="command"
>OUTPUT</KBD
> sections for that alias. In other words, our typemap file need simply say:</P
><PRE
CLASS="programlisting"
>TYPEMAP
Car *      T_PTR</PRE
><P
CLASS="para"
>It so happens that the <KBD
CLASS="command"
>T_PTR</KBD
>'s <KBD
CLASS="command"
>INPUT</KBD
> and <KBD
CLASS="command"
>OUTPUT</KBD
> sections look identical to that shown above for <KBD
CLASS="command"
>CAR_OBJ</KBD
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-36248"
>20.5.3 Object Interface Using XS Typemaps</A
></H3
><P
CLASS="para"
>Let us say we want to give the script writer the ability to write something like the following, without changing the C library in any way:</P
><PRE
CLASS="programlisting"
>$car = Car::new_car(); # As before 
<B
CLASS="emphasis.bold"
>$car-&gt;drive()</B
>;</PRE
><P
CLASS="para"
>In other words, the <KBD
CLASS="command"
>OUTPUT</KBD
> section of our typemap needs to convert a <KBD
CLASS="command"
>Car*</KBD
> (returned by <KBD
CLASS="command"
>new_car</KBD
>) to a blessed scalar reference, as discussed in the section <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="SVs and object pointers"
>"SVs and object pointers</A
>." The <KBD
CLASS="command"
>INPUT</KBD
> section contains the inverse transformation: </P
><PRE
CLASS="programlisting"
>TYPEMAP
Car *     CAR_OBJ

OUTPUT
CAR_OBJ
       sv_setref_iv($arg, &quot;Car&quot;, (I32) $var);

INPUT
CAR_OBJ
       $var = (Car *)SvIV((SV*)SvRV($arg));</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>sv_setref_iv</KBD
> gives an integer to a freshly allocated SV and converts the first argument into a reference, points it to the new scalar, and blesses it in the appropriate module (refer to <A
CLASS="xref"
HREF="ch20_03.htm"
TITLE="API for Scalar Values"
>Table 20.1</A
>). In this example, we cast the pointer to an <KBD
CLASS="command"
>I32</KBD
>, and make the function think we are supplying an integer.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-967191"
>20.5.4 Making XS Typemaps More Generic</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-973034-0"
></A
>The typemap in the preceding example is restricted to objects of type <KBD
CLASS="command"
>Car</KBD
> only. We can use the TYPEMAP section's aliasing capability to generalize this typemap and accommodate any object pointer. Consider the following typemap, with changes highlighted:</P
><PRE
CLASS="programlisting"
>TYPEMAP
Car *     <B
CLASS="emphasis.bold"
>ANY_OBJECT</B
>

OUTPUT
<B
CLASS="emphasis.bold"
>ANY_OBJECT</B
>
     sv_setref_pv($arg, <B
CLASS="emphasis.bold"
>CLASS</B
>, (void*) $var);

INPUT
<B
CLASS="emphasis.bold"
>ANY_OBJECT</B
>
     $var = (<B
CLASS="emphasis.bold"
>$type</B
>) SvIV((SV*)SvRV($arg));</PRE
><P
CLASS="para"
>All we have done is generalize the alias, the cast, and the class name. <KBD
CLASS="command"
>$type</KBD
> is the type of the current C object (the left-hand side of the alias in the <KBD
CLASS="command"
>TYPEMAP</KBD
> section), so in this case it is <KBD
CLASS="command"
>Car*</KBD
>. Because we want to make the class name generic, we adopt the strategy used in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="Object-Oriented Programming"
>Chapter 7, <CITE
CLASS="chapter"
>Object-Oriented Programming</CITE
></A
>&nbsp;- ask the script user to use the arrow notation:</P
><PRE
CLASS="programlisting"
>$c = Car-&gt;new_car();</PRE
><P
CLASS="para"
>This invocation supplies the name of the module as the first parameter, which we capture in the <KBD
CLASS="command"
>CLASS</KBD
> argument in the XS file:</P
><PRE
CLASS="programlisting"
>Car *
new_car (<B
CLASS="emphasis.bold"
>CLASS</B
>)
    <B
CLASS="emphasis.bold"
>char *CLASS</B
></PRE
><P
CLASS="para"
>The only thing remaining is that we would like the user to say <KBD
CLASS="command"
>Car-&gt;new</KBD
> instead of <KBD
CLASS="command"
>Car-&gt;new_car</KBD
>. Just because C doesn't have polymorphism doesn't mean the script user has to suffer. The <KBD
CLASS="command"
>CODE</KBD
> keyword achieves this simply:</P
><PRE
CLASS="programlisting"
>Car *
new (CLASS)
    char *CLASS
   CODE:
     RETVAL = new_car();
   OUTPUT:
     RETVAL</PRE
><P
CLASS="para"
>The <KBD
CLASS="command"
>drive</KBD
> method doesn't need any changes. </P
><P
CLASS="para"
>Having generalized this alias, we can apply the <KBD
CLASS="command"
>ANY_OBJECT</KBD
> alias to other objects too, as long as they also follow the convention of declaring and initializing a <KBD
CLASS="command"
>CLASS</KBD
> variable in any method that returns a pointer to the type declared in the <KBD
CLASS="command"
>TYPEMAP</KBD
> section. In the preceding example, the initialization happened automatically because Perl supplies the name of the class as the first argument.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-965850"
>20.5.5 C++ Objects and XS Typemaps</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-973035-0"
></A
>Suppose you have a C++ class called <KBD
CLASS="command"
>Car</KBD
> that supports a constructor and a method called <KBD
CLASS="command"
>drive</KBD
>. You can declare the corresponding interfaces in the XS file as follows: </P
><PRE
CLASS="programlisting"
>Car *
Car::new ()

void 
Car::drive()</PRE
><P
CLASS="para"
><EM
CLASS="emphasis"
>xsubpp</EM
> translates the <KBD
CLASS="command"
>new</KBD
> declaration to an equivalent constructor call, after translating all parameters (if any):</P
><PRE
CLASS="programlisting"
>XS(XS_Car_new)
{
    dXSARGS;
    if (items != 1)
        croak(&quot;Usage: Car::new(CLASS)&quot;);
    {
        <B
CLASS="emphasis.bold"
>char *  CLASS</B
> = (char *)SvPV(ST(0),na);
        Car *   RETVAL;
        RETVAL = <B
CLASS="emphasis.bold"
>new Car</B
>();
        ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), CLASS, (void*) RETVAL);
    }
    XSRETURN(1);
}</PRE
><P
CLASS="para"
>Unlike the previous example, <EM
CLASS="emphasis"
>xsubpp</EM
> automatically supplies the <KBD
CLASS="command"
>CLASS</KBD
> variable. You still need the typemaps, however, to convert <KBD
CLASS="command"
>Car*</KBD
> to an equivalent Perl object reference. The <KBD
CLASS="command"
>drive</KBD
> interface declaration is translated as follows:</P
><PRE
CLASS="programlisting"
>XS(XS_Car_drive)
{
    dXSARGS;
    if (items != 1)
        croak(&quot;Usage: Car::drive(THIS)&quot;);
    {
        <B
CLASS="emphasis.bold"
>Car *    THIS</B
>;
        THIS = (Car *) SvIV((SV*)SvRV(ST(0)));;
        <B
CLASS="emphasis.bold"
>THIS-&gt;drive</B
>();
    }
    XSRETURN_EMPTY;
}</PRE
><P
CLASS="para"
><EM
CLASS="emphasis"
>xsubpp</EM
> automatically generates the <KBD
CLASS="command"
>THIS</KBD
> variable to refer to the object. Both <KBD
CLASS="command"
>CLASS</KBD
> and <KBD
CLASS="command"
>THIS</KBD
> can be used in a <KBD
CLASS="command"
>CODE</KBD
> section. </P
><P
CLASS="para"
>Dean Roehrich's XS Cookbooks [<A
CLASS="xref"
HREF="ch20_08.htm"
TITLE=""
>5</A
>] provide several excellent examples of XS typemaps, so be sure to look them up before you start rolling your<A
CLASS="indexterm"
NAME="ch20-idx-973042-0"
></A
> own. <A
CLASS="indexterm"
NAME="ch20-idx-973038-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973038-1"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-pgfId-965854"
>20.5.6 Memory Management Using XS</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-973044-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973044-1"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973044-2"
></A
>We have conveniently ignored the issue of memory management so far. In the preceding sections, the <KBD
CLASS="command"
>new</KBD
> function allocates an object that is subsequently stuffed into a scalar value by the typemapping code. When the scalar goes out of scope or is assigned something else, Perl ignores this pointer if the scalar has not been blessed&nbsp;- not surprising, considering that it has been led to believe that the scalar contains just an integer value. This is most definitely a memory leak. But if the scalar is blessed, Perl calls its <KBD
CLASS="command"
>DESTROY</KBD
> routine called when the scalar is cleared. If this routine is written in XS, as shown below, it gives us the opportunity to delete allocated memory:</P
><PRE
CLASS="programlisting"
>void
DESTROY(car)
    Car *car
  CODE:
    delete_car(car); /* deallocate that object */</PRE
><P
CLASS="para"
>The C++ interface is simpler:</P
><PRE
CLASS="programlisting"
>void
Car::DESTROY()</PRE
><P
CLASS="para"
>In this case, <EM
CLASS="emphasis"
>xsubpp</EM
> automatically calls "<KBD
CLASS="command"
>delete</KBD
> <KBD
CLASS="command"
>THIS</KBD
>", where <KBD
CLASS="command"
>THIS</KBD
> represents the object, as we saw earlier.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch20-pgfId-968692"
>20.5.6.1 Recommended memory allocation and deallocation routines</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-973045-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973045-1"
></A
>The Perl library provides a set of functions and macros to replace the conventional dynamic memory management routines (listed on the left-hand side of the table):</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Instead of:</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use:</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>malloc</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>New</KBD
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>free</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>Safefree</KBD
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>realloc</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>Renew</KBD
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>calloc</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>Newz</KBD
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>memcpy</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>Move</KBD
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>memmove</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>Copy</KBD
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>memzero</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>Zero</KBD
></P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The Perl replacements use the version of <CODE
CLASS="literal"
>malloc</CODE
> provided by Perl (by default), and optionally collect statistics on memory usage. It is recommended that you use these routines instead of the conventional memory management routines.<A
CLASS="indexterm"
NAME="ch20-idx-973047-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973047-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch20-40642"
>20.5.7 SWIG Typemaps</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-973049-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973049-1"
></A
>SWIG produces practically the same code as <EM
CLASS="emphasis"
>xsubpp</EM
>. Consequently, you can expect its typemaps to be very similar (if not identical) to that of XS. Consider the <KBD
CLASS="command"
>permute</KBD
> function discussed earlier. We want a <KBD
CLASS="command"
>char**</KBD
> converted to a list, but since typemaps allow their input and output to be scalars, the following typemap translates it to a list <EM
CLASS="emphasis"
>reference </EM
>:</P
><PRE
CLASS="programlisting"
>%typemap(perl5,out) char ** {   // All functions returning char ** 
                                // get this typemap
    // $source is of type char **
    // $target is of type RV (referring to an AV)
    AV *ret_av = newAV();
    int i      = 0;
    char **p   = $source;
    /* First allocate a new AV, of the right size */
    while (*p++)
        ;            /* Incr. p while *p is non-null */ 
    av_extend(ret_av, p - $source);

    /* For each element in the array of strings, create a new
     * mortalscalar, and stuff it into the above array */
    p = $source;
    for (i = 0, p = $source; *p; p++, i++ {
        av_store(ret_av, i, sv_2mortal(newSVPV(*p, 0)));
        p++;
    }
    /* Finally, create a reference to the array; the &quot;target&quot;
       of this typemap */
    $target = sv_2mortal(newRV((SV*)ret_av));
}</PRE
><P
CLASS="para"
>SWIG typemaps are specific to language, hence the <KBD
CLASS="command"
>perl5</KBD
> argument. <KBD
CLASS="command"
>out</KBD
> refers to function return parameters, and this typemap applies to <EM
CLASS="emphasis"
>all</EM
> functions with a <KBD
CLASS="command"
>char**</KBD
> return value. <KBD
CLASS="command"
>$source</KBD
> and <KBD
CLASS="command"
>$target</KBD
> are variables of the appropriate types: for an <KBD
CLASS="command"
>in</KBD
> typemap, <KBD
CLASS="command"
>$source</KBD
> is a Perl type, and <KBD
CLASS="command"
>$target</KBD
> is the data type expected by the corresponding function parameter. Note that unlike XS's <KBD
CLASS="command"
>$arg</KBD
> and <KBD
CLASS="command"
>$val</KBD
>, SWIG's <KBD
CLASS="command"
>$source</KBD
> and <KBD
CLASS="command"
>$target</KBD
> switch meanings depending on the direction of the typemap.</P
><P
CLASS="para"
>If you don't want this typemap applied to all functions returning <KBD
CLASS="command"
>char**</KBD
>'s, you can name exactly which parameter or function you want it applied to, like this:</P
><PRE
CLASS="programlisting"
>%typemap(perl5,out) char ** <B
CLASS="emphasis.bold"
>permute</B
> {
    ...
}</PRE
><P
CLASS="para"
>Please refer to the <KBD
CLASS="command"
>SWIG</KBD
> documentation for a number of other typemap-related features.<A
CLASS="indexterm"
NAME="ch20-idx-973051-0"
></A
><A
CLASS="indexterm"
NAME="ch20-idx-973051-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_04.htm"
TITLE="20.4 Stacks and Messaging Protocol"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 20.4 Stacks and Messaging Protocol"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Perl Programming"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Perl Programming"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_06.htm"
TITLE="20.6 Easy Embedding API"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 20.6 Easy Embedding API"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>20.4 Stacks and Messaging Protocol</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>20.6 Easy Embedding API</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
