<HTML
><HEAD
>
<TITLE>Networking: Implementing RPC (Advanced Perl Programming)</TITLE>
<META
NAME="DC.title"
CONTENT="Advanced Perl Programming"><META
NAME="DC.creator"
CONTENT="Sriram Srinivasan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:37:13Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-220-4"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Advanced Perl Programming"><LINK
REL="prev"
HREF="ch12_07.htm"
TITLE="12.7 Resources"><LINK
REL="next"
HREF="ch13_02.htm"
TITLE="13.2 Remote Procedure Calls (RPC)"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Perl Programming"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Advanced Perl Programming"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch12_07.htm"
TITLE="12.7 Resources"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 12.7 Resources"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 13</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch13_02.htm"
TITLE="13.2 Remote Procedure Calls (RPC)"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 13.2 Remote Procedure Calls (RPC)"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch13-14869"
>13. Networking: Implementing RPC</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch13-37076"
TITLE="13.1 Msg: Messaging Toolkit"
>Msg: Messaging Toolkit</A
><BR><A
CLASS="sect1"
HREF="ch13_02.htm"
TITLE="13.2 Remote Procedure Calls (RPC)"
>Remote Procedure Calls (RPC)</A
><BR><A
CLASS="sect1"
HREF="ch13_03.htm"
TITLE="13.3 Resources"
>Resources</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>I waited and waited and waited, and when no message came, I knew it must have been from you.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Ashleigh Brilliant</P
></DIV
><P
CLASS="para"
>In this chapter, we build on the lessons learned in the preceding chapter and implement two layers on top of sockets. The first is an asynchronous message-passing system, Msg, which takes advantage of nonblocking I/O where available. We then build a remote procedure call module, RPC, on top of the Msg substrate. RPC offers the convenience of synchronous procedure calls and accounts for exceptions, <KBD
CLASS="command"
>wantarray</KBD
>, parameter marshalling, and so on. </P
><P
CLASS="para"
>Before we proceed, let us get one basic definition out of the way. In <A
CLASS="xref"
HREF="ch12_01.htm"
TITLE="Networking with Sockets"
>Chapter 12, <CITE
CLASS="chapter"
>Networking with Sockets</CITE
></A
>, we glossed over the definition of a "<A
CLASS="indexterm"
NAME="ch13-idx-981068-0"
></A
>message." A socket connection is simply a stream of bytes and leaves it to the application to define message boundaries, so the receiver can tell when one message ends and another starts. Some protocols insert an end-of-message character, an arbitrarily chosen byte such as ASCII 4 (Ctrl-D), or a lone period on a line, and some prepend message lengths so that the receiver knows how much to expect. We use the latter option in this chapter. </P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch13-37076"
>13.1 Msg: Messaging Toolkit</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-981069-0"
></A
>In this section, we implement a module called Msg, an event-driven, client-server, messaging framework,[<A
CLASS="footnote"
HREF="#ch13-pgfId-975936"
>1</A
>] using the IO::Select and IO::Socket modules. These are its key characteristics:<DL
CLASS="variablelist"
><DT
CLASS="term"
>Queued messages</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>You can instruct Msg to either send a message right away or queue it for later delivery.</P
></DD
><DT
CLASS="term"
>Nonblocking I/O </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Msg checks to see whether your system supports POSIX and, if so, uses its nonblocking I/O support (as shown in <A
CLASS="xref"
HREF="ch12_01.htm"
TITLE="Networking with Sockets"
>Chapter 12</A
>). On systems with nonblocking I/O support but no POSIX compliance, you can inherit from Msg and override two methods to set a filehandle's blocking properties. On systems with no support at all for this facility, a send or a receive will block, but because <KBD
CLASS="command"
>select</KBD
> is used to determine a good time when messages can be sent out or received, it minimizes the chances that these calls might block (or block for long).</P
></DD
><DT
CLASS="term"
>Message boundaries</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Msg simply prepends every outgoing buffer with 4 bytes containing the message's length. The receiving side knows to expect at least 4 bytes and subsequently knows how long a message to expect.</P
></DD
><DT
CLASS="term"
>Message transparency</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Msg doesn't bother to look inside your message; this means that you have to be careful about sending binary messages to some other architecture. One simple solution is to encode all your messages in ASCII (using <KBD
CLASS="command"
>sprintf</KBD
> or <KBD
CLASS="command"
>pack</KBD
>). The RPC module, described later in this chapter, uses the FreezeThaw library to obtain a network-transparent encoding.</P
></DD
></DL
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch13-pgfId-975936"
>[1]</A
> Talk about being fully buzzword-compliant!</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The following code shows a client that uses Msg:</P
><PRE
CLASS="programlisting"
>use Msg;
$conn = Msg-&gt;connect('localhost', 8080);
die &quot;Error: Could not connect\n&quot; unless $conn;
$conn-&gt;send_now(&quot;Message $i&quot;);
($msg, $err) = $conn-&gt;rcv_now();</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>connect</KBD
><A
CLASS="indexterm"
NAME="ch13-idx-981083-0"
></A
> is a static method that creates a <EM
CLASS="emphasis"
>connection</EM
> object (one of its attributes is a socket connection). The <KBD
CLASS="command"
>send_now</KBD
> method pumps out messages on that connection, and a corresponding method called <KBD
CLASS="command"
>rcv_now</KBD
> blocks until it receives a message from the other side. We'll look at deferred (or queued) messaging shortly.</P
><P
CLASS="para"
>The following code shows a server built using Msg:</P
><PRE
CLASS="programlisting"
>use Msg;
use strict;
my $host = 'localhost';
my $port = 8080;
Msg-&gt;new_server($host, $port, \&amp;login_proc);
print &quot;Server created. Waiting for events&quot;;
Msg-&gt;event_loop();
#---------------------------------------------------------------
sub login_proc {
    # Unconditionally accept an incoming connection request
    return \&amp;rcvd_msg_from_client;
}


sub rcvd_msg_from_client {
    my ($conn, $msg, $err) = @_;
    if (defined $msg) {
        print &quot;$msg\n&quot;;
    }
}</PRE
><P
CLASS="para"
>The script calls <KBD
CLASS="command"
>new_server</KBD
> to create a listening socket (the program's network address) and then calls <KBD
CLASS="command"
>event_loop</KBD
>, an event dispatcher, which is a thin wrapper over <KBD
CLASS="command"
>select</KBD
>.</P
><P
CLASS="para"
>When a client process attempts to connect, Msg creates a local connection object and calls the login procedure supplied by you (to <KBD
CLASS="command"
>new_server</KBD
>), with the connection object as an argument. In the login procedure, you can query the remote host and port if you want and refuse a connection request by returning <KBD
CLASS="command"
>undef</KBD
>. To accept the connection, you return the reference to a subroutine (<KBD
CLASS="command"
>rcvd_msg_from_client</KBD
> in this example), which will be called on every subsequent message received on that connection. Different connections can have different receiving procedures if you so wish.</P
><P
CLASS="para"
>This is how you send or receive messages in a deferred fashion:</P
><PRE
CLASS="programlisting"
>$conn = Msg-&gt;connect($remote_host, $remote_port, \&amp;msg_from_server);
$conn-&gt;send_later($msg);
Msg-&gt;event_loop();</PRE
><P
CLASS="para"
>The <KBD
CLASS="command"
>connect</KBD
> method takes a reference to a subroutine exactly like <KBD
CLASS="command"
>new_server</KBD
>. <KBD
CLASS="command"
>event_loop</KBD
> sends queued outgoing messages when the connection becomes writable, and is responsible for dispatching incoming messages to corresponding local subroutines (deferred receive). Note that if a client wants to use deferred messages, it has to call <KBD
CLASS="command"
>event_loop</KBD
>.</P
><P
CLASS="para"
>Do you see the lines between a "client" and "server" blurring? Both have event loops (although the client requires it only for deferred messages) and respond to incoming messages. In a traditional client/server setup such as a database connection, the client initiates the conversation (<KBD
CLASS="command"
>connect</KBD
>) and asks the questions. The server never initiates a request. In a peer-peer setup, as in a telephone conversation, one process initiates the conversation, but once the connection is established, either process can send messages. Msg supports this peer-peer model.</P
><P
CLASS="para"
>Other filehandles can be incorporated into the event loop, like this:</P
><PRE
CLASS="programlisting"
>Msg-&gt;set_event_handler (\*STDIN, &quot;read&quot; =&gt; \&amp;kbd_input);</PRE
><P
CLASS="para"
>The process can now respond to keyboard events and still keep an ear out for incoming messages, or send outgoing queued messages in the "background." </P
><P
CLASS="para"
>All event-driven frameworks support <A
CLASS="indexterm"
NAME="ch13-idx-981094-0"
></A
>timer events to periodically trigger a background task. If you have a time-consuming task, you are expected to split it up into more manageable pieces and use a timer (with a 0 second time-out) to trigger the next subtask. This way, you can keep returning to the event loop after every subtask is over and get a chance to process other messages that might have trickled in since then. Since this chapter is about networking, I have not taken the trouble to add timer support to Msg. It is a rather trivial addition, because <KBD
CLASS="command"
>select</KBD
> supports a millisecond resolution time-out facility. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-36836"
>13.1.1 Msg Implementation</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-981074-0"
></A
>Msg exhibits the public interface shown in <A
CLASS="xref"
HREF="ch13_01.htm"
TITLE="Msg's Public Interface"
>Table 13.1</A
>.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch13-20036"
>Table 13.1: Msg's Public Interface</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Method</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>connect(host, port,
        [rcv_cb])</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Connects to a server at the remote host and port and returns a connection object. <KBD
CLASS="command"
>rcv_callback</KBD
> is the reference to a user-defined subroutine, which is called as follows when the remote process sends a message (at any time):</P
><PRE
CLASS="programlisting"
>    <KBD
CLASS="command"
>rcv_callback($conn, $msg, $err)</KBD
></PRE
><P
CLASS="para"
><KBD
CLASS="command"
>conn </KBD
>is the connection object, used to send messages or issue a disconnect. <KBD
CLASS="command"
>msg</KBD
> is the received message; it is <KBD
CLASS="command"
>undef</KBD
> if the connection is closed on the other side. <KBD
CLASS="command"
>(</KBD
>Msg automatically closes the connection on this side if this happens.) <KBD
CLASS="command"
>err</KBD
>, if present, contains the last error value on a <KBD
CLASS="command"
>sysread</KBD
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>$conn-&gt;send_now($msg)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sends the message right away and blocks if it needs to. If there are queued messages, it sends them first before attempting to send <CODE
CLASS="literal"
>msg</CODE
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>$conn-&gt;send_later($msg)</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Puts the message in a queue associated with the connection object and leaves it to <KBD
CLASS="command"
>event_loop</KBD
> (described later) to dispatch it when the socket becomes writable. That is, you have to call <KBD
CLASS="command"
>event_loop</KBD
> at some point; otherwise, the message never goes out.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>$conn-&gt;disconnect()</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Closes the connection.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>($msg, $err) =
    $conn-&gt;rcv_now()</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Blocks until it receives a full message. It does not call the callback function given to <KBD
CLASS="command"
>connect</KBD
>. In a scalar context, it returns only the message; otherwise it returns the error code, if any.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>new_server($thishost,
           $thisport,
           [login_proc])</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A static method that creates a listening socket at <KBD
CLASS="command"
>thishost</KBD
>, <KBD
CLASS="command"
>thisport</KBD
>. When a remote socket attempts to <CODE
CLASS="literal"
>connect</CODE
>, <KBD
CLASS="command"
>login_proc</KBD
> is called with the connection object and the connecting host and port as arguments. If <KBD
CLASS="command"
>login_proc</KBD
> returns <KBD
CLASS="command"
>undef</KBD
>, the connection is closed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>set_event_handler(
   $handle,
   [&quot;read&quot; =&gt; rd_cb],
   [&quot;write&quot; =&gt; wt_cb])</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>handle</CODE
> can be a socket, file, or pipe handle, or a derivative of IO::Handle. The callbacks are called by <KBD
CLASS="command"
>event_loop</KBD
> when the corresponding file descriptors become ready for reading or writing. A callback value of <KBD
CLASS="command"
>undef</KBD
> removes existing registered callbacks. Only one callback of a type can be registered for a given handle.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><PRE
CLASS="programlisting"
>event_loop ([count])</PRE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the select loop <CODE
CLASS="literal"
>count</CODE
> times (infinite, by default). This loop quits if no handles are registered with the event loop. Look at RPC for an example of how <CODE
CLASS="literal"
>count</CODE
> is used.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The Msg implementation is divided into four logical parts:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-978412"
></A
><EM
CLASS="emphasis"
>Send routines</EM
>. For connecting to a remote process and sending messages to it.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-978413"
></A
><EM
CLASS="emphasis"
>Receive routines</EM
>. For receiving notification when a message or a connection request comes in.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-978414"
></A
><EM
CLASS="emphasis"
>Support for nonblocking I/O</EM
>. Routines to make a socket blocking or non-blocking if the platform supports the POSIX module.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-978415"
></A
> <EM
CLASS="emphasis"
>Event loop support</EM
>. For dispatching file-related events.</P
></LI
></UL
><P
CLASS="para"
>Let's start with the send-side routines:</P
><PRE
CLASS="programlisting"
>package Msg;
use strict;
use IO::Select;
use IO::Socket;
use Carp;
use vars qw(%rd_callbacks %wt_callbacks $rd_handles $wt_handles);
%rd_callbacks = ();
%wt_callbacks = ();
$rd_handles   = IO::Select-&gt;new();
$wt_handles   = IO::Select-&gt;new();
my $blocking_supported = 0;</PRE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-pgfId-976244"
>13.1.1.1 Msg: Send-side routines</A
></H4
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>connect</B
> {
    my ($pkg, $to_host, $to_port,$rcvd_notification_proc) = @_;  
    # Create a new internet socket
    my $sock = IO::Socket::INET-&gt;new (
                                      PeerAddr =&gt; $to_host,
                                      PeerPort =&gt; $to_port,
                                      Proto    =&gt; 'tcp');

    return undef unless $sock;
    # Create a connection end-point object
    my $conn = bless {
        sock                   =&gt; $sock,
        rcvd_notification_proc =&gt; $rcvd_notification_proc,
    }, $pkg;
    
    if ($rcvd_notification_proc) {
        # Bundle _rcv and $conn together in a closure 
        my $callback = sub {_rcv($conn)}; 
        set_event_handler ($sock, &quot;read&quot; =&gt; $callback);
    }
    $conn;
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>connect</KBD
> sets up a client socket and creates the connection object mentioned earlier. The connection object is a communications endpoint and has the following attributes:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>sock</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The socket connection</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>rcvd_notification_proc</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A callback function to call on receipt of a message</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>queue</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A reference to a list of buffered messages</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>send_offset</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>In nonblocking mode, Msg allows partial writes. If the socket blocks, we note down how much of the topmost message in the queue we have already sent. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>msg</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>In nonblocking mode, <CODE
CLASS="literal"
>msg</CODE
> contains a partial incoming message...</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>bytes_to_read</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>....and <CODE
CLASS="literal"
>bytes_to_read</CODE
> contains the bytes still expected.</P
></DD
></DL
><P
CLASS="para"
>Once the connection is established, each side can use its local connection object to talk to the other side. </P
><P
CLASS="para"
>If the user specifies a <A
CLASS="indexterm"
NAME="ch13-idx-981095-0"
></A
>callback (<KBD
CLASS="command"
>$rcvd_notification_proc</KBD
>), we set up our event handler to call a private routine <KBD
CLASS="command"
>_rcv</KBD
>, which in turn calls this callback when an entire message has been received: </P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>disconnect</B
> {
    my $conn = shift;
    my $sock = delete $conn-&gt;{sock};
    return unless defined($sock);
    set_event_handler ($sock, &quot;read&quot; =&gt; undef, &quot;write&quot; =&gt; undef);
    close($sock); undef $!; # Should ideally process errors from close
}

sub <B
CLASS="emphasis.bold"
>send_now</B
> {
    my ($conn, $msg) = @_;
    _enqueue ($conn, $msg);
    $conn-&gt;_send (1); # 1 ==&gt; flush
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>send_now</KBD
> enqueues the message and tells <KBD
CLASS="command"
>_send</KBD
> to flush this message and other previous messages hanging around in the queue, if any. </P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>send_later</B
> {
    my ($conn, $msg) = @_;
    _enqueue($conn, $msg);
    my $sock = $conn-&gt;{sock};
    return unless defined($sock);
    set_event_handler ($sock, &quot;write&quot; =&gt; sub {$conn-&gt;_send(0)});
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>send_later</KBD
> enqueues the message and registers a "write" callback. This is invoked later on when <KBD
CLASS="command"
>event_loop</KBD
> is called, and the file descriptor is writable.</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>_enqueue</B
> {
    my ($conn, $msg) = @_;
    # prepend length (encoded as network long)
    my $len = length($msg);
    $msg = pack ('N', $len) . $msg; 
    push (@{$conn-&gt;{queue}}, $msg);
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>_enqueue</KBD
> prepends each message with a length and pushes it into a queue associated with the connection. The length is encoded as a "network-independent long" (a 32-bit number) so that the receiving side knows to read exactly four bytes to obtain this length. As was mentioned earlier, the message itself is assumed to be independent of byte-ordering issues.</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>_send</B
> {
    my ($conn, $flush) = @_;
    my $sock = $conn-&gt;{sock};
    return unless defined($sock);
    my ($rq) = $conn-&gt;{queue};   # rq -&gt; ref. to queue.

    # If $flush is set, set the socket to blocking, and send all
    # messages in the queue - return only if there's an error
    # If $flush is 0 (deferred mode) make the socket non-blocking, and
    # return to the event loop only after every message, or if it
    # is likely to block in the middle of a message.

    $flush ? $conn-&gt;set_blocking() : $conn-&gt;set_non_blocking();
    my $offset = (exists $conn-&gt;{send_offset}) ? $conn-&gt;{send_offset} : 0;
    while (@$rq) {
        my $msg            = $rq-&gt;[0];
        my $bytes_to_write = length($msg) - $offset;
        my $bytes_written  = 0;
        while ($bytes_to_write) {
            $bytes_written = syswrite ($sock, $msg,
                                       $bytes_to_write, $offset);
            if (!defined($bytes_written)) {
                if (_err_will_block($!)) {
                    # Should happen only in deferred mode. Record how
                    # much we have already sent.
                    $conn-&gt;{send_offset} = $offset;
                    # Event handler should already be set, so we will
                    # be called back eventually, and will resume sending
                    return 1;
                } else {    # Uh, oh
                    $conn-&gt;handle_send_err($!);
                    return 0; # fail. Message remains in queue ..
                }
            }
            $offset         += $bytes_written;
            $bytes_to_write -= $bytes_written;
        }
        delete $conn-&gt;{send_offset};
        $offset = 0;
        shift @$rq;
        last unless $flush; # Go back to select and wait 
                            # for it to fire again.
    }
    # Call me back if queue has not been drained.
    if (@$rq) {
        set_event_handler ($sock, &quot;write&quot; =&gt; sub {$conn-&gt;_send(0)});
    } else {
        set_event_handler ($sock, &quot;write&quot; =&gt; undef);
    }
    1;  # Success
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>_send</KBD
> does the real work of sending the message and is called either directly from <KBD
CLASS="command"
>send_now</KBD
> or as a callback from the event loop. If called from <KBD
CLASS="command"
>send_now</KBD
>, it sets the socket to blocking mode and flushes all messages in the queue. If called from the event loop, it sets the socket to nonblocking mode and flushes at most one message at a time before returning to the event loop. This way, other connections get their share of time. If <KBD
CLASS="command"
>syswrite</KBD
> says it will block, <KBD
CLASS="command"
>_send</KBD
> notes down how much of the message has already been sent (in the <KBD
CLASS="command"
>send_offset</KBD
> attribute) and returns to the event loop. In all cases, it accounts for the fact that <KBD
CLASS="command"
>syswrite</KBD
> might write only a part of the buffer. </P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>handle_send_err</B
> {
   # For more meaningful handling of send errors, subclass Msg and
   # rebless $conn.  
   my ($conn, $err_msg) = @_;
   warn &quot;Error while sending: $err_msg \n&quot;;
   set_event_handler ($conn-&gt;{sock}, &quot;write&quot; =&gt; undef);
}</PRE
><P
CLASS="para"
>This is a wishy-washy error-handling procedure that doesn't do anything other than turn off the event loop notification. It does not touch the connection object in any way, so you can potentially resume from where you left off. To do this, you must override this method in an inherited class (look at the RPC module described later, for an example).</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-pgfId-976484"
>13.1.1.2 Msg: Receive-side routines</A
></H4
><P
CLASS="para"
>The procedures in this section implement the listening side: </P
><PRE
CLASS="programlisting"
>my ($g_login_proc, $g_pkg); # The prefix g_ stands for global
my $main_socket = 0;
sub <B
CLASS="emphasis.bold"
>new_server</B
> {
    @_ == 4 || die &quot;new_server (myhost, myport, login_proc)\n&quot;;
    my ($pkg, $my_host, $my_port, $login_proc) = @_;
    
    $main_socket = IO::Socket::INET-&gt;new (
                                          LocalAddr =&gt; $my_host,
                                          LocalPort =&gt; $my_port,
                                          Listen    =&gt; 5,
                                          Proto     =&gt; 'tcp',
                                          Reuse     =&gt; 1);
    die &quot;Could not create socket: $! \n&quot; unless $main_socket;
    set_event_handler ($main_socket, &quot;read&quot; =&gt; \&amp;_new_client);
    $g_login_proc = $login_proc; $g_pkg = $pkg;
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>new_server</KBD
> is somewhat similar to <KBD
CLASS="command"
>connect</KBD
>. It creates a listening socket and registers the user-defined login procedure with the event handler. (Client programs that have no wish to send or receive deferred messages don't need to call <KBD
CLASS="command"
>new_server</KBD
> or <KBD
CLASS="command"
>event_loop</KBD
>.) This login procedure will not be called until the server calls <KBD
CLASS="command"
>event_loop</KBD
> <EM
CLASS="emphasis"
>and</EM
> a connection request comes in. Unlike <KBD
CLASS="command"
>connect</KBD
>, <KBD
CLASS="command"
>new_server</KBD
> doesn't create a connection object yet; that is the job of     <KBD
CLASS="command"
>_new_client</KBD
>:</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>_new_client</B
> {
    my $sock = $main_socket-&gt;accept();
    my $conn = bless {
        'sock' =&gt;  $sock,
        'state' =&gt; 'connected'
    }, $g_pkg;
    my $rcvd_notification_proc = &amp;$g_login_proc ($conn);
    if ($rcvd_notification_proc) {
        $conn-&gt;{rcvd_notification_proc} = $rcvd_notification_proc;
        my $callback = sub {_rcv($conn)};
        set_event_handler ($sock, &quot;read&quot; =&gt; $callback);
    } else {  # Login failed
        $conn-&gt;disconnect();
    }
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>_new_client</KBD
> is called when a connection request is received. After doing an <KBD
CLASS="command"
>accept</KBD
>, it gives the user-defined login procedure a chance to accept or reject the connection. If the login procedure accepts the request, it returns a reference to a subroutine. This code reference is promptly associated with the newly created connection object and will be called when a message arrives on that connection.  <CODE
CLASS="literal"
>_</CODE
><KBD
CLASS="command"
>rcv</KBD
> is registered as the standard callback to process all incoming messages (for all connections) and accumulates an entire message before calling the code reference mentioned above.</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>_rcv</B
> {                     # Complement to _send
    my ($conn, $rcv_now) = @_; # $rcv_now complement of $flush
    # Find out how much has already been received, if at all
    my ($msg, $offset, $bytes_to_read, $bytes_read);
    my $sock = $conn-&gt;{sock};
    return unless defined($sock);
    if (exists $conn-&gt;{msg}) {
        $msg           = $conn-&gt;{msg};
        delete $conn-&gt;{'msg'};              # Have made a copy.
        $offset        = length($msg) - 1;  # sysread appends to it.
        $bytes_to_read = $conn-&gt;{bytes_to_read};
    } else {
        # The typical case ...
        $msg           = &quot;&quot;;                # Otherwise -w complains 
        $offset        = 0 ;  
        $bytes_to_read = 0 ;                # Will get set soon
    }
    # We want to read the message length in blocking mode. Quite
    # unlikely that we'll get blocked too long reading 4 bytes
    if (!$bytes_to_read)  {                 # Get new length 
        my $buf;
        $conn-&gt;set_blocking();
        $bytes_read = sysread($sock, $buf, 4);
        if ($! || ($bytes_read != 4)) {
            goto FINISH;
        }
        $bytes_to_read = unpack ('N', $buf);
    }
    $conn-&gt;set_non_blocking() unless $rcv_now;
    while ($bytes_to_read) {
        $bytes_read = sysread ($sock, $msg, $bytes_to_read, $offset);
        if (defined ($bytes_read)) {
            if ($bytes_read == 0) {
                last;
            }
            $bytes_to_read -= $bytes_read;
            $offset        += $bytes_read;
        } else {
            if (_err_will_block($!)) {
                # Should come here only in non-blocking mode
                $conn-&gt;{msg}           = $msg;
                $conn-&gt;{bytes_to_read} = $bytes_to_read;
                return ; # .. to event loop; _rcv will be called 
                         # later when socket is readable again.
            } else {
                last;
            }
        }
    }
    # Message successfully read.
  FINISH:
    if (length($msg) == 0) {
        $conn-&gt;disconnect();
    }
    if ($rcv_now) {
        return ($msg, $!);
    } else {
        &amp;{$conn-&gt;{rcvd_notification_proc}}($conn, $msg, $!);
    }
}
</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>_read</KBD
> is the complement to <KBD
CLASS="command"
>_send</KBD
> and does the grunt work of reading from a socket. Unlike <KBD
CLASS="command"
>_send</KBD
>, it does not know how much data it is going to deal with, but does know that the first four bytes of any message contain the encoded length (of the rest of the message). To simplify matters, it sets the mode to blocking before attempting to read these four bytes with the (reasonable) hope that if it blocks at all, it wouldn't be for too long. Once the length has been decoded, it sets the mode back to nonblocking, if required, and proceeds to read the socket. Like <KBD
CLASS="command"
>_send</KBD
>, it accounts for the fact that <KBD
CLASS="command"
>sysread</KBD
> may return less data than asked for, or it might return an error saying it may block. If the socket will block, <KBD
CLASS="command"
>_rcv</KBD
> copies the partial message into the connection object, notes down the number of bytes still left to read, and returns, waiting for it to be triggered by the event loop again. If there's an error, it disconnects the connection automatically.</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>rcv_now</B
> {
    my ($conn) = @_;
    my ($msg, $err) = _rcv ($conn, 1); # 1 means receive immediately
    return wantarray ? ($msg, $err) : $msg;
}</PRE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-pgfId-976637"
>13.1.1.3 Msg: Support for nonblocking I/O</A
></H4
><PRE
CLASS="programlisting"
>BEGIN {
    eval {
        require POSIX; POSIX-&gt;import(qw(F_SETFL O_NONBLOCK EAGAIN));
    };
    $blocking_supported = 1 unless $@;
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>BEGIN</KBD
> tests to see whether it can load the POSIX module and, if so, sets <KBD
CLASS="command"
>$blocking_supported</KBD
>, which is used by the following routines:</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>_err_will_block</B
> {
    if ($blocking_supported) {
        return ($_[0] == EAGAIN());
    }
    return 0;
}
sub <B
CLASS="emphasis.bold"
>set_non_blocking</B
> {
    if ($blocking_supported) {
        # preserve other fcntl flags
        my $flags = fcntl ($_[0], F_GETFL(), 0);
        fcntl ($_[0], F_SETFL(), $flags | O_NONBLOCK());
    }
}
sub <B
CLASS="emphasis.bold"
>set_blocking</B
> {
    if ($blocking_supported) {
        my $flags = fcntl ($_[0], F_GETFL(), 0);
        $flags  &amp;= ~O_NONBLOCK(); # Clear blocking, but preserve others
        fcntl ($_[0], F_SETFL(), $flags);
    }
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>set_blocking</KBD
> and <KBD
CLASS="command"
>set_non_blocking</KBD
> both call <KBD
CLASS="command"
>fcntl</KBD
> as explained in the last chapter. The <KBD
CLASS="command"
>F_SETFL</KBD
> sets the file descriptor's flags to the bitmask you supplied, so we take care not to obliterate the flags that may already have been set.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-pgfId-974804"
>13.1.1.4 Msg: Event loop routines</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-981096-0"
></A
>event loop support routines use IO::Select to manage collections of filehandles and socket handles. The send and receive side routines described earlier call these routines, but because these procedures do not make any assumptions about who is calling them, they are at a logically lower level. This means that for this module to coexist with another event-driven toolkit, you will just have to rewrite the routines shown below (while preserving the interface). For example, to make Msg work with Tk, you can have <KBD
CLASS="command"
>set_event_handler</KBD
> (described below) simply delegate its functionality to an equivalent Tk procedure called <KBD
CLASS="command"
>fileevent</KBD
> (described in <A
CLASS="xref"
HREF="ch14_01.htm"
TITLE="Introduction to GUIs, Tk, and Perl/Tk"
>Section 14.1, "Introduction to GUIs, Tk, and Perl/Tk"</A
>); similarly, <KBD
CLASS="command"
>event_loop</KBD
> can simply call Tk's <I
CLASS="function"
>run</I
> method, instead of calling IO::Select.</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>set_event_handler</B
> {
    shift unless ref($_[0]); # shift if first arg is package name
    my ($handle, %args) = @_;
    my $callback;
    if (exists $args{'write'}) {
        $callback = $args{'write'};
        if ($callback) {
            $wt_callbacks{$handle} = $callback;
            $wt_handles-&gt;add($handle);
        } else {
            delete $wt_callbacks{$handle};
            $wt_handles-&gt;remove($handle);
        }
    }
    if (exists $args{'read'}) {
        $callback = $args{'read'};
        if ($callback) {
            $rd_callbacks{$handle} = $callback;
            $rd_handles-&gt;add($handle);
        } else {
            delete $rd_callbacks{$handle};
            $rd_handles-&gt;remove($handle);
       }
    }
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>set_event_handler</KBD
> simply keeps track of read and write callbacks by using the handle as a hash index. To remove a callback, you call <KBD
CLASS="command"
>set_event_handler</KBD
> with a callback value of <KBD
CLASS="command"
>undef</KBD
>:</P
><PRE
CLASS="programlisting"
>sub <B
CLASS="emphasis.bold"
>event_loop</B
> {
    my ($pkg, $loop_count) = @_;
    my ($conn, $r, $w, $rset, $wset);
    while (1) {
        # Quit the loop if no handles left to process
        last unless ($rd_handles-&gt;count() || $wt_handles-&gt;count());
        ($rset, $wset) =
            IO::Select-&gt;select ($rd_handles, $wt_handles, 
                                undef, undef);
        foreach $r (@$rset) {
            &amp;{$rd_callbacks{$r}} ($r) if exists $rd_callbacks{$r};
        }
        foreach $w (@$wset) {
            &amp;{$wt_callbacks{$w}}($w) if exists $wt_callbacks{$w};
        }
        if (defined($loop_count)) {
            last unless --$loop_count;
        }
    }
}</PRE
><P
CLASS="para"
><KBD
CLASS="command"
>event_loop</KBD
> is normally an infinite loop but can be instructed to cycle a limited number of times. The idea of giving this a loop count is to be able to dispatch other events without forfeiting control to an infinite loop. Take a look at the RPC implementation, described in the following section, which uses a count of 1 to dispatch messages in a controlled fashion. <A
CLASS="indexterm"
NAME="ch13-idx-981078-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-981078-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-981078-2"
></A
></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch12_07.htm"
TITLE="12.7 Resources"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 12.7 Resources"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Perl Programming"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Perl Programming"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch13_02.htm"
TITLE="13.2 Remote Procedure Calls (RPC)"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 13.2 Remote Procedure Calls (RPC)"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>12.7 Resources</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>13.2 Remote Procedure Calls (RPC)</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
