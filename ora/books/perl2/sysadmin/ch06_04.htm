<html>
<head>
<title>LDAP: A Sophisticated Directory Service  (Perl for System Administration)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David N. Blank-Edelman">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1565926099L" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="LDAP: A Sophisticated Directory Service">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home">
<map name="banner-map"><AREA SHAPE="RECT" COORDS="0,0,466,71" HREF="index.htm" ALT="Perl for System Administration"><AREA SHAPE="RECT" COORDS="467,0,514,18" HREF="jobjects/fsearch.htm" ALT="Search this book">
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch06_03.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch06_01.htm">Chapter 6: Directory Services</a></td><td align="right" valign="top" width="172"><a href="ch06_05.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">6.4. LDAP: A Sophisticated Directory Service</h2>





<p>
<a name="INDEX-548"></a><a name="INDEX-549"></a><a name="INDEX-550"></a>LDAP and
ADSI are much richer and more sophisticated directory services. LDAP
stands for Lightweight Directory Access Protocol. There are two
widely deployed versions of the LDAP protocol out there (Version 2
and Version 3--anything that is version specific will be clearly
noted as such). This protocol is fast becoming the industry standard
for directory access. System administrators have embraced LDAP
because it offers them a way to centralize and make available all
sorts of infrastructure information. Besides the standard
"company directory," examples applications include:</p>





<ul>
<li>
<p>NIS-to-LDAP gateways</p>
</li>
<li>
<p>Finger-to-LDAP gateways</p>
</li>
<li>
<p>Authentication databases of all sorts (e.g., for use on the Web)</p>
</li>
<li>
<p>Resource advertisement (i.e., which machines and peripherals are
available)</p>
</li>
</ul>
<p>LDAP is also the basis of other sophisticated directory services like
Microsoft's Active Directory, which we'll see later, in
the section <a href="ch06_05.htm">Section 6.5, "ADSI (Active Directory Service Interfaces)"</a>.</p>





<p>Even if LDAP is not used in your environment to provide anything but
a fancy phone book, there are still good reasons to learn how to use
the protocol. LDAP servers themselves can be administered using the
same protocol they serve, similar to SQL database servers being
administered via SQL. To this end, Perl offers an excellent glue
environment for automating LDAP administrative tasks. Before we get
there, we need to be sure we understand LDAP itself.</p>





<p>
<a href="appb_01.htm">Appendix B, "The Ten-Minute LDAP Tutorial"</a>, contains a quick introduction to LDAP
for the uninitiated. The biggest barrier new system administrators
encounter when they begin to learn about LDAP is the unwieldy
nomenclature it inherited from its parent protocol, the X.500
Directory Service. LDAP is a simplified version of X.500, but
unfortunately, the distillation process did not make the terminology
any easier to swallow. Taking a few moments with <a href="appb_01.htm">Appendix B, "The Ten-Minute LDAP Tutorial"</a> to get these terms under your belt will make
understanding how to use LDAP from Perl
easier.<a name="INDEX-551"></a><a name="INDEX-552"></a>
</p>





<a name="ch06-2-fm2xml"></a>
<h3 class="sect2">6.4.1. LDAP Programming with Perl </h3>





<p>
<a name="INDEX-553"></a><a name="INDEX-554"></a>Like
so many other systems administration tasks in Perl, a good first step
towards LDAP programming is the selection of the required Perl
module. LDAP is not the most complex protocol out there, but it is
not a plain text protocol. As a result, cobbling something together
that speaks LDAP is not a trivial exercise. Luckily two sets of
authors have already done this work for us: Graham Barr created
<tt class="literal">Net::LDAP</tt> and Leif Hedstrom and Clayton Donley
created <tt class="literal">Mozilla::LDAP</tt> (a.k.a.
<tt class="literal">PerLDAP</tt>). <a href="ch06_04.htm">Table 6-1</a> lists some
of the ways that the two modules
differ.<a name="INDEX-555"></a><a name="INDEX-556"></a><a name="INDEX-557"></a>
</p>





<a name="ch06-85523"></a>
<h4 class="objtitle">Table 6.1. Comparison of the Two Perl LDAP Modules</h4>
<table border="1">




<tr>
<th>
<p>Feature</p>
</th>
<th>
<p>Net::LDAP</p>
</th>
<th>
<p>Mozilla::LDAP (PerLDAP)</p>
</th>
</tr>










<tr>
<td>
<p>Portability</p>
</td>
<td>
<p>Pure Perl</p>
</td>
<td>
<p>Requires the Mozilla/Netscape LDAP C-SDK (source is freely
available). The SDK compiles on many Unixs, NT, and MacOS</p>
</td>
</tr>




<tr>
<td>
<p>SSL encrypted sessions</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>




<tr>
<td>
<p>Asynchronous operations</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Only with the non-object-oriented base-level</p>





<p>API</p>
</td>
</tr>





</table>





<p>Both of these modules have the functionality to perform the simple
system administration-related tasks we'll be discussing, but
they take slightly different approaches in how they offer it. This
creates a rare educational opportunity because it allows us to
observe how two different authors implemented substantial modules to
address essentially the same niche. Careful comparison between the
two modules can offer insight into the module implementation process,
which we'll briefly demonstrate in <a href="ch10_01.htm">Chapter 10, "Security and Network Monitoring"</a>. To facilitate this comparison, most of the
examples in this section show the syntax for both Perl LDAP modules.
The <tt class="literal">use modulename</tt> line in each full code example
will clue you in on which module we are using at the time.</p>





<p>For demonstration servers, we'll be using the commercial
Netscape 4.0 Directory Server and the free OpenLDAP server (found at
<a href="../../../../../../../www.netscape.com/">http://www.netscape.com</a> and
<a href="../../../../../../../www.openldap.org/">http://www.openldap.org</a>) almost
interchangeably. Both come with almost identical command-line
utilities that you can use to prototype and crosscheck your Perl
code.</p>

















<a name="ch06-3-fm2xml"></a>
<h3 class="sect2">6.4.2. The Initial LDAP Connection</h3>





<p>Connecting with authentication is the usual first step in any LDAP
client-server transaction. In LDAP-speak this is known as
"binding to the server." Binding to a server before
sending commands to it was required in LDAPv2 but this requirement
was relaxed for LDAPv3.</p>





<p>
<a name="INDEX-558"></a>When
you bind to an LDAP server, you are said to be doing so in the
context of a specific Distinguished name (DN), described as the
<em class="emphasis">bind DN</em> for that session. This context is
similar to logging in as a particular user on a multiuser system. On
a multiuser system, your current login (for the most part) determines
your level of access to data on that system. With LDAP, it is the
bind DN context that determines how much data on the LDAP server you
can see and modify. There is a special DN known as the <em class="emphasis">root
Distinguished Name</em> (which is not given an acronym to avoid
confusing it with Relative Distinguished Name). The root
Distinguished Name is the DN context that has total control over the
whole tree, just like being logged in as <em class="emphasis">root</em>
under Unix or <em class="emphasis">Administrator</em> for NT/2000. Some
servers also refer to this as the <em class="emphasis">manager DN</em>.
<a name="INDEX-559"></a><a name="INDEX-560"></a><a name="INDEX-561"></a>
</p>





<p>If a client provides no authentication information (e.g., DN and
password) as part of a bind, or does not bother to bind before
sending commands, this is known as <em class="emphasis">anonymous
authentication</em>. Anonymously authenticated clients
typically receive very restricted access to a server's
data.<a name="INDEX-562"></a>
</p>





<p>
<a name="INDEX-563"></a><a name="INDEX-564"></a>There
are two flavors of binding in the LDAPv3 specification: simple and
SASL. Simple binding uses plain-text passwords for authentication.
SASL (Simple Authentication and Security Layer) is an extensible
authentication framework defined in RFC2222 that allows client/server
authors to plug in a number of different authentication schemes like
Kerberos and One-Time Passwords. When a client connects to a server,
it requests a particular authentication mechanism. If the server
supports this mechanism, it will begin the challenge-response
dialogue specific to that mechanism to authenticate the client.
During this dialogue, the client and server may also negotiate a
security layer (e.g., "all traffic between us will be encrypted
using TLS") for use after the initial authentication has been
completed.</p>





<p>
<a name="INDEX-565"></a><a name="INDEX-566"></a>Some LDAP servers and clients add one
more authentication method to the standard simple and SASL choices.
This method comes as a by-product of running LDAP over an encrypted
channel via Secure Socket Layer (SSL). To set this channel up, LDAP
servers and clients exchange public-key cryptography certificates
just like a web server and browser do for HTTPS. The LDAP server can
be told to use a trusted client's certificate as authentication
information without having to bother with other authentication info.
Of the Perl modules available, only PerLDAP offers LDAPS
(SSL-encrypted sessions). To keep our examples from getting too
complicated, we'll stick to simple authentication and
unencrypted transport
sessions.<a name="INDEX-567"></a>
</p>





<p>Here's how you do a simple bind and unbind in Perl:<a name="INDEX-568"></a><a name="INDEX-569"></a>
</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;
# use empty $binddn and $passwd for anonymous bind
$c = new Mozilla::LDAP::Conn($server, $port, $binddn, $passwd); 
die "Unable to connect to $server" unless $c;
...
$c-&gt;close(  );</pre>
</blockquote>





<p>or:</p>





<blockquote>
<pre class="programlisting">use Net::LDAP;
$c = Net::LDAP-&gt;new($server, port =&gt; $port) or 
    die "Unable to connect to $server: $@\n";
# use no parameters to bind(  ) for anonymous bind
$c-&gt;bind($binddn, password =&gt; $passwd) or
    die "Unable to bind: $@\n"; 
...
$c-&gt;unbind(  );</pre>
</blockquote>





<p>With <tt class="literal">Mozilla::LDAP::Conn</tt>, the creation of a new
connection object also binds to the server. In
<tt class="literal">Net::LDAP</tt> this is a two-step process. To
initialize a connection without performing a bind in
<tt class="literal">Mozilla::LDAP</tt>, you'll need to use a function
(<tt class="literal">ldap_init( )</tt>) from the non-object-oriented
<tt class="literal">Mozilla::LDAP::API</tt> module.</p>





<a name="ch06-4-fm2xml"></a>
<blockquote class="note">
<h4 class="objtitle">TIP</h4>
<p>
<em class="emphasis">Be Prepared to Carefully Quote Attribute Values</em>
</p>





<p>A quick tip before we do any more Perl programming: if you have an
attribute in your Relative Distinguished Name with a value that
contains one of the characters "<tt class="literal">+</tt>",
"(space)," "<tt class="literal">,</tt>",
"<tt class="literal">'</tt>",
"<tt class="literal">&gt;</tt>",
"<tt class="literal">&lt;</tt>", or
"<tt class="literal">;</tt>", you must specify the value
surrounded by quotation marks or with the offending character escaped
by a backslash (<tt class="literal">\</tt>). If the value contains
quotation marks, those marks must be escaped using backslashes.
Backslashes in values are also escaped with more backslashes.</p>





<p>Insufficient quoting will bite you if you are not
careful.<a name="INDEX-570"></a>
</p>




</blockquote>

















<a name="ch06-5-fm2xml"></a>
<h3 class="sect2">6.4.3. Performing LDAP Searches</h3>





<p>
<a name="INDEX-571"></a><a name="INDEX-572"></a>The D in LDAP
stands for Directory, and the one operation you perform most on a
directory is a search. Let's start our exploration of LDAP
functionality by learning how to find information.<a name="INDEX-573"></a> An LDAP
search is specified in terms of:</p>





<dl>
<dt>
<b><em class="emphasis">Where to begin the search</em></b>
</dt>
<dd>
<p>This is called the <a name="INDEX-574"></a><a name="INDEX-575"></a><em class="emphasis">base DN</em> or
<em class="emphasis">search base</em>. A base DN is simply the DN of an
entry in the directory tree where the search should begin.</p>
</dd>





<dt>
<b><em class="emphasis">Where to look</em></b>
</dt>
<dd>
<p>
<a name="INDEX-576"></a>This is
known as the search <em class="emphasis">scope</em>. The scope can be:
<em class="emphasis">base</em> (search just the base DN),
<em class="emphasis">one</em> (search everything one level below the base
DN, not including the base DN itself), or <em class="emphasis">sub</em>
(search the base DN and all of the parts of the tree below it).</p>
</dd>





<dt>
<b><em class="emphasis">What to look for</em></b>
</dt>
<dd>
<p>
<a name="INDEX-577"></a>This is
called the <em class="emphasis">search filter</em>. We'll discuss
filters and how they are specified in just a moment.</p>
</dd>





<dt>
<b><em class="emphasis">What to return</em></b>
</dt>
<dd>
<p>
<a name="INDEX-578"></a>To speed up the search operation,
you can select which attributes are returned for each entry found by
the search filter. It is also possible to request that only attribute
names and not their values are returned. This is useful for those
times when you want to know which entries have a certain attribute,
but you don't care what that attribute contains.</p>
</dd>

</dl>





<p>In Perl, a search looks like this (the bind step has been replaced
with an ellipsis):</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;
...
$entry = $c-&gt;search($basedn, $scope, $filter);
die "Bad search: ". $c-&gt;getErrorString()."\n" if $c-&gt;getErrorCode(  );</pre>
</blockquote>





<p>or:</p>





<blockquote>
<pre class="programlisting">use Net::LDAP;
...
$searchobj = $c-&gt;search(base =&gt; $basedn, scope =&gt; $scope, 
                        filter =&gt; $filter); 
die "Bad search, errorcode #".$searchobj-&gt;code() if $searchobj-&gt;code(  );</pre>
</blockquote>





<p>Let's talk about the mysterious <tt class="literal">$filter</tt>
parameter before we see a fully fleshed-out code example. Simple
search filters are of the form:</p>





<blockquote>
<pre class="programlisting">&lt;attribute name&gt; &lt;comparison operator&gt; &lt;attribute value&gt;</pre>
</blockquote>





<p>where &lt;<em class="replaceable">comparison operator</em>&gt; is
specified in RFC2254 as one of the operators listed in <a href="ch06_04.htm">Table 6-2</a>.</p>





<a name="ch06-90651"></a>
<h4 class="objtitle">Table 6.2. LDAP Comparison Operators</h4>
<table border="1">



<tr>
<th>
<p>Operator</p>
</th>
<th>
<p>Means</p>
</th>
</tr>










<tr>
<td>
<p>=</p>
</td>
<td>
<p>Exact value match. Can also be a partial value match if
<tt class="literal">*</tt> is used in the &lt;<em class="replaceable">attribute
value</em>&gt; specification (e.g., <tt class="literal">cn=Tim
O*</tt>).</p>
</td>
</tr>




<tr>
<td>
<p>=*</p>
</td>
<td>
<p>Match all entries that have values for &lt;<em class="replaceable">attribute
name</em>&gt;, independent of what the values are. By
specifying <tt class="literal">*</tt> instead of &lt;<em class="replaceable">attribute
value</em>&gt;, we test for presence of that particular
attribute in an entry (e.g., <tt class="literal">cn=*</tt> would select
entries that have <tt class="literal">cn</tt> attributes).</p>
</td>
</tr>




<tr>
<td>
<p>~=</p>
</td>
<td>
<p>Approximate value match.</p>
</td>
</tr>




<tr>
<td>
<p>&gt;=</p>
</td>
<td>
<p>Greater than or equal to value.</p>
</td>
</tr>




<tr>
<td>
<p>&lt;=</p>
</td>
<td>
<p>Less than or equal to value.</p>
</td>
</tr>





</table>





<p>These look Perlish, but don't be deceived. Two misleading
constructs to a Perl person are <tt class="literal">~=</tt> and
<tt class="literal">=*</tt>. The first has nothing to do with regular
expression matches; it finds matches that approximate the stated
value. The definition of "approximate" in this case is
server dependent. Most servers use an algorithm originally invented
for census-taking called <tt class="literal">soundex</tt> to determine the
matching values, to find words that "sound like" the
given value (in English) but are spelled differently.<a href="#FOOTNOTE-2">[2]</a>
</p>
<blockquote class="footnote">




<a name="FOOTNOTE-2"></a>
<p>[2]If you want to play with the soundex algorithm, Mark
Mielke's <tt class="literal">Text::Soundex</tt><tt class="command">
</tt>module provides a Perl implementation.</p>




</blockquote>





<p>The other construct that may clash with your Perl knowledge is the
<tt class="literal">=</tt> operator. In addition to testing for exact value
matches (both string and numeric), <tt class="literal">=</tt> can also be
used with prefix and suffix asterisks as wildcard characters, similar
to shell globbing. For example, <tt class="literal">cn=a*</tt> will yield
all of the entries that have a common name that begins with the
letter "a". <tt class="literal">cn=*a*</tt> performs just as
you would suspect, finding all entries whose common name attribute
has a letter "a" in it.</p>





<p>We can take two or more of these &lt;<em class="replaceable">attribute
name</em>&gt; &lt;<em class="replaceable">comparison
</em><tt class="literal">operator</tt>&gt;
&lt;<em class="replaceable">attribute value</em>&gt; simple search
forms and string them together with Boolean operators to make a more
complex filter. This takes the form:</p>





<blockquote>
<pre class="programlisting">(&lt;boolean operator&gt; (&lt;simple1&gt;) (&lt;simple2&gt;) (&lt;simple3&gt;) ... )<a name="INDEX-579"></a>
</pre>
</blockquote>





<p>People with LISP experience will have no problem with this sort of
syntax; everyone else will just have to remember that the operator
that combines the simple search forms is written first. To filter
entries that match both criteria A <em class="emphasis">and</em> B, you
would use <tt class="literal">(&amp;(A)(B))</tt>. For entries that match
criteria A <em class="emphasis">or</em> B <em class="emphasis">or</em> C, you
would use <tt class="literal">(|(A)(B)(C))</tt>. The exclamation mark
negates a specific criterion: A <em class="emphasis">and not</em> B is
<tt class="literal">(&amp;(A)(!B))</tt>. Compound filters can be compounded
themselves to make arbitrarily complex search filters. Here is an
example of a compound search filter that finds all of the
Finkelsteins who work in Boston:</p>





<blockquote>
<pre class="programlisting">(&amp;(sn=Finkelstein)(l=Boston))</pre>
</blockquote>





<p>To find anyone with the last name Finkelstein or Hinds:</p>





<blockquote>
<pre class="programlisting">(|(sn=Finkelstein)(sn=Hinds))</pre>
</blockquote>





<p>To find all of the Finkelsteins who do not work in Boston:</p>





<blockquote>
<pre class="programlisting">(&amp;(sn=Finkelstein)(!(l=Boston)))</pre>
</blockquote>





<p>To find all the Finkelsteins or Hinds who do not work in Boston:</p>





<blockquote>
<pre class="programlisting">(&amp;(|(sn=Finkelstein)(sn=Hinds))(!l=Boston))</pre>
</blockquote>





<p>Here are two code examples that take an LDAP server name and an LDAP
filter and return the results of the query:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;

$server = $ARGV[0];
$port   = getservbyname("ldap","tcp") || "389";
$basedn = "c=US";
$scope  = "sub";  

$c = new Mozilla::LDAP::Conn($server, $port, "",""); # anonymous bind
die "Unable to bind to $server\n" unless $c; 

$entry = $c-&gt;search($basedn, $scope, $ARGV[1]);
die "Error in search: ". $c-&gt;getErrorString()."\n" if $c-&gt;getErrorCode(  );

# process the return values from search(  )
while ($entry) {
    $entry-&gt;printLDIF(  );
    $entry = $c-&gt;nextEntry(  );
}
$c-&gt;close(  );

use Net::LDAP;
use Net::LDAP::LDIF;

$server = $ARGV[0];
$port   = getservbyname("ldap","tcp") || "389";
$basedn = "c=US";
$scope  = "sub";

$c = new Net::LDAP($server, port=&gt;$port) or 
    die "Unable to connect to $server: $@\n";
$c-&gt;bind(  ) or die "Unable to bind: $@\n"; # anonymous bind

$searchobj = $c-&gt;search(base =&gt; $basedn, scope =&gt; $scope, 
                        filter =&gt; $ARGV[1]);
die "Bad search, errorcode #".$searchobj-&gt;code() if $searchobj-&gt;code(  );

# process the return values from search(  )
if ($searchobj){
    $ldif = new Net::LDAP::LDIF("-");
    $ldif-&gt;write($searchobj-&gt;entries(  ));
    $ldif-&gt;done(  );
}</pre>
</blockquote>





<p>Here's an excerpt from some sample output:</p>





<blockquote>
<pre class="programlisting">$<tt class="userinput"><b> ldapsrch ldap.bigfoot.com '(sn=Pooh)'</b></tt>
...
dn: cn="bear pooh",mail=poohbear219@hotmail.com,c=US,o=hotmail.com
mail: poohbear219@hotmail.com
cn: bear pooh
o: hotmail.com
givenname: bear
surname: pooh
...</pre>
</blockquote>





<p>Before we develop this example any further, let's explore the
code that processes the results returned by <tt class="literal">search(
)</tt>. This is one place where the two modules diverge in
their programming model. Both of these code samples will output the
same information in LDIF (LDAP Data Interchange Format), a format
we'll explore later, but they get there in two very different
ways.<a name="INDEX-580"></a><a name="INDEX-581"></a>
</p>





<p>The <tt class="literal">Mozilla::LDAP</tt> model holds true to the search
parsing routines described in the RFC1823 C API specification. If a
search succeeds, the first entry found is returned. To view the
results, you ask for the subsequent entries one at a time. For each
entry retrieved, the <tt class="literal">printLDIF( )</tt> method is used
to dump its contents.</p>





<p>
<tt class="literal">Net::LDAP</tt>'s programming model more closely
resembles the protocol definition of RFC2251. LDAP search results are
returned in LDAP Message objects. The code we just saw calls the
<tt class="literal">entries( )</tt> method to return a list of all of the
entries in these packets. We use a method from the adjunct module
<tt class="literal">Net::LDAP::LDIF</tt> to dump these entries out en
masse. The same method, <tt class="literal">write( )</tt>, can also be
used in a manner similar to <tt class="literal">printLDIF( )</tt> in the
first example to print entries one at a time, but the call shown
above is more efficient.</p>





<p>Let's tweak our previous example a little bit. Earlier in this
chapter I mentioned that we could construct speedier searches by
limiting the attributes that are returned by a search. With the
<tt class="literal">Mozilla::LDAP</tt> module this is as simple as adding
extra parameters to our <tt class="literal">search( )</tt> method
call:<a name="INDEX-582"></a>
</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;
...
$entry = $c-&gt;search($basedn,$scope,$ARGV[1],0,@attr);</pre>
</blockquote>





<p>The first additional parameter is a Boolean flag that dictates
whether attribute values are omitted from search results. The default
is false (0), since most of the time we are interested in more than
just the names of the attributes.</p>





<p>The subsequent additional parameters are a list of names of
attributes to be returned. Perl-savvy readers will note that lists
within lists auto-interpolate, so the last line of the above code is
equivalent to (and can be written as):</p>





<blockquote>
<pre class="programlisting">$entry = 
  $c-&gt;search($basedn,$scope,$ARGV[1],0,$attr[0],$attr[1],$attr[2],...);</pre>
</blockquote>





<p>If we change our original example code from:</p>





<blockquote>
<pre class="programlisting">$entry = $c-&gt;search($basedn,$scope,$ARGV[1]);</pre>
</blockquote>





<p>to:</p>





<blockquote>
<pre class="programlisting">@attr = qw(mail);
$entry = $c-&gt;search($basedn,$scope,$ARGV[1],0,@attr);</pre>
</blockquote>





<p>we get this output instead, which only shows the entry's DN and
mail attribute:</p>





<blockquote>
<pre class="programlisting">
<tt class="userinput"><b>...</b></tt>
dn: cn="bear pooh",mail=poohbear219@hotmail.com,c=US,o=hotmail.com
mail: poohbear219@hotmail.com
...</pre>
</blockquote>





<p>The change made to return specific attributes via
<tt class="literal">Net::LDAP</tt> is similarly easy:</p>





<blockquote>
<pre class="programlisting">use Net::LDAP;
...
# could also add "typesonly =&gt; 1" to return just attribute types like
# optional 1st param above
$searchobj = $c-&gt;search(base =&gt; $basedn, filter =&gt; $ARGV[1]<tt class="userinput"><b>,</b></tt>
<tt class="userinput"><b>                        </b></tt>attrs =&gt; \@attr);</pre>
</blockquote>





<p>Note that <tt class="literal">Net::LDAP</tt> takes a
<em class="emphasis">reference</em> to an array, not values in the array
like <a name="INDEX-583"></a><tt class="literal">Mozilla::LDAP</tt>.<a name="INDEX-584"></a><a name="INDEX-585"></a><a name="INDEX-586"></a>
</p>

















<a name="ch06-6-fm2xml"></a>
<h3 class="sect2">6.4.4. Entry Representation in Perl</h3>





<p>
<a name="INDEX-587"></a>These code samples may provoke some
questions about entry representation and manipulation -- that
is, how are entries themselves stored and manipulated in a Perl
program? Let's answer a few of those questions as a follow-up
to our LDAP searching discussion, even though we will discuss them
more thoroughly in the upcoming sections on addition and modification
of entries.</p>





<p>If you've just done a search using
<tt class="literal">Mozilla::LDAP</tt> and have an entry object instance in
hand, you can access the individual attributes in that entry using
the Perl hash-of-lists syntax.
<tt class="literal">$entry-&gt;{attributename}</tt> is a
<em class="emphasis">list</em> of the values for that attribute name. I
emphasize "list" because even single-valued attributes
are stored in an anonymous list referenced through this hash key. To
get at the value in a single-valued attribute like this, you would
use <tt class="literal">$entry-&gt;{attributename}-&gt;[0]</tt>. <a href="ch06_04.htm">Table 6-3</a> lists some more methods from
<tt class="literal">Mozilla::LDAP::Entry</tt> that come in handy when
retrieving entry attributes.<a name="INDEX-588"></a>
</p>





<a name="ch06-46076"></a>
<h4 class="objtitle">Table 6.3. Mozilla::LDAP::Entry Methods</h4>
<table border="1">



<tr>
<th>
<p>Method Call</p>
</th>
<th>
<p>Returns</p>
</th>
</tr>










<tr>
<td>
<blockquote>
<pre class="programlisting">$entry-&gt;exists($attrname)</pre>
</blockquote>
</td>
<td>
<p>
<tt class="command">true</tt> if that entry has an attribute with this name</p>
</td>
</tr>




<tr>
<td>
<blockquote>
<pre class="programlisting">$entry-&gt;hasValue($attrname,$attrvalue)</pre>
</blockquote>
</td>
<td>
<p>
<tt class="command">true</tt> if that entry has a named attribute with this
value</p>
</td>
</tr>




<tr>
<td>
<blockquote>
<pre class="programlisting">$entry-&gt;matchValue($attrname,$attrvalue)</pre>
</blockquote>
</td>
<td>
<p>Same as above, except performs a regular expression match for
attribute value</p>
</td>
</tr>




<tr>
<td>
<blockquote>
<pre class="programlisting">$entry-&gt;size(<em class="replaceable">$attrname</em>)</pre>
</blockquote>
</td>
<td>
<p>The number of values for that attribute (usually 1 unless the
attribute is multivalued)</p>
</td>
</tr>





</table>





<p>Some of these methods have additional parameters; see the
documentation on <tt class="literal">Mozilla::LDAP::Entry</tt> for more
information.</p>





<p>You could probably tell from the sample search code that the method
for accessing <tt class="literal">Net::LDAP</tt> entry attributes is a bit
different. After conducting a search, all of the results are
available encapsulated by a single object. To get at the individual
attributes for the entries in this object, you can take one of two
approaches.</p>





<p>First, you could ask the module to convert all of the returned
entries into one large user-accessible data structure.
<tt class="literal">$searchobj-&gt;as_struct( )</tt> returns a
hash-of-hash-of-lists data structure. It returns a reference to a
hash whose keys are the DNs of the returned entries. The values for
these keys are references to anonymous hashes keyed on the attribute
names. These keys yield references to anonymous arrays that hold the
actual values for those attributes. <a href="ch06_04.htm">Figure 6-1</a>
makes this clearer.</p>





<a name="ch06-26577"></a>
<div class="figure">
<img alt="figure" src="figs/psa_0601.gif"></div>
<h4 class="objtitle">Figure 6.1. Data structure returned by as_struct(  )</h4>

<p>To print the first value for the <tt class="literal">cn</tt> attributes for
all of the entries in this data structure, you could use code like
this:</p>





<blockquote>
<pre class="programlisting">$searchstruct = $searchobj-&gt;as_struct;
for (keys %$searchstruct){
    print $searchstruct-&gt;{$_}{cn}[0],"\n";
}</pre>
</blockquote>





<p>Alternatively, you can first use any one of these methods to unload
an individual entry object from the object returned by a search:</p>





<blockquote>
<pre class="programlisting"># return a specific entry number
$entry   = $searchobj-&gt;entry($entrynum);

# acts like Perl shift(  ) on entry list
$entry   = $searchobj-&gt;shift_entry;      

# acts like Perl pop(  ) on entry list
$entry   = $searchobj-&gt;pop_entry;        

# return all of the entries as a list 
@entries = $searchobj-&gt;entries;</pre>
</blockquote>





<p>Once you have an entry object, you can use one of the method calls in
<a href="ch06_04.htm">Table 6-4</a>.</p>





<a name="ch06-60204"></a>
<h4 class="objtitle">Table 6.4. Net::LDAP Entry Methods</h4>
<table border="1">



<tr>
<th>
<p>Method Call</p>
</th>
<th>
<p>Returns</p>
</th>
</tr>










<tr>
<td>
<p>
<tt class="literal">$entry-&gt;get($attrname)</tt>
</p>
</td>
<td>
<p>The value of that attribute in the given entry</p>
</td>
</tr>




<tr>
<td>
<p>
<tt class="literal">$entry-&gt;attributes(  )</tt>
</p>
</td>
<td>
<p>The list of attribute names for that entry</p>
</td>
</tr>





</table>





<p>It is possible to chain these method calls together in a fairly
legible fashion. For instance, this line of code will retrieve the
value of the <tt class="literal">cn</tt> attribute in the first returned
entry:</p>





<blockquote>
<pre class="programlisting">$value = $searchobj-&gt;entry(1)-&gt;get(cn)</pre>
</blockquote>





<p>Now that you know how to access individual attributes and values
returned by a search, let's look at how to get this sort of
data into a directory server in the first place.</p>

















<a name="ch06-7-fm2xml"></a>
<h3 class="sect2">6.4.5. Adding Entries with LDIF</h3>





<p>Before we look at the generic methods for adding entries to an LDAP
directory, let's stay true to the title of this book and look
at a technique useful mostly to system and directory administrators.
This technique uses a data format that helps you to bulk load data
into a directory server. We're going to look at ways of writing
and reading LDIF.</p>





<p>
<a name="INDEX-589"></a>LDIF, defined in a set of pre-RFC
draft standards at the time of this writing, offers a simple text
representation of a directory entry. Here's a simple LDIF
example taken from the latest draft standard by Gordon Good:</p>





<blockquote>
<pre class="programlisting">version: 1 
   dn: cn=Barbara Jensen, ou=Product Development, dc=airius, dc=com   
   objectclass: top
   objectclass: person
   objectclass: organizationalPerson
   cn: Barbara Jensen
   cn: Barbara J Jensen
   cn: Babs Jensen                 
   sn: Jensen       
   uid: bjensen
   telephonenumber: +1 408 555 1212
   description: A big sailing fan.

   dn: cn=Bjorn Jensen, ou=Accounting, dc=airius, dc=com
   objectclass: top   
   objectclass: person
   objectclass: organizationalPerson
   cn: Bjorn Jensen  
   sn: Jensen 
   telephonenumber: +1 408 555 1212</pre>
</blockquote>





<p>The format should be almost self-explanatory to you by now. After the
LDIF version number, each entry's DN,
<tt class="literal">objectClass</tt> definitions, and attributes are
listed. A line separator alone on a line (i.e., a blank line)
separates individual entries.</p>





<p>
<a name="INDEX-590"></a><a name="INDEX-591"></a>Our first task is to learn how
to write LDIF files from extant directory entries. In addition to
giving us practice data for the next section (where we read LDIF
files), this functionality is useful because once we have an LDIF
file, we can massage it any way we like using Perl's usual text
manipulation idioms.</p>





<p>You've already seen how to print out entries in LDIF format
during our discussion of LDAP searches. Let's change the code
we used in that example so it writes to a file instead:<a name="INDEX-592"></a>
</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;
use Mozilla::LDAP::LDIF;

<em class="replaceable">&lt;perform bind &amp; search&gt;</em>

open(LDIF,"&gt;$LDIFfile") or die "Unable to write to $LDIFfile:$!\n";
# create new LDIF object and pass in destination filehandle
$ldif = new Mozilla::LDAP::LDIF(\*LDIF); 

while ($entry) {
    $ldif-&gt;writeOneEntry($entry);
    $entry = $c-&gt;nextEntry(  );
}

$c-&gt;close(  );
close(LDIF);</pre>
</blockquote>





<p>
<tt class="literal">Mozilla::LDAP</tt> also has a <tt class="literal">writeEntries(
)</tt> method that can take an array of entries instead of just
a single entry and write them out in a similar fashion.</p>





<p>For <tt class="literal">Net::LDAP</tt>, changing our original code is even
simpler. Instead of:</p>





<blockquote>
<pre class="programlisting">$ldif = new Net::LDAP::LDIF("-");</pre>
</blockquote>





<p>we use:</p>





<blockquote>
<pre class="programlisting">$ldif = new Net::LDAP::LDIF($filename, "w");</pre>
</blockquote>





<p>to print the output to the specified filename instead of the standard
output channel.</p>





<p>Let's work in the opposite direction now, reading LDIF files
instead of writing them. The module object methods we're about
to explore will allow us to easily add entries to a
directory.<a href="#FOOTNOTE-3">[3]</a>
</p>
<blockquote class="footnote">




<a name="FOOTNOTE-3"></a>
<p>[3]LDIF files can also contain a special
<tt class="literal">changetype:</tt> directive that instructs the LDIF
reader to delete or modify entry information rather than just add it.
Of the two modules we've been working with, only
<tt class="literal">Net::LDAP</tt> has direct support for
<tt class="literal">changetype:</tt> via its
<tt class="literal">Net::LDAP::LDIF::read_cmd( ) </tt>method.</p>




</blockquote>





<p>When you read LDIF data in via Perl, the process is exactly the
reverse of what we used in the previous LDIF-writing examples. Each
entry listing in the data gets read in and converted to an entry
object instance that is later fed to the appropriate directory
modification method. Both modules handle the data reading and parsing
for you, so this is a relatively painless process. For instance, with
<tt class="literal">Mozilla::LDAP</tt>, we can use code like the following:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;
use Mozilla::LDAP::LDIF;

$server   = $ARGV[0];
$LDIFfile = $ARGV[1];
$port     = getservbyname("ldap","tcp") || "389";
$rootdn   = "cn=Manager, ou=Systems, dc=ccs, dc=hogwarts, dc=edu";
$pw       = "secret";

# read in an LDIF file specified as the second argument 
# on the command line 
open(LDIF,"$LDIFfile") or die "Unable to open $LDIFfile:$!\n";
$ldif = new Mozilla::LDAP::LDIF(\*LDIF);

# parse all of the entries, store in @entries
@entries = $ldif-&gt;readEntries(  ); 
close(LDIF);

# non-anonymous bind
$c = new Mozilla::LDAP::Conn($server,$port,$rootdn,$pw); 
die "Unable to bind to $server\n" unless $c;

# iterate through our parsed entry list, attempting to add one at a time
for (@entries){
    $c-&gt;add($_); # add this entry to the directory
    warn "Error in add for ". $_-&gt;getDN().": ".$c-&gt;getErrorString(  )."\n"
      if $c-&gt;getErrorCode(  );
}
$c-&gt;close(  );</pre>
</blockquote>





<p>This sample also demonstrates the use of the <tt class="literal">getErrorCode(
)</tt> and <tt class="literal">getErrorString( )</tt> methods to
retrieve and report any errors that occur during the data load.
Errors can manifest for any number of reasons, including DN/RDN
duplication, schema violations, hierarchy problems, etc., so it is
important to check for them as part of any entry modification.</p>





<p>One other quick note before we move on to the
<tt class="literal">Net::LDAP</tt> equivalent: in this and the rest of the
examples we're using the root or manager DN user context for
demonstration purposes. In general, if you can avoid using this
context for everyday work, you should. Good practice for setting up
an LDAP server includes creating a powerful account or account group
(which is not the root DN) for directory management. Keep this
security tip in mind as you code your own applications.<a name="INDEX-593"></a><a name="INDEX-594"></a>
</p>





<p>With <tt class="literal">Net::LDAP</tt>, the LDIF entry addition code is
similar:</p>





<blockquote>
<pre class="programlisting">use Net::LDAP;
use Net::LDAP::LDIF;

$server   = $ARGV[0];
$LDIFfile = $ARGV[1];
$port     = getservbyname("ldap","tcp") or "389";
$rootdn   = "cn=Manager, ou=Systems, dc=ccs, dc=hogwarts, dc=edu";
$pw       = "secret";

# read in an LDIF file specified as the second argument
# on the command line
# last parameter is "r" for open for read, "w" for write
$ldif = new Net::LDAP::LDIF($LDIFfile,"r"); 
@entries = $ldif-&gt;read(  );

$c = new Net::LDAP($server, port =&gt; $port) or 
    die "Unable to connect to $server: $@\n";
$c-&gt;bind(dn =&gt; $rootdn, password =&gt; $pw) or die "Error in bind: $@\n";

for (@entries){
    $res = $c-&gt;add($_);
    warn "Error in add for ". $_-&gt;dn(  ).": error code ".$res-&gt;code."\n"
      if $res-&gt;code(  );
}

$c-&gt;unbind(  );</pre>
</blockquote>





<p>A few notes about this code sample:</p>





<ul>
<li>
<p>We could chain the two LDIF <tt class="literal">read</tt> statements into
one line if we wanted to:</p>
</li>
</ul>
<blockquote>
<pre class="programlisting">@entries = new Net::LDAP::LDIF($LDIFfile,"r")-&gt;read;</pre>
</blockquote>





<ul>
<li>
<p>If the <tt class="literal">add( )</tt> fails, we request a
decimal error code. For instance, we may see our code print something like
this:</p>





<blockquote>
<pre class="programlisting">Error in add for cn=Ursula Hampster, ou=Alumni Association, ou=People,
 o=University of Michigan, c=US: error code 68</pre>
</blockquote>



<p>If the server returns a textual message, the <tt class="literal">error(
 )</tt> method retrieves it for us, just like the error reporting
 code we used with <tt class="literal">Mozilla::LDAP</tt>:</p>



<blockquote>
<pre class="programlisting">print "The error message is:  ".$res-&lt;error."\n";</pre>
</blockquote>
</li>


<li>
<p>68 is 44 in hex, so this line in <em class="filename">Constant.pm</em> is
applicable:</p>
</li>
</ul>
<blockquote>
<pre class="programlisting">sub LDAP_ALREADY_EXISTS            (  ) { 0x44 }</pre>
</blockquote>





<p>Now we know we've attempted to add an entry from an LDIF file
that already exists in the directory.<a name="INDEX-595"></a><a name="INDEX-596"></a><a name="INDEX-597"></a>
</p>

















<a name="ch06-8-fm2xml"></a>
<h3 class="sect2">6.4.6. Adding Entries with Standard LDAP Operations</h3>





<p>It's time we look under the hood of the entry addition process
so we can learn how to create and populate entries manually, instead
of just reading them from a file like we did in the last subsection.
Our two available modules handle this process quite differently, so
we'll have to deal with them separately.
<tt class="literal">Mozilla::LDAP</tt><a name="INDEX-598"></a><a name="INDEX-599"></a><a name="INDEX-600"></a> is
closer to classic object-oriented programming style. We create a new
object instance:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Entry;
$e = new Mozilla::LDAP::Entry(  )</pre>
</blockquote>





<p>and then we begin to populate it. The next step is to give the entry
a DN. This accomplished with the <tt class="literal">setDN( )</tt>
method:</p>





<blockquote>
<pre class="programlisting">$e-&gt;setDN("uid=jay, ou=systems, ou=people, dc=ccs, dc=hogwarts, dc=edu");</pre>
</blockquote>





<p>To populate the other attributes like <tt class="literal">objectClass</tt>
we can take one of two tacks. We can make some assumptions about the
underlying data structure used to represent the entry (essentially a
hash of lists) and populate the data structure directly:</p>





<blockquote>
<pre class="programlisting">$e-&gt;{cn} = ['Jay Sekora'];</pre>
</blockquote>





<p>Here we're using the attribute name for the hash key and a
reference to an anonymous array that holds the data. The
<tt class="literal">Mozilla::LDAP</tt> module expects an array reference as
the hash value, not the data itself, so the following, as tempting as
it might be, would be incorrect:</p>





<blockquote>
<pre class="programlisting"># evil incarnate (or at the very least, just wrong)
$e-&gt;{cn} = 'Jay Sekora';</pre>
</blockquote>





<p>Alternatively, we can play it safe and use an object method to add
the data:</p>





<blockquote>
<pre class="programlisting">$e-&gt;addValue('cn', 'Jay Sekora');</pre>
</blockquote>





<p>To add multiple values to an attribute, you simply call
<tt class="literal">addValue( )</tt> repeatedly:</p>





<blockquote>
<pre class="programlisting">$e-&gt;addValue('title', 'Unix SysAdmin');
$e-&gt;addValue('title', 'Part-time Lecturer');</pre>
</blockquote>





<p>I'm partial to the second method because your code is less
likely to break if future versions of the module change the
underlying data representation.</p>





<p>Once you've populated your entry, you call the <tt class="literal">add(
)</tt> method to add this entry to the directory. Here's
a small script that will add an entry to a directory. It takes a
server, a user ID (to be used as part of a DN), and a common name as
commandline arguments:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;

$server   = $ARGV[0];
$port     = getservbyname("ldap","tcp") || "389";
$suffix   = "ou=People, ou=Systems, dc=ccs, dc=hogwarts, dc=edu";
$rootdn   = "cn=Manager, ou=Systems, dc=ccs, dc=hogwarts, dc=edu";
$pw       = "secret";

# non-anonymous bind 
$c = new Mozilla::LDAP::Conn($server,$port,$rootdn,$pw); 
die "Unable to bind to $server\n" unless $c;

$e = new Mozilla::LDAP::Entry;
# DN is uid plus a suffix detailing where to put this 
# in the directory tree
$e-&gt;setDN("uid=$ARGV[1],$suffix"); 
$e-&gt;addValue('uid', $ARGV[1]);
$e-&gt;addValue('cn', $ARGV[2]);
$c-&gt;add($e);
die "Error in add: ". $c-&gt;getErrorString()."\n" if $c-&gt;getErrorCode(  );</pre>
</blockquote>





<p>Note that this code does no input error checking. If you are putting
together a script that might really be used interactively,
you'll need to check your input to make sure it does not
include non-escaped special characters like commas. See the owl tip
on attribute value quoting earlier in this section for more details.</p>





<p>
<a name="INDEX-601"></a>Let's
turn our attention to <tt class="literal">Net::LDAP</tt>. The entry
addition process for <tt class="literal">Net::LDAP</tt> can be less
object-oriented if you are so inclined. It too has an
<tt class="literal">Entry</tt> module (<tt class="literal">Net::LDAP::Entry</tt>)
and a constructor for an entry object instance. But it also contains
an <tt class="literal">add( )</tt> function that can take a naked data
structure for single-step entry addition:</p>





<blockquote>
<pre class="programlisting">$res = $c-&gt;add(
    dn =&gt; 'uid=jay, ou=systems, ou=people, dc=ccs, dc=hogwarts, dc=edu',
    attr =&gt; [ 'cn'   =&gt; 'Jay Sekora',
              'sn    =&gt; 'Sekora',
              'mail' =&gt; 'jayguy@ccs.hogwarts.edu',
              'title'=&gt; ['Sysadmin','Part-time Lecturer'],
              'uid'  =&gt; 'jayguy',
             ]
             );
die "unable to add, errorcode #".$res-&gt;code() if $res-&gt;code(  );</pre>
</blockquote>





<p>Here we are passing two arguments to <tt class="literal">add( )</tt>. The
first is a DN for the entry; the second is a reference to an
anonymous array of attribute-value pairs. You'll notice that
multivalued attributes like <tt class="literal">title</tt> are specified
using a nested anonymous array. If you are used to working with Perl
data structures and have an aversion to the object-oriented
programming style, this may be a more comfortable idiom.<a name="INDEX-602"></a><a name="INDEX-603"></a>
</p>

















<a name="ch06-9-fm2xml"></a>
<h3 class="sect2">6.4.7. Deleting Entries</h3>





<p>Deleting entries from a directory is easy (and irrevocable, so be
careful). Here's some code snippets, again with the bind code
left out for brevity's sake:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;
...</pre>
</blockquote>





<blockquote>
<pre class="programlisting"># if you have an entry in hand, you can use 
# $c-&gt;delete($entry-&gt;getDN(  )) instead
$c-&gt;delete($dn) or 
    die "unable to delete entry: ". $c-&gt;getErrorString(  )."\n";

use Net::LDAP;
...</pre>
</blockquote>





<blockquote>
<pre class="programlisting">$res = $c-&gt;delete($dn);
die "unable to delete, errorcode #".$res-&gt;code() if $res-&gt;code(  );</pre>
</blockquote>





<p>It is important to note that <tt class="literal">delete( )</tt> in both
modules operates on a single entry at a time. If you want to delete
an entire sub-tree, you will need to first search for all of the
child entries of that sub-tree using a scope of
<tt class="literal">sub</tt> or <tt class="literal">one</tt> and then iterate
through the return values, deleting as you go. Once the children have
been deleted, then you can remove the top of that sub-tree.</p>

















<a name="ch06-10-fm2xml"></a>
<h3 class="sect2">6.4.8. Modifying Entry Names</h3>





<p>
<a name="INDEX-604"></a><a name="INDEX-605"></a><a name="INDEX-606"></a><a name="INDEX-607"></a>For our final look at LDAP operations,
we will focus on two kinds of modifications to LDAP entries. The
first kind of modification we'll consider is a change of DN or
RDN. Changing the RDN for an entry is easy and supported by both of
our modules. Here's the <tt class="literal">Mozilla::LDAP</tt>
version:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;
...</pre>
</blockquote>





<blockquote>
<pre class="programlisting">$c-&gt;modifyRDN($newRDN,$oldDN,$delold) or
    die "unable to rename entry:". $c-&gt;getErrorString(  )."\n";</pre>
</blockquote>





<p>This code should be self-explanatory with the exception of the
<tt class="literal">$delold</tt> parameter to <tt class="literal">modifyRDN(
)</tt>. When <tt class="literal">true</tt>, this instructs the LDAP
libraries to remove the values in the entry that match the values
changed in the RDN. For example, if an entry's RDN included the
attribute <tt class="literal">l</tt> (for location), and the RDN was
changed, the old<tt class="literal"> l </tt>attribute in the entry itself
would be deleted, leaving only the new value.</p>





<p>Here's the equivalent <tt class="literal">Net::LDAP</tt> code to
rename an entry:</p>





<blockquote>
<pre class="programlisting">use Net::LDAP;
...</pre>
</blockquote>





<blockquote>
<pre class="programlisting">$res = $c-&gt;moddn($oldDN, 
                 newrdn       =&gt; $newRDN, 
                 deleteoldrdn =&gt; 1);
die "unable to rename, errorcode #".$res-&gt;code() if $res-&gt;code(  );</pre>
</blockquote>





<p>
<tt class="literal">Net::LDAP</tt><a name="INDEX-608"></a>'s
<tt class="literal">moddn( )</tt> is actually more powerful than this
example shows. So far we've only changed an entry's RDN,
a change that does not have an effect on that entry's location
in the directory tree hierarchy. Version 3 of LDAP introduces a more
powerful rename operation that allows arbitrary entry relocations
within the directory tree hierarchy. <tt class="literal">moddn( )</tt>
gives you access to this capability when called with the additional
parameter <tt class="literal">newsuperior</tt>. If we add it like so:</p>





<blockquote>
<pre class="programlisting">$result = $c-&gt;moddn($oldDN, 
                    newrdn       =&gt; $newRDN,
                    deleteoldrdn =&gt; 1, 
                    newsuperior  =&gt; $parentDN);
die "unable to rename, errorcode #".$res-&gt;code() if $res-&gt;code(  );</pre>
</blockquote>





<p>then the entry located at <tt class="literal">$oldDN</tt> will be moved to
become the child of the DN specified in <tt class="literal">$parentDN</tt>.
Using this method to move entries in a directory tree is more
efficient than the <tt class="literal">add( )</tt> or <tt class="literal">delete(
)</tt> sequence previously required by the protocol, but is not
supported by all LDAP servers. In any case, if you've carefully
designed your directory tree structure, you'll have to relocate
entries less often.</p>

















<a name="ch06-11-fm2xml"></a>
<h3 class="sect2">6.4.9. Modifying Entry Attributes</h3>





<p>
<a name="INDEX-609"></a>Let's
move on to the more common operation of modifying the attributes and
attribute values in an entry. Here too we see a significant
difference between <tt class="literal">Mozilla::LDAP</tt> and
<tt class="literal">Net::LDAP</tt>. With <tt class="literal">Mozilla::LDAP</tt>,
we use one of the method calls in <a href="ch06_04.htm">Table 6-5</a> to
change the attributes in an entry.</p>





<a name="ch06-63352"></a>
<h4 class="objtitle">Table 6.5. Mozilla::LDAP Entry Modification Methods</h4>
<table border="1">



<tr>
<th>
<p>Method Call</p>
</th>
<th>
<p>Effect</p>
</th>
</tr>










<tr>
<td>
<p>
<tt class="literal">$entry-&gt;addValue($attrname,$attrvalue)</tt>
</p>
</td>
<td>
<p>Adds the specified value to the named attribute in that entry.</p>
</td>
</tr>




<tr>
<td>
<p>
<tt class="literal">$entry-&gt; removeValue($attrname,$attrvalue)</tt>
</p>
</td>
<td>
<p>Removes the specified value from the named attribute in that entry.
If this value is the only value set for that attribute, the whole
attribute is removed.</p>
</td>
</tr>




<tr>
<td>
<p>
<tt class="literal">$entry-&gt; setValue($attrname,$attrvalue1,...)</tt>
</p>
</td>
<td>
<p>Changes the values for the named attribute to the specified value or
values.</p>
</td>
</tr>




<tr>
<td>
<p>
<tt class="literal">$entry-&gt; remove($attrname)</tt>
</p>
</td>
<td>
<p>Removes the named attribute (values and all) from that entry.</p>
</td>
</tr>





</table>





<p>Once you've made all of your changes to an entry using these
method calls, you must call the <tt class="literal">update( )</tt> method
for that LDAP connection to propagate your changes to the directory
server. <tt class="literal">update( )</tt> is called with a reference to
the entry as an argument (i.e.,
<tt class="literal">$c-&gt;update($entry)</tt>).</p>





<p>Let's see these method calls in action as part of a global
search and replace. Here's the scenario: one of the facilities
at your company is being forced to move from Boston to Indiana. This
code will change all of the entries with a Boston location:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;

$server = $ARGV[0];
$port   = getservbyname("ldap","tcp") || "389";
$basedn = "dc=ccs,dc=hogwarts,dc=edu";
$scope  = "sub";
$rootdn = "cn=Manager, ou=Systems, dc=ccs, dc=hogwarts, dc=edu";
$pw     = "secret";

# non-anonymous bind 
$c = new Mozilla::LDAP::Conn($server,$port,$rootdn,$pw); 
die "Unable to bind to $server\n" unless $c;

# notice that we ask for the least amount of info 
# possible for a speedy search
$entry = $c-&gt;search($basedn,$scope,"(l=Boston)",1,'');
die "Error in search:". $c-&gt;getErrorString()."\n" if $c-&gt;getErrorCode(  );

if ($entry){
    while($entry){
        $entry-&gt;removeValue("l","Boston");
        $entry-&gt;addValue("l","Indiana");
        $c-&gt;update($entry);
        die "Error in update:" . $c-&gt;getErrorString(  ) . "\n" 
          if $c-&gt;getErrorCode(  );
        $entry = $c-&gt;nextEntry(  );
    };
}
$c-&gt;close(  );</pre>
</blockquote>





<p>
<tt class="literal">Net::LDAP</tt> takes a different approach for entry
modification. It crams all of the separate <tt class="literal">Mozilla::LDAP
</tt>method calls we just saw into one mega-method called
<tt class="literal">modify( )</tt>. The parameters passed to this method
determine its functionality. <a href="ch06_04.htm">Table 6-6</a> lists the
possible choices.</p>





<a name="ch06-75100"></a>
<h4 class="objtitle">Table 6.6. Net::LDAP Entry Modification Methods</h4>
<table border="1">



<tr>
<th>
<p>Parameter</p>
</th>
<th>
<p>Effect</p>
</th>
</tr>










<tr>
<td>
<blockquote>
<pre class="programlisting">add =&gt; {$attrname =&gt; $attrvalue}</pre>
</blockquote>
</td>
<td>
<p>Adds a named attribute with the given value.</p>
</td>
</tr>




<tr>
<td>
<blockquote>
<pre class="programlisting">add =&gt; {$attrname =&gt; [$attrvalue1,
$attrvalue2...]}</pre>
</blockquote>
</td>
<td>
<p>Adds a named attribute with the specified set of values.</p>
</td>
</tr>




<tr>
<td>
<blockquote>
<pre class="programlisting">delete =&gt; {$attrname =&gt; $attrvalue}</pre>
</blockquote>
</td>
<td>
<p>Deletes a named attribute with a specific value.</p>
</td>
</tr>




<tr>
<td>
<blockquote>
<pre class="programlisting">delete =&gt; {$attrname =&gt; []}
delete =&gt; [$attrname1,$attrname2...]</pre>
</blockquote>
</td>
<td>
<p>Deletes an attribute or set of attributes independent of their value
or values.</p>
</td>
</tr>




<tr>
<td>
<blockquote>
<pre class="programlisting">replace =&gt; {$attrname =&gt; $attrvalue}</pre>
</blockquote>
</td>
<td>
<p>Like <tt class="literal">add</tt>, but replaces the current named attribute
value. If <tt class="literal">$attrvalue</tt> is a reference to an empty
anonymous list (<tt class="literal">[]</tt>), this becomes a synonym for
the delete operation above.</p>
</td>
</tr>





</table>





<p>Be sure to pay attention to the punctuation in the previous table.
Some parameters call for a reference to an anonymous hash, others
call for a reference to an anonymous array. Mixing the two will cause
problems.</p>





<p>We can combine several of these parameters in the same call to
<tt class="literal">modify( )</tt>, but there's a potential
problem. When you <tt class="literal">modify( )</tt> with a set of these
parameters like so:</p>





<blockquote>
<pre class="programlisting">$c-&gt;modify($dn,replace =&gt; {'l' =&gt; "Medford"},
               add     =&gt; {'l' =&gt; "Boston"},
               add     =&gt; {'l' =&gt; "Cambridge"});</pre>
</blockquote>





<p>there's no guarantee the additions specified will take place
after the replacement. If you need your operations to take place in a
specific order, you can use a similar syntax to the one we've
just introduced. Instead of using a set of discrete parameters, pass
in a single array containing a queue of commands. Here's how it
works: <tt class="literal">modify( )</tt> will take a
<tt class="literal">changes</tt> parameter whose value is a list. This list
is treated as a set of pairs. The first half of the pair is the
operation to be performed; the second half is a reference to an
anonymous array of data for that operation. For instance, if we
wanted to insure that the operations in the previous code snippet
happened in order, we could write:</p>





<blockquote>
<pre class="programlisting">$c-&gt;modify($dn, changes =&gt;
                  [ replace =&gt; ['l' =&gt; "Medford"],
                    add     =&gt; ['l' =&gt; "Boston"],
                    add     =&gt; ['l' =&gt; "Cambridge"]
                  ]);</pre>
</blockquote>





<p>Take careful note of the punctuation: it is different from the other
parameters we saw before.</p>





<p>Given this information on <tt class="literal">modify( )</tt>, we can
write the <tt class="literal">Net::LDAP</tt> version of our previous
Boston-to-Indiana code like this:</p>





<blockquote>
<pre class="programlisting">use Net::LDAP;

$server   = $ARGV[0];
$port     = getservbyname("ldap","tcp") || "389";
$basedn   = "dc=ccs,dc=hogwarts,dc=edu";
$scope    = "sub";
$rootdn   = "cn=Manager, ou=Systems, dc=ccs, dc=hogwarts, dc=edu";
$pw       = "secret";

$c = new Net::LDAP($server, port =&gt; $port) or
  die "Unable to init for $server: $@\n";
$c-&gt;bind(dn =&gt; $rootdn, password =&gt; $pw) or die "Error in bind: $@\n";

$searchobj = $c-&gt;search(base  =&gt; $basedn, filter =&gt; "(l=Boston)",
                        scope =&gt; $scope,  attrs  =&gt; [''], 
                        typesonly =&gt; 1);
die "Error in search: ".$searchobj-&gt;error()."\n" if ($searchobj-&gt;code(  ));

if ($searchobj){
    @entries = $searchobj-&gt;entries;
    for (@entries){
        $res=$c-&gt;modify($_-&gt;dn(), # dn(  ) yields the DN of that entry
                   delete =&gt; {"l" =&gt; "Boston"},
                   add    =&gt; {"l" =&gt; "Indiana"});
        die "unable to modify, errorcode #".$res-&gt;code() if $res-&gt;code(  );
    }
}

$c-&gt;unbind(  );<a name="INDEX-610"></a>
</pre>
</blockquote>

















<a name="ch06-12-fm2xml"></a>
<h3 class="sect2">6.4.10. Putting It All Together</h3>





<p>Now that we've toured all of the major LDAP functions,
let's write some small system administration-related scripts.
We'll import our machine database from <a href="ch05_01.htm">Chapter 5, "TCP/IP Name Services"</a>, into an LDAP server and then generate some
useful output based on LDAP queries. Here are a couple of listings
from that flat file, just to remind you of the format:</p>





<blockquote>
<pre class="programlisting">name: shimmer
address: 192.168.1.11
aliases: shim shimmy shimmydoodles
owner: David Davis
department: software
building: main
room: 909
manufacturer: Sun
model: Ultra60
-=-
name: bendir
address: 192.168.1.3
aliases: ben bendoodles
owner: Cindy Coltrane
department: IT
building: west
room: 143
manufacturer: Apple
model: 7500/100
-=-</pre>
</blockquote>





<p>The first thing we need to do is prepare the directory server to
receive this data. We're going to use non-standard attributes,
so we'll need to update the server's schema. Different
servers handle this process in different ways. For instance, the
Netscape Directory server has a pleasant Directory Server Console GUI
for changing details like this. Other servers require modifications
to a text configuration file. With OpenLDAP, you could use something
like this in a file <tt class="literal">include</tt>d by the master
configuration file to define your own object class for a machine:</p>





<blockquote>
<pre class="programlisting">objectclass machine
        requires
                objectClass,
                cn
        allows
                address,
                aliases,
                owner,
                department,
                building,
                room,
                manufacturer,
                model</pre>
</blockquote>





<p>Once the server is configured properly, we can think about importing
the data. One approach would be to bulk load it using LDIF. If the
sample from our flat-file database shown above reminded you of the
LDIF format, you were right on target. This similarity makes the
translation easy. Still, we'll have to watch out for a few
snares:<a name="INDEX-611"></a>
</p>





<dl>
<dt>
<b>Continuation lines </b>
</dt>
<dd>
<p>Our flat-file database does not have any entries with values spanning
several lines, but if it did we'd need to make sure that output
conformed to the LDIF standard. The LDIF standard dictates that all
continuation lines must begin with exactly one space.</p>
</dd>





<dt>
<b>Entry separators </b>
</dt>
<dd>
<p>Our database uses the adorable character sequence
<tt class="literal">-=-</tt> between each entry. Two line separators (i.e.,
a blank line) must separate LDIF entries, so we'll need to axe
this character sequence when we see it in the input.</p>
</dd>





<dt>
<b>Attribute separators </b>
</dt>
<dd>
<p>
<a name="INDEX-612"></a>Right
now our data has only one multivalued attribute: aliases. LDIF deals
with multivalued attributes by listing each value on a separate line.
If we encounter multiple aliases, we'll need special code to
print out a separate line for each. If it weren't for this
misfeature in our data format, the code to go from our format to LDIF
would be a single line of Perl.</p>
</dd>

</dl>





<p>Even with these snares, the conversion program is still pretty simple:</p>





<blockquote>
<pre class="programlisting">$datafile = "database";
$recordsep = "-=-\n";
$suffix   = "ou=data, ou=systems, dc=ccs, dc=hogwarts, dc=edu";
$objectclass = &lt;&lt;EOC;
objectclass: top
objectclass: machine
EOC

open(DATA,$datafile) or die "unable to open $datafile:$!\n";

# Perl modules break with this, even if it is in the spec 
# print "version: 1\n"; # 

while (&lt;DATA&gt;) {
    # print the header for each entry
    if (/name:\s*(.*)/){ 
        print "dn: cn=$1, $suffix\n";
        print $objectclass;
        print "cn: $1\n";
        next;
    }
    # handle the multi-valued aliases attribute
    if (s/^aliases:\s*//){
        @aliases = split;
        foreach $name (@aliases){
            print "aliases: $name\n";
        }
        next;
    }
    # handle the end of record separator
    if ($_ eq $recordsep){
        print "\n";
        next;
    }
    # otherwise, just print the attribute as we found it
    print;
}

close(DATA);</pre>
</blockquote>





<p>If we run this code, it prints an LDIF file that looks (in part) like
this:</p>





<blockquote>
<pre class="programlisting">dn: cn=shimmer, ou=data, ou=systems, dc=ccs, dc=hogwarts, dc=edu
objectclass: top
objectclass: machine
cn: shimmer
address: 192.168.1.11
aliases: shim
aliases: shimmy
aliases: shimmydoodles
owner: David Davis
department: software
building: main
room: 909
manufacturer: Sun
model: Ultra60

dn: cn=bendir, ou=data, ou=systems, dc=ccs, dc=hogwarts, dc=edu
objectclass: top
objectclass: machine
cn: bendir
address: 192.168.1.3
aliases: ben
aliases: bendoodles
owner: Cindy Coltrane
department: IT
building: west
room: 143
manufacturer: Apple
model: 7500/100
...</pre>
</blockquote>





<p>With this LDIF file, we can use one of the bulk-load programs that
come with our servers to load our data into the server. For instance,
<tt class="command">ldif2ldbm</tt>, packaged with both the OpenLDAP and the
Netscape Directory Servers, reads an LDIF file and directly imports
it into the directory server's native backend format without
having to go through LDAP. Though you can only use this program while
the server is not running, it can provide the quickest way to get
lots of data into a server. If you can't take the server down,
we can use the LDIF-reading Perl code we developed earlier to feed a
file like this to an LDAP server.</p>





<p>To throw one more option into the mix, here's some code that
skips the intermediary step of creating an LDIF file and imports our
data directly into an LDAP server:</p>





<blockquote>
<pre class="programlisting">use Net::LDAP;
use Net::LDAP::Entry;

$datafile  = "database";
$recordsep = "-=-";
$server    = $ARGV[0];
$port      = getservbyname("ldap","tcp") || "389";
$suffix    = "ou=data, ou=systems, dc=ccs, dc=hogwarts, dc=edu";
$rootdn    = "cn=Manager, o=University of Michigan, c=US";
$pw        = "secret";

$c = new Net::LDAP($server,port =&gt; $port) or 
  die "Unable to init for $server: $@\n";
$c-&gt;bind(dn =&gt; $rootdn,password =&gt; $pw) or die "Error in bind: $@\n";

open(DATA,$datafile) or die "unable to open $datafile:$!\n";

while (&lt;DATA&gt;) {
    chomp;
    # at the start of a new record, create a new entry object instance
    if (/^name:\s*(.*)/){
        $dn="cn=$1, $suffix";
        $entry = new Net::LDAP::Entry;
        $entry-&gt;add("cn",$1);
        next;
    }
    # special case for multivalued attribute
    if (s/^aliases:\s*//){
        $entry-&gt;add('aliases',[split(  )]);
        next;
    }

    # if we've hit the end of the record, add it to the server
    if ($_ eq $recordsep){
        $entry-&gt;add("objectclass",["top","machine"]);
        $entry-&gt;dn($dn);
        $res = $c-&gt;add($entry);
        warn "Error in add for " . $entry-&gt;dn(  ) . ": error code " . 
              $res-&gt;code."\n" 
          if $res-&gt;code(  );
        undef $entry;
        next;
    }

    # add all of the other attributes
    $entry-&gt;add(split(':\s*')); # assume single valued attributes
}

close(DATA);
$c-&gt;unbind(  );</pre>
</blockquote>





<p>Now that we've imported the data into a server, we can start to
do some interesting things. For the following examples, we'll
flip-flop between the two LDAP modules. To save space, the header at
the top of each sample that sets our configuration variables and the
code that binds us to a server will not be repeated for each
example.<a name="INDEX-613"></a>
</p>





<p>So what can you do with this data when it resides in an LDAP server?
You can generate a hosts file on the fly:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP;<a name="INDEX-614"></a>
<a name="INDEX-615"></a>
<em class="replaceable">...</em>
$entry = $c-&gt;search($basedn,'one','(objectclass=machine)',0,
                    'cn','address','aliases');
die "Error in search:". $c-&gt;getErrorString()."\n" if $c-&gt;getErrorCode(  );

if ($entry){
    print "#\n\# host file - GENERATED BY $0\n
           # DO NOT EDIT BY HAND!\n#\n";
    while($entry){
        print $entry-&gt;{address}[0],"\t",
              $entry-&gt;{cn}[0]," ",
              join(' ',@{$entry-&gt;{aliases}}),"\n";
        $entry = $c-&gt;nextEntry(  );
    };
}
$c-&gt;close(  );</pre>
</blockquote>





<p>Here's the output:</p>





<blockquote>
<pre class="programlisting">#
# host file - GENERATED BY ldap2hosts
# DO NOT EDIT BY HAND!
#
192.168.1.11    shimmer shim shimmy shimmydoodles
192.168.1.3     bendir ben bendoodles
192.168.1.12    sulawesi sula su-lee
192.168.1.55    sander sandy mickey mickeydoo</pre>
</blockquote>





<p>You can find the names of all of our machines made by Apple:</p>





<blockquote>
<pre class="programlisting">use Net::LDAP;
...
$searchobj = $c-&gt;search(base  =&gt; $basedn, 
                        filter =&gt; "(manufacturer=Apple)",
                        scope =&gt; 'one', attrs =&gt; ['cn']);
die "Error in search: ".$searchobj-&gt;error()."\n" if ($searchobj-&gt;code(  ));

if ($searchobj){
    for ($searchobj-&gt;entries){
        print $_-&gt;get('cn'),"\n";
    }
}

$c-&gt;unbind(  );</pre>
</blockquote>





<p>Here's the output:</p>





<blockquote>
<pre class="programlisting">bendir
sulawesi</pre>
</blockquote>





<p>You can generate a list of machine owners:</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP;
...
$entry = $c-&gt;search($basedn,'one','(objectclass=machine)',0,
                    'cn','owner');
die "Error in search:". $c-&gt;getErrorString()."\n" if $c-&gt;getErrorCode(  );

if ($entry){
    while($entry){
        push(@{$owners{$entry-&gt;{owner}[0]}},$entry-&gt;{cn}[0]);
        $entry = $c-&gt;nextEntry(  );
    };
}
$c-&gt;close(  );
for (sort keys %owners){
    print $_.":\t".join(' ',@{$owners{$_}})."\n";
}</pre>
</blockquote>





<p>Here's the output:</p>





<blockquote>
<pre class="programlisting">Alex Rollins:   sander
Cindy Coltrane: bendir
David Davis:    shimmer
Ellen Monk:     sulawesi</pre>
</blockquote>





<p>Or you can check to see if the current user ID is the owner of the
current Unix machine
(pseudo-authentication):<a name="INDEX-616"></a>
</p>





<blockquote>
<pre class="programlisting">use Mozilla::LDAP::Conn;
use Sys::Hostname;

$user = (getpwuid($&lt;))[6];

$hostname = hostname;
$hostname =~ s/^([^.]+)\..*/$1/; # strip domain name off of host
...
$entry = $c-&gt;search("cn=$hostname,$suffix",'base',"(owner=$user)",1,'');

if ($entry){
    print "Owner ($user) logged on to machine $hostname.\n";
}
else {
    print "$user is not the owner of this machine ($hostname)\n.";
}
$c-&gt;close(  );</pre>
</blockquote>





<p>These snippets should give you an idea of some of the system
administration uses for LDAP access through Perl, and provide
inspiration to write your own. In the next section we'll take
these ideas to the next level and see a whole administration
framework based on the conceptual groundwork laid by LDAP.<a name="INDEX-617"></a>
</p>



<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch06_03.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch06_05.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">6.3. The WHOIS Directory Service</td><td align="center" valign="top" width="171"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">6.5. ADSI (Active Directory Service Interfaces)</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="index.htm">
</map>

<!-- END OF BODY -->

</body>
</html>
