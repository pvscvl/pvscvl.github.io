<HTML
><HEAD
>
<TITLE>Recipe 1.17. Program: fixstyle (Perl Cookbook)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:29:23Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Strings"><LINK
REL="prev"
HREF="ch01_17.htm"
TITLE="1.16. Soundex Matching"><LINK
REL="next"
HREF="ch01_19.htm"
TITLE="1.18. Program: psgrep"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl Cookbook"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Perl Cookbook"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_17.htm"
TITLE="1.16. Soundex Matching"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.16. Soundex Matching"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Strings"
>Chapter 1<BR>Strings</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_19.htm"
TITLE="1.18. Program: psgrep"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.18. Program: psgrep"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch01-97488"
>1.17. Program: fixstyle</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-1000011382-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000011382-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000011382-2"
></A
>Imagine you have a table with both old and new strings, such as the following.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Old Words</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>New Words</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>bonnet</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>hood</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>rubber</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>eraser</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lorry</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>truck</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>trousers</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>pants</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The program in <A
CLASS="xref"
HREF="ch01_18.htm"
TITLE="fixstyle"
>Example 1.4</A
> is a filter that changes all occurrences of each element in the first set to the corresponding element in the second set.</P
><P
CLASS="para"
>When called without filename arguments, the program is a simple filter. If filenames are supplied on the command line, an in-place edit writes the changes to the files, with the original versions safely saved in a file with a &quot;<CODE
CLASS="literal"
>.orig</CODE
>&quot; extension. See <A
CLASS="xref"
HREF="ch07_10.htm"
TITLE="Modifying a File in Place with -i Switch"
>Recipe 7.9</A
> for a description. A <B
CLASS="emphasis.bold"
>-v</B
> command-line option writes notification of each change to standard error.</P
><P
CLASS="para"
>The table of original strings and their replacements is stored below <CODE
CLASS="literal"
>__END__</CODE
> in the main program as described in <A
CLASS="xref"
HREF="ch07_07.htm"
TITLE="Storing Files Inside Your Program Text"
>Recipe 7.6</A
>. Each pair of strings is converted into carefully escaped substitutions and accumulated into the <CODE
CLASS="literal"
>$code</CODE
> variable like the <EM
CLASS="emphasis"
>popgrep2</EM
> program in <A
CLASS="xref"
HREF="ch06_11.htm"
TITLE="Speeding Up Interpolated Matches"
>Recipe 6.10</A
>.</P
><P
CLASS="para"
>A <CODE
CLASS="literal"
>-t</CODE
> check to test for an interactive run check tells whether we're expecting to read from the keyboard if no arguments are supplied. That way if the user forgets to give an argument, they aren't wondering why the program appears to be hung.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="ch01-38470"
>Example 1.4: fixstyle</A
></H4
><PRE
CLASS="programlisting"
>#!/usr/bin/perl -w
# fixstyle - switch first set of &lt;DATA&gt; strings to second set
#   usage: $0 [-v] [files ...]
use strict;
my $verbose = (@ARGV &amp;&amp; $ARGV[0] eq '-v' &amp;&amp; shift);

if (@ARGV) {
    $^I = &quot;.orig&quot;;          # preserve old files
} else {
    warn &quot;$0: Reading from stdin\n&quot; if -t STDIN;
}

my $code = &quot;while (&lt;&gt;) {\n&quot;;
# read in config, build up code to eval
while (&lt;DATA&gt;) {
    chomp;
    my ($in, $out) = split /\s*=&gt;\s*/;
    next unless $in &amp;&amp; $out;
    $code .= &quot;s{\\Q$in\\E}{$out}g&quot;;
    $code .= &quot;&amp;&amp; printf STDERR qq($in =&gt; $out at \$ARGV line \$.\\n)&quot; 
                                                        if $verbose;
    $code .= &quot;;\n&quot;;
}
$code .= &quot;print;\n}\n&quot;;

eval &quot;{ $code } 1&quot; || die;

__END__
analysed        =&gt; analyzed
built-in        =&gt; builtin
chastized       =&gt; chastised
commandline     =&gt; command-line
de-allocate     =&gt; deallocate
dropin          =&gt; drop-in
hardcode        =&gt; hard-code
meta-data       =&gt; metadata
multicharacter  =&gt; multi-character
multiway        =&gt; multi-way
non-empty       =&gt; nonempty
non-profit      =&gt; nonprofit
non-trappable   =&gt; nontrappable
pre-define      =&gt; predefine
preextend       =&gt; pre-extend
re-compiling    =&gt; recompiling
reenter         =&gt; re-enter
turnkey         =&gt; turn-key</PRE
></DIV
><P
CLASS="para"
>One caution: This program is fast, but it doesn't scale if you need to make hundreds of changes. The larger the <CODE
CLASS="literal"
>DATA</CODE
> section, the longer it takes. A few dozen changes won't slow it down, and in fact, the version given in the solution above is faster for that case. But if you run the program on hundreds of changes, it will bog down.</P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch01_18.htm"
TITLE="fixstyle2"
>Example 1.5</A
> is a version that's slower for few changes but faster when there are many changes.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="ch01-36847"
>Example 1.5: fixstyle2</A
></H4
><PRE
CLASS="programlisting"
>#!/usr/bin/perl -w
# <A
CLASS="indexterm"
NAME="ch01-idx-1000010675-0"
></A
>fixstyle2 - like fixstyle but faster for many many matches
use strict;
my $verbose = (@ARGV &amp;&amp; $ARGV[0] eq '-v' &amp;&amp; shift);
my %change = ();
while (&lt;DATA&gt;) { 
    chomp;
    my ($in, $out) = split /\s*=&gt;\s*/;
    next unless $in &amp;&amp; $out;
    $change{$in} = $out;
}

if (@ARGV) { 
    $^I = &quot;.orig&quot;;
} else { 
    warn &quot;$0: Reading from stdin\n&quot; if -t STDIN;
}

while (&lt;&gt;) { 
    my $i = 0;
    s/^(\s+)// &amp;&amp; print $1;         # emit leading whitespace
    for (split /(\s+)/, $_, -1) {   # preserve trailing whitespace
        print( ($i++ &amp; 1) ? $_ : ($change{$_} || $_));
    } 
}

__END__
analysed        =&gt; analyzed
built-in        =&gt; builtin
chastized       =&gt; chastised
commandline     =&gt; command-line
de-allocate     =&gt; deallocate
dropin          =&gt; drop-in
hardcode        =&gt; hard-code
meta-data       =&gt; metadata
multicharacter  =&gt; multi-character
multiway        =&gt; multi-way
non-empty       =&gt; nonempty
non-profit      =&gt; nonprofit
non-trappable   =&gt; nontrappable
pre-define      =&gt; predefine
preextend       =&gt; pre-extend
re-compiling    =&gt; recompiling
reenter         =&gt; re-enter
turnkey         =&gt; turn-key</PRE
></DIV
><P
CLASS="para"
>This version breaks each line into chunks of whitespace and words, which isn't a fast operation. It then uses those words to look up their replacements in a hash, which is much faster than a substitution. So the first part is slower, the second faster. The difference in speed depends on the number of matches.</P
><P
CLASS="para"
>If we didn't care about keeping the amount of whitespace separating each word constant, the second version can run as fast as the first even for a few changes. If you know a lot about your input, you can collapse whitespace into single blanks by plugging in this loop:</P
><PRE
CLASS="programlisting"
># very fast, but whitespace collapse
while (&lt;&gt;) { 
    for (split) { 
        print $change{$_} || $_, &quot; &quot;;
    } 
    print &quot;\n&quot;;
}</PRE
><P
CLASS="para"
>That leaves an extra blank at the end of each line. If that's a problem, you could use the technique from <A
CLASS="xref"
HREF="ch16_15.htm"
TITLE="Sending a Signal"
>Recipe 16.14</A
> to install an output filter. Place the following code in front of the <CODE
CLASS="literal"
>while</CODE
> loop that's collapsing whitespace:</P
><PRE
CLASS="programlisting"
>my $pid = open(STDOUT, &quot;|-&quot;);
die &quot;cannot fork: $!&quot; unless defined $pid;
unless ($pid) {             # child
        while (&lt;STDIN&gt;) {
        s/ $//;
        print;
    } 
    exit;
} <A
CLASS="indexterm"
NAME="ch01-idx-1000010348-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010348-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010348-2"
></A
></PRE
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_17.htm"
TITLE="1.16. Soundex Matching"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.16. Soundex Matching"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_19.htm"
TITLE="1.18. Program: psgrep"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.18. Program: psgrep"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.16. Soundex Matching</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.18. Program: psgrep</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
