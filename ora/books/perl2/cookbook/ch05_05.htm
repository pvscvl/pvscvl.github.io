<HTML
><HEAD
>
<TITLE>Recipe 5.4. Traversing a Hash (Perl Cookbook)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:32:33Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch05_01.htm"
TITLE="5. Hashes"><LINK
REL="prev"
HREF="ch05_04.htm"
TITLE="5.3. Deleting from a Hash"><LINK
REL="next"
HREF="ch05_06.htm"
TITLE="5.5. Printing a Hash"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl Cookbook"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Perl Cookbook"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_04.htm"
TITLE="5.3. Deleting from a Hash"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.3. Deleting from a Hash"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch05_01.htm"
TITLE="5. Hashes"
>Chapter 5<BR>Hashes</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_06.htm"
TITLE="5.5. Printing a Hash"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.5. Printing a Hash"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch05-37034"
>5.4. Traversing a Hash</A
></H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-pgfId-386"
>Problem<A
CLASS="indexterm"
NAME="ch05-idx-1000006438-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-1000006438-1"
></A
></A
></H3
><P
CLASS="para"
>You want to perform an action on each entry (i.e., each key-value pair) in a hash.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-pgfId-392"
>Solution</A
></H3
><P
CLASS="para"
>Use <CODE
CLASS="literal"
>each</CODE
> with a <CODE
CLASS="literal"
>while</CODE
> loop:</P
><PRE
CLASS="programlisting"
>while(($key, $value) = each(%HASH)) {
    # do something with $key and $value
}</PRE
><P
CLASS="para"
>Or use <CODE
CLASS="literal"
>keys</CODE
><A
CLASS="indexterm"
NAME="ch05-idx-1000006451-0"
></A
> with a <CODE
CLASS="literal"
>foreach</CODE
> loop, unless the hash is potentially very large:</P
><PRE
CLASS="programlisting"
>foreach $key (keys %HASH) {
    $value = $HASH{$key};
    # do something with $key and $value
}</PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-pgfId-414"
>Discussion</A
></H3
><P
CLASS="para"
>Here's a simple example, iterating through the <CODE
CLASS="literal"
>%food_color</CODE
> hash from the introduction.</P
><PRE
CLASS="programlisting"
># %food_color per the introduction
while(($food, $color) = each(%food_color)) {
    print &quot;$food is $color.\n&quot;;
}
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Banana is yellow.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Apple is red.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Carrot is orange.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Lemon is yellow.</I
></CODE
></B
></CODE
>

foreach $food (keys %food_color) {
    my $color = $food_color{$food};
    print &quot;$food is $color.\n&quot;;
}
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Banana is yellow.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Apple is red.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Carrot is orange.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Lemon is yellow.</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
>We didn't really need the <CODE
CLASS="literal"
>$color</CODE
> variable in the <CODE
CLASS="literal"
>foreach</CODE
> example because we only use it once. Instead, we could have just written:</P
><PRE
CLASS="programlisting"
><CODE
CLASS="literal"
>print</CODE
> <CODE
CLASS="literal"
>&quot;$food</CODE
> <CODE
CLASS="literal"
>is</CODE
> <CODE
CLASS="literal"
>$food_color{$food}.\n&quot;</CODE
> </PRE
><P
CLASS="para"
>Every time <CODE
CLASS="literal"
>each</CODE
> is called on the same hash, it returns the "next" key-value pair. We say "next" because the pairs are returned in the order the underlying lookup structure imposes on them, and this order is almost never alphabetic or numeric. When <CODE
CLASS="literal"
>each</CODE
> runs out of hash elements, it returns the empty list <CODE
CLASS="literal"
>()</CODE
>, which tests false and terminates the <CODE
CLASS="literal"
>while</CODE
> loop.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>foreach</CODE
> example uses <CODE
CLASS="literal"
>keys</CODE
>, which constructs an entire list containing every key from hash, before the loop even begins executing. The advantage to using <CODE
CLASS="literal"
>each</CODE
> is that it gets the keys and values one pair at a time. If the hash contains many keys, not having to pre-construct a complete list of them can save substantial memory. The <CODE
CLASS="literal"
>each</CODE
> function, however, doesn't let you control the order in which pairs are processed.</P
><P
CLASS="para"
>Using <CODE
CLASS="literal"
>foreach</CODE
> and <CODE
CLASS="literal"
>keys</CODE
> to loop over the list lets you impose an order. For instance, if we wanted to print the food names in alphabetical order:</P
><PRE
CLASS="programlisting"
>foreach $food (sort keys %food_color) {
    print &quot;$food is $food_color{$food}.\n&quot;;
}
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Apple is red.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Banana is yellow.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Carrot is orange.</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Lemon is yellow.</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
>This is a common use of <CODE
CLASS="literal"
>foreach</CODE
>. We use <CODE
CLASS="literal"
>keys</CODE
> to obtain a list of keys in the hash, and then we use <CODE
CLASS="literal"
>foreach</CODE
> to iterate over them. The danger is that if the hash contains a large number of elements, the list returned by <CODE
CLASS="literal"
>keys</CODE
> will use a lot of memory. The trade-off lies between memory use and the ability to process the entries in a particular order. We cover sorting in more detail in <A
CLASS="xref"
HREF="ch05_10.htm"
TITLE="Sorting a Hash"
>Recipe 5.9</A
>.</P
><P
CLASS="para"
>Because <CODE
CLASS="literal"
>keys</CODE
>, <CODE
CLASS="literal"
>values</CODE
>, and <CODE
CLASS="literal"
>each</CODE
> all use the same internal data structures, be careful about mixing calls to these functions or prematurely exiting an <CODE
CLASS="literal"
>each</CODE
> loop. Each time you call <CODE
CLASS="literal"
>keys</CODE
> or <CODE
CLASS="literal"
>values</CODE
>, the current location for <CODE
CLASS="literal"
>each</CODE
> is reset. This code loops forever, printing the first key returned by <CODE
CLASS="literal"
>each</CODE
>:</P
><PRE
CLASS="programlisting"
>while ( ($k,$v) = each %food_color ) {
    print &quot;Processing $k\n&quot;;
    keys %food_color;               # goes back to the start of %food_color
}</PRE
><P
CLASS="para"
>Modifying a hash while looping over it with <CODE
CLASS="literal"
>each</CODE
> or <CODE
CLASS="literal"
>foreach</CODE
> is, in general, fraught with danger. The <CODE
CLASS="literal"
>each</CODE
> function can behave differently with <CODE
CLASS="literal"
>tie</CODE
>d and untied hashes when you add or delete keys from a hash. A <CODE
CLASS="literal"
>foreach</CODE
> loops over a pre-generated list of keys, so once the loop starts, <CODE
CLASS="literal"
>foreach</CODE
> can't know whether you've added or deleted keys. Keys added in the body of the loop aren't automatically appended to the list of keys to loop over, nor are keys deleted by the body of the loop deleted from this list.</P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch05_05.htm"
TITLE="countfrom"
>Example 5.1</A
> reads a mailbox file and reports on the number of messages from each person. It uses the <CODE
CLASS="literal"
>From:</CODE
> line to determine the sender. (It isn't smart in this respect, but we're showing hash manipulation, not mail-file processing.) Supply the mailbox filename as a command-line argument, or use <CODE
CLASS="literal"
>&quot;-&quot;</CODE
> to indicate you're piping the mailbox to the program.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="ch05-34568"
>Example 5.1: countfrom</A
></H4
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
# countfrom - count number of messages from each sender

$filename = $ARGV[0] || &quot;-&quot;;

open(FILE, &quot;&lt;$filename&quot;)            or die &quot;Can't open $filename : $!&quot;;

while(&lt;FILE&gt;) {
    if (/^From: (.*)/) { $from{$1}++ }
}

foreach $person (sort keys %from) {
    print &quot;$person: $from{$person}\n&quot;;
}</PRE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-pgfId-518"
>See Also</A
></H3
><P
CLASS="para"
>The <CODE
CLASS="literal"
>each</CODE
> and <CODE
CLASS="literal"
>keys</CODE
> functions in <EM
CLASS="emphasis"
>perlfunc </EM
>(1) and in <A
CLASS="olink"
HREF="../prog/ch03_01.htm"
>Chapter 3</A
> of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>; we talk about for and foreach in <A
CLASS="xref"
HREF="ch04_06.htm"
TITLE="Iterating Over an Array by Reference"
>Recipe 4.5</A
><A
CLASS="indexterm"
NAME="ch05-idx-1000006440-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-1000006440-1"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-1000006440-2"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_04.htm"
TITLE="5.3. Deleting from a Hash"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.3. Deleting from a Hash"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_06.htm"
TITLE="5.5. Printing a Hash"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.5. Printing a Hash"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.3. Deleting from a Hash</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>5.5. Printing a Hash</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
