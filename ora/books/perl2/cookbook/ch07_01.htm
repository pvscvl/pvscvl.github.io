<HTML
><HEAD
>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:35:15Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Perl Cookbook"><LINK
REL="prev"
HREF="ch06_24.htm"
TITLE="6.23. Regular Expression Grabbag"><LINK
REL="next"
HREF="ch07_02.htm"
TITLE="7.1. Opening a File"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl Cookbook"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Perl Cookbook"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_24.htm"
TITLE="6.23. Regular Expression Grabbag"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.23. Regular Expression Grabbag"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 7</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_02.htm"
TITLE="7.1. Opening a File"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.1. Opening a File"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch07-24448"
>7. File Access</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch07-36590"
TITLE="7.0. Introduction"
>Introduction</A
><BR><A
CLASS="sect1"
HREF="ch07_02.htm"
TITLE="7.1. Opening a File"
>Opening a File</A
><BR><A
CLASS="sect1"
HREF="ch07_03.htm"
TITLE="7.2. Opening Files with Unusual Filenames"
>Opening Files with Unusual Filenames</A
><BR><A
CLASS="sect1"
HREF="ch07_04.htm"
TITLE="7.3. Expanding Tildes in Filenames"
>Expanding Tildes in Filenames</A
><BR><A
CLASS="sect1"
HREF="ch07_05.htm"
TITLE="7.4. Making Perl Report Filenames in Errors"
>Making Perl Report Filenames in Errors</A
><BR><A
CLASS="sect1"
HREF="ch07_06.htm"
TITLE="7.5. Creating Temporary Files"
>Creating Temporary Files</A
><BR><A
CLASS="sect1"
HREF="ch07_07.htm"
TITLE="7.6. Storing Files Inside Your Program Text"
>Storing Files Inside Your Program Text</A
><BR><A
CLASS="sect1"
HREF="ch07_08.htm"
TITLE="7.7. Writing a Filter"
>Writing a Filter</A
><BR><A
CLASS="sect1"
HREF="ch07_09.htm"
TITLE="7.8. Modifying a File in Place with Temporary File"
>Modifying a File in Place with Temporary File</A
><BR><A
CLASS="sect1"
HREF="ch07_10.htm"
TITLE="7.9. Modifying a File in Place with -i Switch"
>Modifying a File in Place with -i Switch</A
><BR><A
CLASS="sect1"
HREF="ch07_11.htm"
TITLE="7.10. Modifying a File in Place Without a Temporary File"
>Modifying a File in Place Without a Temporary File</A
><BR><A
CLASS="sect1"
HREF="ch07_12.htm"
TITLE="7.11. Locking a File"
>Locking a File</A
><BR><A
CLASS="sect1"
HREF="ch07_13.htm"
TITLE="7.12. Flushing Output"
>Flushing Output</A
><BR><A
CLASS="sect1"
HREF="ch07_14.htm"
TITLE="7.13. Reading from Many Filehandles Without Blocking"
>Reading from Many Filehandles Without Blocking</A
><BR><A
CLASS="sect1"
HREF="ch07_15.htm"
TITLE="7.14. Doing Non-Blocking I/O"
>Doing Non-Blocking I/O</A
><BR><A
CLASS="sect1"
HREF="ch07_16.htm"
TITLE="7.15. Determining the Number of Bytes to Read"
>Determining the Number of Bytes to Read</A
><BR><A
CLASS="sect1"
HREF="ch07_17.htm"
TITLE="7.16. Storing Filehandles in Variables"
>Storing Filehandles in Variables</A
><BR><A
CLASS="sect1"
HREF="ch07_18.htm"
TITLE="7.17. Caching Open Output Filehandles"
>Caching Open Output Filehandles</A
><BR><A
CLASS="sect1"
HREF="ch07_19.htm"
TITLE="7.18. Printing to Many Filehandles Simultaneously"
>Printing to Many Filehandles Simultaneously</A
><BR><A
CLASS="sect1"
HREF="ch07_20.htm"
TITLE="7.19. Opening and Closing File Descriptors by Number"
>Opening and Closing File Descriptors by Number</A
><BR><A
CLASS="sect1"
HREF="ch07_21.htm"
TITLE="7.20. Copying Filehandles"
>Copying Filehandles</A
><BR><A
CLASS="sect1"
HREF="ch07_22.htm"
TITLE="7.21. Program: netlock"
>Program: netlock</A
><BR><A
CLASS="sect1"
HREF="ch07_23.htm"
TITLE="7.22. Program: lockarea"
>Program: lockarea</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>I the heir of all the ages, in the foremost files of time.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Alfred, Lord Tennyson <CITE
CLASS="citetitle"
>Locksley Hall</CITE
></P
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch07-36590"
>7.0. Introduction</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-1000009548-0"
></A
>Nothing is more central to data processing than the file. As with everything else in Perl, easy things are easy and hard things are possible. Common tasks (opening, reading data, writing data) use simple I/O functions and operators, whereas fancier functions do hard things like non-blocking I/O and file locking.</P
><P
CLASS="para"
>This chapter deals with the mechanics of file <EM
CLASS="emphasis"
>access</EM
>: opening a file, telling subroutines which files to work with, locking files, and so on. <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="File Contents"
>Chapter 8, <CITE
CLASS="chapter"
>File Contents</CITE
></A
>, deals with techniques for working with the <EM
CLASS="emphasis"
>contents</EM
> of a file: reading, writing, shuffling lines, and other operations you can do once you have access to the file.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-1000009550-0"
></A
>Here's Perl code for printing all lines in the file <EM
CLASS="emphasis"
>/usr/local/widgets/data</EM
> that contain the word <CODE
CLASS="literal"
>&quot;blue&quot;</CODE
>:</P
><PRE
CLASS="programlisting"
>open(INPUT, &quot;&lt; /usr/local/widgets/data&quot;)
    or die &quot;Couldn't open /usr/local/widgets/data for reading: $!\n&quot;;

while (&lt;INPUT&gt;) {
    print if /blue/;
}
close(INPUT);</PRE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-chap07_getting_0"
>Getting a Handle on the File</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-1000009551-0"
></A
>Central to Perl's file access is the <EM
CLASS="emphasis"
>filehandle</EM
>, like INPUT in the preceding program. This is a symbol you use to represent the file when you read and write. Because filehandles aren't variables (they don't have a <CODE
CLASS="literal"
>$</CODE
>, <CODE
CLASS="literal"
>@</CODE
>, or <CODE
CLASS="literal"
>%</CODE
> type marker on their names &nbsp;-  but they are part of Perl's symbol table just as subroutines and variables are), storing filehandles in variables and passing them to subroutines won't always work. You should use the odd-looking <A
CLASS="indexterm"
NAME="ch07-idx-1000009759-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009759-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009759-2"
></A
><CODE
CLASS="literal"
>*FH</CODE
> notation, indicating a typeglob, the basic unit of Perl's symbol table:</P
><PRE
CLASS="programlisting"
>$var = *STDIN;
mysub($var, *LOGFILE);</PRE
><P
CLASS="para"
>When you store filehandles in variables like this, you don't use them directly. They're called <EM
CLASS="emphasis"
>indirect filehandles</EM
><A
CLASS="indexterm"
NAME="ch07-idx-1000009552-0"
></A
> because they indirectly refer to the real filehandle. Two modules, <A
CLASS="indexterm"
NAME="ch07-idx-1000009553-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009553-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009553-2"
></A
>IO::File (standard since 5.004) and FileHandle (standard since 5.000), can create anonymous filehandles.</P
><P
CLASS="para"
>When we use IO::File or IO::Handle in our examples, you could obtain identical results by using FileHandle instead, since it's now just a wrapper module.</P
><P
CLASS="para"
>Here's how we'd write the <CODE
CLASS="literal"
>&quot;blue&quot;</CODE
>-finding program with the IO::File module using purely object-oriented notation:</P
><PRE
CLASS="programlisting"
>use IO::File;

$input = IO::File-&gt;new(&quot;&lt; /usr/local/widgets/data&quot;)
    or die &quot;Couldn't open /usr/local/widgets/data for reading: $!\n&quot;;

while (defined($line = $input-&gt;getline())) {
    chomp($line);
    STDOUT-&gt;print($line) if $line =~ /blue/;
}
$input-&gt;close();</PRE
><P
CLASS="para"
>As you see, it's much more readable to use filehandles directly. It's also a lot faster.</P
><P
CLASS="para"
>But here's a little secret for you: you can skip all that arrow and method-call business altogether. Unlike most objects, you don't actually <EM
CLASS="emphasis"
>have</EM
> to use IO::File objects in an object-oriented way. They're essentially just anonymous filehandles, so you can use them anywhere you'd use a regular indirect filehandle. <A
CLASS="xref"
HREF="ch07_17.htm"
TITLE="Storing Filehandles in Variables"
>Recipe 7.16</A
> covers these modules and the <CODE
CLASS="literal"
>*FH</CODE
> notation. We use both IO::File and symbolic filehandles in this chapter.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-chap07_standard_0"
>Standard FileHandles</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-1000009554-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009554-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009554-2"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009554-3"
></A
>Every program starts out with three global filehandles already opened: STDIN, STDOUT, and STDERR. STDIN (<EM
CLASS="emphasis"
>standard input</EM
>) is the default source of input, STDOUT (<EM
CLASS="emphasis"
>standard output</EM
>) is the default destination for output, and STDERR (<EM
CLASS="emphasis"
>standard error</EM
>) is the default place to send warnings and errors. For interactive programs, STDIN is the keyboard, STDOUT and STDERR are the screen:</P
><PRE
CLASS="programlisting"
>while (&lt;STDIN&gt;) {                   # reads from STDIN
    unless (/\d/) {
        warn &quot;No digit found.\n&quot;;   # writes to STDERR
    }
    print &quot;Read: &quot;, $_;             # writes to STDOUT
}
END { close(STDOUT)                 or die &quot;couldn't close STDOUT: $!&quot; }</PRE
><P
CLASS="para"
>Filehandles live in packages. That way, two packages can have filehandles with the same name and be separate, just as they can with subroutines and variables. The <CODE
CLASS="literal"
>open</CODE
><A
CLASS="indexterm"
NAME="ch07-idx-1000009564-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009564-1"
></A
> function associates a filehandle with a file or program, after which you use that filehandle for I/O. When done, <CODE
CLASS="literal"
>close</CODE
> the filehandle to break the association.</P
><P
CLASS="para"
>Files are accessed at the operating system through numeric file descriptors. You can learn a filehandle's descriptor number using the <CODE
CLASS="literal"
>fileno</CODE
> function. Perl's filehandles are sufficient for most file operations, but <A
CLASS="xref"
HREF="ch07_20.htm"
TITLE="Opening and Closing File Descriptors by Number"
>Recipe 7.19</A
> tells you how to deal with the situation where you're given an file descriptor and want to turn it into a filehandle you can use.<A
CLASS="indexterm"
NAME="ch07-idx-1000009556-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009556-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009556-2"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009556-3"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch07-chap07_i_o_0"
>I/O Operations</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-1000009566-0"
></A
>Perl's most common operations for file interaction are <CODE
CLASS="literal"
>open</CODE
>, <CODE
CLASS="literal"
>print</CODE
>, <CODE
CLASS="literal"
>&lt;FH&gt;</CODE
> to read a record, and <CODE
CLASS="literal"
>close</CODE
>. These are wrappers around routines from the C buffered input/output library called <EM
CLASS="emphasis"
>stdio</EM
><A
CLASS="indexterm"
NAME="ch07-idx-1000009565-0"
></A
>. Perl's I/O functions are documented in <A
CLASS="olink"
HREF="../prog/ch03_01.htm"
>Chapter 3</A
> of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>, <I
CLASS="filename"
>perlfunc </I
>(1), and your system's <I
CLASS="filename"
>stdio </I
>(3S) manpages. The next chapter details I/O operations like &lt;&gt;, <CODE
CLASS="literal"
>print</CODE
>, <CODE
CLASS="literal"
>seek</CODE
>, and <CODE
CLASS="literal"
>tell</CODE
>.</P
><P
CLASS="para"
>The most important I/O function is <CODE
CLASS="literal"
>open</CODE
>. It takes two arguments, the filehandle and a string containing the filename and <A
CLASS="indexterm"
NAME="ch07-idx-1000009573-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009573-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009573-2"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009573-3"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009573-4"
></A
>access mode. To open <EM
CLASS="emphasis"
>/tmp/log</EM
> for writing and to associate it with the filehandle <CODE
CLASS="literal"
>LOGFILE</CODE
>, say:</P
><PRE
CLASS="programlisting"
>open(LOGFILE, &quot;&gt; /tmp/log&quot;)     or die &quot;Can't write /tmp/log: $!&quot;;</PRE
><P
CLASS="para"
>The three most common access modes are &lt; for reading, &gt; for overwriting, and &gt;&gt; for appending. The <CODE
CLASS="literal"
>open</CODE
> function is discussed in more detail in <A
CLASS="xref"
HREF="ch07_02.htm"
TITLE="Opening a File"
>Recipe 7.1</A
>.</P
><P
CLASS="para"
>When opening a file or making virtually any other system call,[<A
CLASS="footnote"
HREF="#ch07-pgfId-1000008479"
>1</A
>] checking the return value is indispensable. Not every <CODE
CLASS="literal"
>open</CODE
> succeeds; not every file is readable; not every piece of data you <CODE
CLASS="literal"
>print</CODE
> can reach its destination. Most programmers check <CODE
CLASS="literal"
>open</CODE
>, <CODE
CLASS="literal"
>seek</CODE
>, <CODE
CLASS="literal"
>tell</CODE
>, and <CODE
CLASS="literal"
>close</CODE
> in robust programs. You might also want to check other functions. The Perl documentation lists return values from all functions and operators. If a system call fails, it returns <CODE
CLASS="literal"
>undef</CODE
>, except for <CODE
CLASS="literal"
>wait</CODE
>, <CODE
CLASS="literal"
>waitpid </CODE
>, and <CODE
CLASS="literal"
>syscall</CODE
>, which return <CODE
CLASS="literal"
>-1</CODE
> on failure. The system error message or number is available in the <CODE
CLASS="literal"
>$!</CODE
> variable. This is often used in <CODE
CLASS="literal"
>die</CODE
> or <CODE
CLASS="literal"
>warn</CODE
> messages.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch07-pgfId-1000008479"
>[1]</A
> The term <EM
CLASS="emphasis"
>system call</EM
> denotes a call into your operating system. It is unrelated to the C and Perl function that's actually named <CODE
CLASS="literal"
>system</CODE
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>To read a record in Perl, use the <A
CLASS="indexterm"
NAME="ch07-idx-1000009574-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009574-1"
></A
>circumfix operator <CODE
CLASS="literal"
>&lt;FILEHANDLE&gt;</CODE
>, whose behavior is also available through the <CODE
CLASS="literal"
>readline</CODE
> function. A record is normally a line, but you can change the record terminator, as detailed in <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="File Contents"
>Chapter 8</A
>. If <CODE
CLASS="literal"
>FILEHANDLE</CODE
> is omitted, Perl opens and reads from the filenames in <CODE
CLASS="literal"
>@ARGV</CODE
> or from STDIN if there aren't any. Customary and curious uses of this are described in <A
CLASS="xref"
HREF="ch07_08.htm"
TITLE="Writing a Filter"
>Recipe 7.7</A
>.</P
><P
CLASS="para"
>Abstractly, files are simply streams of bytes. Each filehandle has associated with it a number representing the current byte position in the file, returned by the <CODE
CLASS="literal"
>tell</CODE
> function and set by the <CODE
CLASS="literal"
>seek</CODE
> function. In <A
CLASS="xref"
HREF="ch07_11.htm"
TITLE="Modifying a File in Place Without a Temporary File"
>Recipe 7.10</A
>, we rewrite a file without closing and reopening by using <CODE
CLASS="literal"
>seek</CODE
> to move back to the start, rewinding it.</P
><P
CLASS="para"
>When you no longer have use for a filehandle, <CODE
CLASS="literal"
>close</CODE
> it. The <CODE
CLASS="literal"
>close</CODE
> function takes a single filehandle and returns true if the filehandle could be successfully flushed and closed, false otherwise. You don't need to explicitly close every filehandle. When you open a filehandle that's already open, Perl implicitly closes it first. When your program exits, any open filehandles also get closed.</P
><P
CLASS="para"
>These implicit closes are for convenience, not stability, because they don't tell you whether the system call succeeded or failed. Not all closes succeed. Even a <CODE
CLASS="literal"
>close</CODE
> on a read-only file can fail. For instance, you could lose access to the device because of a network outage. It's even more important to check the <CODE
CLASS="literal"
>close</CODE
> if the file was opened for writing. Otherwise you wouldn't notice if the disk filled up.</P
><PRE
CLASS="programlisting"
>close(FH)           or die &quot;FH didn't close: $!&quot;;</PRE
><P
CLASS="para"
>The prudent programmer even checks the <CODE
CLASS="literal"
>close</CODE
> on standard output stream at the program's end, in case STDOUT was redirected from the command line the output filesystem filled up. Admittedly, your run-time system should take care of this for you, but it doesn't. <A
CLASS="indexterm"
NAME="ch07-idx-1000009572-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009572-1"
></A
></P
><P
CLASS="para"
>Checking standard error, though, is probably of dubious value. After all, if STDERR fails to close, what are you planning to do about it?</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-1000009575-0"
></A
>STDOUT is the default destination for output from the <CODE
CLASS="literal"
>print</CODE
>, <CODE
CLASS="literal"
>printf</CODE
>, and <CODE
CLASS="literal"
>write</CODE
> functions. Change this with <CODE
CLASS="literal"
>select</CODE
><A
CLASS="indexterm"
NAME="ch07-idx-1000009576-0"
></A
>, which takes the new default output filehandle and returns the previous one. The new output filehandle should have been opened before calling <CODE
CLASS="literal"
>select</CODE
>:</P
><PRE
CLASS="programlisting"
>$old_fh = select(LOGFILE);                  # switch to LOGFILE for output
print &quot;Countdown initiated ...\n&quot;;
select($old_fh);                            # return to original output
print &quot;You have 30 seconds to reach minimum safety distance.\n&quot;;</PRE
><P
CLASS="para"
>Some of Perl's special variables change the behavior of the currently selected output filehandle. Most important is <CODE
CLASS="literal"
>$|</CODE
><A
CLASS="indexterm"
NAME="ch07-idx-1000009577-0"
></A
>, which controls output buffering for each filehandle. Buffering is explained in <A
CLASS="xref"
HREF="ch07_13.htm"
TITLE="Flushing Output"
>Recipe 7.12</A
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-1000009578-0"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009578-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-1000009578-2"
></A
>Perl provides functions for buffered and unbuffered input and output. Although there are some exceptions, you shouldn't mix calls to buffered and unbuffered I/O functions. The following table shows the two sets of functions you should not mix. Functions on a particular row are only loosely associated; for instance, <CODE
CLASS="literal"
>sysread</CODE
> doesn't have the same semantics as <CODE
CLASS="literal"
>&lt; &gt;</CODE
>, but they are on the same row because they both read input from a filehandle.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><B
CLASS="emphasis.bold"
>Action</B
></P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Buffered</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unbuffered</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>opening</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>open,sysopen</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>sysopen </CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>closing</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>close</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>close </CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>input</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>&lt;FILE&gt;,readline</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>sysread </CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>output</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>print</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>syswrite </CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>repositioning</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>seek, tell</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>sysseek </CODE
></P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Repositioning is addressed in <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="File Contents"
>Chapter 8</A
>, but we also use it in <A
CLASS="xref"
HREF="ch07_11.htm"
TITLE="Modifying a File in Place Without a Temporary File"
>Recipe 7.10</A
>.<A
CLASS="indexterm"
NAME="ch07-idx-1000009568-0"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_24.htm"
TITLE="6.23. Regular Expression Grabbag"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.23. Regular Expression Grabbag"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_02.htm"
TITLE="7.1. Opening a File"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.1. Opening a File"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.23. Regular Expression Grabbag</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>7.1. Opening a File</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
