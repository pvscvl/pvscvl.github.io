<HTML
><HEAD
>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:43:36Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Perl Cookbook"><LINK
REL="prev"
HREF="ch15_20.htm"
TITLE="15.19. Program: tkshufflepod"><LINK
REL="next"
HREF="ch16_02.htm"
TITLE="16.1. Gathering Output from a Program"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl Cookbook"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Perl Cookbook"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_20.htm"
TITLE="15.19. Program: tkshufflepod"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 15.19. Program: tkshufflepod"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 16</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch16_02.htm"
TITLE="16.1. Gathering Output from a Program"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 16.1. Gathering Output from a Program"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch16-31304"
>16. Process Management and Communication</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch16-39961"
TITLE="16.0. Introduction"
>Introduction</A
><BR><A
CLASS="sect1"
HREF="ch16_02.htm"
TITLE="16.1. Gathering Output from a Program"
>Gathering Output from a Program</A
><BR><A
CLASS="sect1"
HREF="ch16_03.htm"
TITLE="16.2. Running Another Program"
>Running Another Program</A
><BR><A
CLASS="sect1"
HREF="ch16_04.htm"
TITLE="16.3. Replacing the Current Program with a Different One"
>Replacing the Current Program with a Different One</A
><BR><A
CLASS="sect1"
HREF="ch16_05.htm"
TITLE="16.4. Reading or Writing to Another Program"
>Reading or Writing to Another Program</A
><BR><A
CLASS="sect1"
HREF="ch16_06.htm"
TITLE="16.5. Filtering Your Own Output"
>Filtering Your Own Output</A
><BR><A
CLASS="sect1"
HREF="ch16_07.htm"
TITLE="16.6. Preprocessing Input"
>Preprocessing Input</A
><BR><A
CLASS="sect1"
HREF="ch16_08.htm"
TITLE="16.7. Reading STDERR from a Program"
>Reading STDERR from a Program</A
><BR><A
CLASS="sect1"
HREF="ch16_09.htm"
TITLE="16.8. Controlling Input and Output of Another Program"
>Controlling Input and Output of Another Program</A
><BR><A
CLASS="sect1"
HREF="ch16_10.htm"
TITLE="16.9. Controlling the Input, Output, and Error of Another Program"
>Controlling the Input, Output, and Error of Another Program</A
><BR><A
CLASS="sect1"
HREF="ch16_11.htm"
TITLE="16.10. Communicating Between Related Processes"
>Communicating Between Related Processes</A
><BR><A
CLASS="sect1"
HREF="ch16_12.htm"
TITLE="16.11. Making a Process Look Like a File with Named Pipes"
>Making a Process Look Like a File with Named Pipes</A
><BR><A
CLASS="sect1"
HREF="ch16_13.htm"
TITLE="16.12. Sharing Variables in Different Processes"
>Sharing Variables in Different Processes</A
><BR><A
CLASS="sect1"
HREF="ch16_14.htm"
TITLE="16.13. Listing Available Signals"
>Listing Available Signals</A
><BR><A
CLASS="sect1"
HREF="ch16_15.htm"
TITLE="16.14. Sending a Signal"
>Sending a Signal</A
><BR><A
CLASS="sect1"
HREF="ch16_16.htm"
TITLE="16.15. Installing a Signal Handler"
>Installing a Signal Handler</A
><BR><A
CLASS="sect1"
HREF="ch16_17.htm"
TITLE="16.16. Temporarily Overriding a Signal Handler"
>Temporarily Overriding a Signal Handler</A
><BR><A
CLASS="sect1"
HREF="ch16_18.htm"
TITLE="16.17. Writing a Signal Handler"
>Writing a Signal Handler</A
><BR><A
CLASS="sect1"
HREF="ch16_19.htm"
TITLE="16.18. Catching Ctrl-C"
>Catching Ctrl-C</A
><BR><A
CLASS="sect1"
HREF="ch16_20.htm"
TITLE="16.19. Avoiding Zombie Processes"
>Avoiding Zombie Processes</A
><BR><A
CLASS="sect1"
HREF="ch16_21.htm"
TITLE="16.20. Blocking Signals"
>Blocking Signals</A
><BR><A
CLASS="sect1"
HREF="ch16_22.htm"
TITLE="16.21. Timing Out an Operation"
>Timing Out an Operation</A
><BR><A
CLASS="sect1"
HREF="ch16_23.htm"
TITLE="16.22. Program: sigrand"
>Program: sigrand</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>It is quite a three-pipe problem, and I beg that you won't speak to me for fifty minutes.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Sherlock Holmes <CITE
CLASS="citetitle"
>The Red-Headed League </CITE
></P
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch16-39961"
>16.0. Introduction</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006183-0"
></A
>Perl may be many things to many people, but to most of us it is the glue that connects diverse components. This chapter is about launching commands and connecting separate processes together. It's about managing their creation, communication, and ultimate demise. It's about systems programming.</P
><P
CLASS="para"
>When it comes to systems programming, Perl, as usual, makes easy things easy and hard things possible. If you want to use it as you would the shell, Perl is happy to assist you. If you want to roll up your sleeves for low-level hacking like a hardcore C programmer, you can do that, too.</P
><P
CLASS="para"
>Because Perl lets you get so close to the system, portability issues can sneak in. This chapter is the most Unix-centric chapter of the book. It will be tremendously useful to those on Unix systems, but only of limited use to others. We deal with features that aren't as universal as strings and numbers and basic arithmetic. Most basic operations work more or less the same everywhere. But if you're not using some kind of Unix or other POSIX conformant system, most of the interesting features in this chapter may work differently for you&nbsp;- or not at all. Check the documentation that came with your Perl port if you aren't sure.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-chap16_process_1"
>Process Creation</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006185-0"
></A
>In this chapter, we cover the proper care and feeding of your own child processes. Sometimes this means launching a stand-alone command and letting it have its own way with the world (using <CODE
CLASS="literal"
>system</CODE
>). Other times it means keeping a tight rein on your child, feeding it carefully filtered input or taking hold of its output stream (backticks and piped <CODE
CLASS="literal"
>open</CODE
>s). Without even starting a new process, you can use <CODE
CLASS="literal"
>exec</CODE
> to replace your current program with a completely different program.</P
><P
CLASS="para"
>We first show how to use the most portable and commonly used operations for managing processes: backticks, <CODE
CLASS="literal"
>system</CODE
> , <CODE
CLASS="literal"
>open </CODE
>, and the manipulation of the <CODE
CLASS="literal"
>%SIG</CODE
> hash. Those are the easy things, but we don't stop there. We also show what to do when the simple approach isn't good enough.</P
><P
CLASS="para"
>For example, you might want to interrupt your program while it's running a different program. Maybe you need to process a child program's standard error separately from its standard output. Perhaps you need to control both the input and output of a program simultaneously. When you tire of having just one thread of control and begin to take advantage of multitasking, you'll want to learn how to split your current program into several, simultaneously running processes that all talk to each other.</P
><P
CLASS="para"
>For tasks like these, you have to drop back to the underlying system calls: <CODE
CLASS="literal"
>pipe</CODE
>, <CODE
CLASS="literal"
>fork</CODE
> , and <CODE
CLASS="literal"
>exec</CODE
>. The <CODE
CLASS="literal"
>pipe</CODE
><A
CLASS="indexterm"
NAME="ch16-idx-1000006186-0"
></A
> function creates two connected filehandles, a reader and writer, whereby anything written to the writer can be read from the reader. The <CODE
CLASS="literal"
>fork</CODE
><A
CLASS="indexterm"
NAME="ch16-idx-1000006188-0"
></A
> function is the basis of multitasking, but unfortunately it has not been supported on all non-Unix systems. It clones off a duplicate process identical in virtually every aspect to its parent, including variable settings and open files. The most noticable changes are the process ID and parent process ID. New programs are started by forking, then using <CODE
CLASS="literal"
>exec</CODE
><A
CLASS="indexterm"
NAME="ch16-idx-1000006189-0"
></A
> to replace the program in the child process with a new one. You don't always both <CODE
CLASS="literal"
>fork</CODE
> and <CODE
CLASS="literal"
>exec</CODE
> together, so having them as separate primitives is more expressive and powerful than if all you could do is run <CODE
CLASS="literal"
>system </CODE
>. In practice, you're more apt to use <CODE
CLASS="literal"
>fork</CODE
> by itself than <CODE
CLASS="literal"
>exec</CODE
> by itself.</P
><P
CLASS="para"
>When a child process dies, its memory is returned to the operating system, but its entry in the process table isn't freed. This lets a parent check the exit status of its child processes. Processes that have died but haven't been removed from the process table are called <EM
CLASS="emphasis"
>zombie</EM
><A
CLASS="indexterm"
NAME="ch16-idx-1000006187-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000006187-1"
></A
>s, and you should clean them up lest they fill the whole process table. Backticks and the <CODE
CLASS="literal"
>system</CODE
> and <CODE
CLASS="literal"
>open</CODE
> functions automatically take care of this, and will work on most non-Unix systems. You have more to worry about when you go beyond these simple portable functions and use low-level primitives to launch programs. One thing to worry about is signals.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-42227"
>Signals</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006190-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000006190-1"
></A
>Your process is notified of the death of a child it created with a <EM
CLASS="emphasis"
>signal</EM
>. Signals are a kind of notification delivered by the operating system. They are used for errors (when the kernel says, "Hey, you can't touch that area of memory!") and for events (death of a child, expiration of a per-process timer, interrupt with Ctrl-C). If you're launching processes manually, you normally arrange for a subroutine of your choosing to be called whenever one of your children exits.</P
><P
CLASS="para"
>Each process has a default disposition for each possible signal. You may install your own handler or otherwise change the disposition of most signals. Only SIGKILL and SIGSTOP cannot be changed. The rest you can ignore, trap, or block.</P
><P
CLASS="para"
>Briefly, here's a rundown of the more important signals:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>SIGINT</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006200-0"
></A
>is normally triggered by Ctrl-C. This requests that a process interrupt what it's doing. Simple programs like filters usually just die, but more important ones like shells, editors, or FTP programs usually use SIGINT to stop long-running operations so you can tell them to do something else.</P
></DD
><DT
CLASS="term"
>SIGQUIT</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006202-0"
></A
>is also normally generated by a terminal, usually Ctrl-\. Its default behavior is to generate a core dump.</P
></DD
><DT
CLASS="term"
>SIGTERM</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006207-0"
></A
>is sent by the <EM
CLASS="emphasis"
>kill</EM
> shell command when no signal name is explicitly given. Think of it as a polite request for a process to die.</P
></DD
><DT
CLASS="term"
>SIGUSR1 and SIGUSR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006212-0"
></A
>are never caused by system events, so user applications can safely use them for their own purposes.</P
></DD
><DT
CLASS="term"
>SIGPIPE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006217-0"
></A
>is sent by the kernel when your process tries to write to a pipe or socket when the process on the other end has closed its connection, usually because it no longer exists.</P
></DD
><DT
CLASS="term"
>SIGALRM</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006222-0"
></A
>is sent when the timer set by the <CODE
CLASS="literal"
>alarm</CODE
> function expires, as described in <A
CLASS="xref"
HREF="ch16_22.htm"
TITLE="Timing Out an Operation"
>Recipe 16.21</A
>.</P
></DD
><DT
CLASS="term"
>SIGHUP</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006227-0"
></A
>is sent to a process when its controlling terminal gets a hang-up (e.g., the modem lost its carrier), but it also often indicates that a program should restart or reread its configuration.</P
></DD
><DT
CLASS="term"
>SIGCHLD</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000006232-0"
></A
>is probably the most important signal when it comes to low-level systems programming. The system sends your process a SIGCHLD when one of its child processes stops running&nbsp;- or, more likely, when that child exits. See <A
CLASS="xref"
HREF="ch16_20.htm"
TITLE="Avoiding Zombie Processes"
>Recipe 16.19</A
> for more on SIGCHLD.</P
></DD
></DL
><P
CLASS="para"
>Signal names are a convenience for humans. Each signal has an associated number that the operating system uses instead of names. Although we talk about SIGCHLD, your operating system only knows it as a number, like 20 (these numbers vary across operating systems). Perl translates between signal names and numbers for you, so you can think in terms of signal names.</P
><P
CLASS="para"
>Recipes <A
CLASS="xref"
HREF="ch16_16.htm"
TITLE="Installing a Signal Handler"
>Recipe 16.15</A
>, <A
CLASS="xref"
HREF="ch16_18.htm"
TITLE="Writing a Signal Handler"
>Recipe 16.17</A
>, <A
CLASS="xref"
HREF="ch16_22.htm"
TITLE="Timing Out an Operation"
>Recipe 16.21</A
>, <A
CLASS="xref"
HREF="ch16_19.htm"
TITLE="Catching Ctrl-C"
>Recipe 16.18</A
>, and <A
CLASS="xref"
HREF="ch16_21.htm"
TITLE="Blocking Signals"
>Recipe 16.20</A
> run the full gamut of signal handling.<A
CLASS="indexterm"
NAME="ch16-idx-1000006192-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000006192-1"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_20.htm"
TITLE="15.19. Program: tkshufflepod"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 15.19. Program: tkshufflepod"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch16_02.htm"
TITLE="16.1. Gathering Output from a Program"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 16.1. Gathering Output from a Program"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>15.19. Program: tkshufflepod</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>16.1. Gathering Output from a Program</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
