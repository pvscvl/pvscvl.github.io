<HTML
><HEAD
>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:40:22Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Perl Cookbook"><LINK
REL="prev"
HREF="ch10_18.htm"
TITLE="10.17. Program: Sorting Your Mail"><LINK
REL="next"
HREF="ch11_02.htm"
TITLE="11.1. Taking References to Arrays"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl Cookbook"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Perl Cookbook"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_18.htm"
TITLE="10.17. Program: Sorting Your Mail"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.17. Program: Sorting Your Mail"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 11</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm"
TITLE="11.1. Taking References to Arrays"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 11.1. Taking References to Arrays"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch11-17513"
>11. References and Records</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch11-31765"
TITLE="11.0. Introduction"
>Introduction</A
><BR><A
CLASS="sect1"
HREF="ch11_02.htm"
TITLE="11.1. Taking References to Arrays"
>Taking References to Arrays</A
><BR><A
CLASS="sect1"
HREF="ch11_03.htm"
TITLE="11.2. Making Hashes of Arrays"
>Making Hashes of Arrays</A
><BR><A
CLASS="sect1"
HREF="ch11_04.htm"
TITLE="11.3. Taking References to Hashes"
>Taking References to Hashes</A
><BR><A
CLASS="sect1"
HREF="ch11_05.htm"
TITLE="11.4. Taking References to Functions"
>Taking References to Functions</A
><BR><A
CLASS="sect1"
HREF="ch11_06.htm"
TITLE="11.5. Taking References to Scalars"
>Taking References to Scalars</A
><BR><A
CLASS="sect1"
HREF="ch11_07.htm"
TITLE="11.6. Creating Arrays of Scalar References"
>Creating Arrays of Scalar References</A
><BR><A
CLASS="sect1"
HREF="ch11_08.htm"
TITLE="11.7. Using Closures Instead of Objects"
>Using Closures Instead of Objects</A
><BR><A
CLASS="sect1"
HREF="ch11_09.htm"
TITLE="11.8. Creating References to Methods"
>Creating References to Methods</A
><BR><A
CLASS="sect1"
HREF="ch11_10.htm"
TITLE="11.9. Constructing Records"
>Constructing Records</A
><BR><A
CLASS="sect1"
HREF="ch11_11.htm"
TITLE="11.10. Reading and Writing Hash Records to Text Files"
>Reading and Writing Hash Records to Text Files</A
><BR><A
CLASS="sect1"
HREF="ch11_12.htm"
TITLE="11.11. Printing Data Structures"
>Printing Data Structures</A
><BR><A
CLASS="sect1"
HREF="ch11_13.htm"
TITLE="11.12. Copying Data Structures"
>Copying Data Structures</A
><BR><A
CLASS="sect1"
HREF="ch11_14.htm"
TITLE="11.13. Storing Data Structures to Disk"
>Storing Data Structures to Disk</A
><BR><A
CLASS="sect1"
HREF="ch11_15.htm"
TITLE="11.14. Transparently Persistent Data Structures"
>Transparently Persistent Data Structures</A
><BR><A
CLASS="sect1"
HREF="ch11_16.htm"
TITLE="11.15. Program: Binary Trees"
>Program: Binary Trees</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>With as little a web as this will I ensnare as great a fly as Cassio.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Shakespeare <CITE
CLASS="citetitle"
>Othello, Act II, scene i </CITE
></P
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch11-31765"
>11.0. Introduction</A
></H2
><P
CLASS="para"
>Perl provides three fundamental data types: scalars, arrays, and hashes. It's certainly possible to write many programs without recourse to complex records, but most programs need something more complex than simple variables and lists.</P
><P
CLASS="para"
>Perl's three built-in types combine with references to produce arbitrarily complex and powerful data structures, the records that users of ancient versions of Perl desperately yearned for. Selecting the proper data structure and algorithm can make the difference between an elegant program that does its job quickly and an ungainly concoction that's glacially slow to execute and consumes system resources voraciously.</P
><P
CLASS="para"
>The first part of this chapter shows how to create and use plain references. The second part shows how to use references to create higher order data structures.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-chap11_references_1"
>References</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-1000004778-0"
></A
>To grasp the concept of references, you must first understand how Perl stores values in variables. Each defined variable has a name and the address of a chunk of memory associated with it. This idea of storing addresses is fundamental to references because a reference is a value that holds the location of another value. The scalar value that contains the memory address is called a <EM
CLASS="emphasis"
>reference</EM
>. Whatever value lives at that memory address is called a <EM
CLASS="emphasis"
>referent</EM
><A
CLASS="indexterm"
NAME="ch11-idx-1000004785-0"
></A
>. (You may also call it a "thingie" if you prefer to live a whimsical existence.) See <A
CLASS="xref"
HREF="ch11_01.htm"
TITLE="Reference and referent"
>Figure 11.1</A
>.</P
><P
CLASS="para"
>The referent could be any of Perl's built-in types (scalar, array, hash, ref, code, or glob) or a user-defined type based on one of the built-in ones.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch11-12670"
>Figure 11.1: Reference and referent</A
></H4
><IMG
CLASS="graphic"
SRC="figs/pcb_1101.gif"
ALT="Figure 11.1"><P
CLASS="para"
>Referents in Perl are <EM
CLASS="emphasis"
>typed</EM
><A
CLASS="indexterm"
NAME="ch11-idx-1000004784-0"
></A
>. This means you can't treat a reference to an array as though it were a reference to a hash, for example. Attempting to do so produces a runtime exception. No mechanism for type casting exists in Perl. This is considered a feature.</P
><P
CLASS="para"
>So far, it may look as though a reference were little more than a raw address with strong typing. But it's far more than that. Perl takes care of automatic memory allocation and deallocation (garbage collection) for references, just as it does for everything else. Every chunk of memory in Perl has a <EM
CLASS="emphasis"
>reference count</EM
><A
CLASS="indexterm"
NAME="ch11-idx-1000004786-0"
></A
> associated with it, representing how many places know about that referent. The memory used by a referent is not returned to the process's free pool until its reference count reaches zero. This ensures that you never have a reference that isn't valid &nbsp;-  no more core dumps and general protection faults from mismanaged pointers as in C.</P
><P
CLASS="para"
>Freed memory is returned to Perl for later use, but few operating systems reclaim it and decrease the process's memory footprint. This is because most memory allocators use a stack, and if you free up memory in the middle of the stack, the operating system can't take it back without moving the rest of the allocated memory around. That would destroy the integrity of your pointers and blow XS code out of the water.</P
><P
CLASS="para"
>To follow a reference to its referent, preface the reference with the appropriate type symbol for the data you're accessing. For instance, if <CODE
CLASS="literal"
>$sref</CODE
> is a reference to a scalar, you can say:</P
><PRE
CLASS="programlisting"
>print $$sref;    # prints the scalar value that the reference $sref refers to
$$sref = 3;      # assigns to $sref's referent</PRE
><P
CLASS="para"
>To access one element of an array or hash whose reference you have, use the <A
CLASS="indexterm"
NAME="ch11-idx-1000004787-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-1000004787-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-1000004787-2"
></A
>infix pointer-arrow notation, as in <CODE
CLASS="literal"
>$rv-&gt;[37]</CODE
> or <CODE
CLASS="literal"
>$rv-&gt;{&quot;wilma&quot;}</CODE
>. Besides dereferencing array references and hash references, the arrow is also used to call an indirect function through its reference, as in <CODE
CLASS="literal"
>$code_ref-&gt;(&quot;arg1&quot;,</CODE
> <CODE
CLASS="literal"
>&quot;arg2&quot;)</CODE
>; this is discussed <A
CLASS="xref"
HREF="ch11_05.htm"
TITLE="Taking References to Functions"
>Recipe 11.4</A
>. If you're using an object, use an arrow to call a method, <CODE
CLASS="literal"
>$object-&gt;methodname(&quot;arg1&quot;,</CODE
><SPAN
CLASS="acronym"
> </SPAN
><CODE
CLASS="literal"
>&quot;arg2&quot;)</CODE
>, as shown in <A
CLASS="xref"
HREF="ch13_01.htm"
TITLE="Classes, Objects, and Ties"
>Chapter 13, <CITE
CLASS="chapter"
>Classes, Objects, and Ties</CITE
></A
>.</P
><P
CLASS="para"
>Perl's syntax rules make dereferencing complex expressions tricky &nbsp;-  it falls into the category of "hard things that should be possible." Mixing right associative and left associative operators doesn't work out well. For example, <CODE
CLASS="literal"
>$$x[4]</CODE
> is the same as <CODE
CLASS="literal"
>$x-&gt;[4]</CODE
>; that is, it treats <CODE
CLASS="literal"
>$x</CODE
> as a reference to an array and then extracts element number four from that. This could also have been written <CODE
CLASS="literal"
>${$x}[4]</CODE
>. If you really meant "take the fifth element of <CODE
CLASS="literal"
>@x</CODE
> and dereference it as a scalar reference," then you need to use <CODE
CLASS="literal"
>${$x[4]}</CODE
>. You should avoid putting two type signs (<CODE
CLASS="literal"
>$@%&amp;</CODE
>) side-by-side, unless it's simple and unambiguous like <CODE
CLASS="literal"
>%hash</CODE
> <CODE
CLASS="literal"
>=</CODE
> <CODE
CLASS="literal"
>%$hashref</CODE
>.</P
><P
CLASS="para"
>In the simple cases using <CODE
CLASS="literal"
>$$sref</CODE
> above, you could have written:</P
><PRE
CLASS="programlisting"
>print ${$sref};             # prints the scalar $sref refers to
${$sref} = 3;               # assigns to $sref's referent</PRE
><P
CLASS="para"
>For safety, some programmers use this notation exclusively.</P
><P
CLASS="para"
>When passed a reference, the <CODE
CLASS="literal"
>ref</CODE
><A
CLASS="indexterm"
NAME="ch11-idx-1000004788-0"
></A
> function returns a string describing its referent. (It returns false if passed a non-reference.) This string is usually one of SCALAR, ARRAY, HASH, or CODE, although the other built-in types of GLOB, REF, IO, Regexp, and LVALUE also occasionally appear. If you call <CODE
CLASS="literal"
>ref</CODE
> on a non-reference, it returns an empty string. If you call <CODE
CLASS="literal"
>ref</CODE
> on an object (a reference whose referent has been blessed), it returns the class the object was blessed into: CGI, IO::Socket, or even ACME::Widget.</P
><P
CLASS="para"
>You can create references in Perl by taking references to things that are already there or by using the <CODE
CLASS="literal"
>[</CODE
> <CODE
CLASS="literal"
>]</CODE
>, <CODE
CLASS="literal"
>{</CODE
> <CODE
CLASS="literal"
>}</CODE
>, and <CODE
CLASS="literal"
>sub</CODE
> <CODE
CLASS="literal"
>{</CODE
> <CODE
CLASS="literal"
>}</CODE
> composers. The backslash operator is simple to use: put it before the thing you want a reference to. For instance, if you want a reference to the contents of <CODE
CLASS="literal"
>@array</CODE
>, just say:</P
><PRE
CLASS="programlisting"
>$aref = \@array;</PRE
><P
CLASS="para"
>You can even create references to constant values;  future attempts to change the value of the referent will cause a runtime error:</P
><PRE
CLASS="programlisting"
>$pi = \3.14159;
$$pi = 4;           # runtime error<A
CLASS="indexterm"
NAME="ch11-idx-1000004779-0"
></A
></PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-chap11_anonymous_0"
>Anonymous Data</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-1000004780-0"
></A
>Taking references to existing data is helpful when you're using pass-by-reference in a function call, but for dynamic programming, it becomes cumbersome. You need to be able to grow data structures at will, to allocate new arrays and hashes (or scalars or functions) on demand. You don't want to be bogged down with having to give them names each time.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-1000004789-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-1000004789-1"
></A
>Perl can explicitly create anonymous arrays and hashes, which allocate a new array or hash and return a reference to that memory:</P
><PRE
CLASS="programlisting"
>$aref = [ 3, 4, 5 ];                                # new anonymous array
$href = { &quot;How&quot; =&gt; &quot;Now&quot;, &quot;Brown&quot; =&gt; &quot;Cow&quot; };       # new anonymous hash</PRE
><P
CLASS="para"
>Perl can also create a reference implicitly by <EM
CLASS="emphasis"
>autovivification</EM
><A
CLASS="indexterm"
NAME="ch11-idx-1000004790-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-1000004790-1"
></A
>. This is what happens when you try to assign through an undefined references and Perl automatically creates the reference you're trying to use.</P
><PRE
CLASS="programlisting"
>undef $aref;
@$aref = (1, 2, 3);
print $aref;
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>ARRAY(0x80c04f0)</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
>Notice how we went from an undefined variable to one with an array reference in it without actually assigning anything? Perl filled in the undefined reference for you. This is the property that permits something like this to work as the first statement in your program:</P
><PRE
CLASS="programlisting"
>$a[4][23][53][21] = &quot;fred&quot;;
print $a[4][23][53][21];
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>fred</I
></CODE
></B
></CODE
>
print $a[4][23][53];
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>ARRAY(0x81e2494)</I
></CODE
></B
></CODE
>
print $a[4][23];
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>ARRAY(0x81e0748)</I
></CODE
></B
></CODE
>
print $a[4];
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>ARRAY(0x822cd40)</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
>The following table shows mechanisms for producing references to both named and anonymous scalars, arrays, hashes, and functions. (Anonymous typeglobs are too scary to show &nbsp;-  and virtually never used. It's best to use <CODE
CLASS="literal"
>Symbol::gensym()</CODE
> or <CODE
CLASS="literal"
>IO::Handle-&gt;new()</CODE
> for them.)</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Reference to</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Named</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Anonymous</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Scalar</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>\$scalar</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>\do{my $anon}</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Array</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>\@array</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>[ LIST ]</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Hash</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>\%hash</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>{ LIST }</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Code</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>\&amp;function</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>sub { CODE } </CODE
></P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>These diagrams illustrate the differences between named and anonymous values. <A
CLASS="xref"
HREF="ch11_01.htm"
TITLE="Named values"
>Figure 11.2</A
> shows named values.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch11-17738"
>Figure 11.2: Named values</A
></H4
><IMG
CLASS="graphic"
SRC="figs/pcb_1102.gif"
ALT="Figure 11.2"><P
CLASS="para"
>In other words, saying <CODE
CLASS="literal"
>$a</CODE
> <CODE
CLASS="literal"
>=</CODE
> <CODE
CLASS="literal"
>\$b</CODE
> makes <CODE
CLASS="literal"
>$$a</CODE
> and <CODE
CLASS="literal"
>$b</CODE
> the <EM
CLASS="emphasis"
>same piece of memory</EM
>. If you say <CODE
CLASS="literal"
>$$a</CODE
> <CODE
CLASS="literal"
>=</CODE
> <CODE
CLASS="literal"
>3</CODE
>, then the value of <CODE
CLASS="literal"
>$b</CODE
> is set to 3.</P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch11_01.htm"
TITLE="Anonymous values"
>Figure 11.3</A
> shows anonymous values.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch11-31355"
>Figure 11.3: Anonymous values</A
></H4
><IMG
CLASS="graphic"
SRC="figs/pcb_1103.gif"
ALT="Figure 11.3"><P
CLASS="para"
>Every reference evaluates as true, by definition, so if you write a subroutine that returns a reference, you can return <CODE
CLASS="literal"
>undef</CODE
> on error and check for it with:</P
><PRE
CLASS="programlisting"
>$op_cit = cite($ibid)       or die &quot;couldn't make a reference&quot;;</PRE
><P
CLASS="para"
>The <CODE
CLASS="literal"
>undef</CODE
><A
CLASS="indexterm"
NAME="ch11-idx-1000004791-0"
></A
> operator can be used on any variable or function in Perl to free its memory. This does not necessarily free memory, call object destructors, etc. It just decrements the reference count by one.<A
CLASS="indexterm"
NAME="ch11-idx-1000004781-0"
></A
> Without an argument, <CODE
CLASS="literal"
>undef</CODE
> produces an undefined value.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-chap11_records_0"
>Records</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-1000004782-0"
></A
>The classic use of references in Perl is to circumvent the restriction that arrays and hashes may hold scalars only. References are scalars, so to make an array of arrays, make an array of array <EM
CLASS="emphasis"
>references</EM
>. Similarly, hashes of hashes are implemented as hashes of hash references, arrays of hashes as arrays of hash references, hashes of arrays as hashes of array references, and so on.</P
><P
CLASS="para"
>Once you have these complex structures, you can use them to implement records. A record is a single logical unit composed of different attributes. For instance, a name, an address, and a birthday might comprise a record representing a person. C calls such things <EM
CLASS="emphasis"
>structs</EM
>, and Pascal calls them <EM
CLASS="emphasis"
>RECORDs</EM
>. Perl doesn't have a particular name for these because you can implement this notion in different ways.</P
><P
CLASS="para"
>The most common technique in Perl is to treat a hash as a record, where the keys of the hash are the record's field names and the values of the hash are those fields' values.</P
><P
CLASS="para"
>For instance, we might create a "person" record like this:</P
><PRE
CLASS="programlisting"
>$Nat = { &quot;Name&quot;     =&gt; &quot;Leonhard Euler&quot;,
         &quot;Address&quot;  =&gt; &quot;1729 Ramanujan Lane\nMathworld, PI 31416&quot;,
         &quot;Birthday&quot; =&gt; 0x5bb5580,
       };</PRE
><P
CLASS="para"
>Because <CODE
CLASS="literal"
>$Nat</CODE
> is a scalar, it can be stored in an array or hash element, thus creating create groups of people. Now apply the array and hash techniques from Chapters 4 and 5 to sort the sets, merge hashes, pick a random record, and so on.</P
><P
CLASS="para"
>The attributes of a record, including the "person" record, are always scalars. You can certainly use numbers as readily as strings there, but that's no great trick. The real power play happens when you use even more references for values in the record. <CODE
CLASS="literal"
>&quot;Birthday&quot;</CODE
>, for instance, might be stored as an anonymous array with three elements: day, month, and year. You could then say <CODE
CLASS="literal"
>$person-&gt;{&quot;Birthday&quot;}-&gt;[0]</CODE
> to access just the day field. Or a date might be represented as a hash record, which would then lend itself to access such as <CODE
CLASS="literal"
>$person-&gt;{&quot;Birthday&quot;}-&gt;{&quot;day&quot;}</CODE
>. Adding references to your collection of skills makes possible many more complex and useful programming strategies.</P
><P
CLASS="para"
>At this point, we've conceptually moved beyond simple records. We're now creating elaborate data structures that represent complicated relationships between the data they hold. Although we <EM
CLASS="emphasis"
>can</EM
> use these to implement traditional data structures like linked lists, the recipes in the second half of this chapter don't deal specifically with any particular structure. Instead, they give generic techniques for loading, printing, copying, and saving generic data structures. The final program example demonstrates how to manipulate binary trees.<A
CLASS="indexterm"
NAME="ch11-idx-1000004783-0"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-pgfId-180"
>See Also</A
></H3
><P
CLASS="para"
><A
CLASS="olink"
HREF="../prog/ch04_01.htm"
>Chapter 4</A
> of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>; <I
CLASS="filename"
>perlref </I
>(1), <I
CLASS="filename"
>perllol</I
> (1), and <I
CLASS="filename"
>perldsc</I
> (1)</P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_18.htm"
TITLE="10.17. Program: Sorting Your Mail"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.17. Program: Sorting Your Mail"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm"
TITLE="11.1. Taking References to Arrays"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 11.1. Taking References to Arrays"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>10.17. Program: Sorting Your Mail</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>11.1. Taking References to Arrays</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
