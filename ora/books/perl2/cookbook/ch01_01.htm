<HTML
><HEAD
>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:28:25Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Perl Cookbook"><LINK
REL="prev"
HREF="prf2_06.htm"
TITLE="Acknowledgments"><LINK
REL="next"
HREF="ch01_02.htm"
TITLE="1.1. Accessing Substrings"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl Cookbook"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Perl Cookbook"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="prf2_06.htm"
TITLE="Acknowledgments"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: Acknowledgments"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 1</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.1. Accessing Substrings"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.1. Accessing Substrings"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch01-19248"
>1. Strings</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch01-26961"
TITLE="1.0. Introduction"
>Introduction</A
><BR><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.1. Accessing Substrings"
>Accessing Substrings</A
><BR><A
CLASS="sect1"
HREF="ch01_03.htm"
TITLE="1.2. Establishing a Default Value"
>Establishing a Default Value</A
><BR><A
CLASS="sect1"
HREF="ch01_04.htm"
TITLE="1.3. Exchanging Values Without Using Temporary Variables"
>Exchanging Values Without Using Temporary Variables</A
><BR><A
CLASS="sect1"
HREF="ch01_05.htm"
TITLE="1.4. Converting Between ASCII Characters and Values"
>Converting Between ASCII Characters and Values</A
><BR><A
CLASS="sect1"
HREF="ch01_06.htm"
TITLE="1.5. Processing a String One Character at a Time"
>Processing a String One Character at a Time</A
><BR><A
CLASS="sect1"
HREF="ch01_07.htm"
TITLE="1.6. Reversing a String by Word or Character"
>Reversing a String by Word or Character</A
><BR><A
CLASS="sect1"
HREF="ch01_08.htm"
TITLE="1.7. Expanding and Compressing Tabs"
>Expanding and Compressing Tabs</A
><BR><A
CLASS="sect1"
HREF="ch01_09.htm"
TITLE="1.8. Expanding Variables in User Input"
>Expanding Variables in User Input</A
><BR><A
CLASS="sect1"
HREF="ch01_10.htm"
TITLE="1.9. Controlling Case"
>Controlling Case</A
><BR><A
CLASS="sect1"
HREF="ch01_11.htm"
TITLE="1.10. Interpolating Functions and Expressions Within Strings"
>Interpolating Functions and Expressions Within Strings</A
><BR><A
CLASS="sect1"
HREF="ch01_12.htm"
TITLE="1.11. Indenting Here Documents"
>Indenting Here Documents</A
><BR><A
CLASS="sect1"
HREF="ch01_13.htm"
TITLE="1.12. Reformatting Paragraphs"
>Reformatting Paragraphs</A
><BR><A
CLASS="sect1"
HREF="ch01_14.htm"
TITLE="1.13. Escaping Characters"
>Escaping Characters</A
><BR><A
CLASS="sect1"
HREF="ch01_15.htm"
TITLE="1.14. Trimming Blanks from the Ends of a String"
>Trimming Blanks from the Ends of a String</A
><BR><A
CLASS="sect1"
HREF="ch01_16.htm"
TITLE="1.15. Parsing Comma-Separated Data"
>Parsing Comma-Separated Data</A
><BR><A
CLASS="sect1"
HREF="ch01_17.htm"
TITLE="1.16. Soundex Matching"
>Soundex Matching</A
><BR><A
CLASS="sect1"
HREF="ch01_18.htm"
TITLE="1.17. Program: fixstyle"
>Program: fixstyle</A
><BR><A
CLASS="sect1"
HREF="ch01_19.htm"
TITLE="1.18. Program: psgrep"
>Program: psgrep</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>He multiplieth words without knowledge.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Job 35:16 </P
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch01-26961"
>1.0. Introduction</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-1000010110-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010110-1"
></A
>Many programming languages force you to work at an uncomfortably low level. You think in lines, but your language wants you to deal with pointers. You think in strings, but it wants you to deal with bytes. Such a language can drive you to distraction. Don't despair, though &nbsp;-  Perl isn't a low-level language; lines and strings are easy to handle.</P
><P
CLASS="para"
>Perl was <EM
CLASS="emphasis"
>designed</EM
> for text manipulation. In fact, Perl can manipulate text in so many ways that they can't all be described in one chapter. Check out other chapters for recipes on text processing. In particular, see <A
CLASS="xref"
HREF="ch06_01.htm"
TITLE="Pattern Matching"
>Chapter 6, <CITE
CLASS="chapter"
>Pattern Matching</CITE
></A
>, and <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="File Contents"
>Chapter 8, <CITE
CLASS="chapter"
>File Contents</CITE
></A
>, which discuss interesting techniques not covered here.</P
><P
CLASS="para"
>Perl's fundamental unit for working with data is the <A
CLASS="indexterm"
NAME="ch01-idx-1000010112-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010112-1"
></A
>scalar, that is, single values stored in single (scalar) variables. Scalar variables hold strings, numbers, and references. Array and hash variables hold lists or associations of scalars, respectively. References are used for referring to other values indirectly, not unlike pointers in low-level languages. Numbers are usually stored in your machine's double-precision floating-point notation. Strings in Perl may be of any length (within the limits of your machine's virtual memory) and contain any data you care to put there&nbsp;- even binary data containing null bytes.</P
><P
CLASS="para"
>A string is not an array of bytes: You cannot use array subscripting on a string to address one of its characters; use <CODE
CLASS="literal"
>substr</CODE
> for that. Like all data types in Perl, strings grow and shrink on demand. They get reclaimed by Perl's garbage collection system when they're no longer used, typically when the variables holding them go out of scope or when the expression they were used in has been evaluated. In other words, memory management is already taken care of for you, so you don't have to worry about it.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-1000010113-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010113-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010113-2"
></A
>A scalar value is either defined or undefined. If defined, it may hold a string, number, or reference. The only undefined value is <CODE
CLASS="literal"
>undef</CODE
>. All other values are defined, even 0 and the empty string. Definedness is not the same as Boolean <A
CLASS="indexterm"
NAME="ch01-idx-1000010679-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010679-1"
></A
>truth, though; to check whether a value is defined, use the <CODE
CLASS="literal"
>defined</CODE
> function. Boolean truth has a specialized meaning, tested with operators like <CODE
CLASS="literal"
>&amp;&amp;</CODE
> and <CODE
CLASS="literal"
>||</CODE
> or in an <CODE
CLASS="literal"
>if</CODE
> or <CODE
CLASS="literal"
>while</CODE
> block's test condition.</P
><P
CLASS="para"
>Two defined strings are <A
CLASS="indexterm"
NAME="ch01-idx-1000010114-0"
></A
>false: the <A
CLASS="indexterm"
NAME="ch01-idx-1000010115-0"
></A
>empty string (&quot;&quot;) and a string of length one containing the digit zero (&quot;<CODE
CLASS="literal"
>0</CODE
>&quot;). This second one may surprise you, but Perl does this because of its on-demand conversion between strings and numbers. The numbers <CODE
CLASS="literal"
>0.</CODE
>, <CODE
CLASS="literal"
>0.00</CODE
>, and <CODE
CLASS="literal"
>0.0000000</CODE
> are all false when unquoted but are not false in strings (the string &quot;<CODE
CLASS="literal"
>0.00</CODE
>&quot; is true, not false). All other defined values (e.g., &quot;<CODE
CLASS="literal"
>false</CODE
>&quot;, <CODE
CLASS="literal"
>15</CODE
>, and <CODE
CLASS="literal"
>\$x </CODE
>) are true.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>undef</CODE
> value behaves like the empty string (&quot;&quot;) when used as a string, <CODE
CLASS="literal"
>0</CODE
> when used as a number, and the null reference when used as a reference. But in all these cases, it's false. Using an undefined value where Perl expects a defined value will trigger a run-time warning message on STDERR if you've used the <B
CLASS="emphasis.bold"
>-w</B
> flag. Merely asking whether something is true or false does not demand a particular value, so this is exempt from a warning. Some operations do not trigger warnings when used on variables holding undefined values. These include the autoincrement and autodecrement operators, <CODE
CLASS="literal"
>++</CODE
> and <CODE
CLASS="literal"
>--</CODE
>, and the addition and catenation assignment operators, <CODE
CLASS="literal"
>+=</CODE
> and <CODE
CLASS="literal"
>.=</CODE
> .</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-1000010116-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010116-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010116-2"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-1000010116-3"
></A
>Specify strings in your program either with single quotes, double quotes, the quote-like operators <CODE
CLASS="literal"
>q//</CODE
> and <CODE
CLASS="literal"
>qq//</CODE
>, or "here documents." Single quotes are the simplest form of quoting&nbsp;- the only special characters are <CODE
CLASS="literal"
>'</CODE
> to terminate the string, <CODE
CLASS="literal"
>\'</CODE
> to quote a single quote in the string, and <CODE
CLASS="literal"
>\\</CODE
> to quote a backslash in the string:</P
><PRE
CLASS="programlisting"
>$string = '\n';                     # two characters, \ and an n
$string = 'Jon \'Maddog\' Orwant';  # literal single quotes</PRE
><P
CLASS="para"
>Double quotes interpolate variables (but not function calls&nbsp;- see <A
CLASS="xref"
HREF="ch01_11.htm"
TITLE="Interpolating Functions and Expressions Within Strings"
>Recipe 1.10</A
> to find how to do this) and expand a lot of backslashed shortcuts: &quot;<CODE
CLASS="literal"
>\n</CODE
>&quot; becomes a newline, &quot;<CODE
CLASS="literal"
>\033</CODE
>&quot; becomes the character with octal value 33, &quot;<CODE
CLASS="literal"
>\cJ</CODE
>&quot; becomes a Ctrl-J, and so on. The full list of these is given in the <EM
CLASS="emphasis"
>perlop </EM
>(1) manpage.</P
><PRE
CLASS="programlisting"
>$string = &quot;\n&quot;;                     # a &quot;newline&quot; character
$string = &quot;Jon \&quot;Maddog\&quot; Orwant&quot;;  # literal double quotes</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-1000010118-0"
></A
>The <CODE
CLASS="literal"
>q//</CODE
> and <CODE
CLASS="literal"
>qq//</CODE
> regexp-like quoting operators let you use alternate delimiters for single- and double-quoted strings. For instance, if you want a literal string that contains single quotes, it's easier to write this than to escape the single quotes with backslashes:</P
><PRE
CLASS="programlisting"
>$string = q/Jon 'Maddog' Orwant/;   # literal single quotes</PRE
><P
CLASS="para"
>You can use the same character as delimiter, as we do with / here, or you can balance the delimiters if you use parentheses or paren-like characters:</P
><PRE
CLASS="programlisting"
>$string = q[Jon 'Maddog' Orwant];   # literal single quotes
$string = q{Jon 'Maddog' Orwant};   # literal single quotes
$string = q(Jon 'Maddog' Orwant);   # literal single quotes
$string = q&lt;Jon 'Maddog' Orwant&gt;;   # literal single quotes</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-1000010130-0"
></A
>"Here documents" are borrowed from the shell. They are a way to quote a large chunk of text. The text can be interpreted as single-quoted, double-quoted, or even as commands to be executed, depending on how you quote the terminating identifier. Here we double-quote two lines with a here document:</P
><PRE
CLASS="programlisting"
>$a = &lt;&lt;&quot;EOF&quot;;
This is a multiline here document
terminated by EOF on a line by itself
EOF</PRE
><P
CLASS="para"
>Note there's no semicolon after the terminating <CODE
CLASS="literal"
>EOF</CODE
>. Here documents are covered in more detail in <A
CLASS="xref"
HREF="ch01_12.htm"
TITLE="Indenting Here Documents"
>Recipe 1.11</A
>.</P
><P
CLASS="para"
>A warning for non-Western programmers: Perl doesn't currently directly support multibyte characters (expect <A
CLASS="indexterm"
NAME="ch01-idx-1000010687-0"
></A
>Unicode support in 5.006), so we'll be using the terms <EM
CLASS="emphasis"
>byte</EM
> and <EM
CLASS="emphasis"
>character</EM
> interchangeably.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="prf2_06.htm"
TITLE="Acknowledgments"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: Acknowledgments"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.1. Accessing Substrings"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.1. Accessing Substrings"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>Acknowledgments</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.1. Accessing Substrings</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
