<HTML
><HEAD
>
<TITLE>4.7 Subroutines (Perl in a Nutshell)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl in a Nutshell"><META
NAME="DC.creator"
CONTENT="Ellen Siever, Stephen Spainhour &amp; Nathan Patwardhan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:32:18Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-286-7"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. The Perl Language"><LINK
REL="prev"
HREF="ch04_06.htm"
TITLE="4.6 Regular Expressions"><LINK
REL="next"
HREF="ch04_08.htm"
TITLE="4.8 References and Complex Data Structures"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl in a Nutshell"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,71"
HREF="index.htm"
ALT="Perl in a Nutshell"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_06.htm"
TITLE="4.6 Regular Expressions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.6 Regular Expressions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. The Perl Language"
>Chapter 4<BR>The Perl Language</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_08.htm"
TITLE="4.8 References and Complex Data Structures"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.8 References and Complex Data Structures"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-7"
>4.7 Subroutines</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="PNUT-CH-4-IX-SUBROUTINES"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5864"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5867"
></A
>Subroutines are declared using one of these forms:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sub <EM
CLASS="emphasis"
>name</EM
> {<EM
CLASS="emphasis"
>block</EM
>}
sub <EM
CLASS="emphasis"
>name</EM
> (<EM
CLASS="emphasis"
>proto</EM
>) {<EM
CLASS="emphasis"
>block</EM
>}</PRE
></BLOCKQUOTE
>

<A
CLASS="indexterm"
NAME="AUTOID-5875"
></A
>
Prototypes allow you to put constraints on the arguments you provide to
your subroutines.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5878"
></A
>You can also create anonymous subroutines at run-time, which will
be available for use through a reference:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$<EM
CLASS="emphasis"
>subref</EM
> = sub {<EM
CLASS="emphasis"
>block</EM
>};</PRE
></BLOCKQUOTE
>
&#13;</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-7.1"
>4.7.1 Calling Subroutines</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5886"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5889"
></A
>The ampersand (<CODE
CLASS="literal"
>&amp;</CODE
>) is the identifier used to
call subroutines. 
Most of the
time, however, subroutines can be used in an
expression just like built-in functions. 
To call subroutines directly:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
><EM
CLASS="emphasis"
>name</EM
>(<EM
CLASS="emphasis"
>args</EM
>);                  # &amp; is optional with parentheses
<EM
CLASS="emphasis"
>name</EM
> <EM
CLASS="emphasis"
>args</EM
>;                   # Parens optional if predeclared/imported
&amp;<EM
CLASS="emphasis"
>name;</EM
>                       # Passes current @_ to subroutine</PRE
></BLOCKQUOTE
>


To call subroutines indirectly (by name or by reference):


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>&amp;$subref(<EM
CLASS="emphasis"
>args</EM
>);                 # &amp; is not optional on indirect call
&amp;$subref;                       # Passes current @_ to subroutine</PRE
></BLOCKQUOTE
>
&#13;</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-7.2"
>4.7.2 Passing Arguments</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5904"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5906"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5908"
></A
>All arguments to a subroutine are passed as a single, flat list of scalars,
and return values are returned the same way.
Any arrays or hashes passed in these
lists will have their values interpolated into the flattened list.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5912"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5915"
></A
>Any arguments passed to a
subroutine come in as the array <CODE
CLASS="literal"
>@_</CODE
>. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5920"
></A
>You may use the explicit <CODE
CLASS="literal"
>return</CODE
> statement to return 
a value and leave the subroutine
at any point. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-7.3"
>4.7.3 Passing References</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5926"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5929"
></A
>If you want to pass more than one array or hash into or out of a function
and have them maintain their integrity, then you will want
to pass references as arguments. The simplest way to do this
is to take your named variables and put a backslash in front of them
in the argument list:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>@returnlist = ref_conversion(<EM
CLASS="emphasis"
>\@temps1, \@temps2, \@temps3</EM
>);</PRE
></BLOCKQUOTE
>


This sends references to the three arrays to the subroutine (and saves you
the step of creating your own named references to send to the function).
The references to the arrays are passed to the subroutine as the three-member
<CODE
CLASS="literal"
>@_</CODE
> array. The subroutine will have to dereference the arguments 
so that the data values may be used. </P
><P
CLASS="para"
>Returning references is a simple matter of returning scalars that are
references. This way you can return distinct hashes and arrays. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-7.4"
>4.7.4 Private and Local Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5938"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5941"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5943"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5945"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5948"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5950"
></A
>Any variables you use in the function that aren't declared private are
global variables. In subroutines, you'll often want to use variables
that won't be used anywhere else in your program, and you don't
want them taking up memory when the subroutine is not being executed.
You also might not want to alter variables in subroutines that might
have the same name as global variables.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5954"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5956"
></A
>The <CODE
CLASS="literal"
>my</CODE
> function declares variables
that are <EM
CLASS="emphasis"
>lexically scoped</EM
> within the subroutine. Lexically scoped
variables are private variables that only exist within the block or
subroutine in which they are declared. 
Outside of their scope, they are invisible and can't be altered in any way.</P
><P
CLASS="para"
>To scope multiple variables at once, use a list in parentheses. You can
also assign a variable in a <CODE
CLASS="literal"
>my</CODE
> statement:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>my @list = (44, 55, 66);
my $cd = &quot;orb&quot;;</PRE
></BLOCKQUOTE
>

<A
CLASS="indexterm"
NAME="AUTOID-5963"
></A
>
Dynamic variables are visible to other subroutines
called from within their scope. Dynamic variables are defined
with <CODE
CLASS="literal"
>local</CODE
>, and they are not private variables, but rather they are 
global variables with temporary values. When a subroutine is executed, the
global value is hidden away, and the local value is used. Once the
scope is exited, the original global value is used. Most of the
time you will want to use <CODE
CLASS="literal"
>my</CODE
> to localize parameters in a subroutine.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-7.5"
>4.7.5 Prototypes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5970"
></A
>Prototypes allow you to design your subroutines to take arguments with
constraints on the number of parameters and types of data. 
To declare a function with prototypes, use the prototype symbols 
in the declaration line, like this:<A
CLASS="indexterm"
NAME="AUTOID-5972"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5975"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5978"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5981"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5984"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5987"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5990"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5993"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5996"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5999"
></A
>


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sub addem ($$) {
...
}</PRE
></BLOCKQUOTE
>


In this case, the function expects two scalar arguments.
The following table gives the various prototype symbols:<A
CLASS="indexterm"
NAME="AUTOID-6003"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6005"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6007"
></A
>

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Symbol</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Scalar</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>@</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>List</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>%</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Hash</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Anonymous subroutine</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Typeglob</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6036"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6039"
></A
>
A backslash placed before one of these symbols forces the argument
to be that exact variable type. For instance, a function that requires
a hash variable would be declared like this:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sub hashfunc (\%);</PRE
></BLOCKQUOTE
>


Unbackslashed <CODE
CLASS="literal"
>@</CODE
> or <CODE
CLASS="literal"
>%</CODE
> symbols act exactly alike, and will
eat up all remaining arguments, forcing list context. A <CODE
CLASS="literal"
>$</CODE
> likewise
forces scalar context on an argument, so taking an array or hash variable for that
parameter would probably yield unwanted results.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6047"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6050"
></A
>A semicolon separates mandatory arguments from optional arguments. For example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sub newsplit (\@$;$);</PRE
></BLOCKQUOTE
>


requires two arguments: an array variable and a scalar. The third
scalar is optional.
Placing a semicolon before <CODE
CLASS="literal"
>@</CODE
> and <CODE
CLASS="literal"
>%</CODE
> is not necessary since
lists can be null.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6057"
></A
>A typeglob prototype symbol (<CODE
CLASS="literal"
>*</CODE
>) will always turn its argument
into a reference to a symbol table entry. It is most often used for
filehandles. <A
CLASS="indexterm"
NAME="AUTOID-6060"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_06.htm"
TITLE="4.6 Regular Expressions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.6 Regular Expressions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl in a Nutshell"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl in a Nutshell"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_08.htm"
TITLE="4.8 References and Complex Data Structures"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.8 References and Complex Data Structures"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.6 Regular Expressions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.8 References and Complex Data Structures</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<p><!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
