<HTML
><HEAD
>
<TITLE>4.6 Regular Expressions (Perl in a Nutshell)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl in a Nutshell"><META
NAME="DC.creator"
CONTENT="Ellen Siever, Stephen Spainhour &amp; Nathan Patwardhan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:32:10Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-286-7"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. The Perl Language"><LINK
REL="prev"
HREF="ch04_05.htm"
TITLE="4.5 Operators"><LINK
REL="next"
HREF="ch04_07.htm"
TITLE="4.7 Subroutines"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl in a Nutshell"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,71"
HREF="index.htm"
ALT="Perl in a Nutshell"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_05.htm"
TITLE="4.5 Operators"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.5 Operators"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. The Perl Language"
>Chapter 4<BR>The Perl Language</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_07.htm"
TITLE="4.7 Subroutines"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.7 Subroutines"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6"
>4.6 Regular Expressions</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="PNUT-CH-4-IX-REGULAR-EXPRESSIONS"
></A
>Regular expressions are used several ways in Perl. They're used in conditionals
to determine whether a string matches a particular pattern. They're also
used to find patterns in strings and replace the match with something else.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4882"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4885"
></A
>The ordinary pattern match operator looks like <CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
><CODE
CLASS="literal"
>/</CODE
>.
It matches against the <CODE
CLASS="literal"
>$_</CODE
> variable by default. If the pattern is found
in the string, the operator returns true (<CODE
CLASS="literal"
>&quot;1&quot;</CODE
>); if there is no 
match, a false value (<CODE
CLASS="literal"
>&quot;&quot;</CODE
>) is returned.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4895"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4897"
></A
>The substitution operator looks like <CODE
CLASS="literal"
>s/</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
><CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>replace</I
></CODE
><CODE
CLASS="literal"
>/</CODE
>.
This operator searches <CODE
CLASS="literal"
>$_</CODE
> by default. If it finds the specified <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>,
it is replaced with the string in <CODE
CLASS="replaceable"
><I
>replace</I
></CODE
>. If <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
> is not
matched, nothing happens.</P
><P
CLASS="para"
>You may specify a variable other
than <CODE
CLASS="literal"
>$_</CODE
> with the <CODE
CLASS="literal"
>=~</CODE
> binding operator (or the negated <CODE
CLASS="literal"
>!~</CODE
>
binding operator, which returns true if the pattern is not matched). 
For example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$text =~ /sampo/;</PRE
></BLOCKQUOTE
>
&#13;</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6.1"
>4.6.1 Pattern-Matching Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4916"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4919"
></A
>The following list defines Perl's pattern-matching operators. Some of the
operators have alternative &quot;quoting&quot; schemes and have a set of modifiers
that can be placed directly after the operators to affect the match
operation in some way.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>m/</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
><CODE
CLASS="literal"
>/gimosx</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Searches a string for a pattern match.
Modifiers are:<A
CLASS="indexterm"
NAME="AUTOID-4929"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4931"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4933"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4935"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4937"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4939"
></A
>

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Modifier</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>g</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Match globally, i.e., find all occurrences.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>i</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Do case-insensitive pattern matching.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>m</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as multiple lines.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>o</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Only compile pattern once.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as single line.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>x</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Use extended regular expressions.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>
If <CODE
CLASS="literal"
>/</CODE
> is the delimiter, then the initial <CODE
CLASS="literal"
>m</CODE
> is optional. 
With the <CODE
CLASS="literal"
>m</CODE
>,
you can use any pair of non-alphanumeric, non-whitespace characters as
delimiters. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>?</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
><CODE
CLASS="literal"
>?</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4984"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4987"
></A
>This operator is just like the
<CODE
CLASS="literal"
>m/</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
><CODE
CLASS="literal"
>/</CODE
>
search, except it matches only once.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>qr/</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
><CODE
CLASS="literal"
>/imosx</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5000"
></A
>Creates a precompiled regular expression from <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>,
which can be passed
around in variables and interpolated into other regular expressions.
The modifiers are the same as those for <CODE
CLASS="literal"
>m//</CODE
> above.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>s/</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
><CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>replacement</I
></CODE
><CODE
CLASS="literal"
>/egimosx</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5013"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5015"
></A
>Searches a string for <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>, and replaces
any match with the <CODE
CLASS="replaceable"
><I
>replacement</I
></CODE
> text. Returns the number of
substitutions made, which can be more than one with the <CODE
CLASS="literal"
>/g</CODE
> modifier.
Otherwise, it returns false (0).
If no string is specified via the <CODE
CLASS="literal"
>=~</CODE
> or <CODE
CLASS="literal"
>!~</CODE
> operator, the
<CODE
CLASS="literal"
>$_</CODE
> variable is searched and modified. 
Modifiers are:
</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Modifier</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>e</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Evaluate the right side as an expression.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>g</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Replace globally, i.e., all occurrences.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>i</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Do case-insensitive pattern matching.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>m</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as multiple lines.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>o</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Only compile pattern once.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as single line.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>x</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Use extended regular expressions.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>
Any non-alphanumeric, non-whitespace delimiter may replace the slashes.
If single quotes are used, no interpretation is done on the replacement
string (the <CODE
CLASS="literal"
>/e</CODE
> modifier overrides this, however).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>tr/</CODE
><CODE
CLASS="replaceable"
><I
>pattern1</I
></CODE
><CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>pattern2</I
></CODE
><CODE
CLASS="literal"
>/cds</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>y/</CODE
><CODE
CLASS="replaceable"
><I
>pattern1</I
></CODE
><CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>pattern2</I
></CODE
><CODE
CLASS="literal"
>/cds</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5074"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5076"
></A
>This operator scans
a string, character by character, and replaces
all occurrences of the characters found in <CODE
CLASS="replaceable"
><I
>pattern1</I
></CODE
> 
with the corresponding character in <CODE
CLASS="replaceable"
><I
>pattern2</I
></CODE
>. It returns
the number of characters replaced or deleted. If no string is
specified via the <CODE
CLASS="literal"
>=~</CODE
> or <CODE
CLASS="literal"
>!~</CODE
> operator, the <CODE
CLASS="literal"
>$_</CODE
> string is translated. 
Modifiers are:

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Modifier</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>c</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Complement <CODE
CLASS="replaceable"
><I
>pattern1</I
></CODE
>.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>d</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Delete found but unreplaced characters.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Squash duplicate replaced characters.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
></P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6.2"
>4.6.2 Regular Expression Syntax</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5106"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5109"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5111"
></A
>The simplest kind of regular expression is a literal string. 
More complicated patterns involve the use of <EM
CLASS="emphasis"
>metacharacters</EM
> to
describe all the different choices and variations that you want to
build into a pattern. Metacharacters don't match themselves, but describe
something else. The metacharacters are:
</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Metacharacter</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Escapes the character(s) immediately following it<A
CLASS="indexterm"
NAME="AUTOID-5126"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5129"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>.</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches any single character except a newline (unless <CODE
CLASS="literal"
>/s</CODE
> is used)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>^</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the beginning of the string (or line, if <CODE
CLASS="literal"
>/m</CODE
> used)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the end of the string (or line, if <CODE
CLASS="literal"
>/m</CODE
> used)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches the preceding element 0 or more times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>+</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches the preceding element 1 or more times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches the preceding element 0 or 1 times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{...}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies a range of occurrences for the element preceding it</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>[...]</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches any one of the class of characters contained within the brackets<A
CLASS="indexterm"
NAME="AUTOID-5175"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5179"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>(...)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Groups regular expressions</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>|</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches either the expression preceding or following it</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5193"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5196"
></A
>
The &quot;<CODE
CLASS="literal"
>.</CODE
>&quot; (single dot) is a wildcard character. When
used in a regular expression, it can match any single character.
The exception is the newline character (<CODE
CLASS="literal"
>\n</CODE
>), except when
you use the <CODE
CLASS="literal"
>/s</CODE
> modifier on the pattern match operator. This
modifier treats the string to be matched against as a single &quot;long&quot;
string with embedded newlines.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5203"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5206"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5209"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5212"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5214"
></A
>The <CODE
CLASS="literal"
>^</CODE
> and <CODE
CLASS="literal"
>$</CODE
> metacharacters are used as anchors
in a regular expression. 
The <CODE
CLASS="literal"
>^</CODE
> matches the beginning of a line. This
character should only appear at the beginning of an expression to match
the line beginning. The exception to this is when the <CODE
CLASS="literal"
>/m</CODE
>
(multi-line) modifier is used, in which case it will match at the
beginning of the string and after every newline (except the last, if
there is one). Otherwise, <CODE
CLASS="literal"
>^</CODE
> will match itself, unescaped, anywhere
in a pattern, except if it is the first character in a bracketed character
class, in which case it negates the class.</P
><P
CLASS="para"
>Similarly, <CODE
CLASS="literal"
>$</CODE
> will match the end of a line (just before a newline
character) only if it is at the end of a pattern, unless <CODE
CLASS="literal"
>/m</CODE
> is
used, in which case it matches just before every newline and at the
end of a string. You need to escape <CODE
CLASS="literal"
>$</CODE
> to match a literal dollar
sign in all cases, because if <CODE
CLASS="literal"
>$</CODE
> isn't at the end of a pattern
(or placed right before a <CODE
CLASS="literal"
>)</CODE
> or <CODE
CLASS="literal"
>]</CODE
>), Perl will attempt
to do variable interpretation. The same holds true for the <CODE
CLASS="literal"
>@</CODE
>
sign, which Perl will interpret as an array variable start unless
it is backslashed.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5232"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5235"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5238"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5241"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5244"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5247"
></A
>The <CODE
CLASS="literal"
>*</CODE
>, <CODE
CLASS="literal"
>+</CODE
>, and <CODE
CLASS="literal"
>?</CODE
> metacharacters are called
<EM
CLASS="emphasis"
>quantifiers</EM
>. They specify the number of times to match something.
They act on the element immediately preceding them, which could
be a single character (including the <CODE
CLASS="literal"
>.</CODE
>), a
grouped expression in parentheses, or a character class. The<A
CLASS="indexterm"
NAME="AUTOID-5255"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5258"
></A
>
<CODE
CLASS="literal"
>{...}</CODE
> construct is a generalized modifier. You may
put two numbers separated by a comma within the braces to
specify minimum and maximum numbers that the preceding element
can match.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5263"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5266"
></A
>Parentheses are used to group characters or expressions. They also
have the side effect of remembering what they matched so you can
recall and reuse patterns with a special group of variables.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5270"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5273"
></A
>The <CODE
CLASS="literal"
>|</CODE
> is the alternation operator in regular expressions.
It matches either what's on its left side or right side. It does
not only affect single characters. For example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/you|me|him|her/</PRE
></BLOCKQUOTE
>


looks for any of the four words. You should use parentheses to
provide boundaries for alternation:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/And(y|rew)/</PRE
></BLOCKQUOTE
>


This will match either &quot;Andy&quot; or &quot;Andrew&quot;.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6.3"
>4.6.3 Escaped Sequences</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5282"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5285"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5288"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5290"
></A
>The following table lists the backslashed representations of characters
that you can use in regular expressions: <A
CLASS="indexterm"
NAME="AUTOID-5293"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5295"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5297"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5299"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5301"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5303"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5305"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5307"
></A
>
</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Code</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Matches</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Alarm (beep)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\n</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Newline</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\r</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Carriage return</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\t</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Tab</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Formfeed</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\e</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Escape</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\007</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Any octal ASCII value</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\x7f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Any hexadecimal ASCII value </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\c</CODE
><CODE
CLASS="replaceable"
><I
>x</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Control-<CODE
CLASS="replaceable"
><I
>x</I
></CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6.4"
>4.6.4 Character Classes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5357"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5360"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5363"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5366"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5370"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5374"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5376"
></A
>The <CODE
CLASS="literal"
>[...]</CODE
> construct is used to list a set of characters
(a <EM
CLASS="emphasis"
>character class</EM
>) of which <EM
CLASS="emphasis"
>one</EM
> will match. 
Brackets are often used when
capitalization is uncertain in a match:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/[tT]here/</PRE
></BLOCKQUOTE
>

<A
CLASS="indexterm"
NAME="AUTOID-5383"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5386"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5389"
></A
>
A dash (<CODE
CLASS="literal"
>-</CODE
>) may be used to indicate a range of characters
in a character class:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/[a-zA-Z]/;  # match any single letter
/[0-9]/;     # match any single digit</PRE
></BLOCKQUOTE
>


To put a literal dash in the list you must use a backslash before it 
(<CODE
CLASS="literal"
>\-</CODE
>).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5396"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5399"
></A
>By placing a <CODE
CLASS="literal"
>^</CODE
> as the first element in the brackets, you
create a negated character class, i.e., it matches any character
not in the list. For example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/[^A-Z]/; matches any character other than an uppercase letter</PRE
></BLOCKQUOTE
>


Some common character classes have their own predefined escape sequences
for your programming convenience:<A
CLASS="indexterm"
NAME="AUTOID-5404"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5407"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5410"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5412"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5414"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5416"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5418"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5421"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5424"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5426"
></A
>

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Code</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Matches</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\d</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A digit, same as <CODE
CLASS="literal"
>[0-9]</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\D</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A nondigit, same as <CODE
CLASS="literal"
>[^0-9]</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\w</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A word character (alphanumeric), same as <CODE
CLASS="literal"
>[a-zA-Z_0-9]</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\W</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A nonword character, <CODE
CLASS="literal"
>[^a-zA-Z_0-9]</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A whitespace character, same as <CODE
CLASS="literal"
>[\t\n\r\f]</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\S</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A non-whitespace character, <CODE
CLASS="literal"
>[^\t\n\r\f]</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>
These elements match any single element in (or not in) their class.
A <CODE
CLASS="literal"
>\w</CODE
> matches only one character of a word. Using a modifier,
you can match a whole word, for example, with <CODE
CLASS="literal"
>\w+</CODE
>.
The abbreviated classes may also be used within brackets as
elements of other character classes.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6.5"
>4.6.5 Anchors</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5470"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5473"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5476"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5478"
></A
>Anchors 
don't match any characters; they match places within a string. The two
most common anchors are <CODE
CLASS="literal"
>^</CODE
> and <CODE
CLASS="literal"
>$</CODE
>, which match
the beginning and end of a line, respectively. 
This table lists the anchoring patterns used to match certain
boundaries in regular expressions:<A
CLASS="indexterm"
NAME="AUTOID-5483"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5486"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5489"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5492"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5495"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5497"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5499"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5501"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5504"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5506"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5509"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5511"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5514"
></A
>
</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Assertion</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>^</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the beginning of the string (or line, if <CODE
CLASS="literal"
>/m</CODE
> used)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the end of the string (or line, if <CODE
CLASS="literal"
>/m</CODE
> used)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at word boundary (between <CODE
CLASS="literal"
>\w</CODE
> and <CODE
CLASS="literal"
>\W</CODE
>)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\B</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches except at word boundary</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\A</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the beginning of the string</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\Z</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the end of the string or before a newline</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\z</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches only at the end of the string</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\G</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches where previous <CODE
CLASS="literal"
>m//g</CODE
> left off</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>
The <CODE
CLASS="literal"
>$</CODE
> and <CODE
CLASS="literal"
>\Z</CODE
> assertions can match not only at the end of the
string, but also one character earlier than that, if the last character
of the string happens to be a newline.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6.6"
>4.6.6 Quantifiers</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5573"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5576"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5579"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5581"
></A
>Quantifiers are used to specify how many instances of the previous
element can match. For instance, you could say &quot;match any
number of a's, including none&quot; (<CODE
CLASS="literal"
>a*</CODE
>), or match between five and ten 
instances of the word &quot;owie&quot; (<CODE
CLASS="literal"
>(owie){5,10}</CODE
>).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5587"
></A
>Quantifiers, by nature, are greedy. That is, the way the
Perl regular expression &quot;engine&quot; works is that it will
look for the biggest match possible (the farthest to the right)
unless you tell it not to. Say you are searching a string that
reads:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>a whatever foo, b whatever foo</PRE
></BLOCKQUOTE
>


and you want to find <CODE
CLASS="literal"
>a</CODE
> and <CODE
CLASS="literal"
>foo</CODE
> with something
in between. You might use:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/a.*foo/</PRE
></BLOCKQUOTE
>


A <CODE
CLASS="literal"
>.</CODE
> followed by a <CODE
CLASS="literal"
>*</CODE
> looks for any character,
any number of times, until <CODE
CLASS="literal"
>foo</CODE
> is found. But since Perl
will look as far to the right as possible to find <CODE
CLASS="literal"
>foo</CODE
>,
the first instance of <CODE
CLASS="literal"
>foo</CODE
> is swallowed up by the greedy
<CODE
CLASS="literal"
>.*</CODE
> expression. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5600"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5602"
></A
>All the quantifiers therefore have a notation that allows for
minimal matching, so they are non-greedy. This notation uses
a question mark immediately following the quantifier to force
Perl to look for the earliest available match (farthest to the
left). The following table lists the regular expression quantifiers and
their non-greedy forms:<A
CLASS="indexterm"
NAME="AUTOID-5604"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5607"
></A
>

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Maximal</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Minimal</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Allowed Range</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><CODE
CLASS="literal"
>n</CODE
>,<CODE
CLASS="literal"
>m</CODE
><CODE
CLASS="literal"
>}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><CODE
CLASS="literal"
>n</CODE
>,<CODE
CLASS="literal"
>m</CODE
><CODE
CLASS="literal"
>}?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Must occur at least <CODE
CLASS="literal"
>n</CODE
> times but no more than <CODE
CLASS="literal"
>m</CODE
> times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><CODE
CLASS="literal"
>n</CODE
><CODE
CLASS="literal"
>,}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><CODE
CLASS="literal"
>n</CODE
><CODE
CLASS="literal"
>,}?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Must occur at least <CODE
CLASS="literal"
>n</CODE
> times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><CODE
CLASS="literal"
>n</CODE
><CODE
CLASS="literal"
>}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><CODE
CLASS="literal"
>n</CODE
><CODE
CLASS="literal"
>}?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Must match exactly <CODE
CLASS="literal"
>n</CODE
> times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0 or more times (same as <CODE
CLASS="literal"
>{0,}</CODE
>)<A
CLASS="indexterm"
NAME="AUTOID-5665"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5668"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>+</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>+?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1 or more times (same as <CODE
CLASS="literal"
>{1,}</CODE
>)<A
CLASS="indexterm"
NAME="AUTOID-5679"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5682"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>??</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0 or 1 time (same as <CODE
CLASS="literal"
>{0,1}</CODE
>)<A
CLASS="indexterm"
NAME="AUTOID-5693"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5696"
></A
></P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6.7"
>4.6.7 Pattern Match Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5702"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5705"
></A
>Parentheses not only serve to group elements in a regular expression,
they also remember the patterns they match. 
Every match from a parenthesized
element is saved to a special, read-only variable indicated by a number.
You can recall and reuse a match by using these variables.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5709"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5711"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5714"
></A
>Within a pattern, each parenthesized element saves its match to a numbered
variable, in order starting with <CODE
CLASS="literal"
>1</CODE
>. You can recall these
matches within the expression by using <CODE
CLASS="literal"
>\1</CODE
>, <CODE
CLASS="literal"
>\2</CODE
>, and
so on. </P
><P
CLASS="para"
>Outside of the matching pattern, the matched variables are recalled
with the usual dollar-sign, i.e., <CODE
CLASS="literal"
>$1</CODE
>, <CODE
CLASS="literal"
>$2</CODE
>, etc. The
dollar sign notation should used in the replacement expression
of a substitution and anywhere else you might want to use them in
your program. For example, to implement &quot;i before e, except after c&quot;:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/([^c])ei/$1ie/g;</PRE
></BLOCKQUOTE
>


The backreferencing variables are:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>$+</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns the last parenthesized pattern match</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$&amp;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns the entire matched string</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$`</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns everything before the matched string</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$'</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns everything after the matched string</P
></DD
></DL
><P
CLASS="para"
>Backreferencing with these variables will slow down your program noticeably for
all regular expressions.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-6.8"
>4.6.8 Extended Regular Expressions</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5749"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5751"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5754"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5757"
></A
>Perl defines an extended syntax for regular expressions.
The syntax is a pair of parentheses with a question mark as the first thing
within the parentheses.
The character after the question mark gives the function of the extension.
The extensions are:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="replaceable"
><I
>(?#text)</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A comment. The text is ignored. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?:...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This groups things like &quot;<CODE
CLASS="literal"
>(...)</CODE
>&quot; but doesn't make backreferences.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?=...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A zero-width positive lookahead assertion. For example, <CODE
CLASS="literal"
>/\w+(?=\t)/</CODE
>
matches a word followed by a tab, without including the tab in <CODE
CLASS="literal"
>$&amp;</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?!...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A zero-width negative lookahead assertion. For example, <CODE
CLASS="literal"
>/foo(?!bar)/</CODE
>
matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?&lt;=...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A zero-width positive lookbehind assertion. For example,
<CODE
CLASS="literal"
>/(?&lt;=bad)boy/</CODE
> matches the word <CODE
CLASS="literal"
>boy</CODE
> that
follows <CODE
CLASS="literal"
>bad</CODE
>, without including <CODE
CLASS="literal"
>bad</CODE
> in
<CODE
CLASS="literal"
>$&amp;</CODE
>. This only works for fixed-width lookbehind.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?&lt;!=...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A zero-width negative lookbehind assertion. For example,
<CODE
CLASS="literal"
>/(?&lt;!=bad)boy/</CODE
> matches any occurrence of &quot;boy&quot; that
doesn't follow &quot;bad&quot;. This only works for fixed-width lookbehind.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?&gt;...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Matches the substring that the standalone pattern would
match if anchored at the given position. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?(</CODE
><CODE
CLASS="replaceable"
><I
>condition</I
></CODE
><CODE
CLASS="literal"
>)</CODE
><CODE
CLASS="replaceable"
><I
>yes-pattern</I
></CODE
>|<CODE
CLASS="replaceable"
><I
>no-pattern</I
></CODE
>)</DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?(<CODE
CLASS="replaceable"
><I
>condition</I
></CODE
>)<CODE
CLASS="replaceable"
><I
>yes-pattern</I
></CODE
>)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Matches a pattern determined by a condition. The <CODE
CLASS="replaceable"
><I
>condition</I
></CODE
>
should be either an integer, which is &quot;true&quot; if the
pair of parentheses corresponding to the integer has matched,
or a lookahead, lookbehind, or evaluate, zero-width assertion.
The <CODE
CLASS="replaceable"
><I
>no-pattern</I
></CODE
> will be used to match if the condition was
not meant, but it is also optional.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?imsx-imsx)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>One or more embedded pattern-match modifiers. 
Modifiers are switched off if they follow a <CODE
CLASS="literal"
>-</CODE
> (dash).
The modifiers are defined as follows:<A
CLASS="indexterm"
NAME="AUTOID-5827"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5829"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5831"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5833"
></A
>
</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Modifier</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>i</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Do case-insensitive pattern matching</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>m</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as multiple lines</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as single line</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>x</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Use extended regular expressions</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5858"
></A
></P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_05.htm"
TITLE="4.5 Operators"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.5 Operators"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl in a Nutshell"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl in a Nutshell"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_07.htm"
TITLE="4.7 Subroutines"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.7 Subroutines"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.5 Operators</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.7 Subroutines</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<p><!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
