<HTML
><HEAD
>
<TITLE>4.5 Operators (Perl in a Nutshell)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl in a Nutshell"><META
NAME="DC.creator"
CONTENT="Ellen Siever, Stephen Spainhour &amp; Nathan Patwardhan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:31:30Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-286-7"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. The Perl Language"><LINK
REL="prev"
HREF="ch04_04.htm"
TITLE="4.4 Special Variables"><LINK
REL="next"
HREF="ch04_06.htm"
TITLE="4.6 Regular Expressions"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl in a Nutshell"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,71"
HREF="index.htm"
ALT="Perl in a Nutshell"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_04.htm"
TITLE="4.4 Special Variables"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.4 Special Variables"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. The Perl Language"
>Chapter 4<BR>The Perl Language</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_06.htm"
TITLE="4.6 Regular Expressions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.6 Regular Expressions"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5"
>4.5 Operators</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="PNUT-CH-4-IX-OPERATORS"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3958"
></A
>Table 4-3 lists all the Perl operators from highest
to lowest precedence and indicates their associativity.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PNUT-CH-4-TAB-2"
>Table 4.3: Perl Associativity and Operators, Listed by Precedence</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Associativity</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Operators</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Terms and list operators (leftward)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-&gt;</CODE
> (method call, dereference)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>++ --</CODE
> (autoincrement, autodecrement)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>**</CODE
> (exponentiation)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>! ~ \</CODE
> and unary <CODE
CLASS="literal"
>+</CODE
> and <CODE
CLASS="literal"
>-</CODE
> (logical not, bit-not,
reference, unary plus, unary minus)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>=~ !~ </CODE
> (matches, doesn't match)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>* / % x</CODE
> (multiply, divide, modulus, string replicate)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>+ - .</CODE
> (addition, subtraction, string concatenation)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>&lt;&lt; &gt;&gt;</CODE
> (left bit-shift, right bit-shift)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Named unary operators and file-test operators</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>&lt; &gt; &lt;= &gt;= lt gt le ge</CODE
> (less than, greater than, less
than or equal to, greater than or equal to, and their string
equivalents.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>== != &lt;=&gt; eq ne cmp</CODE
> (equal to, not equal to,
signed comparison, and their string equivalents)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;</CODE
> (bit-and)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>|  ^</CODE
> (bit-or, bit-xor)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;&amp;</CODE
> (logical AND)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>||</CODE
> (logical OR)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>..  ...</CODE
> (range)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>?:</CODE
> (ternary conditional)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>= += -= *=</CODE
> and so on (assignment operators)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>, =&gt;</CODE
> (comma, arrow comma)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>List operators (rightward)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>not</CODE
> (logical not)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>and</CODE
> (logical and)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>or xor</CODE
> (logical or, xor)</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4073"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4076"
></A
>You can make your expressions clear by
using parentheses to group any part of an expression. Anything in
parentheses will be evaluated as a single unit within a larger expression.</P
><P
CLASS="para"
>With very few exceptions, Perl operators act upon scalar values
only, not upon list values. </P
><P
CLASS="para"
>Terms that take highest precedence in Perl include variables,
quote and quotelike operators, any expression in parentheses, and any
function whose arguments are in parentheses. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4082"
></A
>A list operator is a function
that can take a list of values as its argument. 
List operators take highest precedence when considering what's to
the left of them. 
They have considerably lower precedence when looking at their
right side, which is the expected result.</P
><P
CLASS="para"
>Also parsed as high-precedence terms are the <CODE
CLASS="literal"
>do{}</CODE
> and 
<CODE
CLASS="literal"
>eval{}</CODE
> constructs,
as well as subroutine and method calls, the anonymous array and hash
composers (<CODE
CLASS="literal"
>[]</CODE
> and <CODE
CLASS="literal"
>{}</CODE
>), and 
the anonymous subroutine composer <CODE
CLASS="literal"
>sub{}</CODE
>.</P
><P
CLASS="para"
>A unary operator
is a function that takes a single scalar value as its argument.
Unary operators have a lower precedence than list operators
because they only expect and take one value. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.1"
>4.5.1 The Arrow Operator</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4094"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4096"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4098"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4101"
></A
>The arrow operator is a dereference operator.  It can be
used for references to arrays, hashes, code references, or for calling methods
on objects.  See the discussion of references in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="Packages, Modules, and Objects"
>Chapter 7, <CITE
CLASS="chapter"
>Packages, Modules, and Objects</CITE
></A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.2"
>4.5.2 Unary Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4108"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4110"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4113"
></A
>Unary <CODE
CLASS="literal"
>!</CODE
> performs logical negation, that is, &quot;not.&quot; The 
<CODE
CLASS="literal"
>not</CODE
> operator
is a lower-precedence version of <CODE
CLASS="literal"
>!</CODE
>. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4120"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4123"
></A
>Unary <CODE
CLASS="literal"
>-</CODE
> performs arithmetic negation if the operand is numeric. If
the operand is an identifier, then a string consisting of a minus sign
concatenated with the identifier is returned. Otherwise, if the string
starts with a plus or minus, a string starting with the opposite sign
is returned. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4128"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4131"
></A
>Unary <CODE
CLASS="literal"
>~</CODE
> performs bitwise negation, that is, one's complement.
For example, on a 32-bit machine, <CODE
CLASS="literal"
>~0xFF</CODE
> is <CODE
CLASS="literal"
>0xFFFFFF00</CODE
>.
If the argument to <CODE
CLASS="literal"
>~</CODE
> is
a string instead of a number, a string of identical length is
returned, but with all the bits of the string complemented. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4139"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4142"
></A
>Unary <CODE
CLASS="literal"
>+</CODE
> has no semantic effect whatsoever, even on strings. It is
syntactically useful for separating a function name from a parenthesized
expression that would otherwise be interpreted as the complete list of
function arguments.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4147"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4150"
></A
>Unary <CODE
CLASS="literal"
>\</CODE
> creates a reference to whatever follows it 
(see &quot;References and Complex Data Structures&quot; later in this chapter).
Do not confuse this behavior with the behavior of backslash within a
string.
The <CODE
CLASS="literal"
>\</CODE
> operator may also be used on a parenthesized list value in a list
context, in which case it returns references to each element of the list.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.3"
>4.5.3 Arithmetic Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4158"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4160"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4163"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4166"
></A
>Binary <CODE
CLASS="literal"
>**</CODE
> is the exponentiation operator. Note that it binds even
more tightly than unary minus, so <CODE
CLASS="literal"
>-2**4</CODE
> is <CODE
CLASS="literal"
>-(2**4)</CODE
>, not
<CODE
CLASS="literal"
>(-2)**4</CODE
>. Note also that <CODE
CLASS="literal"
>**</CODE
> has right associativity, so:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$e = 2 ** 3 ** 4;</PRE
></BLOCKQUOTE
>


evaluates to 2 to the 81st power, not 8 to the 4th power.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4175"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4178"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4181"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4183"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4186"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4189"
></A
>The <CODE
CLASS="literal"
>*</CODE
> (multiply) and <CODE
CLASS="literal"
>/</CODE
> (divide) operators
work exactly as you might expect, multiplying or
dividing their two operands. Division is done in floating-point mode,
unless integer mode in enabled (via <CODE
CLASS="literal"
>use integer</CODE
>).<A
CLASS="indexterm"
NAME="AUTOID-4194"
></A
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4198"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4201"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4204"
></A
>The <CODE
CLASS="literal"
>%</CODE
> (modulus) operator converts its operands to integers before finding the
remainder according to integer division. For the same operation in
floating-point mode, you may prefer to use the <CODE
CLASS="literal"
>fmod()</CODE
> 
function from the
POSIX module (see <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="Standard Modules"
>Chapter 8</A
>).</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.4"
>4.5.4 Comparison Operators</A
></H3
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.4.1"
>4.5.4.1 Relational operators</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4214"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4216"
></A
>Perl has two classes of relational operators. One class operates on
numeric values, and the other operates on string values.<A
CLASS="indexterm"
NAME="AUTOID-4218"
></A
>
String
comparisons are based on the ASCII collating sequence.
Relational operators are nonassociative, so<A
CLASS="indexterm"
NAME="AUTOID-4221"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4223"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4225"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4228"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4231"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4233"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4235"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4238"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4241"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4243"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4245"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4248"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4251"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4253"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4255"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4258"
></A
>
<CODE
CLASS="literal"
>$a &lt; $b &lt; $c</CODE
> is a syntax error.

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Numeric</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>String</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&gt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>gt</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Greater than</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&gt;=</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>ge</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Greater than or equal to</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>lt</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;=</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>le</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than or equal to</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.4.2"
>4.5.4.2 Equality operators</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4297"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4299"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4302"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4305"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4307"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4310"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4313"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4315"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4318"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4321"
></A
>The equal and not-equal operators return 1 for true, and <CODE
CLASS="literal"
>&quot;&quot;</CODE
> for false (just as
the relational operators do). The <CODE
CLASS="literal"
>&lt;=&gt;</CODE
> and <EM
CLASS="emphasis"
>cmp</EM
> operators return
-1 if the left operand is less than the right operand, 0 if they are
equal, and +1 if the left operand is greater than the right. 

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Numeric</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>String</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>==</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>eq</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Equal to</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>!=</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>ne</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Not equal to</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;=&gt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>cmp</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Comparison, with signed result</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.5"
>4.5.5 Autoincrement and Autodecrement</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4355"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4357"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4359"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4362"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4365"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4368"
></A
>If placed before a variable, 
the <CODE
CLASS="literal"
>++</CODE
> and <CODE
CLASS="literal"
>--</CODE
> operators 
increment or decrement the variable before returning the value, and if
placed after, they increment or decrement the variable after returning the
value. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.6"
>4.5.6 Assignment Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4376"
></A
>Perl recognizes the following operators for assigning a value to a variable:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>=    **=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=
            -=    /=    |=    &gt;&gt;=    ||=
            .=    %=    ^=
                  x=</PRE
></BLOCKQUOTE
>


Each operator requires a variable on the left
side and some expression on the right side. For the simple assignment<A
CLASS="indexterm"
NAME="AUTOID-4379"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4381"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4384"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4387"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4390"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4393"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4396"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4399"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4402"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4405"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4408"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4411"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4414"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4417"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4420"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4423"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4426"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4429"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4432"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4435"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4438"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4441"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4444"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4447"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4450"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4453"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4456"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4459"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4462"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4465"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4468"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4471"
></A
>
operator, <CODE
CLASS="literal"
>=</CODE
>, the value of the expression is stored into the designated
variable. For the other operators, Perl evaluates the expression:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$var <EM
CLASS="emphasis"
>OP</EM
>= $value</PRE
></BLOCKQUOTE
>


as if it were written:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$var = $var <EM
CLASS="emphasis"
>OP</EM
> $value</PRE
></BLOCKQUOTE
>


except that <CODE
CLASS="literal"
>$var</CODE
> is evaluated only once.
For example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$a += 2; # same as $a = $a + 2</PRE
></BLOCKQUOTE
>
&#13;</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.7"
>4.5.7 Pattern Match Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4484"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4487"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4489"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4492"
></A
>Binary <CODE
CLASS="literal"
>=~</CODE
> binds a scalar expression to a pattern match, substitution,
or translation. These operations search or modify the string <CODE
CLASS="literal"
>$_</CODE
> by
default. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4498"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4501"
></A
>Binary <CODE
CLASS="literal"
>!~</CODE
> is just like <CODE
CLASS="literal"
>=~</CODE
> except the return value is negated in
the logical sense. The following expressions are functionally equivalent:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$string !~ /<EM
CLASS="emphasis"
>pattern</EM
>/
not $string =~ /<EM
CLASS="emphasis"
>pattern</EM
>/</PRE
></BLOCKQUOTE
>


See <A
CLASS="xref"
HREF="ch04_06.htm"
TITLE="Regular Expressions"
>Section 4.6</A
>&quot; later in this chapter.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.8"
>4.5.8 File Test Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4513"
></A
>A file test operator is a unary operator that tests a
filename or a filehandle.<A
CLASS="indexterm"
NAME="AUTOID-4515"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4517"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4519"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4521"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4523"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4525"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4527"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4529"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4531"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4533"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4535"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4537"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4539"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4541"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4543"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4545"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4547"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4549"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4551"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4553"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4555"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4557"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4559"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4561"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4563"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4565"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4567"
></A
>

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Operator</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-r</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is readable by effective uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-w</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is writable by effective uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-x</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is executable by effective uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-o</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is owned by effective uid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-R</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is readable by real uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-W</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is writable by real uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-X</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is executable by real uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-O</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is owned by real uid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-e</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File exists.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-z</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has zero size.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has non-zero size (returns size).</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a plain file.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-d</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a directory.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-l</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a symbolic link.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-p</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a named pipe (FIFO).</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-S</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a socket.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a block special file.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-c</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a character special file.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-t</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Filehandle is opened to a tty.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-u</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has setuid bit set.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-g</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has setgid bit set.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-k</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has sticky bit set.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-T</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a text file.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-B</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a binary file (opposite of <CODE
CLASS="literal"
>-T</CODE
>).</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-M</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Age of file (at startup) in days since modification.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-A</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Age of file (at startup) in days since last access.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-C</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Age of file (at startup) in days since inode change.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.9"
>4.5.9 Logical Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4703"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4705"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4708"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4711"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4714"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4717"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4719"
></A
>Perl provides the <CODE
CLASS="literal"
>&amp;&amp;</CODE
> (logical AND)
and <CODE
CLASS="literal"
>||</CODE
> (logical OR) operators. They evaluate from
left to right testing the truth of the statement. 

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Example</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Name</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Result</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a &amp;&amp; $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>And</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>$a</CODE
> if <CODE
CLASS="literal"
>$a</CODE
> is false, <CODE
CLASS="literal"
>$b</CODE
> otherwise</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a || $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Or</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>$a</CODE
> if <CODE
CLASS="literal"
>$a</CODE
> is true, <CODE
CLASS="literal"
>$b</CODE
> otherwise</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>

For example, an oft-appearing idiom
in Perl programs is:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>open(FILE, &quot;somefile&quot;) || die &quot;Cannot open somefile: $!\n&quot;;</PRE
></BLOCKQUOTE
>


In this case, Perl first evaluates the <CODE
CLASS="literal"
>open</CODE
> function. If the value
is true (because <CODE
CLASS="literal"
>somefile</CODE
> was successfully opened), the execution
of the <CODE
CLASS="literal"
>die</CODE
> function is unnecessary and is skipped. </P
><P
CLASS="para"
>Perl also provides lower-precedence <CODE
CLASS="literal"
>and</CODE
> and <CODE
CLASS="literal"
>or</CODE
> operators that are
more readable. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.10"
>4.5.10 Bitwise Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4759"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4761"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4763"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4765"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4767"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4770"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4773"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4776"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4779"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4782"
></A
>Perl has bitwise AND, OR, and XOR (exclusive
OR) operators: <CODE
CLASS="literal"
>&amp;</CODE
>, <CODE
CLASS="literal"
>|</CODE
>, and <CODE
CLASS="literal"
>^</CODE
>. 
These
operators work differently on numeric values than they do on strings.
If either operand is a number, then both
operands are converted to integers, and the bitwise operation is
performed between the two integers. 
If both operands are strings,
these operators do bitwise operations between corresponding
bits from the two strings. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.11"
>4.5.11 Miscellaneous Operators</A
></H3
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.11.1"
>4.5.11.1 Range operator</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4793"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4795"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4798"
></A
>The <CODE
CLASS="literal"
>..</CODE
> range operator is really two different
operators depending on the context. In a list context, it returns a
list of values counting (by ones) from the left value to the right
value. </P
><P
CLASS="para"
>In a scalar context, <CODE
CLASS="literal"
>..</CODE
> returns a Boolean value. 
It is false
as long as its left operand is false. Once the left operand is true,
the range operator stays true until the right operand is true,
after which the range operator becomes false again. 
The right operand is not evaluated while the operator is in the false
state, and the left operand is not evaluated while the operator is in the true
state.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4805"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4807"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4810"
></A
>The alternate version of this operator, <CODE
CLASS="literal"
>...</CODE
>, does not test the right
operand immediately when the operator becomes true; it waits until the next evaluation.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.11.2"
>4.5.11.2 Conditional operator</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4817"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4819"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4822"
></A
>Ternary <CODE
CLASS="literal"
>?:</CODE
> is the conditional operator. 
It works
much like an if-then-else statement, 
but it can safely be embedded within other
operations and functions. 


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
><EM
CLASS="emphasis"
>test_expr</EM
> ? <EM
CLASS="emphasis"
>if_true_expr</EM
> : <EM
CLASS="emphasis"
>if_false_expr</EM
></PRE
></BLOCKQUOTE
>


If the <CODE
CLASS="replaceable"
><I
>test_expr</I
></CODE
> is true, only the
<CODE
CLASS="replaceable"
><I
>if_true_expr</I
></CODE
> is evaluated.
Otherwise, only the <CODE
CLASS="replaceable"
><I
>if_false_expr</I
></CODE
>
is evaluated.  Either way, the value of the evaluated expression
becomes the value of the entire expression.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.11.3"
>4.5.11.3 Comma operator</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4836"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4839"
></A
>In a list context, &quot;<CODE
CLASS="literal"
>,</CODE
>&quot; is the list argument separator and 
inserts both its arguments into the list. 
In scalar context, &quot;<CODE
CLASS="literal"
>,</CODE
>&quot; evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4845"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4848"
></A
>The <CODE
CLASS="literal"
>=&gt;</CODE
> operator is mostly just a synonym for the comma operator.
It's useful for documenting arguments that come in pairs. It also
forces any identifier to the left of it to be interpreted as a string.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-5.11.4"
>4.5.11.4 String operator</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4855"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4858"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4861"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4864"
></A
>The concatenation operator &quot;.&quot; is used to add strings together:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>print 'abc' . 'def';        # prints abcdef
print $a . $b;              # concatenates the string values of $a and $b</PRE
></BLOCKQUOTE
>

<A
CLASS="indexterm"
NAME="AUTOID-4867"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4869"
></A
>
Binary <CODE
CLASS="literal"
>x</CODE
> is the string repetition operator. In scalar context, it
returns a concatenated string consisting of the left operand repeated
the number of times specified by the right operand.


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>print '-' x 80;                           # prints row of dashes
print &quot;\t&quot; x ($tab/8), ' ' x ($tab%8);    # tabs over</PRE
></BLOCKQUOTE
>


In list context, if the left operand is a list in parentheses, the <CODE
CLASS="literal"
>x</CODE
>
works as a list replicator rather than a string replicator. This is
useful for initializing all the elements of an array of indeterminate
length to the same value:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>@ones = (1) x 80;           # a list of 80 1s
@ones = (5) x @ones;        # set all elements to 5</PRE
></BLOCKQUOTE
><A
CLASS="indexterm"
NAME="AUTOID-4875"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_04.htm"
TITLE="4.4 Special Variables"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.4 Special Variables"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl in a Nutshell"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl in a Nutshell"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_06.htm"
TITLE="4.6 Regular Expressions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.6 Regular Expressions"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.4 Special Variables</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.6 Regular Expressions</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<p><!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
