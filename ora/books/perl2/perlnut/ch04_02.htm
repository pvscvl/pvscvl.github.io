<HTML
><HEAD
>
<TITLE>4.2 Data Types and Variables (Perl in a Nutshell)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl in a Nutshell"><META
NAME="DC.creator"
CONTENT="Ellen Siever, Stephen Spainhour &amp; Nathan Patwardhan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:30:27Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-286-7"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. The Perl Language"><LINK
REL="prev"
HREF="ch04_01.htm"
TITLE="4.1 Program Structure"><LINK
REL="next"
HREF="ch04_03.htm"
TITLE="4.3 Statements"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl in a Nutshell"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,71"
HREF="index.htm"
ALT="Perl in a Nutshell"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_01.htm"
TITLE="4.1 Program Structure"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.1 Program Structure"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. The Perl Language"
>Chapter 4<BR>The Perl Language</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_03.htm"
TITLE="4.3 Statements"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.3 Statements"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2"
>4.2 Data Types and Variables</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="PNUT-CH-4-IX-DATA-TYPES"
></A
>Perl has three basic data types: <EM
CLASS="emphasis"
>scalars</EM
>, 
<EM
CLASS="emphasis"
>arrays</EM
>, and <EM
CLASS="emphasis"
>hashes</EM
>.<A
CLASS="indexterm"
NAME="AUTOID-2535"
></A
></P
><P
CLASS="para"
>Scalars are essentially simple variables.  
They are preceded by a 
dollar sign (<CODE
CLASS="literal"
>$</CODE
>).
A scalar is either a number, a string, or a reference.
(A reference is a scalar that points to another piece of data. References are
discussed later in this chapter.)
If you provide a string where a number is expected or vice versa, Perl
automatically converts the operand using fairly intuitive rules.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2540"
></A
>Arrays are ordered lists of scalars that you
access with a numeric subscript (subscripts start at 0).
They are preceded by an
&quot;at&quot; sign (<CODE
CLASS="literal"
>@</CODE
>).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2544"
></A
>Hashes are unordered sets of 
key/value pairs that you access using
the keys as subscripts.
They are preceded by a
percent sign (<CODE
CLASS="literal"
>%</CODE
>).</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2.1"
>4.2.1 Numbers</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2550"
></A
>Perl stores numbers internally as either signed integers or double-precision
floating-point values. Numeric literals 
are specified in any of the following
floating-point or integer formats:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>12345               # integer
-54321              # negative integer
12345.67            # floating point
6.02E23             # scientific notation
0xffff              # hexadecimal
0377                # octal
4_294_967_296       # underline for legibility</PRE
></BLOCKQUOTE
>


Since Perl uses the comma as a list separator, you cannot use a comma for
improving legibility<A
CLASS="indexterm"
NAME="AUTOID-2553"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2556"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2559"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2562"
></A
>
of a large number. To improve legibility, Perl allows you
to use an underscore character instead. The underscore only
works within literal numbers specified in your program, not in strings
functioning as numbers or in data read from somewhere else. Similarly, the
leading <CODE
CLASS="literal"
>0x</CODE
> for hex and <CODE
CLASS="literal"
>0</CODE
> for octal work only for literals.
The automatic conversion of a string to a number does not recognize these
prefixes&nbsp;- you must do an explicit conversion.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2.2"
>4.2.2 String Interpolation</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2570"
></A
>Strings are sequences of characters. 
String literals are usually delimited by either single (<CODE
CLASS="literal"
>'</CODE
>)
or double quotes (<CODE
CLASS="literal"
>&quot;</CODE
>).<A
CLASS="indexterm"
NAME="AUTOID-2574"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2576"
></A
>
Double-quoted string literals
are subject to backslash and variable interpolation, and single-quoted
strings are not (except for <CODE
CLASS="literal"
>\'</CODE
> and <CODE
CLASS="literal"
>\\</CODE
>, 
used to put single quotes and backslashes into single-quoted strings).
You can embed newlines directly in your strings.</P
><P
CLASS="para"
>Table 4-1 lists all the backslashed or escape characters
that can be used in double-quoted strings.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PNUT-CH-4-TAB-0"
>Table 4.1: Double-Quoted String Representations</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Code</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\n</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Newline</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\r</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Carriage return</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\t</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Horizontal tab</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Form feed</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Backspace</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Alert (bell)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\e</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>ESC character</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\033</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>ESC in octal</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\x7f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>DEL in hexadecimal</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\cC</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>CTRL-C</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\\</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Backslash</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\&quot;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Double quote</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\u</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Force next character to uppercase</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\l</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Force next character to lowercase</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\U</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Force all following characters to uppercase</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\L</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Force all following characters to lowercase</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\Q</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Backslash all following non-alphanumeric characters</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\E</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>End <CODE
CLASS="literal"
>\U</CODE
>, <CODE
CLASS="literal"
>\L</CODE
>, or <CODE
CLASS="literal"
>\Q</CODE
></P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2667"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2669"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2671"
></A
>Table 4-2 lists alternative quoting schemes that can be used in Perl.
They are useful in diminishing the number of commas and quotes you may
have to type, and also allow you to not worry about escaping characters
such as backslashes when there are many instances in your data.
The generic forms allow you to use any non-alphanumeric, non-whitespace
characters as delimiters in place of the slash (<CODE
CLASS="literal"
>/</CODE
>). If the delimiters
are single quotes, no variable interpolation is done on the pattern.
Parentheses, brackets, braces, and angle brackets can be used as delimiters
in their standard opening and closing pairs.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PNUT-CH-4-TAB-1"
>Table 4.2: Quoting Syntax in Perl</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Customary</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Generic</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Interpolation</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>''</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>q//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Literal</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>No</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&quot;&quot;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>qq//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Literal</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Yes</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>``</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>qx//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Command</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Yes</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>()</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>qw//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Word list</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>No</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>m//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Pattern match</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Yes</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s///</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s///</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Substitution</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Yes</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>y///</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>tr///</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Translation</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>No</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2.3"
>4.2.3 Lists</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2736"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2738"
></A
>A list is an ordered group of 
scalar values. A literal list can be composed as a comma-separated list of
values contained in parentheses, for example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>(1,2,3)                  # array of three values 1, 2, and 3
(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;)    # array of three values &quot;one&quot;, &quot;two&quot;, and &quot;three&quot;</PRE
></BLOCKQUOTE
>


The generic form of list creation uses the quoting operator <CODE
CLASS="literal"
>qw//</CODE
> to
contain a list of values separated by white space:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>qw/snap crackle pop/</PRE
></BLOCKQUOTE
>
&#13;</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2.4"
>4.2.4 Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="PNUT-CH-4-IX-VARIABLES"
></A
>A variable always begins with the character that identifies its
type: <CODE
CLASS="literal"
>$</CODE
>, <CODE
CLASS="literal"
>@</CODE
>, or <CODE
CLASS="literal"
>%</CODE
>.  Most of the variable names you
create can begin with a letter or underscore, followed by any combination
of letters, digits, or underscores, up to 255 characters in length. 
Upper- and lowercase letters are distinct. Variable names that begin
with a digit can only contain digits, and variable names that begin with a
character other than
an alphanumeric or underscore can contain only that character.
The latter forms are usually predefined variables in Perl, so it
is best to name your variables beginning with a letter or underscore.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2754"
></A
>Variables have the <CODE
CLASS="literal"
>undef</CODE
> value before they are first assigned
or when they become &quot;empty.&quot; For scalar variables, <CODE
CLASS="literal"
>undef</CODE
>
evaluates to zero when used as a number, and a zero-length, empty 
string (<CODE
CLASS="literal"
>&quot;&quot;</CODE
>) when used as a string.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2760"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2763"
></A
>Simple variable assignment uses the assignment operator (<CODE
CLASS="literal"
>=</CODE
>) with
the appropriate data. For example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$age = 26;		# assigns 26 to $age
@date = (8, 24, 70);	# assigns the three-element list to @date
%fruit = ('apples', 3, 'oranges', 6); 
 # assigns the list elements to %fruit in key/value pairs</PRE
></BLOCKQUOTE
>

<A
CLASS="indexterm"
NAME="AUTOID-2768"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2771"
></A
>
Scalar variables are always named
with an initial <CODE
CLASS="literal"
>$</CODE
>,
even when referring to a scalar value that is part of an array or hash.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2776"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2778"
></A
>Every variable type has its own namespace. You can, without fear of
conflict, use the same name for a scalar variable, an array, or a hash
(or, for that matter, a filehandle, a subroutine name, or a label). 
This means that <CODE
CLASS="literal"
>$foo</CODE
> and <CODE
CLASS="literal"
>@foo</CODE
> are two
different variables. It also means that <CODE
CLASS="literal"
>$foo[1]</CODE
> is an element
of <CODE
CLASS="literal"
>@foo</CODE
>, not a part of <CODE
CLASS="literal"
>$foo</CODE
>. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2.4.1"
>4.2.4.1 Arrays</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2788"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2790"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2794"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2797"
></A
>An array is a variable that
stores an ordered list of scalar values. Arrays are preceded by an &quot;at&quot; (@) sign.


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>@numbers = (1,2,3);	# Set the array @numbers to (1,2,3)</PRE
></BLOCKQUOTE
>


To refer to a single element of an array, use the dollar sign (<CODE
CLASS="literal"
>$</CODE
>) with the variable
name (it's a scalar), followed by the index of the element in square brackets (the <EM
CLASS="emphasis"
>subscript
operator</EM
>). 
Array elements
are numbered starting at 0. Negative indexes count backwards from the
last element in the list (i.e., -1 refers to the last element of the list).
For example, in this list:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>@date = (8, 24, 70);</PRE
></BLOCKQUOTE
>


<CODE
CLASS="literal"
>$date[2]</CODE
> is the value of the third element, 70.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2.4.2"
>4.2.4.2 Hashes</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2808"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2810"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2813"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2816"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2819"
></A
>A hash is a set of key/value pairs.
Hashes are preceded by a percent (%) sign.  
To refer to a single element of a hash, you use the hash variable
name followed by the &quot;key&quot; associated with the value in curly brackets.
For example, the hash:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>%fruit = ('apples', 3, 'oranges', 6);</PRE
></BLOCKQUOTE
>


has two values (in key/value pairs). If you want to get the value
associated with the key <CODE
CLASS="literal"
>apples</CODE
>, you use <CODE
CLASS="literal"
>$fruit{'apples'}</CODE
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2826"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2829"
></A
>It is often more readable to use the <CODE
CLASS="literal"
>=&gt;</CODE
> operator in defining
key/value pairs.
The <CODE
CLASS="literal"
>=&gt;</CODE
> operator is similar to a comma, but it's
more visually distinctive, and it also quotes any bare identifiers to
the left of it:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>%fruit = (
    apples  =&gt; 3,
    oranges =&gt; 6
);</PRE
></BLOCKQUOTE
>
&#13;</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2.5"
>4.2.5 Scalar and List Contexts</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2838"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2840"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2842"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2845"
></A
>Every operation
that you invoke in a Perl script is evaluated in a
specific context, and how that operation behaves may depend on
which context it is being called in. There are two major contexts:
<EM
CLASS="emphasis"
>scalar</EM
> and <EM
CLASS="emphasis"
>list</EM
>. 
All operators know which context they are in,
and some return lists in contexts wanting a list, and scalars in
contexts wanting a scalar. <A
CLASS="indexterm"
NAME="AUTOID-2849"
></A
>
For example, the <CODE
CLASS="literal"
>localtime</CODE
> function returns a nine-element
list in list context:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();</PRE
></BLOCKQUOTE
>


But in a scalar context, <CODE
CLASS="literal"
>localtime</CODE
> returns the number of seconds since
January 1, 1970:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$now = localtime();</PRE
></BLOCKQUOTE
>


Statements that look confusing are easy to evaluate by identifying the proper
context. For example, assigning what is commonly a list literal to a scalar variable:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$a = (2, 4, 6, 8);</PRE
></BLOCKQUOTE
>


gives <CODE
CLASS="literal"
>$a</CODE
> the value 8. The context forces the right side to evaluate to a scalar,
and the action of the comma operator in the expression (in the scalar context) returns the
value farthest to the right. </P
><P
CLASS="para"
>Another type of statement that might be confusing is the evaluation
of an array or hash variable as a scalar, for example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$b = @c;</PRE
></BLOCKQUOTE
>


When an array variable is evaluated as a scalar, the number of elements in the array is
returned. This type of evaluation is useful for finding the number of elements in an
array. 
The special <CODE
CLASS="literal"
>$#</CODE
><CODE
CLASS="replaceable"
><I
>array</I
></CODE
> form of an array value returns the
index of the last member of the list (one less than the number of elements).</P
><P
CLASS="para"
>If necessary, you can force a scalar context in the middle of a list by<A
CLASS="indexterm"
NAME="AUTOID-2862"
></A
>
using the <CODE
CLASS="literal"
>scalar</CODE
> function. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-4-SECT-2.6"
>4.2.6 Declarations and Scope</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2868"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2871"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2873"
></A
>In Perl, only subroutines and formats require
explicit declaration. Variables (and similar constructs) are
automatically created when they are first assigned.</P
><P
CLASS="para"
>Variable declaration comes into play when you need to limit the
scope of a variable's use. You can do this in two ways: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2880"
></A
><EM
CLASS="emphasis"
>Dynamic scoping</EM
>
creates temporary objects within a scope. Dynamically scoped constructs
are visible globally, but only take action within their defined scopes.
Dynamic scoping applies to variables declared with <CODE
CLASS="literal"
>local</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2886"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2888"
></A
><EM
CLASS="emphasis"
>Lexical scoping</EM
> creates private constructs that are only visible
within their scopes.
The most frequently seen form of lexically scoped declaration is the
declaration of <CODE
CLASS="literal"
>my</CODE
> variables.</P
></LI
></UL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2893"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2896"
></A
>Therefore, we can say that a <CODE
CLASS="literal"
>local</CODE
> variable is 
<EM
CLASS="emphasis"
>dynamically scoped</EM
>, 
whereas a <CODE
CLASS="literal"
>my</CODE
> variable
is <EM
CLASS="emphasis"
>lexically scoped</EM
>. 
Dynamically scoped variables are visible to
functions called from within the block in which they are
declared. Lexically scoped variables, on the other hand, are 
totally hidden from the
outside world, including any called subroutines unless they are declared within
the same scope.</P
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch04_07.htm"
TITLE="Subroutines"
>Section 4.7, "Subroutines</A
>&quot; later in this chapter for 
further discussion.<A
CLASS="indexterm"
NAME="AUTOID-2904"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2905"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_01.htm"
TITLE="4.1 Program Structure"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.1 Program Structure"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl in a Nutshell"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl in a Nutshell"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_03.htm"
TITLE="4.3 Statements"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.3 Statements"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.1 Program Structure</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.3 Statements</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<p><!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
