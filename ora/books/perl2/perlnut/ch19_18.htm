<HTML
><HEAD
>
<TITLE>19.18 OLE Automation (Perl in a Nutshell)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl in a Nutshell"><META
NAME="DC.creator"
CONTENT="Ellen Siever, Stephen Spainhour &amp; Nathan Patwardhan"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T02:00:24Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-286-7"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch19_01.htm"
TITLE="19. Win32 Modules and Extensions"><LINK
REL="prev"
HREF="ch19_17.htm"
TITLE="19.17 Win32 Extensions"><LINK
REL="next"
HREF="ch20_01.htm"
TITLE="20. PerlScript"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Perl in a Nutshell"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,71"
HREF="index.htm"
ALT="Perl in a Nutshell"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch19_17.htm"
TITLE="19.17 Win32 Extensions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 19.17 Win32 Extensions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch19_01.htm"
TITLE="19. Win32 Modules and Extensions"
>Chapter 19<BR>Win32 Modules and Extensions</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="CHAPTER"
HREF="ch20_01.htm"
TITLE="20. PerlScript"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 20. PerlScript"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18"
>19.18 OLE Automation</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="PNUT-CH-19-IX-OLE-AUTOMATION"
></A
><A
CLASS="indexterm"
NAME="PNUT-CH-19-IX-WIN32-MODULES-WIN32OLE-MODULES"
></A
>The Win32::OLE modules give Perl support for OLE automation. OLE automation
is a Microsoft technology based on COM that allows objects created by another
application to be used and manipulated by a program through a common interface.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-44611"
></A
>The application (or DLL) that implements the automation interface is called
the <EM
CLASS="emphasis"
>automation server</EM
>. The application that creates and uses the
interface is called the <EM
CLASS="emphasis"
>automation controller</EM
> or <EM
CLASS="emphasis"
>automation client</EM
>.
Many popular applications expose their objects through automation. Microsoft
Word, Excel, and other Office applications can be used as automation servers.
Automation is widely used by Active Server Pages (ASP) and CGI scripts to access
data repositories, perhaps via ActiveX Data Objects (ADO). You can even use
automation to control many development environments and editors.</P
><P
CLASS="para"
>In order to create an automation object, the server needs to be <EM
CLASS="emphasis"
>registered</EM
>
on the system. This is typically done by the server's installation program, but
can be done manually using a utility like <EM
CLASS="emphasis"
>regsvr32.exe</EM
>. This involves
adding entries to the system registry to tell COM how to find the component,
what types of interfaces it provides, what type of server it is, etc.
You should be able to find the object model, available methods and properties
of the interface in the documentation provided by the application. This
object model can be used via Perl's object syntax to create and control
objects in your programs.</P
><P
CLASS="para"
>Four modules provide automation functionality to Perl:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Win32::OLE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Provides the main interface for OLE automation. You can create or open
automation objects, use their methods, and set their properties.</P
></DD
><DT
CLASS="term"
>Win32::OLE::Enum</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Creates objects for collections and defines an interface for enumerating them.</P
></DD
><DT
CLASS="term"
>Win32::OLE::Variant</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Allows you to convert the Variant data type used in OLE.</P
></DD
><DT
CLASS="term"
>Win32::OLE::Const</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Imports constants from an automation object into your script.</P
></DD
></DL
><P
CLASS="para"
>There are a few limitations to Win32::OLE to note. There is currently no
support for OCXs or OLE events (notifications generated by the
automation server). Win32::OLE implements the <CODE
CLASS="literal"
>IDispatch</CODE
> interface
only, and therefore cannot access a custom OLE interface.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.1"
>19.18.1 Creating Objects</A
></H3
><P
CLASS="para"
>Automation objects are represented in Perl as instances of Win32::OLE
objects. The module provides three constructors for creating objects
from a registered automation server.
<UL
CLASS="nutlist"
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_163.htm#"
TITLE="Reference: new"
>new</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_164.htm#"
TITLE="Reference: GetActiveObject"
>GetActiveObject</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_165.htm#"
TITLE="Reference: GetObject"
>GetObject</A
></LI
></UL
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.2"
>19.18.2 Automation Methods and Properties</A
></H3
><P
CLASS="para"
>Once you have created an automation object, you can use its methods
or adjust its properties as you require. Automation methods are
implemented as you'd expect with the Perl object syntax:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$obj-&gt;some_method(args);</PRE
></BLOCKQUOTE
>


Automation methods can often take a number of optional parameters.
You can pass <CODE
CLASS="literal"
>undef</CODE
> for any unwanted parameters in the arguments
list. For example, you can save a WorkBook in Excel with <CODE
CLASS="literal"
>SaveAs</CODE
>.
Additional settings allow you to add the WorkBook to the MRU list and
create a backup copy:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$xl-&gt;WorkBooks(1)-&gt;SaveAs($f, undef, undef, undef, undef, 1, undef, undef, 1);</PRE
></BLOCKQUOTE
>


For simplification, you can also use just the named parameters you
want to set by passing a reference to a hash containing them. You
can do this right in the argument list by creating an anonymous hash
reference with <CODE
CLASS="literal"
>{}</CODE
>. The previous example can therefore be
written like this:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$xl-&gt;WorkBooks(1)-&gt;SaveAs($f, {AddtoMru =&gt; 1, CreateBackup =&gt; 1});</PRE
></BLOCKQUOTE
>


Properties of automation objects are accessed via hash reference notation
on the object. For example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$val = $obj-&gt;{&quot;property&quot;};         # get a property value
$obj-&gt;{&quot;property&quot;} = $val;         # set a property value</PRE
></BLOCKQUOTE
>


Be aware that properties may not be writable (or even readable). Many
automation objects have read-only properties and will generate an exception
if you try to write to them. You'll need to consult the documentation for
the object to find out which properties you can safely set.</P
><P
CLASS="para"
>You can enumerate the properties of an automation object using the normal
methods for enumerating hashes, which are <CODE
CLASS="literal"
>keys</CODE
> and <CODE
CLASS="literal"
>each</CODE
>. 
Here's how you can print the properties and values contained within
an object:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$xl = Win32::OLE-&gt;new('Excel.Application', 'Quit');
while( ($key,$value) = each %$xl ) {
    print &quot;$key=$value\n&quot;;
}</PRE
></BLOCKQUOTE
>
&#13;</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.2.1"
>19.18.2.1 Win32::OLE methods</A
></H4
><P
CLASS="para"
>Win32::OLE defines a couple of its own methods for dealing with the
automation interface. These are not automation-defined 
methods, although they look the same. If a given method is not defined
in Win32::OLE, the method call is dispatched to the automation object.
If the method doesn't exist there, you will get an OLE error.</P
><P
CLASS="para"
>The following methods are defined by Win32::OLE:
<UL
CLASS="nutlist"
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_166.htm#"
TITLE="Reference: Invoke"
>Invoke</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_167.htm#"
TITLE="Reference: LastError"
>LastError</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_168.htm#"
TITLE="Reference: QueryObjectType"
>QueryObjectType</A
></LI
></UL
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.2.2"
>19.18.2.2 Win32::OLE functions</A
></H4
><P
CLASS="para"
>The following functions are defined by Win32::OLE. They are not exported
by default.
<UL
CLASS="nutlist"
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_169.htm#"
TITLE="Reference: in"
>in</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_170.htm#"
TITLE="Reference: valof"
>valof</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_171.htm#"
TITLE="Reference: with"
>with</A
></LI
></UL
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.2.3"
>19.18.2.3 Win32::OLE class variables</A
></H4
><P
CLASS="para"
>The Win32::OLE module defines certain class variables that
set default behavior for automation usage.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>$Win32::OLE::CP</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Determines the codepage used by all translations 
between Perl strings and Unicode strings used by the OLE interface. 
The default value is <CODE
CLASS="literal"
>CP_ACP</CODE
>, which is the default ANSI codepage.
It can also be set to <CODE
CLASS="literal"
>CP_OEMCP</CODE
>, which is the default OEM codepage. 
Both constants are not exported by default. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$Win32::OLE::LCID</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Controls the locale identifier used for all OLE calls. It is set 
to <CODE
CLASS="literal"
>LOCALE_NEUTRAL</CODE
> by default. Check the Win32 module 
for other locale-related information. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$Win32::OLE::Warn</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Determines the behavior of the Win32::OLE module when an error happens. 
Valid values are: 

<DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>0</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Ignore error, return <CODE
CLASS="literal"
>undef</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>1</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Use <CODE
CLASS="literal"
>Carp::carp</CODE
> if <CODE
CLASS="literal"
>$^W</CODE
> is set (<EM
CLASS="emphasis"
>-w</EM
> option).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>2</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Always use <CODE
CLASS="literal"
>Carp::carp</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>3</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Use <CODE
CLASS="literal"
>Carp::croak</CODE
>.</P
></DD
></DL
>

The error number and message (without <CODE
CLASS="literal"
>Carp</CODE
> line/module info) are 
also available through the <CODE
CLASS="literal"
>Win32::OLE-&gt;LastError</CODE
> method. </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.3"
>19.18.3 Win32::OLE::Enum</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-44851"
></A
><A
CLASS="indexterm"
NAME="AUTOID-44854"
></A
>The Win32::OLE::Enum module provides special support for collections.
Collections are special automation data types that contain
an array of objects or data. A collection supports enumeration&nbsp;- you
can iterate through each item through a standard interface.</P
><P
CLASS="para"
>Collection objects should always provide a <CODE
CLASS="literal"
>Count</CODE
> property (the number
of items in the collection) and an <CODE
CLASS="literal"
>Item</CODE
> method. The <CODE
CLASS="literal"
>Item</CODE
> method is used
to access a particular collection item using a subscript, which may
be an integer or a string, depending on the server. Collection objects
may also optionally contain an <CODE
CLASS="literal"
>Add</CODE
> and a <CODE
CLASS="literal"
>Remove</CODE
> method.</P
><P
CLASS="para"
>Collection objects also support a standard COM interface (IEnumVARIANT) 
that allows you to enumerate each
item in a collection. It defines methods that let you advance the iteration to the next item, 
skip a given item, restart the enumeration, and create a new copy of the iterator.
While all servers are supposed to provide this interface, some servers don't 
implement all of the methods (often <CODE
CLASS="literal"
>Reset</CODE
> and <CODE
CLASS="literal"
>Clone</CODE
>).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-44866"
></A
><A
CLASS="indexterm"
NAME="AUTOID-44869"
></A
>Win32::OLE::Enum defines these methods for enumerating collections.
The collection object should provide the <CODE
CLASS="literal"
>Count</CODE
> and <CODE
CLASS="literal"
>Item</CODE
>
methods, which are often all you need to use on collections. For example:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$cnt = $coll-&gt;Count();
if( $cnt) {
    $obj = $coll-&gt;Item(0);
    $obj-&gt;do_something();
}</PRE
></BLOCKQUOTE
>


<CODE
CLASS="literal"
>Count</CODE
> will tell you how many items are in the collection,
and <CODE
CLASS="literal"
>Item</CODE
> will return the desired item as a Win32::OLE object.</P
><P
CLASS="para"
>For the enumeration methods, you need to create an enumeration object
for the collection object:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$coll = $obj-&gt;some_coll();
$enum = Win32::OLE::Enum-&gt;new($coll);</PRE
></BLOCKQUOTE
>


Now you can use the enumeration methods on the object.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.3.1"
>19.18.3.1 Win32::OLE::Enum methods</A
></H4
><P
CLASS="para"
>The following methods are defined in Win32::OLE::Enum:
<UL
CLASS="nutlist"
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_172.htm#"
TITLE="Reference: new"
>new</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_173.htm#"
TITLE="Reference: All"
>All</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_174.htm"
TITLE="Reference: Clone"
>Clone</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_175.htm#"
TITLE="Reference: Next"
>Next</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_176.htm#"
TITLE="Reference: Reset"
>Reset</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_177.htm#"
TITLE="Reference: Skip"
>Skip</A
></LI
></UL
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.4"
>19.18.4 Win32::OLE::Variant</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-44957"
></A
><A
CLASS="indexterm"
NAME="AUTOID-44960"
></A
>All automation data has to be coerced into a special type called a Variant. Most of 
the time, you don't need to worry about explicit type coercion. You just provide 
your scalar data and the magic of automation takes care of the rest of it. How-
ever, there are cases when you want to control the exact type of data you're send-
ing to the automation server. The Win32::OLE::Variant module 
provides access to the Variant data type and lets you control exactly how the 
data is represented.</P
><P
CLASS="para"
>A Variant is an OLE data structure that contains a type 
field and a data field. The flags are implemented in Perl (as are many constants) as 
subroutines that return an integer value. The table below lists the Variant type flags, 
along with a brief description of each.

</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Type</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Description</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_EMPTY</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> 
No value specified. Incidentally, automation does not use VT_EMPTY 
for empty optional parameters. Rather, it uses VT_ERROR with a 
value of DISP_E_PARAMNOTFOUND (which isn't exported by Perl: the 
value in current Win32 SDK headers is 0x80020004).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_NULL</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>  
A propagating NULL value was specified (not to be confused with a 
null pointer). This is used for things like the NULL in SQL.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_I2</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A 2-byte integer value.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_I4</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A 4-byte integer value.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_R4</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>An IEEE 4-byte real value.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_R8</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>An IEEE 8-byte real value.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_CY</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>An automation currency value. </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_DATE</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>An automation date value.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_BSTR</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A string value.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_DISPATCH</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The value contains another automation object.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_ERROR</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> 
An error code was specified. The type of the error is determined by 
the actual value. As mentioned earlier, this is used to implement 
empty optional parameters.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_BOOL</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> 
A Boolean (true/false) value. If all bits are 1, it's true, if all bits are 0, 
it's false. Any other value is invalid.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_VARIANT</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>The value contains another Variant.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_UNKNOWN</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> 
The value contains an IUnknown pointer (the base class of COM 
objects).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_UI1</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>An unsigned 1-byte character.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_BYREF</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> 
Can be combined with some fields to indicate that the data is being 
passed by reference, rather than by value.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>VT_ARRAY</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> 
The value contains an OLE SAFEARRAY (this flag is not currently 
exported by Perl).</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>

To convert data to a specific variant type, you create a variant
object with either the <CODE
CLASS="literal"
>new</CODE
> constructor method or the convenience
function <CODE
CLASS="literal"
>Variant</CODE
>:<A
CLASS="indexterm"
NAME="AUTOID-45031"
></A
>


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$vnt = Win32::OLE::Variant-&gt;new(type, data);
$vnt = Variant(type, data);</PRE
></BLOCKQUOTE
>


For example, to force a string to be interpreted as a date, create a
variant object and set it to the <CODE
CLASS="literal"
>VT_DATE</CODE
> type:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$dt = Variant(VT_DATE, &quot;August 24, 1970&quot;);   # create an explicit data type
$sheet-&gt;Cells(1,1)-&gt;{Value} = $dt;           # set it to a spreadsheet cell</PRE
></BLOCKQUOTE
>
&#13;</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.4.1"
>19.18.4.1 Win32::OLE::Variant methods</A
></H4
><P
CLASS="para"
>The following methods are defined by Win32::OLE::Variant for
working with Variant data types:
<UL
CLASS="nutlist"
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_178.htm#"
TITLE="Reference: As"
>As</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_179.htm"
TITLE="Reference: ChangeType"
>ChangeType</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_180.htm#"
TITLE="Reference: Type"
>Type</A
></LI
><LI
CLASS="term"
><A
CLASS="nutentry"
HREF="c19_181.htm#"
TITLE="Reference: Value"
>Value</A
></LI
></UL
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PNUT-CH-19-SECT-18.5"
>19.18.5 Win32::OLE::Const</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-45086"
></A
>While browsing through the documentation for an automation object, you may 
have come across references to constant values. For example, if you're trying to 
save an Excel workbook to a different file format, you need to provide a file for-
mat constant. Since the server documentation typically provides symbolic con-
stants (e.g., <CODE
CLASS="literal"
>xlExcel5</CODE
> or <CODE
CLASS="literal"
>xlTemplate</CODE
>), we need a way to access those from Perl. 
This is the purpose of Win32::OLE::Const, which imports the constants from an automation 
object into your script.</P
><P
CLASS="para"
>You can either import the constants directly into your namespace as subs that 
return the constant value, or you can have them returned as a hash reference with 
the constant name as the key and its value as the value. Here's an example of the 
former:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>use Win32::OLE::Const (&quot;Microsoft Excel&quot;);
print &quot;xlExcel5 = &quot;, xlExcel5, &quot;\n&quot;;</PRE
></BLOCKQUOTE
>


which produces something like:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>xlExcel5 = 39</PRE
></BLOCKQUOTE
>

<A
CLASS="indexterm"
NAME="AUTOID-45094"
></A
>
Here's an example using the <CODE
CLASS="literal"
>Load</CODE
> method to return a hash reference populated 
with the constants and their values (this produces the same output as the previ-
ous example, of course):


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>use Win32::OLE::Const;

my $constants = Win32::OLE::Const-&gt;Load(&quot;Microsoft Excel&quot;);
print &quot;xlExcel5 = $constants-&gt;{xlExcel5}\n&quot;;</PRE
></BLOCKQUOTE
>


Notice that, in both cases, we're supplying a regular expression for the name of 
the type library from which we want to import. <CODE
CLASS="literal"
>Win32::OLE::Const</CODE
> searches the 
registry for matching type libraries and loads the one with the highest version 
number (you can override this by supplying the version you want). You can also 
specify the language you'd like. The parameters (for either <CODE
CLASS="literal"
>Load</CODE
> or 
<CODE
CLASS="literal"
>Win32::OLE::Const</CODE
>) are the typelib regular expression, the major version number, the minor version number, and the locale (LCID).</P
><P
CLASS="para"
>You can also provide the <CODE
CLASS="literal"
>Load</CODE
> method with an automation object, which is then 
queried for its type library. Interestingly, the documentation notes that this seems 
to be slower than searching the Registry (though neither is really speedy with a 
large automation server like Excel). Here's an example of that:


<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>use Win32::OLE;
use Win32::OLE::Const;

# create an Excel application object
my $xl = Win32::OLE-&gt;new('Excel.Application', 'Quit') ||
  die &quot;Can't create Excel: &quot;, Win32::OLE-&gt;LastError;

# import the constants from it 
my $constants = Win32::OLE::Const-&gt;Load($xl);</PRE
></BLOCKQUOTE
>


Using <CODE
CLASS="literal"
>Load</CODE
> (to get a hash reference for the constants) may be preferable to 
importing all of the constants into your namespace. Some automation servers pro-
vide a large number of constants (the current version of Excel has some 900+), so 
importing them into your namespace can clutter things considerably.</P
><A
CLASS="indexterm"
NAME="AUTOID-45106"
></A
><A
CLASS="indexterm"
NAME="AUTOID-45107"
></A
><A
CLASS="indexterm"
NAME="AUTOID-45108"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch19_17.htm"
TITLE="19.17 Win32 Extensions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 19.17 Win32 Extensions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl in a Nutshell"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl in a Nutshell"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="CHAPTER"
HREF="ch20_01.htm"
TITLE="20. PerlScript"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 20. PerlScript"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>19.17 Win32 Extensions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>20. PerlScript</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
></P
></DIV
<p><!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="index.htm"><area shape="rect" coords="162,2,248,125" href="../prog/index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm"></map> </BODY
></HTML
>
