<html>
<head>
<title>Using Hard References (Programming Perl)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Using Hard References">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home">
<map name="banner-map"><AREA SHAPE="RECT" COORDS="0,0,466,71" HREF="index.htm" ALT="Programming Perl"><AREA SHAPE="RECT" COORDS="467,0,514,18" HREF="jobjects/fsearch.htm" ALT="Search this book">
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch08_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch08_01.htm">Chapter 8: References</a></td><td align="right" valign="top" width="172"><a href="ch08_04.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">8.3. Using Hard References</h2>

<p>
<a name="INDEX-2006"></a><a name="INDEX-2007"></a>
Just as there are numerous ways to create references, there are also
several ways to use, or <em class="emphasis">dereference</em>, a reference.  There is just one
overriding principle: Perl does no implicit referencing or
dereferencing.<a href="#FOOTNOTE-4">[4]</a>  When a scalar is
holding a reference, it always behaves like a simple scalar.  It doesn't
magically start being an array or hash or subroutine; you have to tell
it explicitly to do so, by dereferencing it.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-4"></a>
<p>[4] We already confessed that this was a small
fib.  We're not about to do so again.</p>

</blockquote>


<h3 class="sect2">8.3.1. Using a Variable as a Variable Name</h3>

<p>
<a name="INDEX-2008"></a>
When you encounter a scalar like <tt class="literal">$foo</tt>, you should be thinking "the
scalar value of <tt class="literal">foo</tt>."  That is, there's a <tt class="literal">foo</tt> entry in the symbol
table, and the <tt class="literal">$</tt> funny character is a way of looking at whatever
scalar value might be inside.  If what's inside is a reference, you can
look inside <em class="emphasis">that</em> (dereferencing <tt class="literal">$foo</tt>) by prepending another funny
character.  Or looking at it the other way around, you can replace the
literal <tt class="literal">foo</tt> in <tt class="literal">$foo</tt> with a scalar variable that points to the
actual referent.  This is true of any variable type, so not only is
<tt class="literal">$$foo</tt> the scalar value of whatever <tt class="literal">$foo</tt> refers to, but <tt class="literal">@$bar</tt>
is the array value of whatever <tt class="literal">$bar</tt> refers to, <tt class="literal">%$glarch</tt> is the hash
value of whatever <tt class="literal">$glarch</tt> refers to, and so on.  The upshot
is that you can put an extra funny character on the front of any
simple scalar variable to dereference it:
<blockquote>
<pre class="programlisting">$foo         = "three humps";
$scalarref   = \$foo;         # $scalarref is now a reference to $foo
$camel_model = $$scalarref;   # $camel_model is now "three humps"</pre>
</blockquote>

Here are some other dereferences:
<blockquote>
<pre class="programlisting">$bar = $$scalarref;

push(@$arrayref, $filename);
$$arrayref[0] = "January";            # Set the first element of @$arrayref
@$arrayref[4..6] = qw/May June July/; # Set several elements of @$arrayref

%$hashref = (KEY =&gt; "RING", BIRD =&gt; "SING");  # Initialize whole hash
$$hashref{KEY} = "VALUE";                     # Set one key/value pair
@$hashref{"KEY1","KEY2"} = ("VAL1","VAL2");   # Set two more pairs

&amp;$coderef(1,2,3);

print $handleref "output\n";</pre>
</blockquote>
<a name="INDEX-2009"></a>
</p>

<p>This form of dereferencing can only make use of a simple scalar
variable (one without a subscript).  That is, dereferencing happens
<em class="emphasis">before</em> (or binds tighter than) any array or hash
lookups.  Let's use some braces to clarify what we mean: an expression
like <tt class="literal">$$arrayref[0]</tt> is equivalent to
<tt class="literal">${$arrayref}[0]</tt> and means the first element of the
array referred to by <tt class="literal">$arrayref</tt>.  That is not at all
the same as <tt class="literal">${$arrayref[0]}</tt>, which is dereferencing

the first element of the (probably nonexistent) array named
<tt class="literal">@arrayref</tt>.  Likewise,
<tt class="literal">$$hashref{KEY}</tt> is the same as
<tt class="literal">${$hashref}{KEY}</tt>, and has nothing to do with
<tt class="literal">${$hashref{KEY}}</tt>, which would be dereferencing an
entry in the (probably nonexistent) hash named
<tt class="literal">%hashref</tt>.  You will be miserable until you
understand this.</p>

<p>You can achieve multiple levels of referencing and dereferencing by
concatenating the appropriate funny characters.  The following prints
"<tt class="literal">howdy</tt>":
<blockquote>
<pre class="programlisting">$refrefref = \\\"howdy";
print $$$$refrefref;</pre>
</blockquote>

You can think of the dollar signs as operating right to left.  But the
beginning of the chain must still be a simple, unsubscripted scalar
variable.  There is, however, a way to get fancier, which we already sneakily
used earlier, and which we'll explain in the next section.</p>






<h3 class="sect2">8.3.2. Using a BLOCK as a Variable Name</h3>

<a name="INDEX-2010"></a>
<p>Not only can you dereference a simple variable name, you can also
dereference the contents of a <em class="replaceable">BLOCK</em>.  Anywhere you'd put an
alphanumeric identifier as part of a variable or subroutine name, you
can replace the identifier with a <em class="replaceable">BLOCK</em> returning a reference of the
correct type.  In other words, the earlier examples could all be
disambiguated like this:
<blockquote>
<pre class="programlisting">$bar = ${$scalarref};
push(@{$arrayref}, $filename);
${$arrayref}[0] = "January";
@{$arrayref}[4..6] = qw/May June July/;
${$hashref}{"KEY"} = "VALUE";
@{$hashref}{"KEY1","KEY2"} = ("VAL1","VAL2");
&amp;{$coderef}(1,2,3);</pre>
</blockquote>

not to mention:
<blockquote>
<pre class="programlisting">$refrefref = \\\"howdy";
print ${${${$refrefref}}};</pre>
</blockquote>

Admittedly, it's silly to use the braces in these simple cases, but
the <em class="replaceable">BLOCK</em> can contain any arbitrary expression. In particular, it
can contain subscripted expressions. In the following example,
<tt class="literal">$dispatch{$index}</tt> is assumed to contain a reference to a subroutine
(sometimes called a "coderef"). The example invokes the subroutine with
three arguments.
<blockquote>
<pre class="programlisting">&amp;{ $dispatch{$index} }(1, 2, 3);</pre>
</blockquote>

Here, the <em class="replaceable">BLOCK</em> is necessary.  Without that outer pair of braces,
Perl would have treated <tt class="literal">$dispatch</tt> as the coderef instead of
<tt class="literal">$dispatch{$index}</tt>.</p>






<h3 class="sect2">8.3.3. Using the Arrow Operator</h3>

<p>
<a name="INDEX-2011"></a><a name="INDEX-2012"></a><a name="INDEX-2013"></a><a name="INDEX-2014"></a><a name="INDEX-2015"></a>
</p>

<p>For references to arrays, hashes, or subroutines, a third method of
dereferencing involves the use of the <tt class="literal">-&gt;</tt> infix
operator.  This form of syntactic sugar that makes it easier to
get at individual array or hash elements, or to call a subroutine
indirectly.</p>

<p>The type of the dereference is determined by the right operand, that
is, by what follows directly after the arrow.  If the next thing after
the arrow is a bracket or brace, the left operand is treated as a
reference to an array or a hash, respectively, to be subscripted by the
expression on the right.  If the next thing is a left parenthesis, the
left operand is treated as a reference to a subroutine, to be called
with whatever parameters you supply in the parentheses on the right.</p>

<p>Each of these next trios is equivalent, corresponding to the three
notations we've introduced. (We've inserted some spaces to line up
equivalent elements.)
<blockquote>
<pre class="programlisting">$  $arrayref  [2] = "Dorian";         #1
${ $arrayref }[2] = "Dorian";         #2
   $arrayref-&gt;[2] = "Dorian";         #3

$  $hashref  {KEY} = "F#major";       #1
${ $hashref }{KEY} = "F#major";       #2
   $hashref-&gt;{KEY} = "F#major";       #3

&amp;  $coderef  (Presto =&gt; 192);         #1
&amp;{ $coderef }(Presto =&gt; 192);         #2
   $coderef-&gt;(Presto =&gt; 192);         #3</pre>
</blockquote>

You can see that the initial funny character is missing from the third
notation in each trio.  The funny character is guessed at by Perl,
which is why it can't be used to dereference complete arrays, complete hashes,
or slices of either.  As long as you stick with scalar values, though,
you can use any expression to the left of the <tt class="literal">-&gt;</tt>, including
another dereference, because multiple arrow operators associate left to
right:
<blockquote>
<pre class="programlisting">print $array[3]-&gt;{"English"}-&gt;[0];</pre>
</blockquote>

You can deduce from this expression that the fourth element of
<tt class="literal">@array</tt> is intended to be a hash reference, and the value of the
"<tt class="literal">English</tt>" entry in that hash is intended to be an array reference.</p>

<p>Note that <tt class="literal">$array[3]</tt> and <tt class="literal">$array-&gt;[3]</tt> are not the same. The
first is talking about the fourth element of <tt class="literal">@array</tt>, while the
second one is talking about the fourth element of the (possibly
anonymous) array whose reference is contained in <tt class="literal">$array</tt>.</p>

<p>Suppose now that <tt class="literal">$array[3]</tt> is undefined.  The following statement
is still legal:
<blockquote>
<pre class="programlisting">$array[3]-&gt;{"English"}-&gt;[0] = "January";</pre>
</blockquote>

This is one of those cases mentioned earlier in which references spring
into existence (or "autovivify") when used as an lvalue (that is, when
a value is being assigned to it).  If <tt class="literal">$array[3]</tt> was
undefined, it's automatically defined as a hash reference so that we
can set a value for <tt class="literal">$array[3]-&gt;{"English"}</tt> in it.  Once that's
done, <tt class="literal">$array[3]-&gt;{"English"}</tt> is automatically defined as an
array reference so that we can assign something to the first element in
that array.  Note that rvalues are a little different: <tt class="literal">print $array[3]-&gt;{"English"}-&gt;[0]</tt> only defines <tt class="literal">$array[3]</tt> and <tt class="literal">$array[3]-&gt;{"English"}</tt>, not <tt class="literal">$array[3]-&gt;{"English"}-&gt;[0]</tt>,
since the final element is not an lvalue.  (The fact that it defines
the first two at all in an rvalue context could be considered a bug.
We may fix that someday.)</p>

<p>The arrow is optional between brackets or braces, or between a closing
bracket or brace and a parenthesis for an indirect function call.  So
you can shrink the previous code down to:
<blockquote>
<pre class="programlisting">$dispatch{$index}(1, 2, 3);
$array[3]{"English"}[0] = "January";</pre>
</blockquote>

In the case of ordinary arrays, this gives you multidimensional arrays
that are just like C's array:
<blockquote>
<pre class="programlisting">$answer[$x][$y][$z] += 42;</pre>
</blockquote>

Well, okay, not <em class="emphasis">entirely</em> like C's arrays.  For one thing, C doesn't
know how to grow its arrays on demand, while Perl does.  Also, some constructs that are similar in the two languages parse differently. In Perl,
the following two statements do the same thing:
<blockquote>
<pre class="programlisting">$listref-&gt;[2][2] = "hello";    # Pretty clear
$$listref[2][2]  = "hello";    # A bit confusing</pre>
</blockquote>

This second of these statements may disconcert the C programmer, who
is accustomed to using <tt class="literal">*a[i]</tt> to mean "what's
pointed to by the <em class="emphasis">i</em>th element of
<tt class="literal">a</tt>".  But in Perl, the five characters (<tt class="literal">$ @
* % &amp;</tt>) effectively bind more tightly than braces or
brackets.<a href="#FOOTNOTE-5">[5]</a> Therefore, it is
<tt class="literal">$$listref</tt> and not <tt class="literal">$listref[2]</tt>
that is taken to be a

reference

to an array. If you want the C behavior, either you have to write
<tt class="literal">${$listref[2]}</tt>
to force the <tt class="literal">$listref[2]</tt> to get evaluated before
the leading <tt class="literal">$</tt> dereferencer, or you have to use the
<tt class="literal">-&gt;</tt> notation:
<blockquote>
<pre class="programlisting">$listref[2]-&gt;[$greeting] = "hello";</pre>
</blockquote>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-5"></a>
<p>[5] But not because of operator precedence.  The
funny characters in Perl are not operators in that sense.  Perl's
grammar simply prohibits anything more complicated than a simple
variable or block from following the initial funny character, for
various funny reasons.</p>

</blockquote>






<h3 class="sect2">8.3.4. Using Object Methods</h3>

<a name="INDEX-2016"></a><a name="INDEX-2017"></a><a name="INDEX-2018"></a><a name="INDEX-2019"></a>
<p>If a reference happens to be a reference to an object, then the class
that defines that object probably provides methods to access the
innards of the object, and you should generally stick to those methods
if you're merely using the class (as opposed to implementing it).  In other
words, be nice, and don't treat an object like a regular reference,
even though Perl lets you when you really need to.  Perl does not
enforce encapsulation.  We are not totalitarians here.  We do expect
some basic civility, however.</p>

<p>In return for this civility, you get complete orthogonality between
objects and data structures.  Any data structure can behave as an object
when you want it to.  Or not, when you don't.</p>





<a name="ch08-sect-pseudo"></a>
<h3 class="sect2">8.3.5. Pseudohashes</h3>

<a name="INDEX-2020"></a>
<p>A <em class="emphasis">pseudohash</em> is any reference to an array whose first element is a
reference to a hash.  You can treat the pseudohash reference as either an
array reference (as you would expect) or a hash reference (as you might not expect).  Here's an example of a pseudohash:
<blockquote>
<pre class="programlisting">$john = [ {age =&gt; 1, eyes =&gt; 2, weight =&gt; 3}, 47, "brown", 186 ];</pre>
</blockquote>

The underlying hash in <tt class="literal">$john-&gt;[0]</tt> defines the names (<tt class="literal">"age"</tt>, <tt class="literal">"eyes"</tt>,
<tt class="literal">"weight"</tt>) of the array elements that follow (<tt class="literal">47</tt>, <tt class="literal">"brown"</tt>, <tt class="literal">186</tt>).  Now
you can access an element with both hash and array notations:
<blockquote>
<pre class="programlisting">$john-&gt;{weight}             # Treats $john as a hashref
$john-&gt;[3]                  # Treats $john as an arrayref</pre>
</blockquote>

Pseudohash magic is not deep; it only knows one "trick": how to turn a hash dereference into an array dereference. When adding another element to a
pseudohash, you have to explicitly tell the underlying mapping hash where the element
will reside before you can use the hash notation:
<blockquote>
<pre class="programlisting">$john-&gt;[0]{height} = 4;     # height is to be element 4
$john-&gt;{height} = "tall";   # Or $john-&gt;[4] = "tall"</pre>
</blockquote>

Perl raises an exception if you try to delete a key from a pseudohash,
although you can always delete keys from the mapping hash.  Perl
also raises an exception if you try to access a nonexistent key,

where "existence" means presence in the mapping hash:
<blockquote>
<pre class="programlisting">delete $john-&gt;[0]{height};  # Deletes from the underlying hash only
$john-&gt;{height};            # This now raises an exception
$john-&gt;[4];                 # Still prints "tall"</pre>
</blockquote>

Don't try to splice the array unless you know what you're
doing.  If the array elements move around, the mapping hash values
will still refer to the <em class="emphasis">old</em> element positions, unless you change
those explicitly, too.  Pseudohash magic is not deep.</p>

<p>To avoid inconsistencies, you can use the <tt class="literal">fields::phash</tt> function
provided by the <tt class="literal">use fields</tt> pragma to create a pseudohash:
<blockquote>
<pre class="programlisting">use fields;
$ph = fields::phash(age =&gt; 47, eyes =&gt; "brown", weight =&gt; 186);
print $ph-&gt;{age};</pre>
</blockquote>

There are two ways to check for the existence of a key in a
pseudohash.  The first is to use <tt class="literal">exists</tt>, which checks whether the
given field has ever been set.  It acts this way to match the behavior
of a real hash.  For instance:
<blockquote>
<pre class="programlisting">use fields;
$ph= fields::phash([qw(age eyes brown)], [47]);
$ph-&gt;{eyes} = undef;

print exists $ph-&gt;{age};     # True, 'age' was set in declaration.
print exists $ph-&gt;{weight};  # False, 'weight' has not been used.
print exists $ph-&gt;{eyes};    # True, your 'eyes' have been touched.</pre>
</blockquote>

The second way is to use <tt class="literal">exists</tt> on the mapping hash sitting in the
first array element.  This checks whether the given key is a valid
field for that pseudohash:
<blockquote>
<pre class="programlisting">print exists $ph-&gt;[0]{age};   # True, 'age' is a valid field
print exists $ph-&gt;[0]{name};  # False, 'name' can't be used</pre>
</blockquote>

Unlike what happens in a real hash, calling <tt class="literal">delete</tt> on a pseudohash
element deletes only the array value corresponding to the key, not the
real key in the mapping hash.  To delete the key, you have to
explicitly delete it from the mapping hash.  Once you do that, you may
no longer use that key name as a pseudohash subscript:
<blockquote>
<pre class="programlisting">print delete $ph-&gt;{age};     # Removes and returns $ph-&gt;[1], 47
print exists $ph-&gt;{age};     # Now false
print exists $ph-&gt;[0]{age};  # True, 'age' key still usable
print delete $ph-&gt;[0]{age};  # Now 'age' key is gone
print $ph-&gt;{age};            # Run-time exception</pre>
</blockquote>

You've probably begun to wonder what could possibly have motivated
this masquerade of arrays prancing about in hashes' clothing.  Arrays
provide faster lookups and more efficient storage, while hashes offer the
convenience of naming (instead of numbering) your data;
pseudohashes provide the best of both worlds.  But it's not until you
consider Perl's compilation phase that the greatest benefit becomes
apparent.  With the help of a pragma or two, the compiler can verify
proper access to valid fields, so you can find out about nonexistent
subscripts (or spelling errors) before your program starts to run.</p>

<p>Pseudohashes' properties of speed, efficiency, and compile-time
access checking (you might even think of it as type safety) are
especially handy for creating efficient and robust class modules.
See the discussion of the <tt class="literal">use fields</tt> pragma in <a href="ch12_01.htm">Chapter 12, "Objects"</a> and <a href="ch31_01.htm">Chapter 31, "Pragmatic Modules"</a>.</p>

<p>Pseudohashes are a new and relatively experimental feature; as such,
the underlying implementation may well change in the future.  To
protect yourself from such changes, always go through the <tt class="literal">fields</tt>
module's documented interface via its <tt class="literal">phash</tt> and <tt class="literal">new</tt> functions.</p>





<a name="ch08-sect-tricks"></a>
<h3 class="sect2">8.3.6. Other Tricks You Can Do with Hard References</h3>

<p>As mentioned earlier, the backslash operator is usually used
on a single referent to generate a single reference, but it doesn't have
to be.  When used on a list of referents, it produces a list of
corresponding references.  The second line of the following example does the same thing as the first line, since the backslash
is automatically distributed throughout the whole list.
<blockquote>
<pre class="programlisting">@reflist = (\$s, \@a, \%h, \&amp;f);     # List of four references
@reflist = \($s,  @a   %h,  &amp;f);     # Same thing</pre>
</blockquote>

If a parenthesized list contains exactly one array or hash, then all
of its values are interpolated and references to each returned:
<blockquote>
<pre class="programlisting">@reflist = \(@x);                    # Interpolate array, then get refs
@reflist = map { \$_ } @x;           # Same thing</pre>
</blockquote>

This also occurs when there are internal parentheses:
<blockquote>
<pre class="programlisting">@reflist = \(@x, (@y));              # But only single aggregates expand
@reflist = (\@x, map { \$_ } @y);    # Same thing</pre>
</blockquote>

If you try this with a hash, the result will contain references to
the values (as you'd expect), but references to <em class="emphasis">copies</em> of the keys
(as you might not expect).</p>

<p>Since array and hash slices are really just lists, you can backslash a
slice of either of these to get a list of references.  Each of the
next three lines does exactly the same thing:
<blockquote>
<pre class="programlisting">@envrefs = \@ENV{'HOME', 'TERM'};         # Backslashing a slice
@envrefs = \( $ENV{HOME},  $ENV{TERM} );  # Backslashing a list
@envrefs = ( \$ENV{HOME}, \$ENV{TERM} );  # A list of two references</pre>
</blockquote>

Since functions can return lists, you can apply a backslash to them.
If you have more than one function to call, first interpolate each
function's return values into a larger list and then backslash the
whole thing:
<blockquote>
<pre class="programlisting">@reflist = \fx();
@reflist = map { \$_ } fx();                # Same thing

@reflist = \( fx(), fy(), fz() );
@reflist = ( \fx(), \fy(), \fz() );         # Same thing
@reflist = map { \$_ } fx(), fy(), fz();    # Same thing</pre>
</blockquote>
<a name="INDEX-2021"></a>
The backslash operator always supplies a list context to its operand,
so those functions are all called in list context.  If the backslash
is itself in scalar context, you'll end up with a reference to the
last value of the list returned by the function:
<blockquote>
<pre class="programlisting">@reflist = \localtime();      # Ref to each of nine time elements
$lastref = \localtime();      # Ref to whether it's daylight savings time</pre>
</blockquote>

In this regard, the backslash behaves like the named Perl list
operators, such as <tt class="literal">print</tt>, <tt class="literal">reverse</tt>, and <tt class="literal">sort</tt>, which always
supply a list context on their right no matter what might be happening
on their left.  As with named list operators, use an explicit
<tt class="literal">scalar</tt> to force what follows into scalar context:
<blockquote>
<pre class="programlisting">$dateref = \scalar localtime();    # \"Sat Jul 16 11:42:18 2000"</pre>
</blockquote>
<a name="INDEX-2022"></a>
</p>

<p>You can use the <tt class="literal">ref</tt> operator to determine what a reference is
pointing to.  Think of <tt class="literal">ref</tt> as a "typeof" operator that returns true
if its argument is a reference and false otherwise.  The value
returned depends on the type of thing referenced. Built-in types
include <tt class="literal">SCALAR</tt>, <tt class="literal">ARRAY</tt>, <tt class="literal">HASH</tt>, <tt class="literal">CODE</tt>, <tt class="literal">GLOB</tt>, <tt class="literal">REF</tt>,
<tt class="literal">LVALUE</tt>, <tt class="literal">IO</tt>, <tt class="literal">IO::Handle</tt>, and <tt class="literal">Regexp</tt>.  Here, we use
it to check subroutine arguments:
<blockquote>
<pre class="programlisting">sub sum {
    my $arrayref = shift;
    warn "Not an array reference" if ref($arrayref) ne "ARRAY";
    return eval join("+", @$arrayref);
}</pre>
</blockquote>
<a name="INDEX-2023"></a><a name="INDEX-2024"></a>
</p>

<p>If you use a hard reference in a string context, it'll be converted to
a string containing both the type and the address:
<tt class="literal">SCALAR(0x1fc0e)</tt>. (The reverse conversion cannot be done, since
reference count information is lost during stringification--and also
because it would be dangerous to let programs access a memory address
named by an arbitrary string.)</p>

<p>
<a name="INDEX-2025"></a><a name="INDEX-2026"></a><a name="INDEX-2027"></a>
You can use the <tt class="literal">bless</tt> operator to associate a referent with a
package functioning as an object class.  When you do this, <tt class="literal">ref</tt>
returns the class name instead of the internal type.  An object
reference used in a string context returns a string with the external
and internal types, and the address in memory:
<tt class="literal">MyType=HASH(0x20d10)</tt> or <tt class="literal">IO::Handle=IO(0x186904)</tt>.  See <a href="ch12_01.htm">Chapter 12, "Objects"</a> for more details about objects.</p>

<p>
<a name="INDEX-2028"></a><a name="INDEX-2029"></a>
Since the way in which you dereference something always indicates what
sort of referent you're looking for, a typeglob can be used the same
way a reference can, despite the fact that a typeglob contains
multiple referents of various types.  So <tt class="literal">${*main::foo}</tt> and <tt class="literal">${\$main::foo}</tt>
both access the same scalar variable, although the latter is more
efficient.</p>

<p>
<a name="INDEX-2030"></a>
Here's a trick for interpolating the return value of a subroutine call
into a string:
<blockquote>
<pre class="programlisting">print "My sub returned @{[ mysub(1,2,3) ]} that time.\n";</pre>
</blockquote>

It works like this.  At compile time, when the <tt class="literal">@{...}</tt> is seen
within the double-quoted string, it's parsed as a block that returns
a reference.  Within the block, there are square brackets that
create a reference to an anonymous array from whatever is in the
brackets.  So at run time, <tt class="literal">mysub(1,2,3)</tt> is called in list context,
and the results are loaded into an anonymous array, a reference to
which is then returned within the block.  That array reference is
then immediately dereferenced by the surrounding <tt class="literal">@{...}</tt>, and the
array value is interpolated into the double-quoted string just as
an ordinary array would be.  This chicanery is also useful for
arbitrary expressions, such as:
<blockquote>
<pre class="programlisting">print "We need @{ [$n + 5] } widgets!\n";</pre>
</blockquote>

Be careful though: square brackets supply a list context to their
expression.  In this case it doesn't matter, although the earlier call
to <tt class="literal">mysub</tt> might care.  When it does matter, use an
explicit <tt class="literal">scalar</tt> to force the context:
<blockquote>
<pre class="programlisting">print "mysub returns @{ [scalar mysub(1,2,3)] } now.\n";</pre>
</blockquote>
</p>





<a name="ch08-sect-closure"></a>
<h3 class="sect2">8.3.7. Closures</h3>

<a name="INDEX-2031"></a><a name="INDEX-2032"></a><a name="INDEX-2033"></a>
<p>Earlier we talked about creating anonymous subroutines with a nameless
<tt class="literal">sub {}</tt>.  You can think of those subroutines as
defined at run time, which means that they have a time of generation
as well as a location of definition.  Some variables might be in scope
when the subroutine is created, and different variables might be in
scope when the subroutine is called.</p>

<p>Forgetting about subroutines for a moment, consider a reference that
refers to a lexical variable:
<blockquote>
<pre class="programlisting">{
    my $critter = "camel";
    $critterref = \$critter;
}</pre>
</blockquote>

The value of <tt class="literal">$$critterref</tt> will remain
"<tt class="literal">camel</tt>" even though <tt class="literal">$critter</tt>
disappears after the closing curly brace.  But
<tt class="literal">$critterref</tt> could just as well have referred to a
subroutine that refers to <tt class="literal">$critter</tt>:
<blockquote>
<pre class="programlisting">{
    my $critter = "camel";
    $critterref = sub { return $critter };
}</pre>
</blockquote>

This is a <em class="emphasis">closure</em>, which is a notion out of the functional
programming world of LISP and Scheme.<a href="#FOOTNOTE-6">[6]</a> It means that when you define an anonymous
function in a particular lexical scope at a particular moment, it
pretends to run in that scope even when later called from outside that
scope.  (A purist would say it doesn't have to pretend--it actually
<em class="emphasis">does</em> run in that scope.)</p>
<blockquote class="footnote">

<a name="FOOTNOTE-6"></a>
<p>[6] In this context, the
word "functional" should not be construed as an antonym of
"dysfunctional".</p>

</blockquote>

<p>In other words, you are guaranteed to get the same copy of a lexical
variable each time, even if other instances of that lexical variable
have been created before or since for other instances of that closure.
This gives you a way to set values used in a subroutine when you define
it, not just when you call it.</p>

<p>
<a name="INDEX-2034"></a>
You can also think of closures as a way to write a subroutine template
without using <tt class="literal">eval</tt>.  The lexical variables act as
parameters for filling in the template, which is useful for setting up
little bits of code to run later.  These are commonly called
<em class="emphasis">callbacks</em> in event-based programming, where you
associate a bit of code with a keypress, mouse click, window exposure,
and so on.  When used as callbacks, closures do exactly what you
expect, even if you don't know the first thing about functional
programming.  (Note that this closure business only applies to
<tt class="literal">my</tt> variables.  Global variables work as they've
always worked, since they're neither created nor destroyed the way
lexical variables are.)</p>

<p>
<a name="INDEX-2035"></a>
Another use for closures is within <em class="emphasis">function
generators</em>; that is, functions that create and return brand
new functions.  Here's an example of a function generator implemented
with closures:
<blockquote>
<pre class="programlisting">sub make_saying  {
    my $salute = shift;
    my $newfunc = sub {
        my $target = shift;
        print "$salute, $target!\n";
    };
    return $newfunc;            # Return a closure
}

$f = make_saying("Howdy");      # Create a closure
$g = make_saying("Greetings");  # Create another closure

# Time passes...

$f-&gt;("world");
$g-&gt;("earthlings");</pre>
</blockquote>

This prints:
<blockquote>
<pre class="programlisting">Howdy, world!
Greetings, earthlings!</pre>
</blockquote>

Note in particular how <tt class="literal">$salute</tt> continues to refer to the actual
value passed into <tt class="literal">make_saying</tt>, despite the fact that the <tt class="literal">my $salute</tt> has gone out of scope by the time the anonymous subroutine
runs.  That's what closures are all about.  Since <tt class="literal">$f</tt> and <tt class="literal">$g</tt> hold
references to functions that, when called, still need access to the
distinct versions of <tt class="literal">$salute</tt>, those versions automatically stick
around.  If you now overwrite <tt class="literal">$f</tt>, <em class="emphasis">its</em> version of <tt class="literal">$salute</tt> would
automatically disappear.  (Perl only cleans up when you're not looking.)</p>

<p>
<a name="INDEX-2036"></a><a name="INDEX-2037"></a><a name="INDEX-2038"></a>
Perl doesn't provide references to object methods (described in
<a href="ch12_01.htm">Chapter 12, "Objects"</a>) but you can get a similar effect using a
closure.  Suppose you want a reference not just to the subroutine the
method represents, but one which, when invoked, would call that method
on a particular object.  You can conveniently remember both the object
and the method as lexical variables bound up inside a closure:
<blockquote>
<pre class="programlisting">sub get_method_ref {
    my ($self, $methodname) = @_;
    my $methref = sub {
        # the @_ below is not the same as the one above!
        return $self-&gt;$methodname(@_);
    };
    return $methref;
}

my $dog = new Doggie::
            Name =&gt; "Lucky",
            Legs =&gt; 3,
            Tail =&gt; "clipped";

our $wagger = get_method_ref($dog, 'wag');
$wagger-&gt;("tail");        # Calls $dog-&gt;wag('tail').</pre>
</blockquote>

Not only can you get Lucky to wag what's left of his tail now, even
once the lexical <tt class="literal">$dog</tt> variable has gone out of scope and Lucky
is nowhere to be seen, the global <tt class="literal">$wagger</tt> variable can still get
him to wag his tail, wherever he is.</p>

<a name="ch08-sect-clos"></a>
<h3 class="sect3">8.3.7.1. Closures as function templates</h3>

<p>
<a name="INDEX-2039"></a><a name="INDEX-2040"></a>
Using a closure as a function template allows you to generate many
functions that act similarly.  Suppose you want a suite of functions that
generate HTML font changes for various colors:
<blockquote>
<pre class="programlisting">print "Be ", red("careful"), "with that ", green("light"), "!!!";</pre>
</blockquote>

The <tt class="literal">red</tt> and <tt class="literal">green</tt> functions would be very similar.  We'd like to
name our functions, but closures don't have names since they're just
anonymous subroutines with an attitude.  To get around that, we'll
perform the cute trick of naming our anonymous subroutines.  You can
bind a coderef to an existing name by assigning it to a typeglob of
the name of the function you want.  (See the section <a href="ch10_01.htm">Section 8.1, "Symbol Tables"</a> in <a href="ch10_01.htm">Chapter 10, "Packages"</a>.  In this case, we'll bind it to two
different names, one uppercase and one lowercase:
<blockquote>
<pre class="programlisting">@colors = qw(red blue green yellow orange purple violet);
for my $name (@colors) {
    no strict 'refs';       # Allow symbolic references
    *$name = *{uc $name} = sub { "&lt;FONT COLOR='$name'7gt;@_&lt;/FONT&gt;" };
}</pre>
</blockquote>

Now you can call functions named <tt class="literal">red</tt>,
<tt class="literal">RED</tt>, <tt class="literal">blue</tt>,
<tt class="literal">BLUE</tt>, and so on, and the appropriate closure will
be invoked.  This technique reduces compile time and conserves memory,
and is less error-prone as well, since syntax checks happen during
compilation.  It's critical that any variables in the anonymous
subroutine be lexicals in order to create a closure.  That's the
reason for the <tt class="literal">my</tt> above.</p>

<p>
<a name="INDEX-2041"></a>
This is one of the few places where giving a prototype to a closure
makes sense.  If you wanted to impose scalar context on the arguments
of these functions (probably not a wise idea for this
example), you could have written it this way instead:
<blockquote>
<pre class="programlisting">*$name = sub ($) { "&lt;FONT COLOR='$name'&gt;$_[0]&lt;/FONT&gt;" };</pre>
</blockquote>

That's almost good enough.  However, since prototype checking happens
during compile time, the run-time assignment above happens too late to
be of much use.  You could fix this by putting the whole loop of
assignments within a <tt class="literal">BEGIN</tt> block, forcing it to
occur during compilation.  (More likely, you'd put it out in a module
that you <tt class="literal">use</tt> at compile time.)  Then the prototypes
will be visible during the rest of the compilation.</p>




<h3 class="sect3">8.3.7.2. Nested subroutines</h3>

<p>
<a name="INDEX-2042"></a><a name="INDEX-2043"></a><a name="INDEX-2044"></a>
If you are accustomed (from other programming languages) to using
subroutines nested within other subroutines, each with their own
private variables, you'll have to work at it a bit in Perl.  Named
subroutines do not nest properly, although anonymous ones
do.<a href="#FOOTNOTE-7">[7]</a>  Anyway, we
can emulate nested, lexically scoped subroutines using closures.  Here's an
example:
<blockquote>
<pre class="programlisting">sub outer {
    my $x = $_[0] + 35;
    local *inner = sub { return $x * 19 };
    return $x + inner();
}</pre>
</blockquote>

Now <tt class="literal">inner</tt> can only be called from within <tt class="literal">outer</tt>, because of
the temporary assignments of the closure.  But when it is, it has normal
access to the lexical variable <tt class="literal">$x</tt> from the scope of <tt class="literal">outer</tt>.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-7"></a>
<p>[7]To be more precise, globally named subroutines
don't nest.  Unfortunately, that's the only kind of named subroutine
declaration we have.  We haven't yet implemented lexically scoped,
named subroutines (known as <tt class="literal">my sub</tt>s), but when we do,
they should nest correctly.</p>

</blockquote>

<p>This has the interesting effect of creating a function local to another
function, something not normally supported in Perl.  Because <tt class="literal">local</tt>
is dynamically scoped, and because function names are global to their
package, any other function that <tt class="literal">outer</tt> called could also call the
temporary version of <tt class="literal">inner</tt>.  To prevent that, you'd need
an extra level of indirection:
<blockquote>
<pre class="programlisting">sub outer {
    my $x = $_[0] + 35;
    my $inner = sub { return $x * 19 };
    return $x + $inner-&gt;();
}</pre>
</blockquote>
</p>

<a name="INDEX-2045"></a><a name="INDEX-2046"></a><a name="INDEX-2047"></a>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch08_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch08_04.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">8.2. Creating References</td><td align="center" valign="top" width="171"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">8.4. Symbolic References</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm">
</map>

<!-- END OF BODY -->

</body>
</html>
