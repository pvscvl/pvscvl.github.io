<html>
<head>
<title>Operators (Programming Perl)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Operators">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home">
<map name="banner-map"><AREA SHAPE="RECT" COORDS="0,0,466,71" HREF="index.htm" ALT="Programming Perl"><AREA SHAPE="RECT" COORDS="467,0,514,18" HREF="jobjects/fsearch.htm" ALT="Search this book">
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_04.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch01_01.htm">Chapter 1: An Overview of Perl</a></td><td align="right" valign="top" width="172"><a href="ch01_06.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">1.5. Operators</h2>

<p>
<a name="INDEX-190"></a><a name="INDEX-191"></a>
As we alluded to earlier, Perl is also a mathematical language.  This is
true at several levels, from low-level bitwise logical operations, up
through number and set manipulation, on up to larger predicates and
abstractions of various sorts.  And as we all know from studying math in
school, mathematicians love strange symbols.  What's worse, computer
scientists have come up with their own versions of these strange
symbols.  Perl has a number of these strange symbols too, but take
heart, most are borrowed directly from C, FORTRAN, <em class="emphasis">sed</em>(1) or
<em class="emphasis">awk</em>(1), so they'll at least be familiar to users of those languages.</p>

<p>The rest of you can take comfort in knowing that, by learning all these
strange symbols in Perl, you've given yourself a head start on all
those other strange languages.</p>

<p>
<a name="INDEX-192"></a><a name="INDEX-193"></a><a name="INDEX-194"></a><a name="INDEX-195"></a><a name="INDEX-196"></a>
Perl's built-in operators may be classified by number of operands into
unary, binary, and trinary (or ternary) operators.  They may be
classified by whether they're prefix operators (which go in front of
their operands) or infix operators (which go in between their
operands).  They may also be classified by the kinds of objects they
work with, such as numbers, strings, or files.  Later, we'll give you a
table of all the operators, but first here are some handy ones to get you
started.</p>


<h3 class="sect2">1.5.1. Some Binary Arithmetic Operators</h3>

<p>
<a name="INDEX-197"></a>
</p>

<p>Arithmetic operators do what you would expect from learning them
in school.  They perform some sort of mathematical function on numbers.
For example:</p>


<a name="perl3-tab-over-math"></a>
<table border="1">

<tr>
<th>Example</th>
<th>Name</th>
<th>Result</th>
</tr>




<tr>
<td><tt class="literal">$a + $b</tt></td>
<td>Addition</td>
<td>Sum of <tt class="literal">$a</tt> and <tt class="literal">$b</tt><a name="INDEX-198"></a></td>
</tr>

<tr>
<td><tt class="literal">$a * $b</tt></td>
<td>Multiplication</td>
<td>Product of <tt class="literal">$a</tt> and <tt class="literal">$b</tt><a name="INDEX-199"></a></td>
</tr>

<tr>
<td><tt class="literal">$a % $b</tt></td>
<td>Modulus</td>
<td>Remainder of <tt class="literal">$a</tt> divided by <tt class="literal">$b</tt></td>
</tr>

<tr>
<td><tt class="literal">$a ** $b</tt></td>
<td>Exponentiation</td>
<td><tt class="literal">$a</tt> to the power of <tt class="literal">$b</tt></td>
</tr>


</table>
<p>
<a name="INDEX-200"></a><a name="INDEX-201"></a>
Yes, we left out subtraction and division--we suspect you can figure
out how they should work.  Try them and see if you're right.  (Or cheat
and look in <a href="ch03_01.htm">Chapter 3, "Unary and Binary Operators"</a>.)  Arithmetic operators are
evaluated in the order your math teacher taught you (exponentiation
before multiplication; multiplication before addition).  You can
always use parentheses to make it come out differently.</p>






<h3 class="sect2">1.5.2. String Operators</h3>

<p>
<a name="INDEX-202"></a><a name="INDEX-203"></a><a name="INDEX-204"></a><a name="INDEX-205"></a><a name="INDEX-206"></a>
</p>

<p>There is also an "addition" operator for strings that performs
concatenation (that is, joining strings end to end). Unlike some languages that
confuse this with numeric addition, Perl defines a separate operator
(<tt class="literal">.</tt>) for string concatenation:
<blockquote>
<pre class="programlisting">$a = 123;
$b = 456;
print $a + $b;     # prints 579
print $a . $b;     # prints 123456</pre>
</blockquote>
<a name="INDEX-207"></a><a name="INDEX-208"></a><a name="INDEX-209"></a><a name="INDEX-210"></a>
</p>

<p>
<a name="INDEX-211"></a><a name="INDEX-212"></a><a name="INDEX-213"></a>
There's also a "multiply" operator for strings, called the
<em class="emphasis">repeat</em> operator.  Again, it's a separate operator (<tt class="literal">x</tt>) to keep it
distinct from numeric multiplication:
<blockquote>
<pre class="programlisting">$a = 123;
$b = 3;
print $a * $b;     # prints 369
print $a x $b;     # prints 123123123</pre>
</blockquote>

These string operators bind as tightly as their corresponding arithmetic
operators.  The repeat operator is a bit unusual in taking a string for
its left argument but a number for its right argument.  Note also how
Perl is automatically converting from numbers to strings. You could have
put all the literal numbers above in quotes, and it would still have
produced the same output.  Internally though, it would have been
converting in the opposite direction (that is, from strings to numbers).</p>

<p>
<a name="INDEX-214"></a><a name="INDEX-215"></a>
A couple more things to think about.  String concatenation is also
implied by the interpolation that happens in double-quoted strings.  And when
you print out a list of values, you're also effectively concatenating
strings.  So

the following three statements produce the same output:
<blockquote>
<pre class="programlisting">print $a . ' is equal to ' . $b . ".\n";    # dot operator
print $a, ' is equal to ', $b, ".\n";       # list
print "$a is equal to $b.\n";               # interpolation</pre>
</blockquote>

Which of these you use in any particular situation is entirely up to
you.  (But bear in mind that interpolation is often the most readable.)</p>

<p>The <tt class="literal">x</tt> operator may seem relatively worthless at first glance, but it
is quite useful at times, especially for things like this:
<blockquote>
<pre class="programlisting">print "-" x $scrwid, "\n";</pre>
</blockquote>

which draws a line across your screen, presuming <tt class="literal">$scrwid</tt> contains
your screen width, and not your screw identifier.</p>






<h3 class="sect2">1.5.3. Assignment Operators</h3>

<p>
<a name="INDEX-216"></a><a name="INDEX-217"></a><a name="INDEX-218"></a>
Although it's not exactly a mathematical operator, we've already made
extensive use of the simple assignment operator, <tt class="literal">=</tt>.  Try to remember
that <tt class="literal">=</tt> means "gets set to" rather than "equals".  (There is also a
mathematical equality operator <tt class="literal">==</tt> that means "equals", and if you
start out thinking about the difference between them now, you'll save
yourself a lot of headache later.  The <tt class="literal">==</tt> operator is like a function
that returns a Boolean value, while <tt class="literal">=</tt> is more like a procedure that
is evaluated for the side effect of modifying a variable.)</p>

<p>
<a name="INDEX-219"></a><a name="INDEX-220"></a>
Like the operators described earlier, assignment operators are binary infix
operators, which means they have an operand on either side of the
operator.  The right operand can be any expression you like, but the
left operand must be a valid <em class="emphasis">lvalue</em> (which, when translated to
English, means a valid storage location like a variable, or a location
in an array).  The most common assignment operator is simple assignment.
It determines the value of the expression on its right side, and then sets
the variable on the left side to that value:
<blockquote>
<pre class="programlisting">$a = $b;
$a = $b + 5;
$a = $a * 3;</pre>
</blockquote>

Notice the last assignment refers to the same variable twice; once for
the computation, once for the assignment.  There's nothing wrong with
that, but it's a common enough operation that there's a shortcut for it
(borrowed from C).  If you say:
<blockquote>
<pre class="programlisting">lvalue operator= expression</pre>
</blockquote>
it is evaluated as if it were:
<blockquote>
<pre class="programlisting">lvalue = lvalue operator expression</pre>
</blockquote>

except that the lvalue is not computed twice.  (This only makes a
difference if evaluation of the lvalue has side effects.  But when it
<em class="emphasis">does</em> make a difference, it usually does what you want.  So don't
sweat it.)</p>

<p>So, for example, you could write the previous example as:
<blockquote>
<pre class="programlisting">$a *= 3;</pre>
</blockquote>

which reads "multiply <tt class="literal">$a</tt> by 3".  You can do this with almost any
binary operator in Perl, even some that you can't do it with in C:
<blockquote>
<pre class="programlisting">$line .= "\n";  # Append newline to $line.
$fill x= 80;    # Make string $fill into 80 repeats of itself.
$val ||= "2";   # Set $val to 2 if it isn't already "true".</pre>
</blockquote>

Line 6 of our Average Example<a href="#FOOTNOTE-16">[16]</a> contains two string concatenations, one of
which is an assignment operator.  And line 14 contains a <tt class="literal">+=</tt>.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-16"></a>
<p>[16]Thought we'd forgotten it,
didn't you?</p>

</blockquote>

<p>
<a name="INDEX-221"></a><a name="INDEX-222"></a>
Regardless of which kind of assignment operator you use, the final
value of the variable on the left is returned as the value of the
assignment as a whole.<a href="#FOOTNOTE-17">[17]</a> This will not surprise C programmers,
who will already know how to use this idiom to zero out variables:
<blockquote>
<pre class="programlisting">$a = $b = $c = 0;</pre>
</blockquote>

You'll also frequently see assignment used as the condition of a <tt class="literal">while</tt>
loop, as in line 4 of our average example.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-17"></a>
<p>[17] This is unlike, say, Pascal, in which
assignment is a statement and returns no value.  We said earlier that
assignment is like a procedure, but remember that in Perl, even
procedures return values.</p>

</blockquote>

<p>What <em class="emphasis">will</em> surprise C programmers is that
assignment in Perl returns the actual variable as an lvalue, so that
you can modify the same variable more than once in a statement.  For
instance, you could say:
<blockquote>
<pre class="programlisting">($temp -= 32) *= 5/9;</pre>
</blockquote>

to do an in-place conversion from Fahrenheit to Celsius.
This is also why earlier in this chapter we could say:
<blockquote>
<pre class="programlisting">chop($number = &lt;STDIN&gt;);</pre>
</blockquote>

and have it chop the final value of <tt class="literal">$number</tt>.  Generally speaking, you
can use this feature whenever you want to copy something and at the same
time do something else with it.
<a name="INDEX-223"></a><a name="INDEX-224"></a><a name="INDEX-225"></a>
</p>






<h3 class="sect2">1.5.4. Unary Arithmetic Operators</h3>

<p>
<a name="INDEX-226"></a><a name="INDEX-227"></a><a name="INDEX-228"></a><a name="INDEX-229"></a><a name="INDEX-230"></a><a name="INDEX-231"></a><a name="INDEX-232"></a>
As if <tt class="literal">$variable += 1</tt> weren't short enough, Perl borrows from C an
even shorter way to increment a variable.  The autoincrement (and
autodecrement) operators simply add (or subtract) one from the value of
the variable.  They can be placed on either side of the variable,
depending on when you want them to be evaluated:</p>

<a name="perl3-tab-over-crement"></a>
<table border="1">

<tr>
<th>Example</th>
<th>Name</th>
<th>Result</th>
</tr>




<tr>
<td><tt class="literal">++$a, $a++</tt></td>
<td>Autoincrement</td>
<td>Add 1 to <tt class="literal">$a</tt></td>
</tr>

<tr>
<td><tt class="literal">--$a, $a--</tt></td>
<td>Autodecrement</td>
<td>Subtract 1 from <tt class="literal">$a</tt></td>
</tr>


</table>
<p>
<a name="INDEX-233"></a><a name="INDEX-234"></a>
If you place one of these "auto" operators before the variable, it is known
as a pre-incremented (pre-decremented) variable.  Its value will be
changed before it is referenced.  If it is placed after the variable,
it is known as a post-incremented (post-decremented) variable, and its
value is changed after it is used.  For example:
<blockquote>
<pre class="programlisting">$a = 5;        # $a is assigned 5
$b = ++$a;     # $b is assigned the incremented value of $a, 6
$c = $a--;     # $c is assigned 6, then $a is decremented to 5</pre>
</blockquote>

Line 15 of our Average Example increments the number of scores by one,
so that we'll know how many scores we're averaging.  It uses a
post-increment operator (<tt class="literal">$scores++</tt>), but in this
case it doesn't matter, since the expression is in a void context,
which is just a funny way of saying that the expression is being
evaluated only for the side effect of incrementing the variable.  The
value returned is being thrown away.<a href="#FOOTNOTE-18">[18]</a><a name="INDEX-235"></a>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-18"></a>
<p>[18] The optimizer
will notice this and optimize the post-increment into a pre-increment,
because that's a bit faster to execute.  (You didn't need to know
that, but we hoped it would cheer you up.)</p>

</blockquote>






<h3 class="sect2">1.5.5. Logical Operators</h3>

<p>
<a name="INDEX-236"></a><a name="INDEX-237"></a><a name="INDEX-238"></a><a name="INDEX-239"></a>
Logical operators, also known as "short-circuit" operators, allow the
program to make decisions based on multiple criteria without using
nested <tt class="literal">if</tt> statements.  They are known as
short-circuit operators because they skip (short circuit) the
evaluation of their right argument if they decide the left argument
has already supplied enough information to decide the overall
value. This is not just for efficiency.  You are explicitly allowed to
depend on this short-circuiting behavior to avoid evaluating code in
the right argument that you know would blow up if the left argument
were not "guarding" it.  You can say "California or bust!" in Perl
without busting (presuming you do get to California).</p>

<p>
<a name="INDEX-240"></a><a name="INDEX-241"></a>
Perl actually has two sets of logical operators, a traditional set
borrowed from C and a newer (but even more traditional) set of
ultralow-precedence operators borrowed from BASIC.  Both sets contribute
to readability when used appropriately.  C's punctuational operators
work well when you want your logical operators to bind more tightly than
commas, while BASIC's word-based operators work well when you want your
commas to bind more tightly than your logical operators.  Often they work
the same, and which set you use is a matter of personal preference.  (For
contrastive examples, see <a href="ch03_20.htm">Section 1.20, "Logical and, or, not, and xor"</a> in <a href="ch03_01.htm">Chapter 3, "Unary and Binary Operators"</a>.)  Although the
two sets of operators are not interchangeable due to precedence, once
they're parsed, the operators themselves behave identically;
precedence merely governs the extent of their arguments.  
<a href="ch01_05.htm">Table 1-1</a> lists logical operators.</p>


<a name="perl3-tab-over-logical"></a>
<h4 class="objtitle">Table 1.1. Logical Operators</h4>
<table border="1">

<tr>
<th>Example</th>
<th>Name</th>
<th>Result</th>
</tr>




<tr>
<td><tt class="literal">$a &amp;&amp; $b</tt></td>
<td>And</td>
<td><tt class="literal">$a</tt> if <tt class="literal">$a</tt> is false,  <tt class="literal">$b</tt> otherwise<a name="INDEX-242"></a><a name="INDEX-243"></a></td>
</tr>

<tr>
<td><tt class="literal">$a || $b</tt></td>
<td>Or</td>
<td><tt class="literal">$a</tt> if <tt class="literal">$a</tt>  is true, <tt class="literal">$b</tt> otherwise<a name="INDEX-244"></a><a name="INDEX-245"></a></td>
</tr>

<tr>
<td><tt class="literal">! $a</tt></td>
<td>Not</td>
<td>True if <tt class="literal">$a</tt> is not true</td>
</tr>

<tr>
<td><tt class="literal">$a and $b</tt></td>
<td>And</td>
<td><tt class="literal">$a</tt> if <tt class="literal">$a</tt> is false, <tt class="literal">$b</tt> otherwise</td>
</tr>

<tr>
<td><tt class="literal">$a or $b</tt></td>
<td>Or</td>
<td><tt class="literal">$a</tt> if <tt class="literal">$a</tt>  is true, <tt class="literal">$b</tt> otherwise<a name="INDEX-246"></a></td>
</tr>

<tr>
<td><tt class="literal">not $a</tt></td>
<td>Not</td>
<td>True if <tt class="literal">$a</tt> is not true</td>
</tr>

<tr>
<td><tt class="literal">$a xor $b</tt></td>
<td>Xor</td>
<td>True if <tt class="literal">$a</tt> or <tt class="literal">$b</tt> is true, but not both<a name="INDEX-247"></a></td>
</tr>


</table>

<p>
<a name="INDEX-248"></a><a name="INDEX-249"></a>
Since the logical operators "short-circuit" the way they do, they're
often used in Perl to conditionally execute code.  The following line
(line 3 from our Average Example) tries to open the file
<em class="emphasis">grades</em>:
<blockquote>
<pre class="programlisting">open(GRADES, "grades") or die "Can't open file grades: $!\n";</pre>
</blockquote>

If it opens the file, it will jump to the next line of the program.  If
it can't open the file, it will provide us with an error message and
then stop execution.</p>

<p>
<a name="INDEX-250"></a>
Literally, this line means "Open <em class="emphasis">grades</em> or bust!"
Besides being another example of natural language, the short-circuit
operators preserve the visual flow. Important actions are listed down
the left side of the screen, and secondary actions are hidden off to
the right.  (The <tt class="literal">$!</tt> variable contains the error
message returned by the operating system--see
<a href="ch28_01.htm">Chapter 28, "Special Names"</a>.)  Of course, these logical
operators can also be used within the more traditional kinds of
conditional constructs, such as the <tt class="literal">if</tt> and
<tt class="literal">while</tt> statements.
<a name="INDEX-251"></a><a name="INDEX-252"></a>
</p>






<h3 class="sect2">1.5.6. Some Numeric and String Comparison Operators</h3>

<p>
<a name="INDEX-253"></a><a name="INDEX-254"></a><a name="INDEX-255"></a><a name="INDEX-256"></a>
</p>

<p>Comparison, or relational, operators tell us how two scalar values
(numbers or strings) relate to each other.  There are two sets of
operators; one does numeric comparison and the other does string
comparison.  (In either case, the arguments will be "coerced" to have
the appropriate type first.)  Assuming left and right arguments of
<tt class="literal">$a</tt> and <tt class="literal">$b</tt>, we have:</p>

<a name="perl3-tab-over-compare"></a>
<table border="1">

<tr>
<th>Comparison</th>
<th>Numeric</th>
<th>String</th>
<th>Return Value</th>
</tr>




<tr>
<td>Equal</td>
<td><tt class="literal">==</tt></td>
<td><tt class="literal">eq</tt></td>
<td>True if <tt class="literal">$a</tt> is equal to <tt class="literal">$b</tt><a name="INDEX-257"></a></td>
</tr>

<tr>
<td>Not equal</td>
<td><tt class="literal">!=</tt></td>
<td><tt class="literal">ne</tt></td>
<td>True if <tt class="literal">$a</tt> is not equal to <tt class="literal">$b</tt><a name="INDEX-258"></a></td>
</tr>

<tr>
<td>Less than</td>
<td><tt class="literal">&lt;</tt></td>
<td><tt class="literal">lt</tt></td>
<td>True if <tt class="literal">$a</tt> is less than <tt class="literal">$b</tt><a name="INDEX-259"></a></td>
</tr>

<tr>
<td>Greater than</td>
<td><tt class="literal">&gt;</tt></td>
<td><tt class="literal">gt</tt></td>
<td>True if <tt class="literal">$a</tt> is greater than <tt class="literal">$b</tt><a name="INDEX-260"></a></td>
</tr>

<tr>
<td>Less than or equal</td>
<td><tt class="literal">&lt;=</tt></td>
<td><tt class="literal">le</tt></td>
<td>True if <tt class="literal">$a</tt> not greater than <tt class="literal">$b</tt><a name="INDEX-261"></a></td>
</tr>

<tr>
<td>Comparison</td>
<td><tt class="literal">&lt;=&gt;</tt></td>
<td><tt class="literal">cmp</tt></td>
<td>0 if equal, 1 if <tt class="literal">$a</tt> greater, -1 if <tt class="literal">$b</tt> greater<a name="INDEX-262"></a><a name="INDEX-263"></a><a name="INDEX-264"></a></td>
</tr>


</table>
<p>
<a name="INDEX-265"></a><a name="INDEX-266"></a>
The last pair of operators (<tt class="literal">&lt;=&gt;</tt> and
<tt class="literal">cmp</tt>) are entirely redundant. However, they're
incredibly useful in <tt class="literal">sort</tt> subroutines (see
<a href="ch29_01.htm">Chapter 29, "Functions"</a>).<a href="#FOOTNOTE-19">[19]</a>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-19"></a>
<p>[19] Some folks feel
that such redundancy is evil because it keeps a language from being
minimalistic, or orthogonal.  But Perl isn't an orthogonal language;
it's a diagonal language.  By this we mean that Perl doesn't force you
to always go at right angles.  Sometimes you just want to follow the
hypotenuse of the triangle to get where you're going.  TMTOWTDI is
about shortcuts.  Shortcuts are about efficiency.</p>

</blockquote>






<h3 class="sect2">1.5.7. Some File Test Operators</h3>

<p>
<a name="INDEX-267"></a><a name="INDEX-268"></a><a name="INDEX-269"></a>
The file test operators allow you to test whether certain file
attributes are set before you go and blindly muck about with the files.
The most basic file attribute is, of course, whether the file exists.
For example, it would be very nice to know whether your mail aliases
file already exists before you go and open it as a new file, wiping out
everything that was in there before.  Here are a few of the
file test operators:</p>

<a name="perl3-tab-over-file"></a>
<table border="1">

<tr>
<th>Example</th>
<th>Name</th>
<th>Result</th>
</tr>




<tr>
<td><tt class="literal">-e $a</tt></td>
<td>Exists</td>
<td>True if file named in <tt class="literal">$a</tt> exists<a name="INDEX-270"></a></td>
</tr>

<tr>
<td><tt class="literal">-r $a</tt></td>
<td>Readable</td>
<td>True if file named in <tt class="literal">$a</tt> is readable<a name="INDEX-271"></a><a name="INDEX-272"></a></td>
</tr>

<tr>
<td><tt class="literal">-w $a</tt></td>
<td>Writable</td>
<td>True if file named in <tt class="literal">$a</tt> is writable<a name="INDEX-273"></a><a name="INDEX-274"></a></td>
</tr>

<tr>
<td><tt class="literal">-d $a</tt></td>
<td>Directory</td>
<td>True if file named in <tt class="literal">$a</tt> is a directory<a name="INDEX-275"></a><a name="INDEX-276"></a></td>
</tr>

<tr>
<td><tt class="literal">-f $a</tt></td>
<td>File</td>
<td>True if file named in <tt class="literal">$a</tt> is a regular file<a name="INDEX-277"></a><a name="INDEX-278"></a></td>
</tr>

<tr>
<td><tt class="literal">-T $a</tt></td>
<td>Text File</td>
<td>True if file named in <tt class="literal">$a</tt> is a text file<a name="INDEX-279"></a><a name="INDEX-280"></a></td>
</tr>


</table>
<p>You might use them like this:
<blockquote>
<pre class="programlisting">-e "/usr/bin/perl" or warn "Perl is improperly installed\n";
-f "/vmlinuz" and print "I see you are a friend of Linus\n";</pre>
</blockquote>
Note that a regular file is not the same thing as a text file.  Binary
files like <em class="emphasis">/vmlinuz</em> are regular files, but they
aren't text files.  Text files are the opposite of binary files, while
regular files are the opposite of "irregular"
files like directories
and devices.  <a name="INDEX-281"></a><a name="INDEX-282"></a>
</p>

<p>
<a name="INDEX-283"></a><a name="INDEX-284"></a>
There are a lot of file test operators, many of which we didn't list.
Most of the file tests are unary Boolean operators, which is to say
they take only one operand (a scalar that evaluates to a filename or a
filehandle), and they return either a true or false value.  A few of
them return something fancier, like the file's size or age, but you can
look those up when you need them in the section <a href="ch03_10.htm">Section 1.10, "Named Unary and File Test Operators"</a> in <a href="ch03_01.htm">Chapter 3, "Unary and Binary Operators"</a>.</p>



<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_04.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch01_06.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">1.4. Filehandles</td><td align="center" valign="top" width="171"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">1.6. Control Structures</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm">
</map>

<!-- END OF BODY -->

</body>
</html>
