<html>
<head>
<title>Pattern-Matching Operators (Programming Perl)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Pattern-Matching Operators">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home">
<map name="banner-map"><AREA SHAPE="RECT" COORDS="0,0,466,71" HREF="index.htm" ALT="Programming Perl"><AREA SHAPE="RECT" COORDS="467,0,514,18" HREF="jobjects/fsearch.htm" ALT="Search this book">
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch05_01.htm">Chapter 5: Pattern Matching</a></td><td align="right" valign="top" width="172"><a href="ch05_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">5.2. Pattern-Matching Operators</h2>

<p>
<a name="INDEX-1298"></a><a name="INDEX-1299"></a>
Zoologically speaking, Perl's pattern-matching operators function as a
kind of cage for regular expressions, to keep them from getting out.
This is by design; if we were to let the regex beasties wander
throughout the language, Perl would be a total jungle.  The world needs
its jungles, of course--they're the engines of biological diversity,
after all--but jungles should stay where they belong.  Similarly,
despite being the engines of combinatorial diversity, regular
expressions should stay inside pattern match operators where they
belong.  It's a jungle in there.</p>

<p>
<a name="INDEX-1300"></a><a name="INDEX-1301"></a><a name="INDEX-1302"></a><a name="INDEX-1303"></a><a name="INDEX-1304"></a><a name="INDEX-1305"></a><a name="INDEX-1306"></a><a name="INDEX-1307"></a><a name="INDEX-1308"></a>
As if regular expressions weren't powerful enough, the <tt class="literal">m//</tt> and
<tt class="literal">s///</tt> operators also provide the (likewise confined) power of double-quote
interpolation.  Since patterns are parsed like double-quoted strings,
all the normal double-quote conventions will work, including variable
interpolation (unless you use single quotes as the delimiter) and
special characters indicated with backslash escapes.  (See "Specific
Characters" later in this chapter.)  These are applied before the string is interpreted
as a regular expression.   (This is one of the few places in the Perl
language where a string undergoes more than one pass of processing.)
The first pass is not quite normal double-quote interpolation, in that
it knows what it should interpolate and what it should pass on to the
regular expression parser.  So, for instance, any <tt class="literal">$</tt> immediately
followed by a vertical bar, closing parenthesis, or the end of the
string will be treated not as a variable interpolation, but as the
traditional regex assertion meaning end-of-line.  So if you say:
<blockquote>
<pre class="programlisting">$foo = "bar";
/$foo$/;</pre>
</blockquote>

the double-quote interpolation pass knows that those two <tt class="literal">$</tt> signs are
functioning differently.  It does the interpolation of <tt class="literal">$foo</tt>, then
hands this to the regular expression parser:
<blockquote>
<pre class="programlisting">/bar$/;</pre>
</blockquote>
<a name="INDEX-1309"></a>
Another consequence of this two-pass parsing is that the ordinary Perl
tokener finds the end of the regular expression first, just as if it
were looking for the terminating delimiter of an ordinary string.
Only after it has found the end of the string (and done any variable
interpolation) is the pattern treated as a regular expression.  Among
other things, this means you can't "hide" the terminating delimiter of
a pattern inside a regex construct (such as a character class or a
regex comment, which we haven't covered yet).  Perl will see the
delimiter wherever it is and terminate the pattern at that point.</p>

<p>
<a name="INDEX-1310"></a><a name="INDEX-1311"></a>
You should also know that interpolating variables into a pattern slows
down the pattern matcher, because it feels it needs to check whether
the variable has changed, in case it has to recompile the pattern
(which will slow it down even further).  See "Variable Interpolation"
later in this chapter.</p>

<p>
<a name="INDEX-1312"></a>
The <tt class="literal">tr///</tt> transliteration operator does not interpolate variables;
it doesn't even use regular expressions!  (In fact, it probably doesn't
belong in this chapter at all, but we couldn't think of a better place
to put it.)  It does share one feature with <tt class="literal">m//</tt> and <tt class="literal">s///</tt>,
however: it binds to variables using the <tt class="literal">=~</tt> and <tt class="literal">!~</tt> operators.</p>

<p>
<a name="INDEX-1313"></a><a name="INDEX-1314"></a><a name="INDEX-1315"></a><a name="INDEX-1316"></a>
The <tt class="literal">=~</tt> and <tt class="literal">!~</tt> operators,
described in <a href="ch03_01.htm">Chapter 3, "Unary and Binary Operators"</a>,
bind the scalar expression on their lefthand side to one of three
quote-like operators on their right: <tt class="literal">m//</tt> for
matching a pattern, <tt class="literal">s///</tt> for substituting some
string for a substring matched by a pattern, and
<tt class="literal">tr///</tt> (or its synonym, <tt class="literal">y///</tt>) for
transliterating one set of characters to another set.  (You may write
<tt class="literal">m//</tt> as <tt class="literal">//</tt>, without the
<tt class="literal">m</tt>, if slashes are used for the delimiter.)  If the
righthand side of <tt class="literal">=~</tt> or <tt class="literal">!~</tt> is
none of these three, it still counts as a <tt class="literal">m//</tt>
matching operation, but there'll be no place to put any trailing
modifiers (see "Pattern Modifiers" later), and you'll have to handle
your own quoting:
<blockquote>
<pre class="programlisting">print "matches" if $somestring =~ $somepattern;</pre>
</blockquote>

Really, there's little reason not to spell it out explicitly:
<blockquote>
<pre class="programlisting">print "matches" if $somestring =~ m/$somepattern/;</pre>
</blockquote>

When used for a matching operation, <tt class="literal">=~</tt> and <tt class="literal">!~</tt> are sometimes
pronounced "matches" and "doesn't match" respectively (although
"contains" and "doesn't contain" might cause less confusion).</p>

<p>
<a name="INDEX-1317"></a><a name="INDEX-1318"></a><a name="INDEX-1319"></a>
Apart from the <tt class="literal">m//</tt> and <tt class="literal">s///</tt>
operators, regular expressions show up in two other places in Perl.
The first argument to the <tt class="literal">split</tt> function is a
special match operator specifying what <em class="emphasis">not</em> to
return when breaking a string into multiple substrings.  See the
description and examples for <tt class="literal">split</tt> in <a href="ch29_01.htm">Chapter 29, "Functions"</a>.  The <tt class="literal">qr//</tt> ("quote
regex") operator also specifies a pattern via a regex, but it doesn't
try to match anything (unlike <tt class="literal">m//</tt>, which does).
Instead, the compiled form of the regex is returned for future use.
See "Variable Interpolation" for more information.</p>

<p>
<a name="INDEX-1320"></a><a name="INDEX-1321"></a><a name="INDEX-1322"></a>
You apply one of the <tt class="literal">m//</tt>, <tt class="literal">s///</tt>, or <tt class="literal">tr///</tt> operators to a
particular string with the <tt class="literal">=~</tt> binding operator (which isn't a real
operator, just a kind of topicalizer, linguistically speaking).  Here
are some examples:
<blockquote>
<pre class="programlisting">$haystack =~ m/needle/                # match a simple pattern
$haystack =~  /needle/                # same thing

$italiano =~ s/butter/olive oil/      # a healthy substitution

$rotate13 =~ tr/a-zA-Z/n-za-mN-ZA-M/  # easy encryption (to break)</pre>
</blockquote>

Without a binding operator, <tt class="literal">$_</tt> is implicitly used as the "topic":
<blockquote>
<pre class="programlisting">/new life/ and              # search in $_ and (if found)
    /new civilizations/     #    boldly search $_ again

s/sugar/aspartame/          # substitute a substitute into $_

tr/ATCG/TAGC/               # complement the DNA stranded in $_</pre>
</blockquote>
<a name="INDEX-1323"></a><a name="INDEX-1324"></a>
Because <tt class="literal">s///</tt> and <tt class="literal">tr///</tt> change the scalar to which
they're applied, you may only use them on valid lvalues:
<blockquote>
<pre class="programlisting">"onshore" =~ s/on/off/;      # WRONG: compile-time error</pre>
</blockquote>

However, <tt class="literal">m//</tt> works on the result of any scalar expression:
<blockquote>
<pre class="programlisting">if ((lc $magic_hat-&gt;fetch_contents-&gt;as_string) =~ /rabbit/) {
    print "Nyaa, what's up doc?\n";
}
else {
    print "That trick never works!\n";
}</pre>
</blockquote>

But you have to be a wee bit careful, since <tt class="literal">=~</tt> and
<tt class="literal">!~</tt> have rather high precedence--in our previous
example the parentheses are necessary around the left
term.<a href="#FOOTNOTE-3">[3]</a> The <tt class="literal">!~</tt> binding operator
works like <tt class="literal">=~</tt>, but negates the logical result of
the operation:
<blockquote>
<pre class="programlisting">if ($song !~ /words/) {
    print qq/"$song" appears to be a song without words.\n/;
}</pre>
</blockquote>
<a name="INDEX-1325"></a>
Since <tt class="literal">m//</tt>, <tt class="literal">s///</tt>, and
<tt class="literal">tr///</tt> are quote operators, you may pick your own
delimiters.  These work in the same way as the quoting operators
<tt class="literal">q//</tt>, <tt class="literal">qq//</tt>,
<tt class="literal">qr//</tt>, and <tt class="literal">qw//</tt> (see the section
<a href="ch02_06.htm">Section 5.6.3, "Pick Your Own Quotes"</a> in
<a href="ch02_01.htm">Chapter 2, "Bits and Pieces"</a>).
<blockquote>
<pre class="programlisting">$path =~ s#/tmp#/var/tmp/scratch#;

if ($dir =~ m[/bin]) {
    print "No binary directories please.\n";
}</pre>
</blockquote>

When using paired delimiters with <tt class="literal">s///</tt> or <tt class="literal">tr///</tt>, if
the first part is one of the four customary bracketing pairs (angle,
round, square, or curly), you may choose different delimiters for the
second part than you chose for the first:
<blockquote>
<pre class="programlisting">s(egg)&lt;larva&gt;;
s{larva}{pupa};
s[pupa]/imago/;</pre>
</blockquote>

Whitespace is allowed in front of the opening delimiters:
<blockquote>
<pre class="programlisting">s (egg)   &lt;larva&gt;;
s {larva} {pupa};
s [pupa]  /imago/;</pre>
</blockquote>
<a name="INDEX-1326"></a><a name="INDEX-1327"></a><a name="INDEX-1328"></a>
Each time a pattern successfully matches (including the pattern in a
substitution), it sets the <tt class="literal">$`</tt>, <tt class="literal">$&amp;</tt>, and <tt class="literal">$'</tt> variables to the text
left of the match, the whole match, and the text right of the match.  This
is useful for pulling apart strings into their components:
<blockquote>
<pre class="programlisting">"hot cross buns" =~ /cross/;
print "Matched: &lt;$`&gt; $&amp; &lt;$'&gt;\n";    # Matched: &lt;hot &gt; cross &lt; buns&gt;
print "Left:    &lt;$`&gt;\n";            # Left:    &lt;hot &gt;
print "Match:   &lt;$&amp;&gt;\n";            # Match:   &lt;cross&gt;
print "Right:   &lt;$'&gt;\n";            # Right:   &lt; buns&gt;</pre>
</blockquote>
<a name="INDEX-1329"></a>
For better granularity and efficiency, use parentheses to capture the
particular portions that you want to keep around.  Each pair of
parentheses captures the substring corresponding to the
<em class="emphasis">subpattern</em> in the parentheses.  The pairs of
parentheses are numbered from left to right by the positions of the
left parentheses; the substrings corresponding to those subpatterns
are available after the match in the numbered variables,
<tt class="literal">$1</tt>, <tt class="literal">$2</tt>, <tt class="literal">$3</tt>,
and so on:<a href="#FOOTNOTE-4">[4]</a>
<blockquote>
<pre class="programlisting">$_ = "Bilbo Baggins's birthday is September 22";
/(.*)'s birthday is (.*)/;
print "Person: $1\n";
print "Date: $2\n";</pre>
</blockquote>
<a name="INDEX-1330"></a><a name="INDEX-1331"></a><a name="INDEX-1332"></a><tt class="literal">$`</tt>, <tt class="literal">$&amp;</tt>, <tt class="literal">$'</tt>, and the numbered variables are global variables
implicitly localized to the enclosing dynamic scope.  They last until
the next successful pattern match or the end of the current scope,
whichever comes first.  More on this later, in a different scope.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-3"></a>
<p>[3] Without the parentheses, the lower-precedence
<tt class="literal">lc</tt> would have applied to the whole pattern match
instead of just the method call on the magic hat
object.</p>

</blockquote>
<blockquote class="footnote">

<a name="FOOTNOTE-4"></a>
<p>[4] Not <tt class="literal">$0</tt>, though, which
holds the name of your program.</p>

</blockquote>

<p>Once Perl sees that you need one of <tt class="literal">$`</tt>,
<tt class="literal">$&amp;</tt>, or <tt class="literal">$'</tt> anywhere in the
program, it provides them for every pattern match.  This will slow
down your program a bit.  Perl uses a similar mechanism to produce
<tt class="literal">$1</tt>, <tt class="literal">$2</tt>, and so on, so you also
pay a price for each pattern that contains capturing parentheses.
(See "Clustering" to avoid the cost of capturing while still retaining
the grouping behavior.) But if you never use <tt class="literal">$`</tt><tt class="literal">$&amp;</tt>, or <tt class="literal">$'</tt>, then patterns
<em class="emphasis">without</em> capturing parentheses will not be
penalized.  So it's usually best to avoid <tt class="literal">$`</tt>,
<tt class="literal">$&amp;</tt>, and <tt class="literal">$'</tt> if you can,
especially in library modules.  But if you must use them once (and
some algorithms really appreciate their convenience), then use them at
will, because you've already paid the price.  <tt class="literal">$&amp;</tt> is
not so costly as the other two in recent versions of Perl.</p>


<h3 class="sect2">5.2.1. Pattern Modifiers</h3>

<p>
<a name="INDEX-1333"></a><a name="INDEX-1334"></a><a name="INDEX-1335"></a>
We'll discuss the individual pattern-matching operators in a moment,
but first we'd like to mention another thing they all have in common,
<em class="emphasis">modifiers</em>.</p>

<p>
<a name="INDEX-1336"></a><a name="INDEX-1337"></a><a name="INDEX-1338"></a><a name="INDEX-1339"></a>
Immediately following the final delimiter of an
<tt class="literal">m//</tt>, <tt class="literal">s///</tt>,
<tt class="literal">qr//</tt>, or <tt class="literal">tr///</tt> operator, you may
optionally place one or more single-letter modifiers, in any order.
For clarity, modifiers are usually written as "the
<tt class="literal">/o</tt> modifier" and pronounced "the slash oh
modifier", even though the final delimiter might be something other than a
slash.  (Sometimes people say "flag" or "option" to mean "modifier";
that's okay too.)
<a name="INDEX-1340"></a><a name="INDEX-1341"></a>
</p>

<p>Some modifiers change the behavior of the individual operator, so we'll
describe those in detail later.  Others change how the regex is
interpreted, so we'll talk about them here.  The <tt class="literal">m//</tt>, <tt class="literal">s///</tt>, and
<tt class="literal">qr//</tt> operators<a href="#FOOTNOTE-5">[5]</a> all accept the
following modifiers after their final delimiter:</p>
<blockquote class="footnote">

<a name="FOOTNOTE-5"></a>
<p>[5] The <tt class="literal">tr///</tt> operator does not take
regexes, so these modifiers do not apply.</p>

</blockquote>

<a name="perl3-tab-patmods"></a>
<table border="1">

<tr>
<th>Modifier</th>
<th>Meaning</th>
</tr>




<tr>
<td><tt class="literal">/i</tt></td>
<td>Ignore alphabetic case distinctions (case insensitive).<a name="INDEX-1342"></a><a name="INDEX-1343"></a></td>
</tr>

<tr>
<td><tt class="literal">/s</tt></td>
<td>Let <tt class="literal">.</tt> match newline and ignore deprecated <tt class="literal">$*</tt> variable.<a name="INDEX-1344"></a></td>
</tr>

<tr>
<td><tt class="literal">/m</tt></td>
<td>Let <tt class="literal">^</tt> and <tt class="literal">$</tt> match next to embedded <tt class="literal">\n</tt>.<a name="INDEX-1345"></a></td>
</tr>

<tr>
<td><tt class="literal">/x</tt></td>
<td>Ignore (most) whitespace and permit comments in pattern.<a name="INDEX-1346"></a></td>
</tr>

<tr>
<td><tt class="literal">/o</tt></td>
<td>Compile pattern once only.<a name="INDEX-1347"></a></td>
</tr>


</table>
<p>
<a name="INDEX-1348"></a>
The <tt class="literal">/i</tt> modifier says to match both upper- and lowercase (and title
case, under Unicode).  That way <tt class="literal">/perl/i</tt> would also match the strings
"<tt class="literal">PROPERLY</tt>" or "<tt class="literal">Perlaceous</tt>" (amongst other things).  A <tt class="literal">use locale</tt>
pragma may also have some influence on what is considered to be equivalent.
(This may be a negative influence on strings containing Unicode.)</p>

<p>
<a name="INDEX-1349"></a><a name="INDEX-1350"></a>
The <tt class="literal">/s</tt> and <tt class="literal">/m</tt> modifiers don't
involve anything kinky.  Rather, they affect how Perl treats matches
against a string that contains newlines.  But they aren't about
whether your string actually contains newlines; they're about whether
Perl should <em class="emphasis">assume</em> that your string contains a
single line (<tt class="literal">/s</tt>) or multiple lines
(<tt class="literal">/m</tt>), because certain metacharacters work
differently depending on whether they're expected to behave in a
line-oriented fashion or not.</p>

<p>
<a name="INDEX-1351"></a>
Ordinarily, the metacharacter "<tt class="literal">.</tt>" matches any one
character <em class="emphasis">except</em> a newline, because its
traditional meaning is to match characters within a line.  With
<tt class="literal">/s</tt>, however, the "<tt class="literal">.</tt>"
metacharacter can also match a newline, because you've told Perl to
ignore the fact that the string might contain multiple newlines.  (The
<tt class="literal">/s</tt> modifier also makes Perl ignore the deprecated
<tt class="literal">$*</tt> variable, which we hope you too have been
ignoring.)  The <tt class="literal">/m</tt> modifier, on the other hand,
changes the interpretation of the <tt class="literal">^</tt> and
<tt class="literal">$</tt> metacharacters by letting them match next to
newlines within the string instead of considering only the ends of the
string.  See the examples in the section <a href="ch05_06.htm">Section 5.6, "Positions"</a> later in this
chapter.</p>

<p>
<a name="INDEX-1352"></a><a name="INDEX-1353"></a><a name="INDEX-1354"></a>
The <tt class="literal">/o</tt> modifier controls pattern recompilation.
Unless the delimiters chosen are single quotes
(<tt class="literal">m'</tt><em class="replaceable">PATTERN</em><tt class="literal">'</tt>,
<tt class="literal">s'</tt><em class="replaceable">PATTERN</em><tt class="literal">'</tt><em class="replaceable">REPLACEMENT</em><tt class="literal">'</tt>,
or
<tt class="literal">qr'</tt><em class="replaceable">PATTERN</em><tt class="literal">'</tt>),
any variables in the pattern will be interpolated (and may cause the
pattern to be recompiled) every time the pattern operator is
evaluated.  If you want such a pattern to be compiled once and only
once, use the <tt class="literal">/o</tt> modifier.  This prevents expensive
run-time recompilations; it's useful when the value you are
interpolating won't change during execution.  However, mentioning
<tt class="literal">/o</tt> constitutes a promise that you won't change the
variables in the pattern.  If you do change them, Perl won't even
notice.  For better control over recompilation, use the
<tt class="literal">qr//</tt> regex quoting operator.  See "Variable
Interpolation" later in this chapter for details.</p>

<p>
<a name="INDEX-1355"></a><a name="INDEX-1356"></a>
The <tt class="literal">/x</tt> is the <em class="emphasis">ex</em>pressive
modifier: it allows you to <em class="emphasis">ex</em>ploit whitespace and
<em class="emphasis">ex</em>planatory comments in order to
<em class="emphasis">ex</em>pand your pattern's legibility, even
<em class="emphasis">ex</em>tending the pattern across newline
boundaries.</p>

<p>
<a name="INDEX-1357"></a><a name="INDEX-1358"></a>
Er, that is to say, <tt class="literal">/x</tt> modifies the meaning of the
whitespace characters (and the <tt class="literal">#</tt> character):
instead of letting them do self-matching as ordinary characters do, it
turns them into metacharacters that, oddly, now behave as whitespace
(and comment characters) should.  Hence, <tt class="literal">/x</tt> allows
spaces, tabs, and newlines for formatting, just like regular Perl
code.  It also allows the <tt class="literal">#</tt> character, not normally
special in a pattern, to introduce a comment that extends through the
end of the current line within the pattern string.<a href="#FOOTNOTE-6">[6]</a> If you want to match a real whitespace
character (or the <tt class="literal">#</tt> character), then you'll have to
put it into a character class, or escape it with a backslash, or
encode it using an octal or hex escape.  (But whitespace is normally
matched with a <tt class="literal">\s*</tt> or <tt class="literal">\s+</tt>
sequence, so the situation doesn't arise often in

practice.)
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-6"></a>
<p>[6] Be
careful not to include the pattern delimiter in the comment--because
of its "find the end first" rule, Perl has no way of knowing you
didn't intend to terminate the pattern at that
point.</p>

</blockquote>

<p>Taken together, these features go a long way toward making traditional
regular expressions a readable language.  In the spirit of TMTOWTDI,
there's now more than one way to write a given regular expression.  In
fact, there's more than two ways:
<blockquote>
<pre class="programlisting">m/\w+:(\s+\w+)\s*\d+/;       # A word, colon, space, word, space, digits.

m/\w+: (\s+ \w+) \s* \d+/x;  # A word, colon, space, word, space, digits.

m{
    \w+:                     # Match a word and a colon.

    (                        # (begin group)
         \s+                 # Match one or more spaces.
         \w+                 # Match another word.
    )                        # (end group)
    \s*                      # Match zero or more spaces.
    \d+                      # Match some digits
}x;</pre>
</blockquote>
<a name="INDEX-1359"></a>
We'll explain those new metasymbols later in the chapter.  (This
section was supposed to be about pattern modifiers, but we've let it
get out of hand in our <em class="emphasis">ex</em>citement about <tt class="literal">/x</tt>.  Ah well.)  Here's a
regular expression that finds duplicate words in paragraphs, stolen
right out of the <em class="citetitle">Perl Cookbook</em>.  It uses the <tt class="literal">/x</tt> and <tt class="literal">/i</tt>
modifiers, as well as the <tt class="literal">/g</tt> modifier described later.
<blockquote>
<pre class="programlisting"># Find duplicate words in paragraphs, possibly spanning line boundaries.
#   Use /x for space and comments, /i to match both `is'
#   in "Is is this ok?", and use /g to find all dups.
$/ = "";        # "paragrep" mode
while (&lt;&gt;) {
    while ( m{
                \b            # start at a word boundary
                (\w\S+)       # find a wordish chunk
                (
                    \s+       # separated by some whitespace
                    \1        # and that chunk again
                ) +           # repeat ad lib
                \b            # until another word boundary
             }xig
         )
    {
        print "dup word '$1' at paragraph $.\n";
    }
}</pre>
</blockquote>

When run on this chapter, it produces warnings like this:
<blockquote>
<pre class="programlisting">dup word 'that' at paragraph 100</pre>
</blockquote>

As it happens, we know that that particular instance was intentional.</p>

<a name="INDEX-1360"></a><a name="INDEX-1361"></a><a name="INDEX-1362"></a>






<h3 class="sect2">5.2.2. The m// Operator (Matching)</h3>

<p>
<a name="INDEX-1363"></a>
<blockquote>
<pre class="programlisting">
<em class="replaceable">EXPR</em> =~ m/<em class="replaceable">PATTERN</em>/cgimosx
<em class="replaceable">EXPR</em> =~ /<em class="replaceable">PATTERN</em>/cgimosx
<em class="replaceable">EXPR</em> =~ ?<em class="replaceable">PATTERN</em>?cgimosx
m/<em class="replaceable">PATTERN</em>/cgimosx
/<em class="replaceable">PATTERN</em>/cgimosx
?<em class="replaceable">PATTERN</em>?cgimosx</pre>
</blockquote>
<a name="INDEX-1364"></a>
The <tt class="literal">m//</tt> operator searches the string in the scalar <em class="replaceable">EXPR</em> for
<em class="replaceable">PATTERN</em>.  If <tt class="literal">/</tt> or <tt class="literal">?</tt> is the delimiter, the initial <tt class="literal">m</tt> is
optional.  Both <tt class="literal">?</tt> and <tt class="literal">'</tt> have special meanings as delimiters: the
first is a once-only match; the second suppresses variable
interpolation and the six translation escapes (<tt class="literal">\U</tt> and company,
described later).</p>

<p>
<a name="INDEX-1365"></a>
If <em class="replaceable">PATTERN</em> evaluates to a null string,
either because you specified it that way using <tt class="literal">//</tt>
or because an interpolated variable evaluated to the empty string, the
last successfully executed regular expression not hidden within an
inner block (or within a <tt class="literal">split</tt>,
<tt class="literal">grep</tt>, or <tt class="literal">map</tt>) is used instead.</p>

<p>
<a name="INDEX-1366"></a>
In scalar context, the operator returns true (<tt class="literal">1</tt>) if successful,
false (<tt class="literal">""</tt>) otherwise.  This form is usually seen in Boolean context:
<blockquote>
<pre class="programlisting">if ($shire =~ m/Baggins/) { ... }  # search for Baggins in $shire
if ($shire =~ /Baggins/)  { ... }  # search for Baggins in $shire

if ( m#Baggins# )         { ... }  # search right here in $_
if ( /Baggins/ )          { ... }  # search right here in $_</pre>
</blockquote>
<a name="INDEX-1367"></a><a name="INDEX-1368"></a>
Used in list context, <tt class="literal">m//</tt> returns a list of
substrings matched by the capturing parentheses in the pattern (that
is, <tt class="literal">$1</tt>, <tt class="literal">$2</tt>,
<tt class="literal">$3</tt>, and so on) as described later under "Capturing
and Clustering".  The numbered variables are still set even when the
list is returned.  If the match fails in list context, a null list is
returned.  If the match succeeds in list context but there were no
capturing parentheses (nor <tt class="literal">/g</tt>), a list value of
<tt class="literal">(1)</tt> is returned.  Since it returns a null list on
failure, this form of <tt class="literal">m//</tt> can also be used in
Boolean context, but only when participating indirectly via a list
assignment:
<blockquote>
<pre class="programlisting">if (($key,$value) = /(\w+): (.*)/) { ... }</pre>
</blockquote>

Valid modifiers for <tt class="literal">m//</tt> (in whatever guise) are
shown in <a href="ch05_02.htm">Table 5-1</a>.
<a name="INDEX-1369"></a><a name="INDEX-1370"></a>
</p>

<a name="perl3-tab-mmods"></a>
<h4 class="objtitle">Table 5.1. m// Modifiers</h4>
<table border="1">

<tr>
<th>Modifier</th>
<th>Meaning</th>
</tr>




<tr>
<td><tt class="literal">/i</tt><a name="INDEX-1371"></a></td>
<td>Ignore alphabetic case.</td>
</tr>

<tr>
<td><tt class="literal">/m</tt><a name="INDEX-1372"></a></td>
<td>Let <tt class="literal">^</tt> and <tt class="literal">$</tt> match next to embedded <tt class="literal">\n</tt>.<a name="INDEX-1373"></a><a name="INDEX-1374"></a></td>
</tr>

<tr>
<td><tt class="literal">/s</tt></td>
<td>Let <tt class="literal">.</tt> match newline and ignore deprecated <tt class="literal">$*</tt>.<a name="INDEX-1375"></a></td>
</tr>

<tr>
<td><tt class="literal">/x</tt></td>
<td>Ignore (most) whitespace and permit comments in pattern.<a name="INDEX-1376"></a></td>
</tr>

<tr>
<td><tt class="literal">/o</tt></td>
<td>Compile pattern once only.<a name="INDEX-1377"></a></td>
</tr>

<tr>
<td><tt class="literal">/g</tt><a name="INDEX-1378"></a></td>
<td>Globally find all matches.</td>
</tr>

<tr>
<td><tt class="literal">/cg</tt><a name="INDEX-1379"></a></td>
<td>Allow continued search after failed <tt class="literal">/g</tt> match.</td>
</tr>


</table>

<p>
<a name="INDEX-1380"></a><a name="INDEX-1381"></a>
The first five modifiers apply to the regex and were described
earlier.  The last two change the behavior of the match operation
itself.  The <tt class="literal">/g</tt> modifier specifies global matching--that is,
matching as many times as possible within the string.  How it behaves
depends on context.  In list context, <tt class="literal">m//g</tt> returns a list of all
matches found.  Here we find all the places someone mentioned
"<tt class="literal">perl</tt>", "<tt class="literal">Perl</tt>", "<tt class="literal">PERL</tt>", and so on:
<blockquote>
<pre class="programlisting">if (@perls = $paragraph =~ /perl/gi) {
    printf "Perl mentioned %d times.\n", scalar @perls;
}</pre>
</blockquote>

If there are no capturing parentheses within the <tt class="literal">/g</tt>
pattern, then the complete matches are returned.  If there are
capturing parentheses, then only the strings captured are returned.
Imagine a string like:
<blockquote>
<pre class="programlisting">$string = "password=xyzzy verbose=9 score=0";</pre>
</blockquote>

Also imagine you want to use that to initialize a hash like this:
<blockquote>
<pre class="programlisting">%hash = (password =&gt; "xyzzy", verbose =&gt; 9, score =&gt; 0);</pre>
</blockquote>
<a name="INDEX-1382"></a>
Except, of course, you don't have a list, you have a string.  To get
the corresponding list, you can use the <tt class="literal">m//g</tt>
operator in list context to capture all of the key/value pairs from
the string:
<blockquote>
<pre class="programlisting">%hash = $string =~ /(\w+)=(\w+)/g;</pre>
</blockquote>

The <tt class="literal">(\w+)</tt> sequence captures an alphanumeric word.  See the section
<a href="ch05_07.htm">Section 5.7, "Capturing and Clustering"</a>.
<a name="INDEX-1383"></a><a name="INDEX-1384"></a>
</p>

<p>
<a name="INDEX-1385"></a><a name="INDEX-1386"></a><a name="INDEX-1387"></a><a name="INDEX-1388"></a>
Used in scalar context, the <tt class="literal">/g</tt> modifier indicates a
<em class="emphasis">progressive match</em>, which makes Perl start the
next match on the same variable at a position just past where the last
one stopped.  The <tt class="literal">\G</tt> assertion represents that
position in the string; see <a href="ch05_06.htm">Section 5.6, "Positions"</a> later in this chapter for a
description of <tt class="literal">\G</tt>.  If you use the
<tt class="literal">/c</tt> (for "continue") modifier in addition to
<tt class="literal">/g</tt>, then when the <tt class="literal">/g</tt> runs out,
the failed match doesn't reset the position pointer.</p>

<p>If a <tt class="literal">?</tt> is the delimiter, as in
<tt class="literal">?</tt><em class="replaceable">PATTERN</em><tt class="literal">?</tt>,
this works just like a normal
<tt class="literal">/</tt><em class="replaceable">PATTERN</em><tt class="literal">/</tt>
search, except that it matches only once between calls to the
<tt class="literal">reset</tt> operator.  This can be a convenient
optimization when you want to match only the first occurrence of the
pattern during the run of the program, not all occurrences.  The
operator runs the search every time you call it, up until it finally
matches something, after which it turns itself off, returning false
until you explicitly turn it back on with <tt class="literal">reset</tt>.
Perl keeps track of the match state for you.</p>

<p>
<a name="INDEX-1389"></a>
The <tt class="literal">??</tt> operator is most useful when an ordinary
pattern match would find the last rather than the first occurrence:
<blockquote>
<pre class="programlisting">open DICT, "/usr/dict/words" or die "Can't open words: $!\n";
while (&lt;DICT&gt;) {
    $first = $1 if ?(^neur.*)?;
    $last  = $1 if /(^neur.*)/;
}
print $first,"\n";          # prints "neurad"
print $last,"\n";           # prints "neurypnology"</pre>
</blockquote>
The <tt class="literal">reset</tt> operator will reset only those instances
of <tt class="literal">??</tt> compiled in the same package as the call to
<tt class="literal">reset</tt>.  Saying <tt class="literal">m??</tt> is equivalent
to saying <tt class="literal">??</tt>.
<a name="INDEX-1390"></a>
</p>

<a name="INDEX-1391"></a>






<h3 class="sect2">5.2.3. The s/// Operator (Substitution)</h3>

<p>
<blockquote>
<pre class="programlisting">
<em class="replaceable">LVALUE</em> =~ s/<em class="replaceable">PATTERN</em>/<em class="replaceable">REPLACEMENT</em>/egimosx
s/<em class="replaceable">PATTERN</em>/<em class="replaceable">REPLACEMENT</em>/egimosx</pre>
</blockquote>
<a name="INDEX-1392"></a><a name="INDEX-1393"></a><a name="INDEX-1394"></a><a name="INDEX-1395"></a><a name="INDEX-1396"></a>
This operator searches a string for <em class="replaceable">PATTERN</em> and, if found, replaces
the matched substring with the <em class="replaceable">REPLACEMENT</em> text.  (Modifiers are described later in this section.)
<blockquote>
<pre class="programlisting">$lotr = $hobbit;           # Just copy The Hobbit
$lotr =~ s/Bilbo/Frodo/g;  #   and write a sequel the easy way.</pre>
</blockquote>

The return value of an <tt class="literal">s///</tt> operation (in scalar and list
contexts alike) is the number of times it succeeded (which can be more
than once if used with the <tt class="literal">/g</tt> modifier, as described earlier).  On failure, since it
substituted zero times, it returns false (<tt class="literal">""</tt>), which is numerically
equivalent to <tt class="literal">0</tt>.
<blockquote>
<pre class="programlisting">if ($lotr =~ s/Bilbo/Frodo/) { print "Successfully wrote sequel." }
$change_count = $lotr =~ s/Bilbo/Frodo/g;</pre>
</blockquote>
<a name="INDEX-1397"></a><a name="INDEX-1398"></a><a name="INDEX-1399"></a><a name="INDEX-1400"></a><a name="INDEX-1401"></a><a name="INDEX-1402"></a><a name="INDEX-1403"></a>
The replacement portion is treated as a double-quoted string.  You may
use any of the dynamically scoped pattern variables described earlier
(<tt class="literal">$`</tt>, <tt class="literal">$&amp;</tt>, <tt class="literal">$'</tt>, <tt class="literal">$1</tt>, <tt class="literal">$2</tt>, and so on) in the replacement
string, as well as any other double-quote gizmos you care to employ.
For instance, here's an example that finds all the strings
"<tt class="literal">revision</tt>", "<tt class="literal">version</tt>", or "<tt class="literal">release</tt>", and replaces each with
its capitalized equivalent, using the <tt class="literal">\u</tt> escape in the replacement
portion:
<blockquote>
<pre class="programlisting">s/revision|version|release/\u$&amp;/g;  # Use | to mean "or" in a pattern</pre>
</blockquote>
<a name="INDEX-1404"></a><a name="INDEX-1405"></a>
All scalar variables expand in double-quote context, not just these
strange ones.  Suppose you had a <tt class="literal">%Names</tt> hash that mapped revision
numbers to internal project names; for example, <tt class="literal">$Names{"3.0"}</tt> might
be code-named "<tt class="literal">Isengard</tt>".  You could use <tt class="literal">s///</tt> to find version
numbers and replace them with their corresponding project names:
<blockquote>
<pre class="programlisting">s/version ([0-9.]+)/the $Names{$1} release/g;</pre>
</blockquote>
<a name="INDEX-1406"></a>
In the replacement string, <tt class="literal">$1</tt> returns what the
first (and only) pair of parentheses captured.  (You could use also
<tt class="literal">\1</tt> as you would in the pattern, but that usage is
deprecated in the replacement.  In an ordinary double-quoted string,
<tt class="literal">\1</tt> means a Control-A.)</p>

<p>If <em class="replaceable">PATTERN</em> is a null string, the last
successfully executed regular expression is used instead.  Both
<em class="replaceable">PATTERN</em> and
<em class="replaceable">REPLACEMENT</em> are subject to variable
interpolation, but a <em class="replaceable">PATTERN</em> is
interpolated each time the <tt class="literal">s///</tt> operator is
evaluated as a whole, while the <em class="replaceable">REPLACEMENT</em>
is interpolated every time the pattern matches.  (The
<em class="replaceable">PATTERN</em> can match multiple times in one
evaluation if you use the <tt class="literal">/g</tt> modifier.)
<a name="INDEX-1407"></a>
</p>

<p>
<a name="INDEX-1408"></a><a name="INDEX-1409"></a>
As before, the first five modifiers in
<a href="ch05_02.htm">Table 5-2</a> alter the behavior of the regex;
they're the same as in <tt class="literal">m//</tt> and <tt class="literal">qr//</tt>.
The last two alter the substitution operator itself.</p>

<a name="perl3-tab-smods"></a>
<h4 class="objtitle">Table 5.2. s/// Modifiers</h4>
<table border="1">

<tr>
<th>Modifier</th>
<th>Meaning</th>
</tr>




<tr>
<td><tt class="literal">/i</tt><a name="INDEX-1410"></a></td>
<td>Ignore alphabetic case (when matching).</td>
</tr>

<tr>
<td><tt class="literal">/m</tt><a name="INDEX-1411"></a></td>
<td>Let <tt class="literal">^</tt> and <tt class="literal">$</tt> match next to embedded <tt class="literal">\n</tt>.</td>
</tr>

<tr>
<td><tt class="literal">/s</tt><a name="INDEX-1412"></a></td>
<td>Let <tt class="literal">.</tt> match newline and ignore deprecated <tt class="literal">$*</tt>.</td>
</tr>

<tr>
<td><tt class="literal">/x</tt></td>
<td>Ignore (most) whitespace and permit comments in pattern.<a name="INDEX-1413"></a></td>
</tr>

<tr>
<td>
<p>
<tt class="literal">/o</tt><a name="INDEX-1414"></a>
</p>
</td>
<td>Compile pattern once only.</td>
</tr>

<tr>
<td>
<p>
<tt class="literal">/g</tt><a name="INDEX-1415"></a>
</p>
</td>
<td>Replace globally, that is, all occurrences.</td>
</tr>

<tr>
<td><tt class="literal">/e</tt></td>
<td>Evaluate the right side as an expression.<a name="INDEX-1416"></a></td>
</tr>


</table>

<p>
<a name="INDEX-1417"></a><a name="INDEX-1418"></a>
The <tt class="literal">/g</tt> modifier is used with
<tt class="literal">s///</tt> to replace every match of
<em class="replaceable">PATTERN</em> with the
<em class="replaceable">REPLACEMENT</em> value, not just the first one
found.  A <tt class="literal">s///g</tt> operator acts as a global search
and replace, making all the changes at once, much like list
<tt class="literal">m//g</tt>, except that <tt class="literal">m//g</tt> doesn't
change anything.  (And <tt class="literal">s///g</tt> is not a progressive
match as scalar <tt class="literal">m//g</tt> was.)</p>

<p>
<a name="INDEX-1419"></a><a name="INDEX-1420"></a><a name="INDEX-1421"></a>
The <tt class="literal">/e</tt> modifier treats the
<em class="replaceable">REPLACEMENT</em> as a chunk of Perl code rather
than as an interpolated string.  The result of executing that code is
used as the replacement string.  For example,
<tt class="literal">s/([0-9]+)/sprintf("%#x", $1)/ge</tt> would
convert all numbers into hexadecimal, changing, for example,
<tt class="literal">2581</tt> into <tt class="literal">0xb23</tt>.  Or suppose
that, in our earlier example, you weren't sure that you had names for
all the versions, so you wanted to leave any others unchanged.  With a
little creative <tt class="literal">/x</tt> formatting, you could say:
<blockquote>
<pre class="programlisting">s{
    version
    \s+
    (
        [0-9.]+
    )
}{
    $Names{$1}
        ? "the $Names{$1} release"
        : $&amp;
}xge;</pre>
</blockquote>

The righthand side of your <tt class="literal">s///e</tt> (or in this case, the
lower side) is syntax-checked and compiled at compile time along with
the rest of your program.  Any syntax error is detected during
compilation, and run-time exceptions are left uncaught.  Each
additional <tt class="literal">/e</tt> after the first one (like
<tt class="literal">/ee</tt>, <tt class="literal">/eee</tt>, and so on) is
equivalent to calling <tt class="literal">eval</tt><em class="replaceable">STRING</em> on the result of the code, once per
extra <tt class="literal">/e</tt>.  This evaluates the result of the code
expression and traps exceptions in the special <tt class="literal">$@</tt>
variable.  See the section <a href="ch05_10.htm">Section 5.10.3, "Programmatic Patterns"</a> later in the
chapter for more details.</p>


<h3 class="sect3">5.2.3.1. Modifying strings en passant</h3>

<p>
<a name="INDEX-1422"></a>
Sometimes you want a new, modified string without clobbering the
old one upon which the new one was based.  Instead of writing:
<blockquote>
<pre class="programlisting">$lotr = $hobbit;
$lotr =~ s/Bilbo/Frodo/g;</pre>
</blockquote>

you can combine these into one statement.  Due to precedence,
parentheses are required around the assignment, as they are with
most combinations applying <tt class="literal">=~</tt> to an expression.
<blockquote>
<pre class="programlisting">($lotr = $hobbit) =~ s/Bilbo/Frodo/g;</pre>
</blockquote>

Without the parentheses around the assignment, you'd only change
<tt class="literal">$hobbit</tt> and get the number of replacements stored into <tt class="literal">$lotr</tt>,
which would make a rather dull sequel.</p>

<p>
<a name="INDEX-1423"></a><a name="INDEX-1424"></a><a name="INDEX-1425"></a><a name="INDEX-1426"></a><a name="INDEX-1427"></a>
You can't use a <tt class="literal">s///</tt> operator directly on an array.
For that, you need a loop.  By a lucky coincidence, the aliasing
behavior of <tt class="literal">for</tt>/<tt class="literal">foreach</tt>,
combined with its use of <tt class="literal">$_</tt> as the default loop
variable, yields the standard Perl idiom to search and replace each
element in an array:
<blockquote>
<pre class="programlisting">for (@chapters) { s/Bilbo/Frodo/g }  # Do substitutions chapter by chapter.
s/Bilbo/Frodo/g for @chapters;       # Same thing.</pre>
</blockquote>

As with a simple scalar variable, you can combine the substitution
with an assignment if you'd like to keep the original values around,
too:
<blockquote>
<pre class="programlisting">@oldhues = ('bluebird', 'bluegrass',  'bluefish', 'the blues');
for (@newhues = @oldhues) { s/blue/red/ }
print "@newhues\n";           # prints: redbird redgrass redfish the reds</pre>
</blockquote>
<a name="INDEX-1428"></a><a name="INDEX-1429"></a>
The idiomatic way to perform repeated substitutes on the same
variable is to use a once-through loop.   For example, here's how
to canonicalize whitespace in a variable:
<blockquote>
<pre class="programlisting">for ($string) {
    s/^\s+//;       # discard leading whitespace
    s/\s+$//;       # discard trailing whitespace
    s/\s+/ /g;      # collapse internal whitespace
}</pre>
</blockquote>

which just happens to produce the same result as:
<blockquote>
<pre class="programlisting">$string = join(" ", split " ", $string);</pre>
</blockquote>
You can also use such a loop with an assignment, as we did in the
array case:
<blockquote>
<pre class="programlisting">for ($newshow = $oldshow) {
    s/Fred/Homer/g;
    s/Wilma/Marge/g;
    s/Pebbles/Lisa/g;
    s/Dino/Bart/g;
}</pre>
</blockquote>
</p>




<h3 class="sect3">5.2.3.2. When a global substitution just isn't global enough</h3>

<p>
<a name="INDEX-1430"></a>
Occasionally, you can't just use a <tt class="literal">/g</tt> to get all
the changes to occur, either because the substitutions have to happen
right-to-left or because you need the length of <tt class="literal">$`</tt>
to change between matches.  You can usually do what you want by
calling <tt class="literal">s///</tt> repeatedly.  However, you want the
loop to stop when the <tt class="literal">s///</tt> finally fails, so you
have to put it into the conditional, which leaves nothing to do in the
main part of the loop.  So we just write a <tt class="literal">1</tt>, which
is a rather boring thing to do, but bored is the best you can hope for
sometimes.  Here are some examples that use a few more of those odd
regex beasties that keep popping up:
<blockquote>
<pre class="programlisting"># put commas in the right places in an integer
1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/;

# expand tabs to 8-column spacing
1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;

# remove (nested (even deeply nested (like this))) remarks
1 while s/\([^()]*\)//g;

# remove duplicate words (and triplicate (and quadruplicate...))
1 while s/\b(\w+) \1\b/$1/gi;</pre>
</blockquote>
That last one needs a loop because otherwise it would turn this:
<blockquote>
<pre class="programlisting">Paris in THE THE THE THE spring.</pre>
</blockquote>
into this:
<blockquote>
<pre class="programlisting">Paris in THE THE spring.</pre>
</blockquote>
which might cause someone who knows a little French to picture Paris
sitting in an artesian well emitting iced tea, since "th&amp;#233;" is
French for "tea".  A Parisian is never fooled, of course.</p>

<a name="INDEX-1431"></a>







<h3 class="sect2">5.2.4. The tr/// Operator (Transliteration)</h3>

<p>
<a name="INDEX-1432"></a>
<blockquote>
<pre class="programlisting">
<em class="replaceable">LVALUE</em> =~ tr/<em class="replaceable">SEARCHLIST</em>/<em class="replaceable">REPLACEMENTLIST</em>/cds
tr/<em class="replaceable">SEARCHLIST</em>/<em class="replaceable">REPLACEMENTLIST</em>/cds</pre>
</blockquote>
<a name="INDEX-1433"></a><a name="INDEX-1434"></a>
For <em class="emphasis">sed</em> devotees, <tt class="literal">y///</tt> is
provided as a synonym for <tt class="literal">tr///</tt>. This is why you
can't call a function named <tt class="literal">y</tt>, any more than you
can call a function named <tt class="literal">q</tt> or
<tt class="literal">m</tt>.  In all other respects, <tt class="literal">y///</tt>
is identical to <tt class="literal">tr///</tt>, and we won't mention it
again.</p>

<p>
<a name="INDEX-1435"></a><a name="INDEX-1436"></a>
This operator might not appear to fit into a chapter on pattern
matching, since it doesn't use patterns.  This operator scans a
string, character by character, and replaces each occurrence of a
character found in <em class="replaceable">SEARCHLIST</em> (which is not
a regular expression) with the corresponding character from
<em class="replaceable">REPLACEMENTLIST</em> (which is not a replacement
string).  It looks a bit like <tt class="literal">m//</tt> and
<tt class="literal">s///</tt>, though, and you can even use the
<tt class="literal">=~</tt> or <tt class="literal">!~</tt> binding operators on
it, so we describe it here.  (<tt class="literal">qr//</tt> and
<tt class="literal">split</tt> are pattern-matching operators, but you don't
use the binding operators on them, so they're elsewhere in the book.
Go figure.)</p>

<p>Transliteration returns the number of characters replaced or deleted.
If no string is specified via the <tt class="literal">=~</tt> or <tt class="literal">!~</tt> operator, the <tt class="literal">$_</tt>
string is altered.  The <em class="replaceable">SEARCHLIST</em> and <em class="replaceable">REPLACEMENTLIST</em> may
define ranges of sequential characters with a dash:</p>

<p>
<a name="INDEX-1437"></a>
<blockquote>
<pre class="programlisting">$message =~ tr/A-Za-z/N-ZA-Mn-za-m/;    # rot13 encryption.</pre>
</blockquote>
<a name="INDEX-1438"></a><a name="INDEX-1439"></a>
Note that a range like <tt class="literal">A-Z</tt> assumes a linear
character set like ASCII.  But each character set has its own ideas of
how characters are ordered and thus of which characters fall in a
particular range.  A sound principle is to use only ranges that begin
from and end at either alphabets of equal case
(<tt class="literal">a-e</tt>, <tt class="literal">A-E</tt>), or digits
(<tt class="literal">0-4</tt>).  Anything else is suspect.  When in doubt,
spell out the character sets in full: <tt class="literal">ABCDE</tt>.</p>

<p>The <em class="replaceable">SEARCHLIST</em> and <em class="replaceable">REPLACEMENTLIST</em> are not variable interpolated as
double-quoted strings; you may, however, use those backslash sequences
that map to a specific character, such as <tt class="literal">\n</tt> or
<tt class="literal">\015</tt>.</p>

<p>
<a name="INDEX-1440"></a><a href="ch05_02.htm">Table 5-3</a> lists the modifiers applicable to
the <tt class="literal">tr///</tt> operator.  They're completely different
from those you apply to <tt class="literal">m//</tt>,
<tt class="literal">s///</tt>, or <tt class="literal">qr//</tt>, even if some look
the same.</p>

<a name="perl3-tab-trmods"></a>
<h4 class="objtitle">Table 5.3. tr/// Modifiers</h4>
<table border="1">

<tr>
<th>Modifier</th>
<th>Meaning</th>
</tr>




<tr>
<td><tt class="literal">/c</tt></td>
<td>Complement <em class="replaceable">SEARCHLIST</em>.<a name="INDEX-1441"></a></td>
</tr>

<tr>
<td><tt class="literal">/d</tt></td>
<td>Delete found but unreplaced characters.<a name="INDEX-1442"></a><a name="INDEX-1443"></a></td>
</tr>

<tr>
<td><tt class="literal">/s</tt></td>
<td>Squash duplicate replaced characters.<a name="INDEX-1444"></a><a name="INDEX-1445"></a></td>
</tr>


</table>

<p>If the <tt class="literal">/c</tt> modifier is specified, the character set in <em class="replaceable">SEARCHLIST</em>
is complemented; that is, the effective search list consists of all the
characters <em class="emphasis">not</em> in <em class="replaceable">SEARCHLIST</em>.  In the case of Unicode, this can represent a <em class="emphasis">lot</em> of characters, but since they're stored logically,
not physically, you don't need to worry about running out of memory.</p>

<p>The <tt class="literal">/d</tt> modifier turns <tt class="literal">tr///</tt> into
what might be called the "transobliteration" operator: any characters
specified by <em class="replaceable">SEARCHLIST</em> but not given a
replacement in <em class="replaceable">REPLACEMENTLIST</em> are
deleted. (This is slightly more flexible than the behavior of some
<em class="emphasis">tr</em>(1) programs, which delete anything they
find in <em class="replaceable">SEARCHLIST</em>, period.)</p>

<p>If the <tt class="literal">/s</tt> modifier is specified, sequences of characters converted
to the same character are squashed down to a single instance of the
character.</p>

<p>
<a name="INDEX-1446"></a>
If the <tt class="literal">/d</tt> modifier is used, <em class="replaceable">REPLACEMENTLIST</em> is always interpreted
exactly as specified.  Otherwise, if <em class="replaceable">REPLACEMENTLIST</em> is shorter than
<em class="replaceable">SEARCHLIST</em>, the final character is replicated until it is long
enough.  If <em class="replaceable">REPLACEMENTLIST</em> is null, the <em class="replaceable">SEARCHLIST</em> is
replicated, which is surprisingly useful if you just want to count
characters, not change them.  It's also useful for squashing
characters using <tt class="literal">/s</tt>.
<blockquote>
<pre class="programlisting">tr/aeiou/!/;                 # change any vowel into !
tr{/\\\r\n\b\f. }{_};        # change strange chars into an underscore

tr/A-Z/a-z/ for @ARGV;       # canonicalize to lowercase ASCII

$count = ($para =~ tr/\n//); # count the newlines in $para
$count = tr/0-9//;           # count the digits in $_

$word =~ tr/a-zA-Z//s;       # bookkeeper -&gt; bokeper

tr/@$%*//d;                  # delete any of those
tr#A-Za-z0-9+/##cd;          # remove non-base64 chars

# change en passant
($HOST = $host) =~ tr/a-z/A-Z/;

$pathname =~ tr/a-zA-Z/_/cs; # change non-(ASCII)alphas to single underbar

tr [\200-\377]
   [\000-\177];              # strip 8th bit, bytewise</pre>
</blockquote>

If the same character occurs more than once in <em class="replaceable">SEARCHLIST</em>,
only the first is used.  Therefore, this:
<blockquote>
<pre class="programlisting">tr/AAA/XYZ/</pre>
</blockquote>

will change any single character A to an X (in <tt class="literal">$_</tt>).</p>

<p>
<a name="INDEX-1447"></a><a name="INDEX-1448"></a>
Although variables aren't interpolated into <tt class="literal">tr///</tt>, you can still
get the same effect by using <tt class="literal">eval</tt><em class="replaceable">EXPR</em>:
<blockquote>
<pre class="programlisting">$count = eval "tr/$oldlist/$newlist/";
die if $@;  # propagates exception from illegal eval contents</pre>
</blockquote>
<a name="INDEX-1449"></a><a name="INDEX-1450"></a>
</p>

<p>
<a name="INDEX-1451"></a><a name="INDEX-1452"></a>
One more note: if you want to change your text to uppercase or
lowercase, don't use <tt class="literal">tr///</tt>.  Use the
<tt class="literal">\U</tt> or <tt class="literal">\L</tt> sequences in a
double-quoted string (or the equivalent <tt class="literal">uc</tt> and
<tt class="literal">lc</tt> functions) since they will pay attention to
locale or Unicode information and <tt class="literal">tr/a-z/A-Z/</tt>
won't.  Additionally, in Unicode strings, the <tt class="literal">\u</tt>
sequence and its corresponding <tt class="literal">ucfirst</tt> function
understand the notion of titlecase, which for some languages may be
distinct from simply converting to uppercase.</p>

<a name="INDEX-1453"></a>





<a name="INDEX-1454"></a><a name="INDEX-1455"></a>


<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch05_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">5.1. The Regular Expression Bestiary</td><td align="center" valign="top" width="171"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">5.3. Metacharacters and Metasymbols</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <area shape="rect" coords="2,-1,79,99" href="../index.htm"><area shape="rect" coords="84,1,157,108" href="../perlnut/index.htm"><area shape="rect" coords="162,2,248,125" href="index.htm"><area shape="rect" coords="253,2,326,130" href="../advprog/index.htm"><area shape="rect" coords="332,1,407,112" href="../cookbook/index.htm"><area shape="rect" coords="414,2,523,103" href="../sysadmin/index.htm">
</map>

<!-- END OF BODY -->

</body>
</html>
