<html><head>
<title>[Chapter 4] 4.6 Regular Expressions</TITLE>
<meta name="DC.title" content="Perl in a Nutshell"><meta name="DC.creator" content="Ellen Siever, Stephen Spainhour &amp; Nathan Patwardhan"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:32:10Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-286-7" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch04_01.htm" title="4. The Perl Language"><link rel="prev" href="ch04_05.htm#PNUT-CH-4-SECT-5.10" title="4.5 Operators"><link rel="next" href="ch04_07.htm#PNUT-CH-4-SECT-7.1" title="4.7 Subroutines"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Perl in a Nutshell" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,71" href="index.htm" alt="Perl in a Nutshell"><area shape="RECT" coords="467,0,514,18" href="../search/nsrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch04_05.htm#PNUT-CH-4-SECT-5.10" title="4.5 Operators"><img src="../gifs/txtpreva.gif" alt="Previous: 4.5 Operators" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch04_01.htm" title="4. The Perl Language">Chapter 4<br>The Perl Language</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch04_07.htm#PNUT-CH-4-SECT-7.1" title="4.7 Subroutines"><img src="../gifs/txtnexta.gif" alt="Next: 4.7 Subroutines" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PNUT-CH-4-SECT-6">4.6 Regular Expressions</A
></H2
><p class="para"><a class="indexterm" name="PNUT-CH-4-IX-REGULAR-EXPRESSIONS"></A
>Regular expressions are used several ways in Perl. They're used in conditionals
to determine whether a string matches a particular pattern. They're also
used to find patterns in strings and replace the match with something else.</P
><p class="para"><a class="indexterm" name="AUTOID-4882"></A
><a class="indexterm" name="AUTOID-4885"></A
>The ordinary pattern match operator looks like <code class="literal">/</CODE
><code class="replaceable"><i>pattern</I
></CODE
><code class="literal">/</CODE
>.
It matches against the <code class="literal">$_</CODE
> variable by default. If the pattern is found
in the string, the operator returns true (<code class="literal">&quot;1&quot;</CODE
>); if there is no 
match, a false value (<code class="literal">&quot;&quot;</CODE
>) is returned.</P
><p class="para"><a class="indexterm" name="AUTOID-4895"></A
><a class="indexterm" name="AUTOID-4897"></A
>The substitution operator looks like <code class="literal">s/</CODE
><code class="replaceable"><i>pattern</I
></CODE
><code class="literal">/</CODE
><code class="replaceable"><i>replace</I
></CODE
><code class="literal">/</CODE
>.
This operator searches <code class="literal">$_</CODE
> by default. If it finds the specified <code class="replaceable"><i>pattern</I
></CODE
>,
it is replaced with the string in <code class="replaceable"><i>replace</I
></CODE
>. If <code class="replaceable"><i>pattern</I
></CODE
> is not
matched, nothing happens.</P
><p class="para">You may specify a variable other
than <code class="literal">$_</CODE
> with the <code class="literal">=~</CODE
> binding operator (or the negated <code class="literal">!~</CODE
>
binding operator, which returns true if the pattern is not matched). 
For example:


<blockquote class="screen"><pre class="screen">$text =~ /sampo/;</PRE
></BLOCKQUOTE
>
&#13;</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-4-SECT-6.1">4.6.1 Pattern-Matching Operators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-4916"></A
><a class="indexterm" name="AUTOID-4919"></A
>The following list defines Perl's pattern-matching operators. Some of the
operators have alternative &quot;quoting&quot; schemes and have a set of modifiers
that can be placed directly after the operators to affect the match
operation in some way.</P
><dl class="variablelist"><dt class="term"><code class="literal">m/</CODE
><code class="replaceable"><i>pattern</I
></CODE
><code class="literal">/gimosx</CODE
></DT
><dd class="listitem"><p class="para">Searches a string for a pattern match.
Modifiers are:<a class="indexterm" name="AUTOID-4929"></A
><a class="indexterm" name="AUTOID-4931"></A
><a class="indexterm" name="AUTOID-4933"></A
><a class="indexterm" name="AUTOID-4935"></A
><a class="indexterm" name="AUTOID-4937"></A
><a class="indexterm" name="AUTOID-4939"></A
>

</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Modifier</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">g</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Match globally, i.e., find all occurrences.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">i</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Do case-insensitive pattern matching.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">m</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as multiple lines.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">o</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Only compile pattern once.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as single line.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">x</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Use extended regular expressions.</TD
></TR
></TBODY
></TABLE
><p class="para">
If <code class="literal">/</CODE
> is the delimiter, then the initial <code class="literal">m</CODE
> is optional. 
With the <code class="literal">m</CODE
>,
you can use any pair of non-alphanumeric, non-whitespace characters as
delimiters. </P
></DD
><dt class="term"><code class="literal">?</CODE
><code class="replaceable"><i>pattern</I
></CODE
><code class="literal">?</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-4984"></A
><a class="indexterm" name="AUTOID-4987"></A
>This operator is just like the
<code class="literal">m/</CODE
><code class="replaceable"><i>pattern</I
></CODE
><code class="literal">/</CODE
>
search, except it matches only once.</P
></DD
><dt class="term"><code class="literal">qr/</CODE
><code class="replaceable"><i>pattern</I
></CODE
><code class="literal">/imosx</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-5000"></A
>Creates a precompiled regular expression from <code class="replaceable"><i>pattern</I
></CODE
>,
which can be passed
around in variables and interpolated into other regular expressions.
The modifiers are the same as those for <code class="literal">m//</CODE
> above.</P
></DD
><dt class="term"><code class="literal">s/</CODE
><code class="replaceable"><i>pattern</I
></CODE
><code class="literal">/</CODE
><code class="replaceable"><i>replacement</I
></CODE
><code class="literal">/egimosx</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-5013"></A
><a class="indexterm" name="AUTOID-5015"></A
>Searches a string for <code class="replaceable"><i>pattern</I
></CODE
>, and replaces
any match with the <code class="replaceable"><i>replacement</I
></CODE
> text. Returns the number of
substitutions made, which can be more than one with the <code class="literal">/g</CODE
> modifier.
Otherwise, it returns false (0).
If no string is specified via the <code class="literal">=~</CODE
> or <code class="literal">!~</CODE
> operator, the
<code class="literal">$_</CODE
> variable is searched and modified. 
Modifiers are:
</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Modifier</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">e</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Evaluate the right side as an expression.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">g</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Replace globally, i.e., all occurrences.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">i</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Do case-insensitive pattern matching.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">m</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as multiple lines.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">o</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Only compile pattern once.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as single line.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">x</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Use extended regular expressions.</TD
></TR
></TBODY
></TABLE
><p class="para">
Any non-alphanumeric, non-whitespace delimiter may replace the slashes.
If single quotes are used, no interpretation is done on the replacement
string (the <code class="literal">/e</CODE
> modifier overrides this, however).</P
></DD
><dt class="term"><code class="literal">tr/</CODE
><code class="replaceable"><i>pattern1</I
></CODE
><code class="literal">/</CODE
><code class="replaceable"><i>pattern2</I
></CODE
><code class="literal">/cds</CODE
></DT
><dt class="term"><code class="literal">y/</CODE
><code class="replaceable"><i>pattern1</I
></CODE
><code class="literal">/</CODE
><code class="replaceable"><i>pattern2</I
></CODE
><code class="literal">/cds</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-5074"></A
><a class="indexterm" name="AUTOID-5076"></A
>This operator scans
a string, character by character, and replaces
all occurrences of the characters found in <code class="replaceable"><i>pattern1</I
></CODE
> 
with the corresponding character in <code class="replaceable"><i>pattern2</I
></CODE
>. It returns
the number of characters replaced or deleted. If no string is
specified via the <code class="literal">=~</CODE
> or <code class="literal">!~</CODE
> operator, the <code class="literal">$_</CODE
> string is translated. 
Modifiers are:

</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Modifier</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">c</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Complement <code class="replaceable"><i>pattern1</I
></CODE
>.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">d</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Delete found but unreplaced characters.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Squash duplicate replaced characters.</TD
></TR
></TBODY
></TABLE
><p class="para"></P
></DD
></DL
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-4-SECT-6.2">4.6.2 Regular Expression Syntax</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5106"></A
><a class="indexterm" name="AUTOID-5109"></A
><a class="indexterm" name="AUTOID-5111"></A
>The simplest kind of regular expression is a literal string. 
More complicated patterns involve the use of <em class="emphasis">metacharacters</EM
> to
describe all the different choices and variations that you want to
build into a pattern. Metacharacters don't match themselves, but describe
something else. The metacharacters are:
</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Metacharacter</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Escapes the character(s) immediately following it<a class="indexterm" name="AUTOID-5126"></A
><a class="indexterm" name="AUTOID-5129"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">.</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches any single character except a newline (unless <code class="literal">/s</CODE
> is used)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">^</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the beginning of the string (or line, if <code class="literal">/m</CODE
> used)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the end of the string (or line, if <code class="literal">/m</CODE
> used)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">*</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches the preceding element 0 or more times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">+</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches the preceding element 1 or more times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches the preceding element 0 or 1 times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">{...}</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Specifies a range of occurrences for the element preceding it</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">[...]</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches any one of the class of characters contained within the brackets<a class="indexterm" name="AUTOID-5175"></A
><a class="indexterm" name="AUTOID-5179"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">(...)</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Groups regular expressions</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">|</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches either the expression preceding or following it</P
></TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-5193"></A
><a class="indexterm" name="AUTOID-5196"></A
>
The &quot;<code class="literal">.</CODE
>&quot; (single dot) is a wildcard character. When
used in a regular expression, it can match any single character.
The exception is the newline character (<code class="literal">\n</CODE
>), except when
you use the <code class="literal">/s</CODE
> modifier on the pattern match operator. This
modifier treats the string to be matched against as a single &quot;long&quot;
string with embedded newlines.</P
><p class="para"><a class="indexterm" name="AUTOID-5203"></A
><a class="indexterm" name="AUTOID-5206"></A
><a class="indexterm" name="AUTOID-5209"></A
><a class="indexterm" name="AUTOID-5212"></A
><a class="indexterm" name="AUTOID-5214"></A
>The <code class="literal">^</CODE
> and <code class="literal">$</CODE
> metacharacters are used as anchors
in a regular expression. 
The <code class="literal">^</CODE
> matches the beginning of a line. This
character should only appear at the beginning of an expression to match
the line beginning. The exception to this is when the <code class="literal">/m</CODE
>
(multi-line) modifier is used, in which case it will match at the
beginning of the string and after every newline (except the last, if
there is one). Otherwise, <code class="literal">^</CODE
> will match itself, unescaped, anywhere
in a pattern, except if it is the first character in a bracketed character
class, in which case it negates the class.</P
><p class="para">Similarly, <code class="literal">$</CODE
> will match the end of a line (just before a newline
character) only if it is at the end of a pattern, unless <code class="literal">/m</CODE
> is
used, in which case it matches just before every newline and at the
end of a string. You need to escape <code class="literal">$</CODE
> to match a literal dollar
sign in all cases, because if <code class="literal">$</CODE
> isn't at the end of a pattern
(or placed right before a <code class="literal">)</CODE
> or <code class="literal">]</CODE
>), Perl will attempt
to do variable interpretation. The same holds true for the <code class="literal">@</CODE
>
sign, which Perl will interpret as an array variable start unless
it is backslashed.</P
><p class="para"><a class="indexterm" name="AUTOID-5232"></A
><a class="indexterm" name="AUTOID-5235"></A
><a class="indexterm" name="AUTOID-5238"></A
><a class="indexterm" name="AUTOID-5241"></A
><a class="indexterm" name="AUTOID-5244"></A
><a class="indexterm" name="AUTOID-5247"></A
>The <code class="literal">*</CODE
>, <code class="literal">+</CODE
>, and <code class="literal">?</CODE
> metacharacters are called
<em class="emphasis">quantifiers</EM
>. They specify the number of times to match something.
They act on the element immediately preceding them, which could
be a single character (including the <code class="literal">.</CODE
>), a
grouped expression in parentheses, or a character class. The<a class="indexterm" name="AUTOID-5255"></A
><a class="indexterm" name="AUTOID-5258"></A
>
<code class="literal">{...}</CODE
> construct is a generalized modifier. You may
put two numbers separated by a comma within the braces to
specify minimum and maximum numbers that the preceding element
can match.</P
><p class="para"><a class="indexterm" name="AUTOID-5263"></A
><a class="indexterm" name="AUTOID-5266"></A
>Parentheses are used to group characters or expressions. They also
have the side effect of remembering what they matched so you can
recall and reuse patterns with a special group of variables.</P
><p class="para"><a class="indexterm" name="AUTOID-5270"></A
><a class="indexterm" name="AUTOID-5273"></A
>The <code class="literal">|</CODE
> is the alternation operator in regular expressions.
It matches either what's on its left side or right side. It does
not only affect single characters. For example:


<blockquote class="screen"><pre class="screen">/you|me|him|her/</PRE
></BLOCKQUOTE
>


looks for any of the four words. You should use parentheses to
provide boundaries for alternation:


<blockquote class="screen"><pre class="screen">/And(y|rew)/</PRE
></BLOCKQUOTE
>


This will match either &quot;Andy&quot; or &quot;Andrew&quot;.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-4-SECT-6.3">4.6.3 Escaped Sequences</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5282"></A
><a class="indexterm" name="AUTOID-5285"></A
><a class="indexterm" name="AUTOID-5288"></A
><a class="indexterm" name="AUTOID-5290"></A
>The following table lists the backslashed representations of characters
that you can use in regular expressions: <a class="indexterm" name="AUTOID-5293"></A
><a class="indexterm" name="AUTOID-5295"></A
><a class="indexterm" name="AUTOID-5297"></A
><a class="indexterm" name="AUTOID-5299"></A
><a class="indexterm" name="AUTOID-5301"></A
><a class="indexterm" name="AUTOID-5303"></A
><a class="indexterm" name="AUTOID-5305"></A
><a class="indexterm" name="AUTOID-5307"></A
>
</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Code</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Matches</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Alarm (beep)</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\n</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Newline</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\r</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Carriage return</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\t</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Tab</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\f</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Formfeed</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\e</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Escape</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\007</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Any octal ASCII value</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\x7f</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Any hexadecimal ASCII value </TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\c</CODE
><code class="replaceable"><i>x</I
></CODE
></TD
><td class="entry" rowspan="1" colspan="1">Control-<code class="replaceable"><i>x</I
></CODE
></TD
></TR
></TBODY
></TABLE
><p class="para"></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-4-SECT-6.4">4.6.4 Character Classes</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5357"></A
><a class="indexterm" name="AUTOID-5360"></A
><a class="indexterm" name="AUTOID-5363"></A
><a class="indexterm" name="AUTOID-5366"></A
><a class="indexterm" name="AUTOID-5370"></A
><a class="indexterm" name="AUTOID-5374"></A
><a class="indexterm" name="AUTOID-5376"></A
>The <code class="literal">[...]</CODE
> construct is used to list a set of characters
(a <em class="emphasis">character class</EM
>) of which <em class="emphasis">one</EM
> will match. 
Brackets are often used when
capitalization is uncertain in a match:


<blockquote class="screen"><pre class="screen">/[tT]here/</PRE
></BLOCKQUOTE
>

<a class="indexterm" name="AUTOID-5383"></A
><a class="indexterm" name="AUTOID-5386"></A
><a class="indexterm" name="AUTOID-5389"></A
>
A dash (<code class="literal">-</CODE
>) may be used to indicate a range of characters
in a character class:


<blockquote class="screen"><pre class="screen">/[a-zA-Z]/;  # match any single letter
/[0-9]/;     # match any single digit</PRE
></BLOCKQUOTE
>


To put a literal dash in the list you must use a backslash before it 
(<code class="literal">\-</CODE
>).</P
><p class="para"><a class="indexterm" name="AUTOID-5396"></A
><a class="indexterm" name="AUTOID-5399"></A
>By placing a <code class="literal">^</CODE
> as the first element in the brackets, you
create a negated character class, i.e., it matches any character
not in the list. For example:


<blockquote class="screen"><pre class="screen">/[^A-Z]/; matches any character other than an uppercase letter</PRE
></BLOCKQUOTE
>


Some common character classes have their own predefined escape sequences
for your programming convenience:<a class="indexterm" name="AUTOID-5404"></A
><a class="indexterm" name="AUTOID-5407"></A
><a class="indexterm" name="AUTOID-5410"></A
><a class="indexterm" name="AUTOID-5412"></A
><a class="indexterm" name="AUTOID-5414"></A
><a class="indexterm" name="AUTOID-5416"></A
><a class="indexterm" name="AUTOID-5418"></A
><a class="indexterm" name="AUTOID-5421"></A
><a class="indexterm" name="AUTOID-5424"></A
><a class="indexterm" name="AUTOID-5426"></A
>

</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Code</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Matches</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\d</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A digit, same as <code class="literal">[0-9]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\D</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A nondigit, same as <code class="literal">[^0-9]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\w</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A word character (alphanumeric), same as <code class="literal">[a-zA-Z_0-9]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\W</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A nonword character, <code class="literal">[^a-zA-Z_0-9]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A whitespace character, same as <code class="literal">[\t\n\r\f]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\S</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A non-whitespace character, <code class="literal">[^\t\n\r\f]</CODE
></TD
></TR
></TBODY
></TABLE
><p class="para">
These elements match any single element in (or not in) their class.
A <code class="literal">\w</CODE
> matches only one character of a word. Using a modifier,
you can match a whole word, for example, with <code class="literal">\w+</CODE
>.
The abbreviated classes may also be used within brackets as
elements of other character classes.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-4-SECT-6.5">4.6.5 Anchors</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5470"></A
><a class="indexterm" name="AUTOID-5473"></A
><a class="indexterm" name="AUTOID-5476"></A
><a class="indexterm" name="AUTOID-5478"></A
>Anchors 
don't match any characters; they match places within a string. The two
most common anchors are <code class="literal">^</CODE
> and <code class="literal">$</CODE
>, which match
the beginning and end of a line, respectively. 
This table lists the anchoring patterns used to match certain
boundaries in regular expressions:<a class="indexterm" name="AUTOID-5483"></A
><a class="indexterm" name="AUTOID-5486"></A
><a class="indexterm" name="AUTOID-5489"></A
><a class="indexterm" name="AUTOID-5492"></A
><a class="indexterm" name="AUTOID-5495"></A
><a class="indexterm" name="AUTOID-5497"></A
><a class="indexterm" name="AUTOID-5499"></A
><a class="indexterm" name="AUTOID-5501"></A
><a class="indexterm" name="AUTOID-5504"></A
><a class="indexterm" name="AUTOID-5506"></A
><a class="indexterm" name="AUTOID-5509"></A
><a class="indexterm" name="AUTOID-5511"></A
><a class="indexterm" name="AUTOID-5514"></A
>
</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Assertion</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">^</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the beginning of the string (or line, if <code class="literal">/m</CODE
> used)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the end of the string (or line, if <code class="literal">/m</CODE
> used)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\b</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at word boundary (between <code class="literal">\w</CODE
> and <code class="literal">\W</CODE
>)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\B</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches except at word boundary</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\A</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the beginning of the string</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\Z</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the end of the string or before a newline</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\z</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches only at the end of the string</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\G</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches where previous <code class="literal">m//g</CODE
> left off</P
></TD
></TR
></TBODY
></TABLE
><p class="para">
The <code class="literal">$</CODE
> and <code class="literal">\Z</CODE
> assertions can match not only at the end of the
string, but also one character earlier than that, if the last character
of the string happens to be a newline.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-4-SECT-6.6">4.6.6 Quantifiers</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5573"></A
><a class="indexterm" name="AUTOID-5576"></A
><a class="indexterm" name="AUTOID-5579"></A
><a class="indexterm" name="AUTOID-5581"></A
>Quantifiers are used to specify how many instances of the previous
element can match. For instance, you could say &quot;match any
number of a's, including none&quot; (<code class="literal">a*</CODE
>), or match between five and ten 
instances of the word &quot;owie&quot; (<code class="literal">(owie){5,10}</CODE
>).</P
><p class="para"><a class="indexterm" name="AUTOID-5587"></A
>Quantifiers, by nature, are greedy. That is, the way the
Perl regular expression &quot;engine&quot; works is that it will
look for the biggest match possible (the farthest to the right)
unless you tell it not to. Say you are searching a string that
reads:


<blockquote class="screen"><pre class="screen">a whatever foo, b whatever foo</PRE
></BLOCKQUOTE
>


and you want to find <code class="literal">a</CODE
> and <code class="literal">foo</CODE
> with something
in between. You might use:


<blockquote class="screen"><pre class="screen">/a.*foo/</PRE
></BLOCKQUOTE
>


A <code class="literal">.</CODE
> followed by a <code class="literal">*</CODE
> looks for any character,
any number of times, until <code class="literal">foo</CODE
> is found. But since Perl
will look as far to the right as possible to find <code class="literal">foo</CODE
>,
the first instance of <code class="literal">foo</CODE
> is swallowed up by the greedy
<code class="literal">.*</CODE
> expression. </P
><p class="para"><a class="indexterm" name="AUTOID-5600"></A
><a class="indexterm" name="AUTOID-5602"></A
>All the quantifiers therefore have a notation that allows for
minimal matching, so they are non-greedy. This notation uses
a question mark immediately following the quantifier to force
Perl to look for the earliest available match (farthest to the
left). The following table lists the regular expression quantifiers and
their non-greedy forms:<a class="indexterm" name="AUTOID-5604"></A
><a class="indexterm" name="AUTOID-5607"></A
>

</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Maximal</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Minimal</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Allowed Range</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><code class="literal">n</CODE
>,<code class="literal">m</CODE
><code class="literal">}</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><code class="literal">n</CODE
>,<code class="literal">m</CODE
><code class="literal">}?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Must occur at least <code class="literal">n</CODE
> times but no more than <code class="literal">m</CODE
> times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><code class="literal">n</CODE
><code class="literal">,}</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><code class="literal">n</CODE
><code class="literal">,}?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Must occur at least <code class="literal">n</CODE
> times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><code class="literal">n</CODE
><code class="literal">}</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><code class="literal">n</CODE
><code class="literal">}?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Must match exactly <code class="literal">n</CODE
> times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">*</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">*?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">0 or more times (same as <code class="literal">{0,}</CODE
>)<a class="indexterm" name="AUTOID-5665"></A
><a class="indexterm" name="AUTOID-5668"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">+</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">+?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">1 or more times (same as <code class="literal">{1,}</CODE
>)<a class="indexterm" name="AUTOID-5679"></A
><a class="indexterm" name="AUTOID-5682"></A
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">??</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">0 or 1 time (same as <code class="literal">{0,1}</CODE
>)<a class="indexterm" name="AUTOID-5693"></A
><a class="indexterm" name="AUTOID-5696"></A
></P
></TD
></TR
></TBODY
></TABLE
><p class="para"></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-4-SECT-6.7">4.6.7 Pattern Match Variables</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5702"></A
><a class="indexterm" name="AUTOID-5705"></A
>Parentheses not only serve to group elements in a regular expression,
they also remember the patterns they match. 
Every match from a parenthesized
element is saved to a special, read-only variable indicated by a number.
You can recall and reuse a match by using these variables.</P
><p class="para"><a class="indexterm" name="AUTOID-5709"></A
><a class="indexterm" name="AUTOID-5711"></A
><a class="indexterm" name="AUTOID-5714"></A
>Within a pattern, each parenthesized element saves its match to a numbered
variable, in order starting with <code class="literal">1</CODE
>. You can recall these
matches within the expression by using <code class="literal">\1</CODE
>, <code class="literal">\2</CODE
>, and
so on. </P
><p class="para">Outside of the matching pattern, the matched variables are recalled
with the usual dollar-sign, i.e., <code class="literal">$1</CODE
>, <code class="literal">$2</CODE
>, etc. The
dollar sign notation should used in the replacement expression
of a substitution and anywhere else you might want to use them in
your program. For example, to implement &quot;i before e, except after c&quot;:


<blockquote class="screen"><pre class="screen">s/([^c])ei/$1ie/g;</PRE
></BLOCKQUOTE
>


The backreferencing variables are:</P
><dl class="variablelist"><dt class="term"><code class="literal">$+</CODE
></DT
><dd class="listitem"><p class="para">Returns the last parenthesized pattern match</P
></DD
><dt class="term"><code class="literal">$&amp;</CODE
></DT
><dd class="listitem"><p class="para">Returns the entire matched string</P
></DD
><dt class="term"><code class="literal">$`</CODE
></DT
><dd class="listitem"><p class="para">Returns everything before the matched string</P
></DD
><dt class="term"><code class="literal">$'</CODE
></DT
><dd class="listitem"><p class="para">Returns everything after the matched string</P
></DD
></DL
><p class="para">Backreferencing with these variables will slow down your program noticeably for
all regular expressions.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-4-SECT-6.8">4.6.8 Extended Regular Expressions</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5749"></A
><a class="indexterm" name="AUTOID-5751"></A
><a class="indexterm" name="AUTOID-5754"></A
><a class="indexterm" name="AUTOID-5757"></A
>Perl defines an extended syntax for regular expressions.
The syntax is a pair of parentheses with a question mark as the first thing
within the parentheses.
The character after the question mark gives the function of the extension.
The extensions are:</P
><dl class="variablelist"><dt class="term"><code class="replaceable"><i>(?#text)</I
></CODE
></DT
><dd class="listitem"><p class="para">A comment. The text is ignored. </P
></DD
><dt class="term"><code class="literal">(?:...)</CODE
></DT
><dd class="listitem"><p class="para">This groups things like &quot;<code class="literal">(...)</CODE
>&quot; but doesn't make backreferences.</P
></DD
><dt class="term"><code class="literal">(?=...)</CODE
></DT
><dd class="listitem"><p class="para">A zero-width positive lookahead assertion. For example, <code class="literal">/\w+(?=\t)/</CODE
>
matches a word followed by a tab, without including the tab in <code class="literal">$&amp;</CODE
>.</P
></DD
><dt class="term"><code class="literal">(?!...)</CODE
></DT
><dd class="listitem"><p class="para">A zero-width negative lookahead assertion. For example, <code class="literal">/foo(?!bar)/</CODE
>
matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;. </P
></DD
><dt class="term"><code class="literal">(?&lt;=...)</CODE
></DT
><dd class="listitem"><p class="para">A zero-width positive lookbehind assertion. For example,
<code class="literal">/(?&lt;=bad)boy/</CODE
> matches the word <code class="literal">boy</CODE
> that
follows <code class="literal">bad</CODE
>, without including <code class="literal">bad</CODE
> in
<code class="literal">$&amp;</CODE
>. This only works for fixed-width lookbehind.</P
></DD
><dt class="term"><code class="literal">(?&lt;!=...)</CODE
></DT
><dd class="listitem"><p class="para">A zero-width negative lookbehind assertion. For example,
<code class="literal">/(?&lt;!=bad)boy/</CODE
> matches any occurrence of &quot;boy&quot; that
doesn't follow &quot;bad&quot;. This only works for fixed-width lookbehind.</P
></DD
><dt class="term"><code class="literal">(?&gt;...)</CODE
></DT
><dd class="listitem"><p class="para">Matches the substring that the standalone pattern would
match if anchored at the given position. </P
></DD
><dt class="term"><code class="literal">(?(</CODE
><code class="replaceable"><i>condition</I
></CODE
><code class="literal">)</CODE
><code class="replaceable"><i>yes-pattern</I
></CODE
>|<code class="replaceable"><i>no-pattern</I
></CODE
>)</DT
><dt class="term"><code class="literal">(?(<code class="replaceable"><i>condition</I
></CODE
>)<code class="replaceable"><i>yes-pattern</I
></CODE
>)</CODE
></DT
><dd class="listitem"><p class="para">Matches a pattern determined by a condition. The <code class="replaceable"><i>condition</I
></CODE
>
should be either an integer, which is &quot;true&quot; if the
pair of parentheses corresponding to the integer has matched,
or a lookahead, lookbehind, or evaluate, zero-width assertion.
The <code class="replaceable"><i>no-pattern</I
></CODE
> will be used to match if the condition was
not meant, but it is also optional.</P
></DD
><dt class="term"><code class="literal">(?imsx-imsx)</CODE
></DT
><dd class="listitem"><p class="para">One or more embedded pattern-match modifiers. 
Modifiers are switched off if they follow a <code class="literal">-</CODE
> (dash).
The modifiers are defined as follows:<a class="indexterm" name="AUTOID-5827"></A
><a class="indexterm" name="AUTOID-5829"></A
><a class="indexterm" name="AUTOID-5831"></A
><a class="indexterm" name="AUTOID-5833"></A
>
</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Modifier</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">i</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Do case-insensitive pattern matching</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">m</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as multiple lines</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as single line</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">x</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Use extended regular expressions</TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-5858"></A
></P
></DD
></DL
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch04_05.htm#PNUT-CH-4-SECT-5.10" title="4.5 Operators"><img src="../gifs/txtpreva.gif" alt="Previous: 4.5 Operators" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Perl in a Nutshell"><img src="../gifs/txthome.gif" alt="Perl in a Nutshell" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch04_07.htm#PNUT-CH-4-SECT-7.1" title="4.7 Subroutines"><img src="../gifs/txtnexta.gif" alt="Next: 4.7 Subroutines" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">4.5 Operators</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">4.7 Subroutines</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="../prog/index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
