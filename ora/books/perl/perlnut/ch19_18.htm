<html><head>
<title>[Chapter 19] 19.18 OLE Automation</TITLE>
<meta name="DC.title" content="Perl in a Nutshell"><meta name="DC.creator" content="Ellen Siever, Stephen Spainhour &amp; Nathan Patwardhan"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T02:00:24Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-286-7" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch19_01.htm" title="19. Win32 Modules and Extensions"><link rel="prev" href="ch19_17.htm" title="19.17 Win32 Extensions"><link rel="next" href="ch20_01.htm" title="20. PerlScript"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Perl in a Nutshell" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,71" href="index.htm" alt="Perl in a Nutshell"><area shape="RECT" coords="467,0,514,18" href="../search/nsrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch19_17.htm" title="19.17 Win32 Extensions"><img src="../gifs/txtpreva.gif" alt="Previous: 19.17 Win32 Extensions" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch19_01.htm" title="19. Win32 Modules and Extensions">Chapter 19<br>Win32 Modules and Extensions</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="CHAPTER" href="ch20_01.htm" title="20. PerlScript"><img src="../gifs/txtnexta.gif" alt="Next: 20. PerlScript" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PNUT-CH-19-SECT-18">19.18 OLE Automation</A
></H2
><p class="para"><a class="indexterm" name="PNUT-CH-19-IX-OLE-AUTOMATION"></A
><a class="indexterm" name="PNUT-CH-19-IX-WIN32-MODULES-WIN32OLE-MODULES"></A
>The Win32::OLE modules give Perl support for OLE automation. OLE automation
is a Microsoft technology based on COM that allows objects created by another
application to be used and manipulated by a program through a common interface.</P
><p class="para"><a class="indexterm" name="AUTOID-44611"></A
>The application (or DLL) that implements the automation interface is called
the <em class="emphasis">automation server</EM
>. The application that creates and uses the
interface is called the <em class="emphasis">automation controller</EM
> or <em class="emphasis">automation client</EM
>.
Many popular applications expose their objects through automation. Microsoft
Word, Excel, and other Office applications can be used as automation servers.
Automation is widely used by Active Server Pages (ASP) and CGI scripts to access
data repositories, perhaps via ActiveX Data Objects (ADO). You can even use
automation to control many development environments and editors.</P
><p class="para">In order to create an automation object, the server needs to be <em class="emphasis">registered</EM
>
on the system. This is typically done by the server's installation program, but
can be done manually using a utility like <em class="emphasis">regsvr32.exe</EM
>. This involves
adding entries to the system registry to tell COM how to find the component,
what types of interfaces it provides, what type of server it is, etc.
You should be able to find the object model, available methods and properties
of the interface in the documentation provided by the application. This
object model can be used via Perl's object syntax to create and control
objects in your programs.</P
><p class="para">Four modules provide automation functionality to Perl:</P
><dl class="variablelist"><dt class="term">Win32::OLE</DT
><dd class="listitem"><p class="para">Provides the main interface for OLE automation. You can create or open
automation objects, use their methods, and set their properties.</P
></DD
><dt class="term">Win32::OLE::Enum</DT
><dd class="listitem"><p class="para">Creates objects for collections and defines an interface for enumerating them.</P
></DD
><dt class="term">Win32::OLE::Variant</DT
><dd class="listitem"><p class="para">Allows you to convert the Variant data type used in OLE.</P
></DD
><dt class="term">Win32::OLE::Const</DT
><dd class="listitem"><p class="para">Imports constants from an automation object into your script.</P
></DD
></DL
><p class="para">There are a few limitations to Win32::OLE to note. There is currently no
support for OCXs or OLE events (notifications generated by the
automation server). Win32::OLE implements the <code class="literal">IDispatch</CODE
> interface
only, and therefore cannot access a custom OLE interface.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-19-SECT-18.1">19.18.1 Creating Objects</A
></H3
><p class="para">Automation objects are represented in Perl as instances of Win32::OLE
objects. The module provides three constructors for creating objects
from a registered automation server.
<ul class="nutlist"><li class="term"><a class="nutentry" href="c19_163.htm" title="Reference: new">new</A
></LI
><li class="term"><a class="nutentry" href="c19_164.htm" title="Reference: GetActiveObject">GetActiveObject</A
></LI
><li class="term"><a class="nutentry" href="c19_165.htm" title="Reference: GetObject">GetObject</A
></LI
></UL
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-19-SECT-18.2">19.18.2 Automation Methods and Properties</A
></H3
><p class="para">Once you have created an automation object, you can use its methods
or adjust its properties as you require. Automation methods are
implemented as you'd expect with the Perl object syntax:


<blockquote class="screen"><pre class="screen">$obj-&gt;some_method(args);</PRE
></BLOCKQUOTE
>


Automation methods can often take a number of optional parameters.
You can pass <code class="literal">undef</CODE
> for any unwanted parameters in the arguments
list. For example, you can save a WorkBook in Excel with <code class="literal">SaveAs</CODE
>.
Additional settings allow you to add the WorkBook to the MRU list and
create a backup copy:


<blockquote class="screen"><pre class="screen">$xl-&gt;WorkBooks(1)-&gt;SaveAs($f, undef, undef, undef, undef, 1, undef, undef, 1);</PRE
></BLOCKQUOTE
>


For simplification, you can also use just the named parameters you
want to set by passing a reference to a hash containing them. You
can do this right in the argument list by creating an anonymous hash
reference with <code class="literal">{}</CODE
>. The previous example can therefore be
written like this:


<blockquote class="screen"><pre class="screen">$xl-&gt;WorkBooks(1)-&gt;SaveAs($f, {AddtoMru =&gt; 1, CreateBackup =&gt; 1});</PRE
></BLOCKQUOTE
>


Properties of automation objects are accessed via hash reference notation
on the object. For example:


<blockquote class="screen"><pre class="screen">$val = $obj-&gt;{&quot;property&quot;};         # get a property value
$obj-&gt;{&quot;property&quot;} = $val;         # set a property value</PRE
></BLOCKQUOTE
>


Be aware that properties may not be writable (or even readable). Many
automation objects have read-only properties and will generate an exception
if you try to write to them. You'll need to consult the documentation for
the object to find out which properties you can safely set.</P
><p class="para">You can enumerate the properties of an automation object using the normal
methods for enumerating hashes, which are <code class="literal">keys</CODE
> and <code class="literal">each</CODE
>. 
Here's how you can print the properties and values contained within
an object:


<blockquote class="screen"><pre class="screen">$xl = Win32::OLE-&gt;new('Excel.Application', 'Quit');
while( ($key,$value) = each %$xl ) {
    print &quot;$key=$value\n&quot;;
}</PRE
></BLOCKQUOTE
>
&#13;</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PNUT-CH-19-SECT-18.2.1">19.18.2.1 Win32::OLE methods</A
></H4
><p class="para">Win32::OLE defines a couple of its own methods for dealing with the
automation interface. These are not automation-defined 
methods, although they look the same. If a given method is not defined
in Win32::OLE, the method call is dispatched to the automation object.
If the method doesn't exist there, you will get an OLE error.</P
><p class="para">The following methods are defined by Win32::OLE:
<ul class="nutlist"><li class="term"><a class="nutentry" href="c19_166.htm" title="Reference: Invoke">Invoke</A
></LI
><li class="term"><a class="nutentry" href="c19_167.htm" title="Reference: LastError">LastError</A
></LI
><li class="term"><a class="nutentry" href="c19_168.htm" title="Reference: QueryObjectType">QueryObjectType</A
></LI
></UL
></P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PNUT-CH-19-SECT-18.2.2">19.18.2.2 Win32::OLE functions</A
></H4
><p class="para">The following functions are defined by Win32::OLE. They are not exported
by default.
<ul class="nutlist"><li class="term"><a class="nutentry" href="c19_169.htm" title="Reference: in">in</A
></LI
><li class="term"><a class="nutentry" href="c19_170.htm" title="Reference: valof">valof</A
></LI
><li class="term"><a class="nutentry" href="c19_171.htm" title="Reference: with">with</A
></LI
></UL
></P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PNUT-CH-19-SECT-18.2.3">19.18.2.3 Win32::OLE class variables</A
></H4
><p class="para">The Win32::OLE module defines certain class variables that
set default behavior for automation usage.</P
><dl class="variablelist"><dt class="term"><code class="literal">$Win32::OLE::CP</CODE
></DT
><dd class="listitem"><p class="para">Determines the codepage used by all translations 
between Perl strings and Unicode strings used by the OLE interface. 
The default value is <code class="literal">CP_ACP</CODE
>, which is the default ANSI codepage.
It can also be set to <code class="literal">CP_OEMCP</CODE
>, which is the default OEM codepage. 
Both constants are not exported by default. </P
></DD
><dt class="term"><code class="literal">$Win32::OLE::LCID</CODE
></DT
><dd class="listitem"><p class="para">Controls the locale identifier used for all OLE calls. It is set 
to <code class="literal">LOCALE_NEUTRAL</CODE
> by default. Check the Win32 module 
for other locale-related information. </P
></DD
><dt class="term"><code class="literal">$Win32::OLE::Warn</CODE
></DT
><dd class="listitem"><p class="para">Determines the behavior of the Win32::OLE module when an error happens. 
Valid values are: 

<dl class="variablelist"><dt class="term"><code class="literal">0</CODE
></DT
><dd class="listitem"><p class="para">Ignore error, return <code class="literal">undef</CODE
>.</P
></DD
><dt class="term"><code class="literal">1</CODE
></DT
><dd class="listitem"><p class="para">Use <code class="literal">Carp::carp</CODE
> if <code class="literal">$^W</CODE
> is set (<em class="emphasis">-w</EM
> option).</P
></DD
><dt class="term"><code class="literal">2</CODE
></DT
><dd class="listitem"><p class="para">Always use <code class="literal">Carp::carp</CODE
>.</P
></DD
><dt class="term"><code class="literal">3</CODE
></DT
><dd class="listitem"><p class="para">Use <code class="literal">Carp::croak</CODE
>.</P
></DD
></DL
>

The error number and message (without <code class="literal">Carp</CODE
> line/module info) are 
also available through the <code class="literal">Win32::OLE-&gt;LastError</CODE
> method. </P
></DD
></DL
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-19-SECT-18.3">19.18.3 Win32::OLE::Enum</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-44851"></A
><a class="indexterm" name="AUTOID-44854"></A
>The Win32::OLE::Enum module provides special support for collections.
Collections are special automation data types that contain
an array of objects or data. A collection supports enumeration&nbsp;- you
can iterate through each item through a standard interface.</P
><p class="para">Collection objects should always provide a <code class="literal">Count</CODE
> property (the number
of items in the collection) and an <code class="literal">Item</CODE
> method. The <code class="literal">Item</CODE
> method is used
to access a particular collection item using a subscript, which may
be an integer or a string, depending on the server. Collection objects
may also optionally contain an <code class="literal">Add</CODE
> and a <code class="literal">Remove</CODE
> method.</P
><p class="para">Collection objects also support a standard COM interface (IEnumVARIANT) 
that allows you to enumerate each
item in a collection. It defines methods that let you advance the iteration to the next item, 
skip a given item, restart the enumeration, and create a new copy of the iterator.
While all servers are supposed to provide this interface, some servers don't 
implement all of the methods (often <code class="literal">Reset</CODE
> and <code class="literal">Clone</CODE
>).</P
><p class="para"><a class="indexterm" name="AUTOID-44866"></A
><a class="indexterm" name="AUTOID-44869"></A
>Win32::OLE::Enum defines these methods for enumerating collections.
The collection object should provide the <code class="literal">Count</CODE
> and <code class="literal">Item</CODE
>
methods, which are often all you need to use on collections. For example:


<blockquote class="screen"><pre class="screen">$cnt = $coll-&gt;Count();
if( $cnt) {
    $obj = $coll-&gt;Item(0);
    $obj-&gt;do_something();
}</PRE
></BLOCKQUOTE
>


<code class="literal">Count</CODE
> will tell you how many items are in the collection,
and <code class="literal">Item</CODE
> will return the desired item as a Win32::OLE object.</P
><p class="para">For the enumeration methods, you need to create an enumeration object
for the collection object:


<blockquote class="screen"><pre class="screen">$coll = $obj-&gt;some_coll();
$enum = Win32::OLE::Enum-&gt;new($coll);</PRE
></BLOCKQUOTE
>


Now you can use the enumeration methods on the object.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PNUT-CH-19-SECT-18.3.1">19.18.3.1 Win32::OLE::Enum methods</A
></H4
><p class="para">The following methods are defined in Win32::OLE::Enum:
<ul class="nutlist"><li class="term"><a class="nutentry" href="c19_172.htm" title="Reference: new">new</A
></LI
><li class="term"><a class="nutentry" href="c19_173.htm" title="Reference: All">All</A
></LI
><li class="term"><a class="nutentry" href="c19_174.htm" title="Reference: Clone">Clone</A
></LI
><li class="term"><a class="nutentry" href="c19_175.htm" title="Reference: Next">Next</A
></LI
><li class="term"><a class="nutentry" href="c19_176.htm" title="Reference: Reset">Reset</A
></LI
><li class="term"><a class="nutentry" href="c19_177.htm" title="Reference: Skip">Skip</A
></LI
></UL
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-19-SECT-18.4">19.18.4 Win32::OLE::Variant</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-44957"></A
><a class="indexterm" name="AUTOID-44960"></A
>All automation data has to be coerced into a special type called a Variant. Most of 
the time, you don't need to worry about explicit type coercion. You just provide 
your scalar data and the magic of automation takes care of the rest of it. How-
ever, there are cases when you want to control the exact type of data you're send-
ing to the automation server. The Win32::OLE::Variant module 
provides access to the Variant data type and lets you control exactly how the 
data is represented.</P
><p class="para">A Variant is an OLE data structure that contains a type 
field and a data field. The flags are implemented in Perl (as are many constants) as 
subroutines that return an integer value. The table below lists the Variant type flags, 
along with a brief description of each.

</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Type</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_EMPTY</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"> 
No value specified. Incidentally, automation does not use VT_EMPTY 
for empty optional parameters. Rather, it uses VT_ERROR with a 
value of DISP_E_PARAMNOTFOUND (which isn't exported by Perl: the 
value in current Win32 SDK headers is 0x80020004).</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_NULL</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">  
A propagating NULL value was specified (not to be confused with a 
null pointer). This is used for things like the NULL in SQL.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_I2</TD
><td class="entry" rowspan="1" colspan="1">A 2-byte integer value.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_I4</TD
><td class="entry" rowspan="1" colspan="1">A 4-byte integer value.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_R4</TD
><td class="entry" rowspan="1" colspan="1">An IEEE 4-byte real value.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_R8</TD
><td class="entry" rowspan="1" colspan="1">An IEEE 8-byte real value.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_CY</TD
><td class="entry" rowspan="1" colspan="1">An automation currency value. </TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_DATE</TD
><td class="entry" rowspan="1" colspan="1">An automation date value.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_BSTR</TD
><td class="entry" rowspan="1" colspan="1">A string value.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_DISPATCH</TD
><td class="entry" rowspan="1" colspan="1"><p class="para">The value contains another automation object.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_ERROR</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"> 
An error code was specified. The type of the error is determined by 
the actual value. As mentioned earlier, this is used to implement 
empty optional parameters.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_BOOL</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"> 
A Boolean (true/false) value. If all bits are 1, it's true, if all bits are 0, 
it's false. Any other value is invalid.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_VARIANT</TD
><td class="entry" rowspan="1" colspan="1">The value contains another Variant.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_UNKNOWN</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"> 
The value contains an IUnknown pointer (the base class of COM 
objects).</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_UI1</TD
><td class="entry" rowspan="1" colspan="1">An unsigned 1-byte character.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_BYREF</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"> 
Can be combined with some fields to indicate that the data is being 
passed by reference, rather than by value.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">VT_ARRAY</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"> 
The value contains an OLE SAFEARRAY (this flag is not currently 
exported by Perl).</P
></TD
></TR
></TBODY
></TABLE
><p class="para">

To convert data to a specific variant type, you create a variant
object with either the <code class="literal">new</CODE
> constructor method or the convenience
function <code class="literal">Variant</CODE
>:<a class="indexterm" name="AUTOID-45031"></A
>


<blockquote class="screen"><pre class="screen">$vnt = Win32::OLE::Variant-&gt;new(type, data);
$vnt = Variant(type, data);</PRE
></BLOCKQUOTE
>


For example, to force a string to be interpreted as a date, create a
variant object and set it to the <code class="literal">VT_DATE</CODE
> type:


<blockquote class="screen"><pre class="screen">$dt = Variant(VT_DATE, &quot;August 24, 1970&quot;);   # create an explicit data type
$sheet-&gt;Cells(1,1)-&gt;{Value} = $dt;           # set it to a spreadsheet cell</PRE
></BLOCKQUOTE
>
&#13;</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PNUT-CH-19-SECT-18.4.1">19.18.4.1 Win32::OLE::Variant methods</A
></H4
><p class="para">The following methods are defined by Win32::OLE::Variant for
working with Variant data types:
<ul class="nutlist"><li class="term"><a class="nutentry" href="c19_178.htm" title="Reference: As">As</A
></LI
><li class="term"><a class="nutentry" href="c19_179.htm" title="Reference: ChangeType">ChangeType</A
></LI
><li class="term"><a class="nutentry" href="c19_180.htm" title="Reference: Type">Type</A
></LI
><li class="term"><a class="nutentry" href="c19_181.htm" title="Reference: Value">Value</A
></LI
></UL
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PNUT-CH-19-SECT-18.5">19.18.5 Win32::OLE::Const</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-45086"></A
>While browsing through the documentation for an automation object, you may 
have come across references to constant values. For example, if you're trying to 
save an Excel workbook to a different file format, you need to provide a file for-
mat constant. Since the server documentation typically provides symbolic con-
stants (e.g., <code class="literal">xlExcel5</CODE
> or <code class="literal">xlTemplate</CODE
>), we need a way to access those from Perl. 
This is the purpose of Win32::OLE::Const, which imports the constants from an automation 
object into your script.</P
><p class="para">You can either import the constants directly into your namespace as subs that 
return the constant value, or you can have them returned as a hash reference with 
the constant name as the key and its value as the value. Here's an example of the 
former:


<blockquote class="screen"><pre class="screen">use Win32::OLE::Const (&quot;Microsoft Excel&quot;);
print &quot;xlExcel5 = &quot;, xlExcel5, &quot;\n&quot;;</PRE
></BLOCKQUOTE
>


which produces something like:


<blockquote class="screen"><pre class="screen">xlExcel5 = 39</PRE
></BLOCKQUOTE
>

<a class="indexterm" name="AUTOID-45094"></A
>
Here's an example using the <code class="literal">Load</CODE
> method to return a hash reference populated 
with the constants and their values (this produces the same output as the previ-
ous example, of course):


<blockquote class="screen"><pre class="screen">use Win32::OLE::Const;

my $constants = Win32::OLE::Const-&gt;Load(&quot;Microsoft Excel&quot;);
print &quot;xlExcel5 = $constants-&gt;{xlExcel5}\n&quot;;</PRE
></BLOCKQUOTE
>


Notice that, in both cases, we're supplying a regular expression for the name of 
the type library from which we want to import. <code class="literal">Win32::OLE::Const</CODE
> searches the 
registry for matching type libraries and loads the one with the highest version 
number (you can override this by supplying the version you want). You can also 
specify the language you'd like. The parameters (for either <code class="literal">Load</CODE
> or 
<code class="literal">Win32::OLE::Const</CODE
>) are the typelib regular expression, the major version number, the minor version number, and the locale (LCID).</P
><p class="para">You can also provide the <code class="literal">Load</CODE
> method with an automation object, which is then 
queried for its type library. Interestingly, the documentation notes that this seems 
to be slower than searching the Registry (though neither is really speedy with a 
large automation server like Excel). Here's an example of that:


<blockquote class="screen"><pre class="screen">use Win32::OLE;
use Win32::OLE::Const;

# create an Excel application object
my $xl = Win32::OLE-&gt;new('Excel.Application', 'Quit') ||
  die &quot;Can't create Excel: &quot;, Win32::OLE-&gt;LastError;

# import the constants from it 
my $constants = Win32::OLE::Const-&gt;Load($xl);</PRE
></BLOCKQUOTE
>


Using <code class="literal">Load</CODE
> (to get a hash reference for the constants) may be preferable to 
importing all of the constants into your namespace. Some automation servers pro-
vide a large number of constants (the current version of Excel has some 900+), so 
importing them into your namespace can clutter things considerably.</P
><a class="indexterm" name="AUTOID-45106"></A
><a class="indexterm" name="AUTOID-45107"></A
><a class="indexterm" name="AUTOID-45108"></A
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch19_17.htm" title="19.17 Win32 Extensions"><img src="../gifs/txtpreva.gif" alt="Previous: 19.17 Win32 Extensions" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Perl in a Nutshell"><img src="../gifs/txthome.gif" alt="Perl in a Nutshell" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="CHAPTER" href="ch20_01.htm" title="20. PerlScript"><img src="../gifs/txtnexta.gif" alt="Next: 20. PerlScript" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">19.17 Win32 Extensions</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">20. PerlScript</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="../prog/index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
