<html><head>
<title>[Chapter 6] Social Engineering</TITLE>
<meta name="DC.title" content="Programming Perl"><meta name="DC.creator" content="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:59:20Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-149-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="index.htm" title="Programming Perl"><link rel="prev" href="ch05_05.htm#PERL2-CH-5-SECT-5.5" title="5.5 Some Hints About Object Design"><link rel="next" href="ch06_02.htm#PERL2-CH-6-SECT-2.2.4" title="6.2 Cooperating with Other Processes"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Programming Perl" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Programming Perl"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_05.htm#PERL2-CH-5-SECT-5.5" title="5.5 Some Hints About Object Design"><img src="../gifs/txtpreva.gif" alt="Previous: 5.5 Some Hints About Object Design" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 6</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch06_02.htm#PERL2-CH-6-SECT-2.2.4" title="6.2 Cooperating with Other Processes"><img src="../gifs/txtnexta.gif" alt="Next: 6.2 Cooperating with Other Processes" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="CHAPTER"><h1 class="chapter"><a class="title" name="PERL2-CH-6">6. Social Engineering</A
></H1
><div class="htmltoc"><p><b>Contents:</B
><br><a class="SECT1" href="#PERL2-CH-6-SECT-1" title="6.1 Cooperating with Command Interpreters">Cooperating with Command Interpreters</A
><br><a class="SECT1" href="ch06_02.htm#PERL2-CH-6-SECT-2.2.4" title="6.2 Cooperating with Other Processes">Cooperating with Other Processes</A
><br><a class="SECT1" href="ch06_03.htm#PERL2-CH-6-SECT-3.1.3" title="6.3 Cooperating with Strangers">Cooperating with Strangers</A
><br><a class="SECT1" href="ch06_04.htm#PERL2-CH-6-SECT-4.4" title="6.4 Cooperating with Other Languages">Cooperating with Other Languages</A
></P
><p></P
></DIV
><p class="para">Languages have different personalities.  You can classify computer
languages by how introverted or extroverted they are; for instance, Icon
and Lisp are stay-at-home languages, while Tcl and the various shells
are party animals.  Self-sufficient languages prefer to compete with other
languages, while social languages prefer to cooperate with other
languages.  As usual, Perl tries to do both.</P
><p class="para">So this chapter is about relationships.  Until now we've looked inward
at the competitive nature of Perl, but now we need to look outward
and see the cooperative nature of Perl.  If we really mean what we
say about Perl being a glue language, then we can't just talk about
glue; we have to talk about the various kinds of things you can glue
together.  A glob of glue by itself isn't very interesting.</P
><p class="para">Perl doesn't just glue together other computer languages.  It also glues
together command line interpreters, operating systems, processes,
machines, devices, networks, databases, institutions, cultures, Web
pages, GUIs, peers, servers, and clients, not to mention people like
system administrators, users, and of course, hackers, both naughty and
nice.  In fact, Perl is rather competitive about being cooperative.</P
><p class="para">So this chapter is about Perl's relationship with everything in the world.
Obviously, we can't talk about everything in the world, but we'll try.</P
><div class="sect1"><h2 class="sect1"><a class="title" name="PERL2-CH-6-SECT-1">6.1 Cooperating with Command Interpreters</A
></H2
><p class="para"><a class="indexterm" name="CH06.INT1"></A
><a class="indexterm" name="CH06.INT2"></A
><a class="indexterm" name="AUTOID-16615"></A
>It is fortunate that Perl grew up in the UNIX world&nbsp;- that means
its invocation syntax works pretty well under the command interpreters
of other operating systems too.  Most command interpreters know how to
deal with a list of words as arguments, and don't care if an argument
starts with a minus sign.  There are, of course, some sticky spots where
you'll get fouled up if you move from one system to another.  You can't
use single quotes under MS-DOS as you do under UNIX, for instance.  And
on systems like VMS, some wrapper code has to jump through hoops to
emulate UNIX I/O redirection.  Once you get past those issues, however,
Perl treats its switches and arguments much the same on any
operating system.</P
><p class="para">Even when you don't have a command interpreter, <em class="emphasis">per se</EM
>, it's easy to execute a Perl script from another program, such as the <em class="emphasis">inet</EM
>
daemon or a CGI server.  Not only can such a server pass arguments in
the ordinary way, but it can also pass in information via environment
variables and (under UNIX at least) inherited file descriptors.  Even
more exotic argument-passing mechanisms may be encapsulated in a module
that can be brought into the Perl script via a simple <a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> directive.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-6-SECT-1.1">6.1.1 Command Processing</A
></H3
><p class="para"><a class="indexterm" name="CH06.PROC1"></A
><a class="indexterm" name="CH06.PROC2"></A
><a class="indexterm" name="CH06.PROC3"></A
>Perl parses command-line switches in the standard fashion.[<a class="footnote" href="#AUTOID-16632">1</A
>]
That is, it expects any switches (words beginning with a minus) to
come first on the command line.  After that comes the name of the script
(usually), followed by any additional arguments (often filenames) to be
passed into the script.  Some of these additional arguments may be
switches, but if so, they must be processed by the script, since Perl
gives up parsing switches as soon as it sees a non-switch, or the
special &quot;<b class="emphasis.bold">--</B
>&quot; switch that terminates switch processing.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-16632">[1]</A
> Presuming you agree that UNIX is both standard and fashionable.</P
></DIV
></BLOCKQUOTE
><p class="para">Perl gives you some flexibility in how you supply your program.  For
small, quick-and-dirty jobs, you can program Perl entirely from the
command line.  For larger, more permanent jobs, you can supply a Perl
script as a separate file.  Perl looks for the script to be specified in
one of three ways:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Specified line by line via <b class="emphasis.bold">-e</B
> switches on the command line.</P
></LI
><li class="listitem"><p class="para">Contained in the file specified by the first filename on the command line.
(Note that systems supporting the <code class="literal">#!</CODE
> shebang notation invoke
interpreters this way on your behalf.)</P
></LI
><li class="listitem"><p class="para">Passed in implicitly via standard input.  This only works if there are
no filename arguments; to pass arguments to a standard-input script you
must explicitly specify a &quot;<b class="emphasis.bold">-</B
>&quot; for the script name.  For example,
under UNIX:</P
><pre class="programlisting">echo &quot;print 'Hello, world'&quot; | perl -</PRE
><p class="para"><a class="indexterm" name="AUTOID-16648"></A
><a class="indexterm" name="AUTOID-16651"></A
><a class="indexterm" name="AUTOID-16653"></A
>With methods 2 and 3, Perl starts parsing the input file from the
beginning, unless you've specified a <b class="emphasis.bold">-x</B
> switch, in which case it
scans for the first line starting with <code class="literal">#!</CODE
> and containing the word
&quot;<code class="literal">perl</CODE
>&quot;, and starts there instead.  This is useful for running a script
embedded in a larger message.  (In this case you might indicate the end
of the script using the <code class="literal">__END__</CODE
> token.)</P
></LI
></OL
><p class="para">Whether or not you use <b class="emphasis.bold">-x</B
>, the <code class="literal">#!</CODE
> line is always examined for
switches as the line is being parsed.  Thus, if you're on a machine that
only allows one argument with the <code class="literal">#!</CODE
> line, or worse, doesn't even
recognize the <code class="literal">#!</CODE
> line as special, you still can get consistent switch
behavior regardless of how Perl was invoked, even if <b class="emphasis.bold">-x</B
> was used to
find the beginning of the script.</P
><blockquote class="warning"><p class="para"><strong>WARNING:</STRONG
> Because many versions of UNIX silently chop off kernel interpretation of
the <code class="literal">#!</CODE
> line after 32 characters, some switches may be passed in on the
command line, and some may not; you could even get a &quot;<code class="literal">-</CODE
>&quot; without its
letter, if you're not careful.  You probably want to make sure that all
your switches fall either before or after that 32-character boundary.
Most switches don't actually care if they're processed redundantly, but
getting a &quot;<code class="literal">-</CODE
>&quot; instead of a complete switch could cause Perl to try to
execute standard input instead of your script.  And a partial <b class="emphasis.bold">-I</B
> switch
could also cause odd results.  Of course, if you're not on a UNIX system,
you're guaranteed not to have this problem.</P
></BLOCKQUOTE
><p class="para">Parsing of the switches on the <code class="literal">#!</CODE
> line starts wherever &quot;<code class="literal">perl</CODE
>&quot; is
mentioned in the line.  The sequences &quot;<code class="literal">-*</CODE
>&quot; and &quot;<code class="literal">- </CODE
>&quot; are specifically
ignored for the benefit of <em class="emphasis">emacs</EM
> users, so that, if you're
so inclined, you can say:</P
><pre class="programlisting">#!/bin/sh -- # -*- perl -*- -p
eval 'exec perl -S $0 ${1+&quot;$@&quot;}'
    if 0;</PRE
><p class="para"><a class="indexterm" name="AUTOID-16680"></A
>and Perl will see only the <b class="emphasis.bold">-p</B
> switch.  The fancy &quot;<code class="literal">-*- perl
-*-</CODE
>&quot; gizmo tells <em class="emphasis">emacs</EM
> to start up in Perl mode; you don't
need it if you don't use <em class="emphasis">emacs</EM
>.  The <b class="emphasis.bold">-S</B
> mess is explained below.</P
><p class="para">If the <code class="literal">#!</CODE
> line does <em class="emphasis">not</EM
> contain the word &quot;<code class="literal">perl</CODE
>&quot;, the program
named after the <code class="literal">#!</CODE
> is executed instead of the Perl interpreter.
For example, suppose you have an ordinary Bourne shell script out there
that says:</P
><pre class="programlisting">#!/bin/sh
echo &quot;I am a shell script&quot;</PRE
><p class="para"><a class="indexterm" name="AUTOID-16695"></A
><a class="indexterm" name="AUTOID-16697"></A
>If you feed that file to Perl, then Perl will run <em class="emphasis">/bin/sh</EM
> for you.
This is slightly bizarre, but it helps people on machines that don't
recognize <code class="literal">#!</CODE
>, because&nbsp;- by setting their
<code class="literal">SHELL</CODE
> environmental variable&nbsp;- they can tell a program (such as a mailer)
that their shell is <em class="emphasis">/usr/bin/perl</EM
>, and Perl will then dispatch the
program to the correct interpreter for them, even though their kernel is
too stupid to do so.  Classify it as a strange form of cooperation.</P
><p class="para">But back to Perl scripts that are really Perl scripts.
After locating your script, Perl compiles the entire script to an
internal form.  If any compilation errors arise, execution of the
script is not attempted (unlike the typical shell script,
which might run partway through before finding a syntax error).
If the script is syntactically correct, it is executed.  If the script
runs off the end without hitting an <a class="xref" href="ch03_035.htm#PERL2-CMD-EXIT" title="exit"><b class="xref.cmd">exit</B
></A
> or <a class="xref" href="ch03_027.htm#PERL2-CMD-DIE" title="die"><b class="xref.cmd">die</B
></A
> operator, an implicit
<code class="literal">exit(0)</CODE
> is provided to indicate successful completion.</P
><a class="indexterm" name="AUTOID-16708"></A
><a class="indexterm" name="AUTOID-16709"></A
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-6-SECT-1.2">6.1.2 Switches</A
></H3
><p class="para">A single-character switch with no argument may be combined (bundled)
with the following switch, if any.<a class="indexterm" name="AUTOID-16713"></A
><a class="indexterm" name="AUTOID-16716"></A
><a class="indexterm" name="CH06.PROC4"></A
></P
><pre class="programlisting">#!/usr/bin/perl -spi.bak    # same as -s -p -i.bak</PRE
><p class="para">Switches are also known as options, or flags.
Perl recognizes these switches:</P
><dl class="variablelist"><dt class="term"><b class="emphasis.bold">--</B
></DT
><dd class="listitem"><p class="para">Terminates switch processing, even if the next argument starts with a
minus.  It has no other effect.<a class="indexterm" name="AUTOID-16729"></A
><a class="indexterm" name="AUTOID-16732"></A
></P
></DD
><dt class="term"><b class="emphasis.bold">-0</B
>[<em class="emphasis">octnum</EM
>]</DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-16741"></A
><a class="indexterm" name="AUTOID-16744"></A
><a class="indexterm" name="AUTOID-16746"></A
><a class="indexterm" name="AUTOID-16749"></A
><a class="indexterm" name="AUTOID-16752"></A
>Specifies the record separator (<code class="literal">$/</CODE
>) as an octal number.  If <em class="emphasis">octnum</EM
>
is not present, the null character is the separator.  Other switches may
precede or follow the octal number.  For example, if you have a version of
<em class="emphasis">find</EM
>(1) that can print filenames terminated by the null character, you
can say this:</P
><pre class="programlisting">find . -name '*.bak' -print0 | perl -n0e unlink</PRE
><p class="para"><a class="indexterm" name="AUTOID-16760"></A
>The special value <code class="literal">00</CODE
> will cause Perl to slurp files in paragraph mode,
equivalent to setting the <b class="emphasis.bold">$/</B
> variable to <code class="literal">&quot;&quot;</CODE
>.
The value <code class="literal">0777</CODE
> will cause Perl to slurp files whole since there is no
legal ASCII character with that value.  This is equivalent to undefining
the <b class="emphasis.bold">$/</B
> variable.</P
></DD
><dt class="term"><b class="emphasis.bold">-a  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-16772"></A
><a class="indexterm" name="AUTOID-16775"></A
><a class="indexterm" name="AUTOID-16777"></A
>Turns on autosplit mode when used with a <b class="emphasis.bold">-n</B
> 
or <b class="emphasis.bold">-p</B
>.  An implicit
<b class="emphasis.bold">split</B
> command to the <b class="emphasis.bold">@F</B
> array is done as the first thing inside the
implicit <b class="emphasis.bold">while</B
> loop produced by the 
<b class="emphasis.bold">-n</B
> or <b class="emphasis.bold">-p</B
>.  So:</P
><pre class="programlisting">perl -ane 'print pop(@F), &quot;\n&quot;;'</PRE
><p class="para">is equivalent to:</P
><pre class="programlisting">while (&lt;&gt;) {
    @F = split(' ');
    print pop(@F), &quot;\n&quot;;
}</PRE
><p class="para">A different field delimiter may be specified using <b class="emphasis.bold">-F</B
>.</P
></DD
><dt class="term"><b class="emphasis.bold">-c  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-16796"></A
><a class="indexterm" name="AUTOID-16799"></A
><a class="indexterm" name="AUTOID-16801"></A
><a class="indexterm" name="AUTOID-16804"></A
>Causes Perl to check the syntax of the script and then exit without
executing it.  Actually, it will execute any <code class="literal">BEGIN</CODE
> blocks and
<a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> directives, since these are considered to occur before the
execution of your program.  It also executes any <code class="literal">END</CODE
> blocks, in case
they need to clean up something that happened in a corresponding
<code class="literal">BEGIN</CODE
> block.  The switch is more or less equivalent to having an
<code class="literal">exit(0)</CODE
> as the first statement in your program.</P
></DD
><dt class="term"><b class="emphasis.bold">-d  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-16816"></A
><a class="indexterm" name="AUTOID-16819"></A
><a class="indexterm" name="AUTOID-16821"></A
><a class="indexterm" name="AUTOID-16823"></A
>Runs the script under the Perl debugger.  See &quot;The Perl Debugger&quot; in
<a class="xref" href="ch08_01.htm" title="Other Oddments">Chapter 8, <cite class="chapter">Other Oddments</CITE
></A
>.</P
></DD
><dt class="term"><b class="emphasis.bold">-d:</B
><em class="emphasis">foo</EM
></DT
><dd class="listitem"><p class="para">Runs the script under the control of a debugging or tracing module
installed in the Perl library as Devel::<em class="emphasis">foo</EM
>.  For example,
<code class="literal">-d:DProf</CODE
> executes the script using the
Devel::DProf profiler.  See also the debugging section in <a class="xref" href="ch08_01.htm" title="Other Oddments">Chapter 8</A
>.</P
></DD
><dt class="term"><b class="emphasis.bold">-D</B
><em class="emphasis">number</EM
></DT
><dt class="term"><b class="emphasis.bold">-D</B
><em class="emphasis">list</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-16846"></A
><a class="indexterm" name="AUTOID-16849"></A
>Sets debugging flags.  (This only works if debugging is compiled into
your version of Perl via the -DDEBUGGING C compiler switch.)  You may 
specify either a number that is the sum of the bits
you want, or a list of letters.  To watch how it executes your script,
for instance, use <code class="literal">-D14</CODE
> or <code class="literal">-Dslt</CODE
>.  Another nice value is <code class="literal">-D1024</CODE
>
or <code class="literal">-Dx</CODE
>, which lists your compiled syntax tree.  And <code class="literal">-D512</CODE
> or
<code class="literal">-Dr</CODE
> displays compiled regular expressions.  The numeric value is
available internally as the special variable <b class="emphasis.bold">$^D</B
>.  Here are the
assigned bit values:<a class="indexterm" name="AUTOID-16858"></A
></P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Bit</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Letter</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">1</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">p</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Tokenizing and parsing</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">2</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Stack snapshots</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">4</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">l</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Label stack processing</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">8</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">t</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Trace execution</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">16</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">o</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Object method Lookup</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">32</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">c</CODE
></TD
><td class="entry" rowspan="1" colspan="1">String/numeric conversions</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">64</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">P</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Print preprocessor command for -P</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">128</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">m</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Memory allocation</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">256</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">f</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Format processing</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">512</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">r</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Regular expression processing</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">1,024</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">x</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Syntax tree dump</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">2,048</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">u</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Tainting checks</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">4,096</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">L</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Memory leaks (not supported any more)</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">8,192</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">H</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Hash dump -- usurps values()</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">16,384</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">X</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Scratchpad allocation</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">32,768</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">D</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Cleaning up</TD
></TR
></TBODY
></TABLE
></DD
><dt class="term"><b class="emphasis.bold">-e</B
> <em class="emphasis">commandline</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-16956"></A
><a class="indexterm" name="AUTOID-16959"></A
><a class="indexterm" name="AUTOID-16961"></A
><a class="indexterm" name="AUTOID-16964"></A
>May be used to enter one or more lines of script.  If <b class="emphasis.bold">-e</B
> is
used, Perl will not look for a script filename in the argument list.
The <b class="emphasis.bold">-e</B
> argument is treated as if it ends with a newline, so multiple
<b class="emphasis.bold">-e</B
> commands may be given to build up a multi-line script.  (Make
sure to use semicolons where you would in a normal program.) Just
because <b class="emphasis.bold">-e</B
> supplies a newline on each argument doesn't mean you have
to use multiple <b class="emphasis.bold">-e</B
> switches&nbsp;- if your shell supports multi-line
quoting, you may pass a multi-line script as one <b class="emphasis.bold">-e</B
> argument, just as
<em class="emphasis">awk</EM
>(1) scripts are typically passed.</P
></DD
><dt class="term"><b class="emphasis.bold">-F</B
><em class="emphasis">pattern</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-16981"></A
><a class="indexterm" name="AUTOID-16984"></A
>Specifies the pattern to split on if <b class="emphasis.bold">-a</B
> is also in effect.  The
pattern may be surrounded by <code class="literal">//</CODE
>,
<code class="literal">&quot;&quot;</CODE
>
or <code class="literal">''</CODE
>, otherwise it will be
put in single quotes.  (Remember that to pass quotes through a shell,
you have to quote the quotes.)</P
></DD
><dt class="term"><b class="emphasis.bold">-h  </B
></DT
><dd class="listitem"><p class="para">Prints a summary of Perl's command-line options.<a class="indexterm" name="AUTOID-16995"></A
><a class="indexterm" name="AUTOID-16998"></A
></P
></DD
><dt class="term"><b class="emphasis.bold">-i</B
>[<em class="emphasis">extension</EM
>]</DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17006"></A
><a class="indexterm" name="AUTOID-17009"></A
><a class="indexterm" name="AUTOID-17011"></A
><a class="indexterm" name="AUTOID-17015"></A
>Specifies that files processed by the <code class="literal">&lt;&gt;</CODE
> construct are to be edited
in-place.  It does this by renaming the input file, opening the output
file by the original name, and selecting that output file as the default
for <a class="xref" href="ch03_110.htm#PERL2-CMD-PRINT" title="print"><b class="xref.cmd">print</B
></A
> statements.  The extension, if supplied, is added to the name
of the old file to make a backup copy.  If no extension is supplied, no
backup is made.  From the shell, saying:</P
><pre class="programlisting">$ perl -p -i.bak -e &quot;s/foo/bar/; ... &quot;</PRE
><p class="para">is the same as using the script:</P
><pre class="programlisting">#!/usr/bin/perl -pi.bak
s/foo/bar/;</PRE
><p class="para">which is equivalent to:</P
><pre class="programlisting">#!/usr/bin/perl
while (&lt;&gt;) {
    if ($ARGV ne $oldargv) {
        rename($ARGV, $ARGV . '.bak');
        open(ARGVOUT, &quot;&gt;$ARGV&quot;);
        select(ARGVOUT);
        $oldargv = $ARGV;
    }
    s/foo/bar/;
}
continue {
    print;        # this prints to original filename
}
select(STDOUT);</PRE
><p class="para">except that the <b class="emphasis.bold">-i</B
> form doesn't need to compare <code class="literal">$ARGV</CODE
> to <code class="literal">$oldargv</CODE
> to
know when the filename has changed.  It does, however, use <code class="literal">ARGVOUT</CODE
> for
the selected filehandle.  Note that <code class="literal">STDOUT</CODE
> is restored as the
default output filehandle after the loop. You can use <a class="xref" href="ch03_031.htm#PERL2-CMD-EOF" title="eof"><b class="xref.cmd">eof</B
></A
> without parentheses to locate the end of each input file, 
in case you want to append to each file, or reset line numbering (see the
examples of <a class="xref" href="ch03_031.htm#PERL2-CMD-EOF" title="eof"><b class="xref.cmd">eof</B
></A
> in <a class="xref" href="ch03_01.htm" title="Functions">Chapter 3, <cite class="chapter">Functions</CITE
></A
>).</P
></DD
></DL
><dl class="variablelist"><dt class="term"><b class="emphasis.bold">-I</B
><em class="emphasis">directory</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17040"></A
><a class="indexterm" name="AUTOID-17043"></A
><a class="indexterm" name="AUTOID-17045"></A
><a class="indexterm" name="AUTOID-17048"></A
><a class="indexterm" name="AUTOID-17051"></A
>Directories specified by <b class="emphasis.bold">-I</B
> are prepended to <b class="emphasis.bold">@INC</B
>, which
holds the search path for
modules.  <b class="emphasis.bold">-I</B
> also tells the C preprocessor where to search for
include files.  The C preprocessor is invoked with <b class="emphasis.bold">-P</B
>; by default it
searches <em class="emphasis">/usr/include</EM
> and <em class="emphasis">/usr/lib/perl</EM
>.  Unless you're going to be
using the C preprocessor (and almost no one does any more), you're better
off using the <code class="literal">use lib</CODE
> directive within your script.</P
></DD
><dt class="term"><b class="emphasis.bold">-l</B
>[<em class="emphasis">octnum</EM
>]</DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17067"></A
><a class="indexterm" name="AUTOID-17070"></A
><a class="indexterm" name="AUTOID-17072"></A
><a class="indexterm" name="AUTOID-17075"></A
><a class="indexterm" name="AUTOID-17077"></A
>Enables automatic line-end processing.  It has two effects:  first, it
automatically <a class="xref" href="ch03_013.htm#PERL2-CMD-CHOMP" title="chomp"><b class="xref.cmd">chomp</B
></A
>s the line terminator when used with <b class="emphasis.bold">-n</B
> or
<b class="emphasis.bold">-p</B
>, and second, it sets <b class="emphasis.bold">$\</B
> to the value of <em class="emphasis">octnum</EM
> so any
print statements will have a line terminator of ASCII value <em class="emphasis">octnum</EM
>
added back on.  If <em class="emphasis">octnum</EM
> is omitted, sets <b class="emphasis.bold">$\</B
> to the current value
of <b class="emphasis.bold">$/</B
>, typically newline.  So, to trim lines to 80 columns, say this:</P
><pre class="programlisting">perl -lpe 'substr($_, 80) = &quot;&quot;'</PRE
><p class="para">Note that the assignment <code class="literal">$\ = $/</CODE
> is done when the switch is processed,
so the input record separator can be different from the output record
separator if the <b class="emphasis.bold">-l</B
> switch is followed by a <b class="emphasis.bold">-0</B
> switch:</P
><pre class="programlisting">gnufind / -print0 | perl -ln0e 'print &quot;found $_&quot; if -p'</PRE
><p class="para">This sets <b class="emphasis.bold">$\</B
> to newline and later sets <b class="emphasis.bold">$/</B
> to the null character.  (Note that
<code class="literal">0</CODE
> would have been interpreted as part of the <b class="emphasis.bold">-l</B
> switch
had it followed the <b class="emphasis.bold">-l</B
> directly.  That's why we bundled the <b class="emphasis.bold">-n</B
>
switch between them.)</P
></DD
><dt class="term"><b class="emphasis.bold">-m</B
>[<b class="emphasis.bold">-</B
>]<em class="emphasis">module</EM
></DT
><dd class="listitem"><p class="para"></P
></DD
><dt class="term"><b class="emphasis.bold">-M</B
>[<b class="emphasis.bold">-</B
>]<em class="emphasis">module</EM
></DT
><dd class="listitem"><p class="para"></P
></DD
><dt class="term"><b class="emphasis.bold">-M</B
>[<b class="emphasis.bold">-</B
>]<code class="literal">'</CODE
><em class="emphasis">module ...</EM
><code class="literal">'</CODE
></DT
><dd class="listitem"><p class="para"></P
></DD
><dt class="term"><b class="emphasis.bold">-[mM]</B
>[<b class="emphasis.bold">-</B
>]<em class="emphasis">module=arg</EM
>[<em class="emphasis">,arg</EM
>]<em class="emphasis">...</EM
></DT
><dd class="listitem"><p class="para"></P
></DD
><dt class="term"><b class="emphasis.bold">-m</B
><em class="emphasis">module</EM
></DT
><dd class="listitem"><p class="para">Executes <code class="literal">use</CODE
> <em class="emphasis">module</EM
><code class="literal">()</CODE
> before executing your script.<a class="indexterm" name="AUTOID-17143"></A
><a class="indexterm" name="AUTOID-17146"></A
><a class="indexterm" name="AUTOID-17148"></A
><a class="indexterm" name="AUTOID-17150"></A
><a class="indexterm" name="AUTOID-17153"></A
></P
></DD
><dt class="term"><b class="emphasis.bold">-M</B
><em class="emphasis">module</EM
></DT
><dd class="listitem"><p class="para">Executes <code class="literal">use</CODE
> <em class="emphasis">module</EM
> before executing your
script.  The command is formed by mere interpolation, so you can use
quotes to add extra code after the module name, for example,
<code class="literal">-M'module qw(foo bar)'</CODE
>.
If the first character after the <b class="emphasis.bold">-M</B
> or <b class="emphasis.bold">-m</B
> is a minus (<b class="emphasis.bold">-</B
>),
then the <a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> is replaced with <a class="xref" href="ch03_100.htm#PERL2-CMD-NO" title="no"><b class="xref.cmd">no</B
></A
>.</P
><p class="para">A little built-in syntactic sugar means you can also say
<code class="literal">-mmodule=foo,bar</CODE
> or <code class="literal">-Mmodule=foo,bar</CODE
> as a shortcut for
<code class="literal">-M'module qw(foo bar)'</CODE
>.  This avoids the need to use quotes when
importing symbols.  The actual code generated by <code class="literal">-Mmodule=foo,bar</CODE
> is:</P
><pre class="programlisting">use module split(/,/, q{foo, bar})</PRE
><p class="para">Note that the <code class="literal">=</CODE
> form
removes the distinction between <code class="literal">-m</CODE
> and <code class="literal">-M</CODE
>.</P
></DD
><dt class="term"><b class="emphasis.bold">-n  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17184"></A
><a class="indexterm" name="AUTOID-17187"></A
>Causes Perl to assume the following loop around your script, which
makes it iterate over filename arguments rather as <em class="emphasis">sed -n</EM
> or
<em class="emphasis">awk</EM
> do:</P
><pre class="programlisting">LINE:
while (&lt;&gt;) {
    ...                # your script goes here
}</PRE
><p class="para">Note that the lines are not printed by default.  See <b class="emphasis.bold">-p</B
> to have
lines printed.  Here is an efficient way to delete all files older than
a week, assuming you're on UNIX:</P
><pre class="programlisting">find . -mtime +7 -print | perl -nle unlink</PRE
><p class="para">This is faster than using the <em class="emphasis">-exec</EM
> switch of <em class="emphasis">find</EM
>(1) because you don't
have to start a process on every filename found.
By an amazing coincidence, <code class="literal">BEGIN</CODE
> and <code class="literal">END</CODE
> blocks may be used to
capture control before or after the implicit loop, just as in <em class="emphasis">awk</EM
>.</P
></DD
><dt class="term"><b class="emphasis.bold">-p  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17206"></A
><a class="indexterm" name="AUTOID-17209"></A
>Causes Perl to assume the following loop around your script, which
makes it iterate over filename arguments rather as <em class="emphasis">sed</EM
> does:</P
><pre class="programlisting">LINE:
while (&lt;&gt;) {
    ...                # your script goes here
} continue {
    print;
}</PRE
><p class="para">Note that the lines are printed automatically.  To suppress printing
use the <b class="emphasis.bold">-n</B
> switch.  A <b class="emphasis.bold">-p</B
> overrides a <b class="emphasis.bold">-n</B
> switch. By yet another amazing coincidence, <code class="literal">BEGIN</CODE
> and <code class="literal">END</CODE
> blocks may be
used to capture control before or after the implicit loop, just as in
<em class="emphasis">awk</EM
>.</P
></DD
><dt class="term"><b class="emphasis.bold">-P  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17225"></A
><a class="indexterm" name="AUTOID-17228"></A
><a class="indexterm" name="AUTOID-17230"></A
>Causes your script to be run through the C preprocessor before
compilation by Perl.  (Since both comments and <em class="emphasis">cpp</EM
>(1) directives begin
with the <code class="literal">#</CODE
> character, you should avoid starting comments with any words
recognized by the C preprocessor such as &quot;<code class="literal">if</CODE
>&quot;, &quot;<code class="literal">else</CODE
>&quot; or &quot;<code class="literal">define</CODE
>&quot;.)</P
></DD
><dt class="term"><b class="emphasis.bold">-s  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17242"></A
><a class="indexterm" name="AUTOID-17245"></A
>Enables some rudimentary switch parsing for switches on the command line
after the script name but before any filename arguments or &quot;<b class="emphasis.bold">--</B
>&quot;
switch terminator.  Any switch found there is removed from <b class="emphasis.bold">@ARGV</B
>, and
a variable of the same name as the switch is set in the Perl script.
No switch bundling is allowed, since multi-character switches are allowed.
The following script prints &quot;<code class="literal">true</CODE
>&quot; if and only if the script is invoked
with a <code class="literal">-xyz</CODE
> switch.</P
><pre class="programlisting">#!/usr/bin/perl -s
if ($xyz) { print &quot;true\n&quot;; }</PRE
><p class="para">If the switch in question is followed by an equals sign, the variable is
set to whatever follows the equals sign in that argument.
The following script prints &quot;<code class="literal">true</CODE
>&quot; if and only if the script is invoked
with a <code class="literal">-xyz=abc</CODE
> switch.</P
><pre class="programlisting">#!/usr/bin/perl -s
if ($xyz eq 'abc') { print &quot;true\n&quot;; }</PRE
><p class="para"></P
></DD
><dt class="term"><b class="emphasis.bold">-S  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17262"></A
><a class="indexterm" name="AUTOID-17265"></A
><a class="indexterm" name="AUTOID-17267"></A
><a class="indexterm" name="AUTOID-17269"></A
><a class="indexterm" name="AUTOID-17272"></A
>Makes Perl use the <code class="literal">PATH</CODE
> environment variable to search for the
script (unless the name of the script starts with a slash).  Typically
this is used to emulate <code class="literal">#!</CODE
> startup on machines that don't support <code class="literal">#!</CODE
>,
in the following manner:</P
><pre class="programlisting">#!/usr/bin/perl
eval &quot;exec /usr/bin/perl -S $0 $*&quot;
        if $running_under_some_shell;</PRE
><p class="para">The system ignores the first line and feeds the script to <em class="emphasis">/bin/sh</EM
>,
which proceeds to try to execute the Perl script as a shell script.
The shell executes the second line as a normal shell command, and thus
starts up the Perl interpreter.  On some systems <b class="emphasis.bold">$0</B
> doesn't always
contain the full pathname, so <b class="emphasis.bold">-S</B
> tells Perl to search for the
script if necessary. After Perl locates the script, it parses the
lines and ignores them because the variable <code class="literal">$running_under_some_shell</CODE
>
is never true.  A better construct than <code class="literal">$*</CODE
> would be <code class="literal">${1+&quot;$@&quot;}</CODE
>, which
handles embedded spaces and such in the filenames, but doesn't work if
the script is being interpreted by <em class="emphasis">csh</EM
>.  In order to start up <em class="emphasis">sh</EM
> rather
than <em class="emphasis">csh</EM
>, some systems have to replace the <code class="literal">#!</CODE
> line with a line
containing just a colon, which Perl will politely ignore.  Other
systems can't control that, and need a totally devious construct that
will work under any of <em class="emphasis">csh</EM
>, <em class="emphasis">sh</EM
>, or <em class="emphasis">perl</EM
>, such as the following:</P
><pre class="programlisting">eval '(exit $?0)' &amp;&amp; eval 'exec /usr/bin/perl -S $0 ${1+&quot;$@&quot;}'
    &amp; eval 'exec /usr/bin/perl -S $0 $argv:q'
                   if 0;</PRE
><p class="para">Yes, it's ugly, but so are the systems that work[<a class="footnote" href="#AUTOID-17295">2</A
>]
this way.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-17295">[2]</A
> We use the term advisedly.</P
></DIV
></BLOCKQUOTE
></DD
><dt class="term"><b class="emphasis.bold">-T  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17302"></A
><a class="indexterm" name="AUTOID-17305"></A
><a class="indexterm" name="AUTOID-17307"></A
>Forces &quot;taint&quot; checks to be turned on so you can test them.  Ordinarily
these checks are done only when running setuid or setgid.  It's a good
idea to turn them on explicitly for programs run on another's behalf,
such as CGI programs.  See &quot;Cooperating with Strangers&quot; later in
this chapter.</P
></DD
><dt class="term"><b class="emphasis.bold">-u  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17314"></A
><a class="indexterm" name="AUTOID-17317"></A
><a class="indexterm" name="AUTOID-17319"></A
><a class="indexterm" name="AUTOID-17321"></A
><a class="indexterm" name="AUTOID-17324"></A
>Causes Perl to dump core after compiling your script.  You can then
take this core dump and turn it into an executable file by using the
<em class="emphasis">undump</EM
> program (not supplied).  This speeds startup at the expense of
some disk space (which you can minimize by stripping the executable).
If you want to execute a portion of your script before dumping,
use Perl's <a class="xref" href="ch03_029.htm#PERL2-CMD-DUMP" title="dump"><b class="xref.cmd">dump</B
></A
> operator instead.  Note:  availability of <em class="emphasis">undump</EM
> is
platform specific; it may not be available for a specific port of
Perl.</P
></DD
><dt class="term"><b class="emphasis.bold">-U  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17335"></A
><a class="indexterm" name="AUTOID-17338"></A
><a class="indexterm" name="AUTOID-17340"></A
>Allows Perl to do unsafe operations.  Currently the only &quot;unsafe&quot;
operations are the unlinking of directories while running as superuser,
and running setuid programs with fatal taint checks turned into
warnings.</P
></DD
><dt class="term"><b class="emphasis.bold">-v  </B
></DT
><dd class="listitem"><p class="para">Prints the version and patchlevel of your Perl executable.<a class="indexterm" name="AUTOID-17347"></A
><a class="indexterm" name="AUTOID-17350"></A
></P
></DD
><dt class="term"><b class="emphasis.bold">-V  </B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17357"></A
><a class="indexterm" name="AUTOID-17360"></A
>Prints a summary of the major Perl configuration values and the current
value of <b class="emphasis.bold">@INC</B
>.</P
></DD
><dt class="term"><b class="emphasis.bold">-V:</B
><em class="emphasis">name</EM
></DT
><dd class="listitem"><p class="para">Prints to <code class="literal">STDOUT</CODE
> the value of the named configuration variable.</P
></DD
><dt class="term"><b class="emphasis.bold">-w</B
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17375"></A
><a class="indexterm" name="AUTOID-17378"></A
><a class="indexterm" name="AUTOID-17380"></A
>Prints warnings about identifiers that are mentioned only once, and
scalar variables that are used before being set.  Also warns about
redefined subroutines, and references to undefined filehandles or
filehandles opened read-only that you are attempting to write on.  Also
warns you if you use a non-number as though it were a number,
or if you use an array as though it were a scalar, or if your
subroutines recurse more than 100 deep, and innumerable other things.
See every entry labeled (W) in <a class="xref" href="ch09_01.htm" title="Diagnostic Messages">Chapter 9, <cite class="chapter">Diagnostic Messages</CITE
></A
>.</P
></DD
><dt class="term"><b class="emphasis.bold">-x</B
><em class="emphasis">directory</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-17389"></A
><a class="indexterm" name="AUTOID-17392"></A
><a class="indexterm" name="AUTOID-17394"></A
><a class="indexterm" name="AUTOID-17397"></A
>Tells Perl to extract a script that is embedded in a message.  Leading garbage
will be discarded until the first line that starts with <code class="literal">#!</CODE
> and
contains the string &quot;<code class="literal">perl</CODE
>&quot;.  Any meaningful switches on that line after
the word &quot;<code class="literal">perl</CODE
>&quot; will be applied.  If a directory name is specified, Perl
will switch to that directory before running the script.  The <b class="emphasis.bold">-x</B
>
switch only controls the disposal of leading garbage.  The script
must be terminated with <code class="literal">__END__</CODE
> or <code class="literal">__DATA__</CODE
> if there is
trailing garbage to be ignored.  (The script can process any or all of the
trailing garbage via the <code class="literal">DATA</CODE
> filehandle if desired.)</P
></DD
></DL
><a class="indexterm" name="AUTOID-17407"></A
><a class="indexterm" name="AUTOID-17408"></A
><a class="indexterm" name="AUTOID-17409"></A
><a class="indexterm" name="AUTOID-17410"></A
><a class="indexterm" name="AUTOID-17411"></A
></DIV
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_05.htm#PERL2-CH-5-SECT-5.5" title="5.5 Some Hints About Object Design"><img src="../gifs/txtpreva.gif" alt="Previous: 5.5 Some Hints About Object Design" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Programming Perl"><img src="../gifs/txthome.gif" alt="Programming Perl" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch06_02.htm#PERL2-CH-6-SECT-2.2.4" title="6.2 Cooperating with Other Processes"><img src="../gifs/txtnexta.gif" alt="Next: 6.2 Cooperating with Other Processes" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">5.5 Some Hints About Object Design</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">6.2 Cooperating with Other Processes</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
