<html><head>
<title>[Chapter 2] 2.4 Pattern Matching</TITLE>
<meta name="DC.title" content="Programming Perl"><meta name="DC.creator" content="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:38:51Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-149-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch02_01.htm" title="2. The Gory Details"><link rel="prev" href="ch02_03.htm#PERL2-CH-2-SECT-3.1" title="2.3 Terms"><link rel="next" href="ch02_05.htm#PERL2-CH-2-SECT-5.10" title="2.5 Operators"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Programming Perl" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Programming Perl"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch02_03.htm#PERL2-CH-2-SECT-3.1" title="2.3 Terms"><img src="../gifs/txtpreva.gif" alt="Previous: 2.3 Terms" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch02_01.htm" title="2. The Gory Details">Chapter 2<br>The Gory Details</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch02_05.htm#PERL2-CH-2-SECT-5.10" title="2.5 Operators"><img src="../gifs/txtnexta.gif" alt="Next: 2.5 Operators" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PERL2-CH-2-SECT-4">2.4 Pattern Matching</A
></H2
><p class="para"><a class="indexterm" name="CH02.PAT"></A
><a class="indexterm" name="AUTOID-3223"></A
><a class="indexterm" name="AUTOID-3225"></A
><a class="indexterm" name="AUTOID-3227"></A
><a class="indexterm" name="AUTOID-3229"></A
>The two main pattern matching operators are <code class="literal">m//</CODE
>,
the match operator, and <code class="literal">s///</CODE
>, the substitution
operator.  There is also a <a class="xref" href="ch03_155.htm#PERL2-CMD-SPLIT" title="split"><b class="xref.cmd">split</B
></A
>
operator, which takes an ordinary match operator as its first argument
but otherwise behaves like a function, and is therefore documented in
<a class="xref" href="ch03_01.htm" title="Functions">Chapter 3</A
>.</P
><p class="para">Although we write <code class="literal">m//</CODE
> and <code class="literal">s///</CODE
> here, you'll recall that you can
pick your own quote characters.  On the other hand, for the <code class="literal">m//</CODE
>
operator only, the <code class="literal">m</CODE
> may be omitted if the delimiters you pick are in
fact slashes.  (You'll often see patterns written this way, for
historical reasons.)</P
><p class="para">Now that we've gone to all the trouble of enumerating these weird,
quote-like operators, you might
wonder what it is we've gone to all the trouble of quoting.  The answer
is that the string inside the quotes specifies a <em class="emphasis">regular expression</EM
>.
We'll discuss regular expressions in the next section, because there's a lot
to discuss.</P
><p class="para"><a class="indexterm" name="AUTOID-3243"></A
><a class="indexterm" name="AUTOID-3245"></A
><a class="indexterm" name="AUTOID-3247"></A
><a class="indexterm" name="AUTOID-3249"></A
><a class="indexterm" name="AUTOID-3251"></A
><a class="indexterm" name="AUTOID-3255"></A
>The matching operations can have various modifiers, some of which affect
the interpretation of the regular expression inside:</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Modifier</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">i</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Do case-insensitive pattern matching.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">m</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Treat string as multiple lines (<code class="literal">^</CODE
>
and <code class="literal">$</CODE
> match internal <code class="literal">\n</CODE
>).</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Treat string as single line (<code class="literal">^</CODE
> and 
<code class="literal">$</CODE
> ignore <code class="literal">\n</CODE
>, but <code class="literal">.</CODE
>
matches <code class="literal">\n</CODE
>).</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">x</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Extend your pattern's legibility with whitespace and comments.</P
></TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-3294"></A
>These are usually written as &quot;the <b class="emphasis.bold">/x</B
> modifier&quot;, even though the
delimiter in question might not actually be a slash.  In fact, any of
these modifiers may also be embedded within the regular expression
itself using the <code class="literal">(?...)</CODE
> construct.  See the section
&quot;Regular Expression Extensions&quot; later in this chapter.</P
><p class="para">The <b class="emphasis.bold">/x</B
> modifier itself needs a little more explanation.  It tells
the regular expression parser to ignore whitespace that is not
backslashed or within a character class.  You can use this modifier to break up
your regular expression into (slightly) more readable parts.  <a class="indexterm" name="AUTOID-3301"></A
><a class="indexterm" name="AUTOID-3304"></A
>
The <code class="literal">#</CODE
>
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  Taken together, these features go a
long way toward making Perl a readable language.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-4.1">2.4.1 Regular Expressions</A
></H3
><p class="para"><a class="indexterm" name="CH02.RE"></A
>The regular expressions used in the pattern matching and substitution
operators are syntactically similar to those used by the UNIX <em class="emphasis">egrep</EM
> program.  When
you write a regular expression, you're actually writing a grammar for a
little language.  The regular expression interpreter (which we'll call
the Engine) takes your grammar and compares it to the string you're
doing pattern matching on.  If some portion of the string can be parsed
as a sentence of your little language, it says &quot;yes&quot;.  If not, it says
&quot;no&quot;.</P
><p class="para">What happens after the Engine has said &quot;yes&quot; depends on how you invoked
it.  An ordinary pattern match is usually used as a conditional
expression, in which case you don't care <em class="emphasis">where</EM
> it matched, only
<em class="emphasis">whether</EM
> it matched.  (But you can also find out where it matched if
you need to know that.)  A substitution command will take the part that
matched and replace it with some other string of your choice.  And the
<a class="xref" href="ch03_155.htm#PERL2-CMD-SPLIT" title="split"><b class="xref.cmd">split</B
></A
> operator will return (as a
list) all the places your pattern didn't match.</P
><p class="para">Regular expressions are powerful, packing a lot of meaning into a
short space.  They can therefore be quite daunting if you try to
intuit the meaning of a large regular expression as a whole.  But if you
break it up into its parts, and if you know how the Engine interprets
those parts, you can understand any regular expression.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-2-SECT-4.1.1">2.4.1.1 The regular expression bestiary</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-3322"></A
><a class="indexterm" name="AUTOID-3325"></A
>Before we dive into the rules for interpreting regular expressions,
let's take a look at some of the things you'll see in regular expressions.
First of all, you'll see literal strings.  Most characters[<a class="footnote" href="#AUTOID-3327">23</A
>]
in a regular expression simply match themselves.  If you string several
characters in a row, they must match in order, just as you'd expect.  So
if you write the pattern match:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-3327">[23]</A
> In this section we are misusing the term &quot;character&quot; to mean &quot;byte&quot;.
So far, Perl only knows about byte-sized characters, but this will
change someday, at which point &quot;character&quot; will be a more appropriate
word.</P
></DIV
></BLOCKQUOTE
><p class="para"><pre class="programlisting">/Fred/</PRE
></P
><p class="para">you can know that the pattern won't match unless the string contains
the substring &quot;<code class="literal">Fred</CODE
>&quot; somewhere.</P
><p class="para"><a class="indexterm" name="AUTOID-3334"></A
><a class="indexterm" name="AUTOID-3336"></A
><a class="indexterm" name="AUTOID-3339"></A
>Other characters don't match themselves, but are <em class="emphasis">metacharacters</EM
>.
(Before we explain what metacharacters do, we should reassure
you that you can always match such a character literally by putting a
backslash in front of it.  For example, backslash is itself a
metacharacter, so to match a literal backslash, you'd backslash the
backslash: <code class="literal">\\</CODE
>.)  The list of metacharacters is:</P
><p class="para"><pre class="programlisting">\ | ( ) [  {  ^ $ * + ? .</PRE
></P
><p class="para">We said that backslash turns a metacharacter into a literal character,
but it does the opposite to an alphanumeric character: it turns
the literal character into a sort of metacharacter or sequence.  So
whenever you see a two-character sequence:</P
><pre class="programlisting">\b \D \t \3 \s</PRE
><p class="para">you'll know that the sequence matches something strange.  A <code class="literal">\b</CODE
>
matches a word boundary, for instance, while <code class="literal">\t</CODE
> matches an ordinary
tab character.  Notice that a word boundary is zero characters wide,
while a tab character is one character wide.  Still, they're alike in
that they both assert that something is true about a particular spot
in the string.  Most of the things in a regular expression fall into the
class of assertions, including the ordinary characters that simply
assert that they match themselves.  (To be precise, they also assert
that the next thing will match one character later in the string, which
is why we talk about the tab character being &quot;one character wide&quot;.  Some
assertions eat up some of the string as they match, and others don't.
But we usually reserve the term &quot;assertion&quot; for the zero-width
assertions.  We'll call these assertions with nonzero width <em class="emphasis">atoms</EM
>.)<a class="indexterm" name="AUTOID-3352"></A
><a class="indexterm" name="AUTOID-3354"></A
><a class="indexterm" name="AUTOID-3357"></A
><a class="indexterm" name="AUTOID-3359"></A
>
You'll also see some things that aren't assertions.  Alternation is indicated
with a vertical bar:</P
><pre class="programlisting">/Fred|Wilma|Barney|Betty/</PRE
><p class="para"><a class="indexterm" name="AUTOID-3364"></A
><a class="indexterm" name="AUTOID-3366"></A
>That means that any of those strings can trigger a match.
Grouping of various sorts is done with parentheses, including grouping
of alternating substrings within a longer regular expression:</P
><pre class="programlisting">/(Fred|Wilma|Pebbles) Flintstone/</PRE
><p class="para"><a class="indexterm" name="AUTOID-3370"></A
>Another thing you'll see are what we call quantifiers.  They say how many
of the previous thing should match in a row.  Quantifiers look like:</P
><pre class="programlisting">* + ? *? {2,5}</PRE
><p class="para">Quantifiers only make sense when attached to atoms, that is, assertions
that have width.  Quantifiers attach only to the previous atom, which in
human terms means they only quantify one character.  So if you want to
match three copies of &quot;<code class="literal">moo</CODE
>&quot; in a row, you need to group the
&quot;<code class="literal">moo</CODE
>&quot; with
parentheses, like this:</P
><pre class="programlisting">/(moo){3}/</PRE
><p class="para">That will match &quot;<code class="literal">moomoomoo</CODE
>&quot;.  If you'd said <code class="literal">/moo{3}/</CODE
>, it
would only have matched &quot;<code class="literal">moooo</CODE
>&quot;.</P
><p class="para"><a class="indexterm" name="AUTOID-3382"></A
><a class="indexterm" name="AUTOID-3384"></A
><a class="indexterm" name="AUTOID-3386"></A
>Since patterns are processed as double-quoted strings, the normal
double-quoted interpolations will work.  (See &quot;String Literals&quot; earlier in
this chapter.)  These are applied before the string is interpreted as
a regular expression.  One caveat though: any <code class="literal">$</CODE
> immediately followed
by a vertical bar, closing parenthesis, or the end of the string will
be interpreted as an end-of-line assertion rather than a variable
interpolation.  So if you say:</P
><p class="para"><pre class="programlisting">$foo = &quot;moo&quot;;
/$foo$/;</PRE
></P
><p class="para">it's equivalent to saying:</P
><p class="para"><pre class="programlisting">/moo$/;</PRE
></P
><p class="para">You should also know that interpolating variables into a pattern slows
down the pattern matcher considerably, because it feels it needs to recompile the
pattern each time through, since the variable might have changed.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-2-SECT-4.1.2">2.4.1.2 The rules of regular expression matching</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-3399"></A
><a class="indexterm" name="AUTOID-3401"></A
><a class="indexterm" name="AUTOID-3403"></A
><a class="indexterm" name="CH02.OREM"></A
><a class="indexterm" name="CH02.REMO"></A
><a class="indexterm" name="CH02.PMO"></A
><a class="indexterm" name="AUTOID-3414"></A
>Now that you've seen some regular expressions, we'll lay out
the rules that the Engine uses to match your pattern against the string.
The Perl Engine uses a nondeterministic finite-state automaton (NFA) to
find a match.  That just means that it keeps track of what it has tried
and what it hasn't, and when something doesn't pan out, it backs up and
tries something else.  This is called
<em class="emphasis">backtracking</EM
>.  The Perl Engine is capable of
trying a million things at one spot, then giving up on all those,
backing up to within one choice of the beginning, and trying the million
things again at a different spot.  If you're cagey, you can write
efficient patterns that don't do a lot of silly backtracking.</P
><p class="para">The order of the rules below specifies which order the Engine tries
things.  So when someone trots out a stock phrase like &quot;left-most,
longest match&quot;, you'll know that overall Perl prefers left-most over
longest.  But the Engine doesn't realize it's preferring anything at
that level.  The global preferences result from a lot of localized
choices.  The Engine thinks locally and acts globally.</P
><p class="para"><b class="emphasis.bold">Rule 1.</B
>  The Engine tries to match as far left in the string
as it can, such that the entire regular expression matches under Rule 2.</P
><p class="para">In order to do this, its first choice is to start just before the first
character (it could have started anywhere), and to try to match the
entire regular expression at that point.  The regular expression matches
if and only if Engine reaches the end of the regular expression before
it runs off the end of the string.  If it matches, it quits
immediately&nbsp;- it doesn't keep looking for a &quot;better&quot; match, even though
the regular expression could match in many different ways.  The match
only has to reach the end of the regular expression; it doesn't have to
reach the end of the string, unless there's an assertion in the regular
expression that says it must.  If it exhausts all possibilities at the
first position, it realizes that its very first choice was wrong, and
proceeds to its second choice.  It goes to the second position in the
string (between the first and second characters), and tries all the
possibilities again.  If it succeeds, it stops.  If it fails, it
continues on down the string.  The pattern match as a whole doesn't fail
until it has tried to match the entire regular expression at every
position in the string, including after the last character in the
string.</P
><p class="para">Note that the positions it's trying to match at are <em class="emphasis">between</EM
> the
characters of the string.  This rule sometimes surprises people when
they write a pattern like <code class="literal">/x*/</CODE
> that can match zero or more <code class="literal">x</CODE
>'s.
If you try the pattern on a string like &quot;<code class="literal">fox</CODE
>&quot;, it will match the null
string before the &quot;<code class="literal">f</CODE
>&quot; in preference to the &quot;<code class="literal">x</CODE
>&quot; that's later in the
string.  If you want it to match one or more <code class="literal">x</CODE
>'s, you need to tell
it that by using <code class="literal">/x+/</CODE
> instead.  See the quantifiers under Rule 5.</P
><p class="para">A corollary to this rule is that any regular expression that can match
the null string is guaranteed to match at the leftmost position in the string.</P
><p class="para"><a class="indexterm" name="AUTOID-3433"></A
><b class="emphasis.bold">Rule 2.</B
>  For this rule, the whole
regular expression is regarded as a set of alternatives (where the
degenerate case is just a set with one alternative). If there are two
or more alternatives, they are syntactically separated by the
<code class="literal">|</CODE
> character (usually called a vertical bar). A set 
of alternatives matches a string if any of the
alternatives match under Rule 3.  It tries the alternatives
left-to-right (according to their position in the regular expression),
and stops on the first match that allows successful completion of the
entire regular expression.  If none of the alternatives matches, it
backtracks to the Rule that invoked this Rule, which is usually Rule 1,
but could be Rule 4 or 6.  That rule will then look for a new position
at which to apply Rule 2.</P
><p class="para">If there's only
one alternative, then it either it matches or doesn't, and the rule
still applies.  (There's no such thing as zero alternatives, because a
null string can always match something of zero width.)</P
><p class="para"><b class="emphasis.bold">Rule 3.</B
>  Any particular alternative matches if every item in the
alternative matches sequentially according to Rules 4 and 5 (such that the
entire regular expression can be satisfied).  An item consists of either
an assertion, which is covered in Rule 4, or a quantified atom, which is
covered by Rule 5.  Items that have choices on how to match are given
&quot;pecking order&quot; from left to right.  If the items cannot be matched in
order, the Engine backtracks to the next alternative under Rule 2.</P
><p class="para">Items that must be matched sequentially aren't separated in the regular
expression by anything
syntactic&nbsp;- they're merely juxtaposed in the order they must match.
When you ask to match <code class="literal">/^foo/</CODE
>, you're actually asking for four items
to be matched one after the other.  The first is a zero-width assertion,
and the other three are ordinary letters that must match themselves, one
after the other.</P
><p class="para">The left-to-right pecking order means that in a pattern like:</P
><pre class="programlisting">/x*y*/</PRE
><p class="para"><code class="literal">x</CODE
> gets to pick one way to match, and then <code class="literal">y</CODE
> tries all its ways.  If that
fails, then <code class="literal">x</CODE
> gets to pick its second choice, and make <code class="literal">y</CODE
> try all of its
ways again.  And so on.  The items to the right vary faster, to borrow
a phrase from multi-dimensional arrays.</P
><p class="para"><a class="indexterm" name="AUTOID-3450"></A
><a class="indexterm" name="AUTOID-3452"></A
><a class="indexterm" name="AUTOID-3455"></A
><a class="indexterm" name="AUTOID-3458"></A
><a class="indexterm" name="AUTOID-3461"></A
><a class="indexterm" name="AUTOID-3463"></A
><a class="indexterm" name="AUTOID-3465"></A
><a class="indexterm" name="AUTOID-3467"></A
><a class="indexterm" name="AUTOID-3469"></A
><a class="indexterm" name="AUTOID-3471"></A
><a class="indexterm" name="AUTOID-3474"></A
><a class="indexterm" name="AUTOID-3477"></A
><a class="indexterm" name="AUTOID-3480"></A
><b class="emphasis.bold">Rule 4.</B
>  An assertion must match according to this table.  If the
assertion does not match at the current position, the Engine backtracks to
Rule 3 and retries higher-pecking-order items with different choices.</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Assertion</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">^</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the beginning of the string (or line, if <b class="emphasis.bold">/m</B
> used)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the end of the string (or line, if <b class="emphasis.bold">/m</B
> used)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\b</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at word boundary (between <code class="literal">\w</CODE
> and <code class="literal">\W</CODE
>)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\B</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches except at word boundary</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\A</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the beginning of the string</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\Z</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches at the end of the string</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\G</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches where previous <code class="literal">m//g</CODE
> left off</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">(?=...)</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches if engine would match <code class="literal">...</CODE
> next</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">(?!...)</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Matches if engine wouldn't match <code class="literal">...</CODE
> next</P
></TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-3545"></A
>The <code class="literal">$</CODE
> and <code class="literal">\Z</CODE
> assertions can match not only at the end of the
string, but also one character earlier than that, if the last character
of the string happens to be a newline.</P
><p class="para">The positive <code class="literal">(?=...)</CODE
> and negative <code class="literal">(?!...)</CODE
> lookahead assertions are
zero-width themselves, but assert that the regular expression
represented above by <code class="literal">...</CODE
> would (or would not) match at this point,
were we to attempt it.  In fact, the Engine does attempt it.  The Engine
goes back to Rule 2 to test the subexpression, and then wipes out any
record of how much string was eaten, returning only the success or
failure of the subexpression as the value of the assertion.  We'll show
you some examples later.&#13;</P
><p class="para"><a class="indexterm" name="AUTOID-3555"></A
><a class="indexterm" name="CH02.ATOMS"></A
><a class="indexterm" name="AUTOID-3560"></A
><b class="emphasis.bold">Rule 5.</B
>  A quantified atom matches only if the atom itself matches
some number of times allowed by the quantifier.  (The atom is matched
according to Rule 6.) Different quantifiers require different numbers of
matches, and most of them allow a range of numbers of matches.  Multiple
matches must all match in a row, that is, they must be adjacent within
the string.  An unquantified atom is assumed to have a quantifier
requiring exactly one match.  Quantifiers constrain and control matching
according to the table below.  If no match can be found at the current
position for any allowed quantity of the atom in question, the Engine
backtracks to Rule 3 and retries higher-pecking-order items with
different choices.</P
><p class="para"><a class="indexterm" name="AUTOID-3565"></A
><a class="indexterm" name="AUTOID-3568"></A
><a class="indexterm" name="AUTOID-3571"></A
><a class="indexterm" name="AUTOID-3574"></A
>Quantifiers are:</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><b class="emphasis.bold">Maximal</B
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><b class="emphasis.bold">Minimal</B
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><b class="emphasis.bold">Allowed Range</B
></TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><em class="emphasis">n</EM
>,<em class="emphasis">m</EM
><code class="literal">}</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><em class="emphasis">n</EM
>,<em class="emphasis">m</EM
><code class="literal">}?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Must occur at least <em class="emphasis">n</EM
> times but no more than <em class="emphasis">m</EM
> times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><em class="emphasis">n</EM
><code class="literal">,}</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><em class="emphasis">n</EM
><code class="literal">,}?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Must occur at least <em class="emphasis">n</EM
> times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><em class="emphasis">n</EM
><code class="literal">}</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">{</CODE
><em class="emphasis">n</EM
><code class="literal">}?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Must match exactly <em class="emphasis">n</EM
> times</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">*</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">*?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">0 or more times (same as <code class="literal">{0,}</CODE
>)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">+</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">+?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">1 or more times (same as <code class="literal">{1,}</CODE
>)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">?</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">??</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">0 or 1 time (same as <code class="literal">{0,1}</CODE
>)</P
></TD
></TR
></TBODY
></TABLE
><p class="para">If a brace occurs in any other context, it is treated as a regular
character.  <em class="emphasis">n</EM
> and <em class="emphasis">m</EM
> are
limited to integral values less than 65,536.</P
><p class="para">If you use the
<code class="literal">{</CODE
><em class="emphasis">n</EM
><code class="literal">}</CODE
> form,
then there is no choice, and the atom must match exactly that number
of times or not at all.  Otherwise, the atom can match over a range of
quantities, and the Engine keeps track of all the choices so that it
can backtrack if necessary.  But then the question arises as to which
of these choices to try first.  One could start with the maximal
number of matches and work down, or the minimal number of matches and
work up.</P
><p class="para"><a class="indexterm" name="AUTOID-3660"></A
><a class="indexterm" name="AUTOID-3662"></A
><a class="indexterm" name="AUTOID-3665"></A
>The quantifiers in the left column above try the biggest quantity first.
This is often called &quot;greedy&quot; matching.  To find the greediest match,
the Engine doesn't actually count down from the maximum value, which
after all could be infinity.   What actually happens in this case is
that the Engine first counts up to find out how many atoms it's
possible to match in a row in the current string, and then it
remembers all the shorter choices and starts out from the longest one.  This could fail, of course, in which case it backtracks
to a shorter choice.</P
><p class="para">If you say <code class="literal">/.*foo/</CODE
>, for example, it will try to match the maximal
number of &quot;any&quot; characters (represented by the dot) clear out to the end
of the line before it ever tries looking for &quot;<code class="literal">foo</CODE
>&quot;, and then when the
&quot;<code class="literal">foo</CODE
>&quot; doesn't match there (and it can't, because there's not enough room
for it at the end of the string), the Engine will back off one character
at a time until it finds a &quot;<code class="literal">foo</CODE
>&quot;.  If there is more than one &quot;<code class="literal">foo</CODE
>&quot; in
the line, it'll stop on the last one, and throw away all the shorter
choices it could have made.</P
><p class="para">By placing a question mark after any of the greedy quantifiers, they
can be made to choose the smallest quantity for the first try.  So if
you say <code class="literal">/.*?foo/</CODE
>, the <code class="literal">.*?</CODE
> first
tries to match 0 characters, then 1 character, then 2, and so on until
it can match the &quot;<code class="literal">foo</CODE
>&quot;.  Instead of backtracking backward, it
backtracks forward, so to speak, and ends up finding the first &quot;<code class="literal">foo</CODE
>&quot;
on the line instead of the last.</P
><p class="para"><b class="emphasis.bold">Rule 6.</B
> Each atom matches according to
its type, listed below.  If the atom doesn't match (or doesn't allow a
match of the rest of the regular expression), the Engine backtracks to
Rule 5 and tries the next choice for the atom's quantity.</P
><p class="para">Atoms match according to the following types:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3685"></A
><a class="indexterm" name="AUTOID-3688"></A
>A regular expression in parentheses, <code class="literal">(...)</CODE
>, matches whatever the
regular expression (represented by <code class="literal">...</CODE
>) matches according to Rule 2.
Parentheses therefore serve as a grouping operator for quantification.
Parentheses also have the side effect of remembering the matched
substring for later use in a <em class="emphasis">backreference</EM
> (to be
discussed later).  This side
effect can be suppressed by using <code class="literal">(?:...)</CODE
> instead, which has only
the grouping semantics&nbsp;- it doesn't store anything in <b class="emphasis.bold">$1</B
>, <b class="emphasis.bold">$2</B
>, and so on.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3698"></A
>A &quot;<code class="literal">.</CODE
>&quot; matches any character except <code class="literal">\n</CODE
>.  (It also matches
<code class="literal">\n</CODE
> if you use the <b class="emphasis.bold">/s</B
> modifier.)  The main use of
dot is as a vehicle for a minimal or maximal quantifier.  A
<code class="literal">.*</CODE
> matches a maximal number of don't-care characters, while a
<code class="literal">.*?</CODE
> matches a minimal number of don't-care characters.  But it's
also sometimes used within parentheses for its width:
<code class="literal">/(..):(..):(..)/</CODE
> matches three colon-separated fields, each of
which is two characters long.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3710"></A
><a class="indexterm" name="AUTOID-3713"></A
><a class="indexterm" name="AUTOID-3716"></A
><a class="indexterm" name="AUTOID-3719"></A
>A list of characters in square brackets (called a <em class="emphasis">character class</EM
>) matches
any one of the characters in the list.
A caret at the front of the list causes it to match only characters that
are <em class="emphasis">not</EM
> in the list.  Character ranges may be indicated using the
<code class="literal">a-z</CODE
> notation.  You may also use any of <code class="literal">\d</CODE
>, <code class="literal">\w</CODE
>,
<code class="literal">\s</CODE
>, <code class="literal">\n</CODE
>, <code class="literal">\r</CODE
>, <code class="literal">\t</CODE
>, <code class="literal">\f</CODE
>, or
<code class="literal">\</CODE
><em class="emphasis">nnn</EM
>, as listed below.  A <code class="literal">\b</CODE
> means a backspace
in a character class.  You may use a backslash to protect a hyphen that
would otherwise be interpreted as a range delimiter.  To match a right
square bracket, either backslash it or place it first in the list.  To
match a caret, <em class="emphasis">don't</EM
> put it first.  Note that most other
metacharacters lose their meta-ness inside square brackets.  In
particular, it's meaningless to specify alternation in a character
class, since the characters are interpreted individually.  For example,
<code class="literal">[fee|fie|foe]</CODE
> means the same thing as <code class="literal">[feio|]</CODE
>.<a class="indexterm" name="AUTOID-3738"></A
><a class="indexterm" name="AUTOID-3740"></A
></P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3745"></A
><a class="indexterm" name="AUTOID-3747"></A
><a class="indexterm" name="AUTOID-3750"></A
>A backslashed letter matches a special character or character class:</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Code</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Matches</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Alarm (beep)</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\n</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Newline</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\r</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Carriage return</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\t</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Tab</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\f</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Formfeed</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\e</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Escape</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\d</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A digit, same as <code class="literal">[0-9]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\D</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A nondigit</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\w</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A word character (alphanumeric), same as <code class="literal">[a-zA-Z_0-9]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\W</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A nonword character</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A whitespace character, same as <code class="literal">[ \t\n\r\f]</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">\S</CODE
></TD
><td class="entry" rowspan="1" colspan="1">A non-whitespace character</TD
></TR
></TBODY
></TABLE
><p class="para">Note that <code class="literal">\w</CODE
> matches a character of a word, not a whole word.  Use
<code class="literal">\w+</CODE
> to match a word.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3815"></A
><a class="indexterm" name="AUTOID-3817"></A
>A backslashed single-digit number matches whatever the corresponding
parentheses actually matched (except that <code class="literal">\0</CODE
> matches a null
character).  This is called a <em class="emphasis">backreference</EM
> to a substring.  A
backslashed multi-digit number such as <code class="literal">\10</CODE
> will be considered a
backreference if the pattern contains at least that many substrings
prior to it, and the number does not start with a <code class="literal">0</CODE
>.  Pairs of
parentheses are numbered by counting left parentheses from the left.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3826"></A
><a class="indexterm" name="AUTOID-3828"></A
>A backslashed two- or three-digit octal number such as <code class="literal">\033</CODE
> matches the
character with the specified value, unless it would be interpreted as a
backreference.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3834"></A
><a class="indexterm" name="AUTOID-3836"></A
>A backslashed <code class="literal">x</CODE
> followed by one or two hexadecimal digits, such as
<code class="literal">\x7f</CODE
>, matches the character having that hexadecimal value.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3843"></A
><a class="indexterm" name="AUTOID-3845"></A
>A backslashed <code class="literal">c</CODE
> followed by a single character, such as <code class="literal">\cD</CODE
>,
matches the corresponding control character.</P
></LI
><li class="listitem"><p class="para">Any other backslashed character matches that character.</P
></LI
><li class="listitem"><p class="para">Any character not mentioned above matches itself.<a class="indexterm" name="AUTOID-3854"></A
><a class="indexterm" name="AUTOID-3855"></A
><a class="indexterm" name="AUTOID-3856"></A
><a class="indexterm" name="AUTOID-3857"></A
></P
></LI
></UL
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-2-SECT-4.1.3">2.4.1.3 The fine print</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-3861"></A
><a class="indexterm" name="AUTOID-3863"></A
>As mentioned above, <code class="literal">\1</CODE
>, <code class="literal">\2</CODE
>, <code class="literal">\3</CODE
>, and so on, are
equivalent to whatever the corresponding set of parentheses matched,
counting opening parentheses from left to right.  (If the particular
pair of parentheses had a quantifier such as <code class="literal">*</CODE
> after it, such
that it matched a series of substrings, then only the last match counts
as the backreference.) Note that such a backreference matches whatever
actually matched for the subpattern in the string being examined;
it's not just a shorthand for the rules of that subpattern.  Therefore,
<code class="literal">(0|0x)\d*\s\1\d*</CODE
> will match &quot;<code class="literal">0x1234 0x4321</CODE
>&quot;, but not &quot;<code class="literal">0x1234
01234</CODE
>&quot;, since subpattern <code class="literal">1</CODE
> actually matched &quot;<code class="literal">0x</CODE
>&quot;, even though the rule
<code class="literal">0|0x</CODE
> could potentially match the leading <code class="literal">0</CODE
> in the second number.</P
><p class="para"><a class="indexterm" name="AUTOID-3878"></A
><a class="indexterm" name="AUTOID-3882"></A
><a class="indexterm" name="AUTOID-3886"></A
><a class="indexterm" name="AUTOID-3889"></A
><a class="indexterm" name="AUTOID-3892"></A
><a class="indexterm" name="AUTOID-3895"></A
>Outside of the pattern (in particular, in the replacement of a
substitution operator) you can continue to refer to backreferences by
using <code class="literal">$</CODE
> instead of <code class="literal">\</CODE
> in front of
the number.  The variables <b class="emphasis.bold">$1</B
>,
<b class="emphasis.bold">$2</B
>, <b class="emphasis.bold">$3</B
> ... are automatically localized, and their
scope (and that of <b class="emphasis.bold">$</B
><code class="literal">`</CODE
>, <b class="emphasis.bold">$&amp;</B
>, and <b class="emphasis.bold">$</B
><code class="literal">'</CODE
> below) extends to the end of the enclosing block or <a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
> string, or to the next successful pattern
match, whichever comes first.
(The <code class="literal">\1</CODE
> notation sometimes works outside the current pattern, but
should not be relied upon.) <b class="emphasis.bold">$+</B
> returns whatever the last bracket
match matched.  <b class="emphasis.bold">$&amp;</B
> returns the entire matched string. <b class="emphasis.bold">$</B
><code class="literal">`</CODE
> returns everything before the matched string.[<a class="footnote" href="#AUTOID-3914">24</A
>]
<b class="emphasis.bold">$</B
><code class="literal">'</CODE
> returns everything after the matched string.  For more explanation
of these magical variables (and for a way to write them in English), see
the section &quot;Special Variables&quot; at the end of this chapter.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-3914">[24]</A
> In the case of something like
<code class="literal">s/pattern/length($`)/eg</CODE
>, which does
multiple replacements if the pattern occurs multiple times, the value of
<b class="emphasis.bold">$</B
><code class="literal">`</CODE
> does not include any modifications done by previous replacement
iterations.  To get the other effect, say:</P
><p class="para"><pre class="programlisting">1 while s/pattern/length($`)/e;</PRE
></P
><p class="para">For example, to change all tabs to the corresponding number of spaces,
you could say:</P
><p class="para"><pre class="programlisting">1 while s/\t+/' ' x (length($&amp;) * 8 - length($`) % 8)/e;</PRE
></P
></DIV
></BLOCKQUOTE
><p class="para">You may have as many parentheses as you wish.  If you have more
than nine pairs, the variables <b class="emphasis.bold">$10</B
>, <b class="emphasis.bold">$11</B
>, ... refer to the
corresponding substring.  Within the pattern, <code class="literal">\10</CODE
>, <code class="literal">\11</CODE
>, and so on, refer back
to substrings if there have been at least that many left parentheses before
the backreference.  Otherwise (for backward compatibility) <code class="literal">\10</CODE
> is the
same as <code class="literal">\010</CODE
>, a backspace, and <code class="literal">\11</CODE
> the same as <code class="literal">\011</CODE
>, a tab.  And so
on.  (<code class="literal">\1</CODE
> through <code class="literal">\9</CODE
> are always backreferences.)</P
><p class="para">Examples:</P
><p class="para"><pre class="programlisting">s/^([^ ]+) +([^ ]+)/$2 $1/;   # swap first two words

/(\w+)\s*=\s*\1/;             # match &quot;foo = foo&quot;

/.{80,}/;                     # match line of at least 80 chars

/^(\d+\.?\d*|\.\d+)$/;        # match valid number

if (/Time: (..):(..):(..)/) { # pull fields out of a line
        $hours   = $1;
        $minutes = $2;
        $seconds = $3;
}</PRE
></P
><p class="para">Hint: instead of writing patterns like <code class="literal">/(...)(..)(.....)/</CODE
>, use the
<a class="xref" href="ch03_182.htm#PERL2-CMD-UNPACK" title="unpack"><b class="xref.cmd">unpack</B
></A
> function.  It's more efficient.</P
><p class="para"><a class="indexterm" name="AUTOID-3944"></A
><a class="indexterm" name="AUTOID-3946"></A
><a class="indexterm" name="AUTOID-3949"></A
><a class="indexterm" name="AUTOID-3952"></A
>A word boundary (<code class="literal">\b</CODE
>) is defined as a spot between two
characters that has a <code class="literal">\w</CODE
> on one side of it and a
<code class="literal">\W</CODE
> on the other side of it (in either order), counting the
imaginary characters off the beginning and end of the string as matching
a <code class="literal">\W</CODE
>.  (Within character classes <code class="literal">\b</CODE
> represents
backspace rather than a word boundary.)</P
><p class="para"><a class="indexterm" name="AUTOID-3961"></A
><a class="indexterm" name="AUTOID-3964"></A
><a class="indexterm" name="AUTOID-3967"></A
><a class="indexterm" name="AUTOID-3969"></A
>Normally, the <code class="literal">^</CODE
> character is guaranteed to match only at the
beginning of the string, the <code class="literal">$</CODE
> character only at the end (or
before the newline at the end), and Perl does certain optimizations with
the assumption that the string contains only one line.  Embedded
newlines will not be matched by <code class="literal">^</CODE
> or <code class="literal">$</CODE
>.  However, you may
wish to treat a string as a multi-line buffer, such that the
<code class="literal">^</CODE
> will also match after any newline within the string, and <code class="literal">$</CODE
>
will also match before any newline.  At the cost of a little more overhead,
you can do this by using the <b class="emphasis.bold">/m</B
> modifier on the pattern match
operator.  (Older programs did this by setting <b class="emphasis.bold">$*</B
>, but this
practice is now deprecated.)  <code class="literal">\A</CODE
> and <code class="literal">\Z</CODE
> are just
like <code class="literal">^</CODE
> and <code class="literal">$</CODE
> except that they won't match multiple times
when the <b class="emphasis.bold">/m</B
> modifier is used, while <code class="literal">^</CODE
> and <code class="literal">$</CODE
> will
match at every internal line boundary.  To match the actual end of the
string, not ignoring newline, you can use <code class="literal">\Z(?!\n)</CODE
>.  There's
an example of a negative lookahead assertion.</P
><p class="para"><a class="indexterm" name="AUTOID-3988"></A
><a class="indexterm" name="AUTOID-3990"></A
><a class="indexterm" name="AUTOID-3993"></A
><a class="indexterm" name="AUTOID-3995"></A
>To facilitate multi-line substitutions, the <code class="literal">.</CODE
> character never matches a
newline unless you use the <b class="emphasis.bold">/s</B
> modifier, which tells Perl to pretend
the string is a single line&nbsp;- even if it isn't.  (The <b class="emphasis.bold">/s</B
> modifier also
overrides the setting of <b class="emphasis.bold">$*</B
>, in case you have some (badly behaved) older
code that sets it in another module.)
In particular, the following leaves a newline on the <b class="emphasis.bold">$_</B
> string:</P
><p class="para"><pre class="programlisting">$_ = &lt;STDIN&gt;;
s/.*(some_string).*/$1/;</PRE
></P
><p class="para">If the newline is unwanted, use any of these:</P
><p class="para"><pre class="programlisting">s/.*(some_string).*/$1/s;
s/.*(some_string).*\n/$1/;
s/.*(some_string)[^\0]*/$1/;
s/.*(some_string)(.|\n)*/$1/;

chop; s/.*(some_string).*/$1/;
/(some_string)/ &amp;&amp; ($_ = $1);</PRE
></P
><p class="para">Note that all backslashed metacharacters in Perl are
alphanumeric, such as <code class="literal">\b</CODE
>, <code class="literal">\w</CODE
>,
and <code class="literal">\n</CODE
>.  Unlike some regular expression languages, there are no backslashed
symbols that aren't alphanumeric.  So anything that looks like
<code class="literal">\\</CODE
>, <code class="literal">\(</CODE
>, <code class="literal">\)</CODE
>, <code class="literal">\&lt;</CODE
>, <code class="literal">\&gt;</CODE
>,
<code class="literal">\{</CODE
>, or <code class="literal">\}</CODE
> is always interpreted as a literal
character, not a metacharacter.  This makes it simple to quote a string
that you want to use for a pattern but that you are afraid might contain
metacharacters.
Just quote all the non-alphanumeric characters:</P
><p class="para"><pre class="programlisting">$pattern =~ s/(\W)/\\$1/g;</PRE
></P
><p class="para">You can also use the built-in <a class="xref" href="ch03_114.htm#PERL2-CMD-QUOTEMETA" title="quotemeta"><b class="xref.cmd">quotemeta</B
></A
> function to do this.
An even easier way to quote metacharacters right in the match operator
is to say:</P
><p class="para"><pre class="programlisting">/$unquoted\Q$quoted\E$unquoted/</PRE
></P
><p class="para">Remember that the first and last alternatives (before the first <code class="literal">|</CODE
> and
after the last one) tend to gobble up the other elements of the regular
expression on either side, out
to the ends of the expression, unless there are enclosing parentheses.  A
common mistake is to ask for:</P
><p class="para"><pre class="programlisting">/^fee|fie|foe$/</PRE
></P
><p class="para">when you really mean:</P
><p class="para"><pre class="programlisting">/^(fee|fie|foe)$/</PRE
></P
><p class="para">The first matches &quot;<code class="literal">fee</CODE
>&quot; at the beginning of the string, or
&quot;<code class="literal">fie</CODE
>&quot; anywhere, or &quot;<code class="literal">foe</CODE
>&quot; at the end of the string.  The second
matches any string consisting solely of &quot;<code class="literal">fee</CODE
>&quot; or &quot;<code class="literal">fie</CODE
>&quot; or
&quot;<code class="literal">foe</CODE
>&quot;.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-2-SECT-4.1.4">2.4.1.4 Regular expression extensions</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-4042"></A
>Perl defines a consistent extension syntax for regular expressions.
You've seen some of them already.
The syntax is a pair of parentheses with a question mark as the first thing
within the parentheses.[<a class="footnote" href="#AUTOID-4045">25</A
>]
The character after the question mark gives the function of the extension.
Several extensions are already supported:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-4045">[25]</A
> This was a syntax error in older versions of Perl.  If you try to use this
and have problems, upgrade to the newest version.</P
></DIV
></BLOCKQUOTE
><dl class="variablelist"><dt class="term"><code class="literal">(?#text)</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-4053"></A
><a class="indexterm" name="AUTOID-4055"></A
>A comment.  The text is ignored.  If the <b class="emphasis.bold">/x</B
> switch is used to enable
whitespace formatting, a simple <code class="literal">#</CODE
> will suffice.</P
></DD
><dt class="term"><code class="literal">(?:...)</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-4065"></A
>This groups things like &quot;<code class="literal">(...)</CODE
>&quot; but doesn't make backreferences like &quot;<code class="literal">(...)</CODE
>&quot; does.  So:</P
><p class="para"><pre class="programlisting">split(/\b(?:a|b|c)\b/)</PRE
></P
><p class="para">is like:</P
><p class="para"><pre class="programlisting">split(/\b(a|b|c)\b/)</PRE
></P
><p class="para">but doesn't actually save anything in <b class="emphasis.bold">$1</B
>, which means
that the first <a class="xref" href="ch03_155.htm#PERL2-CMD-SPLIT" title="split"><b class="xref.cmd">split</B
></A
> doesn't spit out extra delimiter fields
as the second one does.</P
></DD
><dt class="term"><code class="literal">(?=...)</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-4083"></A
><a class="indexterm" name="AUTOID-4085"></A
><a class="indexterm" name="AUTOID-4087"></A
>A zero-width positive lookahead assertion.  For example, <code class="literal">/\w+(?=\t)/</CODE
>
matches a word followed by a tab, without including the tab in <b class="emphasis.bold">$&amp;</B
>.</P
></DD
><dt class="term"><code class="literal">(?!...)</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-4097"></A
><a class="indexterm" name="AUTOID-4099"></A
>A zero-width negative lookahead assertion.  For example <code class="literal">/foo(?!bar)/</CODE
>
matches any occurrence of &quot;<code class="literal">foo</CODE
>&quot; that isn't followed by &quot;<code class="literal">bar</CODE
>&quot;.  Note,
however, that lookahead and lookbehind are <em class="emphasis">not</EM
> the same thing.  You cannot
use this for lookbehind: <code class="literal">/(?!foo)bar/</CODE
> will not find an occurrence of
&quot;<code class="literal">bar</CODE
>&quot; that is preceded by something that is not &quot;<code class="literal">foo</CODE
>&quot;.  That's because
the <code class="literal">(?!foo)</CODE
> is just saying that the next thing cannot be &quot;<code class="literal">foo</CODE
>&quot;&nbsp;- and
it's not, it's a &quot;<code class="literal">bar</CODE
>&quot;, so &quot;<code class="literal">foobar</CODE
>&quot; will match.  You would have to do
something like <code class="literal">/(?!foo)</CODE
>...<code class="literal">bar/</CODE
> for that.   We say &quot;like&quot; because there's
the case of your &quot;<code class="literal">bar</CODE
>&quot; not having three characters before it.  You could
cover that this way: <code class="literal">/(?:(?!foo)</CODE
>...<code class="literal">|^</CODE
>.<code class="literal">{0, 2}bar/</CODE
>.  Sometimes it's still
easier just to say:</P
><p class="para"><pre class="programlisting">if (/bar/ and $` !~ /foo$/)</PRE
></P
></DD
><dt class="term"><code class="literal">(?imsx)</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-4126"></A
><a class="indexterm" name="AUTOID-4129"></A
><a class="indexterm" name="AUTOID-4131"></A
>One or more embedded pattern-match modifiers.  This is particularly
useful for patterns that are specified in a table somewhere, some of
which want to be case-sensitive, and some of which don't.  The case-insensitive ones merely need to include <code class="literal">(?i)</CODE
> at the front of the
pattern.  For example:</P
><p class="para"><pre class="programlisting"># hardwired case insensitivity
$pattern = &quot;buffalo&quot;;
if ( /$pattern/i )

# data-driven case insensitivity
$pattern = &quot;(?i)buffalo&quot;;
if ( /$pattern/ )</PRE
></P
></DD
></DL
><p class="para">We chose to use the question mark for this (and for the new minimal
matching construct) because (1) question mark is pretty rare in older
regular expressions, and (2) whenever you see one, you should stop
and <em class="emphasis">question</EM
> exactly what is going on.  That's psychology.</P
><a class="indexterm" name="AUTOID-4139"></A
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-4.2">2.4.2 Pattern-Matching Operators</A
></H3
><p class="para">Now that we've got all that out of the way, here finally are the
quotelike operators (er, terms) that perform pattern matching and related
activities.<a class="indexterm" name="CH02.MO1"></A
><a class="indexterm" name="CH02.MO2"></A
></P
><dl class="variablelist"><dt class="term"><code class="literal">m/</CODE
><code class="replaceable"><i>PATTERN</I
></CODE
><code class="literal">/gimosx</CODE
></DT
><dt class="term"><code class="literal">/</CODE
><code class="replaceable"><i>PATTERN</I
></CODE
><code class="literal">/gimosx</CODE
></DT
><dd class="listitem"><p class="para">This operator searches a string for a pattern match, and in a scalar context
returns true (<code class="literal">1</CODE
>) or false (<code class="literal">&quot;&quot;</CODE
>).  If no string is specified via
the <code class="literal">=~</CODE
> or <code class="literal">!~</CODE
> operator, the
<b class="emphasis.bold">$_</B
> string is searched.  (The string
specified with <code class="literal">=~</CODE
> need not be an lvalue&nbsp;- it
may be the result of an expression evaluation, but remember the
<code class="literal">=~</CODE
> binds rather tightly, so you may need
parentheses around your expression.)</P
></DD
></DL
><p class="para"><a class="indexterm" name="AUTOID-4167"></A
><a class="indexterm" name="AUTOID-4169"></A
><a class="indexterm" name="AUTOID-4171"></A
><a class="indexterm" name="AUTOID-4173"></A
><a class="indexterm" name="AUTOID-4176"></A
><a class="indexterm" name="AUTOID-4179"></A
>Modifiers are:</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Modifier</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">g</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Match globally, that is, find all occurrences.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">i</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Do case-insensitive pattern matching.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">m</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as multiple lines.   <em class="emphasis">(continued)</EM
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">o</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Only compile pattern once.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as single line.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">x</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Use extended regular expressions.</TD
></TR
></TBODY
></TABLE
><p class="para">If <code class="literal">/</CODE
> is the delimiter then the initial <code class="literal">m</CODE
> is optional.  With the <code class="literal">m</CODE
>
you can use any pair of non-alphanumeric, non-whitespace characters as
delimiters.  This is particularly useful for matching filenames
that contain &quot;<code class="literal">/</CODE
>&quot;, thus avoiding LTS (leaning toothpick syndrome).</P
><p class="para"><a class="indexterm" name="AUTOID-4219"></A
><a class="indexterm" name="AUTOID-4221"></A
><code class="replaceable"><i>PATTERN</I
></CODE
> may contain variables, which will be interpolated (and the
pattern recompiled) every time the pattern search is evaluated.  (Note
that <b class="emphasis.bold">$)</B
> and <b class="emphasis.bold">$|</B
> will not be interpolated because they look
like end-of-line tests.)  If you want such a pattern to be compiled only
once, add a <b class="emphasis.bold">/o</B
> after the trailing delimiter.  This avoids
expensive run-time recompilations, and is useful when the value you are
interpolating won't change during execution.  However,
mentioning <b class="emphasis.bold">/o</B
> constitutes a promise that you won't change the
variables in the pattern.  If you do change them, Perl won't even
notice.</P
><p class="para">If the <code class="replaceable"><i>PATTERN</I
></CODE
> evaluates to a null string, the last successfully
executed regular expression not hidden within an inner block (including
<a class="xref" href="ch03_155.htm#PERL2-CMD-SPLIT" title="split"><b class="xref.cmd">split</B
></A
>, <a class="xref" href="ch03_072.htm#PERL2-CMD-GREP" title="grep"><b class="xref.cmd">grep</B
></A
>, and <a class="xref" href="ch03_091.htm#PERL2-CMD-MAP" title="map"><b class="xref.cmd">map</B
></A
>) is used instead.</P
><p class="para">If used in a context that requires a list value, a pattern match returns
a list consisting of the subexpressions matched by the parentheses in
the pattern&nbsp;- that is, (<b class="emphasis.bold">$1</B
>, <b class="emphasis.bold">$2</B
>, <b class="emphasis.bold">$3</B
> ...). (The variables are
also set.)  If the match fails, a null list is returned.  If the match
succeeds, but there were no parentheses, a list value of (1) is
returned.</P
><p class="para">Examples:</P
><p class="para"><pre class="programlisting"># case insensitive matching
open(TTY, '/dev/tty');
&lt;TTY&gt; =~ /^y/i and foo();    # do foo() if they want it

# pulling a substring out of a line
if (/Version: *([0-9.]+)/) { $version = $1; }

# avoiding Leaning Toothpick Syndrome
next if m#^/usr/spool/uucp#;

# poor man's grep
$arg = shift;
while (&lt;&gt;) {
    print if /$arg/o;       # compile only once
}

# get first two words and remainder as a list
if (($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/))</PRE
></P
><p class="para">This last example splits <code class="literal">$foo</CODE
> into the first two words and the
remainder of the line, and assigns those three fields to <code class="literal">$F1</CODE
>,
<code class="literal">$F2</CODE
>, and <code class="literal">$Etc</CODE
>.  The conditional is true if any variables
were assigned, that is, if the pattern matched.  Usually, though, one would
just write the equivalent <a class="xref" href="ch03_155.htm#PERL2-CMD-SPLIT" title="split"><b class="xref.cmd">split</B
></A
>:</P
><p class="para"><pre class="programlisting">if (($F1, $F2, $Etc) = split(' ', $foo, 3))</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-4249"></A
><a class="indexterm" name="AUTOID-4251"></A
>The <b class="emphasis.bold">/g</B
> modifier specifies global pattern matching&nbsp;- that is, matching
as many times as possible within the string.  How it behaves depends on
the context.  In a list context, it returns a list of all the
substrings matched by all the parentheses in the regular expression.
If there are no parentheses, it returns a list of all the matched
strings, as if there were parentheses around the whole pattern.</P
><p class="para">In a scalar context, <b class="emphasis.bold">m//g</B
> iterates through the string, returning true
each time it matches, and false when it eventually runs out of
matches.  (In other words, it remembers where it left off last time and
restarts the search at that point.  You can find the current
match position of a string using the <a class="xref" href="ch03_109.htm#PERL2-CMD-POS" title="pos"><b class="xref.cmd">pos</B
></A
> function&nbsp;- see <a class="xref" href="ch03_01.htm" title="Functions">Chapter 3</A
>.)
If you modify the string in any way, the match position is reset to the
beginning.  Examples:</P
><p class="para"><pre class="programlisting"># list context--extract three numeric fields from uptime command
($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

# scalar context--count sentences in a document by recognizing
# sentences ending in [.!?], perhaps with quotes or parens on 
# either side.  Observe how dot in the character class is a literal
# dot, not merely any character.
$/ = &quot;&quot;;  # paragraph mode
while ($paragraph = &lt;&gt;) {
    while ($paragraph =~ /[a-z]['&quot;)]*[.!?]+['&quot;)]*\s/g) {
        $sentences++;
    }
}
print &quot;$sentences\n&quot;;

# find duplicate words in paragraphs, possibly spanning line boundaries.
#   Use /x for space and comments, /i to match the both `is' 
#   in &quot;Is is this ok?&quot;, and use /g to find all dups.
$/ = &quot;&quot;;        # paragrep mode again
while (&lt;&gt;) {
    while ( m{
                \b            # start at a word boundary
                (\w\S+)       # find a wordish chunk
                ( 
                    \s+       # separated by some whitespace
                    \1        # and that chunk again
                ) +           # repeat ad lib
                \b            # until another word boundary
             }xig
         ) 
    {
        print &quot;dup word `$1' at paragraph $.\n&quot;;
    } 
}</PRE
><a class="indexterm" name="AUTOID-4261"></A
><a class="indexterm" name="AUTOID-4262"></A
></P
><dl class="variablelist"><dt class="term"><code class="literal">?</CODE
><code class="replaceable"><i>PATTERN</I
></CODE
><code class="literal">?</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-4271"></A
><a class="indexterm" name="AUTOID-4273"></A
>This is just like the
<code class="literal">/</CODE
><code class="replaceable"><i>PATTERN</I
></CODE
><code class="literal">/</CODE
>
search, except that it matches only once between calls to the
<a class="xref" href="ch03_124.htm#PERL2-CMD-RESET" title="reset"><b class="xref.cmd">reset</B
></A
> operator.  This is a useful
optimization when you only want to see the first occurrence of
something in each file of a set of files, for instance.  Only
<code class="literal">??</CODE
> patterns local to the current package are reset.</P
></DD
></DL
><p class="para">This usage is vaguely deprecated, and may be removed in some future
version of Perl.  Most people just bomb out of the loop when they
get the match they want.</P
><dl class="variablelist"><dt class="term"><code class="literal">s/</CODE
><code class="replaceable"><i>PATTERN</I
></CODE
><code class="literal">/</CODE
><code class="replaceable"><i>REPLACEMENT</I
></CODE
><code class="literal">/egimosx</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="CH02.SO1"></A
><a class="indexterm" name="CH02.SO2"></A
>This operator searches a string for <code class="replaceable"><i>PATTERN</I
></CODE
>, and if found, replaces
that match with the <code class="replaceable"><i>REPLACEMENT</I
></CODE
> text and returns the number of
substitutions made, which can be more than one with the <b class="emphasis.bold">/g</B
> modifier.
Otherwise it returns false (0).</P
></DD
></DL
><p class="para">If no string is specified via the <code class="literal">=~</CODE
> or <code class="literal">!~</CODE
> operator, the
<b class="emphasis.bold">$_</B
> variable is searched and modified.  (The string specified with
<code class="literal">=~</CODE
> must be a scalar variable, an array element, a hash element,
or an assignment to one of those, that is, an lvalue.)</P
><p class="para"><a class="indexterm" name="AUTOID-4304"></A
>If the delimiter you choose happens to be a single quote, no variable
interpolation is done on either the <code class="replaceable"><i>PATTERN</I
></CODE
> or the <code class="replaceable"><i>REPLACEMENT</I
></CODE
>.
Otherwise, if the <code class="replaceable"><i>PATTERN</I
></CODE
> contains a <code class="literal">$</CODE
> that looks like a variable rather
than an end-of-string test, the variable will be interpolated into the
<code class="replaceable"><i>PATTERN</I
></CODE
> at run-time.  If you want the <code class="replaceable"><i>PATTERN</I
></CODE
>
compiled only once, when the
variable is first interpolated, use the <b class="emphasis.bold">/o</B
> option.  If the
<code class="replaceable"><i>PATTERN</I
></CODE
> evaluates to a null string, the
last successfully executed
regular expression is used instead.  The <code class="replaceable"><i>REPLACEMENT</I
></CODE
> pattern also
undergoes variable interpolation, but it does so each time the <code class="replaceable"><i>PATTERN</I
></CODE
>
matches, unlike the <code class="replaceable"><i>PATTERN,</I
></CODE
> which just gets interpolated once when
the operator is evaluated.  (The <code class="replaceable"><i>PATTERN</I
></CODE
> can match multiple times in one
evaluation if you use the <b class="emphasis.bold">/g</B
> option below.)</P
><p class="para"><a class="indexterm" name="AUTOID-4320"></A
><a class="indexterm" name="AUTOID-4322"></A
><a class="indexterm" name="AUTOID-4324"></A
><a class="indexterm" name="AUTOID-4326"></A
><a class="indexterm" name="AUTOID-4328"></A
><a class="indexterm" name="AUTOID-4331"></A
>Modifiers are:</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Modifier</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">e</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Evaluate the right side as an expression.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">g</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Replace globally, that is, all occurrences.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">i</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Do case-insensitive pattern matching.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">m</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as multiple lines.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">o</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Only compile pattern once.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Treat string as single line.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">x</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Use extended regular expressions.</TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-4370"></A
>Any non-alphanumeric, non-whitespace delimiter may replace the slashes.
If single quotes are used, no interpretation is done on the replacement
string (the <b class="emphasis.bold">/e</B
> modifier overrides this, however). If the <code class="replaceable"><i>PATTERN</I
></CODE
> is contained
within naturally paired delimiters (such as parentheses), the
<code class="replaceable"><i>REPLACEMENT</I
></CODE
> has its own pair of delimiters, which may or may not be
the same ones used for <code class="replaceable"><i>PATTERN</I
></CODE
>&nbsp;- for example, <code class="literal">s(foo)(bar)</CODE
> or
<code class="literal">s&lt;foo&gt;/bar/</CODE
>.  A <b class="emphasis.bold">/e</B
> will cause the replacement portion to be
interpreted as a full-fledged Perl expression instead of as a
double-quoted string.  (It's kind of like an <a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
>, but its
syntax is checked at compile-time.)</P
><p class="para">Examples:</P
><p class="para"><pre class="programlisting"># don't change wintergreen
s/\bgreen\b/mauve/g;

# avoid LTS with different quote characters
$path =~ s(/usr/bin)(/usr/local/bin);

# interpolated pattern and replacement
s/Login: $foo/Login: $bar/;

# modifying a string &quot;en passant&quot;
($foo = $bar) =~ s/this/that/;

# counting the changes
$count = ($paragraph =~ s/Mister\b/Mr./g);

# using an expression for the replacement
$_ = 'abc123xyz';
s/\d+/$&amp;*2/e;               # yields 'abc246xyz'
s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e;  # yields 'abc  246xyz'
s/\w/$&amp; x 2/eg;             # yields 'aabbcc  224466xxyyzz'

# how to default things with /e
s/%(.)/$percent{$1}/g;            # change percent escapes; no /e
s/%(.)/$percent{$1} || $&amp;/ge;     # expr now, so /e
s/^=(\w+)/&amp;pod($1)/ge;            # use function call

# /e's can even nest; this will expand simple embedded variables in $_
s/(\$\w+)/$1/eeg;

# delete C comments
$program =~ s {
    /\*     # Match the opening delimiter.
    .*?     # Match a minimal number of characters.
    \*/     # Match the closing delimiter.
} []gsx;

# trim white space
s/^\s*(.*?)\s*$/$1/;

# reverse 1st two fields
s/([^ ]*) *([^ ]*)/$2 $1/;</PRE
></P
><p class="para">Note the use of <code class="literal">$</CODE
> instead of <code class="literal">\</CODE
> in the last example.
Some people get a little too used to writing things like:</P
><p class="para"><pre class="programlisting">$pattern =~ s/(\W)/\\\1/g;</PRE
></P
><p class="para">This is grandfathered for the right-hand side of a substitution to avoid
shocking the <em class="emphasis">sed</EM
> addicts, but it's a dirty habit to get into.[<a class="footnote" href="#AUTOID-4390">26</A
>]
That's because in PerlThink, the right-hand side of a <code class="literal">s///</CODE
> is a
double-quoted string.  In an ordinary double-quoted string, <code class="literal">\1</CODE
>
would mean a control-A, but for <code class="literal">s///</CODE
> the customary UNIX meaning
of <code class="literal">\1</CODE
> is kludged in.  (The lexer actually translates it to
<b class="emphasis.bold">$1</B
> on the fly.)  If you start to rely on that, however, you get
yourself into trouble if you then add an <b class="emphasis.bold">/e</B
> modifier:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-4390">[26]</A
> Or to not get out of, depending on how you look at it.</P
></DIV
></BLOCKQUOTE
><p class="para"><pre class="programlisting">s/(\d+)/ \1 + 1 /eg;   # a scalar reference plus one?</PRE
></P
><p class="para">Or if you try to do:</P
><p class="para"><pre class="programlisting">s/(\d+)/\1000/;        # &quot;\100&quot; . &quot;0&quot; == &quot;@0&quot;?</PRE
></P
><p class="para">You can't disambiguate that by saying <code class="literal">\{1}000</CODE
>, whereas you
<em class="emphasis">can</EM
> fix it with <code class="literal">${1}000</CODE
>.  Basically, the operation of
interpolation should not be confused with the operation of matching a
backreference.  Certainly, interpolation and matching mean two different
things on the <em class="emphasis">left</EM
> side of the <code class="literal">s///</CODE
>.</P
><p class="para"><a class="indexterm" name="AUTOID-4410"></A
>Occasionally, you can't just use a <b class="emphasis.bold">/g</B
> to get all the changes to
occur, either because the substitutions have to happen right-to-left, or
because you need the length of <b class="emphasis.bold">$</B
><code class="literal">`</CODE
> to change between matches.  In this
case you can usually do what you want by calling the substitution
repeatedly.  Here are two common cases:</P
><p class="para"><pre class="programlisting"># put commas in the right places in an integer
1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/;

# expand tabs to 8-column spacing
1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;</PRE
><a class="indexterm" name="AUTOID-4417"></A
><a class="indexterm" name="AUTOID-4418"></A
></P
><dl class="variablelist"><dt class="term"><code class="literal">tr/</CODE
><code class="replaceable"><i>SEARCHLIST</I
></CODE
><code class="literal">/</CODE
><code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
><code class="literal">/cds</CODE
></DT
><dt class="term"><code class="literal">y/</CODE
><code class="replaceable"><i>SEARCHLIST</I
></CODE
><code class="literal">/</CODE
><code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
><code class="literal">/cds</CODE
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-4435"></A
><a class="indexterm" name="AUTOID-4437"></A
><a class="indexterm" name="AUTOID-4439"></A
><a class="indexterm" name="AUTOID-4441"></A
>Strictly speaking, this operator doesn't belong in a section on pattern
matching because it doesn't use regular expressions.  Rather, it scans
a string character by character, and replaces
all occurrences of the characters found in the <code class="replaceable"><i>SEARCHLIST</I
></CODE
> 
with the corresponding character in the <code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
>.  It returns
the number of characters replaced or deleted.  If no string is
specified via the <code class="literal">=~</CODE
> or <code class="literal">!~</CODE
> operator, the <b class="emphasis.bold">$_</B
> string is translated.  (The
string specified with <code class="literal">=~</CODE
> must be a scalar variable, an array element,
or an assignment to one of those, that is, an lvalue.)  For <em class="emphasis">sed</EM
> devotees,
<b class="emphasis.bold">y</B
> is provided as a synonym for <a class="xref" href="ch03_175.htm#PERL2-CMD-TR" title="tr///"><b class="xref.cmd">tr///</B
></A
>.  If the <code class="replaceable"><i>SEARCHLIST</I
></CODE
> is
contained within naturally paired delimiters (such as parentheses), the
<code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
> has its own pair of delimiters, which may or may
not be naturally paired ones&nbsp;- for example, <code class="literal">tr[A-Z][a-z]</CODE
>
or <code class="literal">tr(+-*/)/ABCD/</CODE
>.</P
></DD
></DL
><p class="para">Modifiers:</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Modifier</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Meaning</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">c</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Complement the <code class="replaceable"><i>SEARCHLIST</I
></CODE
>.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">d</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Delete found but unreplaced characters.</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">s</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Squash duplicate replaced characters.</TD
></TR
></TBODY
></TABLE
><p class="para"><a class="indexterm" name="AUTOID-4478"></A
>If the <b class="emphasis.bold">/c</B
> modifier is specified, the
<code class="replaceable"><i>SEARCHLIST</I
></CODE
> character set is complemented; that
is, the effective search list consists of all the characters
<em class="emphasis">not</EM
> in <code class="replaceable"><i>SEARCHLIST</I
></CODE
>.  If the
<b class="emphasis.bold">/d</B
> modifier is specified, any
characters specified by <code class="replaceable"><i>SEARCHLIST</I
></CODE
> but not given
a replacement in <code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
> are deleted.
(Note that this is slightly more flexible than the behavior of some
<a class="xref" href="ch03_175.htm#PERL2-CMD-TR" title="tr///"><b class="xref.cmd">tr///</B
></A
> programs, which delete anything they
find in the <code class="replaceable"><i>SEARCHLIST</I
></CODE
>, period.)  If the
<b class="emphasis.bold">/s</B
> modifier is specified, sequences of
characters that were translated to the same character are squashed
down to a single instance of the character.<a class="indexterm" name="AUTOID-4490"></A
></P
><p class="para"><a class="indexterm" name="AUTOID-4493"></A
>If the <b class="emphasis.bold">/d</B
> modifier is used, the
<code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
> is always interpreted exactly as
specified.  Otherwise, if the <code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
> is
shorter than the <code class="replaceable"><i>SEARCHLIST</I
></CODE
>, the final character
is replicated until it is long enough.  If the
<code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
> is null, the
<code class="replaceable"><i>SEARCHLIST</I
></CODE
> is replicated.  This latter is useful
for counting characters in a class or for squashing character
sequences in a class.</P
><p class="para">Examples:</P
><p class="para"><pre class="programlisting">$ARGV[1] =~ tr/A-Z/a-z/;    # canonicalize to lower case

$cnt = tr/*/*/;             # count the stars in $_

$cnt = $sky =~ tr/*/*/;     # count the stars in $sky

$cnt = tr/0-9//;            # count the digits in $_

tr/a-zA-Z//s;               # bookkeeper -&gt; bokeper

($HOST = $host) =~ tr/a-z/A-Z/;

tr/a-zA-Z/ /cs;             # change non-alphas to single space

tr [\200-\377]
   [\000-\177];             # delete 8th bit</PRE
></P
><p class="para">If multiple translations are given for a character, only the first one is used:</P
><p class="para"><pre class="programlisting">tr/AAA/XYZ/</PRE
></P
><p class="para">will translate any A to X.</P
><p class="para"><a class="indexterm" name="AUTOID-4509"></A
><a class="indexterm" name="AUTOID-4512"></A
>Note that because the translation table is built at compile time, neither
the <code class="replaceable"><i>SEARCHLIST</I
></CODE
> nor the <code class="replaceable"><i>REPLACEMENTLIST</I
></CODE
>
are subject to double quote
interpolation.  That means that if you want to use variables, you must use
an <a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
>:</P
><p class="para"><pre class="programlisting">eval &quot;tr/$oldlist/$newlist/&quot;;
die $@ if $@;

eval &quot;tr/$oldlist/$newlist/, 1&quot; or die $@;</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-4521"></A
><a class="indexterm" name="AUTOID-4523"></A
>One more note: if you want to change your text to uppercase or
lowercase, it's better to use the <code class="literal">\U</CODE
> or <code class="literal">\L</CODE
> sequences
in a double-quoted string, since they will pay attention to locale
information, but <code class="literal">tr/a-z/A-Z/</CODE
> won't.<a class="indexterm" name="AUTOID-4529"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch02_03.htm#PERL2-CH-2-SECT-3.1" title="2.3 Terms"><img src="../gifs/txtpreva.gif" alt="Previous: 2.3 Terms" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Programming Perl"><img src="../gifs/txthome.gif" alt="Programming Perl" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch02_05.htm#PERL2-CH-2-SECT-5.10" title="2.5 Operators"><img src="../gifs/txtnexta.gif" alt="Next: 2.5 Operators" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">2.3 Terms</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">2.5 Operators</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
