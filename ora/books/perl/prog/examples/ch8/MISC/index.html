perl -d -e 42
*****
DB<1> |h
*****
V DB filename line
*****
b 237 $x > 30
b 33 /pattern/i
*****
a 53 print "DB FOUND $foo\n"
*****
$ PERLDB_OPTS="N f=2" perl -d myprogram
*****
|V main
*****
DB<8>
*****
DB<17>>
*****
  DB<1> for (1..4) {         \
  cont:     print "ok\n";    \
  cont: }
  ok
  ok
  ok
  ok
*****
shell_prompt% perl -d camel_flea
Stack dump during die enabled outside of evals.

Loading DB routines from perl5db.pl patch level 0.94
Emacs support available.

Enter h or `h h' for help.

main::(camel_flea:3):   $a = 1;
  DB<1> 
*****
  DB<1> b infested
  DB<2> c
*****
main::infested(camel_flea:12):      my bugs;
*****
  DB<2> w
9:      } 
10:
11:     sub infested {
12==>b      my $bugs;
13:         return 3.5;
14:     } 
  DB<2> 
*****
  DB<2> T
$ = main::infested called from file `Ambulation.pm' line 10
@ = Ambulation::legs(1, 2, 3, 4) called from file `camel_flea' line 7
$ = main::pests('bactrian', 4) called from file `camel_flea' line 4
*****
BEGIN { require "myperl5db.pl" }
*****
$DB::alias{'len'}  = 's/^len(.*)/p length($1)/';
$DB::alias{'stop'} = 's/^stop (at|in)/b/';
$DB::alias{'ps'}   = 's/^ps\b/p scalar /';
$DB::alias{'quit'} = 's/^quit\b.*/exit/';
*****
&parse_options("NonStop=1 LineInfo=db.out");
sub afterinit { $trace = 1; }
*****
perl -d:DProf mycode.pl
*****
print STDOUT, "goodbye", $adj, "world!\n";    # WRONG
*****
print STDOUT "goodbye", $adj, "world!\n";     # ok
*****
print $filehandle "goodbye", $adj, "world!\n";
*****
print $notafilehandle, "goodbye", $adj, "world!\n";
*****
($one,$two) = /(\w+) (\w+)/;
*****
print "the answer is @foo[1]\n";
*****
@foo[1] = <stdin>;
*****
print <fh> "hi";    # WRONG, omit angles
*****
while (<fh>)      { }
while ($_ = <fh>) { }..
<fh>;  # data discarded!
*****
$x =  /foo/;  # changes $x
$x =~ /foo/;  # doesn't
*****
use English;
*****
if (expression) {
    block;
}
else if (another_expression) {
    another_block;
}
*****
if (expression) {
    block;
}
elsif (another_expression) {
    another_block;
}
*****
camel='dromedary';      # WRONG
*****
$camel='dromedary';     # ok
*****
foreach hump (one two)
stuff_it $hump
end
*****
foreach $hump ("one", "two") {
    stuff_it($hump);
}
*****
chop($thishost = `hostname`);
*****
sub SeeYa { die "Hasta la vista, baby!" }
$SIG{'QUIT'} = SeeYa;
*****
print "$a::$b::$c\n";
*****
print "$var::abc::xyz\n";
*****
shift @list + 20; # now parses like shift(@list + 20), illegal!
$n = keys %map + 20; # now parses like keys(%map + 20), illegal!
*****
sleep $dormancy + 20;
*****
/foo/ ? ($a += 2) : ($a -= 2);
*****
/foo/ ? $a += 2 : $a -= 2;
*****
(/foo/ ? $a += 2 : $a) -= 2;
*****
$a += /foo/ ? 1 : 2;
*****
foreach $var (grep /x/, @list) { ... }
*****
foreach $var (my @tmp = grep /x/, @list) { ... }
*****
my %keywords;
for (@keywords) {
    $keywords{$_}++;
}
*****
${$pkg . '::' . $varname} = &{ "fix_" . $varname }($pkg);
*****
"foundstring" =~ /$currentpattern/;        # Dummy match (must succeed).
while (<>) {
    print if //;
}
*****
print if /one-hump/ || /two/;
*****
print if /one-hump|two/;
*****
while (<>) {
    next if /^#/;
    next if /^$/;
    chop;
    @piggies = split(/,/);
    ...
}
*****
opendir(DIR,".");
@files = sort grep(!/^\./, readdir(DIR));
closedir(DIR);
*****
$foo = substr($foo,0,3) . $bar . substr($foo,6);
*****
substr($foo,3,3) = $bar;
*****
if ($a) {
    $foo = $a;
}
elsif ($b) {
    $foo = $b;
}
elsif ($c) {
    $foo = $c;
}
*****
$pi ||= 3;
*****
print $fullname{$name} . " has a new home directory " .
    $home{$name} . "\n";
*****
print $fullname{$name}, " has a new home directory ",
    $home{$name}, "\n";
*****
sub numtoname {
    local($_) = @_;
    unless (defined $numtoname{$_}) {
        local(@a) = gethostbyaddr(pack('C4', split(/\./)),2);
        $numtoname{$_} = @a > 0 ? $a[0] : $_;
    }
    $numtoname{$_};
}
*****
chmod +t /usr/bin/perl
*****
open(FILE, $file) or die "$0: Can't open $file for reading: $!\n";
*****
while ($condition) {	# for short ones, align with keywords
    # do something
} 

# if the condition wraps, line up the 
# braces with each other
while ($this_condition and $that_condition
       and $this_other_long_condition) 
{
    # do something
} 
*****
open(FOO,$foo) || die "Can't open $foo: $!";
*****
die "Can't open $foo: $!" unless open(FOO,$foo);
*****
print "Starting analysis\n" if $verbose;
*****
$verbose && print "Starting analysis\n";
*****
return print reverse sort num values %array;
return print(reverse(sort num (values(%array))));
*****
LINE:
    for (;;) {
        statements;
      last LINE if $foo;
        next LINE if /^#/;
        statements;
    }
*****
$ALL_CAPS_HERE   # constants only (beware clashes with Perl vars!)  
$Some_Caps_Here  # package-wide global/static 
$no_caps_here    # function scope my() or local() variables 
*****
$IDX = $ST_MTIME;       
$IDX = $ST_ATIME       if $opt_u; 
$IDX = $ST_CTIME       if $opt_c;     
$IDX = $ST_SIZE        if $opt_s;     
*****
mkdir $tmpdir, 0700 or die "can't mkdir $tmpdir: $!";
chdir($tmpdir)      or die "can't chdir $tmpdir: $!";
mkdir 'tmp',   0777 or die "can't mkdir $tmpdir/tmp: $!";
*****
opendir(D, $dir)     or die "can't opendir $dir: $!";
*****
tr [abc]
   [xyz];
