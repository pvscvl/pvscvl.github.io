<html><head>
<title>[Chapter 8] 8.2 Common Goofs for Novices</TITLE>
<meta name="DC.title" content="Programming Perl"><meta name="DC.creator" content="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T02:06:42Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-149-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch08_01.htm" title="8. Other Oddments"><link rel="prev" href="ch08_01.htm" title="8.1 The Perl Debugger"><link rel="next" href="ch08_03.htm#PERL2-CH-8-SECT-3.1" title="8.3 Efficiency"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Programming Perl" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Programming Perl"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch08_01.htm" title="8.1 The Perl Debugger"><img src="../gifs/txtpreva.gif" alt="Previous: 8.1 The Perl Debugger" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch08_01.htm" title="8. Other Oddments">Chapter 8<br>Other Oddments</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch08_03.htm#PERL2-CH-8-SECT-3.1" title="8.3 Efficiency"><img src="../gifs/txtnexta.gif" alt="Next: 8.3 Efficiency" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PERL2-CH-8-SECT-2">8.2 Common Goofs for Novices</A
></H2
><p class="para"><a class="indexterm" name="CH08.TROUBLE1"></A
><a class="indexterm" name="CH08.TROUBLE2"></A
>The biggest goof of all is forgetting to use the <b class="emphasis.bold">-w</B
> switch, which points out many errors.  The second
biggest goof is not using <code class="literal">use strict</CODE
> when it's appropriate.</P
><p class="para">Apart from those, there are certain traps that almost everyone falls into, and
other traps you'll fall into only if you come from a particular culture.  We've
separated these out in the following sections.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-8-SECT-2.1">8.2.1 Universal Blunders</A
></H3
><ul class="itemizedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28630"></A
>Putting a comma after the filehandle in a <a class="xref" href="ch03_110.htm#PERL2-CMD-PRINT" title="print"><b class="xref.cmd">print</B
></A
> statement.
Although it looks extremely regular and pretty to say:</P
><pre class="programlisting">print STDOUT, &quot;goodbye&quot;, $adj, &quot;world!\n&quot;;    # WRONG</PRE
><p class="para">this is nonetheless incorrect, because of that first comma.  What you
want instead is:</P
><pre class="programlisting">print STDOUT &quot;goodbye&quot;, $adj, &quot;world!\n&quot;;     # ok</PRE
><p class="para">The syntax is this way so that you can say:</P
><pre class="programlisting">print $filehandle &quot;goodbye&quot;, $adj, &quot;world!\n&quot;;</PRE
><p class="para">where <code class="literal">$filehandle</CODE
> is a scalar holding the name of a filehandle at
run-time.  This is distinct from:</P
><pre class="programlisting">print $notafilehandle, &quot;goodbye&quot;, $adj, &quot;world!\n&quot;;</PRE
><p class="para">where <code class="literal">$notafilehandle</CODE
> is simply a string that is added to the list
of things to be printed.  See Indirect Object in the glossary.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28645"></A
><a class="indexterm" name="AUTOID-28648"></A
><a class="indexterm" name="AUTOID-28651"></A
><a class="indexterm" name="AUTOID-28653"></A
><a class="indexterm" name="AUTOID-28655"></A
><a class="indexterm" name="AUTOID-28658"></A
>Using <code class="literal">==</CODE
> instead of <b class="emphasis.bold">eq</B
> and <code class="literal">!=</CODE
> instead of <b class="emphasis.bold">ne</B
>.  The <code class="literal">==</CODE
> and
<code class="literal">!=</CODE
> operators are
<em class="emphasis">numeric</EM
> tests.  The other two are
<em class="emphasis">string</EM
> tests.  The strings
<code class="literal">&quot;123&quot;</CODE
> and <code class="literal">&quot;123.00&quot;</CODE
> are
equal as numbers, but not equal as strings.  Also, any non-numeric
string is numerically equal to zero.  Unless you are dealing with
numbers, you almost always want the string comparison operators
instead.</P
></LI
><li class="listitem"><p class="para"> <a class="indexterm" name="AUTOID-28673"></A
>
Forgetting the trailing semicolon. Every statement in
Perl is terminated by a semicolon or the end of a block.  Newlines
aren't statement terminators as they are in <em class="emphasis">awk</EM
>
or Python.  </P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28678"></A
>Forgetting that a <code class="replaceable"><i>BLOCK</I
></CODE
> requires braces.  Naked
statements are not <code class="replaceable"><i>BLOCK</I
></CODE
>s.  If you are creating a
control structure such as a <b class="emphasis.bold">while</B
> or an
<b class="emphasis.bold">if</B
> that requires one or more
<code class="replaceable"><i>BLOCK</I
></CODE
>s, you <em class="emphasis">must</EM
> use braces
around each <code class="replaceable"><i>BLOCK</I
></CODE
>.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28689"></A
><a class="indexterm" name="AUTOID-28691"></A
><a class="indexterm" name="AUTOID-28693"></A
><a class="indexterm" name="AUTOID-28695"></A
><a class="indexterm" name="AUTOID-28697"></A
>Not saving <b class="emphasis.bold">$1</B
>, <b class="emphasis.bold">$2</B
>, and so on, across regular expressions.
Remember that every new <code class="literal">m/atch/</CODE
> or
<code class="literal">s/ubsti/tute/</CODE
> will set (or clear, or mangle) your
<b class="emphasis.bold">$1</B
>, <b class="emphasis.bold">$2</B
>... variables, as well as <b class="emphasis.bold">$</B
><code class="literal">`</CODE
>, <b class="emphasis.bold">$</B
><code class="literal">'</CODE
>, and
<b class="emphasis.bold">$&amp;</B
>.  One way to save them right
away is to evaluate the match within a list context, as in:</P
><pre class="programlisting">($one,$two) = /(\w+) (\w+)/;</PRE
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28713"></A
>Not realizing that a <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> also changes
the variable's value within other subroutines called within the scope
of the local.  It's easy to forget that <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> is a run-time statement that does dynamic
scoping, because there's no equivalent in languages like C.  See
<a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> in <a class="xref" href="ch03_01.htm" title="Functions">Chapter 3, <cite class="chapter">Functions</CITE
></A
>.
Usually you wanted a <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> anyway.</P
></LI
><li class="listitem"><p class="para">Losing track of brace pairings.
A good text editor will help you find the pairs.  Get one.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28724"></A
><a class="indexterm" name="AUTOID-28726"></A
>Using loop control statements in <code class="literal">do {} while</CODE
>.
Although the braces in this control structure look suspiciously
like part of a loop <code class="replaceable"><i>BLOCK</I
></CODE
>, they aren't.</P
></LI
><li class="listitem"><p class="para">Saying <code class="literal">@foo[1]</CODE
> when you mean <code class="literal">$foo[1]</CODE
>.
The <code class="literal">@foo[1]</CODE
> reference is an array <em class="emphasis">slice</EM
>, and means an
array consisting of the single element <code class="literal">$foo[1]</CODE
>.
Sometimes, this doesn't make any difference, as in:</P
><pre class="programlisting">print &quot;the answer is @foo[1]\n&quot;;</PRE
><p class="para">but it makes a big difference for things like:</P
><pre class="programlisting">@foo[1] = &lt;STDIN&gt;;</PRE
><p class="para">which will slurp up all the rest of <code class="literal">STDIN</CODE
>,
assign the <em class="emphasis">first</EM
> line to
<code class="literal">$foo[1]</CODE
>, and discard everything else. This is probably not what you
intended.  Get into the habit of thinking that <code class="literal">$</CODE
> means a single
value, while <code class="literal">@</CODE
> means a list of values, and you'll do okay.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28748"></A
>Forgetting to select the right filehandle before setting <b class="emphasis.bold">$^</B
>, <b class="emphasis.bold">$~</B
>, or
<b class="emphasis.bold">$|</B
>.  These variables depend on the
currently selected filehandle, as determined by
<code class="literal">select</CODE
>(<code class="replaceable"><i>FILEHANDLE</I
></CODE
>).
The initial filehandle so selected is <code class="literal">STDOUT</CODE
>.  You
should really be using the filehandle methods from the FileHandle
module instead.  See <a class="xref" href="ch07_01.htm" title="The Standard Perl Library">Chapter 7, <cite class="chapter">The Standard Perl Library</CITE
></A
>.</P
></LI
></UL
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-8-SECT-2.2">8.2.2 Frequently Ignored Advice</A
></H3
><p class="para">Practicing Perl Programmers should take note of the following:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Remember that many operations behave differently in a list context
than they do in a scalar one.  <a class="xref" href="ch03_01.htm" title="Functions">Chapter 3</A
> has all the details.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28767"></A
><a class="indexterm" name="AUTOID-28769"></A
>Avoid barewords if you can, especially all lowercase ones.
You can't tell just by looking at it whether a word is 
a function or a bareword string.  By using quotes on strings and 
parentheses around function call arguments, you won't ever get them confused.
In fact, the pragma <code class="literal">use strict</CODE
> at the beginning of your program
makes barewords a compile-time error&nbsp;- probably a good thing.</P
></LI
><li class="listitem"><p class="para">You can't tell just by looking which built-in functions are unary
operators (like <a class="xref" href="ch03_014.htm#PERL2-CMD-CHOP" title="chop"><b class="xref.cmd">chop</B
></A
> and 
<a class="xref" href="ch03_011.htm#PERL2-CMD-CHDIR" title="chdir"><b class="xref.cmd">chdir</B
></A
>), which are list operators 
(like <a class="xref" href="ch03_110.htm#PERL2-CMD-PRINT" title="print"><b class="xref.cmd">print</B
></A
> and <a class="xref" href="ch03_181.htm#PERL2-CMD-UNLINK" title="unlink"><b class="xref.cmd">unlink</B
></A
>),
and which are argumentless (like <a class="xref" href="ch03_173.htm#PERL2-CMD-TIME" title="time"><b class="xref.cmd">time</B
></A
>).
You'll want to learn them from <a class="xref" href="ch02_01.htm" title="The Gory Details">Chapter 2, <cite class="chapter">The Gory Details</CITE
></A
>.  Note also
that user-defined subroutines are by default list operators, but can
be declared as unary operators with a prototype of <code class="literal">($)</CODE
>.</P
></LI
><li class="listitem"><p class="para">People have a hard time remembering that some functions default to
<b class="emphasis.bold">$_</B
>, or <b class="emphasis.bold">@ARGV</B
>, or whatever, while others do not.  Take
the time to learn which are which, or avoid default arguments.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28788"></A
><code class="literal">&lt;</CODE
><code class="replaceable"><i>FH</I
></CODE
><code class="literal">&gt;</CODE
> is not the
name of a filehandle, but an angle operator that does a line-input
operation on the handle.  This confusion usually manifests itself when
people try to <a class="xref" href="ch03_110.htm#PERL2-CMD-PRINT" title="print"><b class="xref.cmd">print</B
></A
> to the angle
operator:</P
><pre class="programlisting">print &lt;FH&gt; &quot;hi&quot;;    # WRONG, omit angles</PRE
><p class="para"></P
></LI
><li class="listitem"><p class="para">Remember also that data read by the angle operator is assigned to
<b class="emphasis.bold">$_</B
> only when the file read is the sole
condition in a <b class="emphasis.bold">while</B
> loop:</P
><pre class="programlisting">while (&lt;FH&gt;)      { }
while ($_ = &lt;FH&gt;) { }..
&lt;FH&gt;;  # data discarded!</PRE
><p class="para"></P
></LI
><li class="listitem"><p class="para">Remember not to use <code class="literal">=</CODE
> when you need <code class="literal">=~</CODE
>;
the two constructs are quite different:</P
><pre class="programlisting">$x =  /foo/;  # searches $_, puts result in $x
$x =~ /foo/;  # searches $x, discards result</PRE
><p class="para"></P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28811"></A
><a class="indexterm" name="AUTOID-28813"></A
><a class="indexterm" name="AUTOID-28816"></A
><a class="indexterm" name="AUTOID-28819"></A
>Use <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> for local variables whenever you can get away with 
it (but see &quot;Formats&quot; in <a class="xref" href="ch02_01.htm" title="The Gory Details">Chapter 2</A
> for where you can't).  
Using <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> actually gives a local value to a global 
variable, which leaves you open to unforeseen side effects
of dynamic scoping.</P
></LI
><li class="listitem"><p class="para">Don't localize a module's exported variables.  If you localize an
exported variable, its exported value will not change.  The local name
becomes an alias to a new value but the external name is still an alias
for the original.</P
></LI
></UL
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-8-SECT-2.3">8.2.3 Awk Traps</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-28829"></A
><a class="indexterm" name="AUTOID-28832"></A
>Accustomed <em class="emphasis">awk</EM
> users should take special note of the following:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28838"></A
>The English module, loaded via</P
><pre class="programlisting">use English;</PRE
><p class="para">allows you to refer to special variables (like <code class="literal">$RS</CODE
>) using 
their <em class="emphasis">awk</EM
> names; see the end of <a class="xref" href="ch02_01.htm" title="The Gory Details">Chapter 2</A
> for details.</P
></LI
><li class="listitem"><p class="para">Semicolons are required after all simple statements in Perl (except
at the end of a block).  Newline is not a statement delimiter.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28849"></A
>Braces are required on <b class="emphasis.bold">if</B
> and <b class="emphasis.bold">while</B
> blocks.</P
></LI
><li class="listitem"><p class="para">Variables begin with <code class="literal">$</CODE
> or <code class="literal">@</CODE
> in Perl.</P
></LI
><li class="listitem"><p class="para">Arrays index from <code class="literal">0</CODE
>, as do string positions in <a class="xref" href="ch03_162.htm#PERL2-CMD-SUBSTR" title="substr"><b class="xref.cmd">substr</B
></A
> and
<a class="xref" href="ch03_075.htm#PERL2-CMD-INDEX" title="index"><b class="xref.cmd">index</B
></A
>.</P
></LI
><li class="listitem"><p class="para">You have to decide whether your array has numeric or string indices.</P
></LI
><li class="listitem"><p class="para">You have to decide whether you want numeric or string comparisons.</P
></LI
><li class="listitem"><p class="para">Hash values do not spring into existence upon reference.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28871"></A
><a class="indexterm" name="AUTOID-28874"></A
><a class="indexterm" name="AUTOID-28877"></A
>Reading an input line does not split it for you.  You get to split it
yourself to an array.  And the <a class="xref" href="ch03_155.htm#PERL2-CMD-SPLIT" title="split"><b class="xref.cmd">split</B
></A
> operator has different
arguments than you might guess.</P
></LI
><li class="listitem"><p class="para">The current input line is normally in <b class="emphasis.bold">$_</B
>, not <b class="emphasis.bold">$0</B
>.  It
generally does not have the newline stripped.  (<b class="emphasis.bold">$0</B
> is the name of the program executed.)  See
<a class="xref" href="ch02_01.htm" title="The Gory Details">Chapter 2</A
>.</P
></LI
><li class="listitem"><p class="para"> 
<b class="emphasis.bold">$1</B
>, <b class="emphasis.bold">$2</B
>, and so on, do not refer to fields&nbsp;- they
refer to substrings matched by the last pattern match.</P
></LI
><li class="listitem"><p class="para"> <a class="indexterm" name="AUTOID-28892"></A
>
The <a class="xref" href="ch03_110.htm#PERL2-CMD-PRINT" title="print"><b class="xref.cmd">print</B
></A
> operator
does not add field and record separators unless you set <b class="emphasis.bold">$,</B
> and <b class="emphasis.bold">$\</B
>.
(<code class="literal">$OFS</CODE
> and <code class="literal">$ORS</CODE
> if you're using
English.)  </P
></LI
><li class="listitem"><p class="para"> 
You must <a class="xref" href="ch03_102.htm#PERL2-CMD-OPEN" title="open"><b class="xref.cmd">open</B
></A
> your
files before you <a class="xref" href="ch03_110.htm#PERL2-CMD-PRINT" title="print"><b class="xref.cmd">print</B
></A
> to them.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-28905"></A
><a class="indexterm" name="AUTOID-28907"></A
>The range operator is <code class="literal">..</CODE
> rather than comma.  The comma operator works (more or less) as in does C.</P
></LI
><li class="listitem"><p class="para"> <a class="indexterm" name="AUTOID-28913"></A
><a class="indexterm" name="AUTOID-28916"></A
><a class="indexterm" name="AUTOID-28918"></A
>
The match binding operator is
<code class="literal">=~</CODE
>, not <code class="literal">~</CODE
>.
(<code class="literal">~</CODE
> is the 1's complement operator, as in C.)</P
></LI
><li class="listitem"><p class="para"> <a class="indexterm" name="AUTOID-28926"></A
><a class="indexterm" name="AUTOID-28929"></A
><a class="indexterm" name="AUTOID-28931"></A
><a class="indexterm" name="AUTOID-28933"></A
><a class="indexterm" name="AUTOID-28935"></A
><a class="indexterm" name="AUTOID-28937"></A
><a class="indexterm" name="AUTOID-28940"></A
>
The exponentiation operator is
<code class="literal">**</CODE
>, not <code class="literal">^</CODE
>.
<code class="literal">^</CODE
> is the bitwise XOR operator, as in C.  (You
know, one could get the feeling that <em class="emphasis">awk</EM
> is
basically incompatible with C.)  </P
></LI
><li class="listitem"><p class="para"> <a class="indexterm" name="AUTOID-28949"></A
><a class="indexterm" name="AUTOID-28951"></A
>
The concatenation operator is dot
(<code class="literal">.</CODE
>), not &quot;nothing&quot;.  (Using &quot;nothing&quot; as an
operator would render <code class="literal">/pat/ /pat/</CODE
> unparsable, since
the third slash would be interpreted as a division operator&nbsp;- the
tokener is in fact slightly context sensitive for operators like
<code class="literal">/</CODE
>, <code class="literal">?</CODE
>, and
<code class="literal">&lt;</CODE
>.  And, in fact, a dot itself can be the
beginning of a number.)  </P
></LI
><li class="listitem"><p class="para">The <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
>, <a class="xref" href="ch03_035.htm#PERL2-CMD-EXIT" title="exit"><b class="xref.cmd">exit</B
></A
>, 
and <b class="emphasis.bold">continue</B
>
keywords work differently.  </P
></LI
><li class="listitem"><p class="para">The following variables work differently:<a class="indexterm" name="AUTOID-28966"></A
></P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><em class="emphasis">awk</EM
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Perl</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">ARGC</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><code class="literal">$#ARGV</CODE
> or scalar <code class="literal">@ARGV</CODE
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">ARGV[0]</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$0</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">FILENAME</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$ARGV</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">FNR</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$.</CODE
> - something</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">FS</CODE
></TD
><td class="entry" rowspan="1" colspan="1">(whatever you like)</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">NF</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$#Fld</CODE
>, or some such</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">NR</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$.</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">OFMT</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$#</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">OFS</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$,</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">ORS</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$\</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">RLENGTH</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">length($&amp;)</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">RS</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$/</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">RSTART</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">length($`)</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">SUBSEP</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$;</CODE
></TD
></TR
></TBODY
></TABLE
></LI
><li class="listitem"><p class="para">You cannot set <code class="literal">$RS</CODE
> to a pattern, only a string.</P
></LI
><li class="listitem"><p class="para">When in doubt, run the <em class="emphasis">awk</EM
> construct through <em class="emphasis">a2p</EM
> and see what it
gives you.</P
></LI
></UL
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-8-SECT-2.4">8.2.4 C Traps</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-29058"></A
><a class="indexterm" name="AUTOID-29060"></A
>Cerebral C programmers should take note of the following:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Curlies are required for <b class="emphasis.bold">if</B
> and <b class="emphasis.bold">while</B
> blocks.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29070"></A
>You must use <b class="emphasis.bold">elsif</B
> rather than &quot;else if&quot; or &quot;elif&quot;.  Syntax like:</P
><pre class="programlisting">if (expression) {
    block;
}
else if (another_expression) {
    another_block;
}</PRE
><p class="para">is illegal.  The <b class="emphasis.bold">else</B
> part is always a
block, and a naked <b class="emphasis.bold">if</B
> is not a block.
You mustn't expect Perl to be exactly the same as C.  What you want
instead is:</P
><pre class="programlisting">if (expression) {
    block;
}
elsif (another_expression) {
    another_block;
}</PRE
><p class="para">Note also that &quot;elif&quot; is &quot;file&quot; spelled backward.  Only
Algol-ers would want a keyword that was the same as another word spelled
backward.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29081"></A
><a class="indexterm" name="AUTOID-29083"></A
>The <code class="literal">break</CODE
> and <code class="literal">continue</CODE
> keywords from C become in 
Perl <a class="xref" href="ch03_081.htm#PERL2-CMD-LAST" title="last"><b class="xref.cmd">last</B
></A
> and <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
>, respectively.
Unlike in C, these do <em class="emphasis">not</EM
> work within a <code class="literal">do { } while</CODE
> construct.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29093"></A
>There's no switch statement.  (But it's easy to build one on the fly; see 
&quot;Bare Blocks and Case Structures&quot; in <a class="xref" href="ch02_01.htm" title="The Gory Details">Chapter 2</A
>.)</P
></LI
><li class="listitem"><p class="para">Variables begin with <code class="literal">$</CODE
>, <code class="literal">@</CODE
>, or <code class="literal">%</CODE
> in Perl.</P
></LI
><li class="listitem"><p class="para"><a class="xref" href="ch03_111.htm#PERL2-CMD-PRINTF" title="printf"><b class="xref.cmd">printf</B
></A
> does not implement the
<code class="literal">*</CODE
> format for interpolating field widths, but it's
trivial to use interpolation of double-quoted strings to achieve the
same effect.  </P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29107"></A
>Comments begin with <code class="literal">#</CODE
>, not <code class="literal">/*</CODE
>.</P
></LI
><li class="listitem"><p class="para">You can't take the address of anything, although a similar operator
in Perl is the backslash, which creates a reference.</P
></LI
><li class="listitem"><p class="para"><code class="literal">ARGV</CODE
> must be capitalized.
<code class="literal">$ARGV[0]</CODE
> is C's <code class="literal">argv[1]</CODE
>, and C's
<code class="literal">argv[0]</CODE
> ends up in <b class="emphasis.bold">$0</B
>.  </P
></LI
><li class="listitem"><p class="para">Functions such as <a class="xref" href="ch03_085.htm#PERL2-CMD-LINK" title="link"><b class="xref.cmd">link</B
></A
>,
<a class="xref" href="ch03_181.htm#PERL2-CMD-UNLINK" title="unlink"><b class="xref.cmd">unlink</B
></A
>, and <a class="xref" href="ch03_122.htm#PERL2-CMD-RENAME" title="rename"><b class="xref.cmd">rename</B
></A
> return true for success, not <code class="literal">0</CODE
>.</P
></LI
><li class="listitem"><p class="para">Signal handlers deal with signal names, not numbers.</P
></LI
></UL
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-8-SECT-2.5">8.2.5 Sed Traps</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-29131"></A
>Seasoned <em class="emphasis">sed</EM
> programmers should take note of the
following:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Backreferences in substitutions use <code class="literal">$</CODE
> rather than <code class="literal">\</CODE
>.</P
></LI
><li class="listitem"><p class="para"> The pattern matching metacharacters
<code class="literal">(</CODE
>, <code class="literal">)</CODE
>, and <code class="literal">|</CODE
>
do not have backslashes in front.  The corresponding literal
characters do.  </P
></LI
><li class="listitem"><p class="para">The range operator in Perl is ... rather
than a comma.  </P
></LI
></UL
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-8-SECT-2.6">8.2.6 Shell Traps</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-29149"></A
><a class="indexterm" name="AUTOID-29151"></A
>Sharp shell programmers should take note of the following:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Variables are prefixed with <code class="literal">$</CODE
> or <code class="literal">@</CODE
> on the left side of
the assignment as well as the right.  A shellish assignment like:</P
><pre class="programlisting">camel='dromedary';      # WRONG</PRE
><p class="para">won't be parsed the way you expect.  You need:</P
><pre class="programlisting">$camel='dromedary';     # ok</PRE
><p class="para"></P
></LI
><li class="listitem"><p class="para">The loop variable of a <b class="emphasis.bold">foreach</B
> also requires a <code class="literal">$</CODE
>.
Although <em class="emphasis">csh</EM
> likes:</P
><pre class="programlisting">foreach hump (one two)
stuff_it $hump
end</PRE
><p class="para">in Perl this is written as:</P
><pre class="programlisting">foreach $hump (&quot;one&quot;, &quot;two&quot;) {
    stuff_it($hump);
}</PRE
><p class="para"></P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29174"></A
>The backtick operator does variable interpretation without regard to
the presence of single quotes in the command.</P
></LI
><li class="listitem"><p class="para">The backtick operator does no translation of the return value.
In Perl, you have to trim the newline explicitly, like this:</P
><pre class="programlisting">chop($thishost = `hostname`);</PRE
><p class="para"></P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29183"></A
>Shells (especially <em class="emphasis">csh</EM
>) do several levels of substitution on each
command line.  Perl does substitution only within certain constructs
such as double quotes, backticks, angle brackets, and search patterns.</P
></LI
><li class="listitem"><p class="para">Shells tend to interpret scripts a little bit at a time.  Perl compiles
the entire program before executing it (except for <code class="literal">BEGIN</CODE
> blocks,
which execute at compile time).</P
></LI
><li class="listitem"><p class="para"> The arguments are available via <b class="emphasis.bold">@ARGV</B
>, not <b class="emphasis.bold">$1</B
>,
<b class="emphasis.bold">$2</B
>, and so on.  </P
></LI
><li class="listitem"><p class="para">The environment is not automatically made available as separate scalar
variables.  But see the Env module.</P
></LI
></UL
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-8-SECT-2.7">8.2.7 Previous Perl Traps</A
></H3
><p class="para"><a class="indexterm" name="CH08.PERLOLD1"></A
><a class="indexterm" name="CH08.PERLOLD2"></A
>Penitent Perl 4 (and Prior) Programmers should take note of the following
changes between Release 4 and Release 5 that might affect old scripts:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29207"></A
><code class="literal">@</CODE
> now always interpolates an array in double-quotish strings.
Some programs may now need to use backslash to protect any <code class="literal">@</CODE
>
that shouldn't interpolate.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29213"></A
>Barewords that used to look like strings to Perl will now look like
subroutine calls if a subroutine by that name is defined before the
compiler sees them.  For example:</P
><pre class="programlisting">sub SeeYa { die &quot;Hasta la vista, baby!&quot; }
$SIG{'QUIT'} = SeeYa;</PRE
><p class="para">In prior versions of Perl, that code would set the signal handler.  Now, it
actually calls the function!  You may use the <b class="emphasis.bold">-w</B
> switch to find such risky usage.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29220"></A
>Symbols starting with &quot;_&quot; are no longer forced into package main, except
for <b class="emphasis.bold">$_</B
> itself (and <b class="emphasis.bold">@_</B
>, and so on).</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29226"></A
>Double-colon is now a valid package separator in an identifier.  Thus,
the statement:</P
><pre class="programlisting">print &quot;$a::$b::$c\n&quot;;</PRE
><p class="para">now parses <code class="literal">$a::</CODE
> as the variable reference, where in
prior versions only the <code class="literal">$a</CODE
> was considered to be the variable
reference.  Similarly,</P
><pre class="programlisting">print &quot;$var::abc::xyz\n&quot;;</PRE
><p class="para">is now interpreted as a single variable <code class="literal">$var::abc::xyz</CODE
>,
whereas in prior versions, the variable <code class="literal">$var</CODE
> would have been
followed by the constant text <code class="literal">::abc::xyz</CODE
>.</P
></LI
><li class="listitem"><p class="para"><code class="literal">s'$lhs'$rhs'</CODE
> now does no interpolation on either side.  It used to
interpolate <code class="literal">$lhs</CODE
> but not <code class="literal">$rhs</CODE
>.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29245"></A
>The second and third arguments of <a class="xref" href="ch03_154.htm#PERL2-CMD-SPLICE" title="splice"><b class="xref.cmd">splice</B
></A
> are
now evaluated in scalar context (as documented) rather than list context.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29250"></A
>These are now semantic errors because of precedence:</P
><pre class="programlisting">shift @list + 20; # now parses like shift(@list + 20), illegal!
$n = keys %map + 20; # now parses like keys(%map + 20), illegal!</PRE
><p class="para">Because if those were to work, then this couldn't:</P
><pre class="programlisting">sleep $dormancy + 20;</PRE
><p class="para"></P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29258"></A
>The precedence of assignment operators is now the same as the precedence
of assignment.  Previous versions of Perl mistakenly gave them the
precedence of the associated operator.  So you now must parenthesize
them in expressions like</P
><pre class="programlisting">/foo/ ? ($a += 2) : ($a -= 2);</PRE
><p class="para">Otherwise:</P
><pre class="programlisting">/foo/ ? $a += 2 : $a -= 2;</PRE
><p class="para">would be erroneously parsed as:</P
><pre class="programlisting">(/foo/ ? $a += 2 : $a) -= 2;</PRE
><p class="para">On the other hand,</P
><pre class="programlisting">$a += /foo/ ? 1 : 2;</PRE
><p class="para">now works as a C programmer would expect.</P
></LI
><li class="listitem"><p class="para"><code class="literal">open FOO || die</CODE
> is now incorrect.  You need parentheses around
the filehandle, because <a class="xref" href="ch03_102.htm#PERL2-CMD-OPEN" title="open"><b class="xref.cmd">open</B
></A
> has the precedence of a list operator.</P
></LI
><li class="listitem"><p class="para">The elements of argument lists for formats are now evaluated in list
context.  This means you can interpolate list values now.</P
></LI
><li class="listitem"><p class="para">You can't do a <a class="xref" href="ch03_071.htm#PERL2-CMD-GOTO" title="goto"><b class="xref.cmd">goto</B
></A
> into a block that is optimized away.  Darn.</P
></LI
><li class="listitem"><p class="para">It is no longer syntactically legal to use whitespace as the name
of a variable, or as a delimiter for any kind of quote construct.
Double darn.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29281"></A
>The <a class="xref" href="ch03_010.htm#PERL2-CMD-CALLER" title="caller"><b class="xref.cmd">caller</B
></A
> function now returns a false value in a scalar context
if there is no caller.  This lets library modules determine whether
they're being required or run directly.</P
></LI
><li class="listitem"><p class="para"><code class="literal">m//g</CODE
> now attaches its state to the searched string rather than
the regular expression.  See &quot;Regular Expressions&quot; in <a class="xref" href="ch02_01.htm" title="The Gory Details">Chapter 2</A
> for
further details.</P
></LI
><li class="listitem"><p class="para"><code class="literal">reverse</CODE
> is no longer allowed as the name of 
a <a class="xref" href="ch03_153.htm#PERL2-CMD-SORT" title="sort"><b class="xref.cmd">sort</B
></A
> subroutine.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29294"></A
><em class="emphasis">taintperl</EM
> is no longer a separate executable.  
There is now a <b class="emphasis.bold">-T</B
>
switch to turn on tainting when it isn't turned on automatically.</P
></LI
><li class="listitem"><p class="para">Double-quoted strings may no longer end with an unescaped <code class="literal">$</CODE
> or
<code class="literal">@</CODE
>.</P
></LI
><li class="listitem"><p class="para">The archaic <b class="emphasis.bold">if</B
> <code class="replaceable"><i>BLOCK BLOCK</I
></CODE
> syntax is no longer supported.</P
></LI
><li class="listitem"><p class="para">Negative array subscripts now count from the end of the array.</P
></LI
><li class="listitem"><p class="para">The comma operator in a scalar context is now guaranteed to give a
scalar context to its arguments.</P
></LI
><li class="listitem"><p class="para">The <code class="literal">**</CODE
> operator now binds more tightly than unary minus.  
It was documented to work this way before, but didn't.</P
></LI
><li class="listitem"><p class="para">Setting <code class="literal">$#array</CODE
> lower now discards array elements immediately.</P
></LI
><li class="listitem"><p class="para"><a class="xref" href="ch03_026.htm#PERL2-CMD-DELETE" title="delete"><b class="xref.cmd">delete</B
></A
> is not guaranteed to return the deleted value for
<a class="xref" href="ch03_171.htm#PERL2-CMD-TIE" title="tie"><b class="xref.cmd">tie</B
></A
>d arrays, since this capability may be onerous for some modules
to implement.</P
></LI
><li class="listitem"><p class="para">The construct <code class="literal">&quot;this is $$x&quot;</CODE
>, which used to interpolate the pid at that
point, now tries to dereference <code class="literal">$x</CODE
>.  <b class="emphasis.bold">$$</B
> by itself still
works fine, however.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-29327"></A
>The meaning of <b class="emphasis.bold">foreach</B
> has changed slightly when it is iterating over a
list which is not an array.  This used to assign the list to a
temporary array, but for efficiency it no longer does so.  This means
that you'll now be iterating over the actual values, not over copies of
the values.  Modifications to the loop variable can change the original
values.  To retain prior Perl semantics you'd need to assign your list
explicitly to a temporary array and then iterate over that.  For
example, you might need to change:</P
><pre class="programlisting">foreach $var (grep /x/, @list) { ... }</PRE
><p class="para">to:</P
><pre class="programlisting">foreach $var (my @tmp = grep /x/, @list) { ... }</PRE
><p class="para">Otherwise changing <code class="literal">$var</CODE
> will clobber the values of
<code class="literal">@list</CODE
>.  (This most often happens when you use <b class="emphasis.bold">$_</B
> for the
loop variable, and call subroutines in the loop that don't properly
localize <b class="emphasis.bold">$_</B
>.)</P
></LI
><li class="listitem"><p class="para">Some error messages will be different.</P
></LI
><li class="listitem"><p class="para">Some bugs may have been inadvertently removed.[<a class="footnote" href="#AUTOID-29342">4</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-29342">[4]</A
> Much to the consternation of Perl poets.</P
></DIV
></BLOCKQUOTE
></LI
></UL
><a class="indexterm" name="AUTOID-29344"></A
><a class="indexterm" name="AUTOID-29345"></A
><a class="indexterm" name="AUTOID-29346"></A
><a class="indexterm" name="AUTOID-29347"></A
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch08_01.htm" title="8.1 The Perl Debugger"><img src="../gifs/txtpreva.gif" alt="Previous: 8.1 The Perl Debugger" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Programming Perl"><img src="../gifs/txthome.gif" alt="Programming Perl" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch08_03.htm#PERL2-CH-8-SECT-3.1" title="8.3 Efficiency"><img src="../gifs/txtnexta.gif" alt="Next: 8.3 Efficiency" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">8.1 The Perl Debugger</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">8.3 Efficiency</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
