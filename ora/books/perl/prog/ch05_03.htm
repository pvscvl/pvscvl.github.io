<html><head>
<title>[Chapter 5] 5.3 Objects</TITLE>
<meta name="DC.title" content="Programming Perl"><meta name="DC.creator" content="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:58:37Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-149-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch05_01.htm" title="5. Packages, Modules, and Object Classes"><link rel="prev" href="ch05_02.htm" title="5.2 Modules"><link rel="next" href="ch05_04.htm#PERL2-CH-5-SECT-4.3" title="5.4 Using Tied Variables"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Programming Perl" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Programming Perl"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_02.htm" title="5.2 Modules"><img src="../gifs/txtpreva.gif" alt="Previous: 5.2 Modules" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch05_01.htm" title="5. Packages, Modules, and Object Classes">Chapter 5<br>Packages, Modules, and Object Classes</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch05_04.htm#PERL2-CH-5-SECT-4.3" title="5.4 Using Tied Variables"><img src="../gifs/txtnexta.gif" alt="Next: 5.4 Using Tied Variables" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PERL2-CH-5-SECT-3">5.3 Objects</A
></H2
><p class="para"><a class="indexterm" name="CH05.OBJ"></A
>First of all, you need to understand packages and modules as previously
described in this chapter.  You also need to know what references and
referenced thingies are in Perl; see <a class="xref" href="ch04_01.htm" title="References and Nested Data Structures">Chapter 4, <cite class="chapter">References and Nested Data Structures</CITE
></A
>, for that.</P
><p class="para">It's also helpful to understand a little about object-oriented
programming (OOP), so in the next section we'll give you a little course
on OOL (object-oriented lingo).</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.1">5.3.1 Brief Refresher on Object-Oriented Programming</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-15532"></A
><a class="indexterm" name="AUTOID-15534"></A
>
An <em class="emphasis">object</EM
> is a data structure with a collection of behaviors.  We generally speak of behaviors as
being performed by the object directly, sometimes to the point of
anthropomorphizing the object.  For example, we might say that a
rectangle &quot;knows&quot;
how to display itself on the screen, or &quot;knows&quot; how to compute its own
area.</P
><p class="para"><a class="indexterm" name="AUTOID-15538"></A
><a class="indexterm" name="AUTOID-15540"></A
><a class="indexterm" name="AUTOID-15542"></A
><a class="indexterm" name="AUTOID-15544"></A
>An object gets its behaviors by being an <em class="emphasis">instance</EM
> of a <em class="emphasis">class</EM
>.
The class defines <em class="emphasis">methods</EM
> that apply to all objects belonging to
that class, called <em class="emphasis">instance methods</EM
>.</P
><p class="para"><a class="indexterm" name="AUTOID-15551"></A
><a class="indexterm" name="AUTOID-15553"></A
><a class="indexterm" name="AUTOID-15555"></A
>The class will also likely include instance-independent methods,
called <em class="emphasis">class methods</EM
>.[<a class="footnote" href="#AUTOID-15558">9</A
>]
Some class methods create
new objects of the classes, and are called <em class="emphasis">constructor methods</EM
>
(such as &quot;create a new rectangle with width 10 and height 5&quot;).  Other
class methods might perform operations on many objects collectively
(&quot;display all rectangles&quot;), or provide other necessary operations
(&quot;read a rectangle from this file&quot;).</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-15558">[9]</A
> Or sometimes <em class="emphasis">static methods</EM
>.</P
></DIV
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-15563"></A
><a class="indexterm" name="AUTOID-15565"></A
><a class="indexterm" name="AUTOID-15567"></A
>A class may be defined so as to <em class="emphasis">inherit</EM
> both class and instance methods
from <em class="emphasis">parent classes</EM
>, also known as <em class="emphasis">base classes</EM
>.  This allows a new
class to be created
that is similar to an existing class, but with added behaviors. Any
method invocation that is not found in a particular class will be
searched for in the parent classes automatically.  For example, a
rectangle class might inherit some common behaviors from a generic
polygon class.</P
><p class="para">While you might know the particular implementation of an object,
generally you should treat the object as a black box.  All access to the
object should be obtained through the published interface via the
provided methods.  This allows the implementation to be revised, as long
as the interface remains frozen (or at least, upward compatible).  By
published interface, we mean the written documentation describing how
to use a particular class.  (Perl does not have an explicit interface
facility apart from this.  You are expected to exercise common sense and
common decency.)</P
><p class="para">Objects of different classes may be held in the same variable at different
times. When a method is invoked on the contents of the variable, the
proper method for the object's class gets selected automatically.  If, for
example, the <code class="literal">draw()</CODE
> method is invoked on a variable that holds
either a rectangle or a circle, the method actually used depends on the
current nature of the object to which the variable refers.  For this to
work, however, the methods for drawing circles and rectangles must both be
called <code class="literal">draw()</CODE
>.</P
><p class="para">Admittedly, there's a lot more to objects than this, and a lot of ways
to find out more.  But that's not our purpose here.  So, on we go.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.2">5.3.2 Perl's Objects</A
></H3
><p class="para">Here are three simple definitions that you may find reassuring:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">An <em class="emphasis">object</EM
> is simply a referenced thingy that happens to know which class it
belongs to.</P
></LI
><li class="listitem"><p class="para">A <em class="emphasis">class</EM
> is simply a package that happens to provide methods to deal
with objects.</P
></LI
><li class="listitem"><p class="para">A <em class="emphasis">method</EM
> is simply a subroutine that expects an object reference (or
a package name, for class methods) as its first argument.</P
></LI
></UL
><p class="para">We'll cover these points in more depth now.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.3">5.3.3 An Object Is Simply a Referenced Thingy</A
></H3
><p class="para"><a class="indexterm" name="CH05.CONST1"></A
><a class="indexterm" name="CH05.CONST2"></A
><a class="indexterm" name="CH05.CONST3"></A
>Perl doesn't provide any special syntax for constructors.  A constructor
is merely a subroutine that returns a reference to a thingy that it has
blessed into a class, generally the class in which the subroutine is
defined.  The constructor does this using the built-in <a class="xref" href="ch03_009.htm#PERL2-CMD-BLESS" title="bless"><b class="xref.cmd">bless</B
></A
> function,
which marks a thingy as belonging to a particular class.  It takes
either one or two arguments: the first argument is a regular hard reference
to any kind of thingy, and the second argument (if present) is the
package that will own the thingy.  If no second argument is supplied,
the current package is assumed.  Here is a typical constructor:</P
><pre class="programlisting">package Critter;
sub new { return bless {}; }</PRE
><p class="para">The <code class="literal">{}</CODE
> composes a reference to an empty anonymous hash.
The <a class="xref" href="ch03_009.htm#PERL2-CMD-BLESS" title="bless"><b class="xref.cmd">bless</B
></A
> function takes that hash reference and tells the thingy
it references that it's now a member of the class Critter, and returns the
reference.
The same thing can be accomplished more explicitly this way:</P
><pre class="programlisting">sub new {
    my     $obref = {};         # ref to empty hash
    bless  $obref;              # make it an object in this class
    return $obref;              # return it
}</PRE
><p class="para">Once a reference has been blessed into a class, you can invoke the class's
instance methods upon it.  For example:</P
><pre class="programlisting">$circle-&gt;draw();</PRE
><p class="para">We'll discuss method invocation in more detail below.</P
><p class="para">Sometimes constructors call other methods in the class as part of the
construction.  Here we'll call an <code class="literal">_initialize()</CODE
> method, which
may be in the current package or in one of the classes (packages) that
this class inherits from.  The leading underscore is an oft-used convention
indicating that the function is private, that is, to be used
only by the class itself.  This result can also be achieved by omitting
the function from the published documentation for that class.</P
><pre class="programlisting">sub new {
    my $self = {}
    bless $self;
    $self-&gt;_initialize();
    return $self;
}</PRE
><p class="para">If you want your constructor method to be (usefully) inheritable, then
you must use the two-argument form of <a class="xref" href="ch03_009.htm#PERL2-CMD-BLESS" title="bless"><b class="xref.cmd">bless</B
></A
>.  That's because, in
Perl, methods execute in the context of the original base class rather
than in the context of the derived class.  For example, suppose you have
a Polygon class that had a <code class="literal">new()</CODE
> method as a constructor.  This
would work fine when called as <code class="literal">Polygon-&gt;new()</CODE
>.  But then you
decide to also have a Square class, which inherits methods from the
Polygon class.  The only way for that constructor to build an object of
the proper class when it is called as <code class="literal">Square-&gt;new()</CODE
> is by using
the two-argument form of <a class="xref" href="ch03_009.htm#PERL2-CMD-BLESS" title="bless"><b class="xref.cmd">bless</B
></A
>, as in the following example:</P
><pre class="programlisting">sub new {
    my $class = shift;
    my $self = {};
    bless $self, $class;        # bless $self into the designated class
    $self-&gt;_initialize();       # in case there's more work to do
    return $self;
}</PRE
><p class="para">Within the class package, methods will typically deal with the reference
as an ordinary (unblessed) reference to a thingy.  Outside the class
package, the reference should generally be treated as an opaque value that
may only be accessed through the class's methods.  (Mutually consenting
classes may of course do whatever they like with each other, but even
that doesn't necessarily make it right.)</P
><p class="para">A constructor may re-bless a referenced object currently belonging to
another class, but then the new class is responsible for all cleanup
later.  The previous blessing is forgotten, as an object may only
belong to one class at a time.  (Although of course it's free to
inherit methods from many classes.)</P
><p class="para">A clarification:  Perl objects are blessed.  References are not.
Thingies know which package they belong to.  References do not.  The
<a class="xref" href="ch03_009.htm#PERL2-CMD-BLESS" title="bless"><b class="xref.cmd">bless</B
></A
> operator simply uses the reference in order to find the
thingy.  Consider the following example:</P
><pre class="programlisting">$a = {};            # generate reference to hash
$b = $a;            # reference assignment (shallow)
bless $b, Mountain;
bless $a, Fourteener;
print &quot;\$b is a &quot;, ref($b), &quot;\n&quot;;</PRE
><p class="para">This reports <code class="literal">$b</CODE
> as being a member of class <code class="literal">Fourteener</CODE
>, not a
member of class <code class="literal">Mountain</CODE
>, because the second blessing operates on the
underlying thingy that <code class="literal">$a</CODE
> refers to, not on the reference itself.
Thus is the first blessing forgotten.</P
><a class="indexterm" name="AUTOID-15630"></A
><a class="indexterm" name="AUTOID-15631"></A
><a class="indexterm" name="AUTOID-15632"></A
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.4">5.3.4 A Class Is Simply a Package</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-15636"></A
>Perl doesn't provide any special syntax for class definitions.  You
just use a package as a class by putting method definitions into the
class.</P
><p class="para"><a class="indexterm" name="AUTOID-15639"></A
>Within each package a special array called <code class="literal">@ISA</CODE
>
tells Perl where else to look for a method if it can't find the method in
that package.  This is how Perl implements inheritance.  Each
element of the <code class="literal">@ISA</CODE
> array is just the name of another package
that happens to be used as a class.  The packages are recursively
searched (depth first) for missing methods, in the order that packages
are mentioned in <code class="literal">@ISA</CODE
>.  This means that if you have two
different packages (say, <code class="literal">Mom</CODE
> and <code class="literal">Dad</CODE
>) in a class's
<code class="literal">@ISA</CODE
>, Perl would first look for missing methods in
<code class="literal">Mom</CODE
> and all of her ancestor classes before going on to search through
<code class="literal">Dad</CODE
> and his ancestors.  Classes accessible through <code class="literal">@ISA</CODE
>
are known as <em class="emphasis">base classes</EM
> of the current class, which is itself called
the <em class="emphasis">derived class</EM
>.[<a class="footnote" href="#AUTOID-15652">10</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-15652">[10]</A
> Instead of &quot;base class&quot; and &quot;derived class&quot;,
some OOP literature uses <em class="emphasis">superclass</EM
> for the
more generic classes and <em class="emphasis">subclass</EM
> for the more specific ones.
Confusing the issue further, some literature uses &quot;base class&quot; to
mean a &quot;most super&quot; superclass.  That's not what we mean by it.</P
></DIV
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-15657"></A
><a class="indexterm" name="AUTOID-15659"></A
>If a missing method is found in one of the base classes, Perl internally
caches that location in the current class for efficiency, so the next time
it has to find the method, it doesn't have to look so far.  Changing
<code class="literal">@ISA</CODE
> or defining new subroutines invalidates this cache and causes
Perl to do the lookup again.</P
><p class="para"><a class="indexterm" name="AUTOID-15663"></A
><a class="indexterm" name="AUTOID-15666"></A
><a class="indexterm" name="AUTOID-15668"></A
>If a method isn't found but an <code class="literal">AUTOLOAD</CODE
> routine is found, then
that routine is called on behalf of the missing method, with
that package's <code class="literal">$AUTOLOAD</CODE
> variable set to the
fully qualified method name.</P
><p class="para"><a class="indexterm" name="AUTOID-15674"></A
>If neither a method nor an <code class="literal">AUTOLOAD</CODE
> routine is found in
<code class="literal">@ISA</CODE
>, then one last, desperate try is made for the method (or an
<code class="literal">AUTOLOAD</CODE
> routine) in the special pre-defined class called
<code class="literal">UNIVERSAL</CODE
>.
This package does not initially contain any definitions (although see CPAN for
some), but you may place your &quot;last-ditch&quot; methods there.  Think of it as a global base
class from which all other classes implicitly derive.</P
><p class="para">If that method still doesn't work, Perl finally gives up and
complains by raising an exception.</P
><p class="para"><a class="indexterm" name="AUTOID-15682"></A
>Perl classes do only method inheritance.  Data inheritance is left
up to the class itself.  By and large, this is not a problem in Perl,
because most classes model the attributes of their object using
an anonymous hash.  All the object's data fields (termed &quot;instance
variables&quot; in some languages) are contained within this anonymous hash instead of
being part of the language itself.  This hash serves as its own little
namespace to be carved up by the various classes that might want to do
something with the object.  For example, if you want an object called
<code class="literal">$user_info</CODE
> to have a data field named <code class="literal">age</CODE
>, you can simply
access <code class="literal">$user_info-&gt;{age}</CODE
>.  No declarations are necessary. See the
section on &quot;Instance Variables&quot; under &quot;Some Hints About Object Design&quot;
later in this chapter.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.5">5.3.5 A Method Is Simply a Subroutine</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-15690"></A
><a class="indexterm" name="AUTOID-15692"></A
>Perl doesn't provide any special syntax for method definition.  (It
does provide a little syntax for method invocation, though.  More on
that later.)  A method expects its first argument to indicate the object or
package it is being invoked on.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-5-SECT-3.5.1">5.3.5.1 Class methods</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15697"></A
>A <em class="emphasis">class method</EM
> expects a class (package) name as its first argument.
(The class name isn't blessed; it's just a string.)  These methods
provide functionality for the class as a whole, not for any individual
object instance belonging to the class.  Constructors are typically
written as class methods.  Many class methods simply ignore their first
argument, since they already know what package they're in, and don't
care what package they were invoked via.  (These aren't necessarily the
same, since class methods follow the inheritance tree just like ordinary
instance methods.)</P
><p class="para">Another typical use for class methods might be to look up an object by
some nickname in a global registry:</P
><pre class="programlisting">sub find {
    my ($class, $nickname) = @_;
    return $objtable{$nickname};
}</PRE
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-5-SECT-3.5.2">5.3.5.2 Instance methods</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15705"></A
>An <em class="emphasis">instance method</EM
> expects an object reference[<a class="footnote" href="#AUTOID-15708">11</A
>]
as its first argument.
Typically it shifts the first argument into a private variable (often
called <code class="literal">$self</CODE
> or <code class="literal">$this</CODE
> depending on the cultural biases of the
programmer), and then it uses the variable as an ordinary reference:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-15708">[11]</A
> By which we mean simply an ordinary hard reference that happens to
point to an object thingy. Remember that the reference itself doesn't
know or care whether its thingy is blessed.</P
></DIV
></BLOCKQUOTE
><pre class="programlisting">sub display {
    my $self = shift;
    my @keys;
    if (@_ == 0) {                  # no further arguments
        @keys = sort keys(%$self);
    }  else {
        @keys = @_;                 # use the ones given
    }
    foreach $key (@keys) {
        print &quot;\t$key =&gt; $self-&gt;{$key}\n&quot;;
    }
}</PRE
><p class="para">Despite being counterintuitive to object-oriented novices, it's a good idea <em class="emphasis">not</EM
> to
check the type of object that caused the instance method to be
invoked.  If you do, it can get in the way of inheritance.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-5-SECT-3.5.3">5.3.5.3 Dual-nature methods</A
></H4
><p class="para">Because there is no language-defined distinction between definitions of
class methods and instance methods (nor arbitrary functions, for that
matter), you could actually have the same method work for both
purposes.  It just has to check whether it was passed a reference or
not.  Suppose you want a constructor that can figure out its class
from either a classname or an existing object.  Here's an example of the
two uses of such a method:</P
><pre class="programlisting">$ob1  = StarKnight-&gt;new();
$luke = $ob1-&gt;new();</PRE
><p class="para">Here's how such a method might be defined.  We use the <a class="xref" href="ch03_121.htm#PERL2-CMD-REF" title="ref"><b class="xref.cmd">ref</B
></A
> function
to find out the type of the object the method was called on so our new
object can be blessed into that class.  If <a class="xref" href="ch03_121.htm#PERL2-CMD-REF" title="ref"><b class="xref.cmd">ref</B
></A
> returns false, then
our <code class="literal">$self</CODE
> argument isn't an object, so it must be a class name.</P
><pre class="programlisting">package StarKnight;
sub new {
    my $self  = shift;
    my $type  = ref($self) || $self;
    return bless {}, $type;
}</PRE
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.6">5.3.6 Method Invocation</A
></H3
><p class="para"><a class="indexterm" name="CH05.METH1"></A
><a class="indexterm" name="CH05.METH2"></A
>Perl supports two different syntactic forms for explicitly invoking class or
instance methods.[<a class="footnote" href="#AUTOID-15733">12</A
>]
Unlike normal function calls, method
calls always receive, as their first parameter, the appropriate class name
or object reference upon which they were invoked.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-15733">[12]</A
> Methods may also be called implicitly due to object destructors,
tied variables, or operator overloading.
Properly speaking, none of these is a function
invocation.  Rather, Perl uses the information presented via the syntax
to determine which function to call.
Operator overloading is implemented by the standard overload
module as described separately in <a class="xref" href="ch07_01.htm" title="The Standard Perl Library">Chapter 7</A
>.</P
></DIV
></BLOCKQUOTE
><p class="para">The first syntax form looks like this:</P
><pre class="programlisting"><code class="replaceable"><i>METHOD</I
></CODE
> <code class="replaceable"><i>CLASS_OR_INSTANCE</I
></CODE
> <code class="replaceable"><i>LIST</I
></CODE
></PRE
><p class="para">Since this is similar to using the filehandle specification with
<a class="xref" href="ch03_110.htm#PERL2-CMD-PRINT" title="print"><b class="xref.cmd">print</B
></A
> or <a class="xref" href="ch03_111.htm#PERL2-CMD-PRINTF" title="printf"><b class="xref.cmd">printf</B
></A
>, 
and also similar to English sentences like &quot;Give<a class="indexterm" name="AUTOID-15744"></A
>
the dog the bone,&quot; we'll call it the <em class="emphasis">indirect object</EM
> form.  To look
up an object with the class method <code class="literal">find</CODE
>, and to print out
some of its attributes with the instance method <code class="literal">display</CODE
>, you could
say this:</P
><pre class="programlisting">$fred = find Critter &quot;Fred&quot;;
display $fred 'Height', 'Weight';</PRE
><p class="para">The indirect object form allows a <code class="replaceable"><i>BLOCK</I
></CODE
> returning an object (or class)
in the indirect object slot, so you can combine these into one
statement:</P
><pre class="programlisting">display { find Critter &quot;Fred&quot; } 'Height', 'Weight';</PRE
><p class="para">The second syntax form looks like this:</P
><pre class="programlisting"><code class="replaceable"><i>CLASS_OR_INSTANCE</I
></CODE
>-&gt;<code class="replaceable"><i>METHOD</I
></CODE
>(<code class="replaceable"><i>LIST</I
></CODE
>)</PRE
><p class="para"><a class="indexterm" name="AUTOID-15759"></A
><a class="indexterm" name="AUTOID-15761"></A
>This second syntax employs the <code class="literal">-&gt;</CODE
> notation. It is sometimes called the <em class="emphasis">object-oriented</EM
> syntax.
The parentheses are required if there are any arguments, because this form can't
be used as a list operator, although the first form can.</P
><pre class="programlisting">$fred = Critter-&gt;find(&quot;Fred&quot;);
$fred-&gt;display('Height', 'Weight');</PRE
><p class="para">Or, you can put the above in only one statement, like this:</P
><pre class="programlisting">Critter-&gt;find(&quot;Fred&quot;)-&gt;display('Height', 'Weight');</PRE
><p class="para">There are times when one syntax is more readable, and times when the
other syntax is more readable.  The indirect object syntax is less
cluttered, but it has the same ambiguity as ordinary list operators.
If there is an open parenthesis following the class or
object, then the matching close parenthesis terminates the list of
arguments.  Thus, the parentheses of</P
><pre class="programlisting">new Critter ('Barney', 1.5, 70);</PRE
><p class="para">are assumed to surround all the arguments of the method call, regardless
of what comes afterward. Therefore, saying</P
><pre class="programlisting">new Critter ('Bam' x 2), 1.4, 45;</PRE
><p class="para">would be equivalent to</P
><pre class="programlisting">Critter-&gt;new('Bam' x 2), 1.4, 45;</PRE
><p class="para">which is unlikely to do what you want since the <code class="literal">1.4</CODE
> and <code class="literal">45</CODE
>
are not being passed to the <code class="literal">new()</CODE
> routine.</P
><p class="para">There may be occasions when you need to specify which class's method to use.
In that case, you <em class="emphasis">could</EM
> call your method as an ordinary subroutine
call, being sure to pass the requisite first argument explicitly:</P
><p class="para"><pre class="programlisting">$fred = MyCritter::find(&quot;Critter&quot;, &quot;Fred&quot;);
MyCritter::display($fred, 'Height', 'Weight');</PRE
></P
><p class="para">However, this does not do any inheritance.  If you merely
want to specify that Perl should start looking for a method in a
particular package, use an ordinary method call, but qualify the method
name with the package like this:</P
><p class="para"><pre class="programlisting">$fred = Critter-&gt;MyCritter::find(&quot;Fred&quot;);
$fred-&gt;MyCritter::display('Height', 'Weight');</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-15787"></A
>If you're trying to control where the method search begins and you're
executing in the class package itself, then you may use the <code class="literal">SUPER</CODE
>
pseudoclass, which says to start looking in your base class's
<code class="literal">@ISA</CODE
> list without having to explicitly name it:</P
><p class="para"><pre class="programlisting">$self-&gt;SUPER::display('Height', 'Weight');</PRE
></P
><p class="para">The <code class="literal">SUPER</CODE
> construct is meaningful only when used <em class="emphasis">inside</EM
> the class methods; while
writers of class modules can employ <code class="literal">SUPER</CODE
> in their own code,
people who merely use class objects cannot.</P
><p class="para">Sometimes you want to call a method when you don't know the method name
ahead of time.  You can use the arrow form, replacing the method name
with a simple scalar variable (not an expression or indexed aggregate) containing the method name:</P
><p class="para"><pre class="programlisting">$method = $fast ? &quot;findfirst&quot; : &quot;findbest&quot;;
$fred-&gt;$method(@args);</PRE
></P
><p class="para">We mentioned that the object-oriented notation is less syntactically
ambiguous than the indirect object notation, even though the latter
is less cluttered.  Here's why:
An indirect object is limited to a name, a scalar variable, or a
<code class="replaceable"><i>BLOCK</I
></CODE
>.[<a class="footnote" href="#AUTOID-15802">13</A
>]
(If you try to put anything more complicated in that slot, it will not
be parsed as you expect.)  The left side of <code class="literal">-&gt;</CODE
> is not so limited.
This means that A and B below are equivalent to each other, and C and D
are also equivalent, but A and B differ from C and D:
&#13;</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-15802">[13]</A
> Attentive readers will recall that this is precisely the same list of
syntactic items that are allowed after a funny character to indicate a
variable dereference&nbsp;- for example, <code class="literal">@ary</CODE
>, <code class="literal">@$aryref</CODE
>, or
<code class="literal">@{$aryref}</CODE
>.</P
></DIV
></BLOCKQUOTE
><p class="para"><pre class="programlisting">A: method $obref-&gt;{fieldname}
B: (method $obref)-&gt;{fieldname}

C: $obref-&gt;{fieldname}-&gt;method()
D: method {$obref-&gt;{fieldname}}</PRE
></P
><p class="para">In A and B, the method applies to <code class="literal">$obref</CODE
>, which must yield a hash
reference with <code class="literal">&quot;fieldname&quot;</CODE
> as a key.  In C and D the method
applies to <code class="literal">$obref-&gt;{fieldname}</CODE
>, which must evaluate to an object
appropriate for the method.</P
><a class="indexterm" name="AUTOID-15814"></A
><a class="indexterm" name="AUTOID-15815"></A
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.7">5.3.7 Destructors</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-15819"></A
>When the last reference to an object goes away, the object is
automatically destroyed.  (This may even be after you exit, if you've
stored references in global variables.)  If you want to capture control
just before the object is freed, you may define a <code class="literal">DESTROY</CODE
> method in
your class.  It will automatically be called at the appropriate moment,
and you can do any extra cleanup you desire.  (Perl does the memory
management cleanup for you automatically.)</P
><p class="para"><a class="indexterm" name="AUTOID-15823"></A
>Perl does not do nested destruction for you.  If your constructor
re-blessed a reference from one of your base classes, your <code class="literal">DESTROY</CODE
>
method may need to call <code class="literal">DESTROY</CODE
> for any base classes that need it.
But this only applies to re-blessed objects; an object reference that is
merely <em class="emphasis">contained</EM
> within the current object&nbsp;- as, for example, one
value in a larger hash&nbsp;- will be freed and
destroyed automatically.  This is one of the reasons why containership
via mere aggregation (sometimes called a &quot;has-a&quot; relationship) is often
cleaner and clearer than inheritance (an &quot;is-a&quot; relationship).  In other
words, often you really only need to store one object inside another
directly instead of employing inheritance, which can add unnecessary
complexity.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.8">5.3.8 Method Autoloading</A
></H3
><p class="para"><a class="indexterm" name="CH05.METH3"></A
><a class="indexterm" name="CH05.METH4"></A
>After Perl has vainly looked through an object's class package and the packages of
its base classes to find a method, it also checks for an <code class="literal">AUTOLOAD</CODE
>
routine in each package before concluding that the method can't be found.
One could use this property to provide an interface to the object's
data fields (instance variables) without writing a separate function
for each.  Consider the following code:</P
><p class="para"><pre class="programlisting">use Person;
$him = new Person;
$him-&gt;name(&quot;Jason&quot;);
$him-&gt;age(23);
$him-&gt;peers( [&quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;] );
printf &quot;%s is %d years old.\n&quot;, $him-&gt;name, $him-&gt;age;
print &quot;His peers are: &quot;, join(&quot;, &quot;, @{$him-&gt;peers}), &quot;.\n&quot;;</PRE
></P
><p class="para">The Person class implements a data structure containing three fields:
<code class="literal">name</CODE
>, <code class="literal">age</CODE
>, and <code class="literal">peers</CODE
>.  Instead of accessing the objects' data fields directly, you use
supplied methods to do so.  To set one of these fields, call a method of
that name with an argument of the value the field should be set to.  To
retrieve one of the fields without setting it, call the method without an
argument.  Here's the code that does that:</P
><p class="para"><pre class="programlisting">package Person;
use Carp;       # see Carp.pm in <a class="xref" href="ch07_01.htm" title="The Standard Perl Library">Chapter 7</A
>

my %fields = (
    name        =&gt; undef,
    age         =&gt; undef,
    peers       =&gt; undef,
);

sub new {
    my $that  = shift;
    my $class = ref($that) || $that;
    my $self  = {
        %fields,
    };
    bless $self, $class;
    return $self;
} 

sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) || croak &quot;$self is not an object&quot;;
    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion
    unless (exists $self-&gt;{$name} ) {
        croak &quot;Can't access `$name' field in object of class $type&quot;;
    } 
    if (@_) {
        return $self-&gt;{$name} = shift;
    } else {
        return $self-&gt;{$name};
    } 
}</PRE
></P
><p class="para">As you see, there isn't really a method named <code class="literal">name()</CODE
>,
<code class="literal">age()</CODE
>, or <code class="literal">peers()</CODE
> to be found anywhere.  The
<code class="literal">AUTOLOAD</CODE
> routine takes care of all of these.  This class is a
fairly generic implementation of something analogous to a C structure.
A more complete implementation of this notion can be found in the
Class::Template module contained on CPAN.  The Alias
module found there may also prove useful for simplifying member access.[<a class="footnote" href="#AUTOID-15852">14</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-15852">[14]</A
> CPAN is the Comprehensive Perl Archive Network, as described in the
Preface.</P
></DIV
></BLOCKQUOTE
><a class="indexterm" name="AUTOID-15854"></A
><a class="indexterm" name="AUTOID-15855"></A
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-5-SECT-3.9">5.3.9 A Note on Garbage Collection</A
></H3
><p class="para"><a class="indexterm" name="CH05.MEM1"></A
><a class="indexterm" name="CH05.MEM2"></A
><a class="indexterm" name="CH05.MEM3"></A
>High-level languages typically allow the programmers to dispense with
worrying about deallocating memory when they're done using it.  This
automatic reclamation process is known as <em class="emphasis">garbage collection</EM
>.
For most purposes, Perl uses a fast and simple, reference-based garbage
collection system.  One serious concern is that unreachable memory
with a non-zero reference count will normally not get freed.
Therefore, saying this is a bad idea:</P
><p class="para"><pre class="programlisting">{               # make $a and $b point to each other
    my($a, $b);
    $a = \$b;
    $b = \$a;
}</PRE
></P
><p class="para">or more simply:</P
><p class="para"><pre class="programlisting">{               # make $a point to itself
    my $a;
    $a = \$a;
}</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-15873"></A
><a class="indexterm" name="AUTOID-15875"></A
>When a block is exited, its <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> variables are normally
freed up.  But their internal reference counts can never go to zero,
because the variables point at each other or themselves.  This is circular
reference.
No one outside the block can reach them, which makes them useless.  But
even though they <em class="emphasis">should</EM
> go away, they can't.  When building recursive
data structures, you'll have to break the self-reference yourself
explicitly if you don't care to cause a memory leak.</P
><p class="para">For example, here's a self-referential node such as one might use in a
sophisticated tree structure:</P
><p class="para"><pre class="programlisting">sub new_node {
    my $self = shift;
    my $class = ref($self) || $self;
    my $node = {};
    $node-&gt;{LEFT} = $node-&gt;{RIGHT} = $node;
    $node-&gt;{DATA} = [ @_ ];
    return bless $node, $class;
}</PRE
></P
><p class="para">If you create nodes like this, they (currently)[<a class="footnote" href="#AUTOID-15884">15</A
>]
won't ever go away unless you break the circular references yourself.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-15884">[15]</A
> In other words, this behavior is not to be construed as a feature, and
you shouldn't depend on it.  Someday, Perl may have a full
mark-and-sweep style garbage collection as in Lisp or Scheme.  If that
happens, it will properly clean up memory lost to unreachable circular
data.</P
></DIV
></BLOCKQUOTE
><p class="para">Well, almost never.</P
><p class="para"><a class="indexterm" name="AUTOID-15888"></A
>When an interpreter thread finally shuts down (usually when your program
exits), then a complete pass of garbage
collection is performed, and everything allocated by that thread gets
destroyed.  This is essential to support Perl as an embedded or a
multithreadable language.  When a thread shuts down, all its objects
must be properly destructed, and all its memory has to be reclaimed.
The following program demonstrates Perl's multi-phased garbage collection:</P
><p class="para"><pre class="programlisting">#!/usr/bin/perl
package Subtle;

sub new {
    my $test;
    $test = \$test;   # Create a self-reference.
    warn &quot;CREATING &quot; . \$test;
    return bless \$test;
}

sub DESTROY {
    my $self = shift;
    warn &quot;DESTROYING $self&quot;;
}

package main;

warn &quot;starting program&quot;;
{
    my $a = Subtle-&gt;new;
    my $b = Subtle-&gt;new;
    $$a = 0;           # Break this self-reference, but not the other.
    warn &quot;leaving block&quot;;
}

warn &quot;just exited block&quot;;
warn &quot;time to die...&quot;;
exit;</PRE
></P
><p class="para">When run as <em class="emphasis">/tmp/try</EM
>, the following output is produced:</P
><p class="para"><pre class="programlisting">starting program at /tmp/try line 18.
CREATING SCALAR(0x8e5b8) at /tmp/try line 7.
CREATING SCALAR(0x8e57c) at /tmp/try line 7.
leaving block at /tmp/try line 23.
DESTROYING Subtle=SCALAR(0x8e5b8) at /tmp/try line 13.
just exited block at /tmp/try line 26.
time to die... at /tmp/try line 27.
DESTROYING Subtle=SCALAR(0x8e57c) during global destruction.</PRE
></P
><p class="para">Notice that &quot;global destruction&quot; in the last line?  That's the thread
garbage collector reaching the unreachable.</P
><p class="para">Objects are always destructed even when regular references aren't, and in fact
are destructed in a separate pass before ordinary references.  This is an
attempt to prevent object destructors from using references that have
themselves been destructed.  Plain references are (currently) only garbage
collected if the &quot;destruct level&quot; is greater than 0, which is usually only
true when Perl is invoked as an embedded interpreter.  You can test the
higher levels of global destruction in the regular Perl executable by
setting the <code class="literal">PERL_DESTRUCT_LEVEL</CODE
> environment variable (presuming the
<code class="literal">-DDEBUGGING</CODE
> option was enabled at Perl build time).<a class="indexterm" name="AUTOID-15900"></A
><a class="indexterm" name="AUTOID-15902"></A
></P
><a class="indexterm" name="AUTOID-15905"></A
><a class="indexterm" name="AUTOID-15906"></A
><a class="indexterm" name="AUTOID-15907"></A
><a class="indexterm" name="AUTOID-15908"></A
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_02.htm" title="5.2 Modules"><img src="../gifs/txtpreva.gif" alt="Previous: 5.2 Modules" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Programming Perl"><img src="../gifs/txthome.gif" alt="Programming Perl" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch05_04.htm#PERL2-CH-5-SECT-4.3" title="5.4 Using Tied Variables"><img src="../gifs/txtnexta.gif" alt="Next: 5.4 Using Tied Variables" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">5.2 Modules</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">5.4 Using Tied Variables</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
