<html><head>
<title>[Chapter 1] 1.5 Operators</TITLE>
<meta name="DC.title" content="Programming Perl"><meta name="DC.creator" content="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:29:20Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-149-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch01_01.htm" title="1. An Overview of Perl"><link rel="prev" href="ch01_04.htm" title="1.4 Filehandles"><link rel="next" href="ch01_06.htm#PERL2-CH-1-SECT-6.2.4" title="1.6 Control Structures"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Programming Perl" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Programming Perl"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch01_04.htm" title="1.4 Filehandles"><img src="../gifs/txtpreva.gif" alt="Previous: 1.4 Filehandles" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch01_01.htm" title="1. An Overview of Perl">Chapter 1<br>An Overview of Perl</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch01_06.htm#PERL2-CH-1-SECT-6.2.4" title="1.6 Control Structures"><img src="../gifs/txtnexta.gif" alt="Next: 1.6 Control Structures" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PERL2-CH-1-SECT-5">1.5 Operators</A
></H2
><p class="para"><a class="indexterm" name="CH01.OP"></A
>As we alluded to earlier, Perl is also a mathematical language.  This is
true at several levels, from low-level bitwise logical operations, up
through number and set manipulation, on up to larger predicates and
abstractions of various sorts.  And as we all know from studying math in
school, mathematicians love strange symbols.  What's worse, computer
scientists have come up with their own versions of these strange
symbols.  Perl has a number of these strange symbols too, but take
heart, most are borrowed directly from C, FORTRAN, <em class="emphasis">sed</EM
>(1) or
<em class="emphasis">awk</EM
>(1), so
they'll at least be familiar to users of those languages.</P
><p class="para">Perl's built-in operators may be classified by number of operands into
unary, binary, and trinary operators.  They may be classified by whether
they're infix operators or prefix operators.  They may also be
classified by the kinds of objects they work with, such as numbers,
strings, or files.  Later, we'll give you a table of all the operators,
but here are some to get you started.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-1-SECT-5.1">1.5.1 Arithmetic Operators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-846"></A
><a class="indexterm" name="AUTOID-848"></A
>Arithmetic operators do exactly what you would expect from learning them
in school.  They perform some sort of mathematical function on numbers.</P
><br><table class="table" border="1" cellpadding="3"><caption class="table"><a class="title" name="PERL2-CH-1-TAB-2">Table 1.2: Some Binary Arithmetic Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Example</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Name</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Result</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$a + $b</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Addition</TD
><td class="entry" rowspan="1" colspan="1">Sum of <code class="literal">$a</CODE
> and <code class="literal">$b</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$a * $b</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Multiplication</TD
><td class="entry" rowspan="1" colspan="1">Product of <code class="literal">$a</CODE
> and <code class="literal">$b</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$a % $b</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Modulus</TD
><td class="entry" rowspan="1" colspan="1">Remainder of <code class="literal">$a</CODE
> divided by <code class="literal">$b</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$a ** $b</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Exponentiation</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">$a</CODE
> to the power of <code class="literal">$b</CODE
></TD
></TR
></TBODY
></TABLE
><p class="para">Yes, we left subtraction and division out of <a class="xref" href="#PERL2-CH-1-TAB-2" title="Some Binary Arithmetic Operators">Table 1.2</A
>.  But we suspect
you can figure out how they should work.  Try them and see if you're
right.  (Or cheat and look in the index.)  Arithmetic operators are
evaluated in the order your math teacher taught you (exponentiation before multiplication, and multiplication before
addition).  You can always use parentheses to make it come out differently.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-1-SECT-5.2">1.5.2 String Operators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-893"></A
><a class="indexterm" name="AUTOID-896"></A
><a class="indexterm" name="AUTOID-898"></A
><a class="indexterm" name="AUTOID-901"></A
>There is also an &quot;addition&quot; operator for strings that does concatenation.
Unlike some languages that confuse this with numeric addition, Perl defines a
separate operator (<code class="literal">.</CODE
>) for string concatenation:</P
><p class="para"><pre class="programlisting">$a = 123;
$b = 456;
print $a + $b;     # prints 579
print $a . $b;     # prints 123456</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-908"></A
><a class="indexterm" name="AUTOID-910"></A
><a class="indexterm" name="AUTOID-913"></A
><a class="indexterm" name="AUTOID-915"></A
>There's also a &quot;multiply&quot; operation for strings, also called the <em class="emphasis">repeat</EM
>
operator.  Again, it's a separate operator (<b class="emphasis.bold">x</B
>) to keep it distinct
from numeric multiplication:</P
><p class="para"><pre class="programlisting">$a = 123;
$b = 3;
print $a * $b;     # prints 369
print $a x $b;     # prints 123123123</PRE
></P
><p class="para">These string operators bind as tightly as their corresponding
arithmetic operators.  The repeat operator is a bit unusual in taking a
string for its left argument but a number for its right argument.  Note
also how Perl is automatically converting from numbers to strings. You could have put all the literal numbers above in quotes, and it
would still have produced the same output.  Internally though, it would
have been converting in the opposite direction (that is, from strings to
numbers).</P
><p class="para">A couple more things to think about.  String concatenation is
also implied by the interpolation that happens in double-quoted strings.
When you print out a list of values, you're also effectively concatenating
strings.  So the following three statements produce the same output:</P
><p class="para"><pre class="programlisting">print $a . ' is equal to ' . $b . &quot;\n&quot;;    # dot operator
print $a, ' is equal to ', $b, &quot;\n&quot;;       # list
print &quot;$a is equal to $b\n&quot;;               # interpolation</PRE
></P
><p class="para">Which of these you use in any particular situation is entirely up to you.</P
><p class="para">The <b class="emphasis.bold">x</B
> operator may seem relatively
worthless at first glance, but it is quite useful at times, especially
for things like this:</P
><p class="para"><pre class="programlisting">print &quot;-&quot; x $scrwid, &quot;\n&quot;;</PRE
></P
><p class="para">which draws a line across your screen, presuming your screen width
is in <code class="literal">$scrwid</CODE
>.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-1-SECT-5.3">1.5.3 Assignment Operators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-935"></A
><a class="indexterm" name="AUTOID-937"></A
>Although it's not exactly a mathematical operator, we've already made
extensive use of the simple assignment operator, <code class="literal">=</CODE
>.  Try to remember
that <code class="literal">=</CODE
> means &quot;gets set to&quot; rather than &quot;equals&quot;.  (There is also a
mathematical equality operator <code class="literal">==</CODE
> that means &quot;equals&quot;, and if you
start out thinking about the difference between them now, you'll save
yourself a lot of headache later.)</P
><p class="para">Like the operators above, assignment operators are binary infix
operators, which means they have an operand on either side of the
operator.  The right operand can be any expression you like, but the
left operand must be a valid <em class="emphasis">lvalue</EM
> (which, when translated to
English, means a valid storage location like a variable, or a location
in an array).  The most common assignment operator is simple assignment.
It determines the value of the expression on its right side, and sets
the variable on the left side to that value:</P
><p class="para"><pre class="programlisting">$a = $b;
$a = $b + 5;
$a = $a * 3;</PRE
></P
><p class="para">Notice the last assignment refers to the same variable twice; once
for the computation, once for the assignment.  There's nothing wrong with that, but it's a common enough operation that there's a
shortcut for it (borrowed from C).  If you say:</P
><pre class="programlisting">lvalue operator= expression</PRE
><p class="para">it is evaluated as if it were:</P
><pre class="programlisting">lvalue = lvalue operator expression</PRE
><p class="para">except that the lvalue is not computed twice.  (This only makes a
difference if evaluation of the lvalue has side effects.  But when it
<em class="emphasis">does</EM
> make a difference, it usually does what you want.  So don't sweat it.)</P
><p class="para">So, for example, you could write the above as:</P
><p class="para"><pre class="programlisting">$a *= 3;</PRE
></P
><p class="para">which reads &quot;multiply <code class="literal">$a</CODE
> by 3&quot;.  You can do this with almost any
binary operator in Perl, even some that you can't do it with in C:</P
><p class="para"><pre class="programlisting">$line .= &quot;\n&quot;;  # Append newline to $line.
$fill x= 80;    # Make string $fill into 80 repeats of itself.
$val ||= &quot;2&quot;;   # Set $val to 2 if it isn't already set.</PRE
></P
><p class="para">Line 6 of our grade example contains two string concatenations, one
of which is an assignment operator.  And line 14 contains a <code class="literal">+=</CODE
>.</P
><p class="para">Regardless of which kind of assignment operator you use, the final value
is returned as the value of the assignment as a whole.  (This is unlike,
say, Pascal, in which assignment is a statement and has no value.)
This is why we could say:</P
><p class="para"><pre class="programlisting">chop($number = &lt;STDIN&gt;);</PRE
></P
><p class="para">and have it chop the final value of <code class="literal">$number</CODE
>.  You also frequently see
assignment as the condition of a <b class="emphasis.bold">while</B
> loop, as in line 4 of our grade
example.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-1-SECT-5.4">1.5.4 Autoincrement and Autodecrement Operators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-971"></A
><a class="indexterm" name="AUTOID-973"></A
><a class="indexterm" name="AUTOID-975"></A
><a class="indexterm" name="AUTOID-978"></A
><a class="indexterm" name="AUTOID-981"></A
>As if <code class="literal">$variable += 1</CODE
> weren't short enough, Perl borrows from C
an even shorter way to increment a variable.  The autoincrement and
autodecrement operators simply add (or subtract) one from the value of the
variable.  They can be placed on either side of the variable, depending on
when you want them to be evaluated (see <a class="xref" href="#PERL2-CH-1-TAB-3" title="Unary Arithmetic Operators">Table 1.3</A
>).</P
><br><table class="table" border="1" cellpadding="3"><caption class="table"><a class="title" name="PERL2-CH-1-TAB-3">Table 1.3: Unary Arithmetic Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Example</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Name</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Result</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">++$a, $a++</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Autoincrement</TD
><td class="entry" rowspan="1" colspan="1">Add 1 to <code class="literal">$a</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">--$a, $a--</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Autodecrement</TD
><td class="entry" rowspan="1" colspan="1">Subtract 1 from <code class="literal">$a</CODE
></TD
></TR
></TBODY
></TABLE
><p class="para">If you place one of the auto operators before the variable, it is known as
a pre-incremented (pre-decremented) variable.  Its value will be changed
before it is referenced.  If it is placed 
after the variable, it is known
as a post-incremented (post-decremented) variable and its value is changed
after it is used.  For example:</P
><p class="para"><pre class="programlisting">$a = 5;        # $a is assigned 5
$b = ++$a;     # $b is assigned the incremented value of $a, 6
$c = $a--;     # $c is assigned 6, then $a is decremented to 5</PRE
></P
><p class="para">Line 15 of our grade example increments the number of scores by one, so
that we'll know how many scores we're averaging the grade over.  It uses
a post-increment operator (<code class="literal">$scores++</CODE
>), but in this case it doesn't
matter, since the expression is in a void context, which is just a funny
way of saying that the expression is being evaluated only for the side
effect of incrementing the variable.  The value returned is being thrown
away.[<a class="footnote" href="#AUTOID-1012">21</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-1012">[21]</A
> The optimizer will notice this and optimize the
post-increment into a pre-increment, because that's a little more
efficient to execute.  (You didn't need to know that, but we
hoped it would cheer you up.)</P
></DIV
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-1-SECT-5.5">1.5.5 Logical Operators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-1017"></A
><a class="indexterm" name="AUTOID-1020"></A
>Logical operators, also known as &quot;short-circuit&quot; operators, allow the
program to make decisions based on multiple criteria, without using
nested conditionals.  They are known as short-circuit because they skip
evaluating their right argument if evaluating their left argument is
sufficient to determine the overall value.</P
><p class="para">Perl actually has two sets of logical operators, a crufty old set
borrowed from C, and a nifty new set of ultralow-precedence operators
that parse more like people expect them to parse, and are also easier to
read.  (Once they're parsed, they behave identically though.) See
<a class="xref" href="#PERL2-CH-1-TAB-4" title="Logical Operators">Table 1.4</A
> for examples of logical operators.</P
><br><table class="table" border="1" cellpadding="3"><caption class="table"><a class="title" name="PERL2-CH-1-TAB-4">Table 1.4: Logical Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Example</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Name</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Result</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$a &amp;&amp; $b</CODE
></TD
><td class="entry" rowspan="1" colspan="1">And</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><code class="literal">$a</CODE
> if <code class="literal">$a</CODE
> is false, 
<code class="literal">$b</CODE
> otherwise</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$a || $b</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Or</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><code class="literal">$a</CODE
> if <code class="literal">$a</CODE
> 
is true, <code class="literal">$b</CODE
> otherwise</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">! $a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Not</TD
><td class="entry" rowspan="1" colspan="1">True if <code class="literal">$a</CODE
> is not true</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$a and $b</CODE
></TD
><td class="entry" rowspan="1" colspan="1">And</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><code class="literal">$a</CODE
> if <code class="literal">$a</CODE
> is false,
<code class="literal">$b</CODE
> otherwise</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">$a or $b</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Or</TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><code class="literal">$a</CODE
> if <code class="literal">$a</CODE
> 
is true, <code class="literal">$b</CODE
> otherwise</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">not $a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Not</TD
><td class="entry" rowspan="1" colspan="1">True if <code class="literal">$a</CODE
> is not true</TD
></TR
></TBODY
></TABLE
><p class="para">Since the logical operators &quot;short circuit&quot; the way they do, they're
often used to conditionally execute code.  The following line (from our
grade example) tries to open the file <em class="emphasis">grades</EM
>.</P
><pre class="programlisting">open(GRADES, &quot;grades&quot;) or die &quot;Can't open file grades: $!\n&quot;;</PRE
><p class="para">If it opens the file,
it will jump to the next line of the program.  If it can't open the
file, it will provide us with an error message and then stop execution.</P
><p class="para">Literally, the above message means &quot;Open <em class="emphasis">grades</EM
> or die!&quot;  Besides being another example of
natural language, the short-circuit operators preserve the visual flow.
Important actions are listed down the left side of the screen, and
secondary actions are hidden off to the right.  (The <b class="emphasis.bold">$!</B
> variable
contains the error message returned by the operating system&nbsp;- see
&quot;Special Variables&quot; in <a class="xref" href="ch02_01.htm" title="The Gory Details">Chapter 2</A
>).
Of course, these logical operators can also be used within the more
traditional kinds of conditional constructs, such as the <b class="emphasis.bold">if</B
> and <b class="emphasis.bold">while</B
>
statements.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-1-SECT-5.6">1.5.6 Comparison Operators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-1095"></A
><a class="indexterm" name="AUTOID-1097"></A
><a class="indexterm" name="AUTOID-1100"></A
><a class="indexterm" name="AUTOID-1103"></A
>Comparison, or relational, operators tell us how two scalar values
(numbers or strings) relate to each other.  There are two sets of
operators&nbsp;- one does numeric comparison and the other
does string comparison.  (In either case, the arguments will be &quot;coerced&quot;
to have the appropriate type first.)  <a class="xref" href="#PERL2-CH-1-TAB-5" title="Some Numeric and String Comparison Operators">Table 1.5</A
> assumes <code class="literal">$a</CODE
>
and <code class="literal">$b</CODE
> are the left and right arguments, respectively.</P
><br><table class="table" border="1" cellpadding="3"><caption class="table"><a class="title" name="PERL2-CH-1-TAB-5">Table 1.5: Some Numeric and String Comparison Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Comparison</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Numeric</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">String</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Return Value</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">Equal</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">==</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">eq</CODE
></TD
><td class="entry" rowspan="1" colspan="1">True if <code class="literal">$a</CODE
> is equal to <code class="literal">$b</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">Not equal</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">!=</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">ne</CODE
></TD
><td class="entry" rowspan="1" colspan="1">True if <code class="literal">$a</CODE
> is not equal to <code class="literal">$b</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">Less than</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">&lt;</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">lt</CODE
></TD
><td class="entry" rowspan="1" colspan="1">True if <code class="literal">$a</CODE
> is less than <code class="literal">$b</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">Greater than</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">&gt;</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">gt</CODE
></TD
><td class="entry" rowspan="1" colspan="1">True if <code class="literal">$a</CODE
> is greater than <code class="literal">$b</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">Less than or equal</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">&lt;=</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">le</CODE
></TD
><td class="entry" rowspan="1" colspan="1">True if <code class="literal">$a</CODE
> not greater than <code class="literal">$b</CODE
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">Comparison</TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">&lt;=&gt;</CODE
></TD
><td class="entry" rowspan="1" colspan="1"><code class="literal">cmp</CODE
></TD
><td class="entry" rowspan="1" colspan="1">0 if equal, 1 if <code class="literal">$a</CODE
> greater, -1 if <code class="literal">$b</CODE
> greater</TD
></TR
></TBODY
></TABLE
><p class="para">The last pair of operators (<code class="literal">&lt;=&gt;</CODE
> and <code class="literal">cmp</CODE
>)
are entirely redundant. However,
they're incredibly useful in <a class="xref" href="ch03_153.htm#PERL2-CMD-SORT" title="sort"><b class="xref.cmd">sort</B
></A
>
subroutines (see <a class="xref" href="ch03_01.htm" title="Functions">Chapter 3</A
>).[<a class="footnote" href="#AUTOID-1178">22</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-1178">[22]</A
> Some folks feel that such redundancy is evil because it keeps a language
from being minimalistic, or orthogonal.  But Perl isn't an orthogonal
language; it's a diagonal language.  By which we mean that Perl doesn't
force you to always go at right angles.  Sometimes you just want
to follow the hypotenuse of the triangle to get where you're going.
TMTOWTDI is about shortcuts.  Shortcuts are about efficiency.</P
></DIV
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-1-SECT-5.7">1.5.7 File Test Operators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-1183"></A
>The file test operators allow you to test whether certain file attributes are
set before you go and blindly muck about with the files.  For example, it
would be very nice to know that the file <em class="emphasis">/etc/passwd</EM
> already exists
before you go and open it as a new file, wiping out everything that was in
there before. See <a class="xref" href="#PERL2-CH-1-TAB-6" title="Some File Test Operators">Table 1.6</A
> for examples of file test operators.</P
><br><table class="table" border="1" cellpadding="3"><caption class="table"><a class="title" name="PERL2-CH-1-TAB-6">Table 1.6: Some File Test Operators</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Example</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Name</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Result</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">-e $a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Exists</TD
><td class="entry" rowspan="1" colspan="1">True if file named in <code class="literal">$a</CODE
> exists</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">-r $a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Readable</TD
><td class="entry" rowspan="1" colspan="1">True if file named in <code class="literal">$a</CODE
> is readable</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">-w $a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Writable</TD
><td class="entry" rowspan="1" colspan="1">True if file named in <code class="literal">$a</CODE
> is writable</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">-d $a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Directory</TD
><td class="entry" rowspan="1" colspan="1">True if file named in <code class="literal">$a</CODE
> is a directory</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">-f $a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">File</TD
><td class="entry" rowspan="1" colspan="1">True if file named in <code class="literal">$a</CODE
> is a regular file</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><code class="literal">-T $a</CODE
></TD
><td class="entry" rowspan="1" colspan="1">Text File</TD
><td class="entry" rowspan="1" colspan="1">True if file named in <code class="literal">$a</CODE
> is a text file</TD
></TR
></TBODY
></TABLE
><p class="para">Here are some examples:</P
><p class="para"><pre class="programlisting">-e &quot;/usr/bin/perl&quot; or warn &quot;Perl is improperly installed\n&quot;;
-f &quot;/vmunix&quot; and print &quot;Congrats, we seem to be running BSD Unix\n&quot;;</PRE
></P
><p class="para">Note that a regular file is not the same thing as a text file.  Binary
files like <em class="emphasis">/vmunix</EM
> are regular files, but they aren't text files.
Text files are the opposite of binary files, while regular files are the
opposite of irregular files like directories and devices.</P
><p class="para"><a class="indexterm" name="AUTOID-1239"></A
>There are a lot of file test operators, many of which we didn't list.
Most of the file tests are unary Boolean operators: they take only one
operand, a scalar that evaluates to a file or a filehandle, and they
return either a true or false value.  A few of them return something fancier,
like the file's size or age, but you can look those up when you need them.<a class="indexterm" name="AUTOID-1242"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch01_04.htm" title="1.4 Filehandles"><img src="../gifs/txtpreva.gif" alt="Previous: 1.4 Filehandles" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Programming Perl"><img src="../gifs/txthome.gif" alt="Programming Perl" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch01_06.htm#PERL2-CH-1-SECT-6.2.4" title="1.6 Control Structures"><img src="../gifs/txtnexta.gif" alt="Next: 1.6 Control Structures" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">1.4 Filehandles</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">1.6 Control Structures</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
