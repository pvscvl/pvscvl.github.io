<html><head>
<title>[Chapter 2] 2.6 Statements and Declarations</TITLE>
<meta name="DC.title" content="Programming Perl"><meta name="DC.creator" content="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:41:53Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-149-6" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch02_01.htm" title="2. The Gory Details"><link rel="prev" href="ch02_05.htm#PERL2-CH-2-SECT-5.10" title="2.5 Operators"><link rel="next" href="ch02_07.htm#PERL2-CH-2-SECT-7.3" title="2.7 Subroutines"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Programming Perl" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Programming Perl"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch02_05.htm#PERL2-CH-2-SECT-5.10" title="2.5 Operators"><img src="../gifs/txtpreva.gif" alt="Previous: 2.5 Operators" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch02_01.htm" title="2. The Gory Details">Chapter 2<br>The Gory Details</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch02_07.htm#PERL2-CH-2-SECT-7.3" title="2.7 Subroutines"><img src="../gifs/txtnexta.gif" alt="Next: 2.7 Subroutines" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PERL2-CH-2-SECT-6">2.6 Statements and Declarations</A
></H2
><p class="para"><a class="indexterm" name="CH02.SD"></A
><a class="indexterm" name="CH02.DS"></A
>A Perl program consists of a sequence of declarations and statements.
A declaration may be placed anywhere a statement may be placed, but it
has its primary (or only) effect at compile time. (Some declarations do double
duty as ordinary statements, while others are totally transparent at run-time.)
After compilation,
the main sequence of statements is executed just once, unlike in <em class="emphasis">sed</EM
> and
<em class="emphasis">awk</EM
> scripts, where the sequence of statements is executed for each
input line.  While this means that you must explicitly loop over the lines
of your input file (or files), it also means you have much more control
over which files and which lines you look at.[<a class="footnote" href="#AUTOID-6042">36</A
>]
Unlike many high-level languages, Perl requires only subroutines and
report formats to be explicitly declared.  All other user-created
objects spring into existence with a null or 0 value unless they are
defined by some explicit operation such as assignment.[<a class="footnote" href="#AUTOID-6048">37</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6042">[36]</A
> Actually, I'm lying&nbsp;- it is possible to do an implicit loop with
either the <b class="emphasis.bold">-n</B
> or <b class="emphasis.bold">-p</B
> command-line switch.  It's just not the
mandatory default like it is in <em class="emphasis">sed</EM
> and
<em class="emphasis">awk</EM
>.</P
></DIV
><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6048">[37]</A
> The <b class="emphasis.bold">-w</B
> command-line switch will warn
you about using undefined values.  </P
></DIV
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-6052"></A
><a class="indexterm" name="AUTOID-6055"></A
>You <em class="emphasis">may</EM
> declare your variables though, if you like.  You may even
make it an error to use an undeclared variable.  This kind of discipline
is fine, but you have to declare that you want the discipline.  (This
seems appropriate, somehow.)  See <code class="literal">use strict</CODE
> in the section on
&quot;Pragmas&quot; later in this chapter.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.1">2.6.1 Simple Statements</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-6063"></A
>A simple statement is an expression evaluated for its side effects.  Every
simple statement must end in a semicolon, unless it is the final statement in a
block.  In this case, the semicolon is optional (but strongly encouraged in
any multiline block, since you may eventually add another line).  </P
><p class="para">Even though some operators (like <code class="literal">eval {}</CODE
> and 
<code class="literal">do {}</CODE
>) look like compound
statements, they aren't. True, they allow multiple statements on the
inside, but that doesn't count. From the outside those statements are
just terms in an
expression, and thus need an explicit semicolon if used as the last item
in a statement.<a class="indexterm" name="AUTOID-6068"></A
></P
><p class="para">Any simple statement may optionally be followed by a single modifier, just
before the terminating semicolon (or block ending).  The possible modifiers
are:<a class="indexterm" name="AUTOID-6071"></A
></P
><p class="para"><pre class="programlisting">if <code class="replaceable"><i>EXPR</I
></CODE
>
unless <code class="replaceable"><i>EXPR</I
></CODE
>
while <code class="replaceable"><i>EXPR</I
></CODE
>
until <code class="replaceable"><i>EXPR</I
></CODE
></PRE
></P
><p class="para">The <b class="emphasis.bold">if</B
> and <b class="emphasis.bold">unless</B
> modifiers work pretty much as you'd expect if
you speak English:</P
><p class="para"><pre class="programlisting">$trash-&gt;take('out') if $you_love_me;
shutup() unless $you_want_me_to_leave;</PRE
></P
><p class="para">The <b class="emphasis.bold">while</B
> and <b class="emphasis.bold">until</B
> modifiers evaluate repeatedly as long as
the modifier is true:</P
><p class="para"><pre class="programlisting">$expression++ while -e &quot;$file$expression&quot;;
kiss('me') until $I_die;</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-6090"></A
>The <b class="emphasis.bold">while</B
> and <b class="emphasis.bold">until</B
> modifiers also have the usual while-loop
semantics (conditional evaluated first), except when applied to a
<code class="literal">do {}</CODE
> (or to the now-deprecated <code class="literal">do-SUBROUTINE</CODE
> statement), in
which case the block executes once before the conditional is evaluated.
This is so that you can write loops like:</P
><p class="para"><pre class="programlisting">do {
    $line = &lt;STDIN&gt;;
    ...
} until $line eq &quot;.\n&quot;;</PRE
></P
><p class="para">See the <a class="xref" href="ch03_028.htm#PERL2-CMD-DO" title="do"><b class="xref.cmd">do</B
></A
> entry in <a class="xref" href="ch03_01.htm" title="Functions">Chapter 3</A
>.  Note also that the loop-control
statements described later will not work in this construct, since 
modifiers don't take loop labels.  Sorry.  You can always wrap
another block around it to do that sort of thing.  Or write a real
loop with multiple loop-control commands inside.  Speaking of
real loops, we'll talk about compound statements next.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.2">2.6.2 Compound Statements</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-6104"></A
><a class="indexterm" name="AUTOID-6106"></A
>A sequence of statements that defines a scope is called a <em class="emphasis">block</EM
>.
Sometimes a block is delimited by the file containing it (in the
case of either a &quot;<a class="xref" href="ch03_123.htm#PERL2-CMD-REQUIRE" title="require"><b class="xref.cmd">require</B
></A
>d&quot; file, or the program as a whole), and
sometimes it's delimited by the extent of a string (in the case of an <a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
>).  But
generally, a block is delimited by braces (<code class="literal">{}</CODE
>).  When we mean a
block with braces, we'll use the term <code class="replaceable"><i>BLOCK</I
></CODE
>.<a class="indexterm" name="AUTOID-6114"></A
><a class="indexterm" name="AUTOID-6116"></A
></P
><p class="para">Compound statements are built out of expressions and <code class="replaceable"><i>BLOCK</I
></CODE
>s.
The expressions
are built out of the terms and operators we've already discussed.  In our
syntax diagrams, we'll use the word <code class="replaceable"><i>EXPR</I
></CODE
> to indicate a place where
you can
use an expression.</P
><p class="para">The following conditionals and loops may be used to control flow:</P
><p class="para"><pre class="programlisting">if (<code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
>
if (<code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
> else <code class="replaceable"><i>BLOCK</I
></CODE
>
if (<code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
> elsif (<code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
> ...
if (<code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
> elsif (<code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
> ... else <code class="replaceable"><i>BLOCK</I
></CODE
>

<code class="replaceable"><i>LABEL</I
></CODE
> while (<code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
>
<code class="replaceable"><i>LABEL</I
></CODE
> while (<code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
> continue <code class="replaceable"><i>BLOCK</I
></CODE
>

<code class="replaceable"><i>LABEL</I
></CODE
> for (<code class="replaceable"><i>EXPR</I
></CODE
>; <code class="replaceable"><i>EXPR</I
></CODE
>; <code class="replaceable"><i>EXPR</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
>

<code class="replaceable"><i>LABEL</I
></CODE
> foreach <code class="replaceable"><i>VAR</I
></CODE
> (<code class="replaceable"><i>LIST</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
>
<code class="replaceable"><i>LABEL</I
></CODE
> foreach <code class="replaceable"><i>VAR</I
></CODE
> (<code class="replaceable"><i>LIST</I
></CODE
>) <code class="replaceable"><i>BLOCK</I
></CODE
> continue <code class="replaceable"><i>BLOCK</I
></CODE
>

<code class="replaceable"><i>LABEL</I
></CODE
> <code class="replaceable"><i>BLOCK</I
></CODE
>
<code class="replaceable"><i>LABEL</I
></CODE
> <code class="replaceable"><i>BLOCK</I
></CODE
> continue <code class="replaceable"><i>BLOCK</I
></CODE
></PRE
></P
><p class="para">Note that unlike in C and Pascal, these are defined in terms of
<code class="replaceable"><i>BLOCK</I
></CODE
>s, not statements.  This means that
the braces are required&nbsp;- no dangling statements allowed.  If you want to write
conditionals without braces there are several other ways to do it.  The
following all do the same thing:</P
><p class="para"><pre class="programlisting">if (!open(FOO, $foo)) { die &quot;Can't open $foo: $!&quot;; }
 
die &quot;Can't open $foo: $!&quot; unless open(FOO, $foo);

open(FOO, $foo) or die &quot;Can't open $foo: $!&quot;;     # FOO or bust!

open(FOO, $foo) ? 'hi mom' : die &quot;Can't open $foo: $!&quot;;
                    # a bit exotic, that last one</PRE
></P
><p class="para">Your readers would tend to prefer the third of those under most
circumstances.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.3">2.6.3 If Statements</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-6173"></A
><a class="indexterm" name="AUTOID-6177"></A
><a class="indexterm" name="AUTOID-6180"></A
>The <b class="emphasis.bold">if</B
> statement is straightforward.  Since <code class="replaceable"><i>BLOCK</I
></CODE
>s
are always bounded
by braces, there is never any ambiguity about which <b class="emphasis.bold">if</B
> an <b class="emphasis.bold">else</B
> or
an <b class="emphasis.bold">elsif</B
> goes with.  In any particular sequence of
<b class="emphasis.bold">if</B
>/<b class="emphasis.bold">elsif</B
>/<b class="emphasis.bold">else</B
> <code class="replaceable"><i>BLOCK</I
></CODE
>s,
only the first one that has a true
condition will be executed.  If none of them is true, then the
<b class="emphasis.bold">else</B
> <code class="replaceable"><i>BLOCK</I
></CODE
>, if there is any, is executed.</P
><p class="para">If you use <b class="emphasis.bold">unless</B
> in place of <b class="emphasis.bold">if</B
>, the sense of the test is
reversed.  That is:</P
><p class="para"><pre class="programlisting">unless ($OS_ERROR) ...</PRE
></P
><p class="para">is equivalent to:[<a class="footnote" href="#AUTOID-6199">38</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6199">[38]</A
> <code class="literal">$OS_ERROR</CODE
> is the same as <b class="emphasis.bold">$!</B
> if you <code class="literal">use English</CODE
>.</P
></DIV
></BLOCKQUOTE
><p class="para"><pre class="programlisting">if (not $OS_ERROR) ...</PRE
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.4">2.6.4 Loop Statements</A
></H3
><p class="para"><a class="indexterm" name="CH02.LOOPS"></A
><a class="indexterm" name="AUTOID-6211"></A
>All compound loop statements have an optional <code class="replaceable"><i>LABEL</I
></CODE
>.  If present, the
label consists of an identifier followed by a colon.  It's customary to
make the label upper case to avoid potential conflict with reserved
words, and so it stands out better.  (But don't use <code class="literal">BEGIN</CODE
>
or <code class="literal">END</CODE
>!)</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-2-SECT-6.4.1">2.6.4.1 While statements</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-6220"></A
>The <b class="emphasis.bold">while</B
> statement repeatedly executes the block as long as the
<code class="replaceable"><i>EXPR</I
></CODE
>
is true.  If the word <b class="emphasis.bold">while</B
> is replaced by the word <b class="emphasis.bold">until</B
>, the
sense of the test is reversed.  The conditional is still tested before
the first iteration, though.</P
><p class="para"><a class="indexterm" name="AUTOID-6227"></A
>The <b class="emphasis.bold">while</B
> statement has an optional extra block on the end called a
<b class="emphasis.bold">continue</B
> block.  This is a block that is executed every time the
block is continued, either by falling off the end of the first block, or
by an explicit loop-control command that goes to the next iteration.
The <b class="emphasis.bold">continue</B
> block is not heavily used in practice, but it's in there
so we can define the <b class="emphasis.bold">for</B
> loop rigorously.  So let's do that.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-2-SECT-6.4.2">2.6.4.2 For loops</A
></H4
><p class="para"><a class="indexterm" name="CH02.FOR"></A
>The C-style <b class="emphasis.bold">for</B
> loop has three semicolon-separated expressions within
its parentheses.  These three expressions function respectively as the
initialization, the condition, and the re-initialization expressions of
the loop.  (All three expressions are optional, and the condition, if
omitted, is assumed to be true.)  The <b class="emphasis.bold">for</B
> loop can be defined in terms
of the corresponding <b class="emphasis.bold">while</B
> loop.  </P
><p class="para">Thus, the following:</P
><p class="para"><pre class="programlisting">for ($i = 1; $i &lt; 10; $i++) {
    ...
}</PRE
></P
><p class="para">is the same as:</P
><p class="para"><pre class="programlisting">$i = 1;
while ($i &lt; 10) {
    ...
}
continue {
    $i++;
}</PRE
></P
><p class="para">(Defining the <b class="emphasis.bold">for</B
> loop in terms of a <b class="emphasis.bold">continue</B
> block allows us to
preserve the correct semantics even when the loop is continued via a
<a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
> statement.  This is unlike C, in which there is no way to write
the exact equivalent of a continued <b class="emphasis.bold">for</B
> loop without chicanery.)</P
><p class="para">If you want to iterate through two variables simultaneously, just separate
the parallel expressions with commas:</P
><p class="para"><pre class="programlisting">for ($i = 0, $bit = 1; $mask &amp; $bit; $i++, $bit &lt;&lt;= 1) {
    print &quot;Bit $i is set\n&quot;;
}</PRE
></P
><p class="para">Besides the normal array index looping, <b class="emphasis.bold">for</B
> can lend itself to many
other interesting applications.  There doesn't even have to be an
explicit loop variable.  Here's one example that avoids the problem you
get into if you explicitly test for end-of-file on an interactive file
descriptor, causing your program to appear to hang.</P
><p class="para"><pre class="programlisting">$on_a_tty = -t STDIN &amp;&amp; -t STDOUT;
sub prompt { print &quot;yes? &quot; if $on_a_tty }
for ( prompt(); &lt;STDIN&gt;; prompt() ) {
    # do something
}</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-6260"></A
><a class="indexterm" name="AUTOID-6262"></A
>One final application for the <b class="emphasis.bold">for</B
> loop results from the fact that
all three expressions are optional.  If you do leave all
three expressions out, you have written an &quot;infinite&quot; loop in a
way that is customary in the culture of both Perl and C:</P
><p class="para"><pre class="programlisting">for (;;) {
    ...
}</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-6269"></A
><a class="indexterm" name="AUTOID-6272"></A
><a class="indexterm" name="AUTOID-6275"></A
><a class="indexterm" name="AUTOID-6278"></A
><a class="indexterm" name="AUTOID-6281"></A
>If the notion of infinite loops bothers you, we should point out that
you can always terminate such a loop from the inside with an appropriate
loop-control command.  Of course, if you're writing the code to
control a cruise missile, you may not actually need to write a loop exit.
The loop will be terminated automatically at the appropriate moment.[<a class="footnote" href="#AUTOID-6284">39</A
>]<a class="indexterm" name="AUTOID-6286"></A
></P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6284">[39]</A
> That is, the fallout from the loop tends to occur automatically.</P
></DIV
></BLOCKQUOTE
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-2-SECT-6.4.3">2.6.4.3 Foreach loops</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-6290"></A
><a class="indexterm" name="AUTOID-6292"></A
>The <b class="emphasis.bold">foreach</B
> loop iterates over a list value and sets the
control variable (<code class="replaceable"><i>VAR</I
></CODE
>) to be each element of the list in turn:</P
><p class="para"><pre class="programlisting">foreach <code class="replaceable"><i>VAR</I
></CODE
> (<code class="replaceable"><i>LIST</I
></CODE
>) {
    ...
}</PRE
></P
><p class="para">The variable is implicitly local to the loop and regains its former value
upon exiting the loop.  If the variable was previously declared with
<a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
>, that variable instead of the global one is used, but it's still
localized to the loop.</P
><p class="para"><a class="indexterm" name="AUTOID-6304"></A
>The <b class="emphasis.bold">foreach</B
> keyword is actually a synonym for the <b class="emphasis.bold">for</B
> keyword, so
you can use <b class="emphasis.bold">foreach</B
> for readability or <b class="emphasis.bold">for</B
> for brevity.  If
<code class="replaceable"><i>VAR</I
></CODE
> is
omitted, <b class="emphasis.bold">$_</B
> is used.  If <code class="replaceable"><i>LIST</I
></CODE
> is an actual array (as opposed to an
expression returning a list value), you can modify each element of the
array by modifying <code class="replaceable"><i>VAR</I
></CODE
> inside the loop.  That's because the <b class="emphasis.bold">foreach</B
>
loop index variable is an implicit alias for each item in the list that
you're looping over.  Our first two examples modify an array in place:</P
><p class="para"><pre class="programlisting">for (@ary) { s/ham/turkey/ }                # substitution

foreach $elem (@elements) {                 # multiply by 2
    $elem *= 2;
}

for $count (10,9,8,7,6,5,4,3,2,1,'BOOM') {  # do a countdown
    print $count, &quot;\n&quot;; sleep(1);
}

for $count (reverse 'BOOM', 1..10) {        # same thing
    print $count, &quot;\n&quot;; sleep(1);
}

for $item (split /:[\\\n:]*/, $TERMCAP) {   # any <code class="replaceable"><i>LIST</I
></CODE
> expression
    print &quot;Item: $item\n&quot;;
}

foreach $key (sort keys %hash) {            # sorting keys
    print &quot;$key =&gt; $hash{$key}\n&quot;;
}</PRE
></P
><p class="para">That last one is the canonical way to print out the values of a hash
in sorted order.</P
><p class="para">Note that there is no way with <b class="emphasis.bold">foreach</B
> to tell where you are in a
list.  You can compare adjacent elements by remembering the previous one in
a variable, but sometimes you just have to break down and write an ordinary
<b class="emphasis.bold">for</B
> loop with subscripts.  That's what <b class="emphasis.bold">for</B
> is there for, after
all.</P
><p class="para">Here's how a C programmer might code up a particular algorithm in Perl:</P
><p class="para"><pre class="programlisting">for ($i = 0; $i &lt; @ary1; $i++) {
    for ($j = 0; $j &lt; @ary2; $j++) {
        if ($ary1[$i] &gt; $ary2[$j]) {
            last; # can't go to outer :-(
        }
        $ary1[$i] += $ary2[$j];
    }
    # this is where that last takes me
}</PRE
></P
><p class="para">Whereas here's how a Perl programmer more comfortable with list processing
might do it:</P
><p class="para"><pre class="programlisting">WID: foreach $this (@ary1) { 
    JET: foreach $that (@ary2) {
        next WID if $this &gt; $that;
        $this += $that;
    } 
}</PRE
></P
><p class="para">See how much easier this is?  It's cleaner, safer, and faster.  It's
cleaner because it's less noisy.  It's safer because if code gets added
between the inner and outer loops later on, the new code won't be
accidentally executed: <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
> explicitly iterates the other loop
rather than merely terminating the inner one.  And it's faster because
Perl executes a <b class="emphasis.bold">foreach</B
> statement more rapidly than it would the
equivalent <b class="emphasis.bold">for</B
> loop because the elements are accessed
directly instead of through subscripting.</P
><p class="para">Like the <b class="emphasis.bold">while</B
> statement, the <b class="emphasis.bold">foreach</B
> statement can also 
take a <b class="emphasis.bold">continue</B
> block.</P
><p class="para">We keep dropping hints about <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
>, but now we're going to explain it.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PERL2-CH-2-SECT-6.4.4">2.6.4.4 Loop control</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-6344"></A
><a class="indexterm" name="CH02.LAB1"></A
><a class="indexterm" name="CH02.LAB2"></A
>We mentioned that you can put a <code class="replaceable"><i>LABEL</I
></CODE
> on a loop to give it a name.  The
loop's <code class="replaceable"><i>LABEL</I
></CODE
>
identifies the loop for the loop-control commands <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
>,
<a class="xref" href="ch03_081.htm#PERL2-CMD-LAST" title="last"><b class="xref.cmd">last</B
></A
>, and <a class="xref" href="ch03_120.htm#PERL2-CMD-REDO" title="redo"><b class="xref.cmd">redo</B
></A
>.  The <code class="replaceable"><i>LABEL</I
></CODE
> names the loop as a whole, not just the
top of the loop.  Hence, a loop-control command referring to the loop
doesn't actually &quot;go to&quot; the loop label itself.  As far as the computer
is concerned, the label could just as easily have been placed at the end
of the loop.  But people like things labeled at the top, for some
reason.</P
><p class="para">Loops are typically named for the item the loop is processing on each
iteration.  This interacts nicely with the loop-control commands, which
are designed to read like English when used with an appropriate label
and a statement modifier.  The archetypical loop processes lines, 
so the
archetypical loop label is <code class="literal">LINE:</CODE
>, and the archetypical loop-control
command is something like this:</P
><p class="para"><pre class="programlisting">next LINE if /^#/;      # discard comments</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-6364"></A
>The syntax for the loop-control commands is:</P
><p class="para"><pre class="programlisting">last <code class="replaceable"><i>LABEL</I
></CODE
>
next <code class="replaceable"><i>LABEL</I
></CODE
>
redo <code class="replaceable"><i>LABEL</I
></CODE
></PRE
></P
><p class="para">The <code class="replaceable"><i>LABEL</I
></CODE
> is optional, and if omitted,
the loop-control command refers to the innermost enclosing loop.  If you
want to break out more than one level, though, you must use a <code class="replaceable"><i>LABEL</I
></CODE
>.
You may have as many loop-control commands in a loop as you like.[<a class="footnote" href="#AUTOID-6375">40</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6375">[40]</A
> In the early days of structured programming, some people insisted that
loops and subroutines have only one entry and one exit.  The one-entry
notion is still a good idea, but the one-exit notion has led people to
write a lot of unnatural code.  Much of programming consists of
traversing decision trees.  A decision tree naturally starts with a
single trunk but ends with many leaves.  Write your code with the number
of loop exits (and function returns) that is natural to the problem you're
trying to solve.  If you've declared your local variables with
reasonable scopes, things will automatically get cleaned up at the
appropriate moment, whichever way you leave the block.</P
></DIV
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-6378"></A
><a class="indexterm" name="AUTOID-6380"></A
><a class="indexterm" name="AUTOID-6383"></A
><a class="indexterm" name="AUTOID-6385"></A
>The <a class="xref" href="ch03_081.htm#PERL2-CMD-LAST" title="last"><b class="xref.cmd">last</B
></A
> command is like the <code class="literal">break</CODE
> statement in C (as used in
loops); it immediately exits the loop in question.  The <b class="emphasis.bold">continue</B
>
block, if any, is not executed.  The following example bombs out of
the loop on the first blank line:</P
><p class="para"><pre class="programlisting">LINE: while (&lt;STDIN&gt;) {
    last LINE if /^$/;      # exit when done with header
    ...
}</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-6394"></A
><a class="indexterm" name="AUTOID-6396"></A
><a class="indexterm" name="AUTOID-6400"></A
>The <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
> command is like the <code class="literal">continue</CODE
> statement in C; it skips
the rest of the current iteration and starts the next iteration of the
loop.  If there is a <b class="emphasis.bold">continue</B
> <code class="replaceable"><i>BLOCK</I
></CODE
>
on the loop, it is always executed
just before the conditional is about to be evaluated again, just like the
third part of a C-style <b class="emphasis.bold">for</B
> loop.  Thus it can be used to increment a
loop variable, even when a particular iteration of the loop has been
interrupted by a <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
>:</P
><p class="para"><pre class="programlisting">LINE: while (&lt;STDIN&gt;) {
    next LINE if /^#/;      # skip comments
    next LINE if /^$/;      # skip blank lines
    ...
} continue {
    $count++;
}</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-6412"></A
>The <a class="xref" href="ch03_120.htm#PERL2-CMD-REDO" title="redo"><b class="xref.cmd">redo</B
></A
> command restarts the loop block without evaluating the
conditional again.  The <b class="emphasis.bold">continue</B
> block,
if any, is not executed.
This command is normally used by programs that want to lie to themselves
about what was just input.</P
><p class="para"><a class="indexterm" name="AUTOID-6417"></A
>Suppose you are processing a file like <em class="emphasis">/etc/termcap</EM
>. If
your input line ends with a backslash to indicate continuation, skip ahead
and get the next record.</P
><p class="para"><pre class="programlisting">while (&lt;&gt;) {
    chomp;
    if (s/\\$//) { 
        $_ .= &lt;&gt;; 
        redo;
    }
    # now process $_
}</PRE
></P
><p class="para">which is Perl shorthand for the more explicitly written version:</P
><p class="para"><pre class="programlisting">LINE: while ($line = &lt;ARGV&gt;) {
    chomp($line);
    if ($line =~ s/\\$//) { 
        $line .= &lt;ARGV&gt;; 
        redo LINE;
    }
    # now process $line
}</PRE
></P
><p class="para">One more point about loop-control commands.  You may have noticed that
we are not calling them &quot;statements&quot;.  That's because they aren't
statements, though they can be used for statements.  (This is unlike C,
where <code class="literal">break</CODE
> and <code class="literal">continue</CODE
> are allowed <em class="emphasis">only</EM
> as statements.)
You can almost think of them as unary operators that just happen to
cause a change in control flow.  So you can use them anywhere it makes
sense to use them in an expression.  In fact, you can even use them
where it doesn't make sense.  One sometimes sees this coding error:</P
><p class="para"><pre class="programlisting">open FILE, $file
     or warn &quot;Can't open $file: $!\n&quot;, next FILE;   # WRONG</PRE
></P
><p class="para">The intent is fine, but the <code class="literal">next FILE</CODE
> is being parsed as one of the
arguments to <a class="xref" href="ch03_192.htm#PERL2-CMD-WARN" title="warn"><b class="xref.cmd">warn</B
></A
>, which is a list operator.  So the <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
> executes
before the <a class="xref" href="ch03_192.htm#PERL2-CMD-WARN" title="warn"><b class="xref.cmd">warn</B
></A
> gets a chance to emit the warning.  In this case,
it's easily fixed by turning the <a class="xref" href="ch03_192.htm#PERL2-CMD-WARN" title="warn"><b class="xref.cmd">warn</B
></A
> list operator into the <a class="xref" href="ch03_192.htm#PERL2-CMD-WARN" title="warn"><b class="xref.cmd">warn</B
></A
>
function call with some suitably situated parentheses:</P
><p class="para"><pre class="programlisting">open FILE, $file
     or warn(&quot;Can't open $file: $!\n&quot;), next FILE;   # okay</PRE
><a class="indexterm" name="AUTOID-6440"></A
><a class="indexterm" name="AUTOID-6441"></A
></P
><a class="indexterm" name="AUTOID-6442"></A
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.5">2.6.5 Bare Blocks and Case Structures</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-6446"></A
><a class="indexterm" name="CH02.BLOCK1"></A
><a class="indexterm" name="CH02.BLOCK2"></A
>A <code class="replaceable"><i>BLOCK</I
></CODE
> by itself (labeled or not) is semantically equivalent to a
loop that executes once.  Thus you can use <a class="xref" href="ch03_081.htm#PERL2-CMD-LAST" title="last"><b class="xref.cmd">last</B
></A
> to leave the block or
<a class="xref" href="ch03_120.htm#PERL2-CMD-REDO" title="redo"><b class="xref.cmd">redo</B
></A
> to restart the block.[<a class="footnote" href="#AUTOID-6456">41</A
>]
Note that this is not true of the blocks in <code class="literal">eval {}</CODE
>, <code class="literal">sub
{}</CODE
>, or <code class="literal">do {}</CODE
> commands, which are not loop blocks and cannot be
labeled.  They can't be labeled because they're just terms in an
expression.  Loop control commands may only be used on true loops, just
as the <a class="xref" href="ch03_125.htm#PERL2-CMD-RETURN" title="return"><b class="xref.cmd">return</B
></A
> command may only be used within a subroutine or
<a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
>.  But you can always introduce an extra set of braces to give
yourself a bare block, which counts as a loop.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6456">[41]</A
> For reasons that may (or may not) become clear upon reflection, a
<a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
> also exits the once-through block.  There is a slight difference, however, in
that a <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
> will execute a <b class="emphasis.bold">continue</B
> block, while a <a class="xref" href="ch03_081.htm#PERL2-CMD-LAST" title="last"><b class="xref.cmd">last</B
></A
> won't.</P
></DIV
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-6468"></A
><a class="indexterm" name="AUTOID-6471"></A
>The bare block is particularly nice for doing case structures
(multiway switches).</P
><p class="para"><pre class="programlisting">SWITCH: {
    if (/^abc/) { $abc = 1; last SWITCH; }
    if (/^def/) { $def = 1; last SWITCH; }
    if (/^xyz/) { $xyz = 1; last SWITCH; }
    $nothing = 1;
}</PRE
></P
><p class="para">There is no official switch statement in Perl, because there are already
several ways to write the equivalent.  In addition to the above, you could
write: [<a class="footnote" href="#AUTOID-6476">42</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6476">[42]</A
> This code is actually not as strange as it looks once you realize that
you can use loop-control operators within an expression.  That's just
the normal scalar (C-style) comma operator between the assignment and
the <a class="xref" href="ch03_081.htm#PERL2-CMD-LAST" title="last"><b class="xref.cmd">last</B
></A
>.  It evaluates the assignment for its side-effect, and
then exits the loop in question, which happens to be a bare block named
<code class="literal">SWITCH</CODE
>.</P
></DIV
></BLOCKQUOTE
><p class="para"><pre class="programlisting">SWITCH: {
    $abc = 1, last SWITCH  if /^abc/;
    $def = 1, last SWITCH  if /^def/;
    $xyz = 1, last SWITCH  if /^xyz/;
    $nothing = 1;
}</PRE
></P
><p class="para">or:</P
><p class="para"><pre class="programlisting">SWITCH: {
    /^abc/ &amp;&amp; do { $abc = 1; last SWITCH; };
    /^def/ &amp;&amp; do { $def = 1; last SWITCH; };
    /^xyz/ &amp;&amp; do { $xyz = 1; last SWITCH; };
    $nothing = 1;
}</PRE
></P
><p class="para">or, formatted so it stands out more as a &quot;proper&quot; switch statement:</P
><p class="para"><pre class="programlisting">SWITCH: {
    /^abc/      &amp;&amp; do { 
                        $abc = 1; 
                        last SWITCH; 
                   };
    /^def/      &amp;&amp; do { 
                        $def = 1; 
                        last SWITCH; 
                   };
    /^xyz/      &amp;&amp; do { 
                        $xyz = 1; 
                        last SWITCH; 
                    };
    $nothing = 1;
}</PRE
></P
><p class="para">or:</P
><p class="para"><pre class="programlisting">SWITCH: {
    /^abc/      and $abc = 1, last SWITCH;
    /^def/      and $def = 1, last SWITCH;
    /^xyz/      and $xyz = 1, last SWITCH;
    $nothing = 1;
}</PRE
></P
><p class="para">or even, horrors:</P
><p class="para"><pre class="programlisting">if    (/^abc/) { $abc = 1 }
elsif (/^def/) { $def = 1 }
elsif (/^xyz/) { $xyz = 1 }
else           { $nothing = 1 }</PRE
></P
><p class="para">You might think it odd to write a loop over a single value, but a common
idiom for a switch statement is to use <b class="emphasis.bold">foreach</B
>'s aliasing capability
to make a temporary assignment to <b class="emphasis.bold">$_</B
> for convenient matching:</P
><p class="para"><pre class="programlisting">for ($some_ridiculously_long_variable_name) {
    /In Card Names/     and do { push @flags, '-e'; last; };
    /Anywhere/          and do { push @flags, '-h'; last; };
    /In Rulings/        and do {                    last; };
    die &quot;unknown value for form variable where: `$where'&quot;;
}</PRE
></P
><p class="para">Notice how the <a class="xref" href="ch03_081.htm#PERL2-CMD-LAST" title="last"><b class="xref.cmd">last</B
></A
> commands in that example ignore the
<code class="literal">do {}</CODE
> blocks, which aren't loops, and exit the main loop instead.<a class="indexterm" name="AUTOID-6502"></A
><a class="indexterm" name="AUTOID-6503"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.6">2.6.6 Goto</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-6507"></A
><a class="indexterm" name="AUTOID-6509"></A
>Although not for the faint of heart (or the pure of heart, for that
matter), Perl does support a <a class="xref" href="ch03_071.htm#PERL2-CMD-GOTO" title="goto"><b class="xref.cmd">goto</B
></A
> command.  There are three forms:
<code class="literal">goto</CODE
> <code class="replaceable"><i>LABEL</I
></CODE
>, <code class="literal">goto</CODE
> <code class="replaceable"><i>EXPR</I
></CODE
>, and <code class="literal">goto</CODE
> <code class="literal">&amp;</CODE
><code class="replaceable"><i>NAME</I
></CODE
>.</P
><p class="para">The <code class="literal">goto</CODE
> <code class="replaceable"><i>LABEL</I
></CODE
> form finds the statement labeled with
<code class="replaceable"><i>LABEL</I
></CODE
> and
resumes execution there.  It may not be used to go inside any construct
that requires initialization, such as a subroutine or a <b class="emphasis.bold">foreach</B
>
loop.  It also can't be used to go into a construct that is optimized
away.  It can be used to go almost anywhere else within the current block
or one you were called from, including out of subroutines, but it's
usually better to use some other construct.  The author of Perl has never
felt the need to use this form of <a class="xref" href="ch03_071.htm#PERL2-CMD-GOTO" title="goto"><b class="xref.cmd">goto</B
></A
> (in Perl, that is&nbsp;- C is
another matter).</P
><p class="para">The <code class="literal">goto</CODE
> <code class="replaceable"><i>EXPR</I
></CODE
>
form is just a generalization of <code class="literal">goto</CODE
> <code class="replaceable"><i>LABEL</I
></CODE
>.
It expects the expression to return a label name, whose location
obviously has to be resolved dynamically by the interpreter.  (Don't
expect this to work in compiled Perl.) This allows for computed gotos
per FORTRAN, but isn't necessarily recommended if you're optimizing for
maintainability:</P
><p class="para"><pre class="programlisting">goto (&quot;FOO&quot;, &quot;BAR&quot;, &quot;GLARCH&quot;)[$i];</PRE
></P
><p class="para">In almost all cases like this, it's usually a far, far better idea to use
the structured control flow mechanisms of <a class="xref" href="ch03_099.htm#PERL2-CMD-NEXT" title="next"><b class="xref.cmd">next</B
></A
>, <a class="xref" href="ch03_081.htm#PERL2-CMD-LAST" title="last"><b class="xref.cmd">last</B
></A
>, or
<a class="xref" href="ch03_120.htm#PERL2-CMD-REDO" title="redo"><b class="xref.cmd">redo</B
></A
> instead of resorting to a <a class="xref" href="ch03_071.htm#PERL2-CMD-GOTO" title="goto"><b class="xref.cmd">goto</B
></A
>.  For certain
applications, a hash of function pointers or the catch-and-throw pair of
<a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
> and <a class="xref" href="ch03_027.htm#PERL2-CMD-DIE" title="die"><b class="xref.cmd">die</B
></A
> for exception processing can also be
prudent approaches.</P
><p class="para">The <code class="literal">goto &amp;NAME</CODE
> form is highly magical, and quite different from an
ordinary <a class="xref" href="ch03_071.htm#PERL2-CMD-GOTO" title="goto"><b class="xref.cmd">goto</B
></A
>.  It substitutes a call to the 
named subroutine for the currently running subroutine.  This is used by
<code class="literal">AUTOLOAD</CODE
> subroutines that wish to load another subroutine
and
then pretend that the other subroutine had been called in the first place.
After the <a class="xref" href="ch03_071.htm#PERL2-CMD-GOTO" title="goto"><b class="xref.cmd">goto</B
></A
>, not even <a class="xref" href="ch03_010.htm#PERL2-CMD-CALLER" title="caller"><b class="xref.cmd">caller</B
></A
> will be able to tell that this
routine was called first.  See <a class="xref" href="ch03_01.htm" title="Functions">Chapter 3</A
> for a
discussion of <a class="xref" href="ch03_010.htm#PERL2-CMD-CALLER" title="caller"><b class="xref.cmd">caller</B
></A
> and <a class="xref" href="ch07_01.htm" title="The Standard Perl Library">Chapter 7</A
>
for AutoLoader.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.7">2.6.7 Global Declarations</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-6552"></A
><a class="indexterm" name="CH02.DEC"></A
>Subroutine and format declarations are global declarations.  No matter
where you place them, they declare global thingies (actually, package
thingies, but packages are global) that are visible from everywhere.
Global declarations can be put anywhere a statement can, but have no
effect on the execution of the primary sequence of statements&nbsp;- the
declarations take effect at compile time.  Typically the declarations
are put at the beginning or the end of your program, or off in some
other file.  However, if you're using lexically scoped private
variables created with <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
>, you'll want to make sure your format or
subroutine definition is within the same block scope as the <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> if you
expect to be able to access those private variables.[<a class="footnote" href="#AUTOID-6560">43</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6560">[43]</A
> For esoteric reasons related to closures, lexicals, and the <b class="emphasis.bold">foreach</B
>
aliasing mechanism, these <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> variables must not be the index variable
of a <b class="emphasis.bold">foreach</B
> loop, because any named subroutine or format will only have been compiled
with the first binding.</P
></DIV
></BLOCKQUOTE
><p class="para">Formats are bound to a filehandle and accessed implicitly via the <a class="xref" href="ch03_193.htm#PERL2-CMD-WRITE" title="write"><b class="xref.cmd">write</B
></A
>
function.  For more on formats, see &quot;Formats&quot; later in this
chapter.</P
><p class="para"><a class="indexterm" name="AUTOID-6568"></A
><a class="indexterm" name="AUTOID-6571"></A
>Subroutines are generally accessed directly, but don't actually have to
be defined before calls to them can be compiled.  The difference between
a subroutine definition and a mere declaration is that the definition
supplies a <code class="replaceable"><i>BLOCK</I
></CODE
> containing the code to be executed, while the
declaration doesn't.  A subroutine definition can function as a
declaration if the subroutine hasn't previously been declared.</P
><p class="para">Declaring a subroutine allows a subroutine name to be used as if it were a
list operator from that point forward in the compilation.  You can declare a
subroutine without defining it by just saying:</P
><p class="para"><pre class="programlisting">sub myname;
$me = myname $0             or die &quot;can't get myname&quot;;</PRE
></P
><p class="para">Note that it functions as a list operator, though, not as a unary
operator, so be careful to use <b class="emphasis.bold">or</B
> instead of <code class="literal">||</CODE
>.
The <code class="literal">||</CODE
> binds too tightly to use after a list operator (at least,
not without using extra parentheses to turn the list operator back into
a function call).[<a class="footnote" href="#AUTOID-6582">44</A
>]
You also need to define the subroutine at some point, or you'll get
an error at run-time indicating that you've called an undefined subroutine.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6582">[44]</A
> Alternately, turn the subroutine into a unary operator with a prototype.  But
we haven't talked about that yet.</P
></DIV
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-6585"></A
>Subroutine definitions can be loaded from other files with the
<a class="xref" href="ch03_123.htm#PERL2-CMD-REQUIRE" title="require"><b class="xref.cmd">require</B
></A
> statement, but there are two problems with that.
First, the other file will typically insert the subroutine names into
a package (a namespace) of its own choosing, not your package.  Second,
a <a class="xref" href="ch03_123.htm#PERL2-CMD-REQUIRE" title="require"><b class="xref.cmd">require</B
></A
> happens at run-time, so the declaration occurs too late
to serve as a declaration in the file invoking the <a class="xref" href="ch03_123.htm#PERL2-CMD-REQUIRE" title="require"><b class="xref.cmd">require</B
></A
>.</P
><p class="para"><a class="indexterm" name="AUTOID-6591"></A
>A more useful way to pull in declarations and definitions is via the
<a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> declaration, which essentially performs a <a class="xref" href="ch03_123.htm#PERL2-CMD-REQUIRE" title="require"><b class="xref.cmd">require</B
></A
> at compile
time and then lets you import declarations into your own namespace.
Because it is importing names into your own (global) package at compile
time, this aspect of <a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> can be considered a kind of global
declaration.  See <a class="xref" href="ch05_01.htm" title="Packages, Modules, and Object Classes">Chapter 5</A
> for
details on this.</P
><a class="indexterm" name="AUTOID-6597"></A
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.8">2.6.8 Scoped Declarations</A
></H3
><p class="para"><a class="indexterm" name="CH02.SCOPE1"></A
><a class="indexterm" name="CH02.SCOPE2"></A
>Like global declarations, lexically scoped declarations have an effect
at the time of compilation.  Unlike global declarations, lexically
scoped declarations have an effect only from the point of the
declaration to the end of the innermost enclosing block.  That's why we
call them lexically scoped, though perhaps &quot;textually scoped&quot; would be
more accurate, since lexical scoping has nothing to do with lexicons.
But computer scientists the world around know what &quot;lexically scoped&quot;
means, so we perpetuate the usage here.</P
><p class="para">We mentioned that some aspects of <a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> could be considered global
declarations, but there are other aspects that are lexically scoped.
In particular, <a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> is not only used to perform symbol importation but also to implement various magical <em class="emphasis">pragmas</EM
> (compiler hints). Most such pragmas are lexically scoped, including the <code class="literal">use strict vars</CODE
> pragma that forces you to use lexically declared variables.  See the section &quot;Pragmas&quot; below.</P
><p class="para"><a class="indexterm" name="AUTOID-6611"></A
><a class="indexterm" name="AUTOID-6614"></A
><a class="indexterm" name="AUTOID-6617"></A
>A <b class="emphasis.bold">package</B
> declaration, oddly enough, is lexically scoped, despite the
fact that a package is a global entity.  But a <b class="emphasis.bold">package</B
> declaration
merely declares the identity of the default package for the rest of
the enclosing block.  Undeclared, unqualified variable names will be
looked up in that package.  In a sense, a package isn't declared at all,
but springs into existence when you refer to a variable that belongs in the
package.  It's all very Perlish.</P
><p class="para"><a class="indexterm" name="AUTOID-6622"></A
><a class="indexterm" name="AUTOID-6624"></A
><a class="indexterm" name="AUTOID-6627"></A
><a class="indexterm" name="AUTOID-6630"></A
><a class="indexterm" name="AUTOID-6632"></A
><a class="indexterm" name="AUTOID-6635"></A
>The most frequently seen form of lexically scoped declaration is the
declaration of <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> variables.  A related form of scoping known as
<em class="emphasis">dynamic scoping</EM
> applies to <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> variables, which are really
global variables in disguise.
If you refer to a variable that has not been declared, its visibility is
global by default, and its lifetime is forever.  A variable used at
one point in your program is accessible from anywhere else in the
program.[<a class="footnote" href="#AUTOID-6642">45</A
>]
If this were all there were to the matter, Perl programs would quickly
become unwieldy as they grew in size.  Fortunately, you can easily create
private variables using <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
>, and semi-private values of global variables
using <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
>.
A <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> or a <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> declares the listed variables (in the case of
<a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
>), or the values of the listed global variables (in the case of
<a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
>), to be confined to the enclosing block, subroutine, <a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
>,
or file.  If more than one variable is listed, the list must be placed
in parentheses.  All listed elements must be legal lvalues.  (For <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
>
the constraints are even tighter: the elements must be simple scalar,
array, or hash variables, and nothing else.)  Here are some examples of
declarations of lexically scoped variables:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6642">[45]</A
> <a class="indexterm" name="AUTOID-6644"></A
>To reiterate, even apparently global variables aren't really
global&nbsp;- they're actually <em class="emphasis">package variables</EM
>.  These work a bit like
C's file static variables, or C++'s class static variables.  Packages
are used by libraries, modules, and classes to store their own private
data so it doesn't conflict with data in your main program.  If you see
someone write <code class="literal">$Some::stuff</CODE
> or <code class="literal">$Some'stuff</CODE
>, they're using the
<code class="literal">$stuff</CODE
> scalar variable from the package <code class="literal">Some</CODE
>. See <a class="xref" href="ch05_01.htm" title="Packages, Modules, and Object Classes">Chapter 5</A
>.</P
></DIV
></BLOCKQUOTE
><p class="para"><pre class="programlisting">my $name = &quot;fred&quot;;
my @stuff = (&quot;car&quot;, &quot;house&quot;, &quot;club&quot;);
my ($vehicle, $home, $tool) = @stuff;</PRE
></P
><p class="para">(These declarations also happen to perform an initializing assignment at
run-time.)</P
><p class="para">A <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> variable is <em class="emphasis">dynamically scoped</EM
>, 
whereas a <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> variable
is <em class="emphasis">lexically scoped</EM
>.  
The difference is that any dynamic variables are also visible to
functions called from within the block in which those variables are
declared.  Lexical variables are not.  They are totally hidden from the
outside world, including any called subroutines (even if it's the same
subroutine called from itself or elsewhere&nbsp;- every instance of the
subroutine gets its own copy of the variables).[<a class="footnote" href="#AUTOID-6669">46</A
>]
In either event, the variable (or local value) disappears when the program
exits the
lexical scope in which the <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> or <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> finds itself.  By and
large, you should prefer to use <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> over <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> because it's faster
and safer.  But you have to use <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> if you want to temporarily
change the value of an existing global variable, such as any of the
special variables listed at the end of this chapter.  Only alphanumeric
identifiers may be lexically scoped.  We won't talk much more about the
semantics of <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> here.  See
<a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> in <a class="xref" href="ch03_01.htm" title="Functions">Chapter 3</A
> for more information.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="AUTOID-6669">[46]</A
> An <a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
>, however, can see the lexical variables of the scope it is
being evaluated in, so long as the names aren't hidden by declarations within
the <a class="xref" href="ch03_032.htm#PERL2-CMD-EVAL" title="eval"><b class="xref.cmd">eval</B
></A
> itself.  Likewise, any anonymous subroutine (closure)
created within the scope will also see such lexical variables.  See
<a class="xref" href="ch04_01.htm" title="References and Nested Data Structures">Chapter 4</A
> for more on closures.</P
></DIV
></BLOCKQUOTE
><p class="para">Syntactically, <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> and <a class="xref" href="ch03_087.htm#PERL2-CMD-LOCAL" title="local"><b class="xref.cmd">local</B
></A
> are simply modifiers (adjectives)
on an lvalue expression.  When you assign to a modified
lvalue, the modifier doesn't change whether the lvalue is viewed as a
scalar or a list.  To figure how the assignment will work, just pretend
that the modifier isn't there.  So:</P
><pre class="programlisting">my ($foo) = &lt;STDIN&gt;;
my @FOO = &lt;STDIN&gt;;</PRE
><p class="para">both supply a list context to the right-hand side, while:</P
><pre class="programlisting">my $foo = &lt;STDIN&gt;;</PRE
><p class="para">supplies a scalar context.</P
><p class="para">The <a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> binds more tightly (with
higher precedence) than the comma does.
The following only declares one variable because the list following
<a class="xref" href="ch03_097.htm#PERL2-CMD-MY" title="my"><b class="xref.cmd">my</B
></A
> is not enclosed in parentheses:</P
><pre class="programlisting">my $foo, $bar = 1;</PRE
><p class="para">This has the same effect as:</P
><pre class="programlisting">my $foo;
$bar = 1;</PRE
><p class="para">(You'll get a warning about the mistake if you use <b class="emphasis.bold">-w</B
>.)</P
><p class="para">The declared variable is not introduced (is not visible) until after
the current statement.  Thus:</P
><pre class="programlisting">my $x = $x;</PRE
><p class="para">can be used to initialize the new inner <code class="literal">$x</CODE
> with the value of the
old outer <code class="literal">$x</CODE
>.  (Not that we recommend this style.)  On the other hand,
the expression:</P
><pre class="programlisting">my $x = 123 and $x == 123</PRE
><p class="para">is false unless the old <code class="literal">$x</CODE
> just happened to have the value 123.</P
><p class="para">Declaring a lexical variable of a particular name hides any previously
declared lexical variable of the same name. It also hides any
unqualified global variable of the same name, but you can always get to
the global variable by explicitly qualifying it with the name of the
package the global is in.</P
><p class="para">For example:</P
><pre class="programlisting"><code class="literal">$PackageName::varname</CODE
></PRE
><p class="para">A statement sequence may contain declarations of lexically scoped
variables, but apart from declaring variable names, the declarations act
like ordinary statements, and each of them is elaborated within the
sequence of statements as if it were an ordinary statement.<a class="indexterm" name="AUTOID-6710"></A
><a class="indexterm" name="AUTOID-6711"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PERL2-CH-2-SECT-6.9">2.6.9 Pragmas</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-6715"></A
><a class="indexterm" name="AUTOID-6717"></A
>Many languages allow you to give hints to the compiler.  In Perl these
hints are conveyed to the compiler with
the <a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> declaration.  Some of the pragmas
are:</P
><p class="para"><pre class="programlisting">use integer
use strict
use lib
use sigtrap
use subs
use vars</PRE
></P
><p class="para">All the Perl pragmas are described in <a class="xref" href="ch07_01.htm" title="The Standard Perl Library">Chapter 7</A
>, but we'll talk about some
of the more useful ones here.</P
><p class="para"><a class="indexterm" name="AUTOID-6726"></A
>By default, Perl assumes that it must do much of its arithmetic in
floating point.  But by saying:</P
><p class="para"><pre class="programlisting">use integer;</PRE
></P
><p class="para"><a class="indexterm" name="AUTOID-6731"></A
>you may tell the compiler that it's okay to use integer operations
from here to the end of the enclosing block.  An inner block may
countermand this by saying:</P
><p class="para"><pre class="programlisting">no integer;</PRE
></P
><p class="para">which lasts until the end of that inner block.</P
><p class="para"><a class="indexterm" name="AUTOID-6737"></A
>Some users may wish to encourage the use of lexical variables.  As an aid
to catching implicit references to package variables, if you say:</P
><p class="para"><pre class="programlisting">use strict 'vars';</PRE
></P
><p class="para">then any variable reference from there to the end of the enclosing
block must either refer to a lexical variable, or must be fully
qualified with the package name.  A compilation error results
otherwise.  An inner block may countermand this with:</P
><p class="para"><pre class="programlisting">no strict 'vars'</PRE
></P
><p class="para">You can also turn on strict checking of symbolic references and
barewords with this pragma.  Often people say <code class="literal">use strict;</CODE
> to
turn on all three strictures.</P
><p class="para">Subroutines and variables that are imported from other modules have
special privileges in Perl.  Imported subroutines can <em class="emphasis">override</EM
> many
built-in operators, and imported variables are exempt from <code class="literal">use strict
'vars'</CODE
>, since importation is considered a form of declaration.
Sometimes you want to confer these privileges on your own subroutines
and variables.  You can do this with:</P
><p class="para"><pre class="programlisting">use subs qw(&amp;read &amp;write);</PRE
></P
><p class="para">and:</P
><p class="para"><pre class="programlisting">use vars qw($fee $fie $foe $foo @sic);</PRE
></P
><p class="para">Finally, Perl searches for modules in a standard list of locations.  You
need to be able to add to that list at compile time, because when you
<a class="xref" href="ch03_185.htm#PERL2-CMD-USE" title="use"><b class="xref.cmd">use</B
></A
> modules they're loaded at compile time, and adding to the list
at run-time would be too late.  So you can put:</P
><p class="para"><pre class="programlisting">use lib &quot;/my/own/lib/directory&quot;;</PRE
></P
><p class="para">at the front of your program to do this.  Note that these last three
pragmas all modify global structures, and can therefore have effects
outside of the current lexical scope.<a class="indexterm" name="AUTOID-6759"></A
><a class="indexterm" name="AUTOID-6760"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch02_05.htm#PERL2-CH-2-SECT-5.10" title="2.5 Operators"><img src="../gifs/txtpreva.gif" alt="Previous: 2.5 Operators" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Programming Perl"><img src="../gifs/txthome.gif" alt="Programming Perl" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch02_07.htm#PERL2-CH-2-SECT-7.3" title="2.7 Subroutines"><img src="../gifs/txtnexta.gif" alt="Next: 2.7 Subroutines" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">2.5 Operators</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">2.7 Subroutines</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
