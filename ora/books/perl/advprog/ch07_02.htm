<html><head>
<title>[Chapter 7] 7.2 Objects in Perl</TITLE>
<meta name="DC.title" content="Advanced Perl Programming"><meta name="DC.creator" content="Sriram Srinivasan"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:33:46Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-220-4" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch07_01.htm" title="7. Object-Oriented Programming"><link rel="prev" href="ch07_01.htm" title="7.1 OO: An Introduction"><link rel="next" href="ch07_03.htm" title="7.3 UNIVERSAL"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Advanced Perl Programming" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,54" href="index.htm" alt="Advanced Perl Programming"><area shape="RECT" coords="467,0,514,18" href="../search/asrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="sect1" href="ch07_01.htm" title="7.1 OO: An Introduction"><img src="../gifs/txtpreva.gif" alt="Previous: 7.1 OO: An Introduction" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch07_01.htm" title="7. Object-Oriented Programming">Chapter 7<br>Object-Oriented Programming</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="sect1" href="ch07_03.htm" title="7.3 UNIVERSAL"><img src="../gifs/txtnexta.gif" alt="Next: 7.3 UNIVERSAL" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="sect1"><h2 class="sect1"><a class="title" name="ch07-23061">7.2 Objects in Perl</A
></H2
><p class="para"><a class="indexterm" name="ch07-idx-969712-0"></A
>Let us define a few preliminary terms before we start implementing objects in Perl. </P
><p class="para">An <em class="emphasis">object</EM
> (also called an <em class="emphasis">instance</EM
>), like a given car, has the following:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><a class="listitem" name="ch07-pgfId-966491"></A
><i class="firstterm">Attributes</I
> or properties (color: red; seating capacity: 4; power: 180 HP) </P
></LI
><li class="listitem"><p class="para"><a class="listitem" name="ch07-pgfId-966480"></A
><i class="firstterm">Identity</I
> (my car is different from your car)</P
></LI
><li class="listitem"><p class="para"><a class="listitem" name="ch07-pgfId-966484"></A
><i class="firstterm">Behavior</I
> (it can be steered and moved forward and backward)</P
></LI
></UL
><p class="para">Objects of a certain type are said to belong to a <em class="emphasis">class</EM
>. My car and your car belong to the class called Car or, if you are not too worried about specific details, to a class called Vehicle. All objects of a class have the same functionality.</P
><p class="para">In this section, we study how to create objects and how to enrich basic designs using inheritance and polymorphism.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="ch07-pgfId-951417">7.2.1 Attributes</A
></H3
><p class="para">An object is a collection of <a class="indexterm" name="ch07-idx-969714-0"></A
><a class="indexterm" name="ch07-idx-969714-1"></A
>attributes. An array or a hash can be used to represents this set, as we discussed in <a class="xref" href="ch02_01.htm" title="Implementing Complex Data Structures">Chapter 2, <cite class="chapter">Implementing Complex Data Structures</CITE
></A
>. For example, if you need to keep track of an employee's particulars, you might choose one of these approaches:</P
><pre class="programlisting"># Use a hash table to store Employee attributes
%employee = (&quot;name&quot;     =&gt; &quot;John Doe&quot;,
             &quot;age&quot;      =&gt; 32,
             &quot;position&quot; =&gt; &quot;Software Engineer&quot;);
print &quot;Name: &quot;, $employee{name};

# Or use an array
$name_field = 0; $age_field = 1; $position_field = 2;
@employee = (&quot;John Doe&quot;, 32, &quot;Software Engineer&quot;);
print &quot;Name: &quot;, $employee[$name_field];</PRE
><p class="para">The section <a class="xref" href="ch08_01.htm" title="Efficient Attribute Storage">"Efficient Attribute Storage"</A
> in <a class="xref" href="ch08_01.htm" title="Object Orientation: The Next Few Steps">Chapter 8, <cite class="chapter">Object Orientation: The Next Few Steps</CITE
></A
> describes a more efficient approach for storing attributes. Meanwhile, we will use a hash table for all our examples.<a class="indexterm" name="ch07-idx-969716-0"></A
><a class="indexterm" name="ch07-idx-969716-1"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch07-pgfId-951421">7.2.2 Unique Identity</A
></H3
><p class="para"><a class="indexterm" name="ch07-idx-969718-0"></A
>Clearly, one <kbd class="command">%employee</KBD
> won't suffice. Each employee requires a unique identity and his or her own collection of attributes. You can either allocate this structure dynamically or return a reference to a local data structure, as shown below:</P
><pre class="programlisting"># Using an anonymous hash
sub new_employee {
    my ($name, $age, $starting_position) = @_;
    my $r_employee = {                  # Create a unique object 
        &quot;name&quot;     =&gt; $name,            # using an anonymous hash
        &quot;age&quot;      =&gt; $age,
        &quot;position&quot; =&gt; $starting_position
    };
    return $r_employee;                 # Return &quot;object&quot;
}

# OR, returning a reference to a local variable
sub new_employee {
    my ($name, $age, $starting_position) = @_;
    my %employee = (
        &quot;name&quot;     =&gt; $name,
        &quot;age&quot;      =&gt; $age,
        &quot;position&quot; =&gt; $starting_position
    );
    return \%employee;  # return a reference to a local object
}
# Use it to create two employees
$emp1 = new_employee(&quot;John Doe&quot;,   32, &quot;Software Engineer&quot;);
$emp2 = new_employee(&quot;Norma Jean&quot;, 25, &quot;Vice President&quot;);</PRE
><p class="para"><kbd class="command">new_employee()</KBD
> returns a reference to a unique data structure in both cases. </P
><p class="para">As a <em class="emphasis">user</EM
> of this subroutine, you are not expected to know whether this scalar contains a reference to a Perl data structure or whether it contains a string (for example, it could just contain a database primary key, while the rest of the details are in a corporate database). The employee details are hence well encapsulated. Not that encapsulation should not be confused with enforced privacy.</P
><p class="para">In the preceding example, the hash table is the object, and the reference to the hash table is termed the <em class="emphasis">object reference</EM
><a class="indexterm" name="ch07-idx-969719-0"></A
><a class="indexterm" name="ch07-idx-969719-1"></A
>. Keep in mind that we have not introduced any new syntax since the last chapter. </P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch07-pgfId-951422">7.2.3 Behavior</A
></H3
><p class="para"><a class="indexterm" name="ch07-idx-969720-0"></A
>All functions that access or update one or more attributes of the object constitute the behavior of the object. </P
><p class="para">Consider </P
><pre class="programlisting">sub promote_employee {
   my $r_employee = shift;
   $r_employee-&gt;{&quot;position&quot;} = 
       lookup_next_position($r_employee-&gt;{&quot;position&quot;});
}

# To use it
promote_employee($emp1);</PRE
><p class="para">Such functions are also called <em class="emphasis">instance methods</EM
><a class="indexterm" name="ch07-idx-969722-0"></A
><a class="indexterm" name="ch07-idx-969722-1"></A
> in OO circles because they require a specific <i class="firstterm">instance</I
> of the an object; an employee, in this case. </P
><p class="para">To avoid having to suffix every method with the suffix "_employee," we put all these functions in a package of their own, called Employee:</P
><pre class="programlisting">package Employee;
sub new {   # No need for the suffix.
    ....
}
sub promote {
    ....
}</PRE
><p class="para">To use this module, you need to say:</P
><pre class="programlisting">$emp = Employee::new(&quot;John Doe&quot;, 32, &quot;Software Engineer&quot;);
Employee::promote($emp); </PRE
><p class="para">As you can see, this code is beginning to encapsulate a class called <kbd class="command">Employee</KBD
>: the user of this code invokes only the <em class="emphasis">interface functions</EM
><a class="indexterm" name="ch07-idx-969721-0"></A
> <kbd class="command">new</KBD
> and <kbd class="command">promote</KBD
> and does not know or care about the type of data structure used to store employee details, or, as we mentioned earlier, whether a database is being used behind the scenes.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch07-pgfId-951496">7.2.4 The Need for Polymorphism</A
></H3
><p class="para"><a class="indexterm" name="ch07-idx-969723-0"></A
><a class="indexterm" name="ch07-idx-969723-1"></A
>What we have seen thus far is the kind of stuff that a C programmer would do, except that he or she would likely use a <em class="emphasis">struct</EM
> to keep track of the attributes. This is precisely the way the <kbd class="command">stdio</KBD
> library works, for example. <kbd class="command">fopen()</KBD
> is a constructor that returns a pointer to a unique <kbd class="command">FILE</KBD
> structure, allocated dynamically. The pointer (the object reference) is supplied to other methods like <kbd class="command">fgets()</KBD
> and <kbd class="command">fprintf()</KBD
>.</P
><p class="para">Unfortunately, complications arise when the problem gets more involved. Let us say we have to keep information about hourly and regular employees. Hourly employees get paid by the hour and are eligible for overtime pay, while regular employees get a monthly salary. One way to approach it is to create a <kbd class="command">new</KBD
> function per type of employee:</P
><pre class="programlisting">package Employee;
# Creating Regular Employees
sub <b class="emphasis.bold">new_regular</B
> {
    my ($name, $age, $starting_position, $monthly_salary) = @_;
    my $employee = {
        &quot;name&quot;           =&gt; $name,
        &quot;age&quot;            =&gt; $age,
        &quot;position&quot;       =&gt; $starting_position,
        &quot;monthly_salary&quot; =&gt; $monthly_salary,
    };
    return $employee;  # return the object reference
}
# Hourly Employees
sub <b class="emphasis.bold">new_hourly</B
> {
    my ($name, $age, $starting_position, 
        $hourly_rate, $overtime_rate) = @_;
    my $employee = {
        &quot;name&quot;          =&gt; $name,
        &quot;age&quot;           =&gt; $age,
        &quot;position&quot;      =&gt; $starting_position,
        &quot;hourly_rate&quot;   =&gt; $hourly_rate,
        &quot;overtime_rate&quot; =&gt; $overtime_rate
    };
    return $employee;  # return the object reference
}</PRE
><p class="para">Now, if we want to get an employee's year-to-date salary, we have to make a distinction between the two types of employees. We could provide the two subroutines <kbd class="command">compute_hourly_ytd_income()</KBD
> and <kbd class="command">compute_regular_ytd_income()</KBD
>, but of course the story doesn't end there. Other differences between hourly and regular employees (such as allowed vacation, medical benefits, and so on) or the introduction of other <em class="emphasis">types</EM
> of employees (such as temporary employees) results in a combinatorial explosion of functions. Worse, the interface requires the <em class="emphasis">user</EM
> of this package to make a distinction between types of employees to be able to call the right function. </P
><p class="para">To get us out of this bind, we put different types of employees in different packages. Then we use the <kbd class="command">bless</KBD
><a class="indexterm" name="ch07-idx-969724-0"></A
> keyword to tag objects internally with a pointer to the packages they belong to. The boldface lines in the following example show the changes from the code presented above (explanations follow): </P
><pre class="programlisting">#-------------------------------------------------------------
<b class="emphasis.bold">package RegularEmployee</B
>;
sub new {
    my ($name, $age, $starting_position, $monthly_salary) = @_;
    my $r_employee = {                        
        &quot;name&quot;           =&gt; $name,            
        &quot;age&quot;            =&gt; $age,
        &quot;position&quot;       =&gt; $starting_position,
        &quot;monthly_salary&quot; =&gt; $monthly_salary,
        &quot;months_worked&quot;  =&gt; 0,
    };
    <b class="emphasis.bold">bless $r_employee, 'RegularEmployee';</B
>   # Tag object with pkg name
    return $r_employee;                     # Return object
}
sub promote {
   #...
}
sub <b class="emphasis.bold">compute_ytd_income</B
>{
   my $r_emp = shift;
   # Assume the months_worked attribute got modified at some point
   return $r_emp-&gt;{'monthly_salary'} * $r_emp-&gt;{'months_worked'};
}

#-------------------------------------------------------------
<b class="emphasis.bold">package HourlyEmployee</B
>;
sub new {
    my ($name, $age, $starting_position, 
        $hourly_rate, $overtime_rate) = @_;
    my $r_employee = {
        &quot;name&quot;          =&gt; $name,
        &quot;age&quot;           =&gt; $age,
        &quot;position&quot;      =&gt; $starting_position,
        &quot;hourly_rate&quot;   =&gt; $hourly_rate,
        &quot;overtime_rate&quot; =&gt; $overtime_rate
    };
<b class="emphasis.bold">    bless $r_employee, 'HourlyEmployee';</B
>
    return $r_employee;
}
sub promote {
   #...
}
sub <b class="emphasis.bold">compute_ytd_income</B
> {
   my ($r_emp) = $_[0];
   return $r_emp-&gt;{'hourly_rate'} * $r_emp-&gt;{'hours_worked'}
      + $r_emp-&gt;{'overtime_rate'} * $r_emp-&gt;{'overtime_hours_worked'};
}
</PRE
><p class="para"><kbd class="command">bless</KBD
> is given an ordinary reference to a data structure. It tags that data structure (note: not the <em class="emphasis">reference</EM
>[<a class="footnote" href="#ch07-pgfId-952128">1</A
>]) as belonging to a specific package and thus bestows on it some more powers, as we shall soon see. <kbd class="command">bless</KBD
> is to our hash table what baptism is to a child. It doesn't change the data structure in any way (which still remains a hash table), just as baptism doesn't really alter a person except to give them an additional identity.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch07-pgfId-952128">[1]</A
> The reference is like a <code class="literal">void *</CODE
> in C. The object is typed, not the C pointer or Perl reference.</P
></DIV
></BLOCKQUOTE
><p class="para">The nice thing about <kbd class="command">bless</KBD
> is that it gives us a direct way of using this object. Here's how:</P
><pre class="programlisting"># First create two objects as before.
$emp1 = RegularEmployee::new('John Doe', 32,    # Polymorphism
                                'Software Engineer', 5000);
$emp2 = HourlyEmployee::new('Jane Smith', 35,   # Polymorphism
                               'Auditor', 65, 90);<a class="indexterm" name="ch07-idx-969726-0"></A
>
</PRE
><p class="para">Now use the <i class="firstterm">arrow notation</I
><a class="indexterm" name="ch07-idx-969725-0"></A
><a class="indexterm" name="ch07-idx-969725-1"></A
><a class="indexterm" name="ch07-idx-969725-2"></A
><a class="indexterm" name="ch07-idx-969725-3"></A
> to directly invoke instance methods, or, as they say in OO-land, invoke methods <i class="firstterm">on the object</I
>: </P
><pre class="programlisting"># Direct invocation
<b class="emphasis.bold">$emp1-&gt;promote(); </B
>
<b class="emphasis.bold">$emp2-&gt;compute_ytd_income();</B
>      </PRE
><p class="para">When Perl sees <kbd class="command">$emp1-&gt;promote()</KBD
>, it determines the class to which <kbd class="command">$emp1</KBD
> belongs (the one under which it has been blessed). In this case, it is the <kbd class="command">Regular-Employee</KBD
>. Perl then calls this function as follows: <code class="literal">RegularEmployee::promote($emp1)</CODE
>. In other words, the object on the left side of the arrow is simply given as the first parameter of the appropriate subroutine.</P
><p class="para"><a class="indexterm" name="ch07-idx-969739-0"></A
><a class="indexterm" name="ch07-idx-969739-1"></A
>Both the <kbd class="command">::</KBD
> and <kbd class="command">-&gt;</KBD
> notations are in fact permissible, unlike in C++. The first one is more flexible because Perl figures out the class at run time, while the latter is faster because the function to be called is known at compile time. There is nothing magical about an instance method in Perl. It is an ordinary subroutine whose first parameter simply happens to be an object reference. (You might have noticed that the <kbd class="command">promote</KBD
> method did not change from the previous section.)</P
><p class="para">So is this mere syntactic sugar? Finally, all we seem to have achieved is the ability to call an instance method of an object through an alternate notation. </P
><p class="para">No, we have gained an important advantage. The module user doesn't have to discriminate between types of objects using an <kbd class="command">if</KBD
> statement but instead lets Perl take care of routing a call to the appropriate function. That is, instead of saying something like</P
><pre class="programlisting">if (ref($emp) eq &quot;HourlyEmployee&quot;) {
    $income = HourlyEmployee::compute_ytd_income($emp);
} else {
    $income = RegularEmployee::compute_ytd_income($emp);
}</PRE
><p class="para">we can simply say,</P
><pre class="programlisting">$income = $emp-&gt;compute_ytd_income();</PRE
><p class="para">This ability of Perl to call the appropriate module's function is called <i class="firstterm">run-time binding</I
><a class="indexterm" name="ch07-idx-969737-0"></A
>. Incidentally, recall from <a class="xref" href="ch01_01.htm" title="Data References and Anonymous Storage">Chapter 1, <cite class="chapter">Data References and Anonymous Storage</CITE
></A
>, that the <kbd class="command">ref</KBD
><a class="indexterm" name="ch07-idx-969738-0"></A
> function returns a string indicating the type of the entity pointed to by the reference; in the case of a blessed object reference, it returns the name of the corresponding class.</P
><p class="para">Note that while processing payroll records, <kbd class="command">$emp</KBD
> can be a regular employee in one iteration and an hourly employee in another. This feature is called <i class="firstterm">polymorphism</I
> (poly + morph = the ability of an object to take on many forms).</P
><p class="para">Polymorphism and run-time binding are the chief contributions of object-oriented languages. They give a system an enormous amount of flexibility because you can now add a new type of employee (with the same <i class="firstterm">interface</I
> as the other types) without having to change the payroll-processing code. This is possible because each object "knows" how to compute its own year-to-date income. It pays to remember this cardinal rule:</P
><blockquote class="blockquote"><p class="para"><em class="emphasis">It is indicative of inflexible procedural design if you find yourself using conditional statements to distinguish between object types.</EM
></P
></BLOCKQUOTE
><p class="para">The design is flexible also because you can add new methods to any of the packages without hurting what is already present.<a class="indexterm" name="ch07-idx-969728-0"></A
><a class="indexterm" name="ch07-idx-969728-1"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch07-39918">7.2.5 Class Methods and Attributes</A
></H3
><p class="para"><em class="emphasis">Class attributes</EM
><a class="indexterm" name="ch07-idx-969740-0"></A
><a class="indexterm" name="ch07-idx-969740-1"></A
> are properties that pertain to all instances of a class, but don't vary on a per-employee basis. For example, one insurance company might provide health coverage for all employees, so it doesn't make sense to store the name of this company in each and every employee. </P
><p class="para"><em class="emphasis">Class methods</EM
> (also known as <i class="firstterm">static methods</I
><a class="indexterm" name="ch07-idx-969741-0"></A
><a class="indexterm" name="ch07-idx-969741-1"></A
><a class="indexterm" name="ch07-idx-969741-2"></A
>) are functions that are relevant to that class but don't need a specific object instance to work with. For example, a subroutine called <kbd class="command">get_employee_names()</KBD
> doesn't require an employee object as input to figure out what it has to do. </P
><p class="para">Perl has no specific syntax for class attributes and methods, unlike C++ or Java. Class attributes are simply package global variables, and class methods are ordinary subroutines that don't work on any specific instance. Perl supports polymorphism and run-time binding for these ordinary subroutines (not just instance methods), which can be leveraged to produce a truly flexible design. Consider</P
><pre class="programlisting">$record = &lt;STDIN&gt;; # Tab delimited record containing employee details
($type, $name, $age, $position) = split(/\t/, $details);

# Create an employee object of the appropriate class
$emp = <b class="emphasis.bold">$type-&gt;</B
>new($name, $age, $position);

# Now use the object as before
$emp-&gt;compute_ytd_income();</PRE
><p class="para">In this example, <kbd class="command">$type</KBD
> can contain either of these two strings: "HourlyEmployee" or "RegularEmployee." Note that this variable is not an object; it is simply the name of a class. This approach improves on the example in the previous section by avoiding having to hardcode the name of the package. Why is that an improvement? Well, if you <em class="emphasis">didn't</EM
> have this facility, you would have had to say something like this to create an appropriately typed object:</P
><pre class="programlisting">if ($type eq &quot;HourlyEmployee&quot;) {
     $emp = HourlyEmployee-&gt;new(....);
} else {
     $emp = RegularEmployee-&gt;new(....);
}</PRE
><p class="para">Any piece of code that explicitly depends upon checking the class or type of an object requires too much maintenance. If you introduce a new type of employee tomorrow, you'll have to go back and add the new type to all such pieces of code.</P
><p class="para">Recall that in the case of an instance method, the object to the left of the arrow is passed as the first parameter to the subroutine. It is no different here. The procedure <kbd class="command">HourlyEmployee::new</KBD
> must be rewritten to expect this:</P
><pre class="programlisting"><b class="emphasis.bold">package HourlyEmployee</B
>;
sub new {
    my (<b class="emphasis.bold">$pkg,</B
> $name, $age, $starting_position, 
        $hourly_rate, $overtime_rate) = @_;</PRE
><p class="para">Given that both instance and class methods are ordinary subroutines, you can always write a subroutine that can function as either, by checking the type of the first parameter supplied to it. Consider the following constructor, which creates a new object or a clone of an existing one, depending on how it is invoked:</P
><pre class="programlisting">package Employee;
sub new {
    $arg = shift;
    if (ref($arg)) { 
        # Called as $emp-&gt;new(): Clone the Employee given to it
        #....
    } else {
        # Called as Employee-&gt;new():  Create a new employee
        #...
    }
}</PRE
><p class="para">You can now use this method as follows:</P
><pre class="programlisting"># Using new() as a class method
$emp1 = Employee-&gt;new(&quot;John Doe&quot;, 20, &quot;Vice President&quot;);

# Using new() as an instance method to clone the employee details
$emp2 = $emp1-&gt;new();</PRE
><p class="para">I'll leave it up to you to answer why you might want to clone an employee!</P
><p class="para">What have we learned in this section? If we write all our class methods to expect the name of the module as the first parameter, we make it possible for the module's user to employ run-time binding and polymorphism. We will follow this practice from now on. <a class="indexterm" name="ch07-idx-969755-0"></A
><a class="indexterm" name="ch07-idx-969755-1"></A
><a class="indexterm" name="ch07-idx-969755-2"></A
></P
><p class="para">You might be curious why a class method needs to be supplied the name of its own module. We'll answer this shortly when we deal with inheritance.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="ch07-pgfId-967404">7.2.5.1 Detour: The indirect notation</A
></H4
><p class="para">Perl wouldn't be Perl if there weren't a couple of alternatives to suit everyone's fancy. It supports an alternative to the arrow notation, called the <i class="firstterm">indirect</I
><a class="indexterm" name="ch07-idx-969756-0"></A
><a class="indexterm" name="ch07-idx-969756-1"></A
><a class="indexterm" name="ch07-idx-969756-2"></A
> <i class="firstterm">notation</I
>, in which the function name precedes the object or class name. An example should make this clear:</P
><pre class="programlisting">$emp = <b class="emphasis.bold">new Employee</B
> (&quot;John Doe&quot;, 20, &quot;Vice President&quot;);</PRE
><p class="para">C++ folks will identify with this notation. This approach can be used for objects too:</P
><pre class="programlisting">promote $emp &quot;Chairman&quot;, 100000; # Give him a promotion and a raise</PRE
><p class="para">Notice that there is no comma between <kbd class="command">$emp</KBD
> and the first argument (<code class="literal">&quot;Chairman&quot;</CODE
>). This is how Perl knows that you are calling a method using the indirect notation and not calling a subroutine in the current package. Perhaps you will identify more with the following example:</P
><pre class="programlisting">use FileHandle;
$fh = new FileHandle(&quot;&gt; foo.txt&quot;);
<b class="emphasis.bold">print $fh</B
> &quot;foo bar\n&quot;;</PRE
><p class="para"><kbd class="command">print</KBD
> is a method on the FileHandle module. </P
><p class="para">While the indirect notation has the same effect as the arrow notation, it cannot be used in a chain of calls. The following is possible only with the arrow notation:</P
><pre class="programlisting">use FileHandle;
$fh = FileHandle-&gt;new(&quot;&gt; foo.txt&quot;)-&gt;autoflush(1); # Chain of calls</PRE
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch07-pgfId-967277">7.2.6 The Need for Inheritance</A
></H3
><p class="para"><a class="indexterm" name="ch07-idx-969757-0"></A
><a class="indexterm" name="ch07-idx-969757-1"></A
>Perl allows a module to specify a list of other module names, in a special array called <kbd class="command">@ISA</KBD
><a class="indexterm" name="ch07-idx-969768-0"></A
><a class="indexterm" name="ch07-idx-969768-1"></A
>. When it does not find a particular class or instance method in a module, it looks to see if that module's <kbd class="command">@ISA</KBD
> has been initialized. If so, it checks to see if any of those modules support the missing function, picks the first one it can find, and passes control to it. This feature is called <em class="emphasis">inheritance</EM
>. Consider </P
><pre class="programlisting">package Man;
@ISA = qw(Mammal Social_Animal);</PRE
><p class="para">This allows us to specify that <kbd class="command">Man</KBD
> is-a <kbd class="command">Mammal</KBD
> and is-a <kbd class="command">Social_Animal</KBD
>. All traits (read: methods) common to mammals are supported in the <kbd class="command">Mammal</KBD
> class and don't have to be implemented in <kbd class="command">Man</KBD
> too. Let us look at a more practical example. </P
><p class="para">In our attempts to distinguish between hourly and regular employees, we have gone to the other extreme and made them completely independent. Clearly, there are a number of common attributes (name, age, and position) and behavior (<kbd class="command">promote</KBD
>, say) that they all share as employees. We can thus use inheritance to "pull out" the common aspects into a <em class="emphasis"><a class="indexterm" name="ch07-idx-969769-0"></A
><a class="indexterm" name="ch07-idx-969769-1"></A
><a class="indexterm" name="ch07-idx-969769-2"></A
>superclass</EM
> (or <em class="emphasis">base</EM
> <em class="emphasis">class</EM
>) called <kbd class="command">Employee</KBD
>:</P
><pre class="programlisting">#---------------------------------------------------------
<b class="emphasis.bold">package Employee</B
>; #Base class
#---------------------------------------------------------
sub allocate{
    my ($pkg, $name, $age, $starting_position) = @_;
    my $r_employee = bless {
        &quot;name&quot;           =&gt; $name,            
        &quot;age&quot;            =&gt; $age,
        &quot;position&quot;       =&gt; $starting_position
    }<b class="emphasis.bold">, $pkg</B
>; 
    return $r_employee;
}
sub promote {
   my $r_employee            = shift;
   my $current_position      = $r_employee-&gt;{&quot;position&quot;};
   my $next_position         = lookup_next_position($current_position);
   $r_employee-&gt;{&quot;position&quot;} = $next_position;
}
#---------------------------------------------------------
package HourlyEmployee;
#---------------------------------------------------------
<b class="emphasis.bold">@ISA = (&quot;Employee&quot;); # Inherits from Employee</B
>
sub new {
    my ($pkg, $name, $age, $starting_position, 
        $hourly_rate, $overtime_rate) = @_;
    # Let the Employee package create and bless the object
    my $r_employee = <b class="emphasis.bold">$pkg-&gt;allocate</B
>($name, $age, 
                                    $starting_position);
    # Add HourlyEmployee-specific attributes and we are done.
    $r_employee-&gt;{&quot;hourly_rate&quot;}   = $hourly_rate;
    $r_employee-&gt;{&quot;overtime_rate&quot;} = $overtime_rate;
    return $r_employee; # return the object reference
}
sub compute_ytd_income { 
    .... 
}
# ... And similarly for package RegularEmployee </PRE
><p class="para">Whatever is common to all employees is implemented in the base class. Since both <kbd class="command">HourlyEmployee</KBD
> and <kbd class="command">RegularEmployee</KBD
> need a class method called <kbd class="command">new()</KBD
> to allocate a hash table, to bless it, and to insert common attributes into this table, we factor this functionality out into a inheritable subroutine called <kbd class="command">allocate</KBD
><a class="indexterm" name="ch07-idx-969770-0"></A
> in module Employee .</P
><p class="para">Notice how <kbd class="command">allocate</KBD
> avoids hardcoding the name of a class, thus ensuring maximum reusability. <kbd class="command">HourlyEmployee::new()</KBD
> calls <kbd class="command">$pkg-&gt;allocate</KBD
>, which means that the first parameter to <kbd class="command">allocate</KBD
>, <kbd class="command">$pkg</KBD
>, has the value HourlyEmployee. <kbd class="command">allocate</KBD
> uses this to bless the object directly into the inherited class. <kbd class="command">HourlyEmployee::new</KBD
> doesn't need to create the object anymore; it just has to insert its own specific attributes. </P
><p class="para">Nothing has changed from the user's point of view. You still say,</P
><pre class="programlisting">$emp = HourlyEmployee-&gt;new(....);</PRE
><p class="para">But we have now managed to eliminate redundant code in the modules and left them open for future enhancements.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="ch07-36839">7.2.6.1 Overriding base classes</A
></H4
><p class="para"><a class="indexterm" name="ch07-idx-969776-0"></A
><a class="indexterm" name="ch07-idx-969776-1"></A
><a class="indexterm" name="ch07-idx-969776-2"></A
>Let us say we wanted to ensure that hourly employees should never rise above the level of a manager. The example shows how to <em class="emphasis">override</EM
> the base class's <kbd class="command">promote()</KBD
> method to do this check. Here's how:</P
><pre class="programlisting">package HourlyEmployee;
sub promote {
    my $obj = shift;
    die &quot;Hourly Employees cannot be promoted beyond 'Manager'&quot;
           if ($obj-&gt;{position} eq 'Manager');
    # call base class's promote
    $obj-&gt;Employee::promote(); #Specify the package explicitly
}</PRE
><p class="para">This syntax tells Perl to start the search for <kbd class="command">promote()</KBD
> in the <kbd class="command">@ISA</KBD
> hierarchy, starting from <kbd class="command">Employee</KBD
>. A small problem here is that by hardcoding the name of a class (<kbd class="command">Employee</KBD
>), we make it difficult for us to change our mind about the inheritance hierarchy. To avoid this, Perl provides a pseudoclass called <kbd class="command">SUPER</KBD
><a class="indexterm" name="ch07-idx-969781-0"></A
>, like Smalltalk, so that you can say,</P
><pre class="programlisting">    $obj-&gt;SUPER::promote();</PRE
><p class="para">This searches the <kbd class="command">@ISA</KBD
> hierarchy for the appropriate <kbd class="command">promote</KBD
> subroutine. Now, if we interpose another package between <kbd class="command">Employee</KBD
> and <kbd class="command">HourlyEmployee</KBD
> in the inheritance hierarchy, we just need to update <kbd class="command">HourlyEmployee</KBD
>'s <kbd class="command">@ISA</KBD
> array.<a class="indexterm" name="ch07-idx-969779-0"></A
><a class="indexterm" name="ch07-idx-969779-1"></A
><a class="indexterm" name="ch07-idx-969779-2"></A
></P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> We have now gradually eliminated the need for the <kbd class="command">::</KBD
> notation to call a module's subroutines. A subroutine either is imported directly into your namespace, in which case you don't need to fully qualify its name, or is invoked by using the <kbd class="command">-&gt;</KBD
> notation. You still need to use "<kbd class="command">::</KBD
>" to access a foreign package's <em class="emphasis">variables</EM
>.<a class="indexterm" name="ch07-idx-969759-0"></A
><a class="indexterm" name="ch07-idx-969759-1"></A
></P
></BLOCKQUOTE
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch07-16028">7.2.7 Object Destruction</A
></H3
><p class="para"><a class="indexterm" name="ch07-idx-969782-0"></A
><a class="indexterm" name="ch07-idx-969782-1"></A
><a class="indexterm" name="ch07-idx-969782-2"></A
>Perl automatically garbage collects a data structure when its reference count drops to zero. If a data structure has been blessed into a module, Perl allows that module to perform some clean-up before it destroys the object, by calling a special procedure in that module called <kbd class="command">DESTROY</KBD
><a class="indexterm" name="ch07-idx-969783-0"></A
> and passing it the reference to the object to be destroyed:</P
><pre class="programlisting">package Employee;
sub DESTROY {
     my ($emp) = @_;
     print &quot;Alas, &quot;, $emp-&gt;{&quot;name&quot;}, &quot; is now no longer with us \n&quot;;
}</PRE
><p class="para">This is similar to C++'s destructor or the <kbd class="command">finalize()</KBD
> method in Java in that Perl does the memory management automatically, but you get a chance to do something before the object is reclaimed. (Unlike Java's <code class="literal">finalize</CODE
>, Perl's garbage collection is deterministic; <code class="literal">DESTROY</CODE
> is called as soon as the object is not being referred to any more.)</P
><p class="para">Note that you are not compelled to declare this subroutine; you do so only if you have some clean-up work to be done. In a module such as Socket, you would close the corresponding connection, but in something like Employee, where no external system resources are being held up, you don't have to provide a <code class="literal">DESTROY</CODE
> method. But recall that <code class="literal">AUTOLOAD</CODE
><a class="indexterm" name="ch07-idx-969784-0"></A
> is called if a function is not found. In the case in which you supply <code class="literal">AUTOLOAD</CODE
> but not the <code class="literal">DESTROY</CODE
> method, you might want to ensure that <code class="literal">AUTOLOAD</CODE
> checks for this possibility:</P
><pre class="programlisting">sub AUTOLOAD {
    my $obj = $_[0];
    # $AUTOLOAD contains the name of the missing method

    # Never propagate DESTROY methods
    return if $AUTOLOAD =~ /::DESTROY$/;
    # ....
}</PRE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch07-17774">7.2.8 Accessor Methods</A
></H3
><p class="para"><a class="indexterm" name="ch07-idx-969785-0"></A
><a class="indexterm" name="ch07-idx-969785-1"></A
><a class="indexterm" name="ch07-idx-969785-2"></A
><a class="indexterm" name="ch07-idx-969785-3"></A
><a class="indexterm" name="ch07-idx-969785-4"></A
>According to Rumbaugh et al. [<a class="xref" href="ch07_06.htm" title="">15</A
>]:</P
><blockquote class="blockquote"><p class="para">Encapsulation can be violated when code associated with one class directly accesses the attributes of another class. Direct access makes assumptions about storage format and location of the data. These details must be hidden within the class....The proper way to access an attribute of another object is to "ask for it" by invoking an operation on the object, rather than simply "taking it." </P
></BLOCKQUOTE
><p class="para">This is as true for classes related by inheritance as for unrelated classes.</P
><p class="para">To discourage direct access to an object's attributes, we provide "accessor methods." These two methods read and update the "position" attribute of an employee:</P
><pre class="programlisting">$pos = $emp-&gt;get_position();                 # read attribute
$emp-&gt;set_position(&quot;Software Engineer&quot;);     # write attribute</PRE
><p class="para">The more popular convention is to have one method to handle both read and write access:</P
><pre class="programlisting">$pos = $emp-&gt;position();                     # read attribute
$emp-&gt;position(&quot;Software Engineer&quot;);         # write attribute</PRE
><p class="para">This is how the module might implement it:</P
><pre class="programlisting">package Employee;
sub position {
    my $obj = shift;
    @_ ? $obj-&gt;{position} = shift            # modify attribute
       : $obj-&gt;{position};                   # retrieve attribute
}</PRE
><p class="para">Note that the method returns the latest value of the position attribute in both cases, because in both cases (get and set), the expression <kbd class="command">$obj-&gt;{position}</KBD
> is the last to be evaluated.</P
><p class="para">It might seem a complete waste of time to call a method every time you need to touch an attribute. But, as it happens, accessor methods are absolutely necessary in <em class="emphasis">designing for change.</EM
> Consider the following advantages:</P
><dl class="variablelist"><dt class="term">Encapsulation</DT
><dd class="listitem"><p class="para"><a class="indexterm" name="ch07-idx-969789-0"></A
>Accessor methods hide how object attributes are stored. If you change the way this layout is done, only these methods need to be modified; the rest of the code, including derived classes, remain untouched. In Perl, as in other OO scripting languages, in which reengineering may be necessary for performance or space efficiency, accessor methods are a good thing. Smalltalk, CORBA (Common Object Request Broker Architecture), and ActiveX are other well-known cases in which the only way to an attribute is through an accessor. </P
></DD
><dt class="term">Side effects</DT
><dd class="listitem"><p class="para">Accessor methods are sometimes used for triggering actions in addition to retrieving or updating the attribute. GUI toolkits use this idiom routinely. For example: </P
><pre class="programlisting">     $button-&gt;foreground_color('yellow');
</PRE
><p class="para">This not only changes the value of the foreground color attribute, but updates the screen too. </P
></DD
><dt class="term">Access checking</DT
><dd class="listitem"><p class="para">Accessor methods can be made to disallow updates. For example, primary key attributes such as an employee's name should not be updatable once created; an accessor can easily enforce this.</P
></DD
><dt class="term">Computed attributes</DT
><dd class="listitem"><p class="para"><a class="indexterm" name="ch07-idx-969793-0"></A
>An employee's income can be seen as an attribute, though internally it needs to be computed. Instead of writing a method like <kbd class="command">compute_ytd_income()</KBD
>, you simply call it <kbd class="command">income()</KBD
>. This makes it look like an attribute accessor, and it can disallow updates to this attribute.</P
></DD
></DL
><p class="para">Moral of the story: Get in the habit of writing accessor methods. In the next chapter, we will study a module called ObjectTemplate, a standard library called Class::Template, and a module on CPAN called MethodMaker, all of which automatically create accessor methods for you, so there is really no reason not to use such methods.</P
><p class="para">Caveat: Even if your attributes are wrapped in accessor methods, you should be wary of unrelated classes using these methods. When reviewing a piece of code, always look for the real intention behind these accesses; sometimes it may be better to provide other methods that make this access unnecessary. For example, a user should always use <kbd class="command">$emp-&gt;promote()</KBD
> instead of directly updating the <kbd class="command">position</KBD
> attribute.<a class="indexterm" name="ch07-idx-969791-0"></A
><a class="indexterm" name="ch07-idx-969791-1"></A
><a class="indexterm" name="ch07-idx-969791-2"></A
><a class="indexterm" name="ch07-idx-969791-3"></A
><a class="indexterm" name="ch07-idx-969791-4"></A
><a class="indexterm" name="ch07-idx-969791-5"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="sect1" href="ch07_01.htm" title="7.1 OO: An Introduction"><img src="../gifs/txtpreva.gif" alt="Previous: 7.1 OO: An Introduction" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Advanced Perl Programming"><img src="../gifs/txthome.gif" alt="Advanced Perl Programming" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="sect1" href="ch07_03.htm" title="7.3 UNIVERSAL"><img src="../gifs/txtnexta.gif" alt="Next: 7.3 UNIVERSAL" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">7.1 OO: An Introduction</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">7.3 UNIVERSAL</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="../prog/index.htm" title="Programming Perl">Programming Perl</A
> | <a href="index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
