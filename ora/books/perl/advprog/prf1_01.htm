<html><head>
<title>Preface</TITLE>
<meta name="DC.title" content="Advanced Perl Programming"><meta name="DC.creator" content="Sriram Srinivasan"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:28:09Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-220-4" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="index.htm" title="Advanced Perl Programming"><link rel="next" href="prf1_02.htm" title="Why Perl?"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Advanced Perl Programming" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,54" href="index.htm" alt="Advanced Perl Programming"><area shape="RECT" coords="467,0,514,18" href="../search/asrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172">&nbsp;</TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Preface</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="sect1" href="prf1_02.htm" title="Why Perl?"><img src="../gifs/txtnexta.gif" alt="Next: Why Perl?" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="preface"><h1 class="preface"><a class="title" name="ch00-pgfId-952651">Preface</A
></H1
><div class="htmltoc"><p><b>Contents:</B
><br><a class="sect1" href="#ch00-41640" title="The Case for Scripting">The Case for Scripting</A
><br><a class="sect1" href="prf1_02.htm" title="Why Perl?">Why Perl?</A
><br><a class="sect1" href="prf1_03.htm#ch00-pgfId-947539" title="What Must I Know?">What Must I Know?</A
><br><a class="sect1" href="prf1_04.htm#ch00-pgfId-953968" title="The Book's Approach">The Book's Approach</A
><br><a class="sect1" href="prf1_05.htm" title="Conventions">Conventions</A
><br><a class="sect1" href="prf1_06.htm" title="Resources">Resources</A
><br><a class="sect1" href="prf1_07.htm" title="Perl Resources">Perl Resources</A
><br><a class="sect1" href="prf1_08.htm" title="We'd Like to Hear from You">We'd Like to Hear from You</A
><br><a class="sect1" href="prf1_09.htm" title="Acknowledgments">Acknowledgments</A
></P
><p></P
></DIV
><div class="epigraph" align="right"><p class="para" align="right"><i>Errors, like straws, upon the surface flow;<br>He who would search for pearls must dive below.</I
></P
><p class="attribution" align="right">-&nbsp;John Dryden, <cite class="citetitle">All for Love</CITE
>, Prologue</P
></DIV
><p class="para">This book has two  goals: to make you a Perl expert, and, at a broader level, to supplement your current arsenal of techniques and tools for crafting applications. It covers advanced features of the Perl language, teaches you how the <kbd class="command">perl</KBD
> interpreter works, and presents areas of modern computing technology such as networking, user interfaces, persistence, and code generation.</P
><p class="para">You will not merely dabble with language syntax or the APIs of different modules as you read this book. You will spend just as much time dealing with real-world issues such as avoiding deadlocks during remote procedure calls and switching smoothly between data storage using a flat file or a database. Along the way, you'll become comfortable with such Perl techniques as run-time evaluation, nested data structures, objects, and closures.</P
><p class="para">This book expects you to know the essentials of Perl&nbsp;- a minimal subset, actually; you must be conversant with the basic data types (scalars, arrays, and hashes), regular expressions, subroutines, basic control structures (<code class="literal">if</CODE
>, <code class="literal">while</CODE
>, <code class="literal">unless</CODE
>, <code class="literal">for</CODE
>, <code class="literal">foreach</CODE
>), file I/O, and standard variables such as <kbd class="command">@ARGV</KBD
> and <kbd class="command">$_</KBD
>. Should this not be the case, I recommend Randal Schwartz and Tom Christiansen's excellent tutorial, <a class="citetitle" href="../learn/index.htm" title="Learning Perl"><cite class="citetitle">Learning Perl</CITE
></A
>, Second Edition.</P
><p class="para">The book&nbsp;- in particular, this preface&nbsp;- substantiates two convictions of mine. </P
><p class="para">The first is that a two-language approach is most appropriate for tackling typical large-application projects: a scripting language (such as Perl, Visual Basic, Python, or Tcl) in conjunction with a systems programming language (C, C++, Java). A scripting language has weak compile-time type checking, has high-level data structures (for instance, Perl's hash table is a fundamental type; C has no such thing), and does not typically have a separate compilation-linking phase. A systems programming language is typically closer to the operating system, has fine-grained data types (C has short, int, long, unsigned int, float, double, and so on, whereas Perl has a scalar data type), and is typically faster than interpreted languages. Perl spans the language spectrum to a considerable degree: It performs extremely well as a scripting language, yet gives you low-level access to operating system API, is much faster than Java (as this book goes to press), and can optionally be compiled.</P
><p class="para">The distinction between scripting and systems programming languages is a contentious one, but it has served me well in practice. This point will be underscored in the last three chapters of the book (on extending Perl, embedding Perl, and Perl internals).</P
><p class="para">I believe that neither type of language is properly equipped to handle sophisticated application projects satisfactorily on its own, and I hope to make the case for Perl and C/C++ as the two-language combination mentioned earlier. Of course, it would be most gratifying, or <em class="emphasis">totally tubular</EM
>, as the local kids are wont to say, if the design patterns and lessons learned in this book help you even if you were to choose other languages.</P
><p class="para">The second conviction of mine is that to deploy effective applications, it is not enough just to know the language syntax well. You must know, in addition, the internals of the language's environment, and you must have a solid command of technology areas such as networking, user interfaces, databases, and so forth (specially issues that transcend language-specific libraries). </P
><p class="para">Let's look at these two points in greater detail.</P
><div class="sect1"><h2 class="sect1"><a class="title" name="ch00-41640">The Case for Scripting</A
></H2
><p class="para"><a class="indexterm" name="ch00-idx-954918-0"></A
>I started my professional life building entire applications in assembler, on occasion worrying about trying to save 100 bytes of space and optimizing away that one extra instruction. C and PL/M changed my world view. I found myself getting a chance to reflect on the application as a whole, on the life-cycle of the project, and on how it was being used by the end-user. Still, where efficiency was paramount, as was the case for interrupt service routines, I continued with assembler. (Looking back, I suspect that the PL/M compiler could generate far better assembly code than I, but my vanity would have prevented such an admission.)</P
><p class="para">My applications' requirements continued to increase in complexity; in addition to dealing with graphical user interfaces, transactions, security, network transparency, and heterogeneous platforms, I began to get involved in designing software architectures for problems such as aircraft scheduling and network management. My own efficiency had become a much more limiting factor than that of the applications. While object orientation was making me more effective at the design level, the implementation language, C++, and the libraries and tools available weren't helping me raise my level of programming. I was still dealing with low-level issues such as constructing frameworks for dynamic arrays, meta-data, text manipulation, and memory management. Unfortunately, environments such as Eiffel, Smalltalk, and the NeXT system that dealt with these issues effectively were never a very practical choice for my organization. You might understand why I have now become a raucous cheerleader for Java as the application development language of choice. The story doesn't end there, though.</P
><p class="para">Lately, the realization has slowly crept up on me that I have been ignoring two big time-sinks at either end of a software life-cycle. At the designing end, sometimes the only way to clearly understand the problem is to create an electronic storyboard (prototype). And later, once the software is implemented, users are always persnickety (er, discerning) about everything they can <em class="emphasis">see</EM
>, which means that even simple form-based interfaces are constantly tweaked and new types of reports are constantly requested. And, of course, the sharper developers wish to move on to the next project as soon as the software is implemented. These are occasions when scripting languages shine. They provide quick turnaround, dynamic user interfaces, terrific facilities for text handling, run-time evaluation, and good connections to databases and networks. Best of all, they don't need prima donna programmers to baby-sit them. You can focus your attention on making the application much more user-centric, instead of trying to figure out how to draw a pie chart using Xlib's[<a class="footnote" href="#ch00-pgfId-953780">1</A
>] lines and circles.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch00-pgfId-953780">[1]</A
> X Windows Library. Someone once mentioned that programming X Windows is like taking the square root of a number using Roman numerals!</P
></DIV
></BLOCKQUOTE
><p class="para">Clearly, it is not practical to develop complex applications in a scripting language alone; you still want to retain features such as performance, fine-grained data structures, and type safety (crucial when many programmers are working on one problem). This is why I am now an enthusiastic supporter of using scripting languages <em class="emphasis">along with</EM
> C/C++ (or Java when it becomes practical in terms of performance). Many people have been reaping enormous benefits from this <i class="firstterm">component-based</I
><a class="indexterm" name="ch00-idx-954926-0"></A
> approach, in which the components are written in C and woven together using a scripting language. Just ask any of the zillions of Visual Basic, PowerBuilder, Delphi, Tcl, and Perl programmers&nbsp;- or, for that matter, Microsoft Office and Emacs users. </P
><p class="para">For a much more informed and eloquent (not to mention controversial) testimonial to the scripting approach, please read the paper by Dr. John <a class="indexterm" name="ch00-idx-954927-0"></A
>Ousterhout,[<a class="footnote" href="#ch00-pgfId-949641">2</A
>] available at <a class="systemitem.url" href="../../../../../../../www.scriptics.com/people/john.ousterhout/">http://www.scriptics.com/people/john.ousterhout/</A
>.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch00-pgfId-949641">[2]</A
> Inventor of Tcl (Tool Command Language, pronounced "tickle").</P
></DIV
></BLOCKQUOTE
><p class="para">For an even better feel for this argument, play with the Tcl plug-in for Netscape (from the same address), take a look at the sources for Tcl applets ("Tclets"), and notice how compactly you can solve simple problems. A 100-line applet for a calculator, including the UI? I suspect that an equivalent Java applet would not take fewer than 800 lines and would be far less flexible.<a class="indexterm" name="ch00-idx-954920-0"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172">&nbsp;</TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Advanced Perl Programming"><img src="../gifs/txthome.gif" alt="Advanced Perl Programming" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="sect1" href="prf1_02.htm" title="Why Perl?"><img src="../gifs/txtnexta.gif" alt="Next: Why Perl?" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">&nbsp;</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">Why Perl?</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="../prog/index.htm" title="Programming Perl">Programming Perl</A
> | <a href="index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
