<html><head>
<title>[Chapter 20] 20.5 Meaty Extensions</TITLE>
<meta name="DC.title" content="Advanced Perl Programming"><meta name="DC.creator" content="Sriram Srinivasan"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:42:30Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-220-4" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch20_01.htm" title="20. Perl Internals"><link rel="prev" href="ch20_04.htm#ch20-20585" title="20.4 Stacks and Messaging Protocol"><link rel="next" href="ch20_06.htm" title="20.6 Easy Embedding API"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Advanced Perl Programming" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,54" href="index.htm" alt="Advanced Perl Programming"><area shape="RECT" coords="467,0,514,18" href="../search/asrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="sect1" href="ch20_04.htm#ch20-20585" title="20.4 Stacks and Messaging Protocol"><img src="../gifs/txtpreva.gif" alt="Previous: 20.4 Stacks and Messaging Protocol" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch20_01.htm" title="20. Perl Internals">Chapter 20<br>Perl Internals</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="sect1" href="ch20_06.htm" title="20.6 Easy Embedding API"><img src="../gifs/txtnexta.gif" alt="Next: 20.6 Easy Embedding API" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="sect1"><h2 class="sect1"><a class="title" name="ch20-17192">20.5 Meaty Extensions</A
></H2
><p class="para">Having armed ourselves to the teeth with information, and having hand-built a few extensions, we are now ready to exploit SWIG and XS to their hilts. In this section, we'll first look at the type of code produced by XS. As it happens, SWIG produces almost identical code, so the explanation should suffice for both tools. Then we will write typemaps and snippets of code to help XS deal with C structures, to wrap C structures with Perl objects, and, finally, to interface with C++ objects. Most of this discussion is relevant to SWIG also, which is why we need study only one SWIG example. That said, take note that the specific XS typemap examples described in the following pages are solved simply and elegantly using SWIG, without the need for user-defined typemaps.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="ch20-pgfId-969360">20.5.1 Anatomy of an XS Extension</A
></H3
><p class="para">To understand <a class="indexterm" name="ch20-idx-973028-0"></A
>XS typemaps, and the effect of keywords such as <kbd class="command">CODE</KBD
> and <kbd class="command">PPCODE</KBD
>, it pays to take a good look at the glue code generated by <em class="emphasis">xsubpp.</EM
> Consider the following XS declaration of a module, <code class="literal">Test</CODE
>, containing a function that takes two arguments and returns an integer:</P
><pre class="programlisting">MODULE = Test  PACKAGE = Test
int
func_2_args(a, b)
   int    a
   char*  b</PRE
><p class="para"><em class="emphasis">xsubpp</EM
> translates it to the following (comments in italic have been added):</P
><pre class="programlisting">XS(XS_Test_func_2_args) <i class="lineannotation">/*  Mangled function name, with package name */</I
>
                        <i class="lineannotation">/* added to make it unique                                 */</I
>
{
    dXSARGS;            <i class="lineannotation">/* declare &quot;items&quot;, and init it with                     */</I
>
    if (items != 2)     <i class="lineannotation">/* the number of items on the stack                    */</I
>
        croak(&quot;Usage: Test::func_2_args(a, b)&quot;);

    {   <i class="lineannotation">/* Start a fresh block to allow variable declarations          */</I
>
        <i class="lineannotation">/* Built-in typemaps translate the stack to C variables       */</I
>
        int      a = (int)SvIV(ST(0));
        char*    b = (char *)SvPV(ST(1),na);
        <i class="lineannotation">/* RETVAL's type matches the function return                    */</I
> 
        int      RETVAL;

        RETVAL = func_2_args(a, b);
        ST(0)  = sv_newmortal();

        <i class="lineannotation">/* Outgoing typemap to translate C var. to stack                */</I
>
        sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1); <i class="lineannotation">/* Let Perl know one return param has been put back */</I
>
}</PRE
><p class="para">This is practically identical to the code we studied in the section <a class="xref" href="ch20_04.htm#ch20-20585" title="The Called Side: Hand-Coding an XSUB">"The Called Side: Hand-Coding an XSUB</A
>." Notice how the arguments on the stack are translated into the two arguments <kbd class="command">a</KBD
> and <kbd class="command">b</KBD
>. The XS function then calls the real C function, <kbd class="command">func_2_args</KBD
>, gets its return value, and packages the result back to the argument stack. </P
><p class="para">Let us now add some of the more common XS keywords to see how they are accommodated by <em class="emphasis">xsubpp</EM
>. The XS snippet</P
><pre class="programlisting">int
func_with_keywords(a, b)
    int    a
    char*  b
  PREINIT:
    double c;
  INIT:
    c = a * 20.3;
  CODE:
    if (c &gt; 50) {
        RETVAL = test(a,b,c);
    }
  OUTPUT:
    RETVAL</PRE
><p class="para">gets translated to this:</P
><pre class="programlisting">XS(XS_Test_func_with_keywords)
{
    dXSARGS;
    if (items != 2)
        croak(&quot;Usage: Test::func_with_keywords(a, b)&quot;);
    {
        int     a = (int)   SvIV(ST(0));
        char*   b = (char *)SvPV(ST(1),na);
        double  c;                   <i class="lineannotation">/* PREINIT section                    */</I
>
        int     RETVAL;
        c = a * 20.3;                <i class="lineannotation">/* INIT section                           */</I
>
        if (c &gt; 50) {                <i class="lineannotation">/* CODE section                        */</I
>
            RETVAL = test(a,b,c);    <i class="lineannotation">/* Call any function                  */</I
>
        }
        ST(0) = sv_newmortal();      <i class="lineannotation">/* generated due to OUTPUT      */</I
>
        sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}</PRE
><p class="para">As you can see, the code supplied in <kbd class="command">PREINIT</KBD
> goes right after the typemaps to ensure that all declarations are complete before the main code starts. The location is important for traditional C compilers, but would not be an issue for ANSI C or C++ compilers, which allow variable declarations anywhere in a block. The <kbd class="command">INIT</KBD
> section is inserted before the automatically generated call to the function or, in this case, before the <kbd class="command">CODE</KBD
> section starts. The <kbd class="command">CODE</KBD
> directive allows us the flexibility of inserting any piece of code; without it, <em class="emphasis">xsubpp</EM
> would have simply inserted a call to <kbd class="command">func_with_keywords(a,b)</KBD
>, as we saw in the prior example. </P
><p class="para">The <kbd class="command">CODE</KBD
> keyword behaves like a typical C call: you can modify input parameters, and you can return at most one parameter. To deal with a variable number of input arguments or output results, you need the <kbd class="command">PPCODE</KBD
> keyword. To illustrate the implementation of <kbd class="command">PPCODE</KBD
>, consider a C function, <kbd class="command">permute</KBD
>, that takes a string, computes all its permutations and returns a dynamically allocated array of strings (a null-terminated <kbd class="command">char**</KBD
>). Let's say that we want to access it in Perl as follows:</P
><pre class="programlisting">@list = permute($str); </PRE
><p class="para">We use <kbd class="command">PPCODE</KBD
> here because the function expects to return a variable number of scalars. The following snippet of code shows the XS file:</P
><pre class="programlisting">void
permute(str)
   char *     str
  PPCODE:
   int i = 0;
  
   /* Call permute. It returns a null-terminated array of strings */
   char ** ret = permute (str);

   /* Copy these parameters to mortal scalars, and push them onto 
    * the stack */
   for ( ; *ret ; ret++, ++i) {
       XPUSHs (sv_2mortal(newSVpv(*ret, 0)));
   }
   free(ret);
   XSRETURN(i);</PRE
><p class="para">This gets translated to the following:</P
><pre class="programlisting">XS(XS_Test_permute)
{
    dXSARGS;
    if (items != 1)
        croak(&quot;Usage: Test::permute(str)&quot;);

    <i class="lineannotation">/* PPCODE adjusts stack pointer (CODE does not do this) */</I
>
    SP -= items;

    {
       char *  str = (char *)SvPV(ST(0),na);
       int     i   = 0;
       /* Call permute.It returns a null-terminated array of strings */

       char ** ret = permute (str);
       /* Copy these parameters to mortal scalars, and push them onto 
        * the stack */
       for ( ; *ret ; ret++, ++i) {
          XPUSHs (sv_2mortal(newSVpv(*ret, 0)));
       }
       free(ret);
       XSRETURN(i);
       PUTBACK;          <i class="lineannotation">/* These two statements are redundant */</I
>
       return;           <i class="lineannotation">/* because XSRETURN does both            */</I
>
    }
}</PRE
><p class="para">The <kbd class="command">PPCODE</KBD
> directive differs from <kbd class="command">CODE</KBD
> in one small but significant way: it adjusts the stack pointer SP to point to the bottom of the Perl stack frame for this function call (that is, to <kbd class="command">ST(0)</KBD
>), to enable us to use the <kbd class="command">XPUSHs</KBD
> macro to extend and push any number of arguments (recall our discussion in the section <a class="xref" href="ch20_04.htm#ch20-20585" title="Ensuring that the stack is big enough">"Ensuring that the stack is big enough</A
>"). We'll shortly see why we cannot do this using typemaps.<a class="indexterm" name="ch20-idx-973031-0"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch20-pgfId-965761">20.5.2 XS Typemaps: An Introduction</A
></H3
><p class="para">A <a class="indexterm" name="ch20-idx-973033-0"></A
><a class="indexterm" name="ch20-idx-973033-1"></A
>typemap is a snippet of code that translates a scalar value on the argument stack to a corresponding C scalar entity (int, double, pointer), or vice versa. A typemap applies only to one direction. It is important to stress here that both the input and the output for a typemap are scalars in their respective domains. You cannot have a typemap take a scalar value and return a C structure, for example; you can, however, have it return a <em class="emphasis">pointer</EM
> to the structure. This is the reason why the <kbd class="command">permute</KBD
> example in the preceding section cannot use a typemap. We could write a typemap to convert a <kbd class="command">char**</KBD
> to a <em class="emphasis">reference</EM
> to an array and then leave it to the script writer to dereference it. In SWIG, which doesn't support a <kbd class="command">PPCODE</KBD
> equivalent, this is the only option.</P
><p class="para">Another constraint of typemaps is that they convert one argument at a time, with blinkers on: you cannot take a decision based on multiple input arguments, as we mentioned in <a class="xref" href="ch18_01.htm" title="Extending Perl:A First Course">Chapter 18, <cite class="chapter">Extending Perl:A First Course</CITE
></A
>, ("if argument 1 is `foo', then increase argument 2 by 10"). XS offers the <kbd class="command">CODE</KBD
> and <kbd class="command">PPCODE</KBD
> directives to help you out in this situation, while SWIG doesn't. But recall from the section <a class="xref" href="ch18_05.htm" title="Degrees of Freedom">"Degrees of Freedom"</A
> that the two SWIG restrictions mentioned are easily and efficiently taken care of in script space.</P
><p class="para">While <em class="emphasis">xsubpp</EM
> is capable of supplying translations for ordinary C arguments, we have to write custom typemaps for all user-defined types. Assume that we have a C library with the following two functions:</P
><pre class="programlisting">Car*  new_car();
void  drive(Car *);</PRE
><p class="para">In Perl, we want to access it as</P
><pre class="programlisting">$car = Car::new_car;
Car::drive($car);</PRE
><p class="para">Let us first write the XS file for this problem:</P
><pre class="programlisting">/* Car.XS */
#include &lt;EXTERN.h&gt;
#include &lt;perl.h&gt;
#include &lt;XSUB.h&gt;

#include &lt;Car.h&gt;  /* Don't care what Car* looks like */

MODULE = Car  PACKAGE = Car
Car *
new_car ()

void
drive (car)
   Car *   car</PRE
><p class="para">As you can see, we need two typemaps: an output typemap for converting a <kbd class="command">Car*</KBD
> to <kbd class="command">$car</KBD
> and an input typemap for the reverse direction. We start off by editing a typemap file called <i class="filename">typemap</I
>,[<a class="footnote" href="#ch20-pgfId-968192">11</A
>] which contains three sections: <kbd class="command">TYPEMAP</KBD
>, <kbd class="command">INPUT</KBD
>, and <kbd class="command">OUTPUT</KBD
>, as follows:<pre class="programlisting">TYPEMAP
Car *      CAR_OBJ

INPUT 
CAR_OBJ
           $var = (Car *)SvIV($arg);
OUTPUT
CAR_OBJ
           sv_setiv($arg, (I32) $var);</PRE
></P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch20-pgfId-968192">[11]</A
> We choose this particular name because the <em class="emphasis">h2xs</EM
>-generated makefile recognizes it and feeds it to <em class="emphasis">xsubpp</EM
>. It also allows for multiple typemap files to be picked up from different directories.</P
></DIV
></BLOCKQUOTE
><p class="para">The <kbd class="command">TYPEMAP</KBD
> section creates an easy-to-use alias (<kbd class="command">CAR_OBJ</KBD
>, in this case) for your potentially complex C type (<kbd class="command">Car</KBD
> <kbd class="command">*</KBD
>). The <kbd class="command">INPUT</KBD
> and <kbd class="command">OUTPUT</KBD
> sections in the typemap file can now refer to this alias and contain code to transform an object of the corresponding type to a Perl value, or vice versa. When a typemap is used for a particular problem, the marker <kbd class="command">$arg</KBD
> is replaced by the appropriate scalar on the argument stack, and <kbd class="command">$var</KBD
> is replaced by the corresponding C variable name. In this example, the output typemap stuffs a <kbd class="command">Car*</KBD
> into the integer slot of the scalar (recall the discussion in the section <a class="xref" href="ch20_03.htm#ch20-pgfId-948426" title="SVs and object pointers">"SVs and object pointers</A
>").</P
><p class="para">The advantage of the <kbd class="command">TYPEMAP</KBD
> section's aliases is that multiple types can be mapped to the same alias. That is, a <kbd class="command">Car*</KBD
> and a <kbd class="command">Plane*</KBD
> can both be aliased to <kbd class="command">VEHICLE</KBD
>, and because the <kbd class="command">INPUT</KBD
> and <kbd class="command">OUTPUT</KBD
> sections use only the alias, both types end up sharing the same translation code. The Perl distribution comes with a typemap file that supplies all the basic typemaps (see <i class="filename">lib/ExtUtils/typemap</I
>), and you can freely use one of the aliases defined in that file. For example, you can use the alias <kbd class="command">T_PTR</KBD
> (instead of <kbd class="command">CAR_OBJ</KBD
>) and thereby use the corresponding <kbd class="command">INPUT</KBD
> and <kbd class="command">OUTPUT</KBD
> sections for that alias. In other words, our typemap file need simply say:</P
><pre class="programlisting">TYPEMAP
Car *      T_PTR</PRE
><p class="para">It so happens that the <kbd class="command">T_PTR</KBD
>'s <kbd class="command">INPUT</KBD
> and <kbd class="command">OUTPUT</KBD
> sections look identical to that shown above for <kbd class="command">CAR_OBJ</KBD
>.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch20-36248">20.5.3 Object Interface Using XS Typemaps</A
></H3
><p class="para">Let us say we want to give the script writer the ability to write something like the following, without changing the C library in any way:</P
><pre class="programlisting">$car = Car::new_car(); # As before 
<b class="emphasis.bold">$car-&gt;drive()</B
>;</PRE
><p class="para">In other words, the <kbd class="command">OUTPUT</KBD
> section of our typemap needs to convert a <kbd class="command">Car*</KBD
> (returned by <kbd class="command">new_car</KBD
>) to a blessed scalar reference, as discussed in the section <a class="xref" href="ch20_03.htm#ch20-pgfId-948426" title="SVs and object pointers">"SVs and object pointers</A
>." The <kbd class="command">INPUT</KBD
> section contains the inverse transformation: </P
><pre class="programlisting">TYPEMAP
Car *     CAR_OBJ

OUTPUT
CAR_OBJ
       sv_setref_iv($arg, &quot;Car&quot;, (I32) $var);

INPUT
CAR_OBJ
       $var = (Car *)SvIV((SV*)SvRV($arg));</PRE
><p class="para"><kbd class="command">sv_setref_iv</KBD
> gives an integer to a freshly allocated SV and converts the first argument into a reference, points it to the new scalar, and blesses it in the appropriate module (refer to <a class="xref" href="ch20_03.htm#ch20-pgfId-948426" title="API for Scalar Values">Table 20.1</A
>). In this example, we cast the pointer to an <kbd class="command">I32</KBD
>, and make the function think we are supplying an integer.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch20-pgfId-967191">20.5.4 Making XS Typemaps More Generic</A
></H3
><p class="para"><a class="indexterm" name="ch20-idx-973034-0"></A
>The typemap in the preceding example is restricted to objects of type <kbd class="command">Car</KBD
> only. We can use the TYPEMAP section's aliasing capability to generalize this typemap and accommodate any object pointer. Consider the following typemap, with changes highlighted:</P
><pre class="programlisting">TYPEMAP
Car *     <b class="emphasis.bold">ANY_OBJECT</B
>

OUTPUT
<b class="emphasis.bold">ANY_OBJECT</B
>
     sv_setref_pv($arg, <b class="emphasis.bold">CLASS</B
>, (void*) $var);

INPUT
<b class="emphasis.bold">ANY_OBJECT</B
>
     $var = (<b class="emphasis.bold">$type</B
>) SvIV((SV*)SvRV($arg));</PRE
><p class="para">All we have done is generalize the alias, the cast, and the class name. <kbd class="command">$type</KBD
> is the type of the current C object (the left-hand side of the alias in the <kbd class="command">TYPEMAP</KBD
> section), so in this case it is <kbd class="command">Car*</KBD
>. Because we want to make the class name generic, we adopt the strategy used in <a class="xref" href="ch07_01.htm" title="Object-Oriented Programming">Chapter 7, <cite class="chapter">Object-Oriented Programming</CITE
></A
>&nbsp;- ask the script user to use the arrow notation:</P
><pre class="programlisting">$c = Car-&gt;new_car();</PRE
><p class="para">This invocation supplies the name of the module as the first parameter, which we capture in the <kbd class="command">CLASS</KBD
> argument in the XS file:</P
><pre class="programlisting">Car *
new_car (<b class="emphasis.bold">CLASS</B
>)
    <b class="emphasis.bold">char *CLASS</B
></PRE
><p class="para">The only thing remaining is that we would like the user to say <kbd class="command">Car-&gt;new</KBD
> instead of <kbd class="command">Car-&gt;new_car</KBD
>. Just because C doesn't have polymorphism doesn't mean the script user has to suffer. The <kbd class="command">CODE</KBD
> keyword achieves this simply:</P
><pre class="programlisting">Car *
new (CLASS)
    char *CLASS
   CODE:
     RETVAL = new_car();
   OUTPUT:
     RETVAL</PRE
><p class="para">The <kbd class="command">drive</KBD
> method doesn't need any changes. </P
><p class="para">Having generalized this alias, we can apply the <kbd class="command">ANY_OBJECT</KBD
> alias to other objects too, as long as they also follow the convention of declaring and initializing a <kbd class="command">CLASS</KBD
> variable in any method that returns a pointer to the type declared in the <kbd class="command">TYPEMAP</KBD
> section. In the preceding example, the initialization happened automatically because Perl supplies the name of the class as the first argument.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch20-pgfId-965850">20.5.5 C++ Objects and XS Typemaps</A
></H3
><p class="para"><a class="indexterm" name="ch20-idx-973035-0"></A
>Suppose you have a C++ class called <kbd class="command">Car</KBD
> that supports a constructor and a method called <kbd class="command">drive</KBD
>. You can declare the corresponding interfaces in the XS file as follows: </P
><pre class="programlisting">Car *
Car::new ()

void 
Car::drive()</PRE
><p class="para"><em class="emphasis">xsubpp</EM
> translates the <kbd class="command">new</KBD
> declaration to an equivalent constructor call, after translating all parameters (if any):</P
><pre class="programlisting">XS(XS_Car_new)
{
    dXSARGS;
    if (items != 1)
        croak(&quot;Usage: Car::new(CLASS)&quot;);
    {
        <b class="emphasis.bold">char *  CLASS</B
> = (char *)SvPV(ST(0),na);
        Car *   RETVAL;
        RETVAL = <b class="emphasis.bold">new Car</B
>();
        ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), CLASS, (void*) RETVAL);
    }
    XSRETURN(1);
}</PRE
><p class="para">Unlike the previous example, <em class="emphasis">xsubpp</EM
> automatically supplies the <kbd class="command">CLASS</KBD
> variable. You still need the typemaps, however, to convert <kbd class="command">Car*</KBD
> to an equivalent Perl object reference. The <kbd class="command">drive</KBD
> interface declaration is translated as follows:</P
><pre class="programlisting">XS(XS_Car_drive)
{
    dXSARGS;
    if (items != 1)
        croak(&quot;Usage: Car::drive(THIS)&quot;);
    {
        <b class="emphasis.bold">Car *    THIS</B
>;
        THIS = (Car *) SvIV((SV*)SvRV(ST(0)));;
        <b class="emphasis.bold">THIS-&gt;drive</B
>();
    }
    XSRETURN_EMPTY;
}</PRE
><p class="para"><em class="emphasis">xsubpp</EM
> automatically generates the <kbd class="command">THIS</KBD
> variable to refer to the object. Both <kbd class="command">CLASS</KBD
> and <kbd class="command">THIS</KBD
> can be used in a <kbd class="command">CODE</KBD
> section. </P
><p class="para">Dean Roehrich's XS Cookbooks [<a class="xref" href="ch20_08.htm" title="">5</A
>] provide several excellent examples of XS typemaps, so be sure to look them up before you start rolling your<a class="indexterm" name="ch20-idx-973042-0"></A
> own. <a class="indexterm" name="ch20-idx-973038-0"></A
><a class="indexterm" name="ch20-idx-973038-1"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch20-pgfId-965854">20.5.6 Memory Management Using XS</A
></H3
><p class="para"><a class="indexterm" name="ch20-idx-973044-0"></A
><a class="indexterm" name="ch20-idx-973044-1"></A
><a class="indexterm" name="ch20-idx-973044-2"></A
>We have conveniently ignored the issue of memory management so far. In the preceding sections, the <kbd class="command">new</KBD
> function allocates an object that is subsequently stuffed into a scalar value by the typemapping code. When the scalar goes out of scope or is assigned something else, Perl ignores this pointer if the scalar has not been blessed&nbsp;- not surprising, considering that it has been led to believe that the scalar contains just an integer value. This is most definitely a memory leak. But if the scalar is blessed, Perl calls its <kbd class="command">DESTROY</KBD
> routine called when the scalar is cleared. If this routine is written in XS, as shown below, it gives us the opportunity to delete allocated memory:</P
><pre class="programlisting">void
DESTROY(car)
    Car *car
  CODE:
    delete_car(car); /* deallocate that object */</PRE
><p class="para">The C++ interface is simpler:</P
><pre class="programlisting">void
Car::DESTROY()</PRE
><p class="para">In this case, <em class="emphasis">xsubpp</EM
> automatically calls "<kbd class="command">delete</KBD
> <kbd class="command">THIS</KBD
>", where <kbd class="command">THIS</KBD
> represents the object, as we saw earlier.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="ch20-pgfId-968692">20.5.6.1 Recommended memory allocation and deallocation routines</A
></H4
><p class="para"><a class="indexterm" name="ch20-idx-973045-0"></A
><a class="indexterm" name="ch20-idx-973045-1"></A
>The Perl library provides a set of functions and macros to replace the conventional dynamic memory management routines (listed on the left-hand side of the table):</P
><table class="informaltable" border="1" cellpadding="3"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Instead of:</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Use:</P
></TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">malloc</KBD
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">New</KBD
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">free</KBD
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">Safefree</KBD
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">realloc</KBD
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">Renew</KBD
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">calloc</KBD
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">Newz</KBD
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">memcpy</KBD
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">Move</KBD
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">memmove</KBD
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">Copy</KBD
></P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">memzero</KBD
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"><kbd class="command">Zero</KBD
></P
></TD
></TR
></TBODY
></TABLE
><p class="para">The Perl replacements use the version of <code class="literal">malloc</CODE
> provided by Perl (by default), and optionally collect statistics on memory usage. It is recommended that you use these routines instead of the conventional memory management routines.<a class="indexterm" name="ch20-idx-973047-0"></A
><a class="indexterm" name="ch20-idx-973047-1"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch20-40642">20.5.7 SWIG Typemaps</A
></H3
><p class="para"><a class="indexterm" name="ch20-idx-973049-0"></A
><a class="indexterm" name="ch20-idx-973049-1"></A
>SWIG produces practically the same code as <em class="emphasis">xsubpp</EM
>. Consequently, you can expect its typemaps to be very similar (if not identical) to that of XS. Consider the <kbd class="command">permute</KBD
> function discussed earlier. We want a <kbd class="command">char**</KBD
> converted to a list, but since typemaps allow their input and output to be scalars, the following typemap translates it to a list <em class="emphasis">reference </EM
>:</P
><pre class="programlisting">%typemap(perl5,out) char ** {   // All functions returning char ** 
                                // get this typemap
    // $source is of type char **
    // $target is of type RV (referring to an AV)
    AV *ret_av = newAV();
    int i      = 0;
    char **p   = $source;
    /* First allocate a new AV, of the right size */
    while (*p++)
        ;            /* Incr. p while *p is non-null */ 
    av_extend(ret_av, p - $source);

    /* For each element in the array of strings, create a new
     * mortalscalar, and stuff it into the above array */
    p = $source;
    for (i = 0, p = $source; *p; p++, i++ {
        av_store(ret_av, i, sv_2mortal(newSVPV(*p, 0)));
        p++;
    }
    /* Finally, create a reference to the array; the &quot;target&quot;
       of this typemap */
    $target = sv_2mortal(newRV((SV*)ret_av));
}</PRE
><p class="para">SWIG typemaps are specific to language, hence the <kbd class="command">perl5</KBD
> argument. <kbd class="command">out</KBD
> refers to function return parameters, and this typemap applies to <em class="emphasis">all</EM
> functions with a <kbd class="command">char**</KBD
> return value. <kbd class="command">$source</KBD
> and <kbd class="command">$target</KBD
> are variables of the appropriate types: for an <kbd class="command">in</KBD
> typemap, <kbd class="command">$source</KBD
> is a Perl type, and <kbd class="command">$target</KBD
> is the data type expected by the corresponding function parameter. Note that unlike XS's <kbd class="command">$arg</KBD
> and <kbd class="command">$val</KBD
>, SWIG's <kbd class="command">$source</KBD
> and <kbd class="command">$target</KBD
> switch meanings depending on the direction of the typemap.</P
><p class="para">If you don't want this typemap applied to all functions returning <kbd class="command">char**</KBD
>'s, you can name exactly which parameter or function you want it applied to, like this:</P
><pre class="programlisting">%typemap(perl5,out) char ** <b class="emphasis.bold">permute</B
> {
    ...
}</PRE
><p class="para">Please refer to the <kbd class="command">SWIG</KBD
> documentation for a number of other typemap-related features.<a class="indexterm" name="ch20-idx-973051-0"></A
><a class="indexterm" name="ch20-idx-973051-1"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="sect1" href="ch20_04.htm#ch20-20585" title="20.4 Stacks and Messaging Protocol"><img src="../gifs/txtpreva.gif" alt="Previous: 20.4 Stacks and Messaging Protocol" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Advanced Perl Programming"><img src="../gifs/txthome.gif" alt="Advanced Perl Programming" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="sect1" href="ch20_06.htm" title="20.6 Easy Embedding API"><img src="../gifs/txtnexta.gif" alt="Next: 20.6 Easy Embedding API" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">20.4 Stacks and Messaging Protocol</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">20.6 Easy Embedding API</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="../learn32/index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="../prog/index.htm" title="Programming Perl">Programming Perl</A
> | <a href="index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
