<html><head>
<title>[Chapter 1] 1.6 A Stroll Through Perl</TITLE>
<meta name="DC.title" content="Learning Perl on Win32 Systems"><meta name="DC.creator" content="Randal L. Schwartz, Erik Olson &amp; Tom Christiansen"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-07-02T01:29:00Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-324-3" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch01_01.htm" title="1. Introduction"><link rel="prev" href="ch01_05.htm" title="1.5 Basic Concepts"><link rel="next" href="ch01_07.htm" title="1.7 Exercises"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Learning Perl on Win32 Systems" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,54" href="index.htm" alt="Learning Perl on Win32 Systems"><area shape="RECT" coords="467,0,514,18" href="../search/wsrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="sect1" href="ch01_05.htm" title="1.5 Basic Concepts"><img src="../gifs/txtpreva.gif" alt="Previous: 1.5 Basic Concepts" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1"><a class="chapter" rel="up" href="ch01_01.htm" title="1. Introduction">Chapter 1<br>Introduction</A
></FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="sect1" href="ch01_07.htm" title="1.7 Exercises"><img src="../gifs/txtnexta.gif" alt="Next: 1.7 Exercises" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="sect1"><h2 class="sect1"><a class="title" name="ch01-39405">1.6 A Stroll Through Perl</A
></H2
><p class="para">We begin our journey through Perl by taking a little stroll. This stroll presents a number of different features by hacking on a small application. The explanations here are extremely brief&nbsp;- each subject area is discussed in <em class="emphasis">much</EM
> greater detail later in this book. But this little stroll should give you a quick taste for the language, and you can decide if you really want to finish this book instead of reading some more Usenet news or running off to the <a class="indexterm" name="ch01-idx-1839-0"></A
>ski slopes.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-1840">1.6.1 The "Hello, world" Program</A
></H3
><p class="para">Let's look at a little program that actually <em class="emphasis">does</EM
> something. Here is your basic <a class="indexterm" name="ch01-idx-2089-0"></A
>"Hello, world" program (use any text editor to type it in):</P
><pre class="programlisting"><a class="indexterm" name="ch01-idx-2091-0"></A
>print (&quot;Hello, world!\n&quot;);</PRE
><p class="para">This single line is the entire program. The built-in function <code class="literal">print</CODE
> starts it off, and in this case has just one argument, a C-like text string. Within this string, the character combination <code class="literal">\n</CODE
> stands for a newline character, just as it does in C. The <code class="literal">print</CODE
> statement is terminated by a semicolon (<code class="literal">;</CODE
>). As in Pascal or C, all simple statements in Perl are terminated by a <a class="indexterm" name="ch01-idx-868857-0"></A
>semicolon.[<a class="footnote" href="#ch01-pgfId-869681">7</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-869681">[7]</A
> The semicolon can be omitted when the statement is the last statement of a block, file, or <code class="literal">eval</CODE
>.</P
></DIV
></BLOCKQUOTE
><p class="para">When you invoke this program, the Perl interpreter parses the entire program and then executes the compiled form. The first and only operation is the execution of the <code class="literal">print</CODE
> function, which sends any arguments to the standard output. After the program has completed, the Perl process exits, returning a successful exit code to the parent process.</P
><p class="para">Soon, you'll see Perl programs in which <code class="literal">print</CODE
> and other functions are sometimes called with parentheses, and sometimes called without them. The rule is simple: in Perl, parentheses for built-in functions are never required nor forbidden. Their use can help or hinder clarity, so use your own judgment.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869100">1.6.2 Asking Questions and Remembering the Result</A
></H3
><p class="para">Let's add a bit more sophistication. The <code class="literal">Hello, world</CODE
> greeting is a touch cold and inflexible. Let's have the program call you by your name. To do this, we need a place to hold the name, a way to ask for the name, and a way to get a response.</P
><p class="para">One kind of place to hold values (like a name) is a <a class="indexterm" name="ch01-idx-868858-0"></A
><em class="emphasis">scalar variable</EM
>. For this program, we'll use the scalar variable <code class="literal">$name</CODE
> to hold your name. In <a class="xref" href="ch02_01.htm" title="Scalar Data">Chapter 2, <cite class="chapter">Scalar Data</CITE
></A
>,  we'll go into more detail about what these variables can hold, and what you can do with them. For now, assume that you can hold a single number or string (sequence of characters) in a scalar variable.</P
><p class="para">The program needs to ask for the name. To do that, we need a way to <a class="indexterm" name="ch01-idx-4474-0"></A
>prompt and a way to accept input. The previous program showed us how to prompt: use the <code class="literal">print</CODE
> function. And the way to get a line from the terminal is with the <code class="literal">&lt;STDIN&gt;</CODE
><a class="indexterm" name="ch01-idx-4475-0"></A
> construct, which (as we're using it here) grabs one line of input. We assign this input to the <code class="literal">$name</CODE
> variable. This gives us the following program:</P
><pre class="programlisting">print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;</PRE
><p class="para">The value of <code class="literal">$name</CODE
> at this point has a terminating newline (<code class="literal">Erik</CODE
> comes in as <code class="literal">Erik\n</CODE
>). To get rid of the newline, we use the <a class="indexterm" name="ch01-idx-4192-0"></A
><code class="literal">chomp()</CODE
> function, which takes a scalar variable as its sole argument and removes the trailing newline, if present, from the string:</P
><pre class="programlisting">chomp $name;</PRE
><p class="para">Now, all we need to do is say <code class="literal">Hello,</CODE
> followed by the value of the <code class="literal">$name</CODE
> variable, which we can do by embedding the variable inside the <a class="indexterm" name="ch01-idx-868862-0"></A
>quoted string:</P
><pre class="programlisting">print &quot;Hello, $name!\n&quot;;</PRE
><p class="para">Putting it all together, we get:</P
><pre class="programlisting">print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
print &quot;Hello, $name!\n&quot;;</PRE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869020">1.6.3 Adding Choices</A
></H3
><p class="para">Now, let's say we have a special greeting for Erik, but want an ordinary greeting for anyone else. To do this, we need to compare the name that was entered with the string <code class="literal">Erik</CODE
>, and if they are identical, do something special. Let's add a C-like <a class="indexterm" name="ch01-idx-868863-0"></A
><em class="emphasis">if-then-else</EM
> branch and a comparison to the program:</P
><pre class="programlisting">print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
if ($name eq &quot;Erik&quot;) {
  print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
  print &quot;Hello, $name!\n&quot;; # ordinary greeting
}</PRE
><p class="para">The <a class="indexterm" name="ch01-idx-868864-0"></A
><code class="literal">eq</CODE
> operator compares two strings. If they are equal (character for character, and of the same length), the result is true. (No comparable operator[<a class="footnote" href="#ch01-pgfId-1665">8</A
>] exists in C or C++.)</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-1665">[8]</A
> Well, OK, there's a standard <code class="literal">C</CODE
> <code class="literal">library</CODE
> function. But that's not an operator.</P
></DIV
></BLOCKQUOTE
><p class="para">The <code class="literal">if</CODE
> statement selects which <a class="indexterm" name="ch01-idx-868865-0"></A
><a class="indexterm" name="ch01-idx-868865-1"></A
><em class="emphasis">block</EM
> of statements (between matching curly braces) is executed&nbsp;- if the expression is true, it's the first block, otherwise it's the second block.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-18448">1.6.4 Guessing the Secret Word</A
></H3
><p class="para">Well, now that we have the name, let's have the person running the program guess a <a class="indexterm" name="ch01-idx-868866-0"></A
>secret word. For everyone except Erik, we'll have the program repeatedly ask for guesses until the person guesses properly. First the program, and then an explanation:</P
><pre class="programlisting">$secretword = &quot;gecko&quot;; # the secret word
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
if ($name eq &quot;Erik&quot;) {
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp $guess;
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp $guess;
    }
}</PRE
><p class="para">First, we define the secret word by putting it into another scalar variable, <code class="literal">$secretword</CODE
>. After the greeting, the (non-Erik) person is asked (with another <code class="literal">print</CODE
>) for the guess. The guess is compared with the secret word using the <a class="indexterm" name="ch01-idx-3938-0"></A
><code class="literal">ne</CODE
> operator, which returns true if the strings are not equal (<code class="literal">ne</CODE
> is the logical opposite of the <code class="literal">eq</CODE
> operator). The result of the comparison controls a <a class="indexterm" name="ch01-idx-3939-0"></A
><code class="literal">while</CODE
> loop, which executes the block as long as the comparison is true.</P
><p class="para">Of course, this program is not very secure, because anyone who is tired of guessing can merely interrupt the program and get back to the prompt, or even look at the source to determine the word. But, we weren't trying to write a security system, just an example for this book.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869132">1.6.5 More than One Secret Word</A
></H3
><p class="para">Let's see how we can modify this program to allow more than one valid secret word. Using what we've already seen, we could compare the guess repeatedly against a series of good answers stored in separate scalar variables. However, such a list would be hard to modify or read in from a file or compute based on the day of the week.</P
><p class="para"><a class="indexterm" name="ch01-idx-868869-0"></A
><a class="indexterm" name="ch01-idx-868869-1"></A
>A better solution is to store all of the possible answers in a data structure called a <em class="emphasis">list</EM
>, or (preferrably) an <em class="emphasis">array</EM
>. Each <em class="emphasis">element</EM
> of the array is a separate scalar variable that can be independently set or accessed. The entire array can also be given a value in one fell swoop. We can <a class="indexterm" name="ch01-idx-868870-0"></A
>assign a value to the entire array named <code class="literal">@words</CODE
> so that it contains three possible good passwords:</P
><pre class="programlisting">@words = (&quot;camel&quot;,&quot;gecko&quot;,&quot;alpaca&quot;);</PRE
><p class="para">Array variable names begin with <a class="indexterm" name="ch01-idx-868871-0"></A
><code class="literal">@</CODE
>, so they are distinct from scalar variable names. Another way to write this so that we don't have to put all those quotemarks there is with the <a class="indexterm" name="ch01-idx-871913-0"></A
><code class="literal">qw()</CODE
> syntax, like so:</P
><pre class="programlisting">@words = qw(camel gecko alpaca);</PRE
><p class="para">These mean exactly the same thing; the <code class="literal">qw</CODE
> makes it as if we had quoted each of three strings.</P
><p class="para">After the array is assigned, we can <a class="indexterm" name="ch01-idx-868872-0"></A
>access each element by using a <a class="indexterm" name="ch01-idx-868873-0"></A
>subscript reference (subscripts start at zero). So, <code class="literal">$words[0]</CODE
> is <code class="literal">camel</CODE
>, <code class="literal">$words[1]</CODE
> is <code class="literal">gecko</CODE
>, and <code class="literal">$words[2]</CODE
> is <code class="literal">alpaca</CODE
>. The subscript can be an expression as well, so if we set <code class="literal">$i</CODE
> to 2, then <code class="literal">$words[$i]</CODE
> is <code class="literal">alpaca</CODE
>. (Subscript references start with <code class="literal">$</CODE
> rather than <code class="literal">@</CODE
>, because they refer to a single element of the array rather than the whole array.) Going back to our previous example:</P
><pre class="programlisting">@words = qw(camel gecko alpaca);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
if ($name eq &quot;Erik&quot;) {
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    $i = 0; # try this word first
    $correct = &quot;maybe&quot;; # is the guess correct or not?
    while ($correct eq &quot;maybe&quot;) { # keep checking til we know
        if ($words[$i] eq $guess) { # right?
        $correct = &quot;yes&quot;; # yes!
    } elsif ($i &lt; 2) { # more words to look at?
        $i = $i + 1; # look at the next word next time
    } else { # no more words, must be bad
        print &quot;Wrong, try again. What is the secret word?&quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
        $i = 0; # start checking at the first word again
    }
  } # end of while not correct
} # end of &quot;not Erik&quot;</PRE
><p class="para">You'll notice we're using the scalar variable <code class="literal">$correct</CODE
> to indicate that we are either still looking for a good password, or that we've found one.</P
><p class="para">This program also shows the <a class="indexterm" name="ch01-idx-3334-0"></A
><code class="literal">elsif</CODE
> block of the <code class="literal">if-then-else</CODE
> statement. This exact construct is not present in all programming languages&nbsp;- it's an abbreviation of the <code class="literal">else</CODE
> block together with a new <code class="literal">if</CODE
> condition, but it does not nest inside yet another pair of curly braces. It's a very Perl-like thing to compare a set of conditions in a cascaded <code class="literal">if-elsif-elsif-elsif-else</CODE
> chain. Perl doesn't really have the equivalent of C's <code class="literal">switch</CODE
> or Pascal's <code class="literal">case</CODE
> statement, although you can build one yourself without too much trouble. See <a class="olink" href="../prog/ch02_01.htm">Chapter 2</A
> of <a class="citetitle" href="../prog/index.htm" title="Programming Perl"><cite class="citetitle">Programming Perl</CITE
></A
> or the <em class="emphasis">perlsyn </EM
> documentation for details.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869163">1.6.6 Giving Each Person a Different Secret Word</A
></H3
><p class="para">In the previous program, any person who comes along could guess any of the three words and be successful. If we want the secret word to be different for each person, we'll need a table that matches people with words. <a class="xref" href="#ch01-14760" title="Matching Persons to Secret Words">Table 1.1</A
> does just this.</P
><br><table class="table" border="1" cellpadding="3"><caption class="table"><a class="title" name="ch01-14760">Table 1.1: Matching Persons to Secret Words</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Person</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Secret Word</P
></TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Fred</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">camel</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Barney</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">gecko</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Betty</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">alpaca</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Wilma</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">alpaca</P
></TD
></TR
></TBODY
></TABLE
><p class="para">Notice that both Betty and Wilma have the same secret word. This is fine.</P
><p class="para">The easiest way to store such a table in Perl is with a <a class="indexterm" name="ch01-idx-868874-0"></A
><em class="emphasis">hash</EM
>. Each element of the hash holds a separate scalar value (just like the other type of array), but each hash is referenced by a <a class="indexterm" name="ch01-idx-868875-0"></A
><em class="emphasis">key</EM
>, which can be any scalar value (any string or number, including noninteger and negative values). To create a hash called <code class="literal">%words</CODE
> (notice the use of <a class="indexterm" name="ch01-idx-868876-0"></A
><code class="literal">%</CODE
>, rather than <code class="literal">@</CODE
>) with the keys and values given in <a class="xref" href="#ch01-14760" title="Matching Persons to Secret Words">Table 1.1</A
>, we <a class="indexterm" name="ch01-idx-868877-0"></A
>assign a value to <code class="literal">%words</CODE
> (much as we did earlier with the array):</P
><pre class="programlisting">%words = qw(
  fred    camel
  barney  gecko
  betty   alpaca
  wilma   alpaca
);</PRE
><p class="para">Each pair of values in the list represents one key and its corresponding value in the hash. Note that we broke this assignment over many lines without any sort of line continuation character. We could do so because whitespace is generally insignificant in a Perl program.</P
><p class="para">To find the secret word for Betty, we need to use Betty as the key in a reference to the hash <code class="literal">%words</CODE
>, via some expression such as <code class="literal">$words{&quot;betty&quot;}</CODE
>. The value of this reference is <code class="literal">alpaca</CODE
>, similar to what we had before with the other array. Also, as before, the key can be any expression, so setting <code class="literal">$person</CODE
> to <code class="literal">betty</CODE
> and evaluating <code class="literal">$words{$person</CODE
>} gives <code class="literal">alpaca</CODE
> as well.</P
><p class="para">Putting all this together, we get a program like this:</P
><pre class="programlisting">%words = qw(
    fred      camel
    barney    gecko
    betty     alpaca
    wilma     alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name eq &quot;Erik&quot;) {
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}</PRE
><p class="para">Note the lookup of the secret word. If the name is not found, the value of <code class="literal">$secretword</CODE
> will be an empty string,[<a class="footnote" href="#ch01-pgfId-869272">9</A
>] which we can then check for if we want to define a default secret word for everyone else. Here's how that process looks:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-869272">[9]</A
> Well, OK, the value is really the <code class="literal">undef</CODE
> value, but it looks like an empty string to the <code class="literal">eq</CODE
> operator. You'd get a warning about this value if you used <code class="literal">-w</CODE
> on the command line, which is why we omitted it here.</P
></DIV
></BLOCKQUOTE
><pre class="programlisting">[... rest of program deleted ...]
  $secretword = $words{$name}; # get the secret word
  if ($secretword eq &quot;&quot;) { # oops, not found
      $secretword = &quot;groucho&quot;; # sure, why a duck?
  }
  print &quot;What is the secret word? &quot;;
[... rest of program deleted ...]</PRE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869224">1.6.7 Handling Varying Input Formats</A
></H3
><p class="para">If we enter <code class="literal">Erik Olson</CODE
> or <code class="literal">erik</CODE
> rather than <code class="literal">Erik</CODE
>, we're lumped in with the rest of the users, because the <code class="literal">eq</CODE
> comparison requires an exact equality. Let's look at one way to handle that.</P
><p class="para">Suppose we wanted to look for any string that began with <code class="literal">Erik</CODE
>, rather than just a string that was equal to <code class="literal">Erik</CODE
>. We could do this with a <a class="indexterm" name="ch01-idx-868878-0"></A
>regular expression: a template that defines a collection of strings that match. The regular expression in Perl that matches any string that begins with <code class="literal">Erik</CODE
> is <code class="literal">^Erik</CODE
>. To match this against the string in <code class="literal">$name</CODE
>, we use the <a class="indexterm" name="ch01-idx-868879-0"></A
>match operator as follows:</P
><pre class="programlisting">if ($name =~ /^Erik/) {
    ## yes, it matches
} else {
    ## no, it doesn't
}</PRE
><p class="para">Note that the regular expression is delimited by slashes. Within the slashes, spaces and other whitespace are significant, just as they are within strings.</P
><p class="para">This addition almost meets our needs, but it doesn't handle selecting <code class="literal">erik</CODE
> or rejecting <code class="literal">eriko</CODE
>. To accept <code class="literal">erik</CODE
>, we add the <a class="indexterm" name="ch01-idx-868880-0"></A
><a class="indexterm" name="ch01-idx-868880-1"></A
><em class="emphasis">ignore-case</EM
> option, a small <code class="literal">i</CODE
> appended after the closing slash. To reject <code class="literal">eriko</CODE
>, we add a <a class="indexterm" name="ch01-idx-868881-0"></A
><em class="emphasis">word boundary</EM
> special marker in the form of <code class="literal">\b</CODE
> in the regular expression. This ensures that the character following the first <code class="literal">k</CODE
> in the regular expression is not another letter. The addition also changes the regular expression to be <code class="literal">/^erik\b/i</CODE
>, which means "<code class="literal">erik</CODE
> at the beginning of the string, no letter or digit following, and OK to be in either case."</P
><p class="para">When this is added to the rest of the program, the final version looks like this:</P
><pre class="programlisting">%words = qw(
    fred    camel
    barney  gecko
    betty   alpaca
    wilma   alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name =~ /^erik\b/i) {
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    if ($secretword eq &quot;&quot;) { # oops, not found
        $secretword = &quot;groucho&quot;; # sure, why a duck?
  }
  print &quot;What is the secret word? &quot;;
  $guess = &lt;STDIN&gt;;
  chomp ($guess);
  while ($guess ne $secretword) {
      print &quot;Wrong, try again. What is the secret word? &quot;;
      $guess = &lt;STDIN&gt;;
      chomp ($guess);
  }
}</PRE
><p class="para">As you can see, the program is a far cry from the simple <code class="literal">Hello world</CODE
>, but it's still very small and workable, and does quite a bit for being so short. This is The Perl Way.</P
><p class="para">Perl provides nearly every regular expression feature imaginable. In addition, the way Perl handles string matching is about the fastest on the planet, so you don't lose performance. String matching in Perl often compares favorably to hand-coded C programs written specifically for the same purpose.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869113">1.6.8 Making It Fair for the Rest</A
></H3
><p class="para">So, now we can enter <code class="literal">Erik</CODE
> or <code class="literal">erik</CODE
> or <code class="literal">Erik</CODE
> <code class="literal">Olson</CODE
>, but what about everyone else? Barney still has to say exactly <code class="literal">barney</CODE
> (not even <code class="literal">barney</CODE
> followed by a space).</P
><p class="para">To be fair to Barney, we need to grab the first word of whatever's entered, and then <a class="indexterm" name="ch01-idx-868883-0"></A
>convert it to lowercase <em class="emphasis">before</EM
> we look up the name in the table. We do this with two operators: the <em class="emphasis">substitute</EM
><a class="indexterm" name="ch01-idx-868884-0"></A
> operator, which finds a regular expression and replaces it with a string, and the <em class="emphasis">translate</EM
><a class="indexterm" name="ch01-idx-868885-0"></A
> operator, which puts the string in lowercase.</P
><p class="para">First, we discuss the substitute operator. We want to take the contents of <code class="literal">$name</CODE
>, find the first nonword character, and zap everything from there to the end of the string. <code class="literal">/\W.*/</CODE
> is the <a class="indexterm" name="ch01-idx-868886-0"></A
>regular expression we are looking for&nbsp;- the <code class="literal">\W</CODE
> stands for a nonword character (something besides a letter, digit, or underscore), and <code class="literal">.*</CODE
> represents any characters from that point to the end of the line. Now, to zap these characters, we need to take whatever part of the string matches this regular expression and replace it with nothing:</P
><pre class="programlisting">$name =~ s/\W.*//;</PRE
><p class="para">We're using the same <a class="indexterm" name="ch01-idx-868887-0"></A
><code class="literal">=~</CODE
> operator that we did before, but now on the right we have a substitute operator: the letter <code class="literal">s</CODE
> followed by a slash-delimited regular expression and string. (The string in this example is the empty string between the second and third slashes.) This operator looks and acts very much like the substitution command of various editors.</P
><p class="para">Now, to get whatever's left into lowercase, we translate the string using the <a class="indexterm" name="ch01-idx-868888-0"></A
><code class="literal">tr</CODE
> operator.[<a class="footnote" href="#ch01-pgfId-3486">10</A
>] This operation takes a list of characters to find, and another list of characters with which to replace them. For our example, to put the contents of <code class="literal">$name</CODE
> in lowercase, we use:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-3486">[10]</A
> This method doesn't work for characters with accent marks, although the <code class="literal">uc</CODE
> function would.</P
></DIV
></BLOCKQUOTE
><pre class="programlisting">$name =~ tr/A-Z/a-z/;</PRE
><p class="para">The slashes delimit the searched-for and replacement character lists. The dash between <code class="literal">A</CODE
> and <code class="literal">Z</CODE
> stands for all the characters in between, so we have two lists that each contain 26 characters. When the <code class="literal">tr</CODE
> operator finds a character from the string in the first list, the character is then replaced with the corresponding character in the second list. So, all uppercase A's become lowercase a's, and so on.[<a class="footnote" href="#ch01-pgfId-869298">11</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-869298">[11]</A
> <a class="indexterm" name="ch01-idx-868955-0"></A
>Experts will note that we could have also constructed something like   <code class="literal">s/(\S*).*/\L$1/</CODE
> to do this processing in one fell swoop, but experts probably won't be reading this section.</P
></DIV
></BLOCKQUOTE
><p class="para">Putting everything together results in the following:</P
><pre class="programlisting">%words = qw(
    fred    camel
    barney  gecko
    betty   alpaca
    wilma   alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
$original_name = $name; #save for greeting
$name =~ s/\W.*//; # get rid of everything after first word
$name =~ tr/A-Z/a-z/; # lowercase everything
if ($name eq &quot;erik&quot;) { # ok to compare this way now
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $original_name!\n&quot;; # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    if ($secretword eq &quot;&quot;) { # oops, not found
        $secretword = &quot;groucho&quot;; # sure, why a duck?
    }
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}</PRE
><p class="para">Notice how the regular expression match for <code class="literal">Erik</CODE
> became a simple comparison again. After all, both <code class="literal">Erik Olson</CODE
> and <code class="literal">Erik</CODE
> become <code class="literal">erik</CODE
> after the substitution and translation. And everyone else gets a fair ride, because <code class="literal">Fred</CODE
> and <code class="literal">Fred Flintstone</CODE
> both become <code class="literal">fred</CODE
>, <code class="literal">Barney Rubble</CODE
> and <code class="literal">Barney, the little guy</CODE
> become <code class="literal">barney</CODE
>, and so on.</P
><p class="para">With just a few statements, we've made the program much more user friendly. You'll find that expressing complicated string manipulation with a few keystrokes is one of Perl's many strong points.</P
><p class="para">However, hacking away at the name so that we could compare it and look it up in the table destroyed the name that was entered. So, before the program hacks on the name, it saves it in <code class="literal">$original_name</CODE
>. (Like C symbols, Perl <a class="indexterm" name="ch01-idx-868889-0"></A
>variable names consist of letters, digits, and underscores and can be of nearly unlimited length.) We can then make references to <code class="literal">$original_name</CODE
> later.</P
><p class="para">Perl has many ways to monitor and mangle strings. You'll find out about most of them in <a class="xref" href="ch07_01.htm" title="Regular Expressions">Chapter 7, <cite class="chapter">Regular Expressions</CITE
></A
>, and <a class="xref" href="ch15_01.htm" title="Other Data Transformation">Chapter 15, <cite class="chapter">Other Data Transformation</CITE
></A
>.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869299">1.6.9 Making It a Bit More Modular</A
></H3
><p class="para">Now that we've added so much to the code, we have to scan through many detailed lines in order to get the overall flow of the program. What we need is to separate the high-level logic (asking for a name, looping based on entered secret words) from the details (comparing a secret word to a known good word). We might do this for clarity, or maybe because one person is writing the high-level part and another is writing (or has already written) the detailed parts.</P
><p class="para">Perl provides <a class="indexterm" name="ch01-idx-868890-0"></A
><em class="emphasis">subroutines</EM
> that have <a class="indexterm" name="ch01-idx-868891-0"></A
><em class="emphasis">parameters</EM
> and <a class="indexterm" name="ch01-idx-868892-0"></A
><em class="emphasis">return values</EM
>. A subroutine is defined once in a program, and can be invoked repeatedly from within any expression.</P
><p class="para">For our small-but-rapidly-growing program, let's create a subroutine called <code class="literal">good_word</CODE
> that takes a name and a guessed word, and returns <em class="emphasis">true</EM
> if the word is correct, and <em class="emphasis">false</EM
> if not. The definition of such a subroutine looks like this:</P
><pre class="programlisting">sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//; # get rid of everything after first word
    $somename =~ tr/A-Z/a-z/; # lowercase everything
    if ($somename eq &quot;erik&quot;) { # should not need to guess
        return 1; # return value is true
  } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
        return 1; # return value is true
  } else {
        return 0; # return value is false
  }
}</PRE
><p class="para">First, the definition of a subroutine consists of the reserved word <a class="indexterm" name="ch01-idx-3497-0"></A
><code class="literal">sub</CODE
>, followed by the subroutine name, followed by a <a class="indexterm" name="ch01-idx-3499-0"></A
>block of code (delimited by curly braces). These <a class="indexterm" name="ch01-idx-3500-0"></A
>definitions can go anywhere in the program file, but most people put them at the end.</P
><p class="para">The first line within this particular definition is an assignment that copies the values of the two parameters of this subroutine into two local variables named <code class="literal">$somename</CODE
> and <code class="literal">$someguess</CODE
>. (The <code class="literal">my()</CODE
> defines the two variables as private to the enclosing block&nbsp;- in this case, the entire subroutine&nbsp;- and the parameters are initially in a special local array called <a class="indexterm" name="ch01-idx-3507-0"></A
><code class="literal">@_</CODE
>.)</P
><p class="para">The next two lines clean up the name, just like in the previous version of the program.</P
><p class="para">The <code class="literal">if-elsif-else</CODE
><a class="indexterm" name="ch01-idx-868897-0"></A
> statement decides whether the guessed word (<code class="literal">$someguess</CODE
>) is correct for the name (<code class="literal">$somename</CODE
>). <code class="literal">Erik</CODE
> should not make it into this subroutine, but even if it does, whatever word was guessed is OK.</P
><p class="para">A <code class="literal">return</CODE
> statement can be used to make the subroutine immediately return to its caller with the supplied value. In the absence of an explicit <code class="literal">return</CODE
> statement, the last expression evaluated in a subroutine is the return value. We'll see how the return value is used after we finish describing the subroutine definition.</P
><p class="para">The test for the <code class="literal">elsif</CODE
> part looks a little complicated&nbsp;- let's break it apart:</P
><pre class="programlisting">($words{$somename} || &quot;groucho&quot;) eq $someguess</PRE
><p class="para">The first thing inside the parentheses is our familiar hash lookup, yielding some value from <code class="literal">%words</CODE
> based on a key of <code class="literal">$somename</CODE
>. The operator between that value and the string <code class="literal">groucho</CODE
> is the <a class="indexterm" name="ch01-idx-868898-0"></A
><code class="literal">||</CODE
> (logical-or) operator similar to that used in C. If the lookup from the hash has a value (meaning that the key <code class="literal">$somename</CODE
> was in the hash), the value of the expression is that value. If the key could not be found, the string <code class="literal">groucho</CODE
> is used instead. This step is a very Perl-like thing to do&nbsp;- specify some expression, and then provide a <a class="indexterm" name="ch01-idx-3522-0"></A
>default value using <code class="literal">||</CODE
> in case the expression turns out to be false.</P
><p class="para">In any case, whether it's a value from the hash, or the default value <code class="literal">groucho</CODE
>, we compare it to whatever was guessed. If the comparison is true, we return 1; otherwise, we return 0.</P
><p class="para">So, expressed as a rule, if the name is <code class="literal">erik</CODE
>, or the guess matches the lookup in <code class="literal">%words</CODE
> based on the name (with a default of <code class="literal">groucho</CODE
> if not found), then the subroutine returns 1; otherwise, it returns 0.</P
><p class="para">Now, let's integrate all these additions with the rest of the program:</P
><pre class="programlisting">%words = qw(
    fred    camel
    barney  gecko
    betty   alpaca
    wilma   alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name =~ /^erik\b/i) { # back to the other way :-)
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
  while (! good_word($name,$guess)) {
    print &quot;Wrong, try again. What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp $guess;
  }
}
[... insert definition of good_word() here ...]</PRE
><p class="para">Notice that we've gone back to the <a class="indexterm" name="ch01-idx-868899-0"></A
>regular expression to check for <code class="literal">Erik</CODE
>, because now the main program does not have to pull apart the first name and convert it to lowercase.</P
><p class="para">The big difference is the <a class="indexterm" name="ch01-idx-868900-0"></A
><code class="literal">while</CODE
> loop containing <code class="literal">good_word</CODE
>. Here, we see an invocation of the subroutine passing two parameters, <code class="literal">$name</CODE
> and <code class="literal">$guess</CODE
>. Within the subroutine, the value of <code class="literal">$somename</CODE
> is set from the first parameter, in this case <code class="literal">$name</CODE
>. Likewise, <code class="literal">$someguess</CODE
> is set from the second parameter, <code class="literal">$guess</CODE
>.</P
><p class="para">The value returned by the subroutine (either 1 or 0, recalling the definition given earlier) is logically inverted with the prefix <a class="indexterm" name="ch01-idx-868949-0"></A
><a class="indexterm" name="ch01-idx-868949-1"></A
><code class="literal">!</CODE
> (logical not) operator. As in C, this operator returns true if the expression following is false, and vice versa. The result of this negation controls the <code class="literal">while</CODE
> loop. You can read this as "while it's not a good word..." Many well-written Perl programs read very much like English, provided you take a few liberties with either Perl or English. (But you certainly won't win a Pulitzer that way.)</P
><p class="para">Note that the subroutine assumes that the value of the <code class="literal">%words</CODE
> hash is set by the main program.</P
><p class="para">Such a cavalier approach to global variables doesn't scale very well, of course. Generally speaking, variables not created with <code class="literal">my</CODE
> are global to the whole program, while those <code class="literal">my</CODE
> creates last only until the block in which they were declared exits. Don't worry; Perl does in fact support a rich variety of other kinds of variables, including those private to a file (or package), as well as variables private to a function that retain their values between invocations (which is what we could really use here). However, at this stage in your Perl education, explaining these variables would only complicate your life. When you're ready for such information, check out what <a class="citetitle" href="../prog/index.htm" title="Programming Perl"><cite class="citetitle">Programming Perl</CITE
></A
> has to say about scoping, subroutines, modules, and objects. Or, see the online documentation in the <em class="emphasis">perlsub</EM
> , <em class="emphasis">perlmod</EM
> , <em class="emphasis">perlobj</EM
> , and <em class="emphasis">perltoot</EM
>  documentation.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869115">1.6.10 Moving the Secret Word List into a Separate File</A
></H3
><p class="para">Suppose we wanted to share the secret word list among three programs. If we store the word list as we have done already, we will need to change all three programs when Betty decides that her secret word should be <code class="literal">swine</CODE
> rather than <code class="literal">alpaca</CODE
>. This change can get to be a hassle, especially considering how often Betty is likely to change her mind.</P
><p class="para">So, let's put the word list into a file, and then read the file to get the word list into the program. To do so, we need to create an I/O channel called a <a class="indexterm" name="ch01-idx-868902-0"></A
><em class="emphasis">filehandle</EM
>. Your Perl program automatically gets three filehandles called <a class="indexterm" name="ch01-idx-868903-0"></A
><code class="literal">STDIN</CODE
>, <code class="literal">STDOUT</CODE
><a class="indexterm" name="ch01-idx-868904-0"></A
>, and <a class="indexterm" name="ch01-idx-868905-0"></A
><code class="literal">STDERR</CODE
>, corresponding to the three standard I/O channels in many programming environments. We've already been using the <code class="literal">STDIN</CODE
> handle to read data from the person running the program. Now, we just have to get another handle attached to a file of our own choice.</P
><p class="para">Here's a small chunk of code to do that:</P
><pre class="programlisting">sub init_words {
    open (WORDSLIST, &quot;wordslist&quot;);
    while (defined ($name = &lt;WORDSLIST&gt;)) {
        chomp ($name);
        $word = &lt;WORDSLIST&gt;;
        chomp ($word);
        $words{$name} = $word;
     }
     close (WORDSLIST);
}</PRE
><p class="para">We're putting this code into a subroutine so that we can keep the main part of the program uncluttered. This organization also means that at a later time (hint: after a few more revisions in this stroll), we can change where the word list is stored, or even the format of the list.</P
><p class="para">The arbitrarily chosen format of the word list is one item per line, with names and words alternating. So, for our current database, we'd have something like this:</P
><pre class="programlisting">fred
camel
barney
gecko
betty
alpaca
wilma
alpaca</PRE
><p class="para">The <em class="emphasis"></EM
><a class="indexterm" name="ch01-idx-868906-0"></A
><code class="literal">open </CODE
> function creates a <a class="indexterm" name="ch01-idx-868956-0"></A
>filehandle named <code class="literal">WORDSLIST</CODE
> by associating it with a file named <code class="literal">wordslist</CODE
> in the current directory. Note that the filehandle doesn't have a funny character in front of it as do the three variable types. Also, filehandles are generally <a class="indexterm" name="ch01-idx-868957-0"></A
><a class="indexterm" name="ch01-idx-868957-1"></A
>uppercase&nbsp;- although they aren't required to be&nbsp;- for reasons detailed later.</P
><p class="para">The <code class="literal">while</CODE
> loop reads lines from the <code class="literal">wordslist</CODE
> file (via the <code class="literal">WORDSLIST</CODE
> filehandle) one line at a time. Each line is stored into the <code class="literal">$name</CODE
> variable. When <a class="indexterm" name="ch01-idx-868907-0"></A
>end-of-file is reached, the value returned by the <code class="literal">&lt;WORDSLIST&gt;</CODE
> operation is the empty string,[<a class="footnote" href="#ch01-pgfId-869371">12</A
>] which looks false to the <code class="literal">while</CODE
> loop, and terminates it. That's how we get out at the end.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-869371">[12]</A
> Well, technically the value is <code class="literal">undef</CODE
> again, but empty string is close enough for this discussion.</P
></DIV
></BLOCKQUOTE
><p class="para">If you were running with the <b class="emphasis.bold">-w</B
> option, you would have to check that the return value read in was actually <code class="literal">defined</CODE
>. The empty string returned by the <code class="literal">&lt;WORDSLIST&gt;</CODE
> operation isn't merely empty&nbsp;- it's <code class="literal">undef</CODE
> again. The <code class="literal">defined</CODE
> function is how you test for <code class="literal">undef</CODE
> when this matters. In the case of reading lines from a file, you'd test as shown:</P
><pre class="programlisting"> while ( defined ($name = &lt;WORDSLIST&gt;) ) { </PRE
><p class="para">But if you were being that careful, you'd probably also have checked to make sure that <code class="literal">open</CODE
> returned a true value. You know, that's probably not a bad idea either. The built-in <code class="literal">die</CODE
> function is frequently used to exit the program with an error message in case something goes wrong. We'll see an example of this function in the next revision of the program.</P
><p class="para">On the other hand, the normal case is that we've read a line (including the newline) into <code class="literal">$name</CODE
>. First, off comes the newline using the <a class="indexterm" name="ch01-idx-868908-0"></A
><code class="literal">chomp</CODE
> function. Then, we have to read the next line to get the secret word, holding it in the <code class="literal">$word</CODE
> variable. This variable also gets the newline hacked off.</P
><p class="para">The final line of the <code class="literal">while</CODE
> loop puts <code class="literal">$word</CODE
> into <code class="literal">%words</CODE
> with a key of <code class="literal">$name</CODE
>, so that the rest of the program can access it later.</P
><p class="para">After the file has been read, the filehandle can be recycled with the <a class="indexterm" name="ch01-idx-3586-0"></A
><code class="literal">close</CODE
> function. (Filehandles are automatically closed anyway when the program exits, but we're trying to be tidy. If we were <em class="emphasis">really</EM
> tidy, we'd even check for a true return value from <code class="literal">close</CODE
> in case the disk partition which held the file went south, its network filesystem became unreachable, or a similar catastrophe occurred. Yes, these things really do happen. Murphy will always be with us.)</P
><p class="para">This subroutine definition can go after or before the other one. And, we invoke the subroutine instead of setting <code class="literal">%words</CODE
> in the beginning of the program. Therefore, you could wrap up all of this as follows:</P
><pre class="programlisting">init_words();
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name =~ /^erik\b/i) { # back to the other way :-)
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while (! good_word($name,$guess)) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}
## subroutines from here down
sub init_words {
    open (WORDSLIST,&quot;wordslist&quot;) || 
            die &quot;can't open wordlist:$!&quot;;
    while (defined ($name = &lt;WORDSLIST&gt;)) {
        chomp ($name);
        $word = &lt;WORDSLIST&gt;;
        chomp ($word);
        $words{$name} = $word;
    }
    close (WORDSLIST);
}
sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//; # delete everything after first word
    $somename =~ tr/A-Z/a-z/; # lowercase everything
    if ($somename eq &quot;erik&quot;) { # should not need to guess
        return 1; # return value is true
    } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
        return 1; # return value is true
    } else {
        return 0; # return value is false
    }
}</PRE
><p class="para">Now our program is starting to look full-grown. Notice the first executable line is an invocation of <code class="literal">init_words()</CODE
>. The return value is not used in a further calculation, which is good because we didn't return anything remarkable. In this case, a true value is guaranteed (the value 1, in particular), because if the <code class="literal">close</CODE
> had failed, the <code class="literal">die</CODE
> would have printed a message to our STDERR error and exited the program. The <code class="literal">die</CODE
> function is fully explained in <a class="xref" href="ch10_01.htm" title="Filehandles and File Tests">Chapter 10, <cite class="chapter">Filehandles and File Tests</CITE
></A
><em class="emphasis">,</EM
> but because the return values of anything that might fail must be checked, we'll get into the habit of using the function right from the start. The $! variable (also explained in <a class="xref" href="ch10_01.htm" title="Filehandles and File Tests">Chapter 10</A
>) contains the system error message explaining why the system call failed.</P
><p class="para">The <code class="literal">open </CODE
> function is also used to open files for output, or open programs as files (demonstrated shortly). The full scoop on <code class="literal">open</CODE
> comes much later in this book, however, in <a class="xref" href="ch10_01.htm" title="Filehandles and File Tests">Chapter 10</A
>.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869405">1.6.11 Ensuring a Modest Amount of Security</A
></H3
><p class="para">"That secret word list has got to change at least once a week!" cries the Chief Director of Secret Word Lists. Well, we can't force the list to be different, but we can at least issue a warning if the secret word list has not been modified in more than a week.</P
><p class="para">The best place for handling this warning is the <code class="literal">init_words()</CODE
> subroutine&nbsp;- we're already looking at the file there. The Perl operator <a class="indexterm" name="ch01-idx-868911-0"></A
><code class="literal">-M</CODE
> returns the <a class="indexterm" name="ch01-idx-868959-0"></A
><a class="indexterm" name="ch01-idx-868959-1"></A
>age in days since a file or filehandle has last been modified, so we just need to see whether this value is greater than seven for the <code class="literal">WORDSLIST</CODE
> filehandle:</P
><pre class="programlisting">sub init_words {
    open (WORDSLIST,&quot;wordslist&quot;) || 
            die &quot;can't open wordlist:$!&quot;;
    if (-M WORDSLIST &gt; 7.0) { # comply with bureaucratic policy
        die &quot;Sorry, the wordslist is older than seven days.&quot;;
    }
   while (defined ($name = &lt;WORDSLIST&gt;)) {
       chomp ($name);
       $word = &lt;WORDSLIST&gt;;
      chomp ($word);
      $words{$name} = $word;
    }
    close (WORDSLIST) || die &quot;couldn't close wordlist: $!&quot;;
}</PRE
><p class="para">The value of <code class="literal">-M WORDSLIST</CODE
> is compared to seven, and if the value is greater, bingo, we've violated policy.</P
><p class="para">The rest of the program remains unchanged, so in the interest of saving a few trees, we won't repeat it here.</P
><p class="para">Besides getting the age of a file, we can also find out its size, access time, and everything else that an operating system maintains about a file. More information about this feature appears in <a class="xref" href="ch10_01.htm" title="Filehandles and File Tests">Chapter 10</A
>.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869118">1.6.12 Warning Someone When Things Go Astray</A
></H3
><p class="para">We really ought to know when someone guesses incorrectly so that we can watch for break-in attempts. If we were using a UNIX system, we would probably use the <em class="emphasis">mail</EM
> command to send an email message to someone about the failed attempt. However, on a Windows workstation, no standard <em class="emphasis">mail  </EM
>[<a class="footnote" href="#ch01-pgfId-2130">13</A
>] command exists, so we're going to log failures to a file.[<a class="footnote" href="#ch01-pgfId-2477">14</A
>] We need only do a little work to accomplish this task. We'll add a new subroutine and modify only the <code class="literal">good_word()</CODE
> subroutine (thanks to modularity), because we have all the information we need:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-2130">[13]</A
> Perl for Win32 programmers will encounter this <em class="emphasis">mail</EM
> comand issue frequently in scripts that they find on the Net.  The solution is to use one of a number of readily available command-line mailers, or to use Perl's network interface to talk to an SMTP server directly.</P
></DIV
><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-2477">[14]</A
> We could also use the Win32::EventLog module to log our warnings to the Windows NT Event Log.</P
></DIV
></BLOCKQUOTE
><pre class="programlisting">sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//; # get rid of stuff after first word
    $somename =~ tr/A-Z/a-z/; # lowercase everything
    if ($somename eq &quot;erik&quot;) { # should not need to guess
        return 1; # return value is true
    } elsif (($words{$somename}||&quot;groucho&quot;) eq $someguess) {
        return 1; # return value is true
    } else {
        log_failure($somename, $someguess);
        return 0; # return value is false
    }
}

sub log_failure {
    my($somename,$someguess) = @_; # name the parameters
    open(LOG, &quot;&gt;&gt;failures.log&quot;) || die &quot;failures.log: $!&quot;;
    print LOG &quot;bad news: $somename guessed $someguess\n&quot;;
    close (LOG)  || die &quot;can't close failures.log: $!&quot;;
}</PRE
><p class="para">Notice the<em class="emphasis"> </EM
><a class="indexterm" name="ch01-idx-871655-0"></A
><a class="indexterm" name="ch01-idx-871655-2"></A
><a class="indexterm" name="ch01-idx-871655-3"></A
><code class="literal">open</CODE
>, which has a redirection symbol (<code class="literal">&gt;&gt;</CODE
>) in the filename. This symbol is a special indication that we are appending to a file. The next statement, a <code class="literal">print</CODE
>, shows that a <a class="indexterm" name="ch01-idx-868962-0"></A
>filehandle between the <a class="indexterm" name="ch01-idx-868915-0"></A
><code class="literal">print</CODE
> keyword and the values to be printed selects that filehandle for output, rather than <code class="literal">STDOUT</CODE
>.[<a class="footnote" href="#ch01-pgfId-869470">15</A
>] This means that the message will be written to the output file that we've opened. Finally, we close the filehandle.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-869470">[15]</A
> Well, technically, the currently selected filehandle. That's covered much later, though.</P
></DIV
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869121">1.6.13 Many Secret Word Files in the Current Directory</A
></H3
><p class="para">Let's change the definition of the secret word filename slightly. Instead of just the file named <code class="literal">wordslist</CODE
>, let's look for anything in the current directory that ends in <code class="literal">.sec</CODE
>. At the command prompt, we say:</P
><pre class="programlisting">&gt; <b class="emphasis.bold">dir /B *.sec</B
></PRE
><p class="para">to get a brief listing of all of these names. As you'll see in a moment, Perl uses a similar wildcard name syntax.</P
><p class="para">Pulling out the <code class="literal">init_words()</CODE
> definition again:</P
><pre class="programlisting">sub init_words {
    while (defined ($filename = glob(&quot;*.sec&quot;)) ) {
        open (WORDSLIST, $filename) || 
                die &quot;can't open $filename:$!&quot;;
        if (-M WORDSLIST &lt;= 7.0) {
            while (defined ($name = &lt;WORDSLIST&gt;)) {
                chomp ($name);
                $word = &lt;WORDSLIST&gt;;
                chomp ($word);
                $words{$name} = $word;
             }
        }
    close (WORDSLIST) || die &quot;couldn't close $filename: $!&quot;;
    }
}</PRE
><p class="para">First, I've wrapped a new <a class="indexterm" name="ch01-idx-868919-0"></A
><code class="literal">while</CODE
> loop around the bulk of the routine from the previous version. The new thing here is the <code class="literal">glob</CODE
> function. This is called a <a class="indexterm" name="ch01-idx-868916-0"></A
><a class="indexterm" name="ch01-idx-868916-1"></A
><em class="emphasis">filename glob</EM
>[<a class="footnote" href="#ch01-pgfId-3355">16</A
>] for historical reasons. The function works much like <code class="literal">&lt;STDIN&gt;</CODE
>, in that each time it is accessed, it returns the next value: successive filenames that match the pattern, in this case <code class="literal">*.sec</CODE
>. When there are no additional filenames to be returned, the filename glob returns an empty string.[<a class="footnote" href="#ch01-pgfId-869495">17</A
>] In Perl on Windows systems, filename globbing[<a class="footnote" href="#ch01-pgfId-2525">18</A
>] is implemented by means of another program, called <em class="emphasis">PerlGlob.exe</EM
>, which must be somewhere in your search path (this should usually be the case, because <em class="emphasis">PerlGlob.exe</EM
> is installed in the same directory as your Perl interpreter by default).</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-3355">[16]</A
> Glob might be a new word to Win32 programmers.  We'll talk much more about globbing in <a class="xref" href="ch12_01.htm" title="Directory Access">Chapter 12, <cite class="chapter">Directory Access</CITE
></A
>.</P
></DIV
><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-869495">[17]</A
> Yeah, yeah, <code class="literal">undef</CODE
> again.</P
></DIV
><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-2525">[18]</A
> If you're using the ISAPI version of Perl, you'll have better luck if you avoid file globbing altogether and use the following equivalent technique:</P
><pre class="programlisting"><code class="literal">opendir(DIR, `.');</CODE
>
<code class="literal">@files = grep(/\.sec$/, readdir(DIR));</CODE
>
<code class="literal">closedir DIR;</CODE
></PRE
><p class="para">This method leaves you with a list (<code class="literal">@files</CODE
>) of all filenames in the current directory that contain the <code class="literal">.sec</CODE
> pattern.  We'll provide more information on this later.</P
></DIV
></BLOCKQUOTE
><p class="para">So, if the current directory contains <code class="literal">fred.sec</CODE
> and <code class="literal">barney.sec</CODE
>, then <code class="literal">$filename</CODE
> is <code class="literal">barney.sec</CODE
> on the first pass through the <code class="literal">while</CODE
> loop (the names come out in alphabetically sorted order). On the second pass, <code class="literal">$filename</CODE
> is <code class="literal">fred.sec</CODE
>. And there is no third pass because the glob returns an empty string the third time it is called, perceived by the <code class="literal">while</CODE
> loop to be a false, causing an exit from the subroutine.</P
><p class="para">Within the <code class="literal">while</CODE
> loop, we open the file and verify that it is recent enough (less than seven days since the last modification). For the recent-enough files, we scan through as before.</P
><p class="para">Note that if there are no files that match <code class="literal">*.sec</CODE
> and are less than seven days old, the subroutine will exit without having set any secret words into the <code class="literal">%words</CODE
> array. In such a case, everyone must use the word <code class="literal">groucho</CODE
>. Oh well. (For <em class="emphasis">real</EM
> code, we would have added some check on the number of entries in <code class="literal">%words</CODE
> before returning, and <a class="indexterm" name="ch01-idx-2226-0"></A
><code class="literal">die</CODE
>'d if the check wasn't good. See the <code class="literal">keys</CODE
><a class="indexterm" name="ch01-idx-2227-0"></A
> function when we get to hashes in <a class="xref" href="ch05_01.htm" title="Hashes">Chapter 5, <cite class="chapter">Hashes</CITE
></A
>.)</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-2558">1.6.14 Listing the Secret Words</A
></H3
><p class="para">Well, the Chief Director of Secret Word Lists wants a <a class="indexterm" name="ch01-idx-2559-0"></A
>report of all the secret words currently in use, and how old they are. If we set aside the secret word program for a moment, we'll have time to write a reporting program for the Director.</P
><p class="para">First, let's get all of the secret words, by stealing some code from the <code class="literal">init_words()</CODE
> subroutine:</P
><pre class="programlisting">while ( defined ($filename = glob(&quot;*.sec&quot;)) ) {
    open (WORDSLIST, $filename) || 
            die &quot;can't open $filename: $!&quot;;
    if (-M WORDSLIST &lt;= 7.0) {
        while (defined ($name = &lt;WORDSLIST&gt;) {
            chomp ($name);
            $word = &lt;WORDSLIST&gt;;
            chomp ($word);
            ### new stuff will go here
        }
    }
    close (WORDSLIST) || die &quot;couldn't close $filename: $!&quot;;
}</PRE
><p class="para">At the point marked "new stuff will go here," we know three things: the name of the file (<code class="literal">$filename</CODE
>), someone's name (<code class="literal">$name</CODE
>), and that person's secret word (<code class="literal">$word</CODE
>). Here's a place to use Perl's report generating tools. We define a <a class="indexterm" name="ch01-idx-868924-0"></A
>format somewhere in the program (usually near the end, like a subroutine):</P
><pre class="programlisting"><a class="indexterm" name="ch01-idx-868968-0"></A
>format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.</PRE
><p class="para">The format definition begins with <code class="literal">format STDOUT =</CODE
>, and ends with a single period. The other two lines comprise the format itself. The first line of this format is a <a class="indexterm" name="ch01-idx-868925-0"></A
><em class="emphasis">field definition line</EM
> that specifies the number, length, and type of the fields. For this format, we have three fields. The line following a field definition line is always a <a class="indexterm" name="ch01-idx-868926-0"></A
><em class="emphasis">field value line</EM
>. The value line gives a list of expressions that will be evaluated when this format is used, and the results of those expressions will be plugged into the fields defined in the previous line.</P
><p class="para">We invoke this format with the <a class="indexterm" name="ch01-idx-4557-0"></A
><code class="literal">write</CODE
> function, as shown:</P
><pre class="programlisting">while ( defined($filename = glob(&quot;*.sec&quot;)) ) {
    open (WORDSLIST, $filename) || 
            die &quot;can't open $filename: $!&quot;;
    if (-M WORDSLIST &lt;= 7.0) {
        while (defined ($name = &lt;WORDSLIST&gt;) {
            chomp ($name);
            $word = &lt;WORDSLIST&gt;;
            chomp ($word);
            write; # invoke format STDOUT to STDOUT
        }
    }
    close (WORDSLIST) || die &quot;couldn't close $filename: $!&quot;;
}
format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.</PRE
><p class="para">When the format is invoked, Perl evaluates the field expressions and generates a line that it sends to the <code class="literal">STDOUT</CODE
> filehandle. Because <code class="literal">write</CODE
> is invoked once each time through the loop, we'll get a series of lines with text in columns, one line for each secret word entry.</P
><p class="para">Hmm. We haven't labeled the <a class="indexterm" name="ch01-idx-868969-0"></A
>columns. That's easy enough. We just need to add a <a class="indexterm" name="ch01-idx-868928-0"></A
>top-of-page format, as shown:</P
><pre class="programlisting">format STDOUT_TOP =
Page @&lt;&lt;
$%

Filename         Name       Word
================ ========== ============
.</PRE
><p class="para">This format is named <code class="literal">STDOUT_TOP</CODE
>, and will be used initially at the first invocation of the <code class="literal">STDOUT</CODE
> format, and again every time 60 lines of output to <code class="literal">STDOUT</CODE
> have been generated. These column headings line up with the columns from the <code class="literal">STDOUT</CODE
> format, so everything comes out tidy. </P
><p class="para">The first line of this format shows some constant text (<code class="literal">Page</CODE
>) along with a three-character field definition. The following line is a field value line, which in this  case has one expression. This expression is the <a class="indexterm" name="ch01-idx-868929-0"></A
><code class="literal">$%</CODE
> variable,[<a class="footnote" href="#ch01-pgfId-3703">19</A
>] which holds the number of pages printed&nbsp;- a very useful value in top-of-page formats.</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-3703">[19]</A
> More mnemonic aliases for these predefined scalar variables are available via the English module, which provides English names for Perl's special variables.</P
></DIV
></BLOCKQUOTE
><p class="para">The third line of the format is blank. Because this line does not contain any fields, the line following it is not a field value line. This blank line is copied directly to the output, creating a blank line between the page number and the column headers below.</P
><p class="para">The last two lines of the format also contain no fields, so they are copied as-is, directly to the output. So this format generates four lines, one of which has a part that changes from page to page. </P
><p class="para">Just tack this definition onto the previous program to get it to work. Perl notices the top-of-page format automatically. </P
><p class="para">Perl also has fields that are centered or right justified, and supports a <em class="emphasis">filled paragraph area</EM
> as well. More on these features when we get to formats in <a class="xref" href="ch11_01.htm" title="Formats">Chapter 11, <cite class="chapter">Formats</CITE
></A
>.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869613">1.6.15 Making Those Old Word Lists More Noticeable</A
></H3
><p class="para">As we are scanning through the <code class="literal">*.sec</CODE
> files in the current directory, we may find files that are too old. So far, we are simply skipping over those files. Let's go one step more&nbsp;- we'll <a class="indexterm" name="ch01-idx-868930-0"></A
><a class="indexterm" name="ch01-idx-868930-1"></A
>rename them to <code class="literal">*.sec.old</CODE
> so that a directory listing will quickly show us which files are too old, simply by name.</P
><p class="para">Here's how the <code class="literal">init_words()</CODE
> subroutine looks with this modification:</P
><pre class="programlisting">sub init_words {
    while ( defined($filename = glob(&quot;*.sec&quot;)) ) {
        open (WORDSLIST, $filename) || 
                die &quot;can't open $filename: $!&quot;;
        if (-M WORDSLIST &lt;= 7.0) {
            while (defined ($name = &lt;WORDSLIST&gt;)) {
                chomp ($name);
                $word = &lt;WORDSLIST&gt;;
                chomp ($word);
                $words{$name} = $word;
            }
            close (WORDSLIST) ||
                    die &quot;can't close $filename: $!&quot;;
        }
        else {
            # must close file before renaming it
            close (WORDSLIST) ||
                    die &quot;can't close $filename.old: $!&quot;
            rename ($filename,&quot;$filename.old&quot;) ||
                    die &quot;can't rename $filename: $!&quot;;
        }
    }
}</PRE
><p class="para">Notice the new <code class="literal">else</CODE
> part of the file age check. If the file is older than seven days, it gets renamed with the <a class="indexterm" name="ch01-idx-868931-0"></A
><code class="literal">rename</CODE
> function. This function takes two parameters, renaming the file named by the first parameter to the name given in the second parameter. </P
><p class="para">Perl has a complete range of file manipulation operators&nbsp;- nearly anything you can do to a file from a C program, you can also do from Perl.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869617">1.6.16 Maintaining a Last-Good-Guess Database</A
></H3
><p class="para">Let's keep track of when the most recent correct guess has been made for each user. One data structure that might seem to work at first glance is a hash. For example, the statement:</P
><pre class="programlisting">$last_good{$name} = <a class="indexterm" name="ch01-idx-868932-0"></A
>time;</PRE
><p class="para">assigns the current time in internal format (some large integer above 800 million, incrementing one number per second) to an element of <code class="literal">%last_good</CODE
> that has the name for a key. Over time, this method would seem to give us a database indicating the most recent time the secret word was guessed properly for each of the users who had invoked the program.</P
><p class="para">But, the hash doesn't have an existence between invocations of the program. Each time the program is invoked, a new hash is formed, so at most, we create a one-element hash and then immediately forget it when the program exits.</P
><p class="para">The <a class="indexterm" name="ch01-idx-868933-0"></A
><code class="literal">dbmopen</CODE
> function[<a class="footnote" href="#ch01-pgfId-3724">20</A
>] maps a hash out into a disk file (actually a pair of disk files) known as a <a class="indexterm" name="ch01-idx-868934-0"></A
>DBM. It's used like this:</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-3724">[20]</A
> On a specific database, use the more low-level <code class="literal">tie</CODE
> function, as detailed in Chapters <a class="olink" href="../prog/ch05_01.htm">5</A
> and <a class="olink" href="../prog/ch07_01.htm">7</A
> of <a class="citetitle" href="../prog/index.htm" title="Programming Perl"><cite class="citetitle">Programming Perl</CITE
></A
>, or in the <em class="emphasis">perltie</EM
>  documentation.</P
></DIV
></BLOCKQUOTE
><pre class="programlisting">dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
               die &quot;can't dbmopen lastdb: $!&quot;;
$last_good{$name} = time;
dbmclose (%last_good) || die &quot;can't dbmclose lastdb: $!&quot;;</PRE
><p class="para">The first statement performs the mapping, using the disk filenames of <code class="literal">lastdb.dir</CODE
> and <code class="literal">lastdb.pag</CODE
> (these names are the normal names for a DBM called <code class="literal">lastdb</CODE
>). Showing Perl's UNIX heritage, <a class="indexterm" name="ch01-idx-4577-0"></A
><code class="literal">dbmopen</CODE
> takes an octal file permission mask as the third argument. Although all Windows filesystems support file attributes of some sort, they are largely incompatible with the UNIX filesystem scheme used by Perl. The UNIX file permissions used for these two files, if the files must be created (as they will the first time through), is <code class="literal">0666</CODE
>. This mode means that anyone can read or write the files. This mode is usually the one that you want to use when working with files with read/write attributes.[<a class="footnote" href="#ch01-pgfId-4580">21</A
>]</P
><blockquote class="footnote"><div class="footnote"><p class="para"><a class="footnote" name="ch01-pgfId-4580">[21]</A
> The Win32::File module provides additional features for setting file attributes.  We'll discuss those features in more detail in <a class="xref" href="ch13_01.htm" title="File and Directory Manipulation">Chapter 13, <cite class="chapter">File and Directory Manipulation</CITE
></A
>.</P
></DIV
></BLOCKQUOTE
><p class="para">The Perl file <a class="indexterm" name="ch01-idx-871653-0"></A
>permission value is composed of a series of bits with read, write, and execute privileges for the user, the user's group, and everyone else. Traditionally, FAT filesystems only keep track of read and write privileges for the user, along with a few other tidbits of information, like whether the file is a hidden or a system file. We'll discuss file permissions and attributes in detail in <a class="xref" href="ch13_01.htm" title="File and Directory Manipulation">Chapter 13</A
>. For now, just trust us that you want to use <code class="literal">0666</CODE
> for creating DBM files.</P
><p class="para">The second statement shows that we use this mapped hash just like a normal hash. However, creating or updating an element of the hash automatically updates the disk files that form the DBM. And, when the hash is later accessed, the values within the hash come directly from the disk image. This gives the hash a life beyond the current invocation of the program&nbsp;- a persistence of its own.</P
><p class="para">The third statement disconnects the hash from the DBM, much like a file <code class="literal">close</CODE
> operation.</P
><p class="para">You can insert these three statements just ahead of the subroutine definitions.</P
><p class="para">Although the inserted statements maintain the database adequately (and even create the database initially), we don't have any way of examining the information yet. To do so, we can create a separate little program that looks something like this:</P
><pre class="programlisting">dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
                 die &quot;can't dbmopen lastdb: $!&quot;;
foreach $name (sort keys %last_good) {
    $when = $last_good{$name};
     $hours = (time - $when) / 3600; # compute hours ago
     write;
}

format STDOUT =
User @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;: last correct guess was @&lt;&lt;&lt; hours ago.
$name, $hours
.</PRE
><p class="para">We've got a few new operations here: a <code class="literal">foreach</CODE
><a class="indexterm" name="ch01-idx-868935-0"></A
> loop, sorting a list, and getting the keys of an hash.</P
><p class="para">First, the <a class="indexterm" name="ch01-idx-868936-0"></A
><code class="literal">keys</CODE
> function takes a hash name as an argument and returns a list of all the keys of that hash in some unspecified order. For the <code class="literal">%words</CODE
> hash defined earlier, the result is something like <code class="literal">fred</CODE
>, <code class="literal">barney</CODE
>, <code class="literal">betty</CODE
>, <code class="literal">wilma</CODE
>, in some unspecified order. For the <code class="literal">%last_good</CODE
> hash, the result will be a list of all users who have guessed their own secret word successfully.</P
><p class="para">The <a class="indexterm" name="ch01-idx-868937-0"></A
><code class="literal">sort</CODE
> function sorts the list alphabetically (just like passing a text file through the <em class="emphasis">sort</EM
> command). This function makes sure that the list processed by the <code class="literal">foreach</CODE
> statement is always in alphabetical order.</P
><p class="para">The Perl <a class="indexterm" name="ch01-idx-868938-0"></A
><code class="literal">foreach</CODE
> statement takes a list of values and assigns each one in turn to a scalar variable (here, <code class="literal">$name</CODE
>), executing the body of the loop (a block) once for each value. So, for five names in the <code class="literal">%last_good</CODE
> list, we get five passes through the loop, with <code class="literal">$name</CODE
> being a different value each time.</P
><p class="para">The body of the <code class="literal">foreach</CODE
> loop loads up a couple of variables used within the <code class="literal">STDOUT</CODE
> format, and then invokes the format. Note that we figure out the age of the entry by subtracting the stored system <a class="indexterm" name="ch01-idx-3759-0"></A
>time (in the array) from the current time (as returned by <code class="literal">time</CODE
>), and then divide that by 3600 (to convert seconds to hours).</P
><p class="para">Perl also provides easy ways to create and maintain text-oriented databases and fixed-length-record databases. These databases are described in <a class="xref" href="ch17_01.htm" title="Database Manipulation">Chapter 17, <cite class="chapter">Database Manipulation</CITE
></A
>.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="ch01-pgfId-869201">1.6.17 The Final Programs</A
></H3
><p class="para">Here are the programs from this stroll in their final form so that you can play with them.</P
><p class="para">First, the "say hello" program:</P
><pre class="programlisting">init_words();
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
<a class="indexterm" name="ch01-idx-868979-0"></A
>if ($name =~ /^erik\b/i) { # back to the other way :-)
    <a class="indexterm" name="ch01-idx-868972-0"></A
>print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = <a class="indexterm" name="ch01-idx-868973-0"></A
>&lt;STDIN&gt;;
     <a class="indexterm" name="ch01-idx-868974-0"></A
>chomp ($guess);
     while (! good_word($name,$guess)) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
     }
}
<a class="indexterm" name="ch01-idx-868975-0"></A
>dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
                 die &quot;can't dbmopen lastdb: $!&quot;;
$last_good{$name} = time;
<a class="indexterm" name="ch01-idx-868976-0"></A
>dbmclose (%last_good) || die &quot;can't dbmclose lastdb: $!&quot;;
<a class="indexterm" name="ch01-idx-868977-0"></A
>sub init_words {
    while ( defined($filename = glob(&quot;*.sec&quot;)) ) {
        open (WORDSLIST, $filename) || 
                die &quot;can't open $filename: $!&quot;;
        if (-M WORDSLIST &lt;= 7.0) {
            while (defined ($name = &lt;WORDSLIST&gt;)) {
                chomp ($name);
                $word = &lt;WORDSLIST&gt;;
                chomp ($word);
                $words{$name} = $word;
            }
            close (WORDSLIST) ||
                    die &quot;can't close $filename: $!&quot;;
        }
        else {
            # must close file before renaming it
            close (WORDSLIST) ||
                    die &quot;can't close $filename.old: $!&quot;
            rename ($filename,&quot;$filename.old&quot;) ||
                    die &quot;can't rename $filename: $!&quot;;
        }
    }
}
sub good_word {
  my($somename,$someguess) = @_; # name the parameters
  $somename =~ <a class="indexterm" name="ch01-idx-868983-0"></A
>s/\W.*//; # delete everything after first word
  $somename =~ <a class="indexterm" name="ch01-idx-868984-0"></A
>tr/A-Z/a-z/; # lowercase everything
  if ($somename <a class="indexterm" name="ch01-idx-868985-0"></A
>eq &quot;erik&quot;) { # should not need to guess
    return 1; # <a class="indexterm" name="ch01-idx-868986-0"></A
>return value is true
  } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
    return 1; # return value is true
  } else {
    <a class="indexterm" name="ch01-idx-868987-0"></A
>log_failure($somename,$someguess);
    return 0; # return value is false
  }
}

sub log_failure {
    my($somename,$someguess) = @_; # name the parameters
    open(LOG, &quot;&gt;&gt;failures.log&quot;) || die &quot;failures.log: $!&quot;;
    print LOG &quot;bad news: $somename guessed $someguess\n&quot;;
    close (LOG)  || die &quot;can't close failures.log: $!&quot;;
}</PRE
><p class="para">Next, we have the secret word lister:</P
><pre class="programlisting">while ( defined($filename = glob(&quot;*.sec&quot;)) ) {
    open (WORDSLIST, $filename) || 
               die &quot;can't open $filename: $!&quot;;
    if (-M WORDSLIST &lt;= 7.0) {
        while (defined ($name = &lt;WORDSLIST&gt;)) {
            chomp ($name);
            $word = &lt;WORDSLIST&gt;;
             chomp ($word);
              <a class="indexterm" name="ch01-idx-4746-0"></A
>write; # invoke format STDOUT to STDOUT
        }
    }
    close (WORDSLIST) || die &quot;can't close $filename: $!&quot;;
}

<a class="indexterm" name="ch01-idx-4753-0"></A
>format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.
format STDOUT_TOP =
Page @&lt;&lt;
$%

Filename         Name       Word
================ ========== ============
.</PRE
><p class="para">And finally, the last-time-a-word-was-used display program:</P
><pre class="programlisting"><a class="indexterm" name="ch01-idx-868990-0"></A
>dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
                 die &quot;can't dbmopen lastdb: $!&quot;;
<a class="indexterm" name="ch01-idx-868991-0"></A
>foreach $name (sort keys %last_good) {
    $when = $last_good{$name};
    $hours = (<a class="indexterm" name="ch01-idx-868992-0"></A
>time - $when) / 3600; # compute hours ago
    write;
}
dbmclose(%last_good) || die &quot;can't dbmclose lastdb: $!&quot;;
format STDOUT =
User @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;: last correct guess was @&lt;&lt;&lt; hours ago.
$name, $hours
.</PRE
><p class="para">Together with the secret word lists (files named <code class="replaceable"><i>something</I
></CODE
><code class="literal">.sec</CODE
> in the current directory) and the database, <code class="literal">lastdb.dir</CODE
> and <code class="literal">lastdb.pag</CODE
>, you'll have all you need.</P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="sect1" href="ch01_05.htm" title="1.5 Basic Concepts"><img src="../gifs/txtpreva.gif" alt="Previous: 1.5 Basic Concepts" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Learning Perl on Win32 Systems"><img src="../gifs/txthome.gif" alt="Learning Perl on Win32 Systems" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="sect1" href="ch01_07.htm" title="1.7 Exercises"><img src="../gifs/txtnexta.gif" alt="Next: 1.7 Exercises" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">1.5 Basic Concepts</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">1.7 Exercises</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.html" title="The Perl CD Bookshelf">Library Home</A
> | <a href="../perlnut/index.htm" title="Perl in a Nutshell">Perl in a Nutshell</A
> | <a href="../learn/index.htm" title="Learning Perl">Learning Perl</A
> | <a href="index.htm" title="Learning Perl on Win32 Systems">Learning Perl on Win32</A
> | <a href="../prog/index.htm" title="Programming Perl">Programming Perl</A
> | <a href="../advprog/index.htm" title="Advanced Perl Programming">Advanced Perl Programming</A
> | <a href="../cookbook/index.htm" title="Perl Cookbook">Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
