<HTML
><HEAD
><TITLE
>[Chapter 5] 5.2 Sequential Control Statements</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:55:48Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch05_01.htm"
TITLE="5. Conditional and Sequential Control"><LINK
REL="prev"
HREF="ch05_01.htm"
TITLE="5.1 Conditional Control Statements"><LINK
REL="next"
HREF="ch06_01.htm"
TITLE="6. Database Interaction and Cursors"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_01.htm"
TITLE="5.1 Conditional Control Statements"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.1 Conditional Control Statements"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch05_01.htm"
TITLE="5. Conditional and Sequential Control"
>Chapter 5<BR>Conditional and Sequential Control</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch06_01.htm"
TITLE="6. Database Interaction and Cursors"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6. Database Interaction and Cursors"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2"
>5.2 Sequential Control Statements</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-643844-1"
></A
>Certain PL/SQL control structures offer structured methods for processing executable statements in your program. You use an IF statement to test a condition to determine which parts of the code to execute. You use one of the LOOP variations (described in <A
CLASS="xref"
HREF="ch07_01.htm"
>Chapter 7, <CITE
CLASS="chapter"
>Loops</CITE
></A
>) to execute a section of code more than once. In addition to these well-structured approaches to program control, PL/SQL offers two other statements to handle out of the ordinary requirements for sequential processing: GOTO and NULL. The GOTO statement allows you to perform unconditional branching to another executable statement in the same execution section of a PL/SQL block. The NULL statement gives you a way to tell the compiler to do...absolutely nothing. </P
><P
CLASS="para"
>The following sections explain the implementation of the GOTO and NULL statements in PL/SQL. As with other constructs in the language, use them with care and use them appropriately, and your programs will be stronger for it. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.1"
>5.2.1 The GOTO Statement</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-643845-1"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-643845-2"
></A
> <A
CLASS="indexterm"
NAME="ch05-idx-643845-3"
></A
>The GOTO statement performs unconditional branching to a named label. The general format for a GOTO statement is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>GOTO label_name;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where label_name is the name of a label. </P
><P
CLASS="para"
>This GOTO label is defined in the program as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;&lt;label_name&gt;&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4736"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4738"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4740"
></A
>You must surround the label name with double enclosing angle brackets (<KBD
CLASS="command"
>&lt;&lt; &gt;&gt;</KBD
>). In this case, the label names a loop. This label can then be appended to the END LOOP statement, making the termination of the loop more visible. You can also issue an EXIT statement for a particular labeled loop from within another (enclosed) loop. Finally, you can GOTO that loop label, even though it was "designed" for a loop. (<A
CLASS="xref"
HREF="ch07_01.htm"
>Chapter 7</A
> describes the details of loop processing.) </P
><P
CLASS="para"
>When PL/SQL encounters a GOTO statement, it immediately shifts control to the first executable statement following the label. </P
><P
CLASS="para"
>Contrary to popular opinion (including mine), the GOTO statement can come in handy. There are cases where a GOTO statement can simplify the logic in your program. On the other hand, PL/SQL provides so many different control constructs and modularization techniques that you can almost always find a better way to do something than with a GOTO. </P
><P
CLASS="para"
>There are several restrictions regarding the GOTO statement, described in the sections below. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.1.1"
>5.2.1.1 At least one executable statement must follow a label</A
></H4
><P
CLASS="para"
>A label itself is not an executable statement (notice that it does not have a semicolon (<KBD
CLASS="command"
>;</KBD
>) after the label brackets), so it cannot take the place of one. All of the uses of the loop label in the following blocks are illegal because the labels are not followed by an executable statement: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF status_inout = 'COMPLETED'
THEN
   &lt;&lt;all_done&gt;&gt; /* Illegal! */
ELSE
   schedule_activity;
END IF;

DECLARE
   CURSOR company_cur IS ...;
BEGIN
   FOR company_rec IN company_cur
   LOOP
      apply_bonuses (company_rec.company_id);
      &lt;&lt;loop_termination&gt;&gt; /* Illegal! */
   END LOOP;
END;

FUNCTION new_formula (molecule_in IN NUMBER) RETURN VARCHAR2
IS
BEGIN
   ... construct formula for molecule ...
   RETURN formula_string;

   &lt;&lt;all_done&gt;&gt; /* Illegal! */

END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.1.2"
>5.2.1.2 Target labels and scope of GOTO</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-643847-1"
></A
> The target label must be in the same scope as the GOTO statement. In the context of the GOTO statement, each of the following constructs maintains its own scope: functions, procedures, anonymous blocks, IF statements, LOOP statements, and exception handlers. <A
CLASS="indexterm"
NAME="AUTOID-4757"
></A
>All of the code examples below generate the same PL/SQL error: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLS-00375: illegal GOTO statement; this GOTO cannot branch to label </PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>IF conditions</EM
>. The only way to enter an IF statement is through an evaluation to TRUE of an IF condition. Therefore, this code produces an error: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>GOTO label_inside_IF;
IF status = 'NEW'
THEN
   &lt;&lt;label_inside_IF&gt;&gt; /* Out of scope! */
   show_new_one;
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>BEGIN statements</EM
>. The only way to enter a block-within-a-block is through the sub-block's BEGIN statement. PL/SQL insists on orderly entrances and exits. This code produces an error because it doesn't comply with this structure: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>GOTO label_inside_subblock;
BEGIN
   &lt;&lt;label_inside_subblock&gt;&gt; /* Crosses block boundary! */
   NULL;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Scope of IF statements</EM
>. Each IF clause of the IF statement is its own scope. A GOTO may not transfer from one clause to another. This code produces an error: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF status = 'NEW'
THEN
   &lt;&lt;new_status&gt;&gt;
   GOTO old_status; /* Crosses IF clause boundary! */
ELSIF status = 'OLD'
THEN
   &lt;&lt;old_status&gt;&gt;
   GOTO new_status; /* Crosses IF clause boundary! */
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Don't jump into the middle of a loop</EM
>. You cannot jump into the middle of a loop with a GOTO. This code produces an error: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR month_num IN 1 .. 12
LOOP
   &lt;&lt;do_a_month&gt;&gt;
   schedule_activity (month_num);
END LOOP;
GOTO do_a_month; /* Can't go back into loop. */</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4780"
></A
> Don't GOTO a local module. You also cannot issue a GOTO inside of a module to a label in the main body. This code produces an error: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   FUNCTION local_null IS
   BEGIN
      &lt;&lt;descrip_case_statement&gt;&gt;
      NULL;
   END;
BEGIN
   GOTO descrip_case_statement; /* Label not visible here. */
END;</PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.1.3"
>5.2.1.3 Target labels and PL/SQL blocks</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4788"
></A
>The target label must be in the same part of the PL/SQL block as the GOTO statement. A GOTO in the executable section may not go to a label in the exception section. Similarly, a GOTO in the exception section may not go to a label in the executable section. A GOTO in an exception handler may reference a label in the same handler. <A
CLASS="indexterm"
NAME="AUTOID-4791"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4792"
></A
> The code example below generates the same PL/SQL error shown in the previous section (PLS-00375): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   /*
   || The label and GOTO must be in the same section!
   */
   GOTO out_of_here;
EXCEPTION
   WHEN OTHERS
   THEN
      &lt;&lt;out_of_here&gt;&gt; /* Out of scope! */
      NULL;
END;<A
CLASS="indexterm"
NAME="AUTOID-4794"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-4795"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.2"
>5.2.2 The NULL Statement</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-643852-1"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-643852-2"
></A
> Usually when you write a statement in a program, you want it to do something. There are cases, however, when you want to tell PL/SQL to do absolutely nothing, and that is where the NULL statement comes in handy. The NULL statement has the following format: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NULL;
</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Well, you wouldn't want a do-nothing statement to be complicated, would you? The NULL statement is simply the reserved word followed by a semicolon (<KBD
CLASS="command"
>;</KBD
>) to indicate that this is a statement and not the NULL value reserved word. The NULL statement does nothing except pass control to the next executable statement. </P
><P
CLASS="para"
>Why would you want to use the NULL statement? There are several reasons, described in the following sections. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.2.1"
>5.2.2.1 Improving the readability of your program </A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4812"
></A
>There are many situations in your program where you logically do not want to take any action. In most of these cases, PL/SQL will let you write nothing and the program will execute as you wish. The only drawback is the ambiguity surrounding this solution: it is not clear to a person examining the program that you knowingly did not take any action. </P
><P
CLASS="para"
>Consider the IF statement. When you write an IF statement you do not have to include an ELSE clause. To produce a report based on a selection, you can code: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF :report.selection = 'DETAIL'
THEN
   exec_detail_report;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>What should the program have been doing if the report selection is not `DETAIL'? One would assume that the program was supposed to do nothing. But because this is not explicitly stated in the code, one is left to wonder if perhaps there was an oversight. If, on the other hand, you include an explicit ELSE clause that does nothing, you state very clearly, "Don't worry, I thought about this possibility and I really want nothing to happen." </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF :report.selection = 'DETAIL'
THEN
   exec_detail_report;
ELSE
   NULL;
END IF;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.2.2"
>5.2.2.2 Nullifying the effect of a raised exception</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4822"
></A
>The optional exception section of a program contains one or more exception handlers. These handlers trap and handle errors that have been raised in your program. The structure and flow of the exception section is similar in structure and flow to a conditional case statement, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN &lt;exception_name1&gt;
   THEN
      executable_statements;

   WHEN &lt;exception_nameN&gt;
   THEN
      executable_statements;

   WHEN OTHERS
   THEN
      executable_statements;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If &lt;exception_name1&gt; is raised, then execute its statements; if &lt;exception_nameN&gt; is raised, then execute its statements; and so on. The WHEN OTHERS clause handles any exceptions not handled in the previous WHEN clauses (it is just like the ELSE clause of the IF statement). You can use the NULL statement to make sure that a raised exception halts execution of the current PL/SQL block, but does not propagate any exceptions to enclosing blocks: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE calc_avg_sales
BEGIN
   :sales.avg := :sales.month1 / :sales.total;
EXCEPTION
   WHEN ZERO_DIVIDE
   THEN
      :sales.avg := 0;
      RAISE FORM_TRIGGER_FAILURE;

   WHEN OTHERS THEN NULL;

END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If total sales are zero, then an exception is raised, the average is set to zero, and the trigger processing in Oracle Forms is halted. If any other exceptions occur (such as VALUE_ERROR, which would be raised if the number generated by the calculation is larger than the sales.avg item allows), then the procedure does nothing and processing continues. </P
><P
CLASS="para"
>Even though the WHEN OTHERS clause of the exception section is like the ELSE clause of an IF statement, the impact of a NULL statement is very different in each of these statements. The addition of an ELSE NULL clause to the IF statement has an impact only on the readability of the code. The IF statement executes in precisely the same way it would have without the ELSE NULL clause. </P
><P
CLASS="para"
>When you include an exception handler with the NULL executable statement, you are saying, in effect: "End processing in the current PL/SQL block and move to the enclosing block, but otherwise take no action." This is very different from leaving out the exception handler altogether. If there is no exception handler, then PL/SQL raises the exception in the enclosing block again, and continues to do so until the last block, at which point it becomes an unhandled exception and halts the program. A "null" exception handler passes control back to the enclosing block, but does not cause the exception to be raised again. </P
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch08_01.htm"
>Chapter 8, <CITE
CLASS="chapter"
>Exception Handlers</CITE
></A
>, for more detailed information about exceptions. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.2.3"
>5.2.2.3 Supporting top-down design of modules</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4836"
></A
>With top-down design (also known as top-down decomposition), you move from a general description of your system through step-by-step refinements of that idea to the modules which implement that system, and finally to the code that implements the modules. By moving through levels of abstraction, your mind concentrates on a relatively small number of issues at a time and can better process the details. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4840"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4842"
></A
>From a programming perspective, you implement top-down design by creating "stubs," or dummy programs. A stub will have the name and parameter list you need, but not have anything under the covers. Using stubs you define the API (application programmatic interface), which indicates the way that the different modules connect to each other. </P
><P
CLASS="para"
>In order for a PL/SQL program to compile, it must have at least one executable statement. The smallest, most nonintrusive program you can build will therefore be composed of a single NULL statement. Here are sample stubs for both a procedure and a function: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE revise_timetable (year_in IN NUMBER) IS
BEGIN
   NULL;
END;

FUNCTION company_name (company_id_in IN NUMBER) RETURN VARCHAR2 IS
BEGIN
   RETURN NULL;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The NULL statement gives you a way to quickly cobble together the programmatic interface you need to formulate the functional hierarchy of your application. I'd like to say that this is half the battle, but I am not really sure that is so. You still have to figure out how to fill in all of those stubs. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-2.2.4"
>5.2.2.4 Using NULL with GOTO to avoid additional statement execution</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4850"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4853"
></A
>In some cases, you can pair NULL with GOTO to avoid having to execute additional statements. Most of you will never have to use the GOTO statement; there are very few occasions where it is truly needed. If you ever do use GOTO, however, you should remember that when you GOTO a label, at least one executable statement must follow that label. In the following example, I use a GOTO statement to quickly move to the end of my program if the state of my data indicates that no further processing is required: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE process_data (data_in IN orders%ROWTYPE,
                        data_action IN VARCHAR2) IS
BEGIN
   -- First in series of validations.
   IF data_in.ship_date IS NOT NULL
   THEN
      status := validate_shipdate (data_in.ship_date);
      IF status != 0 THEN GOTO end_of_procedure;
   END IF;

   -- Second in series of validations.
   IF data_in.order_date IS NOT NULL
   THEN
      status := validate_orderdate (data_in.order_date);
      IF status != 0 THEN GOTO end_of_procedure;
   END IF;

   ... more validations ...

   &lt;&lt; end_of_procedure &gt;&gt;
   NULL;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With this approach, if I encounter an error in any single section, I use the GOTO to bypass all remaining validation checks. Because I do not have to do anything at the termination of the procedure, I place a NULL statement after the label because at least one statement is required there.<A
CLASS="indexterm"
NAME="AUTOID-4859"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4860"
></A
> </P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_01.htm"
TITLE="5.1 Conditional Control Statements"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.1 Conditional Control Statements"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch06_01.htm"
TITLE="6. Database Interaction and Cursors"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6. Database Interaction and Cursors"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.1 Conditional Control Statements</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6. Database Interaction and Cursors</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
