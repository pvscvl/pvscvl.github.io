<HTML
><HEAD
><TITLE
>[Chapter 15] 15.6 Parameters</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:03:24Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch15_01.htm"
TITLE="15. Procedures and Functions"><LINK
REL="prev"
HREF="ch15_05.htm#SQL2-CH-15-SECT-5.3"
TITLE="15.5 Functions"><LINK
REL="next"
HREF="ch15_07.htm"
TITLE="15.7 Local Modules"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_05.htm#SQL2-CH-15-SECT-5.3"
TITLE="15.5 Functions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 15.5 Functions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch15_01.htm"
TITLE="15. Procedures and Functions"
>Chapter 15<BR>Procedures and Functions</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_07.htm"
TITLE="15.7 Local Modules"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 15.7 Local Modules"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6"
>15.6 Parameters</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948980-1"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948980-2"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948980-3"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948980-4"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948980-5"
></A
>Procedures and functions can both use parameters to pass information back and forth between the module and the calling PL/SQL block. </P
><P
CLASS="para"
>The parameters of a module are at least as important as the code that implements the module (the module's body). Sure, you have to make certain that your module fulfills its promise. But the whole point of creating a module is that it can be called, you hope by more than one other module. If the parameter list is confusing or badly designed, it will be very difficult for programmers to make use of the module. The result will be that few people will use that module. And it doesn't much matter how well you implemented a program that no one uses. </P
><P
CLASS="para"
>Many developers do not give enough attention to a module's set of parameters. Considerations regarding parameters include: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>The number of parameters.</EM
> Too few parameters can limit the reusability of your program. Too many parameters, and no one will want to reuse your program. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>The types of parameters.</EM
> Should you use read-only, write-only, or read-write parameters? </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>The names of parameters.</EM
> How should you name your parameters so that their purpose in a module is properly and easily understood? </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Default values for parameters.</EM
> How do you set defaults? When should a parameter be given defaults and when should the programmer be forced to enter a value? </P
></LI
></UL
><P
CLASS="para"
>PL/SQL offers many different features to help you design parameters effectively. This section covers all elements of parameter definition. <A
CLASS="xref"
HREF="ch22_01.htm"
>Chapter 22, <CITE
CLASS="chapter"
>Code Design Tips</CITE
></A
>, offers a number of tips for designing your parameters for maximum readability and code reusability. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.1"
>15.6.1 Defining the Parameters</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13907"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13910"
></A
>Formal parameters are defined in the parameter list of the program. A parameter definition parallels closely the syntax for declaring variables in the declaration section of a PL/SQL block. There is one important distinction: a parameter declaration must be unconstrained. </P
><P
CLASS="para"
>A <EM
CLASS="emphasis"
>constrained declaration</EM
> is one that constrains or limits the kind of value that can be assigned to a variable declared with that datatype. An <EM
CLASS="emphasis"
>unconstrained declaration</EM
> is one that does not limit values in this way. The following declaration of the variable company_name constrains the variable to 60 characters: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   company_name VARCHAR2(60);
BEGIN</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you declare a parameter, however, you must leave out the constraining part of the declaration: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE display_company (company_name IN VARCHAR2) IS ...</PRE
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.1.1"
>15.6.1.1 %TYPE and %ROWTYPE</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13922"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13924"
></A
>You can use the %TYPE and %ROWTYPE anchoring attributes in the parameter list, even if the %TYPE references a constrained declaration somewhere back along the line, as in a CREATE TABLE statement. The following parameter list will compile just fine: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE fun_and_games (ride_id_in IN rides.ride_id%TYPE)</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13928"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13932"
></A
>If you are using PL/SQL Version 2, you can also declare parameters as PL/SQL tables through use of the TABLE type statement, as shown in this example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE pet_hotel
IS
   /* Define a table type and declare a table */
   TYPE breeds_type IS
      TABLE OF breed.breed_name%TYPE INDEX BY BINARY_INTEGER;
   TYPE avail_rooms_type IS
      TABLE OF room.room_number%TYPE INDEX BY BINARY_INTEGER;

   /* Specification of function which takes a table argument */
   FUNCTION room_by_breeds (breed_table_in IN breeds_type)
      RETURN avail_rooms_type;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The %TYPE and %ROWTYPE attributes are allowed for parameters because both result in unconstrained declarations. The actual sizes of the parameters depend on the structures of the tables and columns to which the attributes point. This size is resolved only at compilation time. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.2"
>15.6.2 Parameter Modes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13939"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13942"
></A
>When you define the parameter you also specify the way in which the parameter can be used. There are three different modes of parameters: </P
><P
CLASS="para"
>The mode determines how the program can use and manipulate the value assigned to the formal parameter. You specify the mode of the parameter immediately after the parameter name and before the parameter's datatype and optional default value. The following procedure header uses all three modes of parameters: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE predict_activity
   (last_date_in IN DATE,
    task_desc_inout IN OUT VARCHAR2,
    next_date_out OUT DATE)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The predict_activity procedure takes in two pieces of information: the date of the last activity and a description of the activity. It then returns or sends out two pieces of information: a possibly modified task description and the date of the next activity. Because the task_desc_inout parameter is IN OUT, the program can both read the value of the argument and change the value of that argument. </P
><P
CLASS="para"
>Let's look at each of these parameter modes in detail.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.2.1"
>15.6.2.1 IN mode</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13952"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13955"
></A
>The IN parameter allows you to pass values in to the module, but will not pass anything out of the module and back to the calling PL/SQL block. In other words, for the purposes of the program, its IN parameters function like constants. Just like constants, the value of the formal IN parameter cannot be changed within the program. You cannot assign values to the IN parameter or in any other way modify its value. </P
><P
CLASS="para"
>IN is the default mode for parameters. If you do not specify a parameter mode, then the parameter is automatically considered an IN parameter. I recommend, however, that you always specify a parameter mode with your parameters. Your intended use of the parameter is then documented explicitly in the code itself. </P
><P
CLASS="para"
>IN parameters can be given default values in the program header (see <A
CLASS="xref"
HREF="ch15_06.htm#SQL2-CH-15-SECT-6.2.3"
>Section 15.6.5, "Default Values"</A
>). </P
><P
CLASS="para"
>The actual parameter for an IN parameter can be a variable, a named constant, a literal, or an expression. All of the following calls to display_title are valid: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   happy_title CONSTANT VARCHAR2(30)    := 'HAPPY BIRTHDAY';
   changing_title VARCHAR2(30) := 'Happy Anniversary';
   spc VARCHAR2(1) := ' ';
BEGIN
   display_title ('Happy Birthday');             -- a literal
   display_title (happy_title);                  -- a constant

   changing_title := happy_title;

   display_title (changing_title);               -- a variable
   display_title ('Happy' || spc || 'Birthday'); -- an expression
   display_title (INITCAP (happy_title));        -- another expression
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>What if you want to transfer data out of your program? For that, you will need an OUT or an IN OUT parameter. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.2.2"
>15.6.2.2 OUT mode</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13966"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13969"
></A
>An OUT parameter is the opposite of the IN parameter, but I suppose you already had that figured out. Use the OUT parameter to pass a value back from the program to the calling PL/SQL block. An OUT parameter is like the return value for a function, but it appears in the parameter list and you can, of course, have as many OUT parameters as you like. </P
><P
CLASS="para"
>Inside the program, an OUT parameter acts like a variable that has not been initialized. In fact, the OUT parameter has no value at all until the program terminates successfully (without raising an exception, that is). During the execution of the program, any assignments to an OUT parameter are actually made to an internal copy of the OUT parameter. When the program terminates successfully and returns control to the calling block, the value in that local copy is then transferred to the actual OUT parameter. That value is then available in the calling PL/SQL block. </P
><P
CLASS="para"
>There are several consquences of these rules concerning OUT parameters: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot assign an OUT parameter's value to another variable or even use it in a re-assignment to itself. An OUT parameter can be found only on the left side of an assignment operation. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You also cannot provide a default value to an OUT parameter. You can only assign a value to an OUT parameter inside the body of the module. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Any assignments made to OUT parameters are rolled back when an exception is raised in the program. Because the value for an OUT parameter is not actually assigned until a program completes successfully, any intermediate assignments to OUT parameters are therefore ignored. Unless an exception handler traps the exception and then assigns a value to the OUT parameter, no assignment is made to that parameter. The variable will retain the same value it had before the program was called. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An OUT actual parameter has to be a variable. It cannot be a constant, literal, or expression, since these formats do not provide a receptacle in which PL/SQL can place the OUTgoing value. </P
></LI
></UL
><P
CLASS="para"
>OUT parameters are very restrictive in how they can and should be used. These restrictions place more of a burden on the programmer to understand the parameter modes and their impact. On the other hand, the OUT parameter provides a level of security and a narrowing of functionality which, when appropriate, is invaluable. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.2.3"
>15.6.2.3 The IN OUT mode</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13986"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13989"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13992"
></A
>With an IN OUT parameter, you can pass values into the program and return a value back to the calling program (either the original, unchanged value or a new value set within the program). The IN OUT parameter shares two restrictions with the OUT parameter: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>An IN OUT parameter cannot have a default value.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An IN OUT actual parameter or argument must be a variable. It cannot be a constant, literal, or expression, since these formats do not provide a receptacle in which PL/SQL can place the outgoing value. </P
></LI
></OL
><P
CLASS="para"
>Beyond these restrictions, none of the other restrictions apply. </P
><P
CLASS="para"
>You can use the IN OUT parameter in both sides of an assignment, because it functions like an initialized, rather than uninitialized, variable. PL/SQL does not lose the value of an IN OUT parameter when it begins execution of the program. Instead, it uses that value as necessary within the program. </P
><P
CLASS="para"
>The combine_and_format_names procedure shown here combines the first and last names into a full name in the format specified ("LAST, FIRST" or "FIRST LAST"). It uses all three different modes of parameters: IN, IN OUT, and OUT. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE combine_and_format_names
   (first_name_inout IN OUT VARCHAR2,
    last_name_inout IN OUT VARCHAR2,
    full_name_out OUT VARCHAR2,
    name_format_in IN VARCHAR2 := 'LAST, FIRST')
IS
BEGIN
   /* Upper-case the first and last names. */
   first_name_inout := UPPER (first_name_inout);
   last_name_inout := UPPER (last_name_inout);

   /* Combine the names as directed by the name format string. */
   IF name_format_in = 'LAST, FIRST'
   THEN
      full_name_out := last_name_inout || ', ' || first_name_inout;

   ELSIF name_format_in = 'FIRST LAST'
   THEN
      full_name_out := first_name_inout || ' ' || last_name_inout;
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first name and last name parameters must be IN OUT. I need the incoming names for the combine action, and I will uppercase the first and last names for future use in the program (thereby enforcing the application standard of all uppercase for names of people and things). </P
><P
CLASS="para"
>The full_name_out is just an OUT parameter because I create the full name from its parts. If the actual parameter used to receive the full name has a value going into the procedure, I certainly don't want to use it! Finally, the name_format_in parameter is a mere IN parameter since it is used to determine how to format the full name, but is not changed or changeable in any way. </P
><P
CLASS="para"
>Each parameter mode has its own characteristics and purpose. You should choose carefully which mode to apply to each of your parameters so that the parameter is used properly within the module. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.3"
>15.6.3 Actual and Formal Parameters</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948988-1"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948988-2"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948988-3"
></A
>When we talk about parameters, we need to distinguish between two different kinds of parameters: actual and formal parameters. The formal parameters are the names that are declared in the parameter list of the header of a module. The actual parameters are the values or expressions placed in the parameter list of the actual call to the module. </P
><P
CLASS="para"
>Let's examine the differences between actual and formal parameters using the example of tot_sales. Here, again, is tot_sales' header: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION tot_sales
   (company_id_in IN company.company_id%TYPE,
    status_in IN order.status_code%TYPE := NULL)
RETURN std_types.dollar_amount;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The formal parameters of tot_sales are:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>company_id_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The primary key of the company</P
></DD
><DT
CLASS="term"
>status_in </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The status of the orders to be included in the sales calculation</P
></DD
></DL
><P
CLASS="para"
>They do not exist outside of the function. You can think of them as place holders for real or actual parameter values that are passed into the function when it is used in a program. </P
><P
CLASS="para"
>When you use tot_sales in your code, the formal parameters disappear. In their place you list the actual parameters or variables, whose values will be passed to tot_sales. In the following example, the company_id variable contains the primary key pointing to a company record. In the first three calls to tot_sales a different, hardcoded status is passed to the function. The last call to tot_sales does not specify a status; in this case the function assigns the default value (provided in the function header) to the status_in parameter: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>new_sales      := tot_sales (company_id, 'N');
paid_sales     := tot_sales (company_id, 'P');
shipped_sales  := tot_sales (company_id, 'S');
all_sales      := tot_sales (company_id);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When tot_sales is called, all the actual parameters are evaluated. The results of the evaluations are then assigned to the formal parameters inside the function to which they correspond. </P
><P
CLASS="para"
>The actual parameters must be evaluated because they can be expressions, as well as pointers, to non-PL/SQL objects such as bind variables in the development tool. </P
><P
CLASS="para"
>The formal parameter and the actual parameter that corresponds to the formal parameter (when called) must be of the same or compatible datatypes. PL/SQL will perform datatype conversions for you in many situations. Generally, however, you are better off avoiding all implicit datatype conversions so you are sure of what is happening in your code. Use a formal conversion function like TO_CHAR or TO_DATE (see <A
CLASS="xref"
HREF="ch14_01.htm"
>Chapter 14, <CITE
CLASS="chapter"
>Conversion Functions</CITE
></A
>), so you know exactly what kind of data you are passing into your modules. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.4"
>15.6.4 Matching Actual and Formal Parameters in PL/SQL</A
></H3
><P
CLASS="para"
>How does PL/SQL know which actual parameter goes with which formal parameter when a program is executed? PL/SQL actually offers you two different ways to make the association: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Positional notation</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Associate the actual parameter implicitly (by position) with the formal parameter. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Named notation</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Associate an actual parameter explicitly (by name) with the formal parameter. </P
></DD
></DL
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.4.1"
>15.6.4.1 Positional notation</A
></H4
><P
CLASS="para"
>In every example you've seen so far, I have employed positional notation in order to guide PL/SQL through the parameters. With positional notation, PL/SQL relies on the relative positions of the parameters to make the correspondence. PL/SQL associates the nth actual parameter in the call to a program with the nth formal parameter in the program's header. </P
><P
CLASS="para"
>With the tot_sales example shown below, PL/SQL associates the first actual parameter, :order.company_id, with the first formal parameter, company_id_in. It then associates the second actual parameter, N, with the second format parameter, status_in: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>new_sales := tot_sales (:order.company_id, 'N');

FUNCTION tot_sales
   (company_id_in IN company.company_id%TYPE,
    status_in IN order.status_code%TYPE := NULL)
RETURN std_types.dollar_amount;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now you know the name for the way compilers pass values through parameters to modules. Positional notation, shown graphically in <A
CLASS="xref"
HREF="ch15_06.htm#SQL2-CH-15-SECT-6.2.3"
>Figure 15.11</A
>, is certainly the most obvious method. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-15-FIG-12"
>Figure 15.11: Matching actual with formal parameters (positional notation)</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1511.gif"
ALT="Figure 15.11"></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.4.2"
>15.6.4.2 Named notation</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948990-1"
></A
>With named notation, you explicitly associate the formal parameter (the name of the parameter) with the actual parameter (the value of the parameter), right in the call to the program, using the combination symbol <KBD
CLASS="command"
>=&gt;</KBD
>. </P
><P
CLASS="para"
>The general syntax for named notation is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>formal_parameter_name =&gt; argument_value</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because you provide explicitly the name of the formal parameter, PL/SQL no longer needs to rely on the order of the parameters to make the association from actual to formal. So, if you use named notation, you do not need to list the parameters in your call to the program in the same order as the formal parameters are listed in the header. I can call tot_sales for new orders in either of these two ways: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>new_sales :=
   tot_sales (company_id_in =&gt; :order.company_id, status_in =&gt;'N');

new_sales :=
   tot_sales (status_in =&gt;'N', company_id_in =&gt; :order.company_id);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can also mix named and positional notation in the same program call: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:order.new_sales := tot_sales (:order.company_id, status_in =&gt;'N');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you do mix notation, however, you must list all of your positional parameters before any named notation parameters, as shown in the preceding example. Positional notation has to have a starting point from which to keep track of positions, and the only starting point is the first parameter. If you place named notation parameters in front of positional notation, PL/SQL loses its place. Both of the calls to tot_sales, shown below, fail. The first statement fails because the named notation comes first. The second fails because positional notation is used, but the parameters are in the wrong order. PL/SQL will try to convert `N' to a NUMBER (for company_id): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:order.new_sales := tot_sales (company_id_in =&gt; :order.company_id, 'N');

:order.new_sales := tot_sales ('N', company_id_in =&gt; :order.company_id);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.4.3"
>15.6.4.3 Benefits of named notation</A
></H4
><P
CLASS="para"
>Now you are aware of different ways to notate the order and association of parameters. One obvious question that you might ask is why you would ever use named notation. Here are some possibilities: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Named notation is self-documenting.</EM
> When you use named notation, the call to the program clearly describes the formal parameter to which the actual parameter is assigned. The names of formal parameters can and should be designed so that their use/purpose is self-explanatory. In a way, the descriptive aspect of named notation is another form of program documentation. If you are not familiar with all the modules called by an application, the listing of the formal parameters helps reinforce your understanding of a particular program call. In some development environments, the standard for parameter notation is named notation for just this reason. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Named notation gives you complete flexibility over parameter specification.</EM
> You can list the parameters in any order you want. You can also include only the parameters you want or need in the parameter list. Complex applications may at times require procedures with literally dozens of parameters. Any parameter with a default value can be left out of the call to the procedure. By using named notation, the developer can use the procedure, passing only the values needed for that usage. </P
></LI
></UL
><P
CLASS="para"
>Remember that whether you use named or positional notation, the actual module (both header and body) remains unchanged. The only difference is in the way the module is called. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-6.5"
>15.6.5 Default Values</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948992-1"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948992-2"
></A
>As you have seen from previous examples, you can provide a default value for IN parameters. If an IN parameter has a default value, you do not need to include that parameter in the call to the program. You must, of course, include an actual parameter for any IN OUT parameters, even if they have default values. A parameter's default value is used by the program only if the call to that program does not include that parameter in the list. </P
><P
CLASS="para"
>The parameter default value works the same way as a specification of a default value for a declared variable. There are two ways to specify a default value: either with the keyword DEFAULT or with the assignment operator (<CODE
CLASS="literal"
>:=</CODE
>), as the following example illustrates: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE astrology_reading
   (sign_in IN VARCHAR2 := 'LIBRA',
    birth_time_in IN NUMBER DEFAULT 800) IS</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By using default values, you can call programs using different numbers of actual parameters. The program uses the default value of any unspecified parameters. It also overrides the default values of any parameters in the list that have default values. Here are all the different ways you can ask for your astrology reading using positional notation: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>astrology_reading ('SCORPIO', 1756);
astrology_reading ('SCORPIO');
astrology_reading;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first line specifies both parameters explicitly. In the second call to astrology_reading, only the first actual parameter is included, so birth_time_in is set to 8:00 A.M. In the third line, no parameters are specified, so we cannot include the parentheses. Both the default values are used in the body of the procedure. </P
><P
CLASS="para"
>What if you want to specify a birth time, but not a sign? The following call to astrology_reading compiles properly since PL/SQL will convert NUMBER to VARCHAR2 automatically, but it results in assigning the string "1756" to the sign, and 8:00 A.M. to the birth time: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>astrology_reading (1756);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Not exactly what you might have had in mind! You also cannot use a comma <CODE
CLASS="literal"
>( , )</CODE
> to indicate a placeholder, as in, "There should be a parameter here so use the default value!" This next call does not even compile: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>astrology_reading (,1756); -- Invalid skipped argument</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you wish to leave out leading and defaulted parameters from your program call, you need to switch to named notation. By including the name of the formal parameter, you can list only those parameters to which you need to pass (or retrieve) values. In this (thankfully) last request for a star-based reading of my fate, I have successfully passed in a default of Libra as my sign and an overridden birth time of 5:56 P.M.<A
CLASS="indexterm"
NAME="AUTOID-14105"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-14106"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-14107"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-14108"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-14109"
></A
> </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>astrology_reading (birth_time_in =&gt; 1756);<A
CLASS="indexterm"
NAME="AUTOID-14111"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-14112"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_05.htm#SQL2-CH-15-SECT-5.3"
TITLE="15.5 Functions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 15.5 Functions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_07.htm"
TITLE="15.7 Local Modules"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 15.7 Local Modules"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>15.5 Functions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>15.7 Local Modules</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
