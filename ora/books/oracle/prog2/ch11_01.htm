<HTML
><HEAD
><TITLE
>[Chapter 11] Character Functions</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:00:35Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part03.htm"
TITLE="III. Built-In Functions "><LINK
REL="prev"
HREF="part03.htm"
TITLE="III. Built-In Functions "><LINK
REL="next"
HREF="ch11_02.htm#SQL2-CH-11-SECT-2.4"
TITLE="11.2 Character Function Examples"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part03.htm"
TITLE="III. Built-In Functions "
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: III. Built-In Functions "
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 11</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm#SQL2-CH-11-SECT-2.4"
TITLE="11.2 Character Function Examples"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 11.2 Character Function Examples"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SQL2-CH-11"
>11. Character Functions</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SQL2-CH-11-SECT-1"
TITLE="11.1 Character Function Descriptions "
>Character Function Descriptions </A
><BR><A
CLASS="sect1"
HREF="ch11_02.htm#SQL2-CH-11-SECT-2.4"
TITLE="11.2 Character Function Examples"
>Character Function Examples</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-763800-1"
></A
> <A
CLASS="indexterm"
NAME="ch11-idx-763800-2"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763800-3"
></A
>A character function is a function that takes one or more character values as parameters and returns either a character value or a number value. The Oracle Server and PL/SQL provide a number of different character datatypes, including CHAR, VARCHAR, VARCHAR2, LONG, RAW, and LONG RAW. In PL/SQL, the three different datatype families for character data are: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>VARCHAR2 </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A variable-length character datatype whose data is converted by the RDBMS </P
></DD
><DT
CLASS="term"
>CHAR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The fixed-length datatype</P
></DD
><DT
CLASS="term"
>RAW</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A variable-length datatype whose data is not converted by the RDBMS, but instead is left in "raw" form </P
></DD
></DL
><P
CLASS="para"
>When a character function returns a character value, that value is always of type VARCHAR2 (variable length), with the following two exceptions: UPPER and LOWER. These functions convert to upper- and lowercase, respectively, and return CHAR values (fixed length) if the strings they are called on to convert are fixed-length CHAR arguments. </P
><P
CLASS="para"
>PL/SQL provides a rich set of character functions that allow you to get information about strings and modify the contents of those strings in very high-level, powerful ways. <A
CLASS="xref"
HREF="ch11_01.htm"
>Table 11.1</A
> shows the character functions covered in detail in this chapter. The remaining functions (not covered in this chapter) are specific to National Language Support and Trusted Oracle. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-11-TABLE-2"
>Table 11.1: The Built-In Character Functions </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Name</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ASCII</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the ASCII code of a character.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CHR</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the character associated with the specified collating code.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CONCAT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Concatenates two strings into one.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>INITCAP</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Sets the first letter of each word to uppercase. All other letters are set to lowercase. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>INSTR</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the location in a string of the specified substring.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>LENGTH</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the length of a string.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>LOWER</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Converts all letters to lowercase.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>LPAD</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Pads a string on the left with the specified characters.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>LTRIM</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Trims the left side of a string of all specified characters.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>REPLACE</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Replaces a character sequence in a string with a different set of characters. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>RPAD</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Pads a string on the right with the specified characters.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>RTRIM</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Trims the right side of a string of all specified characters.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>SOUNDEX</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the "soundex" of a string.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>SUBSTR</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the specified portion of a string.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>TRANSLATE</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Translates single characters in a string to different characters.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>UPPER</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Converts all letters in the string to uppercase.</P
> </TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1"
>11.1 Character Function Descriptions </A
></H2
><P
CLASS="para"
>The following sections briefly describe each of the PL/SQL character functions. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.1"
>11.1.1 The ASCII function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9774"
></A
>The ASCII function returns the NUMBER code that represents the specified character in the database character set. The specification of the ASCII function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION ASCII (single_character IN VARCHAR2) RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where single_character is the character to be located in the collating sequence. Even though the function is named ASCII, it will return the code location in whatever the database character set is set to, such as EBCDIC Code Page 500 or 7-bit ASCII. For example, in the 7-bit ASCII character set, ASCII (`a') returns 97. Remember that the collating code for uppercase letters is different from that for lowercase letters. ASCII (`A') returns 65 (in the 7-bit ASCII character set) because the uppercase letters come before the lowercase letters in the sequence. </P
><P
CLASS="para"
>If you pass more than one character in the parameter to ASCII, it returns the collating code for the first character and ignores the other characters. As a result, the following calls to ASCII all return the same value of 100: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;ASCII ('defg') ==&gt; 100
ASCII ('d') ==&gt; 100
ASCII ('d_e_f_g') ==&gt; 100</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.2"
>11.1.2 The CHR function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9783"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9785"
></A
>The CHR function is the inverse of ASCII. It returns a VARCHAR2 character (length 1) that corresponds to the location in the collating sequence provided as a parameter. The specification of the CHR function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION CHR (code_location IN NUMBER) RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where code_location is the number specifying the location in the collating sequence. </P
><P
CLASS="para"
>The CHR function is especially valuable when you need to make reference to a nonprintable character in your code. For example, the location in the standard ASCII collating sequence for the newline character is ten. The CHR function therefore gives me a way to search for the linefeed control character in a string, and perform operations on a string based on the presence of that control character. </P
><P
CLASS="para"
>You can also insert a linefeed into a character string using the CHR function. Suppose I have to build a report that displays the address of a company. A company can have up to four address strings (in addition to city, state, and zipcode). I need to put each address string on a new line, but I don't want any blank lines embedded in the address. The following SELECT will not do the trick: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SELECT name, address1, address2, address3, address4,
       city || ', ' || state || ' ' || zipcode location
  FROM company;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Assuming each column (report field) goes on a new line, you will end up using six lines per address, no matter how many of these address strings are NULL. For example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;HAROLD HENDERSON
22 BUNKER COURT
SUITE 100


WYANDANCH, MN 66557</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can use the CHR function to suppress these internal blank lines as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SELECT name ||
       DECODE (address1, NULL, NULL, CHR (10) || address1) ||
       DECODE (address2, NULL, NULL, CHR (10) || address2) ||
       DECODE (address3, NULL, NULL, CHR (10) || address3) ||
       DECODE (address4, NULL, NULL, CHR (10) || address4) ||
       CHR (10) ||
       city || ', ' || state || ' ' || zipcode
  FROM company;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now the query returns a single formatted column per company. The DECODE statement offers IF-THEN logic within SQL and executes as follows: "If the address string is NULL then concatenate NULL; otherwise insert a linefeed character. Then concatenate the address string." </P
><P
CLASS="para"
>In this way, blank address lines are ignored. If I now use Wrap on the report field which holds this string, the address will be scrunched down to: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;HAROLD HENDERSON
22 BUNKER COURT
SUITE 100
WYANDANCH, MN 66557</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.3"
>11.1.3 The CONCAT function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9803"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9806"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9808"
></A
>The CONCAT function concatenates by taking two VARCHAR2 strings and returning those strings appended together in the order specified. The specification of the CONCAT function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION CONCAT (string1 IN VARCHAR2, string2 IN VARCHAR2)
                RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>CONCAT always appends string2 to the end of string1. If either string is NULL, CONCAT returns the non-NULL argument all by its lonesome. If both strings are NULL, CONCAT returns NULL. Here are some examples of uses of CONCAT: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;CONCAT ('abc', 'defg') ==&gt; 'abcdefg'
CONCAT (NULL, 'def') ==&gt; 'def'
CONCAT ('ab', NULL) ==&gt; 'ab'
CONCAT (NULL, NULL) ==&gt; NULL</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I have a confession to make about CONCAT: I have never used it once in all my years of PL/SQL coding. In fact, I never even noticed it was available until I did the research for this book. How can this be? Did I never have to concatenate strings together in my programs? No, I certainly have performed many acts of concatenation in my time. <A
CLASS="indexterm"
NAME="AUTOID-9814"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9816"
></A
><A
CLASS="indexterm"
NAME="AUTOID-9818"
></A
>Surprisingly, the answer is that PL/SQL (and the Oracle RDBMS) offers a second concatenation operator&nbsp;-- the double vertical bars (<KBD
CLASS="command"
>||</KBD
>). This operator is much more flexible and powerful and is easier to use than CONCAT. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.4"
>11.1.4 The INITCAP function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-763805-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763805-2"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763805-3"
></A
>The INITCAP function reformats the case of the string argument, setting the first letter of each word to uppercase and the remainder of the letters in that word to lowercase. A word is a set of characters separated by a space or nonalphanumeric characters (such as <KBD
CLASS="command"
>#</KBD
> or <KBD
CLASS="command"
>_ </KBD
>). The specification of INITCAP is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION INITCAP (string_in IN VARCHAR2) RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are some examples of the impact of INITCAP on your strings:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Shift all lowercase to mixed case:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INITCAP ('this is lower') ==&gt; 'This Is Lower'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Shift all uppercase to mixed case:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INITCAP ('BIG&gt;AND^TALL') ==&gt; 'Big&gt;And^Tall'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Shift a confusing blend of cases to consistent initcap format:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INITCAP ('wHatISthis_MESS?') ==&gt; 'Whatisthis_Mess?'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Create Visual Basic-style variable names (I use REPLACE, explained later, to strip out the embedded spaces). </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;REPLACE (INITCAP ('ALMOST_UNREADABLE_VAR_NAME'), '_', NULL)
==&gt;
   'AlmostUnreadableVarName'</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>When and why would you use INITCAP? Many Oracle shops like to store all character string data in the database, such as names and addresses, in uppercase. This makes it easier to search for records that match certain criteria. </P
><P
CLASS="para"
>The problem with storing all the data in uppercase is that, while it is a convenient "machine format," it is not particularly readable or presentable. How easy is it to scan a page of information that looks like the following? </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;CUSTOMER TRACKING LIST - GENERATED ON 12-MAR-1994
LAST PAYMENT WEDNESDAY: PAUL JOHNSON, 123 MADISON AVE - $1200
LAST PAYMENT MONDAY: HARRY SIMMERSON, 555 AXELROD RD - $1500</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It is hard for the eye to pick out the individual words and different types of information; all that text just blends in together. Furthermore, solid uppercase simply has a "machine" or even "mainframe" feel to it; you'd never actually type it that way. A mixture of upper- and lowercase can make your output much more readable and friendly in appearance: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;Customer Tracking List - Generated On 12-Mar-1994
Last Payment Wednesday: Paul Johnson, 123 Madison Ave - $1200
Last Payment Monday: Harry Simmerson, 555 Axelrod Rd - $1500</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Can you see any problems with using INITCAP to format output? There are a couple of drawbacks to the way it works. First, as you saw earlier with the string "BIG AND TALL", INITCAP is not very useful for generating titles, since it doesn't know that little words like "and" and "the" should not be capitalized. That is a relatively minor problem compared with the second: INITCAP is completely ignorant of real-world surname conventions. Names with internal capital letters, in particular, cannot be generated with INITCAP. Consider the following example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INITCAP ('HAMBURGERS BY THE BILLIONS AT MCDONALDS')
==&gt;
   'Hamburgers By The Billions At Mcdonalds'</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9857"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9858"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9859"
></A
> Use INITCAP with caution when printing reports or displaying data, since the information it produces may not always be formatted correctly. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.5"
>11.1.5 The INSTR function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-763807-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763807-2"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763807-3"
></A
> The INSTR function searches a string to find a match for the substring and, if found, returns the position, in the source string, of the first character of that substring. If there is no match, then INSTR returns 0. In Oracle7, if nth_appearance is not positive (i.e., if it is 0 or negative), then INSTR always returns 1. In Oracle8, a value of 0 or a negative number for nth_appearance causes INSTR to raise the VALUE_ERROR exception. </P
><P
CLASS="para"
>The specification of the INSTR function is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION INSTR
   (string1 IN VARCHAR2,
    string2 IN VARCHAR2
   [,start_position IN NUMBER := 1
   [, nth_appearance IN NUMBER := 1]])
RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where string1 is the string searched by INSTR for the position in which the nth_appearance of string2 is found. The start_position parameter is the position in the string where the search will start. It is optional and defaults to 1 (the beginning of string1). The nth_appearance parameter is also optional and also defaults to 1. </P
><P
CLASS="para"
>Both the start_position and nth_appearance parameters can be literals like 5 or 157, variables, or complex expressions, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INSTR (company_name, 'INC', (last_location + 5) * 10)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If start_position is negative, then INSTR counts back start_position number of characters from the end of the string and then searches from that point towards the beginning of the string for the <EM
CLASS="emphasis"
>n</EM
>th match. <A
CLASS="xref"
HREF="ch11_01.htm"
>Figure 11.1</A
> illustrates the two directions in which INSTR searches, depending on the sign of the start_position parameter. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-11-FIG-1"
>Figure 11.1: Forward and reverse searches with INSTR</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1101.gif"
ALT="Figure 11.1"><P
CLASS="para"
>I have found INSTR to be a very handy function&nbsp;-- especially when used to the fullest extent possible. Most programmers make use of (and are even only aware of) only the first two parameters. Use INSTR to search from the end of the string? Search for the <EM
CLASS="emphasis"
>n</EM
>th appearance, as opposed to just the first appearance? "Wow!" many programmers would say, "I didn't know it could do that." Take the time to get familiar with INSTR and use <EM
CLASS="emphasis"
>all</EM
> of its power. </P
><P
CLASS="para"
>Let's look at some examples of INSTR. In these examples, you will see all four parameters used in all their permutations. As you write your own programs, keep in mind the different ways in which INSTR can be used to extract information from a string; it can greatly simplify the code you write to parse and analyze character data. </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Find the first occurrence of archie in "bug-or-tv-character?archie": </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INSTR ('bug-or-tv-character?archie', 'archie') ==&gt; 21</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The starting position and the <EM
CLASS="emphasis"
>n</EM
>th appearance both defaulted to 1. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Find the first occurrence of archie in the following string starting from position 14: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INSTR ('bug-or-tv-character?archie', 'ar', 14) ==&gt; 21</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this example I specified a starting position, which overrides the default of 1; the answer is still the same though. No matter where you start your search, the character position returned by INSTR is always calculated from the beginning of the string. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Find the second occurrence of archie in the following string:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INSTR ('bug-or-tv-character?archie', 'archie', 1, 2) ==&gt; 0</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There is only one archie in the string, so INSTR returns 0. Even though the starting point is the default, I cannot leave it out if I also want to specify a nondefault <EM
CLASS="emphasis"
>n</EM
>th appearance (2 in this case, for "second occurrence"). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Find the second occurrence of "a" in "bug-or-tv-character?archie": </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INSTR ('bug-or-tv-character?archie', 'a', 1, 2) ==&gt; 15</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The second "a" in this string is the second "a" in "character," which is in the fifteenth position in the string. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Find the last occurrence of "ar" in "bug-or-tv-character?archie". </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INSTR ('bug-or-tv-character?archie', 'ar', -1) ==&gt; 21</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Were you thinking that the answer might be 6? Remember that the character position returned by INSTR is always calculated from the leftmost character of the string being position 1. The easiest way to find the last of anything in a string is to specify a negative number for the starting position. I did not have to specify the <EM
CLASS="emphasis"
>n</EM
>th appearance (leaving me with a default value of 1), since the last occurrence is also the first when searching backwards. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Find the second-to-last occurrence of "a" in "bug-or-tv-character?archie": </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INSTR ('bug-or-tv-character?archie', 'a', -1, 2) ==&gt; 15</PRE
></BLOCKQUOTE
><P
CLASS="para"
>No surprises here. Counting from the back of the string, INSTR passes over the "a" in archie, because that is the last occurrence, and searches for the next occurrence. Again, the character position is counted from the leftmost character, not the rightmost character, in the string. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Find the position of the letter "t" closest to (but not past) the question mark in the following string: bug-or-tv-character?archie tophat: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;INSTR ('bug-or-tv-character?archie tophat', 't', -14) ==&gt; 17</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I needed to find the "t" just before the question mark. The phrase "just before" indicates to me that I should search backwards from the question mark for the first occurrence. I therefore counted through the characters and determined that the question mark appears at the 20th position. I specified -14 as the starting position so that INSTR would search backwards right from the question mark. </P
><P
CLASS="para"
>What? Did I hear you mutter that I cheated? That if I could count through the string to find the question mark, I could just as well count through the string to find the closest "t"? I knew that I couldn't slip something like that by my readers. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A more general solution to the previous example: It is true that I "cheated." After all, when you are writing a program you usually do not know in advance the value and location of the string through which you are searching. It is likely to be a variable of some sort. It would be impossible to "count my way" to the question mark. Instead I need to find the location of the question mark and use that as the starting position. I need, in short, to use a second, or nested, INSTR inside the original INSTR. Here is a real solution to the problem: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;search_string := 'bug-or-tv-character?archie tophat';
tee_loc :=
   INSTR (search_string, 't',
          -1 * (LENGTH (search_string) - INSTR (search_string, '?') +1));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Instead of hardcoding 20 in my call to INSTR, I dynamically calculate the location of the question mark (actually, the first question mark in the string; I assume that there is only one). Then I subtract that from the full length of the string and multiply times -1 because I need to count the number of characters from the end of the string. I then use that value to kick off the search for the closest prior "t". </P
><P
CLASS="para"
>This example is a good reminder that any of the parameters to INSTR can be complex expressions that call other functions or perform their own calculations. This fact is also highlighted in the final INSTR example. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use INSTR to confirm that a user entry is valid. In the code below, I check to see if the command selected by the user is found in the list of valid commands. If so, I execute that command: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;IF INSTR ('|ADD|DELETE|CHANGE|VIEW|CALC|', '|' || cmd || '|') &gt; 0
THEN
   execute_command (cmd);
ELSE
   DBMS_OUTPUT.PUT_LINE
      (' You entered an invalid command. Please try again...');
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this case, I use the concatenation operator to construct the string that I will search for in the command list. I have to append a vertical bar (<KBD
CLASS="command"
>|</KBD
>) to the selected command because it is used as a delimiter in the command list. I also use the call to INSTR in a Boolean expression. If INSTR finds a match in the string, it returns a nonzero value. The Boolean expression therefore evaluates to TRUE and I can go on with my processing. Otherwise, I display an error message. </P
><P
CLASS="para"
>INSTR's flexibility allows you to write compact code which implements complex requirements. <A
CLASS="indexterm"
NAME="AUTOID-9930"
></A
>INSTRB is the multiple-byte character set version of INSTR. For single-byte character sets (such as American English), INSTRB returns the same values as INSTR.<A
CLASS="indexterm"
NAME="AUTOID-9932"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9933"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9934"
></A
> </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.6"
>11.1.6 The LENGTH function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9938"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9940"
></A
>The LENGTH function returns the length of the specified string. The specification for LENGTH follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION LENGTH (string1 VARCHAR2) RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If string1 is NULL, then LENGTH returns NULL&nbsp;-- not zero (0)! Remember, a NULL string is a "nonvalue." Therefore, it cannot have a length, even a zero length. </P
><P
CLASS="para"
>The LENGTH function, in fact, will never return zero; it will always return either NULL or a positive number. Here are some examples: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LENGTH (NULL) ==&gt; NULL
LENGTH ('') ==&gt; NULL -- Same as a NULL string.
LENGTH ('abcd') ==&gt; 4
LENGTH ('abcd ') ==&gt; 5</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9948"
></A
>If string1 is a fixed-length CHAR datatype, then LENGTH counts the trailing blanks in its calculation. So the LENGTH of a fixed-length string is always the declared length of the string. If you want to compute the length of the nonblank characters in string1, you will need to use the RTRIM function to remove the trailing blanks (RTRIM is discussed later in this chapter). In the following example, length1 is set to 60 and length2 is set to 14. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;DECLARE
   company_name CHAR(60) := 'ACME PLUMBING';
   length1 NUMBER;
   length2 NUMBER;
BEGIN
   length1 := LENGTH (company_name);
   length2 := LENGTH (RTRIM (company_name));
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>LENGTHB is the multiple-byte character set version of LENGTH. For single-byte character sets (such as American English), LENGTH returns the same values as INSTR. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.7"
>11.1.7 The LOWER function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9956"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9958"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9961"
></A
>The LOWER function converts all letters in the specified string to lowercase. The specifications for the LOWER function are: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION LOWER (string1 IN CHAR) RETURN CHAR
FUNCTION LOWER (string1 IN VARCHAR2) RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As I noted earlier, LOWER and UPPER will actually return a fixed-length string if the incoming string is fixed-length. LOWER will not change any characters in the string that are not letters, since case is irrelevant for numbers and special characters, such as the dollar sign (<CODE
CLASS="literal"
>$</CODE
>). </P
><P
CLASS="para"
>Here are some examples of the effect of LOWER:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LOWER ('BIG FAT LETTERS') ==&gt; 'big fat letters'
LOWER ('123ABC') ==&gt; '123abc'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>LOWER and its partner in case conversion, UPPER, are useful for guaranteeing a consistent case when comparing strings. PL/SQL is not a case-sensitive language with regard to its own syntax and names of identifiers. It is sensitive to case, however, in character strings, whether found in named constants, literals, or variables. The string "ABC" is not the same as "abc", and this can cause problems in your programs if you are not careful and consistent in your handling of such values. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.8"
>11.1.8 The LPAD function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-763813-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763813-2"
></A
> <A
CLASS="indexterm"
NAME="ch11-idx-763813-3"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763813-4"
></A
>By default, PL/SQL strips all trailing blanks from a character string unless it is declared with a fixed-length CHAR datatype. There are occasions, however, when you really want some spaces (or even some other character) added to the front or back of your string. LPAD (and its right-leaning cousin, RPAD) give you this capability. The LPAD function returns a string padded to the left (hence the "L" in "LPAD") to a specified length, and with a specified pad string. The specification of the LPAD function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION LPAD
   (string1 IN VARCHAR2,
    padded_length IN NUMBER
    [, pad_string IN VARCHAR2])
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>LPAD returns string1 padded on the left to length padded_length with the optional character string pad_string. If you do not specify pad_string, then string1 is padded on the left with spaces. You must specify the padded_length. If string1 already has a length equal to padded_length, then LPAD returns string1 without any additional characters. If padded_length is smaller than the length of string1, LPAD effectively truncates string1&nbsp;-- it returns only the first padded_length characters of the incoming string1. </P
><P
CLASS="para"
>As you can easily see, LPAD can do a lot more than just add spaces to the left of a string. Let's look at some examples of how useful LPAD can be. </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Display the number padded left with zeros to a length of 10:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LPAD ('55', 10, '0') ==&gt; '0000000055'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Display the number padded left with zeros to a length of 5:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LPAD ('12345678', 5, '0') ==&gt; '12345'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>LPAD interprets its padded_length as the maximum length of the string that it may return. As a result, it counts padded_length number of characters from the left (start of the string) and then simply returns that substring of the incoming value. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Place the phrase "sell!" in front of the names of selected stocks, up to a string length of 45: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LPAD ('HITOP TIES', 45, 'sell!')
==&gt;
   'sell!sell!sell!sell!sell!sell!sell!HITOP TIES'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because the length of "HITOP TIES" is 10 and the length of "sell!" is 5, there is room for seven repetitions of the pad string. LPAD does, in fact, generate a repetition of the pattern specified in the pad string. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Place the phrase "sell!" in front of the names of selected stocks, up to a string length of 43. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LPAD ('HITOP TIES', 43, 'sell!')
==&gt;
   'sell!sell!sell!sell!sell!sell!selHITOP TIES'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because the length of "HITOP TIES" is 10 and the length of "sell!" is 5, there is no longer room for seven full repetitions of the pad string. As a result, the seventh repetition (counting from the left) of "sell!" lost its last two characters. So you can see that LPAD does not pad by adding to the left of the original string until it runs out of room. Instead, it figures out how many characters it must pad by to reach the total, then constructs that full padded fragment, and finally appends the original string to this fragment. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Place three repetitions of the string "DRAFT-ONLY" in front of the article's title. Put two spaces between each repetition. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LPAD ('Why I Love PL/SQL', 53, 'DRAFT-ONLY  ');
==&gt;
      'DRAFT-ONLY  DRAFT-ONLY  DRAFT-ONLY  Why I Love PL/SQL'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can specify any number of characters to be padded in front of the incoming string value. The 53 that is hardcoded in that call to LPAD is the result of some hard calculations: the title is 17 characters and the prefix, including spaces, is 12 characters. As a result, I needed to make sure that I padded to a length of at least 17 + 12*3 = 53. This is not a very desirable way to solve the problem, however; once again I have assumed that in my program I have access to all these specific values and can precompute the length I need. The section entitled "Frame String with Prefix and Suffix" shows how to generalize this kind of action in a procedure&nbsp;-- without making any assumptions about lengths.<A
CLASS="indexterm"
NAME="AUTOID-10006"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10007"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10008"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10009"
></A
> </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.9"
>11.1.9 The LTRIM function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10013"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10015"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10018"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10021"
></A
>The LTRIM function is the opposite of LPAD. Whereas LPAD adds characters to the left of a string, LTRIM removes, or trims, characters from the leading portion of the string. And just as with LPAD, LTRIM offers much more flexibility than simply removing leading blanks. The specification of the LTRIM function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION LTRIM (string1 IN VARCHAR2 [, trim_string IN VARCHAR2])
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>LTRIM returns string1 with all leading characters removed up to the first character not found in the trim_string. The second parameter is optional and defaults to a single space. </P
><P
CLASS="para"
>There is one important difference between LTRIM and LPAD. LPAD pads to the left with the specified string, and repeats that string (or pattern of characters) until there is no more room. LTRIM, on the other hand removes all leading characters which appear in the trim string, not as a pattern, but as individual candidates for trimming. </P
><P
CLASS="para"
>Here are some examples:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Trim all leading blanks from ` Way Out in Right Field':</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LTRIM ('    Way Out in Right Field') ==&gt; 'Way Out in Right Field'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because I did not specify a trim string, it defaults to a single space and so all leading spaces are removed. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Trim `123' from the front of a string:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;my_string := '123123123LotsaLuck123';

LTRIM (my_string, '123') ==&gt; 'LotsaLuck123'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this example, LTRIM stripped off all three leading repetitions of "123" from the specified string. Although it looks as though LTRIM trims by a specified pattern, this is not so, as the next example illustrates. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove all numbers from the front of the string:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;my_string := '70756234LotsaLuck';

LTRIM (my_string, '0987612345') ==&gt; 'LotsaLuck'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By specifying every possible digit in my trim string, I ensured that any and all numbers would be trimmed, regardless of the order in which they occurred (and the order in which I place them in the trim string). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove all a's, b's, and c's from the front of the string: `abcabcccccI LOVE CHILI': </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LTRIM ('abcabcccccI LOVE CHILI', 'abc') ==&gt; 'I LOVE CHILI'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>LTRIM removed the patterns of "abc", but also removed the individual instances of the letter "c". This worked out fine since the request was to remove any and all of those three letters. What if I wanted to remove only any instance of "abc" as a pattern from the front of the string? I couldn't use LTRIM since it trims off any matching individual characters. To remove a pattern from a string&nbsp;-- or to replace one pattern with another pattern&nbsp;-- you will want to make use of the REPLACE function, which is discussed next. </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.10"
>11.1.10 The REPLACE function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-763816-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763816-2"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763816-3"
></A
> <A
CLASS="indexterm"
NAME="ch11-idx-763816-4"
></A
>The REPLACE function returns a string in which all occurrences of a specified match string are replaced with a replacement string. REPLACE is useful for searching out patterns of characters and then changing all instances of that pattern in a single function call. The specification of the REPLACE function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION REPLACE (string1 IN VARCHAR2, match_string IN VARCHAR2
                  [, replace_string IN VARCHAR2])
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you do not specify the replacement string, then REPLACE simply removes all occurrences of the match_string in string1. If you specify neither a match string nor a replacement string, REPLACE returns NULL. </P
><P
CLASS="para"
>Here are several examples using REPLACE:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove all instances of the letter "C" in the string "CAT CALL": </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;REPLACE ('CAT CALL', 'C') ==&gt; 'AT ALL'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because I did not specify a replacement string, REPLACE changed all occurrences of "C" to NULL. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Replace all occurrences of "99" with "100" in the following string: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;REPLACE ('Zero defects in period 99 reached 99%!', '99', '100')
==&gt;
      'Zero defects in period 100 reached 100%!'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Replace all occurrences of "th" with the letter "z": </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>REPLACE ('this that and the other', 'th', 'z') ==&gt; 'zis zat and ze ozer'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10075"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10077"
></A
>Handle occurrences of a single quote (<KBD
CLASS="command"
>'</KBD
>) within a query criteria string. The single quote is a string terminator symbol. It indicates the start and/or end of the literal string. I ran into this requirement when building query-by-example strings in Oracle Forms. If the user enters a string with a single quote in it, such as: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;Customer didn't have change.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and then I concatenate that string into a larger string, the resulting SQL statement (created dynamically by Oracle Forms in Query Mode) fails, because there are unbalanced single quotes in the string. </P
><P
CLASS="para"
>You can resolve this problem in one of three ways: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Simply strip out the single quote before you execute the query. This is workable only if there really aren't any single quotes in the data in the database. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you do allow single quotes, you can then either replace the single quote with a single character wildcard (<KBD
CLASS="command"
> _ </KBD
>) or: </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Embed that single quote inside other single quotes so that the SQL layer can properly parse the statement. </P
></LI
></OL
><P
CLASS="para"
>To replace the single quote with a wild card, you would code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;criteria_string := REPLACE (criteria_string, '''', '_');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>That's right! Four single quotes in sequence are required for PL/SQL to understand that you want to search for one single quote in the criteria string. The first quote indicates the start of a literal. The fourth quote indicates the end of the string literal. The two inner single quotes parse into one single quote. That is, whenever you want to embed a single quote inside a literal, you must place another single quote before it. </P
><P
CLASS="para"
>This principle comes in handy for the final resolution of the single quote in query criteria problem: change the single quote to two single quotes and then execute the query. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;criteria_string := REPLACE (criteria_string, '''', '''''');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>as in:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;REPLACE ('Customer didn''t have change.', '''', '''''')
==&gt;
   Customer didn''t have change.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now, even if you place single quotes at the beginning and end of this string, the internal single quote will not signal termination of the literal. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove all leading repetitions of "abc" from the string:</P
><P
CLASS="para"
>"abcabcccccI LOVE CHILIabc" </P
><P
CLASS="para"
>This is the behavior I was looking at in the previous section on LTRIM. I want to remove all instances of the pattern "abc" from the beginning of the string, but I do not want to remove that pattern throughout the rest of the string. In addition, I want to remove "abc" only as a pattern; if I encounter three contiguous c's ("ccc"), on the other hand, they should not be removed from the string. This task is less straightforward than it might at first seem. If I simply apply REPLACE to the string, it will remove all occurrences of "abc", instead of just the leading instances. For example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;REPLACE ('abcabccccI LOVE CHILIabc', 'abc') ==&gt; 'cccI LOVE CHILI'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>That is not what I want in this case. If I use LTRIM, on the other hand, I will be left with none of the leading c's, as demonstrated in a previous example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;LTRIM ('abcabcccccI LOVE CHILIabc', 'abc') ==&gt; 'I LOVE CHILIabc'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And this is not quite right either. I want to be left with `cccI LOVE CHILIabc' (please do not ask why), and it turns out that the way to get it is to use a combination of LTRIM and REPLACE. Suppose I create a local variable as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;my_string   := 'abcabccccI LOVE CHILIabc';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Then the following statement will achieve the desired effect by nesting calls to REPLACE and LTRIM within one another: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;REPLACE
   (LTRIM
      (REPLACE (my_string, 'abc', '@'), '@'), '@', 'abc')
==&gt;
      'cccI LOVE CHILIabc'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is how I would describe in English what the above statement does: </P
><P
CLASS="para"
>"First replace all occurrences of `abc' with the special character `@' (which I am assuming does not otherwise appear in the string). Then trim off all leading instances of `@'. Finally, replace all remaining occurrences of `@' with `abc'." </P
><P
CLASS="para"
><EM
CLASS="emphasis"
>Voila</EM
>, as they say in many of the finer restaurants in Paris. Now let's pull apart this single, rather complex statement into separate PL/SQL steps which correspond to my "natural language" description: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Replace all occurrences of "abc" with the special character "@" (which I am assuming does not otherwise appear in the string). Notice that this only affects the pattern and not any appearance of "a", "b", or "c". </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;    REPLACE ('abcabccccI LOVE CHILIabc', 'abc', '@')
          ==&gt; '@@cccI LOVE CHILI@'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Trim off all leading instances of "@".</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;    LTRIM ('@@cccI LOVE CHILI@', '@') ==&gt; 'cccI LOVE CHILI@'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that LTRIM now leaves the c's in place, because I didn't ask it to remove `"a" or "b" or "c"&nbsp;-- just "@". In addition, it left the trailing "@" in the string since LTRIM deals only with characters on the leading end of the string.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Replace all remaining occurrences of "@" with "abc". </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>    REPLACE ('cccI LOVE CHILI@', '@', 'abc') ==&gt; 'cccI LOVE CHILIabc'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And we are done. I used the first REPLACE to temporarily change the occurrences of "abc" so that LTRIM could distinguish between the pattern I wanted to get rid of and the extra characters which needed to be preserved. Then, a final call to REPLACE restored the pattern in the string.<A
CLASS="indexterm"
NAME="AUTOID-10126"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10127"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10128"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10129"
></A
> </P
></LI
></UL
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.11"
>11.1.11 The RPAD function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-763819-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763819-2"
></A
> <A
CLASS="indexterm"
NAME="ch11-idx-763819-3"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763819-4"
></A
>The RPAD function adds characters to the end of a character string. It returns a string padded to the right (hence the "R" in "RPAD") to a specified length, and with an optional pad string. The specification of the RPAD function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION RPAD
   (string1 IN VARCHAR2,
    padded_length IN NUMBER
    [, pad_string IN VARCHAR2])
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>RPAD returns string1 padded on the right to length padded_length with the optional character string pad_string. If you do not specify pad_string, then string1 is padded on the right with spaces. You must specify the padded_length. If string1 already has a length equal to padded_length, then RPAD returns string1 without any additional characters. If padded_length is smaller than the length of string1, RPAD effectively truncates string1: it returns only the first padded_length characters of the incoming string1. </P
><P
CLASS="para"
>Let's look at some examples of RPAD:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Display the number padded right with zeros to a length of 10:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;RPAD ('55', 10, '0') ==&gt; '5500000000'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I could also use TO_CHAR to convert from a number to a character (I don't know off-hand why you would do this, but it's good to be reminded that there are usually at least two or three ways to solve any problem): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;TO_CHAR (55 * 10000000) ==&gt; '5500000000'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Display the number padded right with zeros to a length of 5:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;RPAD ('12345678', 5) ==&gt; '12345'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>RPAD interprets its padded_length as the maximum length of the string that it may return. As a result, it counts padded_length number of characters from the left (start of the string) and then simply returns that substring of the incoming value. This is the same behavior as that found with LPAD, described earlier in this chapter. Remember: RPAD does not return the rightmost five characters (in the above case "45678"). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Place the phrase "sell!" after the names of selected stocks, up to a string length of 45: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;RPAD ('HITOP TIES', 45, 'sell!')
==&gt;
'  HITOP TIESsell!sell!sell!sell!sell!sell!sell!'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since the length of "HITOP TIES" is 10 and the length of "sell!" is 5, there is room for seven repetitions of the pad string. RPAD does, in fact, generate a repetition of the pattern specified in the pad string. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Place the phrase "sell!" after the names of selected stocks, up to a string length of 43: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;RPAD ('HITOP TIES', 43, 'sell!')
==&gt;
   'HITOP TIESsell!sell!sell!sell!sell!sell!sel'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because the length of "HITOP TIES" is 10 and the length of "sell!" is 5, there is no longer room for seven full repetitions of the pad string. As a result, the seventh repetition of "sell!" lost its last two characters. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Create a string of 60 dashes to use as a border in a report: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;RPAD ('-', 60, '-')
==&gt;
'------------------------------------------------------------'</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>You can use RPAD (and LPAD as well) to generate repetitive sequences of characters. I have used this technique in SQL*Reportwriter V1.1, where graphical objects like boxes are not really available. I can include the RPAD in a SELECT statement in the report, and then use the corresponding field in Text elements to provide lines to break up the data in a report.<A
CLASS="indexterm"
NAME="AUTOID-10168"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10169"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10170"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10171"
></A
> </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.12"
>11.1.12 The RTRIM function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10175"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10177"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10180"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10183"
></A
>The RTRIM function is the opposite of RPAD, and the companion function to LTRIM. Where RPAD adds characters to the right of a string, RTRIM removes, or trims, characters from the end portion of the string. Just as with RPAD, RTRIM offers much more flexibility than simply removing trailing blanks. The specification of the RTRIM function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION RTRIM (string1 IN VARCHAR2 [, trim_string IN VARCHAR2])
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>RTRIM returns string1 with all trailing characters removed up to the first character not found in the trim_string. The second parameter is optional and defaults to a single space. </P
><P
CLASS="para"
>Here are some examples of RTRIM:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Trim all trailing blanks from a string:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;RTRIM (`Way Out in Right Field                  ')
==&gt; 'Way Out in Right Field'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since I did not specify a trim string, it defaults to a single space and so all trailing spaces are removed. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Trim all the characters in "BAM! ARGH!" from the end of a string: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;my_string := 'Sound effects: BAM!ARGH!BAM!HAM';
RTRIM (my_string, 'BAM! ARGH!') ==&gt; 'Sound effects:'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This use of RTRIM stripped off all the letters at the end of the string which are found in "BAM!ARGH!." This includes "BAM" and "HAM," so those words too are removed from the string even though "HAM" is not listed explicitly as a "word" in the trim string. Also, the inclusion of two exclamation marks in the trim string is unnecessary, because RTRIM is not looking for the word "ARGH!", but each of the letters in "ARGH!". </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.13"
>11.1.13 The SOUNDEX function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10201"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10203"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10206"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10209"
></A
> The SOUNDEX function allows you to perform string comparisons based on phonetics (the way a word sounds), as opposed to semantics (the way a word is spelled).[<A
CLASS="footnote"
HREF="#AUTOID-10211"
>1</A
>] SOUNDEX returns a character string which is the "phonetic representation" of the argument. The specification of the SOUNDEX function is as follows: </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-10211"
>[1]</A
> Oracle Corporation used the algorithm in <EM
CLASS="emphasis"
>The Art of Computer Programming</EM
>, Volume 3, by Donald Knuth, to generate the phonetic representation.</P
></DIV
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION SOUNDEX (string1 IN VARCHAR2) RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are some of the values SOUNDEX generated and how they vary according to the input string: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SOUNDEX ('smith') ==&gt; 'S530'
SOUNDEX ('SMYTHE') ==&gt; ''S530'
SOUNDEX ('smith smith') ==&gt; 'S532'
SOUNDEX ('smith z') ==&gt; 'S532'
SOUNDEX ('feuerstein') ==&gt; 'F623'
SOUNDEX ('feuerst') ==&gt; 'F623'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Keep the following SOUNDEX rules in mind when using this function:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The SOUNDEX value always begins with the first letter in the input string. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>SOUNDEX only uses the first five consonants in the string to generate the return value. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Only consonants are used to compute the numeric portion of the SOUNDEX value. Except for a possible leading vowel, all vowels are ignored. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>SOUNDEX is not case-sensitive. Upper- and lowercase letters return the same SOUNDEX value. </P
></LI
></UL
><P
CLASS="para"
>The SOUNDEX function is useful for <EM
CLASS="emphasis"
>ad hoc</EM
> queries, and any other kinds of searches where the exact spelling of a database value is not known or easily determined. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.14"
>11.1.14 The SUBSTR function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-763823-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763823-2"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763823-3"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763823-4"
></A
>The SUBSTR function is one of the most useful and commonly used character functions. It allows you to extract a portion or subset of contiguous (connected) characters from a string. The substring is specified by starting position and a length. </P
><P
CLASS="para"
>The specification for the SUBSTR function is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION SUBSTR
   (string_in IN VARCHAR2,
    start_position_in IN NUMBER
    [, substr_length_in IN NUMBER])
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where the arguments are used as follows:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>string_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The source string</P
></DD
><DT
CLASS="term"
>start_position_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The starting position of the substring in string_in</P
></DD
><DT
CLASS="term"
>substr_length_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The length of the substring desired (the number of characters to be returned in the substring) </P
></DD
></DL
><P
CLASS="para"
>The last parameter, substr_length_in, is optional. If you do not specify a substring length, then SUBSTR returns all the characters to the end of string_in (from the starting position specified). </P
><P
CLASS="para"
>The start position cannot be zero. If the start position is less than zero, then the substring is retrieved from the back of the string. SUBSTR counts backwards substr_length_in number of characters from the end of string_in. In this case, however, the characters which are extracted are still to the right of the starting position. See <A
CLASS="xref"
HREF="ch11_01.htm"
>Figure 11.2</A
> for an illustration of how the different arguments are used by SUBSTR. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-11-FIG-2"
>Figure 11.2: How arguments are used by SUBSTR</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1102.gif"
ALT="Figure 11.2"><P
CLASS="para"
>The substr_length_in argument must be greater than zero.</P
><P
CLASS="para"
>You will find that in practice SUBSTR is very forgiving. Even if you violate the rules for the values of the starting position and the number of characters to be substringed, SUBSTR will not generate errors. Instead, for the most part, it will return NULL&nbsp;-- or the entire string&nbsp;-- as its answer. </P
><P
CLASS="para"
>Here are some examples of SUBSTR:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If the absolute value of the starting position exceeds the length of the input string, return NULL: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SUBSTR ('now_or_never', 200) ==&gt; NULL
SUBSTR ('now_or_never', -200) ==&gt; NULL</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If starting position is 0, SUBSTR acts as though the starting position was actually 1: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SUBSTR ('now_or_never', 0, 3) ==&gt; 'now'
SUBSTR ('now_or_never', 0) ==&gt; 'now_or_never'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the substring length is less than or equal to zero, return NULL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SUBSTR ('now_or_never', 5, -2) ==&gt; NULL
SUBSTR ('now_or_never', 1, 0) ==&gt; NULL</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Return the last character in a string:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SUBSTR ('Another sample string', -1) ==&gt; 'g'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the cleanest way to get the single last character. A more direct, but cumbersome, approach is this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SUBSTR
   ('Sample string', LENGTH ('Sample string'), 1) ==&gt; 'g'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, calculate the LENGTH of the string and the one character from the string that starts at that last position. Yuch. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove an element from a string list. This is, in a way, the opposite of SUBSTR: I want to extract a portion or substring of a string&nbsp;-- and leave the rest of it intact. Oddly enough, however, I will use SUBSTR to perform this task. Suppose my screen maintains a list of selected temperatures, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;|HOT|COLD|LUKEWARM|SCALDING|</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The vertical bar delimits the different items on the list. When the user deselects "LUKEWARM," I now have to remove it from the list, which becomes: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;|HOT|COLD|SCALDING|</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The best way to accomplish this task is to determine the starting and ending positions of the item to be removed, and then use SUBSTR to take apart the list and put it back together&nbsp;-- without the specified item. Let's walk through this process a step at a time. The list used in the above example contains 29 characters: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;String:          |HOT|COLD|LUKEWARM|SCALDING|
Character index: 1234567890123456789012345679</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, the item "LUKEWARM" starts on position 11 and ends on position 18. To extract this item from the list, I need to pull off the portion of the string before "LUKEWARM" as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SUBSTR ('|HOT|COLD|LUKEWARM|SCALDING|', 1, 10)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and then I need to extract the trailing portion of the list (after "LUKEWARM"). Notice that I do not want to keep both of the delimiters when I put these pieces back together, so this next SUBSTR does not include the vertical bar at position 19: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SUBSTR ('|HOT|COLD|LUKEWARM|SCALDING|', 20)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Finally, then, to extract "LUKEWARM" from the list, I use the following concatenation of calls to SUBSTR: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;SUBSTR ('|HOT|COLD|LUKEWARM|SCALDING|', 1, 10)
||
SUBSTR ('|HOT|COLD|LUKEWARM|SCALDING|', 20)
==&gt;
   '|HOT|COLD|SCALDING|'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove the middle word in a three-word string (in which each word is separated by an underscore) and switch the order of the first and last words. For example, change better_than_ever to ever_better. This is a bit different from the list_remove function because I do not have immediately available to me the length of the element I need to remove. Instead, I have to make use of INSTR twice to calculate that length. Here is the solution expressed as a function: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;/* Filename on companion disk: bitesw.sf */
FUNCTION bite_and_switch (tripart_string_in IN VARCHAR2)
   RETURN VARCHAR2
IS
   /* Location of first underscore */
   first_delim_loc  NUMBER := INSTR (tripart_string_in, '_', 1, 1);

   /* Location of second underscore */
   second_delim_loc NUMBER := INSTR (tripart_string_in, '_', 1, 2);

   /* Return value of function, set by default to incoming string. */
   return_value VARCHAR2(1000) := tripart_string_in;
BEGIN
   /* Only switch words if two delimiters are found. */
   IF second_delim_loc &gt; 0
   THEN
      /* Pull out  first and second words and stick them together. */
     return_value :=
         SUBSTR (tripart_string_in, 1, first_delim_loc - 1) || '_' ||
         SUBSTR (tripart_string_in, second_delim_loc + 1);
   END IF;

   /* Return the switched string */
   RETURN return_value;
END bite_and_switch;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use SUBSTR to extract the portion of a string between the specified starting and ending points. I run into this requirement all the time. SUBSTR requires a starting position and the number of characters to pull out. Often, however, I have only the starting position and the ending position&nbsp;-- and I then have to compute the number of characters in between. Is it just the difference between the end and start positions? Is it one more or one less than that? Invariably, I get it wrong the first time and have to scribble a little example on scrap paper to prove the formula to myself. </P
><P
CLASS="para"
>So to save all of you the trouble, I offer a tiny function below, called "betwnstr" (for: "BETWeeN STRing"). This function encapsulates the calculation you must perform to come up with the number of characters between start and end positions, which is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;end_position - start_position + 1

/* Filename on companion disk: betwnstr.sf */
FUNCTION betwnstr
   (string_in IN VARCHAR2, start_in IN INTEGER, end_in IN INTEGER)
   RETURN VARCHAR2
IS
BEGIN
   RETURN SUBSTR (string_in, start_in, end_in - start_in + 1);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>While this function does not provide the full flexibility offered by SUBSTR (for example, with negative starting positions), it offers a starting point for the kind of encapsulation you should be performing in these situations. </P
></LI
></UL
><P
CLASS="para"
>By the way, SUBSTRB is the multiple-byte character set version of SUBSTR. For single-byte character sets (such as American English), SUBSTRB returns the same values as SUBSTR.<A
CLASS="indexterm"
NAME="AUTOID-10306"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10307"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10308"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10309"
></A
> </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.15"
>11.1.15 The TRANSLATE function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-763825-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763825-2"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763825-3"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763825-4"
></A
> <A
CLASS="indexterm"
NAME="ch11-idx-763825-5"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-763825-6"
></A
> The TRANSLATE function is a variation on REPLACE. REPLACE replaces every instance of a set of characters with another set of characters; that is, REPLACE works with entire words or patterns. TRANSLATE replaces single characters at a time, translating the <EM
CLASS="emphasis"
>n</EM
>th character in the match set with the <EM
CLASS="emphasis"
>n</EM
>th character in the replacement set. The specification of the TRANSLATE is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION TRANSLATE
   (string_in IN VARCHAR2,
    search_set IN VARCHAR2,
    replace_set VARCHAR2)
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where string_in is the string in which characters are to be translated, search_set is the set of characters to be translated (if found), and replace_set is the set of characters which will be placed in the string. Unlike REPLACE, where the last argument could be left off, you must include all three arguments when you use TRANSLATE. Any of the three arguments may, however, be NULL, in which case TRANSLATE always returns NULL. </P
><P
CLASS="para"
>Here are some examples of the effect of TRANSLATE:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;TRANSLATE ('abcd', 'ab', '12') ==&gt; '12cd'

TRANSLATE ('12345', '15', 'xx') ==&gt; 'x234x'

TRANSLATE ('grumpy old possum', 'uot', '%$*') ==&gt;   'gr%mpy $ld p$ss%m'

TRANSLATE ('my language needs the letter e', 'egms', 'X')
==&gt;
   'y lanuaX nXXd thX lXttXr X';

TRANSLATE ('please go away', 'a', NULL) ==&gt; NULL</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can deduce a number of the usage rules for TRANSLATE from the above examples, but I spell them out here: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If the search set contains a character not found in the string, then no translation is performed for that character. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the string contains a character not found in the search set, then that character is not translated. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the search set contains more characters than the replace set, then all the "trailing" search characters that have no match in the replace set are removed from the string. In the following example, a, b, and c are changed to z, y, and x, respectively. But the letter "d" is removed from the return string entirely since it had no corresponding character in the replace set. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;TRANSLATE ('abcdefg', 'abcd', 'zyx') ==&gt; 'zyxefg'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In these cases, NULL is the matching "character" for all extra characters in the search set. When you replace a character with NULL it is the same as removing that character from the string. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If any of the three arguments is NULL, then the result of the translation is NULL. This is consistent with a basic tenet of NULLs: apply an operation to an unknown value and you always get an unknown value. </P
></LI
></UL
><P
CLASS="para"
>The TRANSLATE function comes in handy when you need to change a whole set of characters in a string, regardless of the order in which they appear in the string. <A
CLASS="xref"
HREF="ch11_02.htm#SQL2-CH-11-SECT-2.4"
>Section 11.2.5, "Verifying String Formats with TRANSLATE"</A
> demonstrates how handy this feature can be.<A
CLASS="indexterm"
NAME="AUTOID-10349"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10350"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10351"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10352"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10353"
></A
> </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-11-SECT-1.0.16"
>11.1.16 The UPPER function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10357"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10359"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10362"
></A
>The UPPER function converts all letters in the specified string to uppercase. The specifications of the UPPER function are: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;FUNCTION UPPER (string1 IN CHAR) RETURN CHAR
FUNCTION UPPER (string1 IN VARCHAR2) RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As I noted at the beginning of this chapter, UPPER and LOWER will actually return a fixed-length string if the incoming string is fixed length. UPPER will not change any characters in the string which are not letters, since case is irrelevant for numbers and special characters such as <CODE
CLASS="literal"
>$</CODE
>. </P
><P
CLASS="para"
>Here are some examples of the effect of UPPER:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;UPPER ('short little letters no more') ==&gt; 'SHORT LITTLE LETTERS NO MORE'

UPPER ('123abc') ==&gt; '123ABC'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>UPPER and its partner in case conversion, LOWER, are useful for guaranteeing a consistent case when comparing strings. PL/SQL is not a case-sensitive language as concerns its own syntax and names of identifiers. It is sensitive to case, however, in character strings, whether found in named constants, literals, or variables. The string "ABC" is not the same as "abc", and this can cause problems in your programs if you are not careful and consistent in your handling of such values. </P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part03.htm"
TITLE="III. Built-In Functions "
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: III. Built-In Functions "
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm#SQL2-CH-11-SECT-2.4"
TITLE="11.2 Character Function Examples"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 11.2 Character Function Examples"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>III. Built-In Functions </TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>11.2 Character Function Examples</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
