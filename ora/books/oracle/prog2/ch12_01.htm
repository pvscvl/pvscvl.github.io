<HTML
><HEAD
><TITLE
>[Chapter 12] Date Functions</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:01:05Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part03.htm"
TITLE="III. Built-In Functions "><LINK
REL="prev"
HREF="ch11_02.htm#SQL2-CH-11-SECT-2.4"
TITLE="11.2 Character Function Examples"><LINK
REL="next"
HREF="ch12_02.htm#SQL2-CH-12-SECT-2.1"
TITLE="12.2 Date Function Examples"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm#SQL2-CH-11-SECT-2.4"
TITLE="11.2 Character Function Examples"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 11.2 Character Function Examples"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 12</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch12_02.htm#SQL2-CH-12-SECT-2.1"
TITLE="12.2 Date Function Examples"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 12.2 Date Function Examples"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SQL2-CH-12"
>12. Date Functions</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SQL2-CH-12-SECT-1"
TITLE="12.1 Date Function Descriptions"
>Date Function Descriptions</A
><BR><A
CLASS="sect1"
HREF="ch12_02.htm#SQL2-CH-12-SECT-2.1"
TITLE="12.2 Date Function Examples"
>Date Function Examples</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10623"
></A
> <A
CLASS="indexterm"
NAME="ch12-idx-765945-2"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-765945-3"
></A
>This chapter contains detailed descriptions and extended examples of functions you can use to manipulate date information in PL/SQL programs. </P
><P
CLASS="para"
>Most applications store and manipulate dates and times. Dates are quite complicated: not only are they highly formatted, but there are myriad rules for determining valid values and valid calculations (leap days and years, national and company holidays, date ranges, etc.). Fortunately, PL/SQL and the Oracle RDBMS provide many ways to handle date information. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10634"
></A
>PL/SQL provides a true DATE datatype that stores both date and time information. Each date value contains the century, year, month, day, hour, minute, and second. The DATE datatype does not support the storage of fractions of time less than a second in length. The time itself is stored as the number of seconds past midnight. If you enter a date without a time (most applications do not require the tracking of time), the time portion of the database value defaults to midnight (12:00:00 AM). PL/SQL validates and stores dates which fall in the range January 1, 4712 B.C. to December 31, 4712 A.D (in Oracle Server 8.0 and higher, the maximum valid date is December 31, 9999). </P
><P
CLASS="para"
>Support for a true date datatype is only half the battle. You also need a language that can manipulate those dates in a natural and intelligent manner&nbsp;-- as dates. PL/SQL offers a set of eight date functions for just this purpose, as shown in <A
CLASS="xref"
HREF="ch12_01.htm"
>Table 12.1</A
>. </P
><P
CLASS="para"
>With PL/SQL you will never have to write a program which calculates the number of days between two dates. You will not need to write your own utility to figure out the day of the week on which a date falls. This information, and just about anything else you can think of having to do with dates, is immediately available to you through built-in functions. The date functions in PL/SQL all take dates, and, in some cases, numbers, for arguments, and all return date values. The only exception is MONTHS_BETWEEN, which returns a number. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-12-TABLE-2"
>Table 12.1: The Built-In Date Functions </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Name</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ADD_MONTHS</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Adds the specified number of months to a date.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>LAST_DAY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the last day in the month of the specified date.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MONTHS_ BETWEEN</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Calculates the number of months between two dates.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NEW_TIME</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the date/time value, with the time shifted as requested by the specified time zones. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NEXT_DAY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the date of the first weekday specified that is later than the date. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ROUND</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the date rounded by the specified format unit.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>SYSDATE</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the current date and time in the Oracle Server.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>TRUNC</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Truncates the specified date of its time portion according to the format unit provided. </P
> </TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1"
>12.1 Date Function Descriptions</A
></H2
><P
CLASS="para"
>This section describes each date function and includes examples to give you a solid feel for how you can put the function to use in your programs. </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> In the examples in this chapter, a date contained in single quotation marks is a character string. PL/SQL converts the string to a true date datatype when it applies the function. (This is an implicit conversion.) Date values that are displayed in the format DD-MON-YYYY and are not contained in single quotation marks represent actual date values in the database. </P
><P
CLASS="para"
>A true date value looks like this in the examples:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>12-DEC-1997</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A character representation looks like this in the examples:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>'12-DEC-1997'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Remember, a date has its own internal storage format and cannot be viewed or entered directly. These examples also assume that the default format mask for dates is DD-MON-YYYY.</P
></BLOCKQUOTE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1.0.1"
>12.1.1 The ADD_MONTHS function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch12-idx-765948-1"
></A
>The ADD_MONTHS function returns a new date with the specified number of months added to the input date. The specification for ADD_MONTHS is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION ADD_MONTHS (date_in IN DATE, month_shift NUMBER) RETURN DATE
FUNCTION ADD_MONTHS (month_shift NUMBER, date_in IN DATE) RETURN DATE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>ADD_MONTHS is an overloaded function. You can specify the date and the number of months by which you want to shift that date, or you can list the month_shift parameter first and then the date. Both arguments are required. </P
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="AUTOID-10708"
>Date Arithmetic</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10711"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10714"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10717"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10720"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10723"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10726"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10729"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10732"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10735"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10738"
></A
>PL/SQL allows you to perform arithmetic operations directly on date variables. You may add numbers to a date or subtract numbers from a date. To move a date one day in the future, simply add 1 to the date as shown below: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>hire_date + 1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can even add a fractional value to a date. For example, adding 1/24 to a date adds an hour to the time component of that value. Adding 1/(24*60) adds a single minute to the time component, and so on. </P
></DIV
><P
CLASS="para"
>If the month_shift parameter is positive, ADD_MONTHS returns a date for that number of months into the future. If the number is negative, ADD_MONTHS returns a date for that number of months in the past. Here are some examples that use ADD_MONTHS: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Move ahead date by three months:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ADD_MONTHS ('12-JAN-1995', 3) ==&gt; 12-APR-1995</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Specify negative number of months in first position:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ADD_MONTHS (-12, '12-MAR-1990') ==&gt; 12-MAR-1989</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>ADD_MONTHS always shifts the date by whole months. You can provide a fractional value for the month_shift parameter, but ADD_MONTHS will always round down to the whole number nearest zero, as shown in these examples: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ADD_MONTHS ('28-FEB-1989', 1.5) same as
ADD_MONTHS ('28-FEB-1989', 1) ==&gt; 31-MAR-1989

ADD_MONTHS ('28-FEB-1989', 1.9999) same as
ADD_MONTHS ('28-FEB-1989', 1) ==&gt; 31-MAR-1989

ADD_MONTHS ('28-FEB-1989', -1.9999) same as
ADD_MONTHS ('28-FEB-1989', -1) ==&gt; 31-JAN-1989

ADD_MONTHS ('28-FEB-1989', .5) same as
ADD_MONTHS ('28-FEB-1989', 0) ==&gt; 28-FEB-1989</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you want to shift a date by a fraction of a month, simply add to or subtract from the date the required number of days. PL/SQL supports direct arithmetic operations between date values. </P
><P
CLASS="para"
>If the input date to ADD_MONTHS does not fall on the last day of the month, the date returned by ADD_MONTHS falls on the same day in the new month as in the original month. If the day number of the input date is greater than the last day of the month returned by ADD_MONTHS, the function sets the day number to the last day in the new month. For example, there is no 31st day in February, so ADD_MONTHS returns the last day in the month: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ADD_MONTHS ('31-JAN-1995', 1) ==&gt; 28-FEB-1995</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is perfectly reasonable. However, what if the input date falls on the last day of the month and the new month has more days in it than the original month? If I shift two months forward from 28-FEB-1994, do I get back 30-APR-1994 (the last day of the month) or 28-APR-1994 (the same day in the new month as in the old month)? The answer is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ADD_MONTHS ('28-FEB-1994', 2) ==&gt; 30-APR-1995</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you pass to ADD_MONTHS a day representing the last day in the month, PL/SQL always returns the last day in the resulting month, regardless of the number of actual days in each of the months. This quirk can cause problems. I offer a solution in the section entitled <A
CLASS="xref"
HREF="ch12_02.htm#SQL2-CH-12-SECT-2.1"
>Section 12.2.1, "Customizing the Behavior of ADD_MONTHS"</A
>" later in this chapter. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1.0.2"
>12.1.2 The LAST_DAY function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10763"
></A
>The LAST_DAY function returns the date of the last day of the month for a given date. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION LAST_DAY (date_in IN DATE) RETURN DATE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This function is useful because the number of days in a month varies throughout the year. With LAST_DAY, for example, you do not have to try to figure out if February of this or that year has 28 or 29 days. Just let LAST_DAY figure it out for you. </P
><P
CLASS="para"
>Here are some examples of LAST_DAY:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Go to the last day in the month:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>LAST_DAY ('12-JAN-99') ==&gt; 31-JAN-1999</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If already on the last day, just stay on that day:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>LAST_DAY ('31-JAN-99') ==&gt; 31-JAN-1999</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Get the last day of the month three months after being hired:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>LAST_DAY (ADD_MONTHS (hiredate, 3))</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Tell me the number of days until the end of the month:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>LAST_DAY (SYSDATE) - SYSDATE</PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1.0.3"
>12.1.3 The MONTHS_BETWEEN function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10784"
></A
>The MONTHS_BETWEEN function calculates the number of months between two dates and returns that difference as a number. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION MONTHS_BETWEEN (date1 IN DATE, date2 IN DATE)
   RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following rules apply to MONTHS_BETWEEN:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If date1 comes after date2, then MONTHS_BETWEEN returns a positive number. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If date1 comes before date2, then MONTHS_BETWEEN returns a negative number. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If date1 and date2 are in the same month, then MONTHS_BETWEEN returns a fraction (a value between -1 and +1). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If date1 and date2 both fall on the last day of their respective months, then MONTHS_BETWEEN returns a whole number (no fractional component). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If date1 and date2 are in different months and at least one of the dates is not a last day in the month, MONTHS_BETWEEN returns a fractional number. The fractional component is calculated on a 31-day month basis and also takes into account any differences in the time component of date1 and date2. </P
></LI
></UL
><P
CLASS="para"
>Here are some examples of the uses of MONTHS_BETWEEN:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Calculate two ends of month, the first earlier than the second:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>MONTHS_BETWEEN ('31-JAN-1994', '28-FEB-1994') ==&gt; -1</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Calculate two ends of month, the first later than the second:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>MONTHS_BETWEEN ('31-MAR-1995', '28-FEB-1994') ==&gt; 13</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Calculate when both dates fall in the same month:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>MONTHS_BETWEEN ('28-FEB-1994', '15-FEB-1994') ==&gt;  0</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Perform months_between calculations with a fractional component:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>MONTHS_BETWEEN ('31-JAN-1994', '1-MAR-1994') ==&gt; -1.0322581
MONTHS_BETWEEN ('31-JAN-1994', '2-MAR-1994') ==&gt; -1.0645161
MONTHS_BETWEEN ('31-JAN-1994', '10-MAR-1994') ==&gt; -1.3225806</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>If you detect a pattern here you are right. As I said, MONTHS_BETWEEN calculates the fractional component of the number of months by assuming that each month has 31 days. Therefore, each additional day over a complete month counts for 1/31 of a month, and: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>1 divided by 31 = .032258065--more or less!</PRE
></BLOCKQUOTE
><P
CLASS="para"
>According to this rule, the number of months between January 31, 1994 and February 28, 1994 is one&nbsp;-- a nice, clean integer. But to calculate the number of months between January 31, 1994 and March 1, 1994, I have to add an additional .032258065 to the difference (and make that additional number negative because in this case MONTHS_BETWEEN counts from the first date back to the second date. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1.0.4"
>12.1.4 The NEW_TIME function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10819"
></A
> <A
CLASS="indexterm"
NAME="ch12-idx-765952-2"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-765952-3"
></A
>I don't know about you, but I am simply unable to remember the time in Anchorage when it is 3:00 P.M. in Chicago (and I really doubt that a lot of people in Anchorage can convert to Midwest U.S. time). Fortunately for me, PL/SQL provides the NEW_TIME function. This function converts dates (along with their time components) from one time zone to another. The specification for NEW_TIME is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION NEW_TIME (date_in DATE, zone1 VARCHAR2, zone2 VARCHAR2)
   RETURN DATE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where date_in is the original date, zone1 is the starting point for the zone switch (usually, but not restricted to, your own local time zone), and zone2 is the time zone in which the date returned by NEW_TIME should be placed. </P
><P
CLASS="para"
>The valid time zones are shown in <A
CLASS="xref"
HREF="ch12_01.htm"
>Table 12.2</A
>. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-12-TABLE-6"
>Table 12.2: Time Zone Abbreviations and Descriptions </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Time Zone Abbreviation</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>AST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Atlantic Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ADT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Atlantic Daylight Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>BST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Bering Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>BDT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Bering Daylight Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Central Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CDT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Central Daylight Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>EST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Eastern Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>EDT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Eastern Daylight Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>GMT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Greenwich Mean Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>HST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Alaska-Hawaii Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>HDT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Alaska-Hawaii Daylight Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Mountain Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MDT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Mountain Daylight Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Newfoundland Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>PST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Pacific Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>PDT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Pacific Daylight Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>YST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Yukon Standard Time</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>YDT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Yukon Daylight Time</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The specification of time zones to NEW_TIME is not case-sensitive, as the following example shows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (NEW_TIME (TO_DATE ('09151994 12:30 AM', 'MMDDYYYY HH:MI AM'),
                   'CST', 'hdt'),
         'Month DD, YYYY HH:MI AM')
==&gt; 'September 14, 1994 09:30 PM'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So, when it was 12:30 in the morning of September 15, 1994 in Chicago, it was 9:30 in the evening of September 14, 1994 in Anchorage. </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> By the way, I used TO_DATE with a format mask to make sure that a time other than the default of midnight would be used in the calculation of the new date and time. I then used TO_CHAR with another date mask (this one intended to make the output more readable) to display the date and time, because by default PL/SQL will not include the time component unless specifically requested to do so.<A
CLASS="indexterm"
NAME="AUTOID-10937"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-10938"
></A
></P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1.0.5"
>12.1.5 The NEXT_DAY function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-10942"
></A
>The NEXT_DAY function returns the date of the first day after the specified date which falls on the specified day of the week. Here is the specification for NEXT_DAY: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION NEXT_DAY (date_in IN DATE, day_name IN VARCHAR2) RETURN DATE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The day_name must be a day of the week in your session's date language (specified by the NLS_DATE_LANGUAGE database initialization parameter). The time component of the returned date is the same as that of the input date, date_in. If the day of the week of the input date matches the specified day_name, then NEXT_DAY will return the date seven days (one full week) after date_in. NEXT_DAY does not return the input date if the day names match. </P
><P
CLASS="para"
>Here are some examples of the use of NEXT_DAY. Let's figure out the date of the first Monday and Wednesday in 1997 in all of these examples. </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You can use both full and abbreviated day names:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NEXT_DAY ('01-JAN-1997', 'MONDAY') ==&gt; 06-JAN-1997
NEXT_DAY ('01-JAN-1997', 'MON') ==&gt; 06-JAN-1997</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The case of the day name doesn't matter a whit:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NEXT_DAY ('01-JAN-1997', 'monday') ==&gt; 06-JAN-1997</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the date language were Spanish:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NEXT_DAY ('01-JAN-1997', 'LUNES') ==&gt; 06-JAN-1997</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>NEXT_DAY of Wednesday moves the date up a full week:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NEXT_DAY ('01-JAN-1997', 'WEDNESDAY') ==&gt; 08-JAN-1997</PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1.0.6"
>12.1.6 The ROUND function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch12-idx-765955-1"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-765955-2"
></A
> The ROUND function rounds a date value to the nearest date as specified by a format mask. It is just like the standard numeric ROUND function, which rounds a number to the nearest number of specified precision, except that it works with dates. The specification for ROUND is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION ROUND (date_in IN DATE [, format_mask VARCHAR2]) RETURN DATE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The ROUND function always rounds the time component of a date to midnight (12:00 A.M.). The format mask is optional. If you do not include a format mask, ROUND rounds the date to the nearest day. In other words, it checks the time component of the date. If the time is past noon, then ROUND returns the next day with a time component of midnight. </P
><P
CLASS="para"
>The set of format masks for ROUND is a bit different from those masks used by TO_CHAR and TO_DATE. (See <A
CLASS="xref"
HREF="ch14_01.htm"
>Chapter 14, <CITE
CLASS="chapter"
>Conversion Functions</CITE
></A
>, for more information on these functions.) The masks are listed in <A
CLASS="xref"
HREF="ch12_01.htm"
>Table 12.3</A
>. <A
CLASS="indexterm"
NAME="AUTOID-10972"
></A
>These same formats are used by the TRUNC function, described later in this chapter, to perform truncation on dates. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-12-TABLE-8"
>Table 12.3: Format Masks for ROUND and TRUNC </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Format Mask</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Rounds or Truncates to</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CC or SSC</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Century</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>SYYY, YYYY, YEAR, SYEAR, YYY, YY, or Y</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Year (rounds up to next year on July 1)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>IYYY, IYY, IY, or I</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Standard ISO year</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Q</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Quarter (rounds up on the sixteenth day of the second month of the quarter) </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MONTH, MON, MM, or RM</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Month (rounds up on the sixteenth day, which is not necessarily the same as the middle of the month) </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>WW</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Same day of the week as the first day of the year</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>IW</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Same day of the week as the first day of the ISO year</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>W</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Same day of the week as the first day of the month</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DDD, DD, or J</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Day</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DAY, DY, or D</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Starting day of the week</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>HH, HH12, HH24</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Hour</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Minute</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Here are some examples of ROUND dates:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Round up to the next century:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (ROUND (TO_DATE ('01-MAR-1994'), 'CC'), 'DD-MON-YYYY')
==&gt; 01-JAN-2000  </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Round back to the beginning of the current century:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (ROUND (TO_DATE ('01-MAR-1945'), 'CC'), 'DD-MON-YYYY')
==&gt; 01-JAN-1900</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Round down and up to the first of the year:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ROUND (TO_DATE ('01-MAR-1994'), 'YYYY') ==&gt; 01-JAN-1994
ROUND (TO_DATE ('01-SEP-1994'), 'YEAR') ==&gt; 01-JAN-1995</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Round up and down to the quarter (first date in the quarter): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ROUND (TO_DATE ('01-MAR-1994'), 'Q') ==&gt; 01-APR-1994
ROUND (TO_DATE ('15-APR-1994'), 'Q') ==&gt; 01-APR-1994</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Round down and up to the first of the month:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ROUND (TO_DATE ('12-MAR-1994'), 'MONTH') ==&gt; 01-MAR-1994
ROUND (TO_DATE ('17-MAR-1994'), 'MM') ==&gt; 01-APR-1994  </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Day of first of year is Saturday:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (TO_DATE ('01-JAN-1994'), 'DAY') ==&gt; 'SATURDAY'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So round to date of nearest Saturday for `01-MAR-1994':</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ROUND (TO_DATE ('01-MAR-1994'), 'WW') ==&gt; 26-FEB-1994</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>First day in the month is a Friday:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (TO_DATE ('01-APR-1994'), 'DAY') ==&gt; FRIDAY</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So round to date of nearest Friday from April 16, 1994:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR ('16-APR-1994'), 'DAY') ==&gt; SATURDAY
ROUND (TO_DATE ('16-APR-1994'), 'W') ==&gt; 15-APR-1994
TO_CHAR (ROUND (TO_DATE ('16-APR-1994'), 'W'), 'DAY') ==&gt; FRIDAY</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>In the rest of the examples I use TO_DATE in order to pass a time component to the ROUND function, and TO_CHAR to display the new time. </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Round back to nearest day (time always midnight):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (ROUND (TO_DATE ('11-SEP-1994 10:00 AM',
                      'DD-MON-YY HH:MI AM'), 'DD'),
         'DD-MON-YY HH:MI AM')
==&gt; 11-SEP-1994 12:00 AM </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Round forward to the nearest day:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (ROUND (TO_DATE ('11-SEP-1994 4:00 PM',
                      'DD-MON-YY HH:MI AM'), 'DD'),
         'DD-MON-YY HH:MI AM')
==&gt; 12-SEP-1994 12:00 AM </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Round back to the nearest hour:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (ROUND (TO_DATE ('11-SEP-1994 4:17 PM',
                      'DD-MON-YY HH:MI AM'), 'HH'),
         'DD-MON-YY HH:MI AM')
==&gt; 11-SEP-1994 04:00 PM<A
CLASS="indexterm"
NAME="AUTOID-11084"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-11085"
></A
>
 </PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1.0.7"
>12.1.7 The SYSDATE function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-11089"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-11091"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-11094"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-11097"
></A
> The SYSDATE function returns the current system date and time as recorded in the database. The time component of SYSDATE provides the current time to the nearest second. It takes no arguments. The specification for SYSDATE is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION SYSDATE RETURN DATE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>SYSDATE is a function without parameters; as a result, it looks like a system-level variable and programmers tend to use it as if it is a variable. For example, to assign the current date and time to a local PL/SQL variable, you would enter the following: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>my_date := SYSDATE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>However, SYSDATE is not a variable. When you use SYSDATE, you are calling a function, which executes underlying code. </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> In Oracle Version 6 and the earliest releases of the Oracle Server, when you called SYSDATE, PL/SQL issued an implicit cursor to the database to get the current date and time, as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT SYSDATE FROM dual;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because this is no longer the case, you do not need to be as concerned about extra calls to SYSDATE as you would have in earlier releases.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-12-SECT-1.0.8"
>12.1.8 The TRUNC function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch12-idx-765959-1"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-765959-2"
></A
>The TRUNC function truncates date values according to the specified format mask. The specification for TRUNC is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION TRUNC (date_in IN DATE [, format_mask VARCHAR2]) RETURN DATE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The TRUNC date function is similar to the numeric FLOOR function discussed in <A
CLASS="xref"
HREF="ch13_01.htm"
>Chapter 13, <CITE
CLASS="chapter"
>Numeric, LOB, and Miscellaneous Functions</CITE
></A
>. Generally speaking, it rounds down to the beginning of the minute, hour, day, month, quarter, year, or century, as specified by the format mask. </P
><P
CLASS="para"
>TRUNC offers the easiest way to retrieve the first day of the month or first day of the year. It is also useful when you want to ignore the time component of dates. This is often the case when you perform comparisons with dates, such as the following: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF request_date BETWEEN start_date AND end_date
THEN
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The date component of date_entered and start_date might be the same, but if your application does not specify a time component for each of its dates, the comparison might fail. If, for example, the user enters a request_date and the screen does not include a time component, the time for request_date will be midnight or 12:00 A.M. of that day. If start_date was set from SYSDATE, however, its time component will reflect the time at which the assignment was made. Because 12:00 A.M. comes before any other time of the day, a comparison that looks to the naked eye like a match might well fail. </P
><P
CLASS="para"
>If you are not sure about the time components of your date fields and variables and want to make sure that your operations on dates disregard the time component, TRUNCate them: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF TRUNC (request_date) BETWEEN TRUNC (start_date) AND TRUNC (end_date)
THEN
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>TRUNC levels the playing field with regard to the time component: all dates now have the same time of midnight (12:00 A.M.). The time will never be a reason for a comparison to fail. </P
><P
CLASS="para"
>Here are some examples of TRUNC for dates (all assuming a default date format mask of DD-MON-YYYY): </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Without a format mask, TRUNC sets the time to 12:00 A.M. of the same day: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (TRUNC (TO_DATE ('11-SEP-1994 9:36 AM', 'DD-MON-YYYY HH:MI AM'))
==&gt; 11-SEP-1994 12:00 AM </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Trunc to the beginning of the century in all cases:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (TRUNC (TO_DATE ('01-MAR-1994'), 'CC'), 'DD-MON-YYYY')
==&gt; 01-JAN-1900

TO_CHAR (TRUNC (TO_DATE ('01-MAR-1945'), 'CC'), 'DD-MON-YYYY')
==&gt; 01-JAN-1900</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Trunc to the first of the current year:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TRUNC (TO_DATE ('01-MAR-1994'), 'YYYY') ==&gt; 01-JAN-1994
TRUNC (TO_DATE ('01-SEP-1994'), 'YEAR') ==&gt; 01-JAN-1994</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Trunc to the first day of the quarter: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TRUNC (TO_DATE ('01-MAR-1994'), 'Q') ==&gt; 01-JAN-1994
TRUNC (TO_DATE ('15-APR-1994'), 'Q') ==&gt; 01-APR-1994</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Trunc to the first of the month:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TRUNC (TO_DATE ('12-MAR-1994'), 'MONTH') ==&gt; 01-MAR-1994
TRUNC (TO_DATE ('17-MAR-1994'), 'MM') ==&gt; 01-APR-1994  </PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>In the rest of the examples I use TO_DATE to pass a time component to the TRUNC function, and TO_CHAR to display the new time: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Trunc back to the beginning of the current day (time is always midnight): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (TRUNC (TO_DATE ('11-SEP-1994 10:00 AM',
                      'DD-MON-YYYY HH:MI AM'), 'DD'),
         'DD-MON-YYYY HH:MI AM')
==&gt; 11-SEP-1994 12:00 AM

TO_CHAR (TRUNC (TO_DATE ('11-SEP-1994 4:00 PM',
                      'DD-MON-YYYY HH:MI AM'), 'DD'),
         'DD-MON-YYYY HH:MI AM')
==&gt; 11-SEP-1994 12:00 AM </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Trunc to the beginning of the current hour:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (TRUNC (TO_DATE ('11-SEP-1994 4:17 PM',
                      'DD-MON-YYYY HH:MI AM'), 'HH'),
       'DD-MON-YYYY HH:MI AM')
==&gt; 11-SEP-1994 04:00 PM<A
CLASS="indexterm"
NAME="AUTOID-11149"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-11150"
></A
>
 </PRE
></BLOCKQUOTE
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm#SQL2-CH-11-SECT-2.4"
TITLE="11.2 Character Function Examples"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 11.2 Character Function Examples"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch12_02.htm#SQL2-CH-12-SECT-2.1"
TITLE="12.2 Date Function Examples"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 12.2 Date Function Examples"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>11.2 Character Function Examples</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>12.2 Date Function Examples</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
