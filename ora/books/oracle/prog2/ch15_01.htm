<HTML
><HEAD
><TITLE
>[Chapter 15] Procedures and Functions</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:02:43Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part04.htm"
TITLE="IV. Modular Code "><LINK
REL="prev"
HREF="part04.htm"
TITLE="IV. Modular Code "><LINK
REL="next"
HREF="ch15_02.htm#SQL2-CH-15-SECT-2.1"
TITLE="15.2 Review of PL/SQL Block Structure"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part04.htm"
TITLE="IV. Modular Code "
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: IV. Modular Code "
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 15</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_02.htm#SQL2-CH-15-SECT-2.1"
TITLE="15.2 Review of PL/SQL Block Structure"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 15.2 Review of PL/SQL Block Structure"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SQL2-CH-15"
>15. Procedures and Functions</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SQL2-CH-15-SECT-1"
TITLE="15.1 Modular Code"
>Modular Code</A
><BR><A
CLASS="sect1"
HREF="ch15_02.htm#SQL2-CH-15-SECT-2.1"
TITLE="15.2 Review of PL/SQL Block Structure"
>Review of PL/SQL Block Structure</A
><BR><A
CLASS="sect1"
HREF="ch15_03.htm"
TITLE="15.3 The Anonymous PL/SQL Block"
>The Anonymous PL/SQL Block</A
><BR><A
CLASS="sect1"
HREF="ch15_04.htm#SQL2-CH-15-SECT-4.4"
TITLE="15.4 Procedures"
>Procedures</A
><BR><A
CLASS="sect1"
HREF="ch15_05.htm#SQL2-CH-15-SECT-5.3"
TITLE="15.5 Functions"
>Functions</A
><BR><A
CLASS="sect1"
HREF="ch15_06.htm#SQL2-CH-15-SECT-6.2.3"
TITLE="15.6 Parameters"
>Parameters</A
><BR><A
CLASS="sect1"
HREF="ch15_07.htm"
TITLE="15.7 Local Modules"
>Local Modules</A
><BR><A
CLASS="sect1"
HREF="ch15_08.htm#SQL2-CH-15-SECT-8.4"
TITLE="15.8 Module Overloading"
>Module Overloading</A
><BR><A
CLASS="sect1"
HREF="ch15_09.htm"
TITLE="15.9 Forward Declarations"
>Forward Declarations</A
><BR><A
CLASS="sect1"
HREF="ch15_10.htm"
TITLE="15.10 Go Forth and Modularize!"
>Go Forth and Modularize!</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948944-1"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948944-2"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948944-3"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948944-4"
></A
> Previous parts of this book explored in detail all the components of the PL/SQL language: cursors, exceptions, loops, variables, etc. While you certainly need to know about these components when you write applications using PL/SQL, putting the pieces together to create well structured, easily understood, and smoothly maintainable programs is even more important. Because this module building process goes to the core of our purpose, it is absolutely the most critical technique for a programmer to master. </P
><P
CLASS="para"
>Few of our tasks are straightforward. Few solutions can be glimpsed in an instant and immediately put to paper or keyboard. The systems we build are, for the most part, large and complex, with many interacting, if not sometimes conflicting, components. Furthermore, as users deserve, demand, and receive applications that are easier to use and vastly more powerful than their predecessors, the inner world of those applications becomes correspondingly more complicated. </P
><P
CLASS="para"
>One of the biggest challenges in our profession today is to find a way to reduce the complexity of our environment. When faced with a massive problem to solve, a mind is likely to recoil in horror. Where do I start? How can I possibly figure out a way through that jungle of requirements and features? </P
><P
CLASS="para"
>A human being is not a massively parallel computer. Even the brightest of our bunch have trouble keeping track of more than seven or eight tasks at one time. We need to break down huge, intimidating projects into smaller, more manageable components, and then further decompose those components into individual programs with an understandable scope. </P
><P
CLASS="para"
>The best way to deal with having too much to deal with is to not deal with it all at once. Use top-down design, or "step-wise refinement," to break down a seemingly impossible challenge into smaller components. Computer scientists have developed comprehensive methodologies (for top-down design and other approaches) and performed studies on this topic&nbsp;-- I urge you to study their findings. When it comes to developing applications in PL/SQL, however, there is a very clear path you must take to reduce complexity and solve your problems: modularize your code! </P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-1"
>15.1 Modular Code</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13167"
></A
> Modularization is the process by which you break up large blocks of code into smaller pieces&nbsp;-- modules&nbsp;-- which can be called by other modules. Modularization of code is analogous to normalization of data, with many of the same benefits (and a few additional advantages which accrue specifically to code). With modularization, your code becomes: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>More reusable.</EM
> By breaking up a large program or entire application into individual components which "plug-and-play" together, you will usually find that many modules will be used by more than one other program in your current application. Designed properly, these utility programs could even be of use in other applications! </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>More manageable.</EM
> Which would you rather debug: a 10,000-line program or five individual 2,000 line programs that call each other as needed? Our minds work better when we can focus on smaller tasks. You can also test and debug on a smaller scale (unit test) before individual modules are combined for a more complicated system test. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>More readable.</EM
> Modules have names and names describe behavior. The more you move or hide your code behind a programmatic interface, the easier it is to read and understand what that program is doing. Modularization helps you focus on the big picture rather than the individual executable statements. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>More reliable.</EM
> The code you produce will have fewer errors. The errors you do find will be easier to fix because they will be isolated within a module. In addition, your code will be easier to maintain since there is less of it and it is more readable. </P
></LI
></UL
><P
CLASS="para"
>Once you have mastered the different control, conditional, and cursor constructs of the PL/SQL language (the IF statement, loops, etc.), you are ready to write programs. You will not really be ready, however, to build an application until you understand how to create and combine PL/SQL modules. </P
><P
CLASS="para"
>PL/SQL offers the following structures which modularize your code in different ways: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Procedure</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A named PL/SQL block that performs one or more actions and is called as an executable PL/SQL statement. You can pass information into and out of a procedure through its parameter list. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Function</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A named PL/SQL block that returns a single value and is used just like a PL/SQL expression. You can pass information into a function through its parameter list. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Anonymous block</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>An unnamed PL/SQL block that performs one or more actions. An anonymous block gives the developer control over scope of identifiers and exception handling. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Package</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A named collection of procedures, functions, types, and variables. A package is not really a module (it's more of a meta-module), but is so tightly related to modules that I mention it here. </P
></DD
></DL
><P
CLASS="para"
>I use the term <EM
CLASS="emphasis"
>module</EM
> to mean either a function, a procedure, or an anonymous block, which is executed as a standalone script. As is the case with many other programming languages, modules can call other named modules. You can pass information into and out of modules with parameters. Finally, the modular structure of PL/SQL also integrates tightly with exception handlers to provide all encompassing error checking techniques. </P
><P
CLASS="para"
>This chapter will first review the PL/SQL block structure and anonymous blocks, and then move on to procedures and functions. The final portion of the chapter is devoted to parameters and some advanced features of PL/SQL modules, including overloading and forward referencing. </P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part04.htm"
TITLE="IV. Modular Code "
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: IV. Modular Code "
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_02.htm#SQL2-CH-15-SECT-2.1"
TITLE="15.2 Review of PL/SQL Block Structure"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 15.2 Review of PL/SQL Block Structure"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>IV. Modular Code </TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>15.2 Review of PL/SQL Block Structure</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
