<HTML
><HEAD
><TITLE
>[Chapter 9] Records in PL/SQL</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:58:32Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part02.htm"
TITLE="II. PL/SQL Language Elements "><LINK
REL="prev"
HREF="ch08_10.htm"
TITLE="8.10 RAISE Nothing but Exceptions"><LINK
REL="next"
HREF="ch09_02.htm#SQL2-CH-9-SECT-2.1"
TITLE="9.2 Table-Based Records"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_10.htm"
TITLE="8.10 RAISE Nothing but Exceptions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.10 RAISE Nothing but Exceptions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 9</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_02.htm#SQL2-CH-9-SECT-2.1"
TITLE="9.2 Table-Based Records"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 9.2 Table-Based Records"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SQL2-CH-9"
>9. Records in PL/SQL</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SQL2-CH-9-SECT-1"
TITLE="9.1 Record Basics"
>Record Basics</A
><BR><A
CLASS="sect1"
HREF="ch09_02.htm#SQL2-CH-9-SECT-2.1"
TITLE="9.2 Table-Based Records"
>Table-Based Records</A
><BR><A
CLASS="sect1"
HREF="ch09_03.htm#SQL2-CH-9-SECT-3.2"
TITLE="9.3 Cursor-Based Records"
>Cursor-Based Records</A
><BR><A
CLASS="sect1"
HREF="ch09_04.htm#SQL2-CH-9-SECT-4.1"
TITLE="9.4 Programmer-Defined Records"
>Programmer-Defined Records</A
><BR><A
CLASS="sect1"
HREF="ch09_05.htm"
TITLE="9.5 Assigning Values to and from Records"
>Assigning Values to and from Records</A
><BR><A
CLASS="sect1"
HREF="ch09_06.htm#SQL2-CH-9-SECT-6.1.1"
TITLE="9.6 Record Types and Record Compatibility"
>Record Types and Record Compatibility</A
><BR><A
CLASS="sect1"
HREF="ch09_07.htm"
TITLE="9.7 Nested Records"
>Nested Records</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch09-idx-181138-1"
></A
> <A
CLASS="indexterm"
NAME="ch09-idx-181138-2"
></A
> Records in PL/SQL programs are very similar in concept and structure to the rows of a database table. A record is a composite data structure, which means that it is composed of more than one element or component, each with its own value. The record as a whole does not have value of its own; instead, each individual component or <EM
CLASS="emphasis"
>field</EM
> has a value. The record gives you a way to store and access these values as a group. </P
><P
CLASS="para"
>If you are not familiar with using records in your programs, you might initially find them complicated. When used properly, however, records will greatly simplify your life as a programmer. You will often need to transfer data from the database into PL/SQL structures and then use the procedural language to further massage, change, or display that data. When you use a cursor to read information from the database, for example, you can pass that table's record directly into a single PL/SQL record. When you do this you preserve the relationship between all the attributes from the table. </P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1"
>9.1 Record Basics</A
></H2
><P
CLASS="para"
>This section introduces the different types of records and the benefits of using them in your programs. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.1"
>9.1.1 Different Types of Records</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7993"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7996"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7999"
></A
>PL/SQL supports three different kinds of records: table-based, cursor-based, and programmer-defined. These different types of records are used in different ways and for different purposes, but all three share the same internal structure: every record is composed of one or more fields. However, the way these fields are defined in the record depend on the record type. <A
CLASS="xref"
HREF="ch09_01.htm"
>Table 9.1</A
> shows this information about each record type. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-9-TABLE-2"
>Table 9.1: PL/SQL Record Types </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Record Type</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Fields in Record</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Table-based</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>A record based on a table's column structure.</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Each field corresponds to&nbsp;-- and has the same name as&nbsp;-- a column in a table. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Cursor-based </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>A record based on the cursor's SELECT statement.</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Each field corresponds to a column or expression in the cursor SELECT statement. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Programmer-defined </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>A record whose structure you, the programmer, get to define with a declaration statement. </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Each field is defined explicitly (its name and datatype) in the TYPE statement for that record; a field in a programmer-defined record can even be another record. </P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch09_01.htm"
>Figure 9.1</A
> illustrates the way a cursor record adopts the structure of the SELECT statement by using the %ROWTYPE declaration attribute (explained later in this chapter). </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-9-FIG-1"
>Figure 9.1: Mapping of cursor structure to PL/SQL record</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.0901.gif"
ALT="Figure 9.1"></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.2"
>9.1.2 Accessing Record-Based Data</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8047"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-8049"
></A
>You access the fields within a record using dot notation, just as you would identify a column from a database table, in the following format: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;record name&gt;.&lt;field name&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You would reference the first_name column from the employee table as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>employee.first_name</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You would reference the emp_full_name field in the employee PL/SQL record as: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>employee_rec.emp_full_name </PRE
></BLOCKQUOTE
><P
CLASS="para"
>The record or tuple structure of relational database tables has proven to be a very powerful way to represent data in a database, and records in your programs offer similar advantages. The next section describes briefly the reasons you might want to use records. The rest of this chapter show you how to define and use each of the different types of records, and the situations appropriate to each record type. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.3"
>9.1.3 Benefits of Using Records</A
></H3
><P
CLASS="para"
>The record data structure provides a high-level way of addressing and manipulating program-based data. This approach offers the following benefits: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Data abstraction</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Instead of working with individual attributes of an entity or object, you think of and manipulate that entity as a "thing in itself." </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Aggregate operations</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>You can perform operations which apply to all the columns of a record.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Leaner, cleaner code</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>You can write less code and make what you do write more understandable. </P
></DD
></DL
><P
CLASS="para"
>The following sections describe each of these benefits.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.3.1"
>9.1.3.1 Data abstraction</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8081"
></A
> When you abstract something, you generalize it. You distance yourself from the nitty-gritty details and concentrate on the big picture. When you create modules, you abstract the individual actions of the module into a name. The name (and program specification) represents those actions. </P
><P
CLASS="para"
>When you create a record, you abstract all the different attributes or fields of the subject of that record. You establish a relationship between all those different attributes and you give that relationship a name by defining a record. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.3.2"
>9.1.3.2 Aggregate operations</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8088"
></A
> Once you have stored information in records, you can perform operations on whole blocks of data at a time, rather than on each individual attribute. This kind of aggregate operation reinforces the abstraction of the record. Very often you are not really interested in making changes to individual components of a record, but instead to the object which represents all of those different components. </P
><P
CLASS="para"
>Suppose that in my job I need to work with companies, but I don't really care about whether a company has two lines of address information or three. I want to work at the level of the company itself, making changes to, deleting, or analyzing the status of a company. In all these cases I am talking about a whole row in the database, not any specific column. The company record hides all that information from me, yet makes it accessible when and if I need it. This orientation brings you closer to viewing your data as a collection of objects with rules applied to those objects. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.3.3"
>9.1.3.3 Leaner, cleaner code</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8095"
></A
>Using records also helps you to write clearer code and less of it. When I use records, I invariably produce programs which have fewer lines of code, are less vulnerable to change, and need fewer comments. Records also cut down on variable sprawl; instead of declaring many individual variables, I declare a single record. This lack of clutter creates aesthetically attractive code which requires fewer resources to maintain. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.4"
>9.1.4 Guidelines for Using Records</A
></H3
><P
CLASS="para"
>Use of PL/SQL records can have a dramatic impact on your programs, both in initial development and in ongoing maintenance. To ensure that I personally get the most out of record structures, I have set the following guidelines for my development: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8105"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-8108"
></A
>Create corresponding cursors and records. Whenever I create a cursor in my programs, I also create a corresponding record (except in the case of cursor FOR loops). I always FETCH into a record, rather than into individual variables. In those few instances when it might involve a little extra work over simply fetching into a single variable, I marvel at the elegance of this approach and compliment myself on my commitment to principle. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Create table-based records.</EM
> Whenever I need to store table-based data within my programs, I create a new (or use a predefined) table-based record to store that data. I keep my variable use to a minimum and dynamically link my program data structures to my RDBMS data structures with the %ROWTYPE attribute. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8116"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-8119"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-8122"
></A
>Pass records as parameters. Whenever appropriate, I pass records rather than individual variables as parameters in my procedural interfaces. This way, my procedure calls are less likely to change over time, making my code more stable. There is a downside to this technique, however: if a record is passed as an OUT or IN OUT parameter, its field values are saved by the PL/SQL program in case of the need for a rollback. This can use up memory and consume unnecessary CPU cycles. </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.5"
>9.1.5 Referencing a Record and its Fields</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8128"
></A
> The rules you must follow for referencing a record in its entirety or a particular field in the record are the same for all types of records: table, cursor, and programmer-defined. </P
><P
CLASS="para"
>A record's structure is similar to that of a database table. Where a table has columns, a record has fields. <A
CLASS="indexterm"
NAME="AUTOID-8132"
></A
>You reference a table's column by its name in a SQL statement, as in: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT company_id FROM company;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Of course, the fully qualified name of a column is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;table_name&gt;.&lt;column_name&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This full name is often required in a SQL statement to avoid ambiguity, as is true in the following statement: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT employee.company_id, COUNT(*) total_employees
  FROM company, employee
 WHERE company.company_id = employee.company_id;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If I do not preface the name of company_id with the appropriate table name, the SQL compiler will not know to which table that column belongs. The same is true for a record's fields. You reference a record by its name, and you reference a record's field by its full name using dot notation, as in: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;record_name&gt;.&lt;field_name&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So if I create a record named company_rec, which contains a company_id field, then I would reference this field as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>company_rec.company_id</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You must always use the fully qualified name of a field when referencing that field. If you don't, PL/SQL will never be able to determine the "default" record for a field, as it does in a SQL statement. </P
><P
CLASS="para"
>You do not, on the other hand, need to use dot notation when you reference the record as a whole; you simply provide the name of the record. In the following example, I pass a record as a parameter to a procedure: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   TYPE customer_sales_rectype IS RECORD (...);
   customer_rec customer_sales_rectype;
BEGIN
   display_sales_data (customer_rec);
END; </PRE
></BLOCKQUOTE
><P
CLASS="para"
>I didn't make a single dotted reference to any particular field in the customer record. Instead I declared the record type, used it to create the record, used the record type again to define the type for the parameter in the procedure specification, and finally called the procedure, passing it the specific record I declared. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-9-SECT-1.6"
>9.1.6 Comparing Two Records</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8150"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-8153"
></A
> While it is possible to stay at the record level in certain situations, you can't avoid direct references to fields in many other cases. If you want to compare records, for example, you must always do so through comparison of the records' individual fields. </P
><P
CLASS="para"
>Suppose you want to know if the old company information is the same as the new company information, both being stored in records of the same structure. The following test for equality will not compile: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF old_company_rec = new_company_rec /-- Illegal syntax!
THEN
   ...
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>even though the structures of the two records are absolutely identical and based on the same record type (in this case, a table record type). </P
><P
CLASS="para"
>PL/SQL will not automatically compare each individual field in the old company record to the corresponding field in the new company record. Instead, you will have to perform that detailed check yourself, as in: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF old_company_rec.name = new_company_rec.name AND
   old_company_rec.incorp_date = new_company_rec.incorp_date AND
   old_company_rec.address1 = new_company_rec.address1 AND
THEN
   ... the two records are identical ...
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Of course, you do not simply examine the value of a particular field when you work with records and their fields. Instead, you will assign values to the record and its fields, from either scalar variables or other records. You can reference a record's field on both sides of the assignment operator. In the following example I change the contents of a record, even though that record was just filled from a cursor: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR company_cur IS ...;
   company_rec company_cur%ROWTYPE;
BEGIN
   OPEN company_cur;
   FETCH company_cur INTO company_rec;
   company_rec.name := 'New Name';
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There is, in other words, no such thing as a "read-only" PL/SQL record structure. </P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_10.htm"
TITLE="8.10 RAISE Nothing but Exceptions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.10 RAISE Nothing but Exceptions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_02.htm#SQL2-CH-9-SECT-2.1"
TITLE="9.2 Table-Based Records"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 9.2 Table-Based Records"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.10 RAISE Nothing but Exceptions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>9.2 Table-Based Records</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
