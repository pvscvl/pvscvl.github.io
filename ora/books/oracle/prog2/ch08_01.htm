<HTML
><HEAD
><TITLE
>[Chapter 8] Exception Handlers</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:57:51Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part02.htm"
TITLE="II. PL/SQL Language Elements "><LINK
REL="prev"
HREF="ch07_07.htm#SQL2-CH-7-SECT-7.2.2"
TITLE="7.7 Tips for PL/SQL Loops"><LINK
REL="next"
HREF="ch08_02.htm"
TITLE="8.2 The Exception Section"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_07.htm#SQL2-CH-7-SECT-7.2.2"
TITLE="7.7 Tips for PL/SQL Loops"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.7 Tips for PL/SQL Loops"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 8</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.2 The Exception Section"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.2 The Exception Section"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SQL2-CH-8"
>8. Exception Handlers</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SQL2-CH-8-SECT-1"
TITLE="8.1 Why Exception Handling?"
>Why Exception Handling?</A
><BR><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.2 The Exception Section"
>The Exception Section</A
><BR><A
CLASS="sect1"
HREF="ch08_03.htm#SQL2-CH-8-SECT-3.2"
TITLE="8.3 Types of Exceptions"
>Types of Exceptions</A
><BR><A
CLASS="sect1"
HREF="ch08_04.htm#SQL2-CH-8-SECT-4.1.3"
TITLE="8.4 Determining Exception-Handling Behavior"
>Determining Exception-Handling Behavior</A
><BR><A
CLASS="sect1"
HREF="ch08_05.htm#SQL2-CH-8-SECT-5.1.2"
TITLE="8.5 Raising an Exception"
>Raising an Exception</A
><BR><A
CLASS="sect1"
HREF="ch08_06.htm"
TITLE="8.6 Handling Exceptions"
>Handling Exceptions</A
><BR><A
CLASS="sect1"
HREF="ch08_07.htm"
TITLE="8.7 Client-Server Error Communication"
>Client-Server Error Communication</A
><BR><A
CLASS="sect1"
HREF="ch08_08.htm"
TITLE="8.8 NO_DATA_FOUND: Multipurpose Exception"
>NO_DATA_FOUND: Multipurpose Exception</A
><BR><A
CLASS="sect1"
HREF="ch08_09.htm"
TITLE="8.9 Exception Handler as IF Statement"
>Exception Handler as IF Statement</A
><BR><A
CLASS="sect1"
HREF="ch08_10.htm"
TITLE="8.10 RAISE Nothing but Exceptions"
>RAISE Nothing but Exceptions</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-66458-1"
></A
> <A
CLASS="indexterm"
NAME="ch08-idx-66458-2"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-66458-3"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-66458-4"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-66458-5"
></A
>In the PL/SQL language, errors of any kind are treated as exceptions&nbsp;-- situations that should not occur&nbsp;-- in your program. An exception can be one of the following: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>An error generated by the system (such as "out of memory" or "duplicate value in index") </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An error caused by a user action</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A warning issued by the application to the user </P
></LI
></UL
><P
CLASS="para"
>PL/SQL traps and responds to errors using an architecture of exception handlers. The exception-handler mechanism allows you to cleanly separate your error processing code from your executable statements. It also provides an event-driven model, as opposed to a linear code model, for processing errors. In other words, no matter how a particular exception is raised, it is handled by the same exception handler in the exception section. </P
><P
CLASS="para"
>When an error occurs in PL/SQL, whether a system error or an application error, an exception is raised. The processing in the current PL/SQL block's execution section halts and control is transferred to the separate exception section of your program, if one exists, to handle the exception. You cannot return to that block after you finish handling the exception. Instead, control is passed to the enclosing block, if any. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch08_01.htm"
>Figure 8.1</A
> illustrates how control is transferred to the exception section when an exception is raised. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-8-FIG-1"
>Figure 8.1: Exception handling architecture</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.0801.gif"
ALT="Figure 8.1"><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-8-SECT-1"
>8.1 Why Exception Handling?</A
></H2
><P
CLASS="para"
>It is a sad fact of life that most programmers never take the time to properly bullet-proof their programs. Instead, wishful thinking often reigns. Most of us find it hard enough&nbsp;-- and more than enough work&nbsp;-- to simply write the code that implements the positive aspects of an application: maintaining customers, generating invoices, etc. It is devilishly difficult from both a psychological standpoint and a resources perspective to focus on the negative side of our life: what happens when the user presses the wrong key? If the database is unavailable, what should I do? </P
><P
CLASS="para"
>As a result, we write applications that often assume the best of all possible worlds, hoping that our programs are bug-free, that users will enter only the correct data in only the correct fashion, and that all systems (hardware and software) will always be a "go." </P
><P
CLASS="para"
>Of course, harsh reality dictates that no matter how hard you try, there will always be one more bug in your application. And your users will always find just the right sequence of keystrokes it takes to make a screen implode. The situation is clear: either you spend the time up front to properly debug and bulletproof your programs, or you will fight an unending series of rear-guard battles, taking frantic calls from your users and putting out the fires. </P
><P
CLASS="para"
>You know what you should do. Fortunately, PL/SQL offers a powerful and flexible way to trap and handle errors in your programs. It is entirely feasible within the PL/SQL language to build an application which fully protects the user and the database from errors. </P
><P
CLASS="para"
>The exception handler model offers the following advantages:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Event-driven handling of errors.</EM
> As we've mentioned, PL/SQL exception handling follows an event-driven rather than a linear code model. No matter how a particular exception is raised, it is handled by the same exception handler in the exception section. You do not have to check repeatedly for a condition in your code, but instead can insert an exception for that condition once in the exception section and be certain that it will be handled throughout that block (and all of its enclosing blocks). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Clean separation of error-processing code.</EM
> With the exception-handling model, whenever an exception is raised, program control transfers completely out of the normal execution sequence and into the exception section. Instead of placing error-handling logic throughout different sections of your program, you can consolidate all of this logic into a single, separate section. Furthermore, if you need to add new exceptions in your program (perhaps you overlooked a possible problem, or a new kind of system error has been identified), you do not have to figure out where in your executable code to put the error-handling logic. Simply add another exception handler at the bottom of the block. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Improved reliability of error handling.</EM
> It is quite difficult for errors to go undetected with the PL/SQL error-handling model. If there is a handler, then that exception will be dealt with in the current block or in an enclosing block. Even if there is no explicit handler for that error, normal code execution will still stop. Your program cannot simply "work through" an error&nbsp;-- unless you explicitly organize your code to allow this. </P
></LI
></UL
><P
CLASS="para"
>There is no avoiding the fact that if you want to trap errors in your PL/SQL programs you will have to write some additional code. The exception handler architecture, however, minimizes the amount of code you will need to write, and offers the possibility of guarding against all problems that might arise in your application. The following sections look at how you define, raise, and handle exceptions in PL/SQL.<A
CLASS="indexterm"
NAME="AUTOID-7159"
></A
> </P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_07.htm#SQL2-CH-7-SECT-7.2.2"
TITLE="7.7 Tips for PL/SQL Loops"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.7 Tips for PL/SQL Loops"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.2 The Exception Section"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.2 The Exception Section"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>7.7 Tips for PL/SQL Loops</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.2 The Exception Section</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
