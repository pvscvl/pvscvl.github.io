<HTML
><HEAD
><TITLE
>[Appendix C] C.15 DBMS_TRANSACTION</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:14:42Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="appc_01.htm"
TITLE="C. Built-In Packages"><LINK
REL="prev"
HREF="appc_14.htm#SQL2-AP-C-SECT-14.0.2"
TITLE="C.14 DBMS_SQL"><LINK
REL="next"
HREF="appc_16.htm#appc-133-fm2xml"
TITLE="C.16 DBMS_UTILITY"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appc_14.htm#SQL2-AP-C-SECT-14.0.2"
TITLE="C.14 DBMS_SQL"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: C.14 DBMS_SQL"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="appendix"
REL="up"
HREF="appc_01.htm"
TITLE="C. Built-In Packages"
>Appendix C<BR>Built-In Packages</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appc_16.htm#appc-133-fm2xml"
TITLE="C.16 DBMS_UTILITY"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: C.16 DBMS_UTILITY"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-15"
>C.15 DBMS_TRANSACTION</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="appc-idx-998564-1"
></A
><A
CLASS="indexterm"
NAME="appc-idx-998564-2"
></A
>DBMS_TRANSACTION package provides a programmatic interface to a number of the SQL transaction statements. The majority of these procedures (advise_commit through rollback_force) have SQL equivalents that you can invoke directly from within PL/SQL. Thus, many PL/SQL programmers choose to use the SQL equivalents rather than these procedures. However, the last five procedures (begin_discrete_transaction through step_id) have no equivalents and nicely abstract the PL/SQL programmer or database administrator from the internals of what is being accomplished. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-114-fm2xml"
>C.15.1 The <A
CLASS="indexterm"
NAME="AUTOID-24892"
></A
> ADVISE_COMMIT procedure</A
></H3
><P
CLASS="para"
>The ADVISE_COMMIT procedure specifies that "commit" in-doubt transaction advice is sent to remote databases during distributed transactions. </P
><P
CLASS="para"
>The advice generated by this procedure appears on the remote database in the ADVICE column of the DBA_2PC_PENDING data dictionary view if the distributed transaction becomes in-doubt (i.e., a network or machine failure occurs during the commit). The remote database administrator can then review the DBA_2PC_PENDING information and manually commit or roll back in-doubt transactions using the FORCE clause of the COMMIT or ROLLBACK commands. Each call to an ADVISE procedure remains in effect for the duration of that connection or until a different ADVISE procedure call is made. This allows you to send different advice to various remote databases. </P
><P
CLASS="para"
>This procedure is equivalent to the SQL command, ALTER SESSION ADVISE COMMIT. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ADVISE_COMMIT;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-115-fm2xml"
>C.15.2 The <A
CLASS="indexterm"
NAME="AUTOID-24900"
></A
> ADVISE_NOTHING procedure</A
></H3
><P
CLASS="para"
>The ADVISE_NOTHING procedure specifies that no in-doubt transaction advice is sent to remote databases during distributed transactions. Advice is handled as described for ADVISE_COMMIT. This procedure is equivalent to the SQL command, ALTER SESSION ADVISE NOTHING. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ADVISE_NOTHING;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-116-fm2xml"
>C.15.3 The <A
CLASS="indexterm"
NAME="AUTOID-24906"
></A
> ADVISE_ROLLBACK procedure</A
></H3
><P
CLASS="para"
>The ADVISE_ROLLBACK procedure specifies that "rollback" in-doubt transaction advice is sent to remote databases during distributed transactions. Advice is handled as described for ADVISE_COMMIT. This procedure is equivalent to the SQL command, ALTER SESSION ADVISE ROLLBACK. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ADVISE_ROLLBACK;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-117-fm2xml"
>C.15.4 The <A
CLASS="indexterm"
NAME="AUTOID-24912"
></A
> COMMIT procedure </A
></H3
><P
CLASS="para"
>The COMMIT procedure ends the current transaction and makes permanent all pending changes. It also erases savepoints and releases all locks. It is provided primarily for completeness. It is equivalent to the COMMIT command, which is already implemented as part of PL/SQL. I recommend using the SQL command rather than the procedure. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.COMMIT;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-118-fm2xml"
>C.15.5 The <A
CLASS="indexterm"
NAME="AUTOID-24918"
></A
> COMMIT_COMMENT procedure </A
></H3
><P
CLASS="para"
>The COMMIT_COMMENT procedure performs a commit and sends a "commit" in-doubt transaction comment to remote databases during distributed transactions. This comment appears on the remote database in the TRAN_COMMENT column of the DBA_2PC_PENDING data dictionary view if the distributed transaction becomes in-doubt (i.e., a network or machine failure occurs during the commit). The remote database administrator can then review the DBA_2PC_PENDING information and manually commit or roll back in-doubt transactions using the FORCE clause of the COMMIT or ROLLBACK commands. This procedure is equivalent to the SQL command, COMMIT COMMENT. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.COMMIT_COMMENT (cmnt VARCHAR2);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-119-fm2xml"
>C.15.6 The <A
CLASS="indexterm"
NAME="AUTOID-24924"
></A
> COMMIT_FORCE procedure</A
></H3
><P
CLASS="para"
>The COMMIT_FORCE procedure manually commits local in-doubt, distributed transactions. Any decisions to force in-doubt transactions should be made after consulting with the database administrator(s) at the remote database location(s). If the decision is made to locally force any transactions, the database administrator should either commit or rollback such transactions as was done by nodes that successfully resolved the transactions. Otherwise, the administrator should query the DBA_2PC_PENDING views ADVICE and TRAN_COMMENT columns for further insight.[<A
CLASS="footnote"
HREF="#AUTOID-24927"
>2</A
>] This procedure is equivalent to the SQL command, COMMIT FORCE. The specification is: </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-24927"
>[2]</A
> For more information on this topic, see "Manually Overriding In-Doubt Transactions" in <CITE
CLASS="citetitle"
>Oracle8 Server Distributed Systems</CITE
> .</P
></DIV
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.COMMIT_FORCE
   (xid VARCHAR2,
    scn VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-120-fm2xml"
>C.15.7 The <A
CLASS="indexterm"
NAME="AUTOID-24933"
></A
> READ_ONLY procedure</A
></H3
><P
CLASS="para"
>The READ_ONLY procedure establishes the current transaction as a read-consistent transaction (i.e., repeatable reads). Once a transaction is designated as read-only, all queries within that transaction can only see changes committed prior to that transactions start. Thus, read-only transactions let you issue two or more queries against tables that may be undergoing concurrent inserts or updates, and yet return results consistent as of the transaction's start. This procedure is equivalent to the SQL command, SET TRANSACTION READ ONLY. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
> PROCEDURE DBMS_TRANSACTION.READ_ONLY;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-121-fm2xml"
>C.15.8 The <A
CLASS="indexterm"
NAME="AUTOID-24939"
></A
> READ_WRITE procedure</A
></H3
><P
CLASS="para"
>The READ_WRITE procedure establishes the current transaction as a read-write transaction. This is the default transaction mode. This procedure is equivalent to the SQL command, SET TRANSACTION READ WRITE. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.READ-WRITE;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-122-fm2xml"
>C.15.9 The <A
CLASS="indexterm"
NAME="AUTOID-24945"
></A
> ROLLBACK procedure</A
></H3
><P
CLASS="para"
>The ROLLBACK procedure ends the current transaction and undoes all pending changes. It also erases savepoints and releases all locks. It is provided primarily for completeness. It is equivalent to the ROLLBACK command, which is already implemented as part of PL/SQL. I recommend using the SQL command rather than the procedure. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ROLLBACK;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-123-fm2xml"
>C.15.10 The <A
CLASS="indexterm"
NAME="AUTOID-24951"
></A
> ROLLBACK_FORCE procedure</A
></H3
><P
CLASS="para"
>The ROLLBACK_FORCE procedure manually rolls back local in-doubt, distributed transactions. The parameter identifies the transaction's local or global transaction ID. To find these transaction IDs, query the data dictionary view DBA_2PC_PENDING. Any decisions to force in-doubt transactions should be made after consulting with the database administrator(s) at the remote database location(s), as described for COMMIT_FORCE. This procedure is equivalent to the SQL command, ROLLBACK FORCE. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ROLLBACK_FORCE (xid VARCHAR2);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-124-fm2xml"
>C.15.11 The <A
CLASS="indexterm"
NAME="AUTOID-24957"
></A
> ROLLBACK_SAVEPOINT procedure</A
></H3
><P
CLASS="para"
>The ROLLBACK_SAVEPOINT procedure rolls back the current transaction to a previously declared savepoint. It is provided primarily for completeness. It is equivalent to the ROLLBACK SAVEPOINT command, which is already implemented as part of PL/SQL. I recommend using the SQL command rather than the procedure. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ROLLBACK_SAVEPOINT;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-125-fm2xml"
>C.15.12 The <A
CLASS="indexterm"
NAME="AUTOID-24963"
></A
> SAVEPOINT procedure </A
></H3
><P
CLASS="para"
>The SAVEPOINT procedure identifies a logical point within a transaction to which you can later roll back. It is provided primarily for completeness. It is equivalent to the SAVEPOINT command, which is already implemented as part of PL/SQL. I recommend using the SQL command rather than the procedure. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.SAVEPOINT;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-126-fm2xml"
>C.15.13 The <A
CLASS="indexterm"
NAME="AUTOID-24969"
></A
> USE_ROLLBACK_SEGMENT procedure</A
></H3
><P
CLASS="para"
>The USE_ROLLBACK_SEGMENT procedure assigns the current transaction to the specified rollback segment. This option also establishes the transaction as a read-write transaction. The rollback segment specified must be online. You cannot use both the READ_ONLY and USE_ROLLBACK_SEGMENT procedures within the same transaction. Read-only transactions do not generate rollback information and thus cannot be assigned rollback segments. This procedure is equivalent to the SQL command, SET TRANSACTION USE ROLLBACK SEGMENT. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.USE_ROLLBACK_SEGMENT (rb_name VARCHAR2);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-127-fm2xml"
>C.15.14 The <A
CLASS="indexterm"
NAME="AUTOID-24975"
></A
> BEGIN_DISCRETE_TRANSACTION procedure</A
></H3
><P
CLASS="para"
>The BEGIN_DISCRETE_TRANSACTION procedure streamlines transaction processing so short transactions can execute more rapidly. During discrete transactions, normal redo information is generated although it is stored in a separate location in memory. When the discrete transaction commits, the redo information is written to the redo log file and data block changes are applied directly. As such, there is no need for undo information in rollback segments. The block is then written to the database file in the usual manner. The call to this procedure is effective only until the transaction is committed or rolled back; the next transaction is processed as a standard transaction. Any PL/SQL using this procedure must be coded to ensure that the transaction is attempted again in the event of a discrete transaction failure.[<A
CLASS="footnote"
HREF="#AUTOID-24978"
>3</A
>] The specification is: </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-24978"
>[3]</A
> For more information on this topic, see "Using Discrete Transactions" in <CITE
CLASS="citetitle"
> Oracle8 Server Tuning</CITE
> .</P
></DIV
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.BEGIN_DISCRETE_TRANSACTION;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-128-fm2xml"
>C.15.15 The <A
CLASS="indexterm"
NAME="AUTOID-24984"
></A
> PURGE_MIXED procedure</A
></H3
><P
CLASS="para"
>The PURGE_MIXED procedure deletes information about a given in-doubt, distributed transaction that has had mixed outcomes due to a transaction resolution mismatch. This occurs when an in-doubt, distributed transaction is forced to commit or roll back on one node and other nodes do the opposite. Oracle cannot automatically resolve such inconsistencies, but it does flag entries in the DBA_2PC_PENDING view by setting the MIXED column to yes. When the database administrator is sure that any inconsistencies for a transaction have been resolved, he or she can call the PURGE_MIXED procedure.[<A
CLASS="footnote"
HREF="#AUTOID-24987"
>4</A
>] The specification is: </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-24987"
>[4]</A
> For more information on this topic, see "Manually Overriding In-Doubt Transactions" in <CITE
CLASS="citetitle"
>Oracle8 Server Distributed Systems</CITE
> .</P
></DIV
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.PURGE_MIXED (xid VARCHAR2);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-129-fm2xml"
>C.15.16 The <A
CLASS="indexterm"
NAME="AUTOID-24993"
></A
> PURGE_LOST_DB procedure </A
></H3
><P
CLASS="para"
>The PURGE_LOST_DB procedure deletes information about a given in-doubt, distributed transaction that has had mixed outcomes due to a lost database. This occurs when an in-doubt, distributed transaction is able to commit or roll back on one node and other nodes have either destroyed or recreated their databases. Oracle cannot automatically resolve such inconsistencies, as described in PURGE_MIXED. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.PURGE_LOST_DB (xid VARCHAR2);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-130-fm2xml"
>C.15.17 The <A
CLASS="indexterm"
NAME="AUTOID-24999"
></A
> LOCAL_TRANSACTION_ID function</A
></H3
><P
CLASS="para"
>The LOCAL_TRANSACTION_ID function returns the unique identifier for the current transaction. The function returns NULL if there is no current transaction. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	FUNCTION DBMS_TRANSACTION.LOCAL_TRANSACTION_ID
   (create_transaction BOOLEAN := false)
RETURN VARCHAR2;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-131-fm2xml"
>C.15.18 The <A
CLASS="indexterm"
NAME="AUTOID-25005"
></A
> STEP_ID function</A
></H3
><P
CLASS="para"
>The STEP_ID function returns the unique positive integer that orders the DML operations of the current transaction. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	FUNCTION DBMS_TRANSACTION.STEP_ID RETURN VARCHAR2; <A
CLASS="indexterm"
NAME="AUTOID-25009"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-25010"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appc_14.htm#SQL2-AP-C-SECT-14.0.2"
TITLE="C.14 DBMS_SQL"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: C.14 DBMS_SQL"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appc_16.htm#appc-133-fm2xml"
TITLE="C.16 DBMS_UTILITY"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: C.16 DBMS_UTILITY"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>C.14 DBMS_SQL</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>C.16 DBMS_UTILITY</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
