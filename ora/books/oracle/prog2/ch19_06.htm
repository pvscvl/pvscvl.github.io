<HTML
><HEAD
><TITLE
>[Chapter 19] 19.6 Collection Built-Ins</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:08:57Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch19_01.htm"
TITLE="19. Nested Tables and VARRAYs"><LINK
REL="prev"
HREF="ch19_05.htm#SQL2-CH-19-SECT-5.2"
TITLE="19.5 Collection Pseudo-Functions"><LINK
REL="next"
HREF="ch19_07.htm"
TITLE="19.7 Example: PL/SQL-to-Server Integration"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_05.htm#SQL2-CH-19-SECT-5.2"
TITLE="19.5 Collection Pseudo-Functions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 19.5 Collection Pseudo-Functions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch19_01.htm"
TITLE="19. Nested Tables and VARRAYs"
>Chapter 19<BR>Nested Tables and VARRAYs</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_07.htm"
TITLE="19.7 Example: PL/SQL-to-Server Integration"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 19.7 Example: PL/SQL-to-Server Integration"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-19-SECT-6"
>19.6 Collection Built-Ins</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-8635-1"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-8635-2"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-8635-3"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-8635-4"
></A
> <A
CLASS="indexterm"
NAME="ch19-idx-8635-5"
></A
>As we've seen already, there are a number of built-in functions and procedures that apply to collection variables. These functions are collectively known as "collection methods" in honor of their object-like invocation syntax. That is, you invoke them using a "<EM
CLASS="emphasis"
>variable</EM
>-dot-<EM
CLASS="emphasis"
>method</EM
> " style. For functions, use this syntax: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>result := <I
CLASS="replaceable"
>collection_variable.function_method (method_argument);</I
></PRE
></BLOCKQUOTE
><P
CLASS="para"
>where "result" must be of a datatype that is type-compatible with the method. For procedures, the syntax is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
><I
CLASS="replaceable"
>collection_variable.procedure_method (method_arguments);</I
></PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following methods are not available from within SQL; they can only be used within PL/SQL programs. The first seven are functions (and are the same methods available for PL/SQL or index-by tables in PL/SQL Release 2.3), and the last three are procedures. For quick reference purposes, this section documents each method using a standard format, which includes an example. </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>COUNT function</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns the current number of elements in a collection.</P
></DD
><DT
CLASS="term"
>DELETE procedure</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Removes one or more elements from the "middle" of a nested table. Reduces COUNT if the element is not already DELETEd. Does not apply to VARRAYs. </P
></DD
><DT
CLASS="term"
>EXISTS function</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns TRUE or FALSE to indicate whether the specified element exists. </P
></DD
><DT
CLASS="term"
>EXTEND procedure</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Increases the number of elements in a collection. Increases COUNT.</P
></DD
><DT
CLASS="term"
>FIRST, LAST functions</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Return the smallest (FIRST) and largest (LAST) subscripts in use.</P
></DD
><DT
CLASS="term"
>LIMIT function</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns the maximum number of allowed elements in a VARRAY.</P
></DD
><DT
CLASS="term"
>PRIOR, NEXT functions</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Return the subscript immediately before (PRIOR) or after (NEXT) a specified subscript. Useful for nested tables that might be sparse. </P
></DD
><DT
CLASS="term"
>TRIM procedure</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Removes collection elements at the "end" of the collection. Reduces COUNT if elements are not DELETEd. </P
></DD
></DL
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-32-fm2xml"
>19.6.1 COUNT<A
CLASS="indexterm"
NAME="ch19-idx-8641-1"
></A
></A
></H3
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Specification</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION COUNT RETURN BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Example</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR element IN 1..my_list.COUNT
LOOP
   DBMS_OUTPUT.PUT_LINE (my_list(element));
END LOOP;
/* Note: If my_list is a nested table with any deleted elements
|| in the middle, the my_list(element) reference above will
|| generate a NO_DATA_FOUND exception.
*/</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Returns</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Current number of elements in a collection. If elements have been DELETEd or TRIMmed from the collection, they are not included in COUNT. </P
></DD
><DT
CLASS="term"
>Applies to</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Nested tables, index-by tables, VARRAYs.</P
></DD
><DT
CLASS="term"
>Boundary considerations</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to an initialized collection with no elements, returns zero. Also returns zero if applied to empty index-by table. </P
></DD
><DT
CLASS="term"
>Exceptions possible</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to an uninitialized nested table or a VARRAY, raises COLLECTION_IS_NULL predefined exception. (This exception is not possible for index-by tables, which do not require initialization.)<A
CLASS="indexterm"
NAME="AUTOID-18338"
></A
> </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-19-SECT-6.0.2"
>19.6.2 DELETE [ ( i [ , j ] ) ]</A
></H3
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Specification (overloaded)</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
><CODE
CLASS="literal"
>PROCEDURE DELETE;</CODE
>
<CODE
CLASS="literal"
>PROCEDURE DELETE (i BINARY_INTEGER);</CODE
>
<CODE
CLASS="literal"
>PROCEDURE DELETE (i BINARY_INTEGER, j BINARY_INTEGER);</CODE
></PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Example</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE PROCEDURE keep_last (the_list IN OUT List_t)
AS
   first_elt BINARY_INTEGER := the_list.FIRST;
   next_to_last_elt BINARY_INTEGER := the_list.PRIOR(the_list.LAST);
BEGIN
   the_list.DELETE(first_elt, next_to_last_elt);
END;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Action</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>DELETE without arguments removes all the elements of a collection. DELETE(<EM
CLASS="emphasis"
>i</EM
>) removes the <EM
CLASS="emphasis"
>i</EM
>th element from the nested table or index-by table. DELETE(<EM
CLASS="emphasis"
>i</EM
>,<EM
CLASS="emphasis"
>j</EM
>) removes all elements in an inclusive range beginning with <EM
CLASS="emphasis"
>i</EM
> and ending with <EM
CLASS="emphasis"
>j</EM
>. When you use parameters, DELETE actually keeps a placeholder for the "removed" element, and you can later reassign a value to that element. </P
></DD
></DL
><BLOCKQUOTE
CLASS="warning"
><P
CLASS="para"
><STRONG
>WARNING:</STRONG
> Confusing behavior results if you TRIM and DELETE the same collection.</P
></BLOCKQUOTE
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Applies to</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Nested tables, index-by tables. Also, DELETE without arguments can be applied to VARRAYs. </P
></DD
><DT
CLASS="term"
>Boundary considerations</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If <EM
CLASS="emphasis"
>i</EM
> and/or <EM
CLASS="emphasis"
>j</EM
> refer to nonexistent elements, DELETE will attempt to "do the right thing" and will not raise an exception. For example, if you have three elements in a TABLE item and DELETE(-5,1), the first element will be deleted. However, DELETE(-5) will do nothing. </P
></DD
><DT
CLASS="term"
>Exceptions possible</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to an uninitialized nested table or a VARRAY, raises COLLECTION_IS_NULL predefined exception. </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-19-SECT-6.0.3"
>19.6.3 EXISTS(i)</A
></H3
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Specification<A
CLASS="indexterm"
NAME="AUTOID-18385"
></A
> </DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION EXISTS (i IN BINARY_INTEGER) RETURN BOOLEAN;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Example</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   my_list Color_tab_t := Color_tab_t();
   element INTEGER := 1;
BEGIN
   ...
   IF my_list.EXISTS(element)
   THEN
     my_list(element) := NULL;
   END IF;
END;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Returns</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Boolean TRUE if i th element exists, FALSE otherwise. Never returns NULL. If you have used TRIM or DELETE to remove an element <EM
CLASS="emphasis"
>i</EM
> that existed previously, EXISTS(<EM
CLASS="emphasis"
>i</EM
>) returns false. </P
></DD
><DT
CLASS="term"
>Applies to</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Nested tables, index-by tables, VARRAYs.</P
></DD
><DT
CLASS="term"
>Boundary considerations</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to an uninitialized (atomically null) nested table or VARRAY, or to an initialized collection with no elements, simply returns FALSE. You can use EXISTS beyond the COUNT without raising an exception. </P
></DD
><DT
CLASS="term"
>Exceptions possible</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If i is not an integer and cannot be converted to an integer, EXISTS will raise VALUE_ERROR. This exception is possible for any collection method which accepts an argument. </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-19-SECT-6.0.4"
>19.6.4 EXTEND [ (n [,i] ) ]</A
></H3
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Specification (overloaded)<A
CLASS="indexterm"
NAME="ch19-idx-8652-1"
></A
> </DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE EXTEND (n BINARY_INTEGER:=1);
PROCEDURE EXTEND (n BINARY_INTEGER, i BINARY_INTEGER);</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Example</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE PROCEDURE push (the_list IN OUT List_t, new_value IN VARCHAR2)
AS
BEGIN
   the_list.EXTEND;
   the_list(the_list.LAST) := new_value;
END;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Action</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Appends element(s) to a collection. EXTEND with no arguments appends a single null element. EXTEND(<EM
CLASS="emphasis"
>n</EM
>) appends <EM
CLASS="emphasis"
>n</EM
> null elements. EXTEND(<EM
CLASS="emphasis"
>n</EM
>,<EM
CLASS="emphasis"
>i</EM
>) appends <EM
CLASS="emphasis"
>n</EM
> elements and sets each to the same value as the <EM
CLASS="emphasis"
>i</EM
>th element; this form of EXTEND is required for collections with NOT NULL elements. </P
></DD
><DT
CLASS="term"
>Applies to</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Nested tables, VARRAYs. Applying it to an index-by table will cause a compile-time error. </P
></DD
><DT
CLASS="term"
>Boundary considerations</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If you have deleted or trimmed from the end of a collection, EXTEND will "jump over" (skip) the deleted elements when it assigns a new index. If <EM
CLASS="emphasis"
>n</EM
> is null, EXTEND will do nothing. </P
></DD
><DT
CLASS="term"
>Exceptions possible</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to an uninitialized nested table or a VARRAY, raises COLLECTION_IS_NULL predefined exception. An attempt to EXTEND a VARRAY beyond its declared limit raises SUBSCRIPT_BEYOND_LIMIT. If the <EM
CLASS="emphasis"
>i</EM
>th element does not exist, EXTEND will raise SUBSCRIPT_BEYOND_COUNT or, in the case of a VARRAY with a limit less than i, EXTEND will raise SUBSCRIPT_BEYOND_LIMIT.<A
CLASS="indexterm"
NAME="AUTOID-18448"
></A
> </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-19-SECT-6.0.5"
>19.6.5 FIRST, LAST</A
></H3
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Specification</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION FIRST RETURN BINARY_INTEGER;<A
CLASS="indexterm"
NAME="AUTOID-18456"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-18458"
></A
>

FUNCTION LAST RETURN BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Example</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF my_list.EXISTS(my_list.FIRST)
THEN
   my_list(my_list.FIRST) := 42;
ELSE
   my_list.EXTEND;
   my_list(my_list.FIRST) := 42;
END IF;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Returns</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>FIRST returns the lowest index in use in the collection; LAST returns the highest. </P
></DD
><DT
CLASS="term"
>Applies to</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Nested tables, index-by tables, VARRAYs.</P
></DD
><DT
CLASS="term"
>Boundary considerations</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>FIRST and LAST return NULL when applied to initialized collections which have no elements. For VARRAYs which have at least one element, FIRST is always 1, and LAST is always equal to COUNT. </P
></DD
><DT
CLASS="term"
>Exceptions possible</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to an uninitialized nested table or a VARRAY, raises COLLECTION_IS_NULL predefined exception. </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-19-SECT-6.0.6"
>19.6.6 LIMIT</A
></H3
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Specification<A
CLASS="indexterm"
NAME="AUTOID-18485"
></A
> </DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION LIMIT RETURN BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Example</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF my_list.LAST &lt; my_list.LIMIT
THEN
   my_list.EXTEND;
END IF;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Returns</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The maximum number of elements that is possible for a given VARRAY.</P
></DD
><DT
CLASS="term"
>Applies to</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>VARRAYs only. Returns NULL if applied to nested tables or index-by tables. </P
></DD
><DT
CLASS="term"
>Boundary considerations</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>None</P
></DD
><DT
CLASS="term"
>Exceptions possible</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to an uninitialized nested table or a VARRAY, raises COLLECTION_IS_NULL predefined exception. </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-19-SECT-6.0.7"
>19.6.7 PRIOR(i), NEXT(i)</A
></H3
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Specification<A
CLASS="indexterm"
NAME="ch19-idx-8658-1"
></A
> <A
CLASS="indexterm"
NAME="ch19-idx-8658-2"
></A
> </DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION PRIOR (i BINARY_INTEGER) RETURN BINARY_INTEGER;
FUNCTION NEXT (i BINARY_INTEGER) RETURN BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Example</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This function returns the sum of elements in a List_t collection of numbers: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE FUNCTION compute_sum (the_list IN List_t) RETURN NUMBER
AS
   elt BINARY_INTEGER := the_list.FIRST;
   total NUMBER := 0;
BEGIN
   LOOP
      EXIT WHEN elt IS NULL;
      total := total + the_list(elt);
      elt := the_list.NEXT(elt);
   END LOOP;
   RETURN total;
END;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Returns</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>PRIOR returns the next lower index in use relative to i; NEXT returns the next higher. </P
></DD
><DT
CLASS="term"
>Applies to</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Nested tables, index-by tables, VARRAYs.</P
></DD
><DT
CLASS="term"
>Boundary considerations</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to initialized collections which have no elements, returns NULL. If <EM
CLASS="emphasis"
>i</EM
> is greater than or equal to COUNT, NEXT returns NULL; if <EM
CLASS="emphasis"
>i</EM
> is less than or equal to FIRST, PRIOR returns NULL. (Currently, if the collection has elements, and <EM
CLASS="emphasis"
>i</EM
> is greater than COUNT, PRIOR returns LAST; if <EM
CLASS="emphasis"
>i</EM
> is less than FIRST, NEXT returns FIRST; however, do not rely on this behavior in future Oracle versions.) </P
></DD
><DT
CLASS="term"
>Exceptions possible</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If applied to an uninitialized nested table or a VARRAY, raises COLLECTION_IS_NULL predefined exception.<A
CLASS="indexterm"
NAME="AUTOID-18545"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-18546"
></A
> </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-19-SECT-6.0.8"
>19.6.8 TRIM [ (n ) ]</A
></H3
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Specification</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE TRIM (n BINARY_INTEGER:=1);<A
CLASS="indexterm"
NAME="ch19-idx-8662-1"
></A
></PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Example</DT
><DD
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE FUNCTION pop (the_list IN OUT List_t) RETURN VARCHAR2
AS
   l_value VARCHAR2(30);
BEGIN
   IF the_list.COUNT &gt;= 1
   THEN
      /* Save the value of the last element in the collection
      || so it can be returned
      */
      l_value := the_list(the_list.LAST);
      the_list.TRIM;
   END IF;
   RETURN l_value;
END;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>Action</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Removes <EM
CLASS="emphasis"
>n</EM
> elements from the end of a collection. Without arguments, TRIM removes exactly one element. Confusing behavior occurs if you combine DELETE and TRIM actions on a collection; for example, if an element that you are trimming has previously been DELETEd, TRIM "repeats" the deletion but counts this as part of <EM
CLASS="emphasis"
>n</EM
>, meaning that you may be TRIMming fewer actual elements than you think. </P
></DD
><DT
CLASS="term"
>Applies to</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Nested tables, VARRAYs. Attempting to TRIM an index-by table will produce a compile-time error. </P
></DD
><DT
CLASS="term"
>Boundary considerations</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If <EM
CLASS="emphasis"
>n</EM
> is null, TRIM will do nothing.</P
></DD
><DT
CLASS="term"
>Exceptions possible</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Will raise SUBSCRIPT_BEYOND_COUNT if you attempt to TRIM more elements than actually exist. If applied to an uninitialized nested table or a VARRAY, raises COLLECTION_IS_NULL predefined exception.<A
CLASS="indexterm"
NAME="AUTOID-18579"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-18580"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-18581"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-18582"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-18583"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-18584"
></A
> </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_05.htm#SQL2-CH-19-SECT-5.2"
TITLE="19.5 Collection Pseudo-Functions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 19.5 Collection Pseudo-Functions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_07.htm"
TITLE="19.7 Example: PL/SQL-to-Server Integration"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 19.7 Example: PL/SQL-to-Server Integration"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>19.5 Collection Pseudo-Functions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>19.7 Example: PL/SQL-to-Server Integration</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
