<HTML
><HEAD
><TITLE
>[Chapter 5] Conditional and Sequential Control</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:55:42Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part02.htm"
TITLE="II. PL/SQL Language Elements "><LINK
REL="prev"
HREF="ch04_07.htm#SQL2-CH-4-SECT-7.7"
TITLE="4.7 Tips for Creating and Using Variables"><LINK
REL="next"
HREF="ch05_02.htm#SQL2-CH-5-SECT-2.1"
TITLE="5.2 Sequential Control Statements"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_07.htm#SQL2-CH-4-SECT-7.7"
TITLE="4.7 Tips for Creating and Using Variables"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.7 Tips for Creating and Using Variables"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 5</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_02.htm#SQL2-CH-5-SECT-2.1"
TITLE="5.2 Sequential Control Statements"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.2 Sequential Control Statements"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SQL2-CH-5"
>5. Conditional and Sequential Control</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SQL2-CH-5-SECT-1"
TITLE="5.1 Conditional Control Statements"
>Conditional Control Statements</A
><BR><A
CLASS="sect1"
HREF="ch05_02.htm#SQL2-CH-5-SECT-2.1"
TITLE="5.2 Sequential Control Statements"
>Sequential Control Statements</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-643827-1"
></A
>This chapter describes two types of PL/SQL control statements: conditional control statements and sequential control statements. Almost every piece of code you write will require conditional control: the ability to direct the flow of execution through your program based on a condition; you do this with IF-THEN-ELSE statements. Far less often, you will need to tell PL/SQL to transfer control unconditionally via the GOTO statement, or to do nothing via the NULL statement. </P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-1"
>5.1 Conditional Control Statements</A
></H2
><P
CLASS="para"
>You need to be able to implement requirements such as:</P
><BLOCKQUOTE
CLASS="blockquote"
><P
CLASS="para"
> If the salary is between ten and twenty thousand, then apply a bonus of $1500.</P
><P
CLASS="para"
>If the salary is between twenty and forty thousand, apply a bonus of $1000.</P
><P
CLASS="para"
>If the salary is over forty thousand, give the employee a bonus of $500. </P
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
CLASS="blockquote"
><P
CLASS="para"
> If the user preference includes the toolbar, display the toolbar when the window first opens. </P
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-643834-1"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-643834-2"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-643834-3"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-643834-4"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-643834-5"
></A
>The IF statement allows you to design conditional logic in your programs. The IF statement comes in three flavors: </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF
THEN
END IF;</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>This is the simplest form of the IF statement. The condition between the IF and THEN determines whether the set of statements between the THEN and END IF should be executed. If the condition evaluates to false, then the code is not executed. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF
ELSE
END IF;</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>This combination implements an either/or logic: based on the condition between the IF and THEN keywords, either execute the code between the THEN and ELSE or between the ELSE and END IF. One of these two sections of executable statements is performed. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF
ELSIF
ELSE
END IF;</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>This last and most complex form of the IF statement selects an action from a series of mutually exclusive conditions and then executes the set of statements associated with that condition. </P
> </TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-1.1"
>5.1.1 The IF-THEN Combination</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4562"
></A
>The general format of the IF-THEN syntax is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF &lt;condition&gt;
THEN
   ... sequence of executable statements ...
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The &lt;condition&gt; is a Boolean variable, constant, or expression that evaluates to TRUE, FALSE, or NULL. If &lt;condition&gt; evaluates to TRUE, then the executable statements found after the THEN keyword and before the matching END IF statement are executed. <A
CLASS="indexterm"
NAME="AUTOID-4568"
></A
>If the &lt;condition&gt; evaluates to FALSE or NULL, then those statements are not executed. </P
><P
CLASS="para"
>Here are some examples of the simple IF-THEN structure:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The following IF condition compares two different numeric values. Remember that if one of these two variables is NULL, then the entire Boolean expression returns NULL and the discount is not applied: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF :company.total_sales &gt; system_average_sales
THEN
   apply_discount (:company.company_id);
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Here is an example of an IF statement with a single Boolean variable (or function&nbsp;-- you really can't tell the difference just by looking at this line of code): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF report_requested
THEN
   print_report (report_id);
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In the previous example, I used a single Boolean variable in my condition. If the variable report_requested evaluates to TRUE, then the report prints. Otherwise, the print step is skipped. I could code that same IF statement as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF report_requested = TRUE
THEN
   print_report (report_id);
END IF;</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>While the code in the third example is logically equivalent to the IF report_requested formulation, it is superfluous and works against the nature of a Boolean variable. A Boolean variable itself evaluates to TRUE, FALSE, or NULL; you don't have to test the variable against those values. If you name your Boolean variables properly, you will be able to easily read the logic and intent of your IF-THEN logic by leaving out the unnecessary parts of the statement. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-1.2"
>5.1.2 The IF-THEN-ELSE Combination</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4586"
></A
>Use the IF-THEN-ELSE format when you want to choose between two mutually exclusive actions. The format of this either/or version of the IF statement is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF &lt;condition&gt;
THEN
   ... TRUE sequence of executable statements ...
ELSE
   ... FALSE/NULL sequence of executable statements ...
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The &lt;condition&gt; is a Boolean variable, constant, or expression. If &lt;condition&gt; evaluates to TRUE, then the executable statements found after the THEN keyword and before the ELSE keyword are executed (the "TRUE sequence of executable statements"). If the &lt;condition&gt; evaluates to FALSE or NULL, then the executable statements that come after the ELSE keywords and before the matching END IF keywords are executed (the "FALSE/NULL sequence of executable statements"). </P
><P
CLASS="para"
>The important thing to remember is that one of these sequences of statements will always execute, because it is an either/or construct. Once the appropriate set of statements has been executed, control passes to the statement immediately following the END IF statement. </P
><P
CLASS="para"
>Notice that the ELSE clause does not have a THEN associated with it. </P
><P
CLASS="para"
>Here are some examples of the IF-THEN-ELSE construct:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In this example, if there is a VIP caller, I generate an express response; otherwise, I use normal delivery: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF caller_type = 'VIP'
THEN
   generate_response ('EXPRESS');
ELSE
   generate_response ('NORMAL');
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4600"
></A
>You can put an entire IF-THEN-ELSE on a single line if you wish, as shown below: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF new_caller THEN get_next_id; ELSE use_current_id; END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>This example sets the order_exceeds_balance Boolean variable based on the order total: </P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF :customer.order_total &gt; max_allowable_order
THEN
   order_exceeds_balance := TRUE;
ELSE
   order_exceeds_balance := FALSE;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the last example, the IF statement is not only unnecessary, but confusing. Remember: you can assign a TRUE/FALSE value directly to a Boolean variable. You do not need the IF-THEN-ELSE construct to decide how to set order_exceeds_balance. Instead, you can assign the value directly, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>order_exceeds_balance :=  :customer.order_total &gt; max_allowable_order;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This assignment sets the order_exceeds_balance variable to TRUE if the customer's order total is greater than the maximum allowed, and sets it to FALSE otherwise. In other words, it achieves exactly the same result as the IF-THEN-ELSE and does it more clearly and with less code. </P
><P
CLASS="para"
>If you have not had much experience with Boolean variables, it may take you a little while to learn how to integrate them smoothly into your code. It is worth the effort, though. The result is cleaner, more readable code. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-1.3"
>5.1.3 The IF-ELSIF Combination</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-643837-1"
></A
> This last form of the IF statement comes in handy when you have to implement logic which has many alternatives; it is not an either/or situation. The IF-ELSIF formulation provides the most straightforward and natural way to handle multiple, mutually exclusive alternatives. The general format for this variation of the IF statement is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF &lt;condition-1&gt;
THEN
   &lt;statements-1&gt;
...
ELSIF &lt;condition-N&gt;
THEN
   &lt;statements-N&gt;

[ELSE
   &lt;else_statements&gt;]
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Logically speaking, the IF-ELSIF implements the CASE statement in PL/SQL. The sequence of evaluation and execution for this statement is: </P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>If &lt;condition1&gt; is true then execute &lt;statements1&gt;. </TD
></TR
><TR
><TD
CLASS="member"
>Otherwise ... if &lt;condition <EM
CLASS="emphasis"
>n</EM
>&gt; is true then execute &lt;statements n&gt;. </TD
></TR
><TR
><TD
CLASS="member"
>Otherwise execute the &lt;else_statements&gt;. </TD
></TR
></TABLE
><P
CLASS="para"
>Each ELSIF clause must have a THEN after its condition. Only the ELSE keyword does not need the THEN keyword. The ELSE clause in the IF-ELSIF is the "otherwise" of the statement. If none of the conditions evaluate to TRUE, then the statements in the ELSE clause are executed. But the ELSE clause is also optional. You can code an IF-ELSIF that has only IF and ELSIF clauses. In this case, if none of the conditions are TRUE, then no statements inside the IF block are executed. </P
><P
CLASS="para"
>The conditions in the IF-ELSIF are always evaluated in the order of first condition to last condition. Once a condition evaluates to TRUE, the remaining conditions are not evaluated at all. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-1.3.1"
>5.1.3.1 IF-ELSIF examples</A
></H4
><P
CLASS="para"
>Here are some examples of the possible variations in the format of the IF-ELSIF structure: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>I have three different caller types to check. If the caller type is not one of VIP, BILL_COLLECTOR, or INTERNATIONAL, then send the response with normal delivery: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF caller_type = 'VIP'
THEN
   generate_response ('EXPRESS');

ELSIF caller_type = 'BILL_COLLECTOR'
THEN
   generate_response ('THROUGH_CHICAGO');

ELSIF caller_type = 'INTERNATIONAL'
THEN
   generate_response ('AIR');

ELSE
   generate_response ('NORMAL');
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Here is an IF-ELSIF without an ELSE clause. If none of the conditions are TRUE, then this block of code does not run any of its executable statements: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF new_caller AND caller_id IS NULL
THEN
   confirm_caller;

ELSIF new_company AND company_id IS NULL
THEN
   confirm_company;

ELSIF new_call_topic AND call_id IS NULL
THEN
   confirm_call_topic;
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Here's an IF-ELSIF with just a single ELSIF&nbsp;-- and no ELSE. In this case, however, you could just as well have used an IF-THEN-ELSE structure because the two conditions are mutually exclusive. The ELSIF statements execute only if the IF condition is FALSE. The advantage to including the ELSIF is that it documents more clearly the condition under which its executable statements will be run. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF start_date &gt; SYSDATE AND order_total &gt;= min_order_total
THEN
   fill_order (order_id);

ELSIF start_date &lt;= SYSDATE OR order_total &lt; min_order_total
THEN
   queue_order_for_addtl_parts (order_id);
END IF;</PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-1.3.2"
>5.1.3.2 Mutually exclusive IF-ELSIF conditions</A
></H4
><P
CLASS="para"
>Make sure that your IF-ELSIF conditions are mutually exclusive. The conditions in the IF-ELSIF are always evaluated in the order of first to last. Once a condition evaluates to TRUE, the remaining conditions are not evaluated at all. If you have an overlap in the conditions so that more than one condition could be TRUE, you probably have an error in your logic. Either the conditions in the IF statement should be changed to make them exclusive, or you'll sometimes run the risk of not executing the right set of code in your IF statement. The following example illustrates these points. Translate the following rules: </P
><BLOCKQUOTE
CLASS="blockquote"
><P
CLASS="para"
> If the salary is between ten and twenty thousand, then apply a bonus of $1500.</P
><P
CLASS="para"
>If the salary is between twenty and forty thousand, apply a bonus of $1000.</P
><P
CLASS="para"
>If the salary is over forty thousand, give the employee a bonus of $500. </P
></BLOCKQUOTE
><P
CLASS="para"
>into this code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF salary BETWEEN 10000 AND 20000
THEN
   bonus := 1500;

ELSIF salary BETWEEN 20000 AND 40000
THEN
   bonus := 1000;

ELSIF salary &gt; 40000
THEN
   bonus := 500;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>What if the salary is $20,000? Should the person receive a bonus of $1000 or $1500? The way the IF-ELSIF is currently written, a person making $20,000 will always receive a bonus of $1500. This might not be the intent of the specification, the overall approach of which seems to be "let the poorer catch up a little with the richer." Actually, the problem here is that the original phrasing of the specification is ambiguous&nbsp;-- and even incomplete. It assumes that no one ever has a salary of less than $10,000 (or, if we did not want to give the author of this specification the benefit of the doubt, we would say, "Anyone with a salary under $10,000 gets no bonus"). </P
><P
CLASS="para"
>We can close up the holes in this logic by moving away from the BETWEEN operator and instead relying on <KBD
CLASS="command"
>&lt;</KBD
> and <KBD
CLASS="command"
>&gt;</KBD
>. This clarifies those break-points in the salary: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF salary &lt; 10000
THEN
   bonus := 2000;

ELSIF salary &lt; 20000
THEN
   bonus := 1500;

ELSIF salary &lt; 40000
THEN
   bonus := 1000;

ELSE -- same as ELSIF salary &gt;= 40000
   bonus := 500;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now the conditions are mutually exclusive, and the people who make the lowest salary get the largest bonus. That seems fair to me. </P
><P
CLASS="para"
>Here is an example of an IF-ELSIF with a condition that will never evaluate to TRUE; the code associated with it, therefore, will never be executed. See if you can figure out which condition that is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF order_date &gt; SYSDATE AND order_total &gt;= min_order_total
THEN
   fill_order (order_id, 'HIGH PRIORITY');

ELSIF order_date &lt; SYSDATE OR order_date = SYSDATE
THEN
   fill_order (order_id, 'LOW PRIORITY');

ELSIF order_date &lt;= SYSDATE AND order_total &lt; min_order_total
THEN
   queue_order_for_addtl_parts (order_id);

ELSIF order_total = 0
THEN
   MESSAGE (' No items have been placed in this order!');
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The only executable statement that we can say with complete confidence will never be executed is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>queue_order_for_addtl_parts (order_id);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>An order is put in the queue to wait for additional parts (to boost up the order total) only if the third condition evalutes to TRUE: </P
><BLOCKQUOTE
CLASS="blockquote"
><P
CLASS="para"
> The order was placed today or earlier and the total for the order is under the minimum. </P
></BLOCKQUOTE
><P
CLASS="para"
>The reason that queue_order_for_addtl_parts will never be executed lies in the second condition: </P
><BLOCKQUOTE
CLASS="blockquote"
><P
CLASS="para"
> An order is filled with LOW PRIORITY whenever the order date was no later than the system date. </P
></BLOCKQUOTE
><P
CLASS="para"
>The second condition is a logical subset of the third condition. Whenever the second condition is FALSE, the third condition will also be FALSE. Whenever the third condition evaluates to TRUE, the second condition will also evaluate to TRUE. Because it comes before the third condition in the evaluation sequence, the second condition will catch any scenarios that would otherwise satisfy the third condition. </P
><P
CLASS="para"
>When you write an IF-ELSIF, especially one with more than three alternatives, review your logic closely and make sure there is no overlap in the conditions. For any particular set of values or circumstances, at most one&nbsp;-- and perhaps none&nbsp;-- of the conditions should evalute to TRUE.<A
CLASS="indexterm"
NAME="AUTOID-4667"
></A
> </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-5-SECT-1.4"
>5.1.4 Nested IF Statements</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4671"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4674"
></A
>You can nest any IF statement within any other IF statement. The following IF statement shows several layers of nesting: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF &lt;condition1&gt;
THEN
   IF &lt;condition2&gt;
   THEN
      &lt;statements2&gt;
   ELSE
      IF &lt;condition3&gt;
      THEN
         &lt;statements3&gt;
      ELSIF &lt;condition4&gt;
      THEN
         &lt;statements4&gt;
      END IF;
   END IF;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Nested IF statements are often necessary to implement complex logic rules, but you should use them carefully. Nested IF statements, like nested loops, can be very difficult to understand and debug. If you find that you need to nest more than three levels deep in your conditional logic, you should review that logic and see if there is a simpler way to code the same requirement. If not, then consider creating one or more local modules to hide the innermost IF statements. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4680"
></A
>A key advantage to the nested IF structure is that it defers evaluation of inner conditions. The conditions of an inner IF statement are evaluated only if the condition for the outer IF statement that encloses them evaluates to TRUE. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4685"
></A
>If the evaluation of a condition is very expensive (in CPU or memory terms), you may want to defer that processing to an inner IF statement so that it is executed only when absolutely necessary. This is especially true of code that will be performed frequently or in areas of the application where quick response time is critical. </P
><P
CLASS="para"
>The following IF statement illustrates this concept:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF condition1 AND condition2
THEN
   ...
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The PL/SQL run-time engine evalutes both conditions in order to determine if the Boolean expression A AND B evaluates to TRUE. Suppose that condition2 is an expression which PL/SQL can process simply and efficiently, such as: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>total_sales &gt; 100000</PRE
></BLOCKQUOTE
><P
CLASS="para"
>but that condition1 is a much more complex and CPU-intensive expression, perhaps calling a stored function which executes a query against the database. If condition2 is evaluated in a tenth of a second to TRUE and condition1 is evaluated in three seconds to FALSE, then it would take more than three seconds to determine that the code inside the IF statement should not be executed. </P
><P
CLASS="para"
>Now consider this next version of the same IF statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF condition2
THEN
   IF condition1
   THEN
      ...
   END IF;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now condition1 will be evaluated only if condition2 evaluates to TRUE. In those situations where total_sales &lt;= 100000, the user will never have to wait the extra three seconds to continue. </P
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="AUTOID-4696"
>Avoiding Syntax Gotchas</A
></H4
><P
CLASS="para"
>Keep in mind these points about IF statement syntax:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Always match up an IF with an END IF</EM
>. In all three variations of the IF statement, you must close off the executable statements associated with the conditional structure with an END IF statement. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>You must have a space between the keywords END and IF.</EM
> If you type ENDIF instead of END IF, the compiler will get very confused and give you the following hard-to-understand error messages: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-06550: line 14, column 4:
PLS-00103: Encountered the symbol &quot;;&quot; when expecting one of the following:
if
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>The ELSIF keyword does not have an embedded "E".</EM
> If you use type ELSEIF in place of ELSIF, the compiler will get very confused and not recognize the ELSEIF as part of the IF statement. It will interpret it as a variable name or program name. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Place a semicolon (<KBD
CLASS="command"
>;</KBD
>) only after the END IF keywords. The keywords THEN, ELSE, and ELSIF should not have a semicolon after them. They are not standalone executable statements and, unlike END IF, do not complete a statement. If you include a semicolon after these keywords, the compiler will issue messages indicating that it is looking for a statement of some kind before the semicolon.<A
CLASS="indexterm"
NAME="AUTOID-4713"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4714"
></A
> </P
></LI
></UL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_07.htm#SQL2-CH-4-SECT-7.7"
TITLE="4.7 Tips for Creating and Using Variables"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.7 Tips for Creating and Using Variables"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_02.htm#SQL2-CH-5-SECT-2.1"
TITLE="5.2 Sequential Control Statements"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.2 Sequential Control Statements"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.7 Tips for Creating and Using Variables</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>5.2 Sequential Control Statements</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
