<HTML
><HEAD
><TITLE
>[Chapter 7] 7.3 The Numeric FOR Loop</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:57:37Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch07_01.htm"
TITLE="7. Loops"><LINK
REL="prev"
HREF="ch07_02.htm#SQL2-CH-7-SECT-2.1"
TITLE="7.2 The Simple Loop"><LINK
REL="next"
HREF="ch07_04.htm"
TITLE="7.4 The Cursor FOR Loop"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_02.htm#SQL2-CH-7-SECT-2.1"
TITLE="7.2 The Simple Loop"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.2 The Simple Loop"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch07_01.htm"
TITLE="7. Loops"
>Chapter 7<BR>Loops</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_04.htm"
TITLE="7.4 The Cursor FOR Loop"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.4 The Cursor FOR Loop"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-7-SECT-3"
>7.3 The Numeric FOR Loop</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch07-idx-151602-1"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-151602-2"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-151602-3"
></A
><A
CLASS="indexterm"
NAME="ch07-idx-151602-4"
></A
>There are two kinds of PL/SQL FOR loops: the numeric FOR loop and the cursor FOR loop. The numeric FOR loop is the traditional and familiar "counted" loop. <A
CLASS="indexterm"
NAME="AUTOID-6629"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6633"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6635"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6637"
></A
>The number of iterations of the FOR loop is known when the loop starts; it is specified in the loop boundary's range scheme. The number of times the loop executes is actually determined by the range scheme found between the FOR and LOOP keywords in the boundary. </P
><P
CLASS="para"
>The range scheme implicitly declares the loop index (if it has not already been declared), specifies the start and end points of the range, and optionally dictates the order in which the loop index proceeds (from lowest to highest or highest to lowest). </P
><P
CLASS="para"
>Here is the general syntax of the numeric FOR loop:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR &lt;loop index&gt; IN [REVERSE] &lt;lowest number&gt; .. &lt;highest number&gt;
LOOP
   &lt;executable statement(s)&gt;
END LOOP;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You must have at least one executable statement between the LOOP and END LOOP key words. </P
><P
CLASS="para"
>The following table summarizes the properties of the numeric FOR loop:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Property</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>How the loop is terminated</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>The numeric FOR loop terminates unconditionally when the number of times specified in its range scheme has been satisfied. You can also terminate the loop with an EXIT statement, but this is not recommended. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>When the test for termination takes place</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>After each execution of the loop body, PL/SQL checks the value of the loop index. When it exceeds the difference between the upper and lower bounds of the range scheme, the loop terminates. If the lower bound is greater than the upper bound of the range scheme, the loop never executes its body. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Reason to use this loop</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Use the numeric FOR loop when you want to execute a body of code a fixed number of times, and you do not want to halt that looping prematurely. </P
> </TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-7-SECT-3.1"
>7.3.1 Rules for Numeric FOR Loops</A
></H3
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not declare the loop index. PL/SQL automatically and implicitly declares it as a local variable with datatype INTEGER. The scope of this index is the loop itself; you cannot reference the loop index outside the loop. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Expressions used in the range scheme (both for lowest and highest bounds) are evaluated once, when the loop starts. The range is not re-evaluated during the execution of the loop. If you make changes within the loop to the variables which you used to determine the FOR loop range, those changes will have no effect. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Never change the values of either the loop index or the range boundary from within the loop. This is an extremely bad programming practice. In most cases, PL/SQL will not let you compile such code. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not use an EXIT statement inside a FOR loop in order to cause early execution of the loop. If you are going to use a numeric FOR loop, then you should let the loop execute as it is designed: from start value to end value. If you need more control over how frequently a loop is to execute and, particularly, when it is to terminate, do not use the FOR loop. Instead, use the WHILE loop or simple loop with EXIT WHEN constructs. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6685"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6687"
></A
>Use the REVERSE keyword to force the loop to decrement from the upper bound to the lower bound. You must still make sure that the first value in the range specification (the N in N .. M) is less than the second value. Do not reverse the order in which you specify these values when you use the REVERSE keyword. </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-7-SECT-3.2"
>7.3.2 Examples of Numeric FOR Loops</A
></H3
><P
CLASS="para"
>The following examples demonstrate some variations of the numeric FOR loop syntax: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The loop executes ten times; loop_counter starts at 1 and ends at 10:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR loop_counter IN 1 .. 10
LOOP
   ... executable statements ...
END LOOP;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The loop executes ten times; loop_counter starts at 10 and ends at 1: </P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR loop_counter IN REVERSE 1 .. 10
LOOP
   ... executable statements ...
END LOOP;</PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Here is a loop that doesn't execute even once. I specified REVERSE so the loop index, loop_counter, will start at the highest value and end with the lowest. I then mistakenly concluded that I should switch the order in which I list the highest and lowest bounds: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR loop_counter IN REVERSE 10 .. 1
LOOP
   /* This loop body will never execute even once! */
END LOOP;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Even when you specify a REVERSE direction, you must still list the lowest bound before the highest bound. If the first number is greater than the second number, the body of the loop will not execute at all. If the lowest and highest bounds have the same value, then the loop will execute just once. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Loop executes for a range determined by the values in the variable and expression: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR calc_index IN start_period_number ..
            LEAST (end_period_number, current_period)
LOOP
   ... executable statements ...
END LOOP;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that in this example we do not know the values for the lowest and highest bounds at the time of the writing of the code. The actual or dynamic range is determined at runtime and is fully supported by PL/SQL. In other words, the numeric FOR loop needs to know when it starts and how many times it will execute, but <EM
CLASS="emphasis"
>you</EM
> do not have to know this when you write the program. </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-7-SECT-3.3"
>7.3.3 Handling Nontrivial Increments</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6713"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6717"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6720"
></A
>PL/SQL does not provide a "step" syntax, whereby you can specify that the loop index increment. In all variations of the PL/SQL numeric FOR loop, the loop index is always incremented or decremented by one. </P
><P
CLASS="para"
>If you have a loop body which you want executed for a nontrivial (different from one) increment, you will have to write some cute code. For example, what if you want your loop to execute only for all even numbers between 1 and 100? You can make use of the numeric MOD function, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR loop_index IN 1 .. 100
LOOP
   IF MOD (loop_index, 2) = 0
   THEN
      /* We have an even number, so perform calculation */
      calc_values (loop_index);
   END IF;
END LOOP;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Or you can use simple multiplication inside a loop with half the iterations: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR even_number IN 1 .. 50
LOOP
   calc_values (even_number*2);
END LOOP;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In both cases, the calc_values procedure executes only for even numbers. In the first example, the FOR loop executes 100 times. In the second example, the FOR loop executes only 50 times. </P
><P
CLASS="para"
>Whichever approach you decide to take, be sure to document this kind of technique clearly. You are, in essence, manipulating the numeric FOR loop to do something for which it is not designed. Comments would be very helpful for the maintenance programmer who has to understand why you would code something like that.<A
CLASS="indexterm"
NAME="AUTOID-6729"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6730"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6731"
></A
> </P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_02.htm#SQL2-CH-7-SECT-2.1"
TITLE="7.2 The Simple Loop"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.2 The Simple Loop"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_04.htm"
TITLE="7.4 The Cursor FOR Loop"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.4 The Cursor FOR Loop"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>7.2 The Simple Loop</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>7.4 The Cursor FOR Loop</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
