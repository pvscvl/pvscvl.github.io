<HTML
><HEAD
><TITLE
>[Chapter 20] Object Views</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:09:09Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part05.htm"
TITLE="V. New PL/SQL8 Features"><LINK
REL="prev"
HREF="ch19_09.htm"
TITLE="19.9 Which Collection Type Should I Use?"><LINK
REL="next"
HREF="ch20_02.htm"
TITLE="20.2 INSTEAD OF Triggers"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_09.htm"
TITLE="19.9 Which Collection Type Should I Use?"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 19.9 Which Collection Type Should I Use?"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 20</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_02.htm"
TITLE="20.2 INSTEAD OF Triggers"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 20.2 INSTEAD OF Triggers"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SQL2-CH-20"
>20. Object Views</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SQL2-CH-20-SECT-1"
TITLE="20.1 Example: Using Object Views"
>Example: Using Object Views</A
><BR><A
CLASS="sect1"
HREF="ch20_02.htm"
TITLE="20.2 INSTEAD OF Triggers"
>INSTEAD OF Triggers</A
><BR><A
CLASS="sect1"
HREF="ch20_03.htm#SQL2-CH-20-SECT-3.3"
TITLE="20.3 Syntax for Object Views"
>Syntax for Object Views</A
><BR><A
CLASS="sect1"
HREF="ch20_04.htm#SQL2-CH-20-SECT-4.2.3"
TITLE="20.4 Differences Between Object Views and Object Tables"
>Differences Between Object Views and Object Tables</A
><BR><A
CLASS="sect1"
HREF="ch20_05.htm"
TITLE="20.5 Not All Views with Objects Are Object Views"
>Not All Views with Objects Are Object Views</A
><BR><A
CLASS="sect1"
HREF="ch20_06.htm"
TITLE="20.6 Schema Evolution"
>Schema Evolution</A
><BR><A
CLASS="sect1"
HREF="ch20_07.htm#SQL2-CH-20-SECT-7.3"
TITLE="20.7 Object Views Housekeeping"
>Object Views Housekeeping</A
><BR><A
CLASS="sect1"
HREF="ch20_08.htm"
TITLE="20.8 Postscript: Using the BFILE Datatype"
>Postscript: Using the BFILE Datatype</A
></P
><P
></P
></DIV
><P
CLASS="para"
>Although Oracle's object extensions offer rich possibilities for the design of new systems, few Oracle shops with large relational databases in place will want to, or be able to, completely reengineer those systems to use objects. To allow established applications to take advantage of the new object features over time, Oracle8 provides <EM
CLASS="emphasis"
>object views</EM
><A
CLASS="indexterm"
NAME="ch20-idx-6235-1"
></A
>. With object views, you can achieve the following benefits: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Efficiency of object access</EM
>. In PL/SQL, and particularly in Oracle Call Interface (OCI) applications, object programming constructs provide for the convenient retrieval, caching, and updating of object data. These programming facilities provide performance improvements, with the added benefit that application code can now be more succinct. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Ability to navigate using REFs (reference pointers)</EM
><A
CLASS="indexterm"
NAME="AUTOID-18741"
></A
>. By designating unique identifiers as the basis of an object identifier (OID), you can reap the benefits of object navigation. For example, you can retrieve attributes from related "virtual objects" using dot notation rather than via explicit joins. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-18746"
></A
><A
CLASS="indexterm"
NAME="AUTOID-18749"
></A
><EM
CLASS="emphasis"
>Easier schema evolution</EM
>. In early versions of Oracle8, a pure object approach renders almost any kind of schema change at best ugly (see <A
CLASS="xref"
HREF="ch18_01.htm"
>Chapter 18, <CITE
CLASS="chapter"
>Object Types</CITE
></A
>). In contrast, object views offer more ways that you can change both the table structure and the object type definitions of an existing system. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Consistency with new object-based applications</EM
>. If you need to extend the design of a legacy database, the new components can be implemented in object tables; new object-oriented applications requiring access to existing data can employ a consistent programming model. Legacy applications can continue to work without modification. </P
></LI
></UL
><P
CLASS="para"
>Other new features of Oracle can improve the expressiveness of any type of view, not just object views. Two features which are not strictly limited to object views are collections and "INSTEAD OF" triggers. Consider two relational tables with a simple master-detail relationship. Using the Oracle objects option, you can portray the detail records as a single nonscalar attribute (collection) of the master, which could be a very useful abstraction. In addition, by using INSTEAD OF triggers, you can tell Oracle exactly how to perform inserts, updates, and deletes on any view. These two features are available to both object views and nonobject views. (I've described collections in <A
CLASS="xref"
HREF="ch19_01.htm"
>Chapter 19, <CITE
CLASS="chapter"
>Nested Tables and VARRAYs</CITE
></A
>, and I describe INSTEAD OF triggers later in this chapter.) </P
><P
CLASS="para"
>From an <A
CLASS="indexterm"
NAME="AUTOID-18760"
></A
>object-oriented perspective, there is one unavoidable "disadvantage" of object views, when compared to reengineering using an all-object approach: object views cannot retrofit any benefits of encapsulation. Insofar as old applications apply INSERT, UPDATE, and DELETE statements directly to table data, they will subvert the benefits of encapsulation normally provided by an object approach. As I discussed in <A
CLASS="xref"
HREF="ch18_01.htm"
>Chapter 18</A
>, object-oriented designs typically prevent free-form access directly to object data. </P
><P
CLASS="para"
>Despite this intrusion of reality, if you do choose to layer object views on top of a legacy system, your future applications can employ object abstractions and enjoy many benefits of encapsulation and information hiding. And your legacy systems are no <EM
CLASS="emphasis"
>worse</EM
> off than they were before! <A
CLASS="xref"
HREF="ch20_01.htm"
>Figure 20.1</A
> illustrates this use of object views. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-20-FIG-1"
>Figure 20.1: Object views allow you to "bind" an object type definition to (existing) relational tables</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.2001.gif"
ALT="Figure 20.1"><P
CLASS="para"
>This chapter discusses the nuances of creating and, to a lesser extent, using object views. The discussion of PL/SQL-specific aspects of object views is rather terse, for two reasons: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Object views are substantially similar to regular object types, which are covered in a <A
CLASS="xref"
HREF="ch18_01.htm"
>Chapter 18</A
>. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>As a topic, object views are closer to SQL than to PL/SQL.</P
></LI
></OL
><P
CLASS="para"
>However, PL/SQL developers who are interested in fully exploiting Oracle's object features must understand object views. This chapter pays close attention to the areas of difference between object tables and object views.<A
CLASS="indexterm"
NAME="AUTOID-18778"
></A
> </P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-20-SECT-1"
>20.1 Example: Using Object Views</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch20-idx-6239-1"
></A
> <A
CLASS="indexterm"
NAME="ch20-idx-6239-2"
></A
>In our first example, let's look at how object views might be used at Planetary Pages, a fictitious firm that designs Web sites. Their existing relational application tracks JPEG, GIF, and other images that they use when designing client Web sites. These images are stored in files, but data about them are stored in relational tables. To help the graphic artists locate the right image, each image has one or more associated keywords, stored in a straightforward master-detail relationship. </P
><P
CLASS="para"
>Our legacy system has one table for image metadata:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE images (
   image_id INTEGER NOT NULL,
   file_name VARCHAR2(512),
   file_type VARCHAR2(12),
   bytes INTEGER,
   CONSTRAINT image_pk PRIMARY KEY (image_id));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and one table for the keywords associated with the images:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE keywords (
   image_id INTEGER NOT NULL,
   keyword VARCHAR2(45) NOT NULL,
   CONSTRAINT keywords_pk PRIMARY KEY (image_id, keyword),
   CONSTRAINT keywords_for_image FOREIGN KEY (image_id)
      REFERENCES images (image_id));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To create a more useful abstraction, Planetary Pages has decided to logically merge these two tables into a single object view. To do so, we must first create an object type with appropriate attributes. Since there are usually only a few keywords for a given image, this relationship lends itself to using an Oracle collection to hold the keywords. </P
><P
CLASS="para"
>Before we can create the top-level type, we must first define a collection to hold the keywords. We choose a nested table because keyword ordering is unimportant and because there is no logical maximum number of keywords.[<A
CLASS="footnote"
HREF="#AUTOID-18794"
>1</A
>] </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-18794"
>[1]</A
>  If ordering were important, or if there were a (small) logical maximum number of keywords per image, a VARRAY collection would be a better choice. See <A
CLASS="xref"
HREF="ch19_01.htm"
>Chapter 19</A
> for details.</P
></DIV
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE Keyword_tab_t AS TABLE OF VARCHAR2(45);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>From here, it's a simple matter to define the object type. To keep the example short, we'll define only a couple of methods. In the following object type specification, notice that the keywords attribute is defined on the Keyword_tab_t collection type: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE Image_t AS OBJECT (
    image_id INTEGER,
    file_name VARCHAR2(512),
    file_type VARCHAR2(12),
    bytes INTEGER,
    keywords Keyword_tab_t,
    MEMBER FUNCTION set_attrs (new_file_name IN VARCHAR2,
       new_file_type IN VARCHAR2, new_bytes IN INTEGER)
       RETURN Image_t,
    MEMBER FUNCTION set_keywords (new_keywords IN Keyword_tab_t)
       RETURN Image_t,
    PRAGMA RESTRICT_REFERENCES (DEFAULT, RNDS, WNDS, RNPS, WNPS)
);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the body:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE BODY Image_t
AS
   MEMBER FUNCTION set_attrs (new_file_name IN VARCHAR2,
       new_file_type IN VARCHAR2, new_bytes IN INTEGER)
       RETURN Image_t
   IS
      image_holder Image_t := SELF;
   BEGIN
      image_holder.file_name := new_file_name;
      image_holder.file_type := new_file_type;
      image_holder.bytes := new_bytes;
      RETURN image_holder;
   END;
   MEMBER FUNCTION set_keywords (new_keywords IN Keyword_tab_t)
       RETURN Image_t
   IS
      image_holder Image_t := SELF;
   BEGIN
      image_holder.keywords := new_keywords;
      RETURN image_holder;
   END;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I've presented the body only for completeness; from this point forward, I'll discuss object views without regard for the details of their underlying type bodies. </P
><P
CLASS="para"
>At this point, there is no connection between the relational tables and the object type. They are independent organisms. It is when we build the object view that we "overlay" the object definition onto the tables. </P
><P
CLASS="para"
>Finally, to create the object view, we use the following statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE VIEW images_v
   OF Image_t
   WITH OBJECT OID (image_id)
AS
   SELECT i.image_id, i.file_name, i.file_type, i.bytes,
      CAST (MULTISET (SELECT keyword
                        FROM keywords k
                       WHERE k.image_id = i.image_id)
        AS Keyword_tab_t)
     FROM images i;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Interestingly, there are only a couple of components of this statement that are unique to object views: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>OF Image_t</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This means that the view will return objects of type Image_t.</P
></DD
><DT
CLASS="term"
>WITH OBJECT OID (image_id)</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>To behave like a "real" object instance, data returned by the view will need some kind of object identifier. By designating the primary key as the basis of a virtual OID, we can enjoy the benefits of referencing objects of this type from other object views. </P
></DD
></DL
><P
CLASS="para"
>In addition, the select-list has an important requirement unique to object views. The select-list must define the same number of columns as there are attributes in the object type Image_t. The datatype of each retrieved column matches the datatype of its corresponding object attributes. </P
><P
CLASS="para"
>You can use the <A
CLASS="indexterm"
NAME="AUTOID-18818"
></A
>CAST clause shown in the example in any view, not just in object views (but it does require the presence of the Oracle objects option). This subquery performs an "on-the-fly" conversion of the detail records into a collection type. For more details about the CAST and MULTISET operators, refer to <A
CLASS="xref"
HREF="ch19_05.htm#SQL2-CH-19-SECT-5.2"
>Section 19.5, "Collection Pseudo-Functions"</A
> in <A
CLASS="xref"
HREF="ch19_01.htm"
>Chapter 19</A
>. </P
><P
CLASS="para"
>OK, now that we've created it, what can we do with it? Well, we can retrieve data from it just as if it were an object table. First, let's put some data into the underlying tables: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO images VALUES (100001, 'smiley_face.gif', 'GIF', 813);
INSERT INTO images VALUES (100002, 'peace_symbol.gif', 'GIF', 972);

INSERT INTO KEYWORDS VALUES (100001, 'SIXTIES');
INSERT INTO KEYWORDS VALUES (100001, 'HAPPY FACE');

INSERT INTO KEYWORDS VALUES (100002, 'SIXTIES');
INSERT INTO KEYWORDS VALUES (100002, 'PEACE SYMBOL');
INSERT INTO KEYWORDS VALUES (100002, 'JERRY RUBIN');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now, from SQL*Plus, you can make a query like the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT image_id, file_name, keywords
  FROM images_v;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Which yields:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IMAGE_ID FILE_NAME        KEYWORDS
-------- ---------------- -------------------------------------------------------
  100001 smiley_face.gif  KEYWORD_TAB_T('HAPPY FACE', 'SIXTIES')
  100002 peace_symbol.gif KEYWORD_TAB_T('JERRY RUBIN', 'PEACE SYMBOL', 'SIXTIES')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Or, in a PL/SQL block, we can fetch and display a row of data very easily: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET SERVEROUTPUT ON SIZE 100000
DECLARE
   CURSOR icur IS
      SELECT VALUE(v)
        FROM images_v v
       WHERE image_id = 100001;
   image Image_t;
BEGIN
   OPEN icur;
   FETCH icur INTO image;
   CLOSE icur;

   /* Print it out, just to prove that we got it */
   DBMS_OUTPUT.PUT_LINE('Image:    ' || image.image_id);
   DBMS_OUTPUT.PUT_LINE('File:     ' || image.file_name);
   DBMS_OUTPUT.PUT('Keywords: ');

   /* image.keywords is a nested table, and we can just loop
   || through it to print each keyword.
   */
   FOR key_elt IN 1..image.keywords.COUNT
   LOOP
      DBMS_OUTPUT.PUT(image.keywords(key_elt) || '   ');
   END LOOP;
   DBMS_OUTPUT.NEW_LINE;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This results in:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Image:    100001
File:     smiley_face.gif
Keywords: HAPPY FACE   SIXTIES</PRE
></BLOCKQUOTE
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch19_01.htm"
>Chapter 19</A
> for more examples of retrieving data from an object table. </P
><P
CLASS="para"
>Other things you can do with object views include the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Define REFs that point to "virtual" objects (discussed in detail in <A
CLASS="xref"
HREF="ch20_04.htm#SQL2-CH-20-SECT-4.2.3"
>Section 20.4, "Differences Between Object Views and Object Tables"</A
> later in this chapter). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Encapsulate an object view (more or less) using object methods and/or PL/SQL packages (discussed in-depth in <A
CLASS="xref"
HREF="ch18_01.htm"
>Chapter 18</A
>). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Write INSTEAD OF triggers that will allow direct manipulation of the view's contents (discussed in the next section).<A
CLASS="indexterm"
NAME="AUTOID-18845"
></A
> </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_09.htm"
TITLE="19.9 Which Collection Type Should I Use?"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 19.9 Which Collection Type Should I Use?"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_02.htm"
TITLE="20.2 INSTEAD OF Triggers"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 20.2 INSTEAD OF Triggers"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>19.9 Which Collection Type Should I Use?</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>20.2 INSTEAD OF Triggers</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
