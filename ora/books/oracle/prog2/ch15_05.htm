<HTML
><HEAD
><TITLE
>[Chapter 15] 15.5 Functions</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:03:17Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch15_01.htm"
TITLE="15. Procedures and Functions"><LINK
REL="prev"
HREF="ch15_04.htm#SQL2-CH-15-SECT-4.4"
TITLE="15.4 Procedures"><LINK
REL="next"
HREF="ch15_06.htm#SQL2-CH-15-SECT-6.2.3"
TITLE="15.6 Parameters"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_04.htm#SQL2-CH-15-SECT-4.4"
TITLE="15.4 Procedures"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 15.4 Procedures"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch15_01.htm"
TITLE="15. Procedures and Functions"
>Chapter 15<BR>Procedures and Functions</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_06.htm#SQL2-CH-15-SECT-6.2.3"
TITLE="15.6 Parameters"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 15.6 Parameters"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5"
>15.5 Functions</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948966-1"
></A
>A function is a module that returns a value. Unlike a procedure, which is a standalone executable statement, a call to a function can only be part of an executable statement. </P
><P
CLASS="para"
>Because a function returns a value, it can be said to have a datatype. A function can be used in place of an expression in a PL/SQL statement having the same datatype as the function. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="appc_01.htm"
>Appendix C, <CITE
CLASS="appendix"
>Built-In Packages</CITE
></A
>, describes the built-in functions that PL/SQL provides to help you write your programs. You can also write your own functions&nbsp;-- numeric functions, VARCHAR2 functions, and even functions that return a PL/SQL table or record. The programmer-defined function, a powerful addition to your toolchest, will aid greatly in making your code more flexible and easier to understand. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.1"
>15.5.1 Structure of a Function</A
></H3
><P
CLASS="para"
>The structure of a function is the same as that of a procedure, except that the function also has a RETURN clause. The general format of a function follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION name [ ( parameter [, parameter ... ] ) ]
   RETURN return_datatype
IS
   [ declaration statements ]

BEGIN
   executable statements

[ EXCEPTION
   exception handler statements ]

END [ name ];</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where each component is used in the following ways:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>name</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The name of the procedure comes directly after the keyword FUNCTION.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>parameters</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>An optional list of parameters that you define to both pass information into the procedure and send information out of the procedure, back to the calling program. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>return_datatype</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The datatype of the value returned by the function. This is required in the function header and is explained in more detail in the next section. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>declaration statements</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The declarations of local identifiers for that function. If you do not have any declarations, then there will not be any statements between the IS and BEGIN statements. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>executable statements</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The statements the function executes when it is called. You must have at least one executable statement after the BEGIN and before the END or EXCEPTION keywords. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>exception handler statements</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The optional exception handlers for the function. If you do not explicitly handle any exceptions, then you can leave out the EXCEPTION keyword and simply terminate the execution section with the END keyword. </P
></DD
></DL
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch15_05.htm#SQL2-CH-15-SECT-5.3"
>Figure 15.10</A
> illustrates the PL/SQL function and its different sections. Notice that the tot_sales function does not have an exception section. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-15-FIG-10"
>Figure 15.10: The tot_sales function</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1510.gif"
ALT="Figure 15.10"></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.2"
>15.5.2 The RETURN Datatype</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13718"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13720"
></A
>The return_datatype is the datatype of the value returned by the function. This datatype can be any datatype (and many complex structures) supported by PL/SQL, including scalars like these: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>VARCHAR2</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>NUMBER</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>BINARY_INTEGER</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>BOOLEAN</P
></LI
></UL
><P
CLASS="para"
>Functions can also return complex and composite datatypes, such as:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>PL/SQL table (Oracle7)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Nested table or variable array (VARRAY) (PL/SQL8)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>PL/SQL record</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Object type (PL/SQL8)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Large objects (LOBs) such as BFILEs and CLOBs (PL/SQL8)</P
></LI
></UL
><P
CLASS="para"
>The datatype of a function cannot be either of the following:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Named exception</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Once you declare an exception, you can reference that exception only in a RAISE statement and in the exception handler itself. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Cursor name</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>You cannot return a cursor from a function. (Note that PL/SQL Release 2.2 and beyond provides a REF CURSOR TYPE declaration that will allow you to return a cursor and even declare a parameter as a cursor.) </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.3"
>15.5.3 The END Label</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13759"
></A
>You can append the name of the function directly after the END keyword when you complete your function, as shown below: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION tot_sales (company_in IN INTEGER) RETURN NUMBER
IS
BEGIN
   ...
END tot_sales;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This name serves as a label that explicitly links up the end of the program with its beginning. You should as a matter of habit use an END label. It is especially important to do so when you have a function that spans more than a single page, or is one in a series of functions and procedures in a package body. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.4"
>15.5.4 Calling a Function</A
></H3
><P
CLASS="para"
>A function is called as part of an executable PL/SQL statement, wherever an expression can be used. The following examples illustrate the different ways that the tot_sales function demonstrated in <A
CLASS="xref"
HREF="ch15_05.htm#SQL2-CH-15-SECT-5.3"
>Figure 15.10</A
> might be called: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Call tot_sales to assign a value to a local PL/SQL variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>sales_for_1995 := tot_sales (1504, 'C');</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use a call to tot_sales to set a default value for a variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   sales_for_1995 NUMBER DEFAULT tot_sales (1504, 'C');
BEGIN</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use tot_sales directly in an expression:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF tot_sales (275, 'O') &gt; 10000
THEN
...</PRE
></BLOCKQUOTE
></LI
></UL
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.4.1"
>15.5.4.1 Functions without parameters</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13780"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13784"
></A
>If a function has no parameters, then the function call must be written without parentheses, as the line below illustrates: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF tot_sales THEN ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that you cannot tell just by looking at the above line of code whether tot_sales is a function or a variable. You would, in fact, have to check the declaration section of your PL/SQL block if you really needed to know. And that's the whole point. A function returns a value, as does a variable. The function just happens to execute some code to come up with that value, whereas a variable has that value as its very attribute, available for immediate return. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.5"
>15.5.5 Function Header</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13792"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13795"
></A
>The portion of the function definition that comes before the IS keyword is called the function header. The header provides all the information a programmer needs to call that function, namely: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The function name</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The parameter list, if any</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The RETURN datatype</P
></LI
></UL
><P
CLASS="para"
>A programmer does not need to know about the inside of the function in order to be able to call it properly from another program. </P
><P
CLASS="para"
>The header for the tot_sales function discussed above is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION tot_sales
   (company_id_in IN company.company_id%TYPE,
    status_in IN order.status_code%TYPE := NULL)
RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It consists of the module type, the name, a list of two parameters, and a RETURN datatype of NUMBER. This means that the PL/SQL statement containing a call to tot_sales must be able to use a numeric value. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.6"
>15.5.6 Function Body</A
></H3
><P
CLASS="para"
>The body of the function is the code required to implement the function. It consists of the declaration, execution, and exception sections of the function. Everything after the IS keyword in the function makes up that function's body. </P
><P
CLASS="para"
>Once again, the declaration and exception sections are optional. If you have no exception handlers, you will simply leave off the EXCEPTION keyword and enter the END statement to terminate the function. </P
><P
CLASS="para"
>If you do not have any declarations, the BEGIN statement simply follows immediately after the IS keyword (see the does_nothing function below for an example of this structure). </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.7"
>15.5.7 A Tiny Function</A
></H3
><P
CLASS="para"
>You must supply at least one executable statement in a function. Here is my candidate for the Boolean function with the smallest possible body in PL/SQL: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION does_nothing RETURN BOOLEAN IS
BEGIN
   RETURN TRUE;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You would call does_nothing as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF does_nothing
THEN
   NULL;
END IF;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.8"
>15.5.8 The RETURN Statement</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948975-1"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948975-2"
></A
>A function must have at least one RETURN statement in its execution section of statements. It can have more than one RETURN, but only one of those statements is executed each time the function is called. The RETURN statement that is executed by the function determines the value that is returned by that function. When a RETURN statement is processed, the function terminates immediately and returns control to the calling PL/SQL block. </P
><P
CLASS="para"
>The RETURN clause in the header of the function is different from the RETURN statement in the execution section of the body of the function. While the RETURN clause indicates the datatype of the return or result value of the function, the RETURN statement specifies the actual value that is returned. You have to specify the RETURN datatype in the header, but then also include at least one RETURN statement in the function. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.8.1"
>15.5.8.1 Multiple RETURNs</A
></H4
><P
CLASS="para"
>In the tot_sales function shown in <A
CLASS="xref"
HREF="ch15_05.htm#SQL2-CH-15-SECT-5.3"
>Figure 15.10</A
>, I used two different RETURN statements to handle different situations in the function, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF sales_cur%NOTFOUND
THEN
   CLOSE sales_cur;
   RETURN NULL;
ELSE
   CLOSE sales_cur;
   RETURN return_value;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, if I could not obtain sales information from the cursor, I will return NULL (which is different from zero). If I do get a value from the cursor, I return it to the calling program. In both of these cases the RETURN statement passes back a value; in one case the NULL value, and in the other the return_value variable. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.8.2"
>15.5.8.2 RETURN any valid expression</A
></H4
><P
CLASS="para"
>The RETURN statement can accept any expression for evaluation and return. This expression can be composed of calls to other functions, complex calculations, and even data conversions. All of the following usages of RETURN are valid: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>RETURN 'buy me lunch';
RETURN POWER (max_salary, 5);
RETURN (100 - pct_of_total_salary (employee_id));
RETURN TO_DATE ('01' || earliest_month || initial_year, 'DDMMYY');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>An expression in the RETURN statement is evaluated when the RETURN is executed. When control is passed back to the calling form, the result of the evaluated expression is passed along, too. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.8.3"
>15.5.8.3 No RETURN is executed</A
></H4
><P
CLASS="para"
>What happens when you include one or any number of RETURN statements in your functions but none of them is executed? PL/SQL raises an error. </P
><P
CLASS="para"
>The following function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION company_type (type_code_in IN VARCHAR2)
   RETURN VARCHAR2 IS
BEGIN
   IF type_code_in = 'S'
   THEN
      RETURN 'SUBSIDIARY';
   ELSIF type_code_in = 'P'
   THEN
      RETURN 'PARTNER';
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>is then called in this executable statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>type_description := company_type ('R');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because the RETURN statements are executed only when the type code is `S' or `P', the function never hits a RETURN. <A
CLASS="indexterm"
NAME="AUTOID-13848"
></A
>It does, however, execute to the end of the function and then raise an error, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-6503: PL/SQL: Function returned without value</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can avoid this kind of problem (which you may never encounter in testing since you always pass a sensible value to the function) by restructuring your use of the RETURN statement. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.8.4"
>15.5.8.4 RETURN as last executable statement</A
></H4
><P
CLASS="para"
>Generally, the best way to make sure that your function always returns a value is to make the last executable statement in the function your RETURN statement. Declare a variable named return_value, which clearly indicates that it will contain the return value for the function, write all the code to come up with that value, and then at the very end of the function RETURN the return_value: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION do_it_all (parameter_list) RETURN NUMBER
IS
   return_value NUMBER;
BEGIN

   ... lots of executable statements ...

   RETURN return_value;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The company_type function, for example, can be converted easily to this structure: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION company_type (type_code_in IN VARCHAR2)
   RETURN VARCHAR2
IS
   return_value VARCHAR2 (25) := NULL;
BEGIN
   IF type_code_in = 'S'
   THEN
      return_value := 'SUBSIDIARY';

   ELSIF type_code_in = 'P'
   THEN
      return_value := 'PARTNER';
   END IF;

   RETURN return_value;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that, because I provided the return_value variable with a default value of NULL, I didn't have to code an ELSE clause in the IF statement to explicitly make that assignment (though doing so would probably make the code more readable). If the type_code_in does not match any of the values in the IF statement, there is no problem because each IF and ELSIF no longer performs its own RETURN. Instead, they just assign a value and then leave the RETURNing to the little RETURN section at the end of the function. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-5.8.5"
>15.5.8.5 RETURN statement in a procedure</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13863"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13866"
></A
>Believe it or not, RETURN statements can also be used in procedures. The procedure version of the RETURN does not take an expression; it cannot, therefore, pass a value back to the calling program unit. The RETURN simply halts execution of the procedure and returns control to the calling code. </P
><P
CLASS="para"
>You do not (should not, in any case) see this usage of RETURN very often, and for good reason. Use of the RETURN in a procedure usually leads to very unstructured code that is hard to understand and maintain. Avoid using both RETURN and GOTO to bypass proper control structures and process flow in your program units. </P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_04.htm#SQL2-CH-15-SECT-4.4"
TITLE="15.4 Procedures"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 15.4 Procedures"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_06.htm#SQL2-CH-15-SECT-6.2.3"
TITLE="15.6 Parameters"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 15.6 Parameters"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>15.4 Procedures</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>15.6 Parameters</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
