<HTML
><HEAD
><TITLE
>[Chapter 4] 4.2 Scalar Datatypes </TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:53:40Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. Variables and Program Data"><LINK
REL="prev"
HREF="ch04_01.htm"
TITLE="4.1 Identifiers"><LINK
REL="next"
HREF="ch04_03.htm#SQL2-CH-4-SECT-3.3"
TITLE="4.3 NULLs in PL/SQL"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_01.htm"
TITLE="4.1 Identifiers"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.1 Identifiers"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. Variables and Program Data"
>Chapter 4<BR>Variables and Program Data</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_03.htm#SQL2-CH-4-SECT-3.3"
TITLE="4.3 NULLs in PL/SQL"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.3 NULLs in PL/SQL"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2"
>4.2 Scalar Datatypes </A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2940"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-2943"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-25580-3"
></A
>Each constant and variable element you use in your programs has a datatype. The datatype dictates the storage format, the restrictions on how the variable can be used, and the valid values which may be placed in that variable. </P
><P
CLASS="para"
>PL/SQL offers a comprehensive set of predefined scalar and composite datatypes. A scalar datatype is an atomic; it is not made up of other variable components. A composite datatype has internal structure or components. The two composite types currently supported by PL/SQL are the record and table (described in <A
CLASS="xref"
HREF="ch09_01.htm"
>Chapter 9, <CITE
CLASS="chapter"
>Records in PL/SQL</CITE
></A
>, and <A
CLASS="xref"
HREF="ch10_01.htm"
>Chapter 10, <CITE
CLASS="chapter"
>PL/SQL Tables</CITE
></A
>, respectively). </P
><P
CLASS="para"
>The scalar datatypes fall into one of four categories or families: number, character, Boolean, and date-time, as shown in <A
CLASS="xref"
HREF="ch04_02.htm#SQL2-CH-4-SECT-2.7.7"
>Table 4.1</A
>. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-4-TABLE-2"
>Table 4.1: Datatype Categories </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Category</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Datatype</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Number</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>BINARY_INTEGER</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DEC</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DECIMAL</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DOUBLE PRECISION</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>FLOAT</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>INT</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>INTEGER</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NATURAL</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMERIC</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>PLS_INTEGER</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>POSITIVE</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>REAL</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>SMALLINT</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Character</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CHAR</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CHARACTER</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>LONG</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>LONG RAW</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NCHAR</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NVARCHAR2</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>RAW</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ROWID</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>STRING</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>VARCHAR</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>VARCHAR2</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Boolean</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>BOOLEAN</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Date-time</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DATE</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Large object (LOB)</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>BFILE</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>BLOB</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CLOB</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>  </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NCLOB</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Let's take a closer look at each of the scalar datatypes. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.1"
>4.2.1 Numeric Datatypes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-25581-1"
></A
> PL/SQL, just like the Oracle RDBMS, offers a variety of numeric datatypes to suit different purposes. There are generally two types of numeric data: whole number and decimal (in which digits to the right of the decimal point are allowed). </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.1.1"
>4.2.1.1 Binary integer datatypes</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3104"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3106"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3108"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3110"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3112"
></A
>The whole number, or integer, datatypes are: </P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>BINARY_INTEGER</TD
></TR
><TR
><TD
CLASS="member"
>INTEGER</TD
></TR
><TR
><TD
CLASS="member"
>SMALLINT</TD
></TR
><TR
><TD
CLASS="member"
>INT</TD
></TR
><TR
><TD
CLASS="member"
>POSITIVE</TD
></TR
><TR
><TD
CLASS="member"
>NATURAL</TD
></TR
></TABLE
><P
CLASS="para"
>The BINARY_INTEGER datatype allows you to store signed integers. The range of magnitude of a BINARY_INTEGER is -2<SUP
CLASS="superscript"
>31</SUP
> + 1 through 2<SUP
CLASS="superscript"
>31</SUP
> - 1 (2<SUP
CLASS="superscript"
>31</SUP
> is equal to 2147483647). BINARY_INTEGERs are represented in the PL/SQL compiler as signed binary numbers. They do not, as a result, need to be converted before PL/SQL performs numeric calculations. Variables of type NUMBER (see <A
CLASS="xref"
HREF="ch04_02.htm#SQL2-CH-4-SECT-2.7.7"
>Section 4.2.1.2, "Decimal numeric datatypes"</A
>") do, however, need to be converted. So if you will be performing intensive calculations with integer values, you might see a performance improvement by declaring your variables as BINARY_INTEGER. In most situations, to be honest, the slight savings offered by BINARY_INTEGER will not be noticeable. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3127"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3129"
></A
>NATURAL and POSITIVE are both subtypes of BINARY_INTEGER. A subtype uses the storage format and restrictions on how the variable of this type can be used, but it allows only a subset of the valid values allowed by the full datatype. In the case of BINARY_INTEGER subtypes, we have the following value subsets: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>NATURAL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>0 through 231</P
></DD
><DT
CLASS="term"
>POSITIVE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>1 through 2<SUP
CLASS="superscript"
>31</SUP
></P
></DD
></DL
><P
CLASS="para"
>If you have a variable whose values must always be non-negative (0 or greater), you should declare that variable to be NATURAL or POSITIVE. This improves the self-documenting aspect of your code. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.1.2"
>4.2.1.2 Decimal numeric datatypes</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3145"
></A
>The decimal numeric datatypes are: </P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>NUMBER</TD
></TR
><TR
><TD
CLASS="member"
>FLOAT</TD
></TR
><TR
><TD
CLASS="member"
>DEC</TD
></TR
><TR
><TD
CLASS="member"
>DECIMAL</TD
></TR
><TR
><TD
CLASS="member"
>DOUBLE PRECISION</TD
></TR
><TR
><TD
CLASS="member"
>NUMBER</TD
></TR
><TR
><TD
CLASS="member"
>NUMERIC</TD
></TR
><TR
><TD
CLASS="member"
>REAL</TD
></TR
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3157"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3159"
></A
>Use the NUMBER datatype to store fixed or floating-point numbers of just about any size. The maximum precision of a variable with NUMBER type is 38 digits. This means that the range of magnitude of values is 1.0E-129 through 9.999E125; you are unlikely to require numbers outside of this range. </P
><P
CLASS="para"
>When you declare a variable type NUMBER, you can also optionally specify the variable's precision and scale, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NUMBER (precision, scale)</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3165"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3167"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3169"
></A
>The precision of a NUMBER is the total number of digits. The scale dictates the number of digits to the right or left of the decimal point at which rounding occurs. Both the precision and scale values must be literal values (and integers at that); you cannot use variables or constants in the declaration. Legal values for the scale range from -84 to 127. Rounding works as follows: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If the scale is positive, then the scale determines the point at which rounding occurs to the right of the decimal point. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the scale is negative, then the scale determines the point at which rounding occurs to the left of the decimal point. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the scale is zero, then rounding occurs to the nearest whole number. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the scale is not specified, then no rounding occurs.</P
></LI
></UL
><P
CLASS="para"
>The following examples demonstrate the different ways you can declare variables of type NUMBER: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The bean_counter variable can hold values with up to ten digits of precision, three of which are to the right of the decimal point. If you assign 12345.6784 to bean_counter, it is rounded to 12345.678. If you assign 1234567891.23 to the variable, the operation will return an error because there are more digits than allowed for in the precision. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>bean_counter NUMBER (10,3);</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The big_whole_number variable contains whole numbers spanning the full range of supported values, because the default precision is 38 and the default scale is 0. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>big_whole_number NUMBER;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The rounded_million variable is declared with a negative scale. This causes rounding to the left of the decimal point. Just as a scale of -1 would cause rounding to the nearest tenth, a scale of -2 would round to the nearest hundred and a scale of -6 would round to the nearest million. If you assign 53.35 to rounded_million, it will be rounded to 0. If you assign 1,567,899 to rounded_million, it will be rounded to two million (2,000,000). </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>rounded_million NUMBER (10,-6);</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In the following unusual but perfectly legitimate declaration, the scale is larger than the precision. In this case, the precision indicates the maximum number of digits allowed&nbsp;-- all to the right of the decimal point. If you assign .003566 to small_value, it will be rounded to .00357. Because the scale is two greater than the precision, any value assigned to small_value must have two zeros directly to the right of the decimal point, followed by up to three nonzero digits. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>small_value NUMBER (3, 5);</PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.1.3"
>4.2.1.3 The PLS_INTEGER datatype</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3198"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3200"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3202"
></A
>This datatype is available in PL/SQL Release 2.3 and above. </P
><P
CLASS="para"
>Variables declared as PLS_INTEGER store signed integers. The magnitude range for this datatype is -2147483647 through 2147483647. Oracle recommends that you use PLS_INTEGER for all integer calculations which do not fall outside of its range. PLS_INTEGER values require less storage than NUMBER values, and operations on PLS_INTEGER's use machine arithmetic, making them more efficient. </P
><P
CLASS="para"
>Variables declared as pls_integer and binary_integer have the same range, but they are treated differently. When a calculation involving pls_integer overflows, pl/sql raises an exception. However, similar overflow involving binary_integers will not raise an exception if the result is being assigned to a number variable. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-8-fm2xml"
>4.2.2 <A
CLASS="indexterm"
NAME="AUTOID-3209"
></A
> Numeric Subtypes</A
></H3
><P
CLASS="para"
>The remainder of the datatypes in the numeric category are all subtypes of NUMBER. They are provided in ORACLE's SQL and in PL/SQL in order to offer compatibility with ANSI SQL, SQL/DS, and DB2 datatypes. They have the same range of legal values as their base type, as displayed in <A
CLASS="xref"
HREF="ch04_02.htm#SQL2-CH-4-SECT-2.7.7"
>Table 4.2</A
>. <A
CLASS="indexterm"
NAME="AUTOID-3213"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3215"
></A
>The NUMERIC, DECIMAL, and DEC datatypes can declare only fixed-point numbers. FLOAT, DOUBLE PRECISION, and REAL allow floating decimal points with binary precisions that range from 63 to 126. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-4-TABLE-4"
>Table 4.2: Predefined Numeric Subtypes </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3227"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3229"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3231"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3233"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3235"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3238"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3241"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3243"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3245"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3248"
></A
>Subtype </P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Compatibility</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Corresponding Oracle Datatype</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DEC (prec, scale)</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ANSI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER (prec, scale)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DECIMAL (prec, scale)</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>IBM</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER (prec, scale)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DOUBLE PRECISION </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ANSI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>FLOAT (binary)</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ANSI, IBM</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>INT </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ANSI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER (38)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>INTEGER</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ANSI, IBM</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER (38)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMERIC (prec, scale)</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ANSI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER (prec, scale)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>REAL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ANSI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>SMALLINT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>ANSI, IBM</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NUMBER (38)</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Prec, scale, and binary have the following meanings:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>prec</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Precision for the subtype</P
></DD
><DT
CLASS="term"
>scale </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Scale of the subtype</P
></DD
><DT
CLASS="term"
>binary</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Binary precision of the subtype</P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.3"
>4.2.3 Character Datatypes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3335"
></A
> <A
CLASS="indexterm"
NAME="ch04-idx-25589-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-25589-3"
></A
> <A
CLASS="indexterm"
NAME="ch04-idx-25589-4"
></A
>Variables with character datatypes store text and are manipulated by character functions. Because character strings are "free-form," there are few rules concerning their content. You can, for example, store numbers and letters, as well as any combination of special characters, in a character-type variable. There are, however, several different kinds of character datatypes, each of which serves a particular purpose. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.3.1"
>4.2.3.1 The CHAR datatype</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3351"
></A
>The CHAR datatype specifies that the character string has a fixed length. When you declare a fixed-length string, you also specify a maximum length for the string, which can range from 1 to 32767 bytes (this is much higher than that for the CHAR datatype in the Oracle RDBMS, which is only 255). If you do not specify a length for the string, then PL/SQL declares a string of one byte. Note that this is the opposite of the situation with the NUMBER datatype. For example, a declaration of: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>fit_almost_anything NUMBER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>results in a numeric variable with up to 38 digits of precision. You could easily get into a bad habit of declaring all your whole number variables simply as NUMBER, even if the range of legal values is much smaller than the default. However, if you try a similar tactic with CHAR, you may be in for a nasty surprise. If you declare a variable as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>line_of_text CHAR;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>then as soon as you assign a string of more than one character to line_of_text, PL/SQL will raise the generic VALUE_ERROR exception. It will not tell you where it encountered this problem. So if you do get this error, check your variable declarations for a lazy use of CHAR. </P
><P
CLASS="para"
>Just to be sure, you should always specify a length when you use the CHAR datatype. Several examples follow: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>yes_or_no CHAR (1) DEFAULT 'Y';
line_of_text    CHAR (80); --Always a full 80 characters!
whole_paragraph CHAR (10000); --Think of all the spaces...</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3360"
></A
>Remember that even though you can declare a CHAR variable with 10,000 characters, you will not be able to stuff that PL/SQL variable's value into a database column of type CHAR. It will take up to 255 characters. So if you want to insert a CHAR value into the database and its declared length is greater than 255, you will have to use the SUBSTR function (described in <A
CLASS="xref"
HREF="ch11_01.htm"
>Chapter 11, <CITE
CLASS="chapter"
>Character Functions</CITE
></A
>) to trim the value down to size: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO customer_note
   (customer_id, full_text /* Declared as CHAR(255) */)
VALUES
   (1000, SUBSTR (whole_paragraph, 1, 255));</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3366"
></A
>Because CHAR is fixed-length, PL/SQL will right-pad any value assigned to a CHAR variable with spaces to the maximum length specified in the declaration. Prior to Oracle7, the CHAR datatype was variable-length; Oracle did not, in fact, support a fixed-length character string datatype and prided itself on that fact. To improve compatibility with IBM relational databases and to comply with ANSI standards, Oracle7 reintroduced CHAR as a fixed-length datatype and offered VARCHAR2 as the variable-length datatype. When a Version 6 RDBMS is upgraded to Oracle7, all CHAR columns are automatically converted to VARCHAR2. (VARCHAR2 is discussed in the next section.) </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3371"
></A
>You will rarely need or want to use the CHAR datatype in Oracle-based applications. In fact, I recommend that you never use CHAR unless there is a specific requirement for fixed-length strings or unless you are working with data sources like DB2. Character data in DB2 is almost always stored in fixed-length format due to performance problems associated with variable-length storage. So, if you build applications that are based on DB2, you may have to take fixed-length data into account in your SQL statements and in your procedural code. You may, for example, need to use RTRIM to remove trailing spaces from (or RPAD to pad spaces onto) many of your variables in order to allow string comparisons to function properly. (These character functions are described in <A
CLASS="xref"
HREF="ch11_01.htm"
>Chapter 11</A
>.) </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.3.2"
>4.2.3.2 The VARCHAR2 and VARCHAR datatypes</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3377"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3379"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3381"
></A
> VARCHAR2 variables store variable-length character strings. When you declare a variable-length string, you must also specify a maximum length for the string, which can range from 1 to 32767 bytes. The general format for a VARCHAR2 declaration is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;variable_name&gt; VARCHAR2 (&lt;max_length&gt;);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>as in:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   small_string VARCHAR2(4);
   line_of_text VARCHAR2(2000);</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> In Version 1.1 of PL/SQL, which you use in Oracle Developer/2000 tools like Oracle Forms, the compiler does not insist that you include a maximum length for a VARCHAR2 declaration. As a result, you could mistakenly leave off the length in the declaration and end up with a variable with a maximum length of a single character. As discussed in the section on the fixed-length CHAR datatype, this can cause PL/SQL to raise runtime VALUE_ERROR exceptions. Always include a maximum length in your character variable declarations. </P
></BLOCKQUOTE
><P
CLASS="para"
>The maximum length allowed for PL/SQL VARCHAR2 variables is a much higher maximum than that for the VARCHAR2 datatype in the Oracle RDBMS, which is only 2000. As a result, if you plan to store a PL/SQL VARCHAR2 value into a VARCHAR2 database column, you must remember that only the first 2000 can be inserted. Neither PL/SQL nor SQL automatically resolves this inconsistency, though. You will need to make sure you don't try to pass more than the maximum 2000 (actually, the maximum length specified for the column) through the use of the SUBSTR function. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3391"
></A
>Because the length of a LONG column is two gigabytes, on the other hand, you can insert PL/SQL VARCHAR2 values into a LONG column without any worry of overflow. (LONG is discussed in the next section.) </P
><P
CLASS="para"
>The VARCHAR datatype is actually a subtype of VARCHAR2, with the same range of values found in VARCHAR2. VARCHAR, in other words, is currently synonymous with VARCHAR2. Use of VARCHAR offers compatibility with ANSI and IBM relational databases. There is a strong possibility, however, that VARCHAR's meaning might change in a new version of the ANSI SQL standards. Oracle recommends that you avoid using VARCHAR if at all possible, and instead stick with VARCHAR2 to declare variable-length PL/SQL variables (and table columns as well). </P
><P
CLASS="para"
>If you make use of both fixed-length (CHAR) and variable-length (VARCHAR2) strings in your PL/SQL code, you should be aware of the following interactions between these two datatypes: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3399"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3401"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3403"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3406"
></A
>Database-to-variable conversion. When you SELECT or FETCH data from a CHAR database column into a VARCHAR2 variable, the trailing spaces are retained. If you SELECT or FETCH from a VARCHAR2 database column into a CHAR variable, PL/SQL automatically pads the value with spaces out to the maximum length. In other words, the type of the variable, not the column, determines the variable's resulting value. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3411"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3413"
></A
> Variable-to-database conversion. When you INSERT or UPDATE a CHAR variable into a VARCHAR2 database column, the SQL kernel does not trim the trailing blanks before performing the change. When the following PL/SQL is executed, the company_name in the new database record is set to `ACME SHOWERS········' (where · indicates a space). It is, in other words, padded out to 20 characters, even though the default value was a string of only 12 characters: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   comp_id#    NUMBER;
   comp_name   CHAR(20) := 'ACME SHOWERS';
BEGIN
   SELECT company_id_seq.NEXTVAL
      INTO comp_id#
      FROM dual;
   INSERT INTO company (company_id, company_name)
      VALUES (comp_id#, comp_name);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>On the other hand, when you INSERT or UPDATE a VARCHAR2 variable into a CHAR database column, the SQL kernel automatically pads the variable-length string with spaces out to the maximum (fixed) length specified when the table was created, and places that expanded value into the database. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3419"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3422"
></A
> String comparisons. Suppose your code contains a string comparison such as the following: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF company_name = parent_company_name ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>PL/SQL must compare company_name to parent_company_name. It performs the comparison in one of two ways, depending on the types of the two variables: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If a comparison is made between two CHAR variables, then PL/SQL uses a blank-padding comparison. With this approach, PL/SQL blank-pads the shorter of the two values out to the length of the longer value. It then performs the comparison. So with the above example, if company_name is declared CHAR(30) and parent_company_name is declared CHAR(35), then PL/SQL adds five spaces to the end of the value in company_name and then performs the comparison. Note that PL/SQL does not actually change the variable's value. It copies the value to another memory structure and then modifies this temporary data for the comparison. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If at least one of the strings involved in the comparison is variable-length, then PL/SQL performs a nonblank-padding comparison. It makes no changes to any of the values, uses the existing lengths, and performs the comparison. This comparison analysis is true of evaluations which involve more than two variables as well, as may occur with the IN operator: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF menu_selection NOT IN
      (save_and_close, cancel_and_exit, 'OPEN_SCREEN')
   THEN ...</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>If any of the four variables (menu_selection, the two named constants, and the single literal) is declared VARCHAR2, then exact comparisons without modification are performed to determine if the user has made a valid selection. Note that a literal like OPEN_SCREEN is always considered a fixed-length CHAR datatype. </P
></LI
></UL
><P
CLASS="para"
>These rules can make your life very complicated. Logic which looks perfectly correct may not operate as expected if you have a blend of fixed-length and variable-length data. Consider the following fragment: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   company_name CHAR (30) DEFAULT 'PC HEAVEN';
   parent_company_name  VARCHAR2 (25) DEFAULT 'PC HEAVEN';
BEGIN
   IF company_name = parent_company_name
   THEN
      -- This code will never be executed.
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The conditional test will never return TRUE because the value company_name has been padded to the length of 30 with 21 spaces. To get around problems like this, you should always RTRIM your CHAR values when they are involved in any kind of comparison or database modification. </P
><P
CLASS="para"
>It makes more sense to use RTRIM (to remove trailing spaces) than it does to use RPAD (to pad variable-length strings with spaces). With RPAD you have to know what length you wish to pad the variable-length string to get it in order to match the fixed-length string. With RTRIM you just get rid of all the blanks and let PL/SQL perform its nonblank-padding comparison. </P
><P
CLASS="para"
>It was easy to spot the problem in this anonymous PL/SQL block because all the related statements are close together. In the real world, unfortunately, the variables' values are usually set in a much less obvious manner and are usually in a different part of the code from the conditional statement which fails. So if you have to use fixed-length variables, be on the lookout for logic which naively believes that trailing spaces are not an issue. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.3.3"
>4.2.3.3 The LONG datatype</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3442"
></A
>A variable declared LONG can store variable-length strings of up to 32760 bytes&nbsp;-- this is actually seven fewer bytes than allowed in VARCHAR2 type variables! The LONG datatype for PL/SQL variables is quite different from the LONG datatype for columns in the Oracle Server. <A
CLASS="indexterm"
NAME="AUTOID-3444"
></A
>The LONG datatype in Oracle7 can store character strings of up to two gigabytes or 231-1 bytes; this large size makes the LONG column a possible repository of multimedia information, such as graphics images. </P
><P
CLASS="para"
>As a result of these maximum length differences, you can always insert a PL/SQL LONG variable value into a LONG database column, but you cannot select a LONG database value larger than 32760 bytes into a PL/SQL LONG variable. </P
><P
CLASS="para"
>In the Oracle database, there are many restrictions on how the LONG column can be used in a SQL statement; for example: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>A table may <EM
CLASS="emphasis"
>not</EM
> contain more than one single LONG column. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You may <EM
CLASS="emphasis"
>not</EM
> use the LONG column in a GROUP BY, ORDER BY, WHERE, or CONNECT BY clause. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You may <EM
CLASS="emphasis"
>not</EM
> apply character functions (such as SUBSTR, INSTR, or LENGTH), to the LONG column. </P
></LI
></UL
><P
CLASS="para"
>PL/SQL LONG variables are free of these restrictions. In your PL/SQL code you can use a variable declared LONG just as you would a variable declared VARCHAR2. You can apply character functions to the variable. You can use it in the WHERE clause of a SELECT or UPDATE statement. This all makes sense given that, at least from the standpoint of the maximum size of the variables, there is really little difference between VARCHAR2 and LONG in PL/SQL. </P
><P
CLASS="para"
>Given the fact that a VARCHAR2 variable actually has a higher maximum length than the LONG and has no restrictions attached to it, I recommend that you always use the VARCHAR2 datatype in PL/SQL programs. LONGs have a place in the RDBMS, but that role is not duplicated in PL/SQL. This makes some sense since you will very rarely want to manipulate truly enormous strings within your program using such functions as SUBSTR or LENGTH or INSTR. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.3.4"
>4.2.3.4 The RAW datatype</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3463"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3465"
></A
>The RAW datatype is used to store binary data or other kinds of raw data, such as a digitized picture or image. A RAW variable has the same maximum length as VARCHAR2 (32767 bytes), which must also be specified when the variable is declared. The difference between RAW and VARCHAR2 is that PL/SQL will not try to interpret raw data. Within the Oracle RDBMS this means that Oracle will not perform character set conversions on RAW data when it is moved from one system (based, for example, on 7-bit ASCII) to another system. </P
><P
CLASS="para"
>Once again, there is an inconsistency between the PL/SQL maximum length for a RAW variable (32767) and the RDBMS maximum length (255). As a result, you cannot insert more than 255 bytes of your PL/SQL RAW variable's value into a database column. You can, on the other hand, insert the full value of a PL/SQL RAW variable into a column with type LONG RAW, which is a two-gigabyte container for raw data in the database. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.3.5"
>4.2.3.5 The LONG RAW datatype</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3472"
></A
>The LONG RAW datatype stores raw data of up to 32760 bytes and is just like the LONG datatype except that the data in a LONG RAW variable is not interpreted by PL/SQL. </P
><P
CLASS="para"
>Given the fact that a RAW variable actually has a higher maximum length than the LONG RAW and has no restrictions attached to it, I recommend that you always use the RAW datatype in PL/SQL programs. LONG RAWs have a place in the RDBMS, but that role is not duplicated in PL/SQL. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.3.6"
>4.2.3.6 The ROWID datatype</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-25610-1"
></A
>In the Oracle RDBMS, ROWID is a pseudocolumn that is a part of every table you create. The rowid is an internally generated and maintained binary value which identifies a row of data in your table. It is called a pseudocolumn because a SQL statement includes it in places where you would normally use a column. However, it is not a column that you create for the table. Instead, the RDBMS generates the rowid for each row as it is inserted into the database. The information in the rowid provides the exact physical location of the row in the database. You cannot change the value of a rowid. </P
><P
CLASS="para"
>You can use the ROWID datatype to store rowids from the database in your pl/sql program. You can SELECT or FETCH the rowid for a row into a ROWID variable. To manipulate rowids in Oracle8, you will want to use the built-in package, dbms_rowid (see <A
CLASS="xref"
HREF="appa_01.htm"
>Appendix A, <CITE
CLASS="appendix"
>What's on the Companion Disk?</CITE
></A
>). In Oracle7, you will use the rowidtochar function to convert the rowid to a fixed-length string and then perform operations against that string. </P
><P
CLASS="para"
>In Oracle7, the format of the fixed-length rowid is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BBBBBBB.RRRR.FFFFF</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Components of this format have the following meanings:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>BBBBBBB</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The block in the database file</P
></DD
><DT
CLASS="term"
>RRRR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The row in the block (where the first row is zero, not one)</P
></DD
><DT
CLASS="term"
>FFFFF</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The database file</P
></DD
></DL
><P
CLASS="para"
>All these numbers are hexadecimal; the database file is a number which you would then use to look up the actual name of the database file through the data dictionary. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3500"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3503"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3506"
></A
>In Oracle8, rowid have been "extended" to support partitioned tables and indexes. The new, extended rowids include a data object number, identifying the database segment. Any schema object found in the same segment, such as a cluster of tables, will have the same object number. In Oracle8, then, a rowid contains the following information: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The data object number</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The data file (where the first file is 1)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The data block within the data file</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The row in the data block (where the first row is 0)</P
></LI
></UL
><P
CLASS="para"
>Oracle8 provides functions in the dbms_rowid package to convert between the new formats of rowids. </P
><P
CLASS="para"
>Usually (and always in Oracle7), a rowid will uniquely identify a row of data. Within Oracle8, however, rows in different tables stored in the same cluster can have the same rowid value. </P
><P
CLASS="para"
>You are now probably thinking, "Why is he telling me this? Do I actually have to know about the physical blocks in the Oracle RDBMS? I thought the whole point of the relational approach is that I can focus on the logical design of my data and ignore the physical representation. Rowids are scary!" </P
><P
CLASS="para"
>Calm down. Very rarely would you want to use a rowid, and in those cases you probably wouldn't care about its internal structure. You would simply use it to find a row in the database. Access by rowid is typically the fastest way to locate or retrieve a particular row in the database: faster even than a search by primary key. </P
><P
CLASS="para"
>You could make use of the rowid in an Oracle Forms application to access the row in the database corresponding to the record on the screen. When you create a base-table block in Oracle Forms, it automatically includes the rowid in the block as an "invisible pseudoitem." You do not see it on your item list, but you can reference it in your triggers and PL/SQL program units. For example, to update the name of an employee displayed on the screen, you could issue the following statement: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UPDATE employee
   SET last_name = :employee.last_name
 WHERE rowid = :employee.rowid;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can also use rowid inside a cursor FOR loop (or any other loop which FETCHes records from a cursor) to make changes to the row just FETCHed, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE remove_internal_competitors IS
BEGIN
   FOR emp_rec IN
      (SELECT connections, rowid
         FROM employee
        WHERE sal &gt; 50000)
   LOOP
      IF emp_rec.connections IN ('President', 'CEO')
      THEN
         send_holiday_greetings;
      ELSE
         DELETE FROM employee
          WHERE rowid = emp_rec.rowid;
      END IF;
   END LOOP;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The DELETE uses the rowid stored in the emp_rec record to immediately get rid of anyone making more than $50,000 who does not have known connections to the President or CEO. Note that the DBA controls who may have EXECUTE privilege to this stored procedure. So one must now wonder: does the DBA have connections to the President or CEO? Well, in any case, use of the rowid guarantees the fastest possible DELETE of that employee. </P
><P
CLASS="para"
>Of course, the above procedure could also simply have fetched the employee_id (primary key of the employee table) and executed a DELETE based on that real column, as in: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DELETE FROM employee WHERE employee_id = emp_id;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I am not convinced that the theoretical performance gains of searching by rowid justify its use. The resulting code is harder to understand than the application-specific use of the primary key. Furthermore, references to rowid could cause portability problems in the future.[<A
CLASS="footnote"
HREF="#AUTOID-3530"
>1</A
>] </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-3530"
>[1]</A
> The rowid is not a part of the ANSI SQL standard; instead, it reflects directly the internal storage structure of the Oracle RDBMS. Use of this proprietary pseudo-column is akin to coding a clever trick in FORTRAN 77 which takes advantage of a loophole in the compiler to gain performance. The improvements could be wiped out in a future release of the software. If you are building applications which may need to work against both Oracle and non-Oracle data sources, you should avoid any references to the rowid pseudo-column and the ROWID datatype.</P
></DIV
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.4"
>4.2.4 The Boolean Datatype</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3535"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3538"
></A
>The Oracle RDBMS/SQL language offers features not found in PL/SQL, such as the Oracle SQL DECODE construct. PL/SQL, on the other hand, has a few tricks up its sleeve which are unavailable in native SQL. One particularly pleasant example of this is the BOOLEAN datatype.[<A
CLASS="footnote"
HREF="#AUTOID-3541"
>2</A
>] Boolean data may only be TRUE, FALSE, or NULL. A Boolean is a "logical" datatype. </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-3541"
>[2]</A
> The Boolean is named after George Boole, who lived in the first half of the 19th century and is considered "the father of symbolic logic." One therefore capitalizes "Boolean," whereas the other datatypes get no respect.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The Oracle RDBMS does not support a Boolean datatype. You can create a table with a column of datatype CHAR(1) and store either "Y" or "N" in that column to indicate TRUE or FALSE. That is a poor substitute, however, for a datatype which stores those actual Boolean values (or NULL). </P
><P
CLASS="para"
>Because there is no counterpart for the PL/SQL Boolean in the Oracle RDBMS, you can neither SELECT into a Boolean variable nor insert a TRUE or FALSE value directly into a database column. </P
><P
CLASS="para"
>Boolean values and variables are very useful in PL/SQL. Because a Boolean variable can only be TRUE, FALSE, or NULL, you can use that variable to explain what is happening in your code. With Booleans you can write code which is easily readable, because it is more English-like. You can replace a complicated Boolean expression involving many different variables and tests with a single Boolean variable that directly expresses the intention and meaning of the text. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.5"
>4.2.5 The Date-Time Datatype</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3549"
></A
>Most of our applications require the storage and manipulation of dates and times. Dates are quite complicated: not only are they highly-formatted data, but there are myriad rules for determining valid values and valid calculations (leap days and years, national and company holidays, date ranges, etc.). Fortunately, the Oracle RDBMS and PL/SQL offer us help in many ways to handle date information. </P
><P
CLASS="para"
>The RDBMS provides a true DATE datatype which stores both date and time information. While you can enter a date value in a variety of formats, the RDBMS stores the date in a standard, internal format. It is a fixed-length value which uses seven bytes. You cannot actually specify this internal or literal value with an assignment. Instead you rely on implicit conversion of character and numeric values to an actual date, or explicit conversion with the TO_DATE function. (The next section describes these types of conversion.) PL/SQL provides a DATE datatype which corresponds directly to the RDBMS DATE. </P
><P
CLASS="para"
>An Oracle DATE stores the following information:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>century</TD
></TR
><TR
><TD
CLASS="member"
>year</TD
></TR
><TR
><TD
CLASS="member"
>month</TD
></TR
><TR
><TD
CLASS="member"
>day</TD
></TR
><TR
><TD
CLASS="member"
>hour</TD
></TR
><TR
><TD
CLASS="member"
>minute</TD
></TR
><TR
><TD
CLASS="member"
>second</TD
></TR
></TABLE
><P
CLASS="para"
>PL/SQL validates and stores dates which fall between January 1, 4712 B.C. to December 31, 4712 A.D. The time component of a date is stored as the number of seconds past midnight. If you enter a date without a time (many applications do not require the tracking of time, so PL/SQL lets you leave it off), the time portion of the database value defaults to midnight (12:00:00 AM). </P
><P
CLASS="para"
>Neither the Oracle RDBMS DATE nor the PL/SQL DATE datatypes store times in increments of less than single seconds. The DATE datatype, therefore, is not very useful for tracking real-time activities which occur in subsecond intervals. If you need to track time at subsecond intervals, you could instead store this information as a number. You can obtain subsecond timings using the DBMS_UTILITY package's GET_TIME function described in <A
CLASS="xref"
HREF="appc_01.htm"
>Appendix C, <CITE
CLASS="appendix"
>Built-In Packages</CITE
></A
>. </P
><P
CLASS="para"
>Because a variable declared DATE is a true date and not simply a character representation of a date, you can perform arithmetic on date variables, such as the subtraction of one date from another, or the addition/subtraction of numbers from a date. You can make use of date functions, described in <A
CLASS="xref"
HREF="ch12_01.htm"
>Chapter 12, <CITE
CLASS="chapter"
>Date Functions</CITE
></A
>, which offer a wide range of powerful operations on dates. Use the SYSDATE function to return the current system date and time. You can also use the TO_CHAR conversion function (described in <A
CLASS="xref"
HREF="ch14_01.htm"
>Chapter 14, <CITE
CLASS="chapter"
>Conversion Functions</CITE
></A
>) to convert a date to character string or to a number. </P
><P
CLASS="para"
>In PL/SQL, a Julian date is the number of days since the first valid date, January 1, 4712 BC. Use Julian dates if you need to perform calculations or display date information with a single point of reference and continuous dating. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.6"
>4.2.6 NLS Character Datatypes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-998563-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-998563-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-998563-3"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-998563-4"
></A
>When working with languages like Japanese, the 8-bit ASCII character set is simply not able to represent all of the available characters. Such languages require 16 bits (two bytes) to represent each character. Oracle offers National Language Support (NLS) to process single-byte and multibyte character data. NLS features also allow you to convert between character sets. PL/SQL8 supports two character sets which allow for the storage and manipulation of strings in either single-byte or multibyte formats. The two character sets are: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Database character set: used for PL/SQL identifiers and source code</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>National character set: used for NLS data</P
></LI
></UL
><P
CLASS="para"
>PL/SQL offers two datatypes, NCHAR and NVARCHAR2, to store character strings formed from the national character set. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.6.1"
>4.2.6.1 The NCHAR datatype</A
></H4
><P
CLASS="para"
>Use the <A
CLASS="indexterm"
NAME="AUTOID-3592"
></A
> NCHAR datatype to store fixed-length nls character data. The internal representation of the data is determined by the national character set. When you declare a variable of this type, you can also specify its length. If you do not provide a length, the default of 1 is used. </P
><P
CLASS="para"
>Here is the declaration of a NCHAR variable with a length of 10:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ssn NCHAR (10);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the declaration of a NCHAR variable with a default length of 1: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>yes_no NCHAR;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The maximum length for NCHAR variables is 32767.</P
><P
CLASS="para"
>But what does "a length of 10" actually mean? If the national character set is a fixed-width character set, then the length indicates length in characters. If the national character set is a variable-width character set (JA16SJIS is one example), then the length indicates length in bytes. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-21-fm2xml"
>4.2.6.2 The <A
CLASS="indexterm"
NAME="AUTOID-3602"
></A
> NVARCHAR2 datatype</A
></H4
><P
CLASS="para"
>Use the nvarchar2 datatype to store variable-length nls character data. The internal representation of the data is determined by the national character set. When you declare a variable of this type, you must also specify its length. </P
><P
CLASS="para"
>Here is the declaration of an nvarchar2 variable with a maximum length of 200: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>any_name NVARCHAR2 (200);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The maximum length allowed for nvarchar2 variables is 32767. Length has the same meaning described above for nchar. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.7"
>4.2.7 LOB Datatypes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-998647-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-998647-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-998647-3"
></A
>Oracle8 and PL/SQL8 support several variations of LOB (large object) datatypes. LOBs can store large amounts (up to four gigabytes) of raw data, binary data (such as images), or character text data. </P
><P
CLASS="para"
>Within PL/SQL you can declare LOB variables of the following datatypes: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>BFILE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Declares variables that hold a file locator pointing to large binary objects in operating system files outside of the database. </P
></DD
><DT
CLASS="term"
>BLOB</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Declares variables that hold a LOB locator pointing to a large binary object. </P
></DD
><DT
CLASS="term"
>CLOB</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Declares variables that hold a LOB locator pointing to a large block of single-byte, fixed-width character data. </P
></DD
><DT
CLASS="term"
>NCLOB</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Declares variables that hold a LOB locator pointing to a large block of single-byte or fixed-width multibyte character data. </P
></DD
></DL
><P
CLASS="para"
>There are two types of LOBs in Oracle8: internal and external. Internal LOBs (BLOB, CLOB, and NCLOB) are stored in the database and can participate in a transaction in the database server. External LOBs (BFILE) are large binary data stored in operating system files outside the database tablespaces. External LOBs cannot participate in transactions. You cannot, in other words, commit or roll back changes to a BFILE. Instead, you rely on the underlying filesystem for data integrity. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.7.1"
>4.2.7.1 The BFILE datatype</A
></H4
><P
CLASS="para"
>Use the BFILE datatype to store large binary objects (up to four gigabytes in size) in files outside of the database. This variable gives you read-only, byte-stream I/O access to these files (which can reside on a hard disk, CD-ROM, or other such device). </P
><P
CLASS="para"
>When you declare a BFILE variable, you allocate memory to store the file locator of the BFILE, not the BFILE contents itself. This file locator contains a directory alias as well as a file name. See <A
CLASS="xref"
HREF="ch04_02.htm#SQL2-CH-4-SECT-2.7.7"
>Section 4.2.7.7, "Working with BFILEs"</A
> later in this chapter for more information about the file locator. </P
><P
CLASS="para"
>Here is an example of a declaration of a BFILE variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_part1 BFILE;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.7.2"
>4.2.7.2 The BLOB datatype</A
></H4
><P
CLASS="para"
>Use the <A
CLASS="indexterm"
NAME="AUTOID-3648"
></A
>BLOB datatype to store large binary objects "out of line" inside the database. This means that when a table has a BLOB column, a row of data for that table contains a pointer or a locator to the actual location of the BLOB data (so it is not "in line" with the other column values of the row). </P
><P
CLASS="para"
>A BLOB variable contains a locator, which then points to the large binary object. BLOBs can be up to four gigabytes in size, and they participate fully in transactions. In other words, any changes you make to a BLOB (via the DBMS_LOB built-in package) can be rolled back or committed along with other outstanding changes in your transaction. BLOB locators cannot, however, span transactions or sessions. </P
><P
CLASS="para"
>Here is an example of a declaration of a BLOB variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   family_portrait BLOB;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.7.3"
>4.2.7.3 The CLOB datatype</A
></H4
><P
CLASS="para"
>Use the <A
CLASS="indexterm"
NAME="AUTOID-3656"
></A
>CLOB datatype to store large blocks of single-byte character data "out of line" inside the database. This means that when a table has a CLOB column, a row of data for that table contains a pointer or locator to the actual location of the CLOB data (so it is not "in line" with the other column values of the row). </P
><P
CLASS="para"
>A CLOB variable contains a locator, which then points to the large block of single-byte character data. CLOBs can be up to four gigabytes in size, and they participate fully in transactions. In other words, any changes you make to a CLOB (via the DBMS_LOB built-in package) can be rolled back or committed along with other outstanding changes in your transaction. CLOB locators cannot, however, span transactions or sessions. </P
><P
CLASS="para"
>Variable-width character sets are not supported in CLOBs.</P
><P
CLASS="para"
>Here is an example of a declaration of a CLOB variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   war_and_peace_text CLOB;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.7.4"
>4.2.7.4 The NCLOB datatype</A
></H4
><P
CLASS="para"
>Use the <A
CLASS="indexterm"
NAME="AUTOID-3665"
></A
> NCLOB datatype to store large blocks of single-byte or fixed-width multibyte character data "out of line" inside the database. This means that when a table has a NCLOB column, a row of data for that table contains a pointer or locator to the actual location of the NCLOB data (so it is not "in line" with the other column values of the row). </P
><P
CLASS="para"
>A NCLOB variable contains a locator, which then points to the large block of single-byte character data. NCLOBs can be up to four gigabytes in size, and they participate fully in transactions. In other words, any changes you make to a NCLOB (via the DBMS_LOB built-in package) can be rolled back or committed along with other outstanding changes in your transaction. NCLOB locators cannot, however, span transactions or sessions. </P
><P
CLASS="para"
>Variable-width character sets are not supported in NCLOBs.</P
><P
CLASS="para"
>Here is an example of a declaration of a NCLOB variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   war_and_peace_in japanese NCLOB;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.7.5"
>4.2.7.5 LOBs and LONGs</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3674"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3677"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3680"
></A
>LOB types are different from, and preferable to, LONG and LONG RAW. The maximum size of a LONG is two gigabytes, whereas the maximum size of a LOB is four gigabytes. </P
><P
CLASS="para"
>Oracle offers a powerful new built-in package, DBMS_LOB, to help you manipulate the contents of LOBs in ways not possible with LONGs. Generally, Oracle offers you random access to LOB contents, whereas with LONGs you have only sequential access. For example, with DBMS_LOB you can perform SUBSTR and INSTR operations against a LOB. This is not possible with LONG data. </P
><P
CLASS="para"
>Oracle recommends that you no longer use LONG or LONG RAW in your applications and instead take advantage of the new and improved features of the LOB datatypes. If you are going to be working with object types, you really don't have much choice: a LOB (except for NCLOB) can be an attribute of an object type, but LONGs cannot. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.7.6"
>4.2.7.6 Working with LOBs</A
></H4
><P
CLASS="para"
>LOB values are not stored "in line" with other row data. Instead, a LOB locator, which points to the LOB, is stored in the row. Suppose that I have created the following table: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE favorite_books
   (isbn VARCHAR2(50), title VARCHAR2(100), contents_loc CLOB);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I can then display the number of characters in the book, The Bell Curve, with the following code: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE howbig (title_in IN VARCHAR2)
IS
   CURSOR book_cur
   IS
      SELECT contents_loc
        FROM favorite_books
       WHERE title = UPPER (title_in);
   book_loc CLOB;
BEGIN
   OPEN book_cur;
   FETCH book_cur INTO book_loc;
   IF book_cur%NOTFOUND
   THEN
      DBMS_OUTPUT.PUT_LINE
         ('Remember? You don''t like &quot;' || INITCAP (title_in) || '&quot;.');
   ELSE
      DBMS_OUTPUT.PUT_LINE (title_in || ' contains ' ||
          TO_CHAR (DBMS_LOB.GETLENGTH (book_loc)) ||
          ' characters.');
   END IF;
   CLOSE book_cur;
END;
/

SQL&gt; exec howbig ('the bell curve');
Remember? You don't like &quot;The Bell Curve&quot;.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is an example of copying a BLOB from one row to another in SQL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO favorite_books (isbn, title, contents_loc)
   SELECT isbn, title || ', Second Edition', contents_loc
     FROM favorite_books
    WHERE title = 'Oracle PL/SQL Programming';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this situation, I have assigned a new LOB locator for my second edition. I have also copied the LOB value (the contents of my first edition) to this new row, not merely created another locator or pointer back to the same text. </P
><P
CLASS="para"
>Notice that I copied the entire contents of my book. DML operations such as INSERT and UPDATE always affect an entire LOB. If you want to change or delete just a portion of a LOB, you need to call the appropriate functions in the DBMS_LOB package. </P
><P
CLASS="para"
>You cannot directly copy values between a character LOB and a VARCHAR2 variable, even if the LOB value is small and "fits" inside the specified VARCHAR2 variable. You can, however, use functions in the DBMS_LOB package to extract some or all of a CLOB value and place it in a VARCHAR2 variable (as the following example shows): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   big_kahuna CLOB;
   little_kahuna VARCHAR2(2000);
BEGIN
   /* I know it's in here. */
   SELECT contents_loc INTO big_kahuna
     FROM favorite_books
    WHERE title = 'WAR AND PEACE';

   /* Get first 2000 characters of book. */
   little_kahuna := DBMS_LOB.SUBSTR (big_kahuna, 2000, 1);
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.7.7"
>4.2.7.7 Working with BFILEs</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-998656-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-998656-2"
></A
>BFILEs are very different from internal LOBs in a number of ways: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The value of a BFILE is stored in an operating system file, not within the database at all. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>BFILEs do not participate in transactions (i.e., changes to a BFILE cannot be rolled back or committed). </P
></LI
></UL
><P
CLASS="para"
>When you work with BFILEs in PL/SQL, you still do work with a LOB locator. In the case of a BFILE, however, the locator simply points to the file stored on the server. For this reason, two different rows in a database table can have a BFILE column which point to the <EM
CLASS="emphasis"
>same</EM
> file. </P
><P
CLASS="para"
>A BFILE locator is composed of a directory alias and a file name. You use the <A
CLASS="indexterm"
NAME="AUTOID-3713"
></A
> BFILENAME function (see <A
CLASS="xref"
HREF="ch13_01.htm"
>Chapter 13, <CITE
CLASS="chapter"
>Numeric, LOB, and Miscellaneous Functions</CITE
></A
>) to return a locator based on those two pieces of information. </P
><P
CLASS="para"
>In the following block, I declare a BFILE variable and assign it a locator for a file named <I
CLASS="filename"
>family.ipg</I
> located in the photos "directory": </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   all_of_us BFILE;
BEGIN
   all_of_us := BFILENAME ('photos', 'family.ipg');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>But what precisely is "photos"? It doesn't conform to the format used for directories in UNIX, Windows NT, etc. It is, in fact, a database object called a DIRECTORY. Here is the statement I would use to create a directory: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="AUTOID-3721"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-3723"
></A
>
CREATE DIRECTORY photos AS 'c:\photos';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You will need the CREATE DIRECTORY or CREATE ANY DIRECTORY privileges to create a directory. To be able to reference this directory you must be granted the READ privilege, as in: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>GRANT READ ON DIRECTORY photos TO SCOTT;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>For more information on directory aliases, see <A
CLASS="xref"
HREF="ch13_02.htm#SQL2-CH-13-SECT-2.0.1"
>Section 13.2.1, "The BFILENAME function"</A
> in <A
CLASS="xref"
HREF="ch13_01.htm"
>Chapter 13</A>. 
 </P
><P
CLASS="para"
>The maximum number of BFILEs that can be opened within a session is established by the database initialization parameter, SESSION_MAX_OPEN_FILES. This parameter defines an upper limit on the number of files opened simultaneously in a session (not just BFILEs, but all kinds of files, including those opened using the UTL_FILE package).<A
CLASS="indexterm"
NAME="AUTOID-3732"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3733"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3734"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3735"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3736"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3737"
></A
> </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.8"
>4.2.8 Conversion Between Datatypes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-59982-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-59982-2"
></A
>Both SQL and PL/SQL offer many different types of data. In many situations&nbsp;-- more frequently than you perhaps might like to admit&nbsp;-- you will find it necessary to convert your data from one datatype to another. </P
><P
CLASS="para"
>You might have one table which stores primary key information as a character string, and another table which stores that same key as a foreign key in numeric format. When you perform an assignment, you will need to convert the information: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:employee.department_num   -- the numeric format
   := :department.depno    -- the character format</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You might wish to view a rowid value, in which case it is necessary to convert that value to character (hex) format, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ROWIDTOCHAR (:employee.rowid);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Or you might perform date comparisons by specifying dates as literals, as in the following: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF start_date BETWEEN '01-JAN-95' AND last_sales_date THEN ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Whenever PL/SQL performs an operation involving one or more values, it must first convert the data so that it is in the right format for the operation. There are two kinds of conversion: explicit and implicit. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.8.1"
>4.2.8.1 Explicit data conversions</A
></H4
><P
CLASS="para"
>An <A
CLASS="indexterm"
NAME="AUTOID-3757"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-998664-2"
></A
>explicit conversion takes place when you use a built-in conversion function to force the conversion of a value from one datatype to another. In the earlier example which demonstrated viewing a rowid value, I used the ROWIDTOCHAR conversion function so that the PUT_LINE function could display the resulting character string. PL/SQL provides a full set of conversion functions to enable conversion from one datatype to another. (These functions are explored more fully in <A
CLASS="xref"
HREF="ch14_01.htm"
>Chapter 14</A
>.) </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.8.2"
>4.2.8.2 Implicit data conversions</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-26212-1"
></A
>Whenever PL/SQL detects that a conversion is necessary, it will attempt to change the values as necessary to perform the operation. You would probably be surprised to learn how often PL/SQL is performing conversions on your behalf. <A
CLASS="xref"
HREF="ch04_02.htm#SQL2-CH-4-SECT-2.7.7"
>Figure 4.1</A
> shows what kinds of implicit conversions PL/SQL can perform. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-4-FIG-1"
>Figure 4.1: Implicit conversions performed by PL/SQL</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.0401.gif"
ALT="Figure 4.1"><P
CLASS="para"
>With implicit conversions you can specify literal values in place of data with the correct internal format, and PL/SQL will convert that literal as necessary. In the example below, PL/SQL converts the literal string "125" to the numeric value 125 in the process of assigning a value to the numeric variable: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   a_number NUMBER;
BEGIN
   a_number := '125';
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can also pass parameters of one datatype into a module and then have PL/SQL convert that data into another format for use inside the program. In the following procedure, the first parameter is a date. When I call that procedure, I pass a string value in the form DD-MON-YY, and PL/SQL converts that string automatically to a date: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE change_hiredate
   (emp_id_in IN INTEGER, hiredate_in IN DATE)

change_hiredate (1004, '12-DEC-94');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As shown in <A
CLASS="xref"
HREF="ch04_02.htm#SQL2-CH-4-SECT-2.7.7"
>Figure 4.1</A
>, conversions are limited; PL/SQL cannot convert any datatype to any other datatype. Furthermore, some implicit conversions raise exceptions. Consider the following assignment: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   a_number NUMBER;
BEGIN
   a_number := 'abc';
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>PL/SQL cannot convert "abc" to a number and so will raise the VALUE_ERROR exception when it executes this code. It is up to you to make sure that if PL/SQL is going to perform implicit conversions, it is given values it can convert without error. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-2.8.3"
>4.2.8.3 Drawbacks of implicit conversions</A
></H4
><P
CLASS="para"
>There are several drawbacks to implicit conversion:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Each implicit conversion PL/SQL performs represents a loss, however small, in the control you have over your program. You do not expressly perform or direct the performance of that conversion; you make an assumption that the conversion will take place, and that it will have the intended effect. There is always a danger in making this assumption: If Oracle changes the way and circumstances under which it performs conversions; your code could then be affected. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The implicit conversion that PL/SQL performs depends on the context in which the code occurs. As a result, a conversion might occur in one program and not in another even though they seem to be the same. The conversion PL/SQL performs is not necessarily always the one you might expect. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Implicit conversions can actually degrade <A
CLASS="indexterm"
NAME="AUTOID-3790"
></A
>performance. A dependence on implicit conversions can result in excessive conversions taking place, or in the conversion of a column value in a SQL statement instead of in a constant. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3795"
></A
>Your code is easier to read and understand if you explicitly convert data where needed. Such conversions document variances in datatypes between tables or between code and tables. By removing an assumption and a hidden action from your code, you remove a potential misunderstanding as well. </P
></LI
></UL
><P
CLASS="para"
>As a consequence, I recommend that you avoid allowing either the SQL or PL/SQL languages to perform implicit conversions on your behalf. Whenever possible, use a conversion function to guarantee that the right kind of conversion takes place.<A
CLASS="indexterm"
NAME="AUTOID-3799"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3800"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3801"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3802"
></A
> </P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_01.htm"
TITLE="4.1 Identifiers"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.1 Identifiers"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_03.htm#SQL2-CH-4-SECT-3.3"
TITLE="4.3 NULLs in PL/SQL"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.3 NULLs in PL/SQL"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.1 Identifiers</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.3 NULLs in PL/SQL</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
