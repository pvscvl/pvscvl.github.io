<HTML
><HEAD
><TITLE
>[Chapter 8] 8.3 Types of Exceptions</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:57:53Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch08_01.htm"
TITLE="8. Exception Handlers"><LINK
REL="prev"
HREF="ch08_02.htm"
TITLE="8.2 The Exception Section"><LINK
REL="next"
HREF="ch08_04.htm#SQL2-CH-8-SECT-4.1.3"
TITLE="8.4 Determining Exception-Handling Behavior"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.2 The Exception Section"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.2 The Exception Section"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch08_01.htm"
TITLE="8. Exception Handlers"
>Chapter 8<BR>Exception Handlers</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_04.htm#SQL2-CH-8-SECT-4.1.3"
TITLE="8.4 Determining Exception-Handling Behavior"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.4 Determining Exception-Handling Behavior"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-8-SECT-3"
>8.3 Types of Exceptions</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-998443-1"
></A
>There are four kinds of exceptions in PL/SQL: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Named system exceptions.</EM
> Exceptions that have been given names by PL/SQL and raised as a result of an error in PL/SQL or RDBMS processing. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Named programmer-defined exceptions.</EM
> Exceptions that are raised as a result of errors in your application code. You give these exceptions names by declaring them in the declaration section. You then raise the exceptions explicitly in the program. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Unnamed system exceptions.</EM
> Exceptions that are raised as a result of an error in PL/SQL or RDBMS processing but have not been given names by PL/SQL. Only the most common errors are so named; the rest have numbers and can be assigned names with the special PRAGMA EXCEPTION_INIT syntax. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Unnamed programmer-defined exceptions.</EM
> Exceptions that are defined and raised in the server by the programmer. In this case, the programmer provides both an error number (between -20000 and -20999) and an error message, and raises that exception with a call to RAISE_APPLICATION_ERROR. That error, along with its message, is propagated back to the client-side application. </P
></LI
></UL
><P
CLASS="para"
>The system exceptions (both named and unnamed) are raised by PL/SQL whenever a program violates a rule in the RDBMS (such as "duplicate value in index") or causes a resource limit to be exceeded (such as "maximum open cursors exceeded"). Each of these RDBMS errors has a number associated with it. In addition, PL/SQL predefines names for some of the most commonly encountered errors. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-8-SECT-3.1"
>8.3.1 Named System Exceptions </A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-963152-1"
></A
> <A
CLASS="indexterm"
NAME="ch08-idx-963152-2"
></A
> <A
CLASS="indexterm"
NAME="ch08-idx-963152-3"
></A
> <A
CLASS="indexterm"
NAME="ch08-idx-963152-4"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7246"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7249"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7251"
></A
> The exceptions which are already given names by PL/SQL are declared in the STANDARD package in PL/SQL. You do not have to declare them in your own programs.[<A
CLASS="footnote"
HREF="#AUTOID-7255"
>1</A
>] <A
CLASS="indexterm"
NAME="AUTOID-7257"
></A
>Each of the predefined exceptions is listed in <A
CLASS="xref"
HREF="ch08_03.htm#SQL2-CH-8-SECT-3.2"
>Table 8.1</A
> along with its Oracle error number, the value returned by a call to SQLCODE, and a brief description. SQLCODE is a PL/SQL built-in function that returns the status code of the last-executed statement. SQLCODE returns zero if the last statement executed without errors. In most, but not all, cases, the SQLCODE value is the same as the Oracle error code. </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-7255"
>[1]</A
> If you do so, in fact, you will have declared your own local exception. It will not be raised when the internal error with that name occurs. Avoid declaring an exception with the same name as a predefined exception.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Here is an example of how you might use the exceptions table. Suppose that your program generates an unhandled exception for error ORA-6511. Looking up this error, you find that it is associated with the CURSOR_ALREADY_OPEN exception. Locate the PL/SQL block in which the error occurs and add an exception handler for CURSOR_ALREADY_OPEN, as shown below: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN CURSOR_ALREADY_OPEN
   THEN
      CLOSE my_cursor;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Of course, you would be even better off analyzing your code to determine proactively which of the predefined exceptions might occur. Then you could decide which of those exceptions you want to handle specifically, which should be covered by the WHEN OTHERS clause, and which would best be left unhandled. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-8-TABLE-4"
>Table 8.1: Predefined Exceptions in PL/SQL </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Oracle Error/SQLCODE</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7278"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7281"
></A
>CURSOR_ALREADY_OPEN </P
>  <P
CLASS="para"
>ORA-6511 SQLCODE= -6511</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>You tried to OPEN a cursor that was already OPEN. You must CLOSE a cursor before you try to OPEN or re-OPEN it. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7289"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7292"
></A
> DUP_VAL_ON_INDEX </P
>  <P
CLASS="para"
>ORA-00001 SQLCODE= -1</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Your INSERT or UPDATE statement attempted to store duplicate values in a column or columns in a row which is restricted by a unique index. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7300"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7303"
></A
> INVALID_CURSOR </P
>  <P
CLASS="para"
>ORA-01001 SQLCODE= -1001</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>You made reference to a cursor that did not exist. This usually happens when you try to FETCH from a cursor or CLOSE a cursor before that cursor is OPENed. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7311"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7314"
></A
> INVALID_NUMBER </P
>  <P
CLASS="para"
>ORA-01722 SQLCODE = -1722</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>PL/SQL executes a SQL statement that cannot convert a character string successfully to a number. This exception is different from the VALUE_ERROR exception, as it is raised only from within a SQL statement. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7322"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7325"
></A
> LOGIN_DENIED </P
>  <P
CLASS="para"
>ORA-01017 SQLCODE= -1017</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Your program tried to log onto the Oracle RDBMS with an invalid username-password combination. This exception is usually encountered when you embed PL/SQL in a 3GL language. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7333"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7336"
></A
> NO_DATA_FOUND </P
>  <P
CLASS="para"
>ORA-01403 SQLCODE= +100</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>This exception is raised in three different scenarios: (1) You executed a SELECT INTO statement (implicit cursor) that returned no rows. (2) You referenced an uninitialized row in a local PL/SQL table. (3) You read past end of file with UTL_FILE package. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7344"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7347"
></A
> NOT_LOGGED_ON </P
>  <P
CLASS="para"
>ORA-01012 SQLCODE= -1012</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Your program tried to execute a call to the database (usually with a DML statement) before it had logged into the Oracle RDBMS. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7355"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7358"
></A
> PROGRAM_ERROR </P
>  <P
CLASS="para"
>ORA-06501 SQLCODE= -6501</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>PL/SQL encounters an internal problem. The message text usually also tells you to "Contact Oracle Support." </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7366"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7369"
></A
> STORAGE_ERRORORA-06500 SQLCODE= -6500 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Your program ran out of memory or memory was in some way corrupted. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7376"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7379"
></A
>TIMEOUT_ON_RESOURCEORA-00051 SQLCODE= -51 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>A timeout occurred in the RDBMS while waiting for a resource.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7386"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7389"
></A
> TOO_MANY_ROWSORA-01422 SQLCODE= -1422 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>A SELECT INTO statement returned more than one row. A SELECT INTO can return only one row; if your SQL statement returns more than one row you should place the SELECT statement in an explicit CURSOR declaration and FETCH from that cursor one row at a time. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7396"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7399"
></A
>TRANSACTION_BACKED_OUTORA-00061 SQLCODE= -61 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>The remote part of a transaction is rolled back, either with an explicit ROLLBACK command or as the result of some other action. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7406"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7409"
></A
> VALUE_ERRORORA-06502 SQLCODE= -6502 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>PL/SQL raises the VALUE_ERROR whenever it encounters an error having to do with the conversion, truncation, or invalid constraining of numeric and character data. This is a very general and common exception. If this same type of error is encountered in a SQL DML statement within a PL/SQL block, then the INVALID_NUMBER exception is raised. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7416"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7419"
></A
> ZERO_DIVIDEORA-01476 SQLCODE= -1476 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Your program tried to divide by zero.<A
CLASS="indexterm"
NAME="AUTOID-7423"
></A
> </P
> </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-8-SECT-3.2"
>8.3.2 Named Programmer-Defined Exceptions</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7427"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7430"
></A
> The exceptions that PL/SQL has declared in the STANDARD package cover internal or system-generated errors. Many of the problems a user will encounter (or cause) in an application, however, are specific to that application. Your program might need to trap and handle errors such as "negative balance in account" or "call date cannot be in the past." While different in nature from "division by zero," these errors are still exceptions to normal processing and should be handled gracefully by your program. </P
><P
CLASS="para"
>One of the most useful aspects of the PL/SQL exception handling model is that it does not make any structural distinction between internal errors and application-specific errors. Once an exception is raised, it can and should be handled in the exception section, regardless of the type or source of error. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7435"
></A
>Of course, to handle an exception, you must have a name for that exception. Because PL/SQL cannot name these exceptions for you (they are specific to your application), you must do so yourself by declaring an exception in the declaration section of your PL/SQL block. You declare an exception by listing the name of the exception you want to raise in your program, followed by the keyword EXCEPTION, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>exception_name EXCEPTION;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following declaration section of the calc_annual_sales contains three programmer-defined exception declarations: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE calc_annual_sales
   (company_id_in IN company.company_id%TYPE)
IS
   invalid_company_id   EXCEPTION;
   no_sales_for_company EXCEPTION;
   negative_balance     EXCEPTION;

   duplicate_company    BOOLEAN;
BEGIN
   ... body of executable statements ...
EXCEPTION
   WHEN invalid_company_id
   THEN
      ...
   WHEN no_sales_for_company
   THEN
      ...
   WHEN negative_balance
   THEN
      ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The names for exceptions are similar in format to (and "read" just like) Boolean variable names, but can be referenced in only two ways: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In a RAISE statement in the execution section of the program (to raise the exception), as in: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>RAISE no_sales_for_company;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In the WHEN clauses of the exception section (to handle the raised exception), as in: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHEN no_sales_for_company THEN</PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-8-SECT-3.3"
>8.3.3 Unnamed System Exceptions</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7451"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7452"
></A
> What do you do when you want to trap an internal error raised by PL/SQL or the SQL engine, but it is not one of the lucky errors that have been given a predefined name? Although this error is identified only by its internal error number, exception handlers need a name by which they can check for a match. Sure, you can always use the WHEN OTHERS clause to simply catch any exceptions not previously handled. (This is covered in detail in <A
CLASS="xref"
HREF="ch08_06.htm"
>Section 8.6.3, "Using SQLCODE and SQLERRM in WHEN OTHERS Clause"</A
>.) In many cases, however, you will want to trap specific errors in a way that clearly documents and highlights them in your code. To do this, you assign your own name to the Oracle or PL/SQL error that might be raised in your program, and then write a specific exception handler for that custom-named exception. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-8-SECT-3.3.1"
>8.3.3.1 The EXCEPTION_INIT pragma</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7457"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7460"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7462"
></A
>You can use a compiler construct called a pragma to associate a name with an internal error code. A pragma (introduced in <A
CLASS="xref"
HREF="ch02_01.htm"
>Chapter 2, <CITE
CLASS="chapter"
>PL/SQL Language Fundamentals</CITE
></A
>) is a special instruction to the compiler that is processed at compile time instead of at runtime. A pragma called EXCEPTION_INIT instructs the compiler to associate or initialize a programmer-defined exception with a specific Oracle error number. With a name for that error, you can then raise this exception and write a handler which will trap that error. While in most cases you will leave it to Oracle to raise these system exceptions, you could also raise them yourself. </P
><P
CLASS="para"
>The pragma EXCEPTION_INIT must appear in the declaration section of a block, after the declaration of the exception name used in the pragma, as shown below: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   exception_name EXCEPTION;
   PRAGMA EXCEPTION_INIT (exception_name, error_code_literal);
BEGIN</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where exception_name is the name of an exception and error_code_literal is the number of the Oracle error (including the minus sign, if the error code is negative, as is almost always the case). </P
><P
CLASS="para"
>In the following program code, I declare and associate an exception for this error: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-2292 violated integrity constraining (OWNER.CONSTRAINT) -
         child record found. </PRE
></BLOCKQUOTE
><P
CLASS="para"
>This error occurs if I try to delete a parent record while there are child records still in that table. <A
CLASS="indexterm"
NAME="AUTOID-7472"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7475"
></A
>A child record is a record with a foreign key reference to the parent table: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE delete_company (company_id_in IN NUMBER)
IS
   /* Declare the exception. */
   still_have_employees EXCEPTION;

   /* Associate the exception name with an error number. */
   PRAGMA EXCEPTION_INIT (still_have_employees, -2292);
BEGIN
   /* Try to delete the company. */
   DELETE FROM company
    WHERE company_id = company_id_in;
EXCEPTION
   /* If child records were found, this exception is raised! */
   WHEN still_have_employees
   THEN
      DBMS_OUTPUT.PUT_LINE
         (' Please delete employees for company first.');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you use EXCEPTION_INIT, you must supply a literal number for the second argument of the pragma call. By explicitly naming this system exception, the purpose of the exception handler is self-evident. </P
><P
CLASS="para"
>The EXCEPTION_INIT pragma improves the readability of your programs by assigning names to otherwise obscure error numbers. You can employ the EXCEPTION_INIT pragma more than once in your program. You can even assign more than one exception name to the same error number. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-8-SECT-3.4"
>8.3.4 Unnamed Programmer-Defined Exceptions </A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7484"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-7487"
></A
> The final type of exception is the unnamed, yet programmer-defined exception. This kind of exception occurs when you need to raise an application-specific error from within the server and communicate this error back to the client application process. This scenario is more common than you might at first imagine. For example, even when you run all your Oracle software in a single hardware environment (such as a character-based SQL*Forms applications running on UNIX against an Oracle server on the same UNIX platform), you still have a separation between your client (SQL*Forms screen) and your server (the RDBMS). </P
><P
CLASS="para"
>You will trap some, perhaps most, application-specific errors on the client side. On the other hand, the Oracle7 architecture allows you to embed many of your business rules directly into your database structure, using database triggers, constraints, and stored procedures. In many cases, you will want to let the RDBMS trap and reject invalid database actions. To do this, you need a way to identify application-specific errors and return information about those error back to the client. This kind of error communication is illustrated in <A
CLASS="xref"
HREF="ch08_03.htm#SQL2-CH-8-SECT-3.2"
>Figure 8.2</A
>. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-8-FIG-2"
>Figure 8.2: Error communication from server to client</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.0802.gif"
ALT="Figure 8.2"><P
CLASS="para"
>I have called this type of exception "unnamed" and "programmer-defined." The programmer-defined aspect should be clear: because the error is application-specific, you cannot expect PL/SQL to have already defined it for you. The reason this type of exception is also unnamed is that you cannot name or declare an exception within a server-based program or database trigger and have the client-side tool handle that named exception. This identifier simply doesn't cross the great divide between client and server. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7497"
></A
>To get around this problem, Oracle provides a special procedure to allow communication of an unnamed, yet programmer-defined, server-side exception: RAISE_APPLICATION_ERROR. (The use of this procedure and exception type is discussed in <A
CLASS="xref"
HREF="ch08_07.htm"
>Section 8.7, "Client-Server Error Communication"</A
> later in this chapter.) The specification for this procedure is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE RAISE_APPLICATION_ERROR
   (error_number_in IN NUMBER, error_msg_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where error_number_in is the error number you have assigned to this error. The error_msg_in argument is the message that will be sent back with the error code to the client program.<A
CLASS="indexterm"
NAME="AUTOID-7502"
></A
> </P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.2 The Exception Section"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.2 The Exception Section"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_04.htm#SQL2-CH-8-SECT-4.1.3"
TITLE="8.4 Determining Exception-Handling Behavior"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.4 Determining Exception-Handling Behavior"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.2 The Exception Section</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.4 Determining Exception-Handling Behavior</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
