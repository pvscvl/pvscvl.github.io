<HTML
><HEAD
><TITLE
>[Chapter 1] 1.6 A Few of My Favorite (PL/SQL) Things</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:49:57Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Introduction to PL/SQL"><LINK
REL="prev"
HREF="ch01_05.htm"
TITLE="1.5 Advice for Oracle Programmers"><LINK
REL="next"
HREF="ch01_07.htm#SQL2-CH-1-SECT-7.5"
TITLE="1.7 Best Practices for PL/SQL Excellence"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_05.htm"
TITLE="1.5 Advice for Oracle Programmers"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.5 Advice for Oracle Programmers"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Introduction to PL/SQL"
>Chapter 1<BR>Introduction to PL/SQL</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_07.htm#SQL2-CH-1-SECT-7.5"
TITLE="1.7 Best Practices for PL/SQL Excellence"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.7 Best Practices for PL/SQL Excellence"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6"
>1.6 A Few of My Favorite (PL/SQL) Things</A
></H2
><P
CLASS="para"
>PL/SQL is a powerful, many-featured product. This is a lengthy book. I have gone to great lengths to make all the information within the covers highly accessible. Still, I thought it would be helpful to offer a quick review of some of my favorite aspects of the PL/SQL language. </P
><P
CLASS="para"
>It's all wonderful, of course, and I wouldn't trade PL/SQL for any other programming language in the world. Yet certain features and techniques have stood out for me as ways to improve the efficiency of my code and the productivity of my development effort. </P
><P
CLASS="para"
>The topics in the following sections offer just enough information to give you a sense of what is possible. Go to the appropriate chapter for detailed information. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6.0.1"
>1.6.1 Anchored declarations</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1227"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-1229"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-1232"
></A
> You can use the %TYPE and %ROWTYPE declaration attributes to anchor the datatype of one variable to that of a previously existing variable or data structure. The anchoring data structure can be a column in a database table, the entire table itself, a programmer-defined record, or a local PL/SQL variable. In the following example, I declare a local variable with the same structure as the company name: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>my_company company.name%TYPE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch04_01.htm"
>Chapter 4</A
> for details.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6.0.2"
>1.6.2 Built-in functions</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1241"
></A
> PL/SQL offers dozens of built-in functions to help you get your job done with the minimum amount of code and fuss possible. Some of them are straightforward, such as the LENGTH function, which returns the length of the specified string. Others offer subtle variations which will aid you greatly&nbsp;-- but only when you are aware of those variations. </P
><P
CLASS="para"
>Two of my favorites in this category of hidden talents are SUBSTR and INSTR, both character functions. SUBSTR returns a subportion of a string. INSTR returns the position in a string where a substring is found. Most developers only use these functions to search forward through the strings. By passing a negative starting location, however, SUBSTR will count from the end of the string. And INSTR will actually scan in reverse through the string for the nth occurrence of a substring. </P
><P
CLASS="para"
>See the chapters in <A
CLASS="xref"
HREF="part03.htm"
>Part 3</A
> for details.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6.0.3"
>1.6.3 Built-in packages</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1250"
></A
> In addition to the many built-in functions provided by PL/SQL, Oracle Corporation also offers many built-in packages. These packages of functions, procedures, and data structures greatly expand the scope of the PL/SQL language. With each new release of the Oracle Server, we get new packages to improve our own programs. </P
><P
CLASS="para"
>It is no longer sufficient for a developer to become familiar simply with the basic PL/SQL functions like TO_CHAR, ROUND, and so on. Those functions have now become only the innermost layer of useful functionality. Oracle Corporation has built upon those functions, and you should do the same thing. </P
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="appc_01.htm"
>Appendix C</A
> for a summary of the Application Programming Interfaces (APIs) of the built-in packages. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6.0.4"
>1.6.4 The cursor FOR loop</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1259"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-1262"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1265"
></A
>The cursor FOR loop is one of my favorite PL/SQL constructs. It leverages fully the tight and effective integration of the Ada-like programming language with the power of the SQL database language. It reduces the volume of code you need to write to fetch data from a cursor. It greatly lessens the chance of introducing loop errors in your programming&nbsp;-- and loops are one of the more error-prone parts of a program. Does this loop sound too good to be true? Well, it isn't&nbsp;-- it's all true! </P
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch07_01.htm"
>Chapter 7, <CITE
CLASS="chapter"
>Loops</CITE
></A
>, for more information.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6.0.5"
>1.6.5 Scoping with nested blocks</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1273"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-1277"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-1280"
></A
>The general advantage of&nbsp;-- and motivation for&nbsp;-- a nested block is that you create a scope for all the declared objects and executable statements in that block. You can use this scope to improve your control over activity in your program, particularly in the area of exception handling. </P
><P
CLASS="para"
>In the following procedure, I have placed BEGIN and END keywords around a sequence of DELETE statements. This way, if any DELETE statement fails, I trap the exception, ignore the problem, and move on to the next DELETE: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE delete_details
IS
BEGIN
   BEGIN
      DELETE FROM child1 WHERE ...;
   EXCEPTION
      WHEN OTHERS THEN NULL;
   END;

   BEGIN
      DELETE FROM child2 WHERE ...;
   EXCEPTION
      WHEN OTHERS THEN NULL;
   END;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I can in this way use my nested blocks to allow my PL/SQL program to continue past exceptions. </P
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch15_01.htm"
>Chapter 15, <CITE
CLASS="chapter"
>Procedures and Functions</CITE
></A
>, for details.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6.0.6"
>1.6.6 Module overloading</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1290"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-1293"
></A
>Within a package and within the declaration section of a PL/SQL block, you can define more than one module with the same name! The name is, in other words, overloaded. In the following example, I have overloaded the value_ok function in the body of the check package: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE BODY check
IS
   /* First version takes a DATE parameter. */
   FUNCTION value_ok (date_in IN DATE) RETURN BOOLEAN
   IS
   BEGIN
      RETURN date_in &lt;= SYSDATE;
   END;

   /* Second version takes a NUMBER parameter. */
   FUNCTION value_ok (number_in IN NUMBER) RETURN BOOLEAN
   IS
   BEGIN
      RETURN number_in &gt; 0;
   END;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Overloading can greatly simplify your life and the lives of other developers. This technique consolidates the call interfaces for many similar programs into a single module name. It transfers the burden of knowledge from the developer to the software. You do not have to try to remember, for example, the six different names for programs which all add values (dates, strings, Booleans, numbers, etc.) to various PL/SQL tables. </P
><P
CLASS="para"
>Instead, you simply tell the compiler that you want to "add" and pass it the value you want added. PL/SQL and your overloaded programs figure out what you want to do and they do it for you. </P
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch15_01.htm"
>Chapter 15</A
> for details.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6.0.7"
>1.6.7 Local modules</A
></H3
><P
CLASS="para"
>A local module is a procedure or function defined in the declaration section of a PL/SQL block (anonymous or named). This module is considered local because it is only defined within the parent PL/SQL block. It cannot be called by any other PL/SQL blocks defined outside of that enclosing block. </P
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch15_01.htm"
>Chapter 15</A
> for details.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-1-SECT-6.0.8"
>1.6.8 Packages</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1308"
></A
>A package is a collection of related elements, including modules, variables, table and record TYPEs, cursors, and exceptions. Packages are among the least understood and most underutilized features of PL/SQL. That is a shame, because the package structure is also one of the most useful constructs for building well-designed PL/SQL-based applications. Packages provide a structure in which you can organize your modules and other PL/SQL elements. They encourage proper programming techniques in an environment that often befuddles the implementation of good design. </P
><P
CLASS="para"
>With packages, you can:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Create abstract datatypes and employ object-oriented design principles in your Oracle-based applications. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use top-down design techniques comprehensively. You can build package specifications devoid of any code and actually compile programs that call the modules in these "stub" packages. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Create and manipulate data that persist throughout a database session. You can use variables that are declared in a package to create global data structures. </P
></LI
></UL
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch16_01.htm"
>Chapter 16, <CITE
CLASS="chapter"
>Packages</CITE
></A
>, for details. The disk that accompanies this book contains many examples of packages. The frontend software gives you an easy-to-use interface to the code and explanations for using it. </P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_05.htm"
TITLE="1.5 Advice for Oracle Programmers"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.5 Advice for Oracle Programmers"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_07.htm#SQL2-CH-1-SECT-7.5"
TITLE="1.7 Best Practices for PL/SQL Excellence"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.7 Best Practices for PL/SQL Excellence"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.5 Advice for Oracle Programmers</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.7 Best Practices for PL/SQL Excellence</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
