<HTML
><HEAD
><TITLE
>[Chapter 4] 4.5 Anchored Declarations</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:55:17Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. Variables and Program Data"><LINK
REL="prev"
HREF="ch04_04.htm#SQL2-CH-4-SECT-4.3"
TITLE="4.4 Variable Declarations"><LINK
REL="next"
HREF="ch04_06.htm#SQL2-CH-4-SECT-6.1"
TITLE="4.6 Programmer-Defined Subtypes"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_04.htm#SQL2-CH-4-SECT-4.3"
TITLE="4.4 Variable Declarations"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.4 Variable Declarations"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. Variables and Program Data"
>Chapter 4<BR>Variables and Program Data</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_06.htm#SQL2-CH-4-SECT-6.1"
TITLE="4.6 Programmer-Defined Subtypes"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.6 Programmer-Defined Subtypes"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-5"
>4.5 Anchored Declarations</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-26076-1"
></A
> <A
CLASS="indexterm"
NAME="ch04-idx-26076-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-26076-3"
></A
> <A
CLASS="indexterm"
NAME="ch04-idx-26076-4"
></A
>This section describes the use of the %TYPE declaration attribute to anchor the datatype of one variable to another data structure, such as a PL/SQL variable or a column in a table. When you anchor a datatype, you tell PL/SQL to set the datatype of one variable from the datatype of another element. </P
><P
CLASS="para"
>The syntax for an anchored datatype is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;variable name&gt; &lt;type attribute&gt;%TYPE [optional default value assignment];</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where &lt;variable name&gt; is the name of the variable you are declaring and &lt;type attribute&gt; is any of the following: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Previously declared PL/SQL variable name</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Table column in format "table.column"</P
></LI
></UL
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch04_05.htm"
>Figure 4.2</A
> shows how the datatype is drawn both from a database table and PL/SQL variable. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-4-FIG-2"
>Figure 4.2: Anchored declarations with %TYPE</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.0402.gif"
ALT="Figure 4.2"><P
CLASS="para"
>Here are some examples of %TYPE used in declarations:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Anchor the datatype of monthly_sales to the datatype of total_sales:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>total_sales NUMBER (20,2);
monthly_sales total_sales%TYPE;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Anchor the datatype of the company ID variable to the database column:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>company_id# company.company_id%TYPE;</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>Anchored declarations provide an excellent illustration of the fact that PL/SQL is not just a procedural-style programming language but was designed specifically as an extension to the Oracle SQL language. A very thorough effort was made by Oracle Corporation to tightly integrate the programming constructs of PL/SQL to the underlying database (accessed through SQL). </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> PL/SQL also offers the %ROWTYPE declaration attribute, which allows you to create anchored datatypes for PL/SQL record structures. %ROWTYPE is described in <A
CLASS="xref"
HREF="ch09_01.htm"
>Chapter 9</A
>. </P
></BLOCKQUOTE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-5.1"
>4.5.1 Benefits of Anchored Declarations</A
></H3
><P
CLASS="para"
>All the declarations you have so far seen&nbsp;-- character, numeric, date, Boolean&nbsp;-- specify explicitly the type of data for that variable. In each of these cases, the declaration contains a direct reference to a datatype and, in most cases, a constraint on that datatype. You can think of this as a kind of hardcoding in your program. While this approach to declarations is certainly valid, it can cause problems in the following situations: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Synchronization with database columns.</EM
> The PL/SQL variable "represents" database information in the program. If I declare explicitly and then change the structure of the underlying table, my program may not work properly. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Normalization of local variables.</EM
> The PL/SQL variable stores calculated values used throughout the application. What are the consequences of repeating (hardcoding) the same datatype and constraint for each declaration in all of my programs? </P
></LI
></UL
><P
CLASS="para"
>Let's take a look at each of these scenarios in more detail.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-5.1.1"
>4.5.1.1 Synchronization with database columns</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4033"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4036"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4039"
></A
>Databases hold information that needs to be stored and manipulated. Both SQL and PL/SQL perform these manipulations. Your PL/SQL programs often read data from a database into local program variables, and then write information from those variables back into the database. </P
><P
CLASS="para"
>Suppose I have a company table with a column called NAME and a datatype of VARCHAR2(60). I can therefore create a local variable to hold this data as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   cname VARCHAR2(60);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and then use this variable to represent this database information in my program. Now, consider an application which uses the company entity. There may be a dozen different screens, procedures, and reports which contain this same PL/SQL declaration, VARCHAR2(60), over and over again. And everything works just fine...until the business requirements change or the DBA has a change of heart. With a very small effort, the definition of the name column in the company table changes to VARCHAR2(100), in order to accommodate longer company names. Suddenly the database can store names which will raise VALUE_ERROR exceptions when FETCHed into the company_name variable. </P
><P
CLASS="para"
>My programs have become incompatible with the underlying data structures. All declarations of cname (and all the variations programmers employed for this data throughout the system) must be modified. Otherwise, my application is simply a ticking time bomb, just waiting to fail. My variable, which is a local representation of database information, is no longer synchronized with that database column. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-5.1.2"
>4.5.1.2 Normalization of local variables</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4048"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4050"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4053"
></A
>Another drawback to explicit declarations arises when working with PL/SQL variables which store and manipulate calculated values not found in the database. Suppose my programmers built an application to manage my company's finances. I am very bottom-line oriented, so many different programs make use of a total_revenue variable, declared as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>total_revenue NUMBER (10,2); </PRE
></BLOCKQUOTE
><P
CLASS="para"
>Yes, I like to track my total revenue down to the last penny. Now, in 1992, when specifications for the application were first written, the maximum total revenue I ever thought I could possibly obtain from any single customer was $99 million, so we used the NUMBER (10,2) declaration, which seemed like plenty. Then in 1995, my proposal to convert B-2 bombers to emergency transport systems to deliver Midwestern wheat to famine regions was accepted: a $2 billion contract! I was just about ready to pop the corks on the champagne when my lead programmer told me the bad news: I wouldn't be able to generate reports on this newest project and customer: those darn total_revenue variables were too small! </P
><P
CLASS="para"
>What a bummer...I had to fire the guy. </P
><P
CLASS="para"
>Just kidding. Instead, we quickly searched out any and all instances of the revenue variables so that we could change the declarations. This was a time-consuming job because we had spread equivalent declarations throughout the entire application. I had, in effect, denormalized my local data structures, with the usual consequences on maintenance. If only I had a way to define each of local total revenue variables in relation to a single datatype. </P
><P
CLASS="para"
>If only they had used %TYPE!</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-5.2"
>4.5.2 Anchoring at Compile Time</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4063"
></A
>The %TYPE declaration attribute anchors the datatype of one variable to that of another data structure at the time a PL/SQL block is compiled. If a change is made to the "source" datatype, then any program which contains a declaration anchored to this datatype must be recompiled before it will be able to use this new state of the datatype. </P
><P
CLASS="para"
>The consequences of this rule differ for PL/SQL modules stored in the database and those defined in client-side tools, such as Oracle Forms. </P
><P
CLASS="para"
>Consider the following declaration of company_name in the procedure display_company: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE display_company (company_id_in IN INTEGER)
IS
   company_name company.name%TYPE;
BEGIN
   ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When PL/SQL compiles this module, it looks up the structure of the company table in the data dictionary, finds the column NAME, and obtains its datatype. It then uses this data dictionary-based datatype to define the new variable. </P
><P
CLASS="para"
>What, then, is the impact on the compiled display_company procedure if the datatype for the name column of the company table changes? There are two possibilities: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If display_company is a stored procedure, then the compiled code will be marked as "invalid." The next time a program tries to run display_company, it will be recompiled automatically before it is used. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If display_company is a client-side procedure, then the Oracle Server cannot mark the program as invalid. The compiled client source code remains compiled using the old datatype. The next time you execute this module, it could cause a VALUE_ERROR exception to be raised. </P
></LI
></UL
><P
CLASS="para"
>Whether stored or in client-side code, you should make sure that all affected modules are recompiled after data structure changes. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-5.3"
>4.5.3 Nesting Usages of the %TYPE Attribute</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4080"
></A
>You can nest usages of %TYPE in your declarations as well: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   /* The &quot;base&quot; variable */
   unlimited_revenue NUMBER;

   /* Anchored to unlimited revenue */
   total_revenue unlimited_revenue%TYPE;

   /* Anchored to total revenue */
   total_rev_94    total_revenue%TYPE;
   total_rev_95    total_revenue%TYPE;
BEGIN</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this case total_revenue is based on unlimited_revenue and both variables for 1994 and 1995 are based on the total_revenue variable. There is no practical limit on the number of layers of nested usages of %TYPE. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-5.4"
>4.5.4 Anchoring to Variables in Other PL/SQL Blocks</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4088"
></A
>The declaration of the source variable for your %TYPE declarations does not need to be in the same declaration section as the variables which use it. That variable must simply be visible in that section. The variable could be a global PL/SQL variable (defined in a package) or be defined in an PL/SQL block which contains the current block, as in the following example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE calc_revenue
IS
   unlimited_revenue NUMBER;
   total_revenue unlimited_revenue%TYPE;
BEGIN
   IF TO_CHAR (SYSDATE, 'YYYY') = '1994'
   THEN
      DECLARE
         total_rev_94    total_revenue%TYPE;
      BEGIN
         ...
      END;
   END IF;
END calc_revenue;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-4-SECT-5.5"
>4.5.5 Anchoring to NOT NULL Datatypes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4095"
></A
>When you declare a variable, you can also specify the need for the variable to be NOT NULL This NOT NULL declaration constraint is transferred to variables declared with the %TYPE attribute. If I include a NOT NULL in my declaration of a source variable (one that is referenced afterwards in a %TYPE declaration), I must also make sure to specify a default value for the variables which make use of that source variable. Suppose I declare max_available_date NOT NULL in the following example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   max_available_date DATE NOT NULL :=
            LAST_DAY (ADD_MONTHS (SYSDATE, 3));
   last_ship_date max_available_date%TYPE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The declaration of last_ship_date will then fail to compile, with the following message: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>a variable declared NOT NULL must have an initialization assignment.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you use a NOT NULL variable in a %TYPE declaration, the new variable must have a default value provided. The same is not true, however, for variables declared with %TYPE where the source is a database column. </P
><P
CLASS="para"
>The NOT NULL column constraint does not apply to variables declared with the %TYPE attribute. The following code will compile successfully: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   -- Company name is a NOT NULL column in the company table.
   comp_name company.name%TYPE;
BEGIN
   comp_name := NULL;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You will be able to declare the comp_name variable without specifying a default, and you will be able to NULL out the contents of that variable.<A
CLASS="indexterm"
NAME="AUTOID-4105"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4106"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4107"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4108"
></A
> </P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_04.htm#SQL2-CH-4-SECT-4.3"
TITLE="4.4 Variable Declarations"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.4 Variable Declarations"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_06.htm#SQL2-CH-4-SECT-6.1"
TITLE="4.6 Programmer-Defined Subtypes"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.6 Programmer-Defined Subtypes"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.4 Variable Declarations</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.6 Programmer-Defined Subtypes</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
