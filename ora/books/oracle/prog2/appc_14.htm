<HTML
><HEAD
><TITLE
>[Appendix C] C.14 DBMS_SQL</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:14:39Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="appc_01.htm"
TITLE="C. Built-In Packages"><LINK
REL="prev"
HREF="appc_13.htm#appc-92-fm2xml"
TITLE="C.13 DBMS_SNAPSHOT"><LINK
REL="next"
HREF="appc_15.htm#appc-127-fm2xml"
TITLE="C.15 DBMS_TRANSACTION"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appc_13.htm#appc-92-fm2xml"
TITLE="C.13 DBMS_SNAPSHOT"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: C.13 DBMS_SNAPSHOT"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="appendix"
REL="up"
HREF="appc_01.htm"
TITLE="C. Built-In Packages"
>Appendix C<BR>Built-In Packages</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appc_15.htm#appc-127-fm2xml"
TITLE="C.15 DBMS_TRANSACTION"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: C.15 DBMS_TRANSACTION"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14"
>C.14 DBMS_SQL</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="appc-idx-854933-1"
></A
><A
CLASS="indexterm"
NAME="appc-idx-854933-2"
></A
> <A
CLASS="indexterm"
NAME="appc-idx-854933-3"
></A
> DBMS_SQL package offers access to dynamic SQL from within PL/SQL. "Dynamic SQL" means SQL statements are not prewritten into your programs; instead, they are constructed at run time as character strings and then passed to the SQL engine for execution. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.1"
>C.14.1 The BIND_ARRAY procedure</A
></H3
><P
CLASS="para"
>With PL/SQL8 you can perform bulk selects, inserts, updates and deletes to improve the performance of your application. You accomplish these by associating one or more index-by tables with columns in your cursor. The BIND_ARRAY procedure performs this step for you with this interface: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.BIND_ARRAY (c IN INTEGER,
   name IN VARCHAR2,
   &lt;table_variable&gt; IN &lt;datatype&gt;,
  [,index1 IN INTEGER,
   ,index2 IN INTEGER)]);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The &lt;table_variable&gt; &lt;datatype&gt; pairing may be any of the following: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;number_table&gt; DBMS_SQL.NUMBER_TABLE
&lt;varchar2_table&gt; DBMS_SQL.VARCHAR2_TABLE
&lt;date_table&gt; DBMS_SQL.DATE_TABLE
&lt;blob_table&gt; DBMS_SQL.BLOB_TABLE
&lt;clob_table&gt; DBMS_SQL.CLOB_TABLE
&lt;bfile_table&gt; DBMS_SQL.BFILE_TABLE</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.2"
>C.14.2 The BIND_VARIABLE procedure </A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24782"
></A
> BIND_VARIABLE procedure lets you bind a specific value to a host variable which was placed in the SQL statement as a placeholder. Whenever you include a reference to a bind or host variable in the SQL statement that you pass to the PARSE procedure, you must issue a call to BIND_VARIABLE in order to bind or attach a value to that variable. The overloaded specification for this procedure supports multiple datatypes, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.BIND_VARIABLE
   (c IN INTEGER,
    name IN VARCHAR2,
    value IN &lt;datatype&gt;);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The &lt;datatype&gt; may be any of the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
MLSLABEL /* Trusted Oracle only */
NUMBER
VARCHAR2 CHARACTER SET ANY_CS </PRE
></BLOCKQUOTE
><P
CLASS="para"
>The dbms_sql package also offers more specific variants of bind_variable for less common datatypes: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.BIND_VARIABLE
   (c IN INTEGER,
    name IN VARCHAR2,
    value IN VARCHAR2 CHARACTER SET ANY_CS,
    [,out_value_size IN INTEGER]);

PROCEDURE DBMS_SQL.BIND_VARIABLE_CHAR
   (c IN INTEGER,
    name IN VARCHAR2,
    value IN CHAR CHARACTER SET ANY_CS,
    [,out_value_size IN INTEGER]);

PROCEDURE DBMS_SQL.BIND_VARIABLE_RAW
   (c IN INTEGER,
    name IN VARCHAR2,
    value IN RAW,
    [,out_value_size IN INTEGER]);

PROCEDURE DBMS_SQL.BIND_VARIABLE_ROWID
   (c IN INTEGER,
    name IN VARCHAR2,
    value IN ROWID;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.3"
>C.14.3 The CLOSE_CURSOR procedure</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24792"
></A
> CLOSE_CURSOR procedure closes the specified cursor and sets the cursor handle to NULL. It releases all memory associated with the cursor. The specification for the procedure is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.CLOSE_CURSOR (c IN OUT INTEGER);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.4"
>C.14.4 The COLUMN_VALUE procedure</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24798"
></A
> COLUMN_VALUE procedure retrieves a value from the cursor into a local variable. Use this procedure when the SQL statement is a query and you are fetching rows with EXECUTE_AND_FETCH or FETCH_ROWS. You call COLUMN_VALUE after a row has been fetched to transfer the value from the SELECT list of the cursor into a local variable. For each call to COLUMN_VALUE, you should have made a call to DEFINE_COLUMN in order to define that column in the cursor. </P
><P
CLASS="para"
>The overloaded specification is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.COLUMN_VALUE
   (c IN INTEGER,
    position IN INTEGER,
    value OUT DATE,
    [, column_error OUT NUMBER]
    [, actual_length OUT INTEGER ]);

PROCEDURE DBMS_SQL.COLUMN_VALUE
   (c IN INTEGER,
    position IN INTEGER,
    value OUT NUMBER,
    [, column_error OUT NUMBER]
    [, actual_length OUT INTEGER ]);

PROCEDURE DBMS_SQL.COLUMN_VALUE
   (c IN INTEGER,
    position IN INTEGER,
    value OUT VARCHAR2,
    [, column_error OUT NUMBER]
    [, actual_length OUT INTEGER ]);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The DBMS_SQL package also offers more specific variants of COLUMN_VALUE for less common datatypes: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.COLUMN_VALUE
   (c IN INTEGER,
    position IN INTEGER,
    value OUT MLSLABEL,
    [, column_error OUT NUMBER]
    [, actual_length OUT INTEGER ]);

PROCEDURE DBMS_SQL.COLUMN_VALUE
   (c IN INTEGER,
    position IN INTEGER,
    value OUT CHAR,
    [, column_error OUT NUMBER]
    [, actual_length OUT INTEGER ]);

PROCEDURE DBMS_SQL.COLUMN_VALUE
   (c IN INTEGER,
    position IN INTEGER,
    value OUT RAW,
    [, column_error OUT NUMBER]
    [, actual_length OUT INTEGER ]);

PROCEDURE DBMS_SQL.COLUMN_VALUE
   (c IN INTEGER,
    position IN INTEGER,
    value OUT ROWID,
    [, column_error OUT NUMBER]
    [, actual_length OUT INTEGER ]);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-102-fm2xml"
>C.14.5 The <A
CLASS="indexterm"
NAME="AUTOID-24806"
></A
> DEFINE_COLUMN procedure</A
></H3
><P
CLASS="para"
>When you call DBMS_SQL.PARSE to process a SELECT statement, you want to pass values from the database into local variables. To do this you must associate the columns or expressions in the SELECT list with those local variables. You do this with the DEFINE_COLUMN procedure, whose overloaded specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.DEFINE_COLUMN
   (c IN INTEGER,
    position IN INTEGER,
    column IN DATE);

PROCEDURE DBMS_SQL.DEFINE_COLUMN
   (c IN INTEGER,
    position IN INTEGER,
    column IN NUMBER);

PROCEDURE DBMS_SQL.DEFINE_COLUMN
   (c IN INTEGER,
    position IN INTEGER,
    column IN VARCHAR2,
    column_size IN INTEGER);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.6"
>C.14.6 The EXECUTE function</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24813"
></A
>EXECUTE function executes the SQL statement associated with the specified cursor. It returns the number of rows processed by the SQL statement if that statement is an UPDATE, INSERT, or DELETE. If the SQL statement is not an UPDATE, INSERT, or DELETE, ignore the value returned by EXECUTE. If the SQL statement is a query, you can now call the FETCH_ROWS function to fetch rows which are retrieved by that query. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.EXECUTE (c IN INTEGER) RETURN INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.7"
>C.14.7 The EXECUTE_AND_FETCH function</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24819"
></A
>EXECUTE_AND_FETCH function executes the SELECT statement associated with the specified cursor and immediately fetches the rows associated with the query. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.EXECUTE_AND_FETCH
   (c IN INTEGER,
    exact_match IN BOOLEAN DEFAULT FALSE)
RETURN INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.8"
>C.14.8 The FETCH_ROWS function</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24826"
></A
> FETCH_ROW function corresponds to the FETCH statement for regular PL/SQL cursors. It fetches the next row from the cursor. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.FETCH_ROWS (c IN INTEGER) RETURN INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.9"
>C.14.9 The IS_OPEN function</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24832"
></A
> IS_OPEN function returns TRUE if the specified cursor is already open, FALSE otherwise. This function corresponds to the %ISOPEN attribute for regular PL/SQL cursors. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.IS_OPEN (c IN INTEGER) RETURN BOOLEAN;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.10"
>C.14.10 The LAST_ERROR_POSITION function</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24838"
></A
>LAST_ERROR_POSITION function returns the byte offset in the SQL statement where the ERROR occurred. Call this function immediately after a call to EXECUTE or EXECUTE_AND_FETCH in order to obtain meaningful results. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.LAST_ERROR_POSTITION RETURN INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.11"
>C.14.11 The LAST_ROW_COUNT function</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24844"
></A
> LAST_ROW_COUNT function returns the total number of rows fetched at that point. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.LAST_ROW_COUNT RETURN INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.12"
>C.14.12 The LAST_ROW_ID function</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24850"
></A
> LAST_ROW_ID function returns the rowid of the row fetched most recently. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.LAST_ROW_ID RETURN ROWID;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.13"
>C.14.13 The LAST_SQL_FUNCTION_CODE function</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24856"
></A
>LAST_SQL_FUNCTION_CODE function returns the SQL function code for the SQL statement. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.LAST_SQL_FUNCTION_CODE RETURN INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appc-111-fm2xml"
>C.14.14 The <A
CLASS="indexterm"
NAME="AUTOID-24861"
></A
> OPEN_CURSOR function</A
></H3
><P
CLASS="para"
>Use this function to open a cursor, which means that the Oracle Server will set aside memory for a cursor data area and return a pointer to that area. The specification is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.OPEN_CURSOR RETURN INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.15"
>C.14.15 The PARSE procedure</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24868"
></A
>PARSE procedure immediately parses the statement specified. The specification for this procedure is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.PARSE
   (cursor_handle IN INTEGER,
    SQL_statement IN VARCHAR2,
    language_flag IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>PL/SQL8 offers a second, overloaded version of DBMS_SQL.PARSE, which comes in handy when you have very large SQL statements. If your SQL statement exceeds the largest possible contiguous allocation on your system (and it is machine-dependent) or 32K bytes (the maximum size for VARCHAR2), use this version of the PARSE procedure: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.PARSE
   (cursor_handle IN INTEGER,
    SQL_statement IN DBMS_SQL.VARCHAR2S,
    lb IN INTEGER,
    ub IN INTEGER,
    lfflg IN BOOLEAN,
    language_flag IN INTEGER);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-AP-C-SECT-14.0.16"
>C.14.16 The VARIABLE_VALUE procedure</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="AUTOID-24876"
></A
>VARIABLE_VALUE procedure lets you retrieve the value of a named variable from the specified PL/SQL block. The overloaded specification for this procedure supports three datatypes, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.VARIABLE_VALUE
   (cursor_handle IN INTEGER,
    variable_name IN VARCHAR2,
    value OUT NUMBER);

PROCEDURE DBMS_SQL.VARIABLE_VALUE
   (cursor_handle IN INTEGER,
    variable_name IN VARCHAR2,
    value OUT DATE);

PROCEDURE DBMS_SQL.VARIABLE_VALUE
   (cursor_handle IN INTEGER, 
    variable_name IN VARCHAR2, 
    value OUT VARCHAR2);<A
CLASS="indexterm"
NAME="AUTOID-24879"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-24880"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-24881"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appc_13.htm#appc-92-fm2xml"
TITLE="C.13 DBMS_SNAPSHOT"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: C.13 DBMS_SNAPSHOT"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appc_15.htm#appc-127-fm2xml"
TITLE="C.15 DBMS_TRANSACTION"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: C.15 DBMS_TRANSACTION"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>C.13 DBMS_SNAPSHOT</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>C.15 DBMS_TRANSACTION</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
