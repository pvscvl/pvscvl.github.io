<HTML
><HEAD
><TITLE
>[Chapter 13] 13.3 Miscellaneous Function Descriptions</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:01:37Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch13_01.htm"
TITLE="13. Numeric, LOB, and Miscellaneous Functions"><LINK
REL="prev"
HREF="ch13_02.htm#SQL2-CH-13-SECT-2.0.1"
TITLE="13.2 LOB Function Descriptions"><LINK
REL="next"
HREF="ch14_01.htm"
TITLE="14. Conversion Functions"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch13_02.htm#SQL2-CH-13-SECT-2.0.1"
TITLE="13.2 LOB Function Descriptions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 13.2 LOB Function Descriptions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch13_01.htm"
TITLE="13. Numeric, LOB, and Miscellaneous Functions"
>Chapter 13<BR>Numeric, LOB, and Miscellaneous Functions</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch14_01.htm"
TITLE="14. Conversion Functions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 14. Conversion Functions"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3"
>13.3 Miscellaneous Function Descriptions</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-82860-1"
></A
> The following sections briefly describe the miscellaneous PL/SQL functions; these are functions that do not fall naturally into particular datatype categories. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.1"
>13.3.1 The DUMP function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-11870"
></A
>The DUMP function "dumps," or returns, the internal representation of the input expression. DUMP is an overloaded function, as is shown by its specification: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DUMP (expr_in DATE
    [, return_format_in BINARY_INTEGER
    [, start_position_in BINARY_INTEGER
    [, length_in BINARY_INTEGER
   )
RETURN VARCHAR2

FUNCTION DUMP (expr_in NUMBER
    [, return_format_in BINARY_INTEGER
    [, start_position_in BINARY_INTEGER
    [, length_in BINARY_INTEGER
   )
RETURN VARCHAR2

FUNCTION DUMP (expr_in VARCHAR2
    [, return_format_in BINARY_INTEGER
    [, start_position_in BINARY_INTEGER
    [, length_in BINARY_INTEGER
   )
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where expr_in is the expression to be dumped, return_format_in is a numeric code specifying the format of the returned string, start_position_in is the starting position of the portion of the internal representation to be returned, and length_in is the length of the portion to be returned. The starting position and length arguments perform the same way as in the SUBSTR function described in <A
CLASS="xref"
HREF="ch11_01.htm"
>Chapter 11, <CITE
CLASS="chapter"
>Character Functions</CITE
></A
>. </P
><P
CLASS="para"
>Valid return format numbers are:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
> 8 Returns result in octal notation</TD
></TR
><TR
><TD
CLASS="member"
>10 Returns result in decimal notation</TD
></TR
><TR
><TD
CLASS="member"
>16 Returns result in hexadecimal notation</TD
></TR
><TR
><TD
CLASS="member"
>17 Returns result as individual characters</TD
></TR
></TABLE
><P
CLASS="para"
>The default for the return format is 10 (decimal), the default for the starting position is 1, and the default for length is the full length of the value. So, a fully default call to DUMP will return the full internal representation in decimal notation. </P
><P
CLASS="para"
>If expr_in IS NULL, then DUMP returns NULL. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.2"
>13.3.2 The GREATEST function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-11886"
></A
>The GREATEST function evaluates a list of values and returns the greatest value in that list. (The LEAST function, discussed below, returns the least value.) GREATEST accepts two or more arguments, and there is no upper limit on the number of values you can pass to GREATEST, which makes it especially useful. The specification for GREATEST is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION GREATEST (expr1, expr2 [, expr3 ...) RETURN DATE
FUNCTION GREATEST (expr1, expr2 [, expr3 ...) RETURN VARCHAR2
FUNCTION GREATEST (expr1, expr2 [, expr3 ...) RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The datatype of the return value of the GREATEST function is determined by the datatype of the first expression (expr1) in the list. In addition, PL/SQL must convert all the additional expressions in the list (expr2, expr3, and so on) to the same datatype as expr1, so they must all be compatible. </P
><P
CLASS="para"
>This example finds the greatest (most recent) of three dates: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>GREATEST (SYSDATE, :emp.hire_date, '13-JAN-1994') </PRE
></BLOCKQUOTE
><P
CLASS="para"
>My first expression is a call to the SYSDATE function. My second expression is an Oracle Forms item of type DATE. My third expression is a literal string. This string is converted to a date by PL/SQL with an internal call to TO_DATE. The comparison of the values then proceeds. </P
><P
CLASS="para"
>The next example finds the greatest (last in alphabetical order) of two strings: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>GREATEST (SUBSTR (text_chunk, INSTR (text_chunk, ';') + 1),
          last_command_entered)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first expression is comprised of nested calls first to SUBSTR and then to INSTR, to find that part of the text_chunk variables that comes after the first semicolon (<CODE
CLASS="literal"
>;</CODE
>). </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.3"
>13.3.3 The LEAST function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-11900"
></A
>The LEAST function, the opposite of the GREATEST function, evaluates a list of values and returns the least value in that list. LEAST accepts two or more arguments; there is no upper limit on the number of values you can pass to LEAST, which makes it especially useful. The specification for LEAST is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION LEAST (expr1, expr2 [, expr3 ...) RETURN DATE
FUNCTION LEAST (expr1, expr2 [, expr3 ...) RETURN VARCHAR2
FUNCTION LEAST (expr1, expr2 [, expr3 ...) RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The datatype of the return value of the LEAST function is determined by the datatype of the first expression (expr1) in the list. In addition, PL/SQL must convert all the additional expressions in the list (expr2, expr3, and so on) to the same datatype as expr1, so they must all be compatible. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.4"
>13.3.4 The NVL function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-122951-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-122951-2"
></A
>The NVL function offers a concise way to return or substitute a non-NULL value if the specified value is NULL. You can think of NVL as an abbreviation for "if Null VaLue, then return X." The NVL function is massively overloaded because any type of data can also have a NULL value. Here is the specification: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION NVL (string_in IN CHAR, replace_with_in IN CHAR)
   RETURN CHAR
FUNCTION NVL (string_in IN VARCHAR2, replace_with_in IN VARCHAR2)
   RETURN VARCHAR2
FUNCTION NVL (date_in IN DATE, replace_with_in IN DATE)
   RETURN DATE
FUNCTION NVL (date_in IN NUMBER, replace_with_in IN DATE)
   RETURN NUMBER
FUNCTION NVL (date_in IN CHAR, replace_with_in IN DATE)
   RETURN BOOLEAN</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that the CHAR version of NVL also returns a CHAR, or fixed-length, value. </P
><P
CLASS="para"
>For dates, if date_in is NOT NULL, then return date_in; otherwise, return replace_with_in. The NVL function in this case is therefore equivalent to the following IF statement: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF date_in IS NOT NULL
THEN
   RETURN date_in;
ELSE
   RETURN replace_with_in;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>NVL simply provides a much cleaner and more concise way of coding this functionality. And since it is a function, you can call it inline to provide substitution of NULL values where such a state of data would disrupt your program. For example, if you calculate the total compensation of an employee as salary plus compensation, then the expression: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>salary + commission</PRE
></BLOCKQUOTE
><P
CLASS="para"
>will be NULL when commission is NULL. With NVL, however, you can be sure that the calculated value will make sense: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>salary + NVL (commission, 0)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next two examples show some other ways to use the NVL function:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Check all IN parameters of a procedure and convert NULL values to in the default value setting of the declarations of local variable copies of the parameters: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE no_nulls_allowed (number1_in IN NUMBER, number2_in IN NUMBER)
IS
   local_number1 NUMBER := NVL (number1_in, 0);
   local_number2 NUMBER := NVL (number2_in, 0);
BEGIN
   ...
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>After fetching the employee information from the database, return the employee's commission as 0 whenever it is NULL. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR emp_cur IS
      SELECT first_name, last_name, salary, NVL (commission, 0)
         commission
      FROM employee
      WHERE employee_id = :emp.employee_id;
BEGIN
   ...
END;<A
CLASS="indexterm"
NAME="AUTOID-11928"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-11929"
></A
>
 </PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.5"
>13.3.5 The SQLCODE function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-122953-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-122953-2"
></A
>The SQLCODE function returns the number of the exception raised by PL/SQL. The specification for this function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION SQLCODE RETURN INTEGER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>SQLCODE returns values as follows:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If you reference SQLCODE outside of an exception section, it always returns 0, which means normal, successful completion. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you explicitly raise your own user-defined exception, then SQLCODE returns a value of +1. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If PL/SQL raises the NO_DATA_FOUND exception, then SQLCODE returns a value of +100. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In all other cases, SQLCODE returns a negative value. In other words, if you try to convert a date to a string with TO_CHAR and use the wrong format mask, you might encounter the following error message: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-01830: date format picture ends before converting entire input string</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this case, SQLCODE returns a value of -1830. </P
></LI
></UL
><P
CLASS="para"
>You will find SQLCODE and its sibling function, SQLERRM, most useful in the WHEN OTHERS exception handler. If an error is trapped by WHEN OTHERS, you do not know which exception was raised or which error was encountered. You can, however, use SQLCODE to find out, as shown in this example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      MESSAGE ('No match found for entry!');

   WHEN OTHERS
   THEN
      MESSAGE
         ('Error ' || TO_CHAR (SQLCODE) || ': ' ||
          SQLERRM);
END;<A
CLASS="indexterm"
NAME="AUTOID-11953"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-11954"
></A
>
 </PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.6"
>13.3.6 The SQLERRM function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-11958"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-11960"
></A
> The SQLERRM returns the error message associated with the specified code. The specification for this function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION SQLERRM (code_in IN INTEGER := SQLCODE) RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you do not provide an error code when you call SQLERRM, it uses the value returned by SQLCODE (see the preceding section). If SQLCODE returns 0, then SQLERRM returns the following message: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-0000; normal, successful completion</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If PL/SQL has raised an internal Oracle error or you pass a negative value to SQLERRM, then the function returns the error message provided by Oracle Corporation. If you pass (or allow SQLCODE to pass) a value of +100 to SQLERRM, it returns this message: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-01403: no data found</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Any other positive value passed to SQLERRM will result in this message: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>User-Defined Exception</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The maximum length of a message returned by SQLERRM is 512 bytes. This length includes the error code and all nested messages that may have been flagged by the compiler. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.7"
>13.3.7 The UID function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-11974"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-11976"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-122956-3"
></A
>The UID function returns an integer that uniquely identifies the current user. This integer is generated by the Oracle RDBMS when a user connects to the database. The specification for UID is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UID RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When called inline, the UID function looks like a variable since it has no arguments. Remember that when you call UID you will actually issue a SQL call to the RDBMS to extract the UID information for the user. Furthermore, in a distributed SQL statement, the UID always returns the value identifying the user on the local database. You cannot obtain the UID for connections to other, remote databases. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.8"
>13.3.8 The USER function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-122957-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-122957-2"
></A
>The USER function returns the name of the current account. The specification for USER is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION USER RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Like UID, when called inline, the USER function looks like a variable since it has no arguments. Remember that when you call USER you actually issue a SQL call to the RDBMS to extract the account name for the user. Furthermore, in a distributed SQL statement, the USER always returns the value identifying the user on the local database. You cannot obtain the USER for connections to other, remote databases. </P
><P
CLASS="para"
>The most common use for the USER function is to initialize an application session with configuration for a user. </P
><P
CLASS="para"
>Most of the applications I build have a system configuration table (with one row for each system or application) and a separate user configuration table (with one row for each user in each application). This user configuration table might have the following columns: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>RDBMS account name</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The name of the Oracle account, which matches the value returned by USER. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>User name</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The actual name of the user, as in: STEVEN FEUERSTEIN.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Business data</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Information about the user that relates to the business of the application, such as the user's department and default printer. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Preference data</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Information about the preferences of the user, such as "Display Toolbar" or "Automatically pop up a list of values boxes." </P
></DD
></DL
><P
CLASS="para"
>Assuming an Oracle Forms-based set of screens, each screen the user is able to enter from a Windows icon will contain a When-New-Form-Instance trigger. This trigger calls a procedure to transfer the information from the user configuration table to GLOBAL variables that are then available to all screens for the duration of the session. A sample initialization procedure follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE configure_user_globals
IS
   /*
   || I identify the row from the configuration table using the
   || USER function provided by PL/SQL.
   */
   CURSOR user_cur IS
      SELECT username, default_printer, toolbar_status, ... etc ...
        FROM user_configuration
       WHERE user_account_name = USER;
BEGIN

   OPEN user_cur;
   FETCH user_cur INTO
      :GLOBAL.username, :GLOBAL.default_printer ... etc ...;
   IF user_cur%NOTFOUND
   THEN
      CLOSE user_cur;
      MESSAGE (' You are not authorized to run this screen!');
      RAISE FORM_TRIGGER_FAILURE;
   ELSE
      CLOSE user_cur;
   END IF;

END configure_user_globals;<A
CLASS="indexterm"
NAME="AUTOID-12019"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-12020"
></A
></PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.9"
>13.3.9 The USERENV function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-12024"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12026"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12029"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12031"
></A
>The USERENV function returns information about the current user session or environment. The specification for USERENV is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION USERENV (info_type_in IN VARCHAR2) RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where info_type_in can be one of these values (specified in a named constant or a literal string in single quotes). The following list gives options and descriptions of what they return: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ENTRYID</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>An auditing entry identifier</P
></DD
><DT
CLASS="term"
>LANGUAGE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The language, territory, and character set used by your session. The value is returned in this format: language_territory.characterset </P
></DD
><DT
CLASS="term"
>SESSIONID</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>An auditing session identifier</P
></DD
><DT
CLASS="term"
>TERMINAL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The operating system identifier for your current session's terminal. The format of this information will clearly be dependent on your underlying operating system. </P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-13-SECT-3.0.10"
>13.3.10 The VSIZE function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-12055"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12057"
></A
>The VSIZE function returns the number of bytes used by the internal representation of the input expression. The specification for VSIZE is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION VSIZE (expr_in IN DATE) RETURN NUMBER
FUNCTION VSIZE (expr_in IN VARCHAR2) RETURN NUMBER
FUNCTION VSIZE (expr_in IN NUMBER) RETURN NUMBER
FUNCTION VSIZE (expr_in IN CHAR) RETURN NUMBER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the expression is NULL, then VSIZE returns NULL. </P
><P
CLASS="para"
>I am not sure when I would use this function in a program, but it comes in very handy when I get a call like this on the phone: "How many bytes does a date value take up in the database?" I could try to remember the answer (it sure seems like something I once knew). I could try to hunt down the answer in one of the many database administration manuals from Oracle, or I could execute the following SQL statement: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT VSIZE (hiredate) FROM emp WHERE ROWNUM=1

VSIZE(HIREDATE)
---------------
              7</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I included the WHERE clause for ROWNUM equal to 1 so that I would receive the answer (7 bytes) only once. Otherwise, I would have had the "opportunity" to learn that the VSIZE of hiredate is 7&nbsp;-- for every record in the emp table. </P
><P
CLASS="para"
>Interestingly, if you apply VSIZE to the SYSDATE function, you get a slightly different answer: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT VSIZE (SYSDATE) FROM dual;

VSIZE(SYSDATE)
--------------
             8 <A
CLASS="indexterm"
NAME="AUTOID-12067"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch13_02.htm#SQL2-CH-13-SECT-2.0.1"
TITLE="13.2 LOB Function Descriptions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 13.2 LOB Function Descriptions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch14_01.htm"
TITLE="14. Conversion Functions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 14. Conversion Functions"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>13.2 LOB Function Descriptions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>14. Conversion Functions</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
