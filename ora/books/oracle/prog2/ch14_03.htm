<HTML
><HEAD
><TITLE
>[Chapter 14] 14.3 Conversion Function Examples</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:01:59Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch14_01.htm"
TITLE="14. Conversion Functions"><LINK
REL="prev"
HREF="ch14_02.htm#SQL2-CH-14-SECT-2.0.1"
TITLE="14.2 Conversion Function Descriptions"><LINK
REL="next"
HREF="part04.htm"
TITLE="IV. Modular Code "></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch14_02.htm#SQL2-CH-14-SECT-2.0.1"
TITLE="14.2 Conversion Function Descriptions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 14.2 Conversion Function Descriptions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch14_01.htm"
TITLE="14. Conversion Functions"
>Chapter 14<BR>Conversion Functions</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part04.htm"
TITLE="IV. Modular Code "
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: IV. Modular Code "
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3"
>14.3 Conversion Function Examples</A
></H2
><P
CLASS="para"
>This section shows how you can use the conversion functions we've described in actual PL/SQL examples. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.1"
>14.3.1 FM: Suppressing Blanks and Zeros</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-12702"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12704"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12707"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-137942-4"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-137942-5"
></A
>PL/SQL offers the FM element as a modifier to a format mask. FM (fill mode) controls the suppression of padded blanks and leading zeros in values returned by the TO_CHAR function. </P
><P
CLASS="para"
>By default, the following format mask results in both padded blanks and leading zeros (there are five spaces between the month name and the day number): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (SYSDATE, 'Month DD, YYYY') ==&gt; 'April     05, 1994'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With the FM modifier at the beginning of the format mask, however, both the extra blank and the leading zeros disappear: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (SYSDATE, 'FMMonth DD, YYYY') ==&gt; April 5, 1994'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The modifier can be specified in upper-, lower-, or mixed-case; the effect is the same. </P
><P
CLASS="para"
>The FM modifier is a toggle, and can appear more than once in a format model. Each time it appears in the format, it changes the effect of the modifier. By default (that is, if FM is not specified anywhere in a format mask), blanks are not suppressed and leading zeros are included in the result value. So the first time that FM appears in the format it indicates that blanks and leading zeros are suppressed for any following elements. The second time that FM appears in the format, it indicates that blanks and leading zeros are not suppressed for any following elements, and so on. </P
><P
CLASS="para"
>In the following example I suppress the padded blank at the end of the month name, but preserve the leading zero on the day number with a second specification of FM: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (SYSDATE, 'fmMonth FMDD, YYYY') ==&gt; April 05, 1994'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you do not use FM in your mask, a converted date value is always right-padded with blanks to a fixed length (that length is dependent on the different format elements you use). When you do use FM, on the other hand, the length of your return value may vary depending on the actual values returned by the different format elements. </P
><P
CLASS="para"
>When you do not use FM to convert a number to a character string, the resulting value is always left-padded with blanks so that the number is right-justified to the length specified by the format (or declaration of the variable). When you do use FM, the left-padded blanks are suppressed and the resulting value is left-justified. </P
><P
CLASS="para"
>Here are some examples of the impact of FM on numbers converted with TO_CHAR: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_CHAR (8889.77, 'L9999D99')   ==&gt; '      $8889.77'
TO_CHAR (8889.77, 'fmL9999D99') ==&gt; '$8889.77'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The FM modifier can also be used in the format model of a call to the TO_DATE function to fill a string with blanks or zeros to match the format model. This variation of FM is explored in the discussion of FX.<A
CLASS="indexterm"
NAME="AUTOID-12728"
></A
> </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.2"
>14.3.2 FX: Matching Formats Exactly</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-137944-1"
></A
>PL/SQL offers the FX element as a modifier to a format mask. FX (format exact) specifies that an exact match must be performed for a character argument and date format mask in a call to the TO_DATE function. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-137945-1"
></A
>If FX is not specified, the TO_DATE function does not require that the character string match the format precisely. It makes the following allowances: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Extra blanks in the character string are ignored. Blanks are not significant data in any of the parts of a date value, except to delimit separate parts of the date and time: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_DATE ('Jan         15       1994', 'MON DD YYYY') ==&gt; 15-JAN-1994</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Numeric values, such as the day number or the year, do not have to include leading zeros to fill out the mask. As long as the numbers are in the right place in the string (as determined, usually, by the delimiter characters in the string), TO_DATE can convert the numeric values properly: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_DATE ('1-1-4', 'DD-MM-YYYY') ==&gt; 01-JAN-0004
TO_DATE ('7/16/94', 'MM/DD/YY') ==&gt; 14-JUL-1994</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Punctuation and literals in the string to be converted can simply match the length and position of punctuation and quoted text in the format. In the following example, my format mask specifies hyphen (<CODE
CLASS="literal"
>-</CODE
>) delimiters and the text "WhatIsaynotdo" between the day and the year. The string that I pass it, on the other hand, uses caret (<CODE
CLASS="literal"
>^</CODE
>) delimiters and "the year of" for the embedded text. Because both of the two literals inside quotes have the same number of characters, TO_DATE has no problem making the match. </P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_DATE ('JANUARY^1^ the year of 94', 'Month-dd-&quot;WhatIsaynotdo&quot;yy')
==&gt; 01-JAN-1994</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This kind of flexibility is great&nbsp;-- until you want to actually restrict a user or even a batch process from entering data in a nonstandard format. In some cases, it simply is not a reflection of everything being OK when a date string has a pound sign (<CODE
CLASS="literal"
>#</CODE
>) instead of a hyphen (<CODE
CLASS="literal"
>-</CODE
>) between the day and month numbers. For these situations, you can use the FX modifier to enforce an exact match between string and format model. </P
><P
CLASS="para"
>With FX, there is no flexibility for interpretation of the string. It cannot have extra blanks if none are found in the model. Its numeric values must include leading zeros if the format model specifies additional digits. And the punctuation and literals must exactly match the punctuation and quoted text of the format mask (except for case, which is always ignored). In all of the following examples, PL/SQL raises one of the following errors: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-01861: literal does not match format string
ORA-01862: wrong number of digits for this format item

TO_DATE ('Jan 15 1994', 'fxMON DD YYYY')
TO_DATE ('1-1-4', 'fxDD-MM-YYYY')
TO_DATE ('7/16/94', 'FXMM/DD/YY')
TO_DATE ('JANUARY^1^ the year of 94', 'FXMonth-dd-&quot;WhatIsaynotdo&quot;yy')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The FX modifier can be specified in upper-, lower-, or mixed-case; the effect is the same. </P
><P
CLASS="para"
>The FX modifier is a toggle, and can appear more than once in a format model. Each time it appears in the format, it changes the effect of the modifier. By default (that is, if FX is not specified anywhere in a format mask), an exact match is not required in any part of the string (as described above). So the first time that FX appears in the format it turns on exact matching for any following elements. The second time that FX appears in the format it indicates that an exact match is not required for any following elements, and so on. </P
><P
CLASS="para"
>In the following example I specify FX three times. As a result, an exact match is required for the day number and the year number, but not the month number: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_DATE ('07-1-1994', 'FXDD-FXMM-FXYYYY') ==&gt; 07-JUL-1994</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This next attempt at date conversion will raise ORA-01862 because the year number is not fully specified: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_DATE ('07-1-94', 'FXDD-FXMM-FXYYYY') -- Invalid string for format!</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You saw in the previous section how the FM modifier would strip leading blanks and zeros from the output of a call to TO_CHAR. You can also use FM in the format model of a call to the TO_DATE function to fill a string with blanks or zeros. This action matches the format model (the opposite of the suppression action). You can, in other words, use FM to guarantee that a format exact match required by FX will succeed. The following call to TO_DATE will return a date because the fm at the beginning of the format mask turns on fill mode for the entire string, thus changing the 1 to 01 and 94 to 1994: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TO_DATE ('07-1-94', 'FXfmDD-FXMM-FXYYYY')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can also include multiple references to both FM and FX in the same format string, to toggle both or either of these modifiers.<A
CLASS="indexterm"
NAME="AUTOID-12764"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12765"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12766"
></A
> </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.3"
>14.3.3 RR: Changing Millenia</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-137947-1"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-137947-2"
></A
> <A
CLASS="indexterm"
NAME="ch14-idx-137947-3"
></A
>We are coming up fast on the end of the 20th century. How many of your programs will still work when the clock ticks over midnight on December 31, 1999? Many of your Oracle-based applications should be well protected since you have been able to take advantage of a true date datatype. In other words, you haven't had to write any special programs to manually manipulate dates, thereby leaving yourself vulnerable. On the other hand, most everyone has been using a two-digit year in their date format masks, either inherited from the default DD-MON-YY or with common substitutes like MM/DD/YY. </P
><P
CLASS="para"
>The two-digit year format elements could give you problems when the century and millenium are close to changing. The YY format element always defaults to the current century. So when it is November 1999 and your user enters 1/1/1 or 1-JAN-1, they will enter into the database the date of January 1, 1901&nbsp;-- not January 1, 2001, as they might have been thinking. </P
><P
CLASS="para"
>What's an IS manager to do? One solution is to go into all your screens and change or add trigger logic so that if the user enters a year number less than ten (or whatever you decide the cutoff to be), then the next century will be assumed. That will work, but it surely must be a most undesirable prospect. </P
><P
CLASS="para"
>Fortunately, Oracle7 provides a new format element to take care of this problem: the RR format model. With RR you can enter dates from the 21st century before the year 2000 and you can enter dates from the 20th century after the year 2000 (like the birthdays of employees and customers). Here is how RR works: </P
><P
CLASS="para"
>If the current year is in the first half of the century (years through 49) then: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If you enter a date in the first half of the century, RR returns the current century. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>On the other hand, if you enter a date in the latter half of the century, RR returns the previous century. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the current year is in the latter half of the century (years 50 through 99) then: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If you enter a date in the first half of the century, RR returns the next century. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you enter a date in the latter half of the century, RR returns the current century. </P
></LI
></UL
></LI
></UL
><P
CLASS="para"
>Here are some examples of the impact of RR. Notice that the same year numbers are returned for Year 88 and Year 18, even though SYSDATE returns a current date in the 20th and 21st centuries, respectively: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT TO_CHAR (SYSDATE, 'MM/DD/YYYY') &quot;Current Date&quot;,
       TO_CHAR (TO_DATE ('14-OCT-88', 'DD-MON-RR'), 'YYYY') &quot;Year 88&quot;,
       TO_CHAR (TO_DATE ('14-OCT-18', 'DD-MON-RR'), 'YYYY') &quot;Year 18&quot;
  FROM dual;

Current Date  Year 88  Year 18
------------  -------  -------
  11/14/1994     1988     2018


SELECT TO_CHAR (SYSDATE, 'MM/DD/YYYY') &quot;Current Date&quot;,
       TO_CHAR (TO_DATE ('10/14/88', 'MM/DD/RR'), 'YYYY') &quot;Year 88&quot;,
       TO_CHAR (TO_DATE ('10/14/18', 'MM/DD/RR'), 'YYYY') &quot;Year 18&quot;
  FROM dual;

Current Date  Year 88  Year 18
------------  -------  -------
  11/14/2001     1988     2018</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Of course, if you use the RR format after the year 2000 and want to enter a date that falls in the latter half of the 21st century, you will need to add special logic. Masks with the RR format model will always convert such two-digit years into the previous century. </P
><P
CLASS="para"
>There are a number of ways you can activate the RR logic in your current applications. The cleanest and simplest way is to change the default format mask for dates in your database instance(s). You can do this by changing the NLS_DATE_FORMAT initialization parameter as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NLS_DATE_FORMAT = 'MM/DD/RR'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NLS_DATE_FORMAT = 'DD-MON-RR'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>depending on what the previous format was. Then, if you have not hardcoded the date format mask anywhere else in your screens or reports, you are done. Bring down and restart the database and then your application will allow users to enter dates in the 21st century. If you do have date format masks in the format property for an Oracle Forms item or in an Oracle Reports query or field, you will need to change those modules to reflect the new approach embodied by RR.<A
CLASS="indexterm"
NAME="AUTOID-12802"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12803"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-12804"
></A
> </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.4"
>14.3.4 Using TO_CHAR to Create a Date Range</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-137949-1"
></A
> <A
CLASS="indexterm"
NAME="ch14-idx-137949-2"
></A
>At times, users want information about activity on a specific date. In other situations, however, their interest lies in a range of dates. The user might enter the two dates and then expect to view all data that falls between them. </P
><P
CLASS="para"
>Suppose, for example, that in an Oracle Forms application the user enters 12/4/93 in the start date field and 4/8/96 in the end date field. The query that Oracle Forms executes against the database would need to have logic in it as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>hire_date BETWEEN '04-DEC-93' AND '08-APR-96'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or, more generally:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>hire_date BETWEEN :criteria.start_date AND :criteria.end_date</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where criteria is the name of the block containing the start_date and end_date fields. The colons (:) in front of the field names indicate to PL/SQL that these are bind variables from the host environment. </P
><P
CLASS="para"
>Sometimes this general logic can be passed directly to the SQL layer. In other situations, programmers must use the Pre-Query trigger or the SET_BLOCK_PROPERTY built-in to alter the SQL statement directly. In this case, they will need to create a string date range from the input dates. </P
><P
CLASS="para"
>Rather than write the application-specific code to handle this each time, you can build a generic utility, using TO_CHAR and TO_DATE conversion functions. </P
><P
CLASS="para"
>I offer below the date_range function. Its specification is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION date_range
   (start_date_in IN DATE,
    end_date_in IN DATE,
    check_time_in IN VARCHAR2 := 'NOTIME')
RETURN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The arguments to date_range are:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>start_date_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The starting date in the range. If NULL then use the min_start_date. If that is NULL, range has form `&lt;= end_date'. </P
></DD
><DT
CLASS="term"
>end_date_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The end date in the range. If NULL then use the max_end_date. If that is NULL, range has form `&gt;= start_date'. </P
></DD
><DT
CLASS="term"
>check_time_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Flag indicating whether or not to include the time component of the dates in the range check. If TIME then use the time component of the dates as part of the comparison. If NOTIME then strip off the time. </P
></DD
></DL
><P
CLASS="para"
>If the start date is NULL or the end date is NULL, the string returned by date_range uses the <KBD
CLASS="command"
>&lt;=</KBD
> and <KBD
CLASS="command"
>&gt;=</KBD
> operators rather than the BETWEEN operator. </P
><P
CLASS="para"
>Here are some examples of the output from date_range. Note that date_range places two contiguous quote marks around each date because these are actually string literals. At runtime these two quotes are resolved into a single quote by PL/SQL: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>date_range ('04-DEC-93', '08-APR-96')
==&gt;
   BETWEEN TO_DATE (''04-DEC-93'') AND TO_DATE (''08-APR-96'')

date_range ('04-DEC-93', NULL)
==&gt;
   &gt;= TO_DATE (''04-DEC-93'')

date_range (NULL, '04-DEC-93')
==&gt;
   &lt;= TO_DATE (''04-DEC-93'') </PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you do want to include the time component, then date_range will generate a string in this form: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>date_range ('04-DEC-93', '08-APR-96', 'time')
==&gt;
   BETWEEN TO_DATE (''04-DEC-93'', ''HHMMYYYY HHMISS'') AND
           TO_DATE (''08-APR-96'', ''HHMMYYYY HHMISS'')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Let's take a look at how you might use date_range in query processing in Oracle Forms. The Pre-Query trigger modifies the Default Where clause of a base table block. In Pre-Query, an assignment actually results in the addition of a WHERE clause in the SQL query for that block. Let's look at a simple example first. If Pre-Query contains a statement like this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:customer.contact_date := '12-JAN-95';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>then the query executed by the forms tool to fill the block contains a WHERE clause that looks like this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHERE &lt;other clauses&gt; AND (contact_date = '12-JAN-95')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So a simple assignment results in a straightforward comparison/restriction in the WHERE clause. You can also place complex SQL statements in the WHERE clause by appending a pound sign (<CODE
CLASS="literal"
>#</CODE
>) at the beginning of the assignment string. When the forms tools detect the <CODE
CLASS="literal"
>#</CODE
>, they know to substitute completely the equals sign (<CODE
CLASS="literal"
>=</CODE
>) comparison with the text following the symbol. So if you place a statement like this in Pre-Query: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:customer.customer_id :=
   '# IN (SELECT customer_id FROM invoice WHERE invoice_total &gt; ' ||
   TO_CHAR (:invoice.amount);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>then the query executed by the forms tool to fill the block contains a WHERE clause that looks like this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHERE &lt;other-where-clauses&gt; AND
      customer_id IN (SELECT customer_id
                         FROM invoice WHERE invoice_total &gt; 1000)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This very useful feature is documented in the <EM
CLASS="emphasis"
>Advanced Oracle Forms Techniques</EM
> manual from Oracle Corporation. The syntax of a <CODE
CLASS="literal"
>#</CODE
> assignment in Pre-Query for a date range would be like this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:employee.hire_date :=
   '# BETWEEN ' || TO_CHAR (:criteria.start_date) || ' AND ' ||
   TO_CHAR (:criteria.end_date);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If I were to place literal dates inside this string assignment, then I would need to put two single quotes together in the string wherever I needed one single quote to appear in the actual value placed in that field, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:employee.hire_date := '# BETWEEN ''01-JAN-93'' AND ''01-DEC-94''';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now if I apply the date_range function to this Pre-Query context, I have one of the following: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:customer.contact_date :=
   '# ' || date_range (:criteria.start_date, :criteria.end_date);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>:customer.contact_date :=
   '# ' || date_range (:criteria.start_date, :criteria.end_date, 'TIME');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the first call to date_range, I rely on the default value of the check_time_in parameter of NOTIME to ignore the time component of the dates. In the second call, I explicitly request that the time component be included. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-12867"
></A
>The SET_BLOCK_PROPERTY built-in in Oracle Forms offers another method of modifying the DEFAULT WHERE clause of a base table block. It allows you to directly pass a string of SQL syntax, which then replaces the DEFAULT WHERE clause specified at design time in the form. It is a much more structured approach than using the <KBD
CLASS="command"
>#</KBD
> syntax. In the following two calls to the built-in, I call date_range to generate a date range and attach that date range syntax to the contact_date column. In the second example I apply TRUNC to the contact date so that the time at which the contact_date was entered does not become a factor in the range check: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET_BLOCK_PROPERTY
   ('customer', DEFAULT_WHERE,
    'contact_date ' ||
    date_range (:criteria.start_date, :criteria.end_date, 'TIME'));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET_BLOCK_PROPERTY
   ('customer', DEFAULT_WHERE,
    'TRUNC (contact_date) ' ||
    date_range (:criteria.start_date, :criteria.end_date));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the code for the date_range function: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: daternge.sf */
FUNCTION date_range
   (start_date_in IN DATE,
    end_date_in IN DATE,
    check_time_in IN VARCHAR2 := 'NOTIME')
RETURN VARCHAR2
IS
   /* String versions of parameters to place in return value */
   start_date_int VARCHAR2(30);
   end_date_int VARCHAR2(30);

   /* Date mask for date&lt;-&gt;character conversions. */
   mask_int VARCHAR2(15) := 'MMDDYYYY';

   /* Version of date mask which fits right into date range string */
   mask_string VARCHAR2(30) := NULL;

   /* The return value for the function. */
   return_value VARCHAR2(1000) := NULL;
BEGIN
   /*
   || Finalize the date mask. If user wants to use time, add that to
   || the mask. Then set the string version by embedding the mask
   || in single quotes and with a trailing paranthesis.
   */
   IF UPPER (check_time_in) = 'TIME'
   THEN
      mask_int := mask_int || ' HHMISS';
   END IF;
   /*
   || Convert mask. Example:
   ||       If mask is: MMDDYYYY HHMISS
   ||       then mask string is: ', 'MMDDYYYY HHMISS')
   */
   mask_string := ''', ''' || mask_int || ''')';

   /* Now convert the dates to character strings using format mask */
   start_date_int := TO_CHAR (start_date_in, mask_int);
   end_date_int := TO_CHAR (end_date_in, mask_int);

   /* If both start and end are NULL, then return NULL. */
   IF start_date_int IS NULL AND end_date_int IS NULL
   THEN
      return_value := NULL;

   /* If no start point then return &quot;&lt;=&quot; format. */
   ELSIF start_date_int IS NULL
   THEN
      return_value := '&lt;= TO_DATE (''' || end_date_int || mask_string;

   /* If no end point then return &quot;&gt;=&quot; format. */
   ELSIF end_date_int IS NULL
   THEN
      return_value := '&gt;= TO_DATE (''' || start_date_int || mask_string;

   /* Have start and end. A true range, so just put it together. */
   ELSE
      return_value :=
        'BETWEEN TO_DATE (''' || start_date_int || mask_string ||
           ' AND TO_DATE (''' || end_date_int || mask_string;
   END IF;

   RETURN return_value;

END;<A
CLASS="indexterm"
NAME="AUTOID-12875"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-12876"
></A
></PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.5"
>14.3.5 Building a Date Manager</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-137952-1"
></A
>The Oracle Server offers the ability to set a default date format for each instance of a database with the NLS_DATE_FORMAT initialization parameter.[<A
CLASS="footnote"
HREF="#AUTOID-12882"
>2</A
>] Oracle provides a ruthlessly efficient gatekeeper for its RDBMS: there is no way you will ever be able to enter an invalid date into the database. And there are lots of functions that enable you to perform arithmetic on dates once they are in the database. There are, however, obstacles to entering dates efficiently: </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-12882"
>[2]</A
> This is a big improvement over earlier versions, in which the default date format was hardcoded to be DD-MON-YY. In the Oracle RDBMS Version 6, for example, if your company happened to use something else, you would have to make extensive use of the TO_DATE and TO_CHAR functions (and set the mask on all date fields in your forms applications, as well).</P
></DIV
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Oracle tools do not make it easy for users to enter dates. Oracle Forms, for example, insists that when a user enters a date, it must conform to a single date format mask&nbsp;-- either the system-wide default, or an override for that particular item. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Users cannot enter partial date information and have the rest defaulted by the system. Shouldn't users be able to enter a date in any manner they please? That same date mask demands that you enter every part of the date, even if it is always going to be in the current month or year. It seems to me that users should be able to enter the smallest number of characters needed to specify their date, and let the application figure out the rest. </P
></LI
></UL
><P
CLASS="para"
>It is possible with PL/SQL to build a "date manager" that satisfies the above moral imperatives for our users. The rest of this section explores the implementation of a function, dm_convert, which converts a string entered by the user into an actual Oracle date value. It liberates the user from having to know the default/enforced format in the Oracle7 database, because the input can conform to any of a wide variety of formats. The function determines which format applies, and returns the date. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.5.1"
>14.3.5.1 The dm_convert function date masks</A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch14_03.htm#SQL2-CH-14-SECT-3.1"
>Table 14.4</A
> shows the different date masks which dm_convert supports. The user can enter a string conforming to any of these masks and dm_convert will return a date value. It will not issue such errors as: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-01861 literal does not match format string
ORA-01858 a non-numeric character found where a digit was expected</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In addition to supporting many different date formats, dm_convert also offers conversion of "shortcut" entries. Suppose the user wishes to enter the Monday (first day) of this week or the last day of the month. Rather than requiring that users figure out the dates for those days, dm_convert allows them to simply enter a shortcut like "ew" for "end of week." <A
CLASS="xref"
HREF="ch14_03.htm#SQL2-CH-14-SECT-3.1"
>Table 14.5</A
> shows the shortcuts supported by dm_convert. You can easily add your own! </P
><P
CLASS="para"
>Here are some examples of the way dm_convert changes a string to a date (assuming today's date is December 15, 1994): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>dm_convert ('12')    ==&gt; 12-DEC-1994
dm_convert ('3/15')  ==&gt; 15-MAR-1994
dm_convert ('em')    ==&gt; 31-DEC-1994  </PRE
></BLOCKQUOTE
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-14-TABLE-8"
>Table 14.4: Different Masks Supported by dm_convert </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Date Mask</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>User Input</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Result (Assuming SYSDATE = 15-DEC-93)</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DD</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>12</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>12-DEC-1993</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MM/DD</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>12/1</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>01-DEC-1993</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MM/DD/YY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>2/5/92</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>05-FEB-1992</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MM/DD/YYYY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>4/12/1990</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>12-APR-1990</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DD-MON</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>3-Jan</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>03-JAN-1993</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DD-MON-YY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>19-NOV-92</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>19-NOV-1992</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DD-MON-YYYY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>19-NOV-1992</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>19-NOV-1992</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MON</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>JAN</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>01-JAN-1993</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MON-DD</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MAR-02</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>02-MAR-1990</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MON-DD-YY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MAR-13-90</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>13-MAR-1990</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MON-DD-YYYY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MAR-13-1990</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>13-MAR-1990</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Mon-YYYY</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MAR-1990</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>01-MAR-1990</P
> </TD
></TR
></TBODY
></TABLE
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-14-TABLE-10"
>Table 14.5: Shortcut Entries for dm_convert </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Abbreviation</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>String</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Result (Assuming SYSDATE = 14-MAY-93)</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Beginning of Week</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>BW or bw</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Monday in the current week:</P
>  <P
CLASS="para"
>14-MAY-93</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>End of Week</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>EW or ew</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Friday in the current week:</P
>  <P
CLASS="para"
>18-MAY-93</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Beginning of Month</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>BM or bm</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>First day in current month:</P
>  <P
CLASS="para"
>01-MAY-93</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>End of Month</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>EM or em</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Last day in current month:</P
>  <P
CLASS="para"
>30-MAY-93</P
> </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.5.2"
>14.3.5.2 Using exception handlers to find the right format</A
></H4
><P
CLASS="para"
>You might be wondering how Steven gets around raising those nasty Oracle errors relating to invalid date formats when he tries to convert the string to a date. The answer is that I use both the procedurality and the exception handling of PL/SQL. In native SQL, I can use TO_DATE to convert a string to a date, but if the format doesn't match the string, I will get an error and the SQL statement will fail. In fact, this is exactly what Oracle Forms does when a user enters a value in a date item. </P
><P
CLASS="para"
>In PL/SQL, I can use the EXCEPTION clause in my program to trap a conversion failure and handle that failure. Usually when you get such a failure you raise an error, as shown in the following trap conversion failure example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION convert_date (string_in IN VARCHAR2) RETURN DATE IS
BEGIN
   RETURN TO_DATE (string_in);
EXCEPTION
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE
         (' Invalid format for date conversion of ' || string_in);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Clearly, this is not the behavior I want in dm_convert. In dm_convert, a conversion failure does not result from a user's error in entry. It is simply the first step in a search for the right date format mask. The behavior I need to create in dm_convert is the following: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Try to convert the string with a particular date mask.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If it fails, then try to convert the string with a different date mask. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Continue to do this until the string converts without an error or I run out of date masks. </P
></LI
></OL
><P
CLASS="para"
>I can use nested exception handlers, as shown in the following example, to implement this multiple-pass technique: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION dm_convert (string_in IN VARCHAR2) RETURN DATE
IS
   my_date DATE;
BEGIN
   BEGIN
      my_date := TO_DATE (string_in, 'MM/DD');
   EXCEPTION
      WHEN OTHERS
      THEN
         BEGIN
            my_date := TO_DATE (string_in, 'MM/DD/YY');
         EXCEPTION
            WHEN OTHERS
            THEN
               BEGIN
                  my_date := TO_DATE (string_in, 'MM/DD/YYYY');

   .. and so on for all the formats...

               END;
         END;
   END;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here, the dm_convert function uses nested anonymous blocks, each with its own exception section, to trap a date conversion failure and pass it on to the next format. The sequence and variety of masks used dictate the range of valid user input and the precedence with which it is parsed. One problem you might notice with this approach is with indentation. When I use my indentation guidelines for these nested blocks and exception handlers, I quickly run out of room on my page! As a result, in the final version of dm_convert, you will see that I pointedly give up trying to properly indent the exception sections of the function. Instead, I structure the exception sections like a CASE statement: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: dmcnvrt.sf */
FUNCTION dm_convert (value_in IN VARCHAR2)     RETURN DATE
/*
|| Summary: Validate and convert date input of most any format.
||    dm_convert stands for &quot;date manager conversion&quot;. Accepts
||    a character string and returns a fully-parsed and validated
||    date. If the string does not specify a valid date, the function
||    returns NULL.
*/
IS
   /* Internal, upper-cased version of date string */
   value_int VARCHAR2(100) := UPPER (value_in);

   /* The value returned by the function */
   return_value DATE := NULL;

   /* Transfer SYSDATE to local variable to avoid repetitive calls */
   today DATE := SYSDATE;
BEGIN
   /*
   || Handle short-cut logic before checking for specific date formats.
   || Supported short-cuts include:
   ||    EW - end of week
   ||    BW - beginning of week
   ||    EM - end of month
   ||    BM - beginning of month
   ||
   || Add shortcuts for quarters specific to your site.
   */
   IF value_int = 'EW'
   THEN
      /* End of week in this case is Friday of the week */
      return_value := NEXT_DAY (today, 'FRIDAY');

   ELSIF value_int = 'BW'
   THEN
      /* Beginning of week in this case is Monday of the week */
      return_value := NEXT_DAY (today, 'MONDAY') - 7;

   ELSIF value_int = 'BM'
   THEN
       return_value := TRUNC (today, 'MONTH');

   ELSIF value_int = 'EM'
   THEN
      return_value := LAST_DAY (today);

   ELSIF value_int IS NOT NULL
   THEN
      /* No known short-cut. The user must have entered a date string for
      || conversion. Now attempt to convert the value using a sequence
      || of calls to TO_DATE. If one attempt fails, pass it to the next
      || TO_DATE and format mask within a (very) nested exception section.
      */
      BEGIN    return_value := TO_DATE (value_int, 'DD');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'MM/DD');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'MM/DD/YY');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'MM/DD/YYYY');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'DD-MON');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'DD-MON-YY');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'DD-MON-YYYY');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'MON');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'MON-DD');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'MON-DD-YY');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'MON-DD-YYYY');
      EXCEPTION WHEN OTHERS THEN
      BEGIN return_value := TO_DATE (value_int, 'MON-YYYY');
      EXCEPTION WHEN OTHERS THEN return_value := NULL;
      END; END; END; END; END; END;
      END; END; END; END; END; END;
   END IF;

   /* Whether NULL or a real date, return the value */
   RETURN (return_value);

END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the rest of this section I offer alternative implementations of dm_convert. These do not require nesting of exception handling sections and also avoid hardcoding the format masks into the function. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.5.3"
>14.3.5.3 Table-driven date format masks</A
></H4
><P
CLASS="para"
>One drawback to the dm_convert procedure as implemented in the previous section is that everything is hardcoded. Sure, I offer lots of acceptable formats, but they still are all coded explicitly in the procedure. What if a new format needs to be added? In addition, the order of precedence of those formats in validating the date input is hardcoded. If a person enters a 1 and the system date is 12-FEB-95, then dm_convert will change the entry into 01-FEB-95. Suppose, however, that the user really wanted to enter 01-JAN-95 by entering a 1 and suppose further that such defaulted entry is a requirement of your application? </P
><P
CLASS="para"
>Generally, I like to avoid hardcoding any literal values (like the specific formats and their order of execution) in my routines. Any changes (additions or deletions from the supported date formats, or a request in a specific application to move a format up in the batting order) necessitate a change to the program itself, and then the recompilation of all affected modules. I can avoid this scenario by making the date formats and the order in which they are used data-driven. Here's what I would need to do: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Create a table to store the date formats:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE dm_date_mask
   (date_mask VARCHAR2(30), date_mask_seq NUMBER(5,2));</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Build a screen in your choice of tools to enter and maintain records in this table. Note that users should be able to change the date_mask_seq. This sequence number determines the order in which the mask is applied to the date input. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Rewrite dm_convert to use the data in this table instead of the hardcoded sequence of masks. This new version of dm_convert, shown in the following example, replaces the nested exception sections with a simple loop that reads through the contents of the table and attempts to convert the entry with the next format in the table.</P
></LI
></OL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: dmcntab.sf */
FUNCTION dm_convert (value_in IN VARCHAR2) RETURN DATE

/* I will only comment the new sections in the function */

IS
   value_int VARCHAR2(100) := UPPER (value_in);
   return_value DATE := NULL;
   today DATE := SYSDATE;

   /* Now set up a cursor to go through the table of formats */
   CURSOR mask_cur IS
      SELECT date_mask FROM dm_date_mask
       ORDER BY date_mask_seq;
   mask_rec mask_cur%ROWTYPE;
BEGIN
   /* Convert short-cut entry. Same as before. */
   IF value_int = 'EW'
   THEN return_value := NEXT_DAY (today, 'FRIDAY');
   ELSIF value_int = 'BW'
   THEN return_value := NEXT_DAY (today, 'MONDAY') - 7;
   ELSIF value_int = 'BM'
   THEN return_value := TRUNC (today, 'MONTH');
   ELSIF value_int = 'EM'
   THEN return_value := LAST_DAY (today);
   ELSIF value_int IS NOT NULL
   THEN
      /*
      || Open the cursor and loop through the date masks until one
      || of them is used successfully in a TO_DATE conversion.
      */
      OPEN mask_cur;
      LOOP
         /* Fetch a record. Exit loop if there aren't any more masks */
         FETCH mask_cur INTO mask_rec;
         EXIT WHEN mask_cur%NOTFOUND;
         /*
         || Still need separate PL/SQL block in the function to trap
         || a conversion failure, but I only need ONE!
         */
         BEGIN
            /* Try to convert the date */
            return_value := TO_DATE (value_int, mask_rec.date_mask);
            /*
            || If I made it this far, I have converted the string, so
            || EXIT the loop.
            */
            EXIT;
         EXCEPTION
            /*
            || Conversion failure. Reset value to make sure it is still
            || NULL and then keep going -- back to the loop!
            */
            WHEN OTHERS
            THEN
               return_value := NULL;
         END;
      END LOOP;
      CLOSE mask_cur;
   END IF;

   /* Return the converted date */
   RETURN return_value;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This new version of dm_convert not only looks more elegant than the first version&nbsp;-- it is considerably more flexible in its approach. If you no longer want to accept Month YYYY DD as a date format, simply pull up the maintenance screen, delete that entry from the table, or execute a DELETE from the dm_date_mask table directly in SQL*Plus. Poof ! The users will no longer be able to enter January 1995 11 for a date value. </P
><P
CLASS="para"
>There is, of course, a downside to this solution, and it is a familiar one. The price of making your code more flexible (for the developer) is almost always to make your code work less efficiently. Now, instead of executing a series of inline TO_DATE conversion functions, we fetch a series of records from a table. The dm_date_mask table could well be sitting on a remote server. This network traffic could well make the application performance unacceptable to precisely the people you are trying to help by providing flexible date formats. What's a developer to do? One answer is to transfer the table into a memory structure at the start of each user session, as we describe in the next section. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.5.4"
>14.3.5.4 Stashing date masks in memory</A
></H4
><P
CLASS="para"
>Say you moved the date masks to a table and that any changes made to the dm_date_mask table will not happen very often. For all intents and purposes, the date masks are constant for a particular user session. So it is not really necessary to read the masks from the table every time you need to validate a date entry. Instead, we can transfer the masks from the table into a memory structure at the start of the user session. With this approach you add a little more time to the startup execution of the form, but then speed up the validation and conversion for each date item. </P
><P
CLASS="para"
>You have a number of options for storing these date masks in memory:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>GLOBAL variables in Oracle Forms</EM
>. These variables persist across forms and menus in an application and so are good candidates to store information which should last for an entire user session. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>A record group in Oracle Forms.</EM
> This structure takes less memory than GLOBAL variables (which use a fixed 255 bytes regardless of the actual data stored in the variable) and can be manipulated more naturally with Oracle Forms built-ins. However, you cannot currently pass a record group from one form to another (except with a call to RUN_PRODUCT, which is not always appropriate). You might use the record group if the user performs date processing primarily within a single form. Or you might just be looking for an excuse to practice building and manipulating record groups. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Other tool-specific memory structures.</EM
> </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>A PL/SQL table in PL/SQL Version 2.</EM
> Oracle's version of a simple array structure is perfect for this application; unfortunately, PL/SQL tables are available only in the RDBMS (through stored procedures and triggers) and SQL*Plus scripts. </P
></LI
></UL
><P
CLASS="para"
>I provide the code for PL/SQL table-based alternatives in the following sections. The technique based on Oracle Forms GLOBAL variables may be found in the <EM
CLASS="emphasis"
>dmcnvrt.doc</EM
> and <EM
CLASS="emphasis"
>dmcnvrt.fp</EM
> files on the companion disk. In both cases, there are two steps involved in using the memory-resident, data-driven approach: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Initialize the data structure with the various format masks.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Revamp dm_convert to rely on that data structure.</P
></LI
></OL
><P
CLASS="para"
>Notice that the specification of the call to dm_convert does not change with any of these new implementations. I am changing the engine under the hood without making any alterations to the body style, dashboard, or steering controls. None of the triggers that call dm_convert would have to be modified if you did change the storage implementation for the date masks. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-14-SECT-3.5.5"
>14.3.5.5 Storing and accessing date masks in a PL/SQL table</A
></H4
><P
CLASS="para"
>You can also store the date masks in a PL/SQL table (PL/SQL tables are explained fully in <A
CLASS="xref"
HREF="ch10_01.htm"
>Chapter 10, <CITE
CLASS="chapter"
>PL/SQL Tables</CITE
></A
>). The PL/SQL table structure, available only with PL/SQL Version 2, is similar to both a database table and a single-dimensional array. There are two steps to using date masks from the PL/SQL table: Initialize the date masks in the PL/SQL table structure, and revamp dm_convert to rely on the PL/SQL table. These are described below: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Initialize the date masks in the PL/SQL table structure.</EM
> The best way to do this in PL/SQL tables is to build a package (see <A
CLASS="xref"
HREF="ch16_01.htm"
>Chapter 16, <CITE
CLASS="chapter"
>Packages</CITE
></A
>, for more information about this structure). This package contains the code to initialize the masks in the PL/SQL table by transferring them from the database table, to perform the date conversions, and to clean up the table when done. </P
><P
CLASS="para"
>A package is made up of two parts: the specification and the body. The specification for the date manager (dm) package is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: dmcnvrt.spp */</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE dm
IS
   /* The replacement for dm_convert */
   FUNCTION convert (value_in IN VARCHAR2) RETURN DATE;

   /* Clean-up program */
   PROCEDURE erase;

END dm;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The body of the dm package shown in the following example contains all the code behind the specification. In addition to the definitions of the convert and erase modules, the body also contains an initialization section following the last BEGIN in the body. This section is run automatically the first (and only the first) time the convert or erase modules are called. This initialization code populates the PL/SQL table of masks. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: dmcnvrt.spp */
PACKAGE BODY dm
IS
   /*
   || Declare the structure of the PL/SQL table which will hold
   || the masks. Then declare the table itself.
   */
   TYPE mask_tabtype IS TABLE OF VARCHAR2 (30) INDEX BY BINARY_INTEGER;
   mask_table mask_tabtype;

   /* Also declare an empty table for use in erasing the masks */
   empty_table mask_tabtype;

   /* Package variable which keeps track of number of rows in table */
   mask_count NUMBER;

   /* Replacement for dm_convert */
   FUNCTION convert (value_in IN VARCHAR2) RETURN DATE
   IS
      value_int VARCHAR2(100) := UPPER (value_in);
      return_value DATE := NULL;
      today DATE := SYSDATE;

      /* Loop index for the scan through the masks */
      mask_index INTEGER := 1;

      /* Boolean to terminate loop if date was converted */
      date_converted BOOLEAN := FALSE;
   BEGIN
      /* Same old shortcuts! */
      IF value_int = 'EW'
      THEN return_value := NEXT_DAY (today, 'FRIDAY');
      ELSIF value_int = 'BW'
      THEN return_value := NEXT_DAY (today, 'MONDAY') - 7;
      ELSIF value_int = 'BM'
      THEN return_value := TRUNC (today, 'MONTH');
      ELSIF value_int = 'EM'
      THEN return_value := LAST_DAY (today);

      /* Now convert from masks in table */
      ELSIF value_int IS NOT NULL
      THEN
         /* Loop through the rows in the table... */
         WHILE mask_index &lt;= mask_count AND
               NOT date_converted
         LOOP
            BEGIN
               /* Try to convert string using mask in table row */
               return_value :=
                  TO_DATE (value_int, mask_table (mask_index));
               date_converted := TRUE;
            EXCEPTION
               WHEN OTHERS THEN
                  return_value := NULL;
                  mask_index:= mask_index+ 1;
            END;
         END LOOP;
      END IF;
      RETURN (return_value);
   END convert;

   PROCEDURE erase IS
   BEGIN
      /*
      || Clear the table of any defined rows by assigning the empty
      || table to the mask table.
      */
      mask_table := empty_table;
   END;

BEGIN
   /* ------------ Initialization Section of Package ------------*/

   /* Transfer values from RDBMS table to PL/SQL table */
   mask_count := 0;
   FOR mask_rec IN (SELECT date_mask
                      FROM dm_date_mask
                     ORDER BY date_mask_seq)
   LOOP
      mask_count := mask_count + 1;
      mask_table (mask_count) := mask_rec.date_mask;
   END LOOP;

END dm;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Revamp dm_convert to rely on the PL/SQL table.</EM
> The structure of the convert program in the dm package is very similar to that of the dm_convert program, which relied on global variables in Oracle Forms. In both cases, I replace the nested exception sections with a PL/SQL loop. </P
><P
CLASS="para"
>To call the conversion program in the dm package, you would use dot notation, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>my_date := dm.convert ('12');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>But dm.convert is not the same thing as dm_convert, which is what all my triggers are already calling. In order to make the conversion to PL/SQL table-based format masks completely transparent to my Oracle Forms applications, I will need to build another layer of code over the package. I do this by creating a stored procedure as follows:[<A
CLASS="footnote"
HREF="#AUTOID-13124"
>3</A
>] </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-13124"
>[3]</A
> I could also create this function in a PL/SQL library and attach it to all of my forms.</P
></DIV
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE FUNCTION dm_convert (string_in IN VARCHAR2)
   RETURN DATE
IS
BEGIN
   RETURN dm.convert (string_in);
END;</PRE
></BLOCKQUOTE
></LI
></OL
><P
CLASS="para"
>Now I can call dm_convert just as I did in the good old days:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>my_date := dm_convert ('12');<A
CLASS="indexterm"
NAME="AUTOID-13129"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-13130"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-13131"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-13132"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-13133"
></A
>
 </PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch14_02.htm#SQL2-CH-14-SECT-2.0.1"
TITLE="14.2 Conversion Function Descriptions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 14.2 Conversion Function Descriptions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part04.htm"
TITLE="IV. Modular Code "
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: IV. Modular Code "
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>14.2 Conversion Function Descriptions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>IV. Modular Code </TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
