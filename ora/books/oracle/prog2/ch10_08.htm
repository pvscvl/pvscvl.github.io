<HTML
><HEAD
><TITLE
>[Chapter 10] 10.8 PL/SQL Table Enhancements in PL/SQL Release 2.3</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:59:17Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch10_01.htm"
TITLE="10. PL/SQL Tables"><LINK
REL="prev"
HREF="ch10_07.htm"
TITLE="10.7 Clearing the PL/SQL Table"><LINK
REL="next"
HREF="ch10_09.htm#SQL2-CH-10-SECT-9.5.6"
TITLE="10.9 Working with PL/SQL Tables"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_07.htm"
TITLE="10.7 Clearing the PL/SQL Table"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.7 Clearing the PL/SQL Table"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch10_01.htm"
TITLE="10. PL/SQL Tables"
>Chapter 10<BR>PL/SQL Tables</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_09.htm#SQL2-CH-10-SECT-9.5.6"
TITLE="10.9 Working with PL/SQL Tables"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.9 Working with PL/SQL Tables"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8"
>10.8 PL/SQL Table Enhancements in PL/SQL Release 2.3</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-824504-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-824504-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-824504-3"
></A
>PL/SQL Release 2.3 offers significantly enhanced functionality for PL/SQL tables. These new features include: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-824505-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-824505-2"
></A
>Records supported as elements of PL/SQL tables. Prior to Release 2.3, the element or single column of the PL/SQL table could only be a scalar datatype, such as VARCHAR2 or BOOLEAN or DATE. Release 2.3 allows you to define table types whose element datatype is defined with the %ROWTYPE declaration attribute or is a named RECORD type. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>New operations on PL/SQL tables.</EM
> PL/SQL Release 2.3 offers a set of new built-in functions and procedures which return information about, or modify the contents of, a PL/SQL table. These operations are shown in <A
CLASS="xref"
HREF="ch10_08.htm#SQL2-CH-10-SECT-8.2"
>Table 10.1</A
>. </P
></LI
></UL
><P
CLASS="para"
>These new features allow you to use PL/SQL tables for a wider range of applications and also manipulate the data in tables in a more natural and efficient manner. You can now create local PL/SQL data structures which mimic precisely the structure of a table stored in the database. You do not have to create separate tables and manage them in parallel to emulate the multiple-column SQL table structure. </P
><P
CLASS="para"
>You can use the built-ins to obtain PL/SQL table information that previously was unavailable. For example, you can use the COUNT function to determine the number of elements defined in a table. You no longer have to keep track of that number yourself. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-10-TABLE-2"
>Table 10.1: PL/SQL Release 2.3 Built-in Functions and Procedures for Tables </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Operator</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description </P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>COUNT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the number of elements currently contained in the PL/SQL table. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>DELETE</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Deletes one or more elements from the PL/SQL table.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>EXISTS</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns FALSE if a reference to an element at the specified index would raise the NO_DATA_FOUND exception. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>FIRST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the smallest index of the PL/SQL table for which an element is defined. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>LAST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the greatest index of the PL/SQL table for which an element is defined. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>NEXT</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the smallest index of the PL/SQL table containing an element which is greater than the specified index. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>PRIOR</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the greatest index of the PL/SQL table containing an element which is less than the specified index. </P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>These functions and procedures are described in detail later in this chapter. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.1"
>10.8.1 PL/SQL Tables of Records</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9018"
></A
>To declare a PL/SQL table, you must first declare a PL/SQL table TYPE. The syntax for the TYPE statement is as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE &lt;type name&gt; IS TABLE OF &lt;datatype&gt;
   INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With PL/SQL Release 2.3, the &lt;datatype&gt; may be a record type. This record type can be defined using the %ROWTYPE declaration attribute. You can also specify a previously defined record structure defined with the TYPE statement for records. </P
><P
CLASS="para"
>When you do create a PL/SQL table based on a record structure, that record may only be composed of scalar fields. A nested record type (in which a field in the record is yet another record type) may not be used to define a table type. </P
><P
CLASS="para"
>The following examples illustrate the different ways to declare table types based on records: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Declare a PL/SQL table type with same structure as the employee table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE local_emp_table IS TABLE OF employee%ROWTYPE
   INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Declare a PL/SQL table type to correspond to the data returned by a cursor: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CURSOR emp_cur IS SELECT * FROM employee;

TYPE cursor_emp_table IS TABLE OF emp_cur%ROWTYPE
   INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Declare a PL/SQL table type based on a programmer-defined record:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE emp_rectype IS
   RECORD (employee_id INTEGER, emp_name VARCHAR2(60));

TYPE emp_table IS TABLE OF emp_rectype
   INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>Notice that when you use a programmer-defined record type you do not append the %ROWTYPE attribute to the record type. That is only done when you are using a table-based or cursor-based record. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.1.1"
>10.8.1.1 Referencing fields of record elements in PL/SQL tables</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9039"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9043"
></A
>References to fields of elements of PL/SQL tables which are records have the following syntax: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;table name&gt;(&lt;index expression&gt;).&lt;field name&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where &lt;table name&gt; is the name of the table, &lt;index expression&gt; is an expression (constant, variable, or computed expression) which evaluates to a number and &lt;field name&gt; is the name of the field in the record used to define the PL/SQL table. </P
><P
CLASS="para"
>If, for example, you have created a PL/SQL table named emp_tab based on a record structure with a field named emp_name, then the following assignment sets the employee name in the 375th row of the PL/SQL table to SALIMBA: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>emp_tab(375).emp_name := 'SALIMBA';</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9051"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9053"
></A
>The index to the table does not have to be a constant. In the following example, the index is calculated: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF names_table (old_name_row + 1).last_name = 'SMITH'
THEN</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9058"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9061"
></A
>You can define functions which return PL/SQL tables. As a result, you can also reference a field in a PL/SQL table's record with the following syntax: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;function name&gt;(&lt;argument list&gt;)(&lt;index expression&gt;).&lt;field name&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>An example will make it easier to understand this complicated syntax. Suppose that I have defined a function as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION best_company (year_in IN INTEGER)
   RETURN company_tabtype;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where company_tabtype is a PL/SQL table type with a record structure for its element. Then the following call to PUT_LINE displays the name of the company found in the tenth row of the returned table: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_OUTPUT.PUT_LINE
   (best_company(1995)(10).company_name || ' was tenth best!');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To make sense of this expression, break it up into its components:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>best_company(1995)</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns a table, each row of which contains information about a company. </P
></DD
><DT
CLASS="term"
>best_company(1995)(10)</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns the tenth row of that table.</P
></DD
><DT
CLASS="term"
>best_company(1995)(10).company_name</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns the name of the company found in the tenth row of the table.</P
></DD
></DL
><P
CLASS="para"
>You can improve the readability of such a statement by separating it as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>current_company_rec := best_company(1995)(10);

DBMS_OUTPUT.PUT_LINE
   (current_company.company_name || ' was tenth best!')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where current_company_rec is a record defined with the same type as the RETURN clause of the best_company function. Now you have two statements where only one is really needed, but the code can be more easily understood and therefore maintained. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.1.2"
>10.8.1.2 Assigning records in PL/SQL tables</A
></H4
><P
CLASS="para"
>You can assign a whole record fetched from the database directly into the row of a PL/SQL table as shown below (where both the cursor and the PL/SQL table use the same company%ROWTYPE row type declaration): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR company_rec IN company_cur
LOOP
   /* Get last row used and add one. */
   next_row := NVL (company_table.LAST, 0) + 1;

   company_table(next_row) := company_rec;

END LOOP;<A
CLASS="indexterm"
NAME="AUTOID-9090"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-9091"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.2"
>10.8.2 PL/SQL Table Built-ins</A
></H3
><P
CLASS="para"
>Each of the PL/SQL table built-in procedures and functions provides different information about the referenced PL/SQL table, except for DELETE, which removes rows from the PL/SQL table. The syntax for using the table built-ins for PL/SQL tables is different from the syntax I described in <A
CLASS="xref"
HREF="part03.htm"
>Part 3, <CITE
CLASS="part"
>Built-In Functions </CITE
></A
> of this book. It employs a "member method" syntax, common in object-oriented languages such as C++. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9097"
></A
>To give you a feeling for member-method syntax, consider the LAST function. It returns the greatest index value in use in the PL/SQL table. Using standard function syntax, you might expect to call LAST as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF LAST (company_table) &gt; 10 THEN ... /* Invalid syntax */</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, you would pass the PL/SQL table as an argument. In contrast, by using the member-method syntax, the LAST function is a method which "belongs to" the object, in this case the PL/SQL table. So the correct syntax for using LAST is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF company_table.LAST &gt; 10 THEN ... /* Correct syntax */</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The general syntax for calling these PL/SQL table built-ins is either of the following: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>An operation which takes no arguments:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;table name&gt;.&lt;operation&gt;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An operation which takes a row index for an argument:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;table name&gt;.&lt;operation&gt;(&lt;index number&gt; [, &lt;index_number&gt;])</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>The following statement, for example, returns TRUE if the 15th row of the company_tab PL/SQL table is defined: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>company_tab.EXISTS(15)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By using the member-method syntax, Oracle is able to distinguish the PL/SQL table functions such as EXISTS and DELETE from the SQL operations of the same name (which never appear with dot-qualified notation). </P
><P
CLASS="para"
>The following sections describe each of the table built-ins.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.2.1"
>10.8.2.1 The COUNT function</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9117"
></A
>The COUNT function returns the number of elements currently defined in the PL/SQL table. The specification for the function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION COUNT RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You call COUNT as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>total_rows := emp_table.COUNT;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that if the emp_table structure were defined inside a package, then double dot notation would be needed to get the count: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>total_rows := employee_pkg.emp_table.COUNT;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Prior to PL/SQL Release 2.3, the only way to determine this count was to manually keep track of the number of elements defined in the table. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.2.2"
>10.8.2.2 The DELETE procedure</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9128"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9130"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9133"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9136"
></A
> The DELETE procedure deletes elements from the specified PL/SQL table. The specifications for the procedure are overloaded, as shown in the following table. </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Procedure Header</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Description of Use</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DELETE;
</PRE
></BLOCKQUOTE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> Just as with SQL, this simplest form of the DELETE build-in (which takes no arguments at all) has the most sweeping impact: delete all rows from the PL/SQL table. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DELETE
(index_in IN INTEGER);
</PRE
></BLOCKQUOTE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> Delete the row specified by that index. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DELETE
(start_index_in IN INTEGER,
end_index_in IN INTEGER);
</PRE
></BLOCKQUOTE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> Deletes all the rows defined between the start and end indexes. If end_index_in is less than start_index_in, then no rows are deleted. </P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>If any of the arguments to DELETE is NULL, then the operation does not remove any rows at all. </P
><P
CLASS="para"
>You call DELETE as shown in the following examples:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Delete all the rows from the names table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>names_tab.DELETE;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Delete the 77th row from the globals table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ps_globals.DELETE (77);</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Delete all rows in the temperature readings table between the 0th row and the -15,000th row, inclusive: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>temp_reading_tab.DELETE (-15000, 0);</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>Prior to PL/SQL Release 2.3, the only way to delete rows from a PL/SQL table was to assign an empty table to the existing PL/SQL table. The DELETE procedure gives you much finer control over the memory required by your PL/SQL tables. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.2.3"
>10.8.2.3 The EXISTS function</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9179"
></A
>The EXISTS function returns TRUE if an element is defined at the specified index in a PL/SQL table. Otherwise, it returns FALSE. The specification for the function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION EXISTS (index_in IN INTEGER) RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You call EXISTS as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF seuss_characters_table.EXISTS(1) THEN ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Prior to PL/SQL Release 2.3, you could emulate the EXISTS function with your own function looking something like this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: rowexist.sf */
FUNCTION row_exists
   (table_in IN &lt;table type&gt;, row_in IN INTEGER) RETURN BOOLEAN
IS
   stg VARCHAR2(20);
BEGIN
   stg := table_in (row_in);
   RETURN TRUE;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      RETURN FALSE;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Unfortunately, you would need a different version of the function for each PL/SQL table TYPE, which makes this a very undesirable approach. The EXISTS function is a big improvement. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.2.4"
>10.8.2.4 The FIRST function</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9190"
></A
>The FIRST function returns the lowest value index for which an element is defined in the specified PL/SQL table. The specification for the function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION FIRST RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You call FIRST as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>first_entry_row := employee_table.FIRST;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the PL/SQL table does not contain any elements at all, FIRST returns NULL. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.2.5"
>10.8.2.5 The LAST function</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9199"
></A
>The LAST function returns the highest value index for which an element is defined in the specified PL/SQL table. The specification for the function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION LAST RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You call LAST as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>last_entry_row := employee_table.LAST;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the PL/SQL table does not contain any elements at all, LAST returns NULL. </P
><P
CLASS="para"
>If you plan to use the PL/SQL table to fill rows sequentially from, say, the first row, you will want to make sure to use the NVL function (see <A
CLASS="xref"
HREF="ch13_01.htm"
>Chapter 13, <CITE
CLASS="chapter"
>Numeric, LOB, and Miscellaneous Functions</CITE
></A
>) to convert the NULL to a zero, as shown in this example. </P
><P
CLASS="para"
>The following block uses a cursor FOR loop to transfer data from the database to a PL/SQL table of records. When the first record is fetched, the company_table is empty, so the LAST operator will return NULL. NVL converts that value to zero. I then add one and I am on my way: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR company_rec IN company_cur
LOOP
   /* Get last row used and add one. */
   next_row := NVL (company_table.LAST, 0) + 1;

   /* Set the (next_row) values for ID. */
   company_table(next_row).company_id :=
         company_rec.company_id;

END LOOP;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.2.6"
>10.8.2.6 The NEXT function</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9212"
></A
>The NEXT function returns the next greater index after the specified index at which some element is defined in the specified PL/SQL table. The specification for the function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION NEXT (index_in IN INTEGER) RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You call NEXT as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>next_index := employee_table.NEXT (curr_index);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Remember that PL/SQL tables are sparse: if the tenth and 2005th rows are defined, there is no guarantee that the 11th row is also defined. NEXT gives you a way to find the next defined element, "skipping over" any undefined row numbers. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9219"
></A
>The table.NEXT procedure will return NULL if there aren't any elements defined after the specified row. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-10-SECT-8.2.7"
>10.8.2.7 The PRIOR function</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9224"
></A
>The PRIOR function returns the prior greater index after the specified index at which some element is defined in the specified PL/SQL table. The specification for the function is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION PRIOR (index_in IN INTEGER) RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You call PRIOR as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>prev_index := employee_table.PRIOR (curr_index);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Remember that, as we described in the preceding section, PL/SQL tables are sparse. PRIOR gives you a way to find the previously defined element, "skipping over" any undefined row numbers.<A
CLASS="indexterm"
NAME="AUTOID-9230"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9231"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-9232"
></A
> </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-9234"
></A
>The table.PRIOR procedure will return NULL if there aren't any elements defined before the specified row. </P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_07.htm"
TITLE="10.7 Clearing the PL/SQL Table"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.7 Clearing the PL/SQL Table"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_09.htm#SQL2-CH-10-SECT-9.5.6"
TITLE="10.9 Working with PL/SQL Tables"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.9 Working with PL/SQL Tables"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>10.7 Clearing the PL/SQL Table</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10.9 Working with PL/SQL Tables</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
