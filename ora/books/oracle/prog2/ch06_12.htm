<HTML
><HEAD
><TITLE
>[Chapter 6] 6.12 Cursor Variables</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:57:02Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. Database Interaction and Cursors"><LINK
REL="prev"
HREF="ch06_11.htm#SQL2-CH-6-SECT-11.1"
TITLE="6.11 SELECT FOR UPDATE in Cursors"><LINK
REL="next"
HREF="ch06_13.htm#SQL2-CH-6-SECT-13.2"
TITLE="6.13 Working with Cursors "></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_11.htm#SQL2-CH-6-SECT-11.1"
TITLE="6.11 SELECT FOR UPDATE in Cursors"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.11 SELECT FOR UPDATE in Cursors"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch06_01.htm"
TITLE="6. Database Interaction and Cursors"
>Chapter 6<BR>Database Interaction and Cursors</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_13.htm#SQL2-CH-6-SECT-13.2"
TITLE="6.13 Working with Cursors "
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.13 Working with Cursors "
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12"
>6.12 Cursor Variables</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-104774-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-104774-2"
></A
>In PL/SQL Release 2.3, available with the release of Oracle Server Release 7.3, you can create and use cursor variables. Unlike an explicit cursor, which names the PL/SQL work area for the result set, a cursor variable is instead a (Release 2.3) reference to that work area. Explicit and implicit cursors are both static in that they are tied to specific queries. The cursor variable can be opened for any query, even different queries within a single program execution. </P
><P
CLASS="para"
>The most important benefit of the cursor variable is that it provides a mechanism for passing results of queries (the rows returned by fetches against a cursor) between different PL/SQL programs&nbsp;-- even between client and server PL/SQL programs. Prior to PL/SQL Release 2.3, you would have had to fetch all data from the cursor, store it in PL/SQL variables (perhaps a PL/SQL table), and then pass those variables as arguments. With cursor variables, you simply pass the reference to that cursor. This improves performance and streamlines your code. </P
><P
CLASS="para"
>It also means that the cursor is, in effect, shared among the programs which have access to the cursor variable. In a client-server environment, for example, a program on the client side could open and start fetching from the cursor variable, then pass that variable as an argument to a stored procedure on the server. This stored program could then continue fetching and pass control back to the client program to close the cursor. You can also perform the same steps between different stored programs, on the same or different database instances. </P
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="SQL2-CH-6-FIG-2"
>Cursor Variables in PL/SQL Release 2.2</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5940"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5943"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5946"
></A
> Cursor variables first became available in PL/SQL Release 2.2. This first version of cursor variables allowed you to open and close the cursor objects within PL/SQL, but you could fetch through these cursor variables only within a host language (using the Oracle Call Interface&nbsp;-- OCI&nbsp;-- or a precompiler like Pro*C). It was not until Release 2.3 that the PL/SQL language made cursor variables available for "self-contained" execution, independent of any host language. </P
><P
CLASS="para"
>Because the focus of this book is on standalone PL/SQL development, I present cursor variables as a PL/SQL Release 2.3 enhancement. If you do have PL/SQL Release 2.2 and work with PL/SQL in a host language environment, you can still use cursor variables. Just don't try to FETCH within PL/SQL and don't expect any of the cursor attributes to be available for your cursor variables. </P
></DIV
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> The client-server aspect of this sharing will only really come into play when the Oracle Developer/2000 tools are converted to use PL/SQL Release 2.3 or above. </P
></BLOCKQUOTE
><P
CLASS="para"
>This process, shown in <A
CLASS="xref"
HREF="ch06_12.htm#SQL2-CH-6-SECT-12.5"
>Figure 6.2</A
>, offers dramatic new possibilities for data sharing and cursor management in PL/SQL programs. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-6-FIG-3"
>Figure 6.2: Referencing a cursor variable across two programs</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.0602.gif"
ALT="Figure 6.2"><P
CLASS="para"
>The code you write to take advantage of cursor variables is very similar to that for explicit cursors. The following example declares a cursor type (called a REF CURSOR type) for the company table, then opens, fetches from, and closes the cursor: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   /* Create the cursor type. */
   TYPE company_curtype IS REF CURSOR RETURN company%ROWTYPE;

   /* Declare a cursor variable of that type. */
   company_curvar company_curtype;

   /* Declare a record with same structure as cursor variable. */
   company_rec company%ROWTYPE;
BEGIN
   /* Open the cursor variable, associating with it a SQL statement. */
   OPEN company_curvar FOR SELECT * FROM company;

   /* Fetch from the cursor variable. */
   FETCH company_curvar INTO company_rec;

   /* Close the cursor object associated with variable. */
   CLOSE company_curvar;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>That looks an awful lot like explicit cursor operations, except for the following: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The REF CURSOR type declaration</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The OPEN FOR syntax which specified the query at the time of the open </P
></LI
></UL
><P
CLASS="para"
>While the syntax is very similar, the fact that the cursor variable is a variable opens up many new opportunities in your programs. These are explored in the remainder of this section. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.1"
>6.12.1 Features of Cursor Variables</A
></H3
><P
CLASS="para"
>Cursor variables let you:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Associate a cursor variable with different queries at different times in your program execution. In other words, a single cursor variable can be used to fetch from different result sets. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Pass a cursor variable as an argument to a procedure or function. You can, in essence, share the results of a cursor by passing the reference to that result set. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Employ the full functionality of static PL/SQL cursors for cursor variables. You can OPEN, CLOSE, and FETCH with cursor variables within your PL/SQL programs. You can reference the standard cursor attributes&nbsp;-- %ISOPEN, %FOUND, %NOTFOUND, and %ROWCOUNT&nbsp;-- for cursor variables. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Assign the contents of one cursor (and its result set) to another cursor variable. Because the cursor variable is a variable, it can be used in assignment operations. There are, however, restrictions on referencing this kind of variable, addressed later in this chapter. </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.2"
>6.12.2 Similarities to Static Cursors</A
></H3
><P
CLASS="para"
>One of the key design requirements for cursor variables was that as much as possible the semantics used to manage cursor objects would be the same as that of static cursors. While the declaration of a cursor variable and the syntax for opening it are enhanced, the following cursor operations are unchanged for cursor variables: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>The CLOSE statement.</EM
> In the following example I declare a REF CURSOR type and a cursor variable based on that type. Then I close the cursor variable using the same syntax as for that of a static cursor: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   TYPE var_cur_type IS REF CURSOR;
   var_cur var_cur_type;
BEGIN
   CLOSE var_cur;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5988"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5992"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5995"
></A
>Cursor attributes. You can use any of the four cursor attributes with exactly the same syntax as for that of a static cursor. The rules governing the use and values returned by those attributes match that of explicit cursors. If I have declared a variable cursor as in the previous example, I could use all the cursor attributes as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>var_cur%ISOOPEN
var_cur%FOUND
var_cur%NOTFOUND
var_cur%ROWCOUNT</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Fetching from the cursor variable.</EM
> You use the same FETCH syntax when fetching from a cursor variable into local PL/SQL data structures. There are, however, additional rules applied by PL/SQL to make sure that the data structures of the cursor variable's row (the set of values returned by the cursor object) match that of the data structures to the right of the INTO keyword. These rules are discussed in <A
CLASS="xref"
HREF="ch06_12.htm#SQL2-CH-6-SECT-12.5"
>Section 6.12.6, "Rules for Cursor Variables"</A
>.</P
></LI
></UL
><P
CLASS="para"
>Because the syntax for these aspects of cursor variables remain unchanged, I won't cover them again in the remainder of this section. Instead I will focus on the new capabilities available and the changed syntax required for cursor variables. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.3"
>6.12.3 Declaring REF CURSOR Types and Cursor Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6006"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6008"
></A
>Just as with a PL/SQL table or a programmer-defined record, you must perform two distinct declaration steps in order to create a cursor variable: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Create a referenced cursor TYPE.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Declare the actual cursor variable based on that type.</P
></LI
></OL
><P
CLASS="para"
>The syntax for creating a referenced cursor type is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE cursor_type_name IS REF CURSOR [ RETURN return_type ];</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where cursor_type_name is the name of the type of cursor and return_type is the RETURN data specification for the cursor type. The return_type can be any of the data structures valid for a normal cursor RETURN clause, defined using the %ROWTYPE attribute or by referencing a previously-defined record TYPE. </P
><P
CLASS="para"
>Notice that the RETURN clause is optional with the REF CURSOR type statement. Both of the following declarations are valid: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE company_curtype IS REF CURSOR RETURN company%ROWTYPE;
TYPE generic_curtype IS REF CURSOR;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first form of the REF CURSOR statement is called a <EM
CLASS="emphasis"
>strong type</EM
> because it attaches a record type (or row type) to the cursor variable type at the moment of declaration. Any cursor variable declared using that type can only be used with SQL statement and FETCH INTO data structures which match the specified record type. The advantage of a strong REF TYPE is that the compiler can determine whether or not the developer has properly matched up the cursor variable's FETCH statements with its cursor object's query list. </P
><P
CLASS="para"
>The second form of the REF CURSOR statement, in which the RETURN clause is missing, is called a <EM
CLASS="emphasis"
>weak type</EM
>. This cursor variable type is not associated with any record data structure. Cursor variables declared without the RETURN clause can be used in much more flexible ways than the strong type. They can be used with any query, with any rowtype structure&nbsp;-- varying even within the course of a single program. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.3.1"
>6.12.3.1 Declaring cursor variables</A
></H4
><P
CLASS="para"
>The syntax for declaring a cursor variable is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>cursor_name cursor_type_name;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where cursor_name is the name of the cursor and cursor_type_name is the name of the type of cursor previously defined with a TYPE statement. </P
><P
CLASS="para"
>Here is an example of the creation of a cursor variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   /* Create a cursor type for sports cars. */
   TYPE sports_car_cur_type IS REF CURSOR RETURN car%ROWTYPE;

   /* Create a cursor variable for sports cars. */
   sports_car_cur sports_car_cur_type;
BEGIN
   ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It is very important to distinguish between declaring a cursor variable and creating an actual cursor object&nbsp;-- the result set identified by the cursor SQL statement. The cursor variable is nothing more than a reference or pointer. A constant is nothing more than a value, whereas a variable points to its value. Similarly, a static cursor acts as a constant, whereas a cursor variable points to a cursor object. <A
CLASS="indexterm"
NAME="AUTOID-6033"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6036"
></A
>These distinctions are shown in <A
CLASS="xref"
HREF="ch06_12.htm#SQL2-CH-6-SECT-12.5"
>Figure 6.3</A
>. Notice that two different cursor variables in different programs both refer to the same cursor object. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-6-FIG-4"
>Figure 6.3: The referencing character of cursor variables</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.0603.gif"
ALT="Figure 6.3"><P
CLASS="para"
>Declaration of a cursor variable does not create a cursor object. To do that, you must instead use the OPEN FOR syntax to create a new cursor object and assign it to the variable. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.4"
>6.12.4 Opening Cursor Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6047"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6049"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6052"
></A
>You assign a value (the cursor object) to a cursor when you OPEN the cursor. So the syntax for the OPEN statement is now modified in PL/SQL Release 2.3 to accept a SELECT statement after the FOR clause, as shown below: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OPEN cursor_name FOR select_statement;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where cursor_name is the name of a cursor or cursor variable and select_statement is a SQL SELECT statement. </P
><P
CLASS="para"
>For strong REF CURSOR type cursor variables, the structure of the SELECT statement (the number and datatypes of the columns) must match or be compatible with the structure specified in the RETURN clause of the type statement. <A
CLASS="xref"
HREF="ch06_12.htm#SQL2-CH-6-SECT-12.5"
>Figure 6.4</A
> offers an example of the kind of compatibility required. <A
CLASS="xref"
HREF="ch06_12.htm#SQL2-CH-6-SECT-12.5"
>Figure 6.4</A
>" contains the full set of compatibility rules. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-6-FIG-5"
>Figure 6.4: Compatible REF CURSOR rowtype and SELECT list</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.0604.gif"
ALT="Figure 6.4"><P
CLASS="para"
>If cursor_name is a cursor variable defined with a weak REF CURSOR type, you can OPEN it for any query, with any structure. In the following example, I open (assign a value to) the cursor variable twice, with two different queries: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   TYPE emp_curtype IS REF CURSOR;
   emp_curvar emp_curtype;
BEGIN
   OPEN emp_curvar FOR SELECT * FROM emp;
   OPEN emp_curvar FOR SELECT employee_id FROM emp;
   OPEN emp_curvar FOR SELECT company_id, name FROM company;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>That last open didn't even have anything to do with the employee table! </P
><P
CLASS="para"
>If the cursor variable has not yet been assigned to any cursor object, the OPEN FOR statement implicitly creates an object for the variable. </P
><P
CLASS="para"
>If at the time of the OPEN the cursor variable already is pointing to a cursor object, then OPEN FOR does not create a new object. Instead, it reuses the existing object and attaches a new query to that object. The cursor object is maintained separately from the cursor or query itself. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.5"
>6.12.5 Fetching from Cursor Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-104780-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-104780-2"
></A
>As mentioned earlier, the syntax for a FETCH statement using a cursor variable is the same as that for static cursors: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FETCH &lt;cursor variable name&gt; INTO &lt;record name&gt;;
FETCH &lt;cursor variable name&gt; INTO &lt;variable name&gt;, &lt;variable name&gt; ...;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When the cursor variable was declared with a strong REF CURSOR type, the PL/SQL compiler makes sure that the data structure(s) listed after the INTO keyword are compatible with the structure of the query associated with cursor variable. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.5.1"
>6.12.5.1 Strong and weak REF CURSOR types</A
></H4
><P
CLASS="para"
>If the cursor variable is of the weak REF CURSOR type, the PL/SQL compiler cannot perform the same kind of check. Such a cursor variable can FETCH into any data structures, because the REF CURSOR type it is not identified with a rowtype at the time of declaration. At compile time, there is no way to know which cursor object (and associated SQL statement) will be assigned to that variable. </P
><P
CLASS="para"
>Consequently, the check for compatibility must happen at run time, when the FETCH is about to be executed. At this point, if the query and the INTO clause do not structurally match (and PL/SQL will use implicit conversions if necessary and possible), then the PL/SQL runtime engine will raise the predefined ROWTYPE_MISMATCH exception. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.5.2"
>6.12.5.2 Handling the ROWTYPE_MISMATCH exception</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-104781-1"
></A
> <A
CLASS="indexterm"
NAME="ch06-idx-104781-2"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-104781-3"
></A
>Before PL/SQL actually performs its FETCH, it checks for compatibility. As a result, you can trap the ROWTYPE_MISMATCH exception and attempt to FETCH from the cursor variable using a different INTO clause&nbsp;-- and you will not have skipped any rows in the result set. </P
><P
CLASS="para"
>Even though you are executing a second FETCH statement in your program, you will still retrieve the first row in the result set of the cursor object's query. This functionality comes in especially handy for weak REF CURSOR types. </P
><P
CLASS="para"
>In the following example, a centralized real estate database stores information about properties in a variety of tables, one for homes, another for commercial properties, etc. There is also a single, central table which stores an address and a building type (home, commercial, etc.). I use a single procedure to open a weak REF CURSOR variable for the appropriate table, based on the street address. Each individual real estate office can then call that procedure to scan through the matching properties: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Define my weak REF CURSOR type:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE building_curtype IS REF CURSOR;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Create the procedure. Notice that the mode of the cursor variable parameter is IN OUT: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE open_site_list
   (address_in IN VARCHAR2,
    site_cur_inout IN OUT building_curtype)
IS
   home_type CONSTANT INTEGER := 1;
   commercial_type CONSTANT INTEGER := 2;

   /* A static cursor to get building type. */
   CURSOR site_type_cur IS
      SELECT site_type FROM property_master
       WHERE address = address_in;
   site_type_rec site_type_cur%ROWTYPE;

BEGIN
   /* Get the building type for this address. */
   OPEN site_type_cur;
   FETCH site_type_cur INTO site_type_rec;
   CLOSE site_type_cur;

   /* Now use the site type to select from the right table.*/
   IF site_type_rec.site_type =  home_type
   THEN
      /* Use the home properties table. */
      OPEN site_cur_inout FOR
         SELECT * FROM home_properties
          WHERE address LIKE '%' || address_in || '%';

   ELSIF site_type_rec.site_type =  commercial_type
   THEN
      /* Use the commercial properties table. */
      OPEN site_cur_inout FOR
         SELECT * FROM commercial_properties
          WHERE address LIKE '%' || address_in || '%';
   END IF;
END open_site_list;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Now that I have my open procedure, I can use it to scan properties. </P
></LI
></OL
><P
CLASS="para"
>In the following example, I pass in the address and then try to fetch from the cursor, assuming a home property. If the address actually identifies a commercial property, PL/SQL will raise the ROWTYPE_MISMATCH exception (incompatible record structures). The exception section then fetches again, this time into a commercial building record, and the scan is complete.[<A
CLASS="footnote"
HREF="#AUTOID-6106"
>2</A
>] </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-6106"
>[2]</A
> The "prompt" and "show" programs referenced in the example interact with users and are not documented here.</P
></DIV
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   /* Declare a cursor variable. */
   building_curvar building_curtype;

   /* Define record structures for two different tables. */
   home_rec home_properties%ROWTYPE;
   commercial_rec commercial_properties%ROWTYPE;
BEGIN
   /* Get the address from the user. */
   prompt_for_address (address_string);

   /* Assign a query to the cursor variable based on the address. */
   open_site_list (address_string, building_curvar);

   /* Give it a try! Fetch a row into the home record. */
   FETCH building_curvar INTO home_rec;

   /* If I got here, the site was a home, so display it. */
   show_home_site (home_rec);
EXCEPTION
   /* If the first record was not a home... */
   WHEN ROWTYPE_MISMATCH
   THEN
      /* Fetch that same 1st row into the commercial record. */
      FETCH building_curvar INTO commercial_rec;

      /* Show the commercial site info. */
      show_commercial_site (commercial_rec);
END;<A
CLASS="indexterm"
NAME="AUTOID-6109"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-6110"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-6111"
></A
>
<A
CLASS="indexterm"
NAME="AUTOID-6112"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.6"
>6.12.6 Rules for Cursor Variables</A
></H3
><P
CLASS="para"
>This section examines in more detail the rules and issues regarding the use of cursor variables in your programs. This includes rowtype matching rules, cursor variable aliases, and scoping issues. </P
><P
CLASS="para"
>Remember that the cursor variable is a reference to a cursor object or query in the database. It is not the object itself. A cursor variable is said to "refer to a given query" if either of the following is true: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>An OPEN statement FOR that query was executed with the cursor variable. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A cursor variable was assigned a value from another cursor variable that refers to that query. </P
></LI
></UL
><P
CLASS="para"
>You can perform assignment operations with cursor variables and also pass these variables as arguments to procedures and functions. In order to perform such actions between cursor variables (and to bind a cursor variable to a parameter), the different cursor variables must follow a set of compile-time and runtime rowtype matching rules. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.6.1"
>6.12.6.1 Compile-time rowtype matching rules</A
></H4
><P
CLASS="para"
>These are the rules that PL/SQL follows at compile-time:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Two cursor variables (including procedure parameters) are compatible for assignments and argument passing if any of the following are true: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Both variables (or parameters) are of a strong REF CURSOR type with the same &lt;rowtype_name&gt;. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Both variables (or parameters) are of some weak REF CURSOR type, regardless of the &lt;rowtype_name&gt;. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>One variable (parameter) is of any strong REF CURSOR type, and the other is of any weak REF CURSOR type. </P
></LI
></UL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A cursor variable (parameter) of a strong REF CURSOR type may be OPEN FOR a query that returns a rowtype which is structurally equal to the &lt;rowtype_name&gt; in the original type declaration. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A cursor variable (parameter) of a weak REF CURSOR type may be OPEN FOR any query. The FETCH from such a variable is allowed INTO any list of variables or record structure. </P
></LI
></UL
><P
CLASS="para"
>In other words, if either of the cursor variables are of the weak REF CURSOR type, then the PL/SQL compiler cannot really validate whether the two different cursor variables will be compatible. That will happen at runtime; the rules are covered in the next section. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.6.2"
>6.12.6.2 Run-time rowtype matching rules</A
></H4
><P
CLASS="para"
>These are the rules that PL/SQL follows at run time:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>A cursor variable (parameter) of a weak REF CURSOR type may be made to refer to a query of any rowtype regardless of the query or cursor object to which it may have referred earlier. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A cursor variable (parameter) of a strong REF CURSOR type may be made to refer only to a query which matches structurally the &lt;rowtype_name&gt; of the RETURN clause of the REF CURSOR type declaration. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Two records (or lists of variables) are considered structurally matching with implicit conversions if both of the following are true: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The number of fields is the same in both records (lists).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>For each field in one record (or variable on one list), a corresponding field in the second list (or variable in second list) has the same PL/SQL datatype, or one which can be converted implicitly by PL/SQL to match the first. </P
></LI
></UL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>For a cursor variable (parameter) used in a FETCH statement, the query associated with the cursor variable must structurally match with implicit conversions the record or list of variables of the INTO clause of the FETCH statement. This is, by the way, the same rule used for static cursors. </P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.6.3"
>6.12.6.3 Cursor variable aliases</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6161"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6164"
></A
>If you assign one cursor variable to another cursor variable, those two cursor variables become aliases for the same cursor object. They share the reference to the cursor object (result set of the cursor's query). An action taken against the cursor object through one variable is also available to and reflected in the other variable. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6168"
></A
>The following anonymous block illustrates the way cursor aliases work: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>1  DECLARE
2     TYPE curvar_type IS REF CURSOR;
3     curvar1 curvar_type;
4     curvar2 curvar_type;
5     story fairy_tales%ROWTYPE;
6  BEGIN
7     /* Assign cursor object to curvar1. */
8     OPEN curvar1 FOR SELECT * FROM fairy_tales;
9
10    /* Assign same cursor object to curvar2. */
11    curvar2 := curvar1;
12
13    /* Fetch first record from curvar1. */
14    FETCH curvar1 INTO story;
15
16    /* Fetch second record from curvar2. */
17    FETCH curvar2 INTO story;
18
19    /* Close the cursor object by referencing curvar2. */
20    CLOSE curvar2;
21
22    /* This statement raises INVALID_CURSOR exception! */
23    FETCH curvar1 INTO story;
24 END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following table is an explanation of cursor variable actions.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Lines</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Action</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>1-5</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Declare my weak REF CURSOR type and cursor variable through line 5. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>8</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Creates a cursor object and assigns it to curvar1. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>11 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Assigns that same cursor object to the second cursor variable, curvar2. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>14 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Fetches the first record using the curvar1 variable. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>17 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Fetches the second record using the curvar2 variable. (Notice that it doesn't matter which of the two variables you use. The pointer to the current record resides with the cursor object, not any particular variable.) </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>20</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Closes the cursor object referencing curvar2. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>23</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Raises the INVALID_CURSOR exception when I try to fetch again from the cursor object. (When I closed the cursor through curvar2, it also closed it as far as curvar1 was concerned.) </P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Any change of state in a cursor object will be seen through any cursor variable which is an alias to that cursor object. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.6.4"
>6.12.6.4 Scope of cursor object</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6223"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6226"
></A
>The scope of a cursor variable is the same as that of a static cursor: the PL/SQL block in which the variable is declared (unless declared in a package, which makes the variable globally accessible). The scope of the cursor object to which a cursor variable is assigned, however, is a different matter. </P
><P
CLASS="para"
>Once an OPEN FOR creates a cursor object, that cursor object remains accessible as long as at least one active cursor variable refers to that cursor object. This means that you can create a cursor object in one scope (PL/SQL block) and assign it to a cursor variable. Then, by assigning that cursor variable to another cursor variable with a different scope, the cursor object remains accessible even if the original cursor variable has gone out of scope. </P
><P
CLASS="para"
>In the following example I use nested blocks to demonstrate how the cursor object can persist outside of the scope in which it was originally created: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   /* Define weak REF CURSOR type, cursor variable
      and local variable */
   TYPE curvar_type IS REF CURSOR;
   curvar1 curvar_type;
   do_you_get_it VARCHAR2(100);
BEGIN
   /*
   || Nested block which creates the cursor object and
   || assigns it to the curvar1 cursor variable.
   */
   DECLARE
      curvar2 curvar_type;
   BEGIN
      OPEN curvar2 FOR SELECT punch_line FROM jokes;
      curvar1 := curvar2;
   END;
   /*
   || The curvar2 cursor variable is no longer active,
   || but &quot;the baton&quot; has been passed to curvar1, which
   || does exist in the enclosing block. I can therefore
   || fetch from the cursor object, through this other
   || cursor variable.
   */
   FETCH curvar1 INTO do_you_get_it;
END;</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.7"
>6.12.7 Passing Cursor Variables as Arguments</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6235"
></A
>You can pass a cursor variable as an argument in a call to a procedure or function. When you use a cursor variable in the parameter list of a program, you need to specify the mode of the parameter and the datatype (the REF CURSOR type). </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.7.1"
>6.12.7.1 Identifying the REF CURSOR type</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6241"
></A
>In your program header, you must identify the REF CURSOR type of your cursor variable parameter. To do this, that cursor type must already be defined. </P
><P
CLASS="para"
>If you are creating a local module within another program (see <A
CLASS="xref"
HREF="ch15_01.htm"
>Chapter 15</A
> for more information about local modules), then you can also define the cursor type in the same program. It will then be available for the parameter. This approach is shown below: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   /* Define the REF CURSOR type. */
   TYPE curvar_type IS REF CURSOR RETURN company%ROWTYPE;

   /* Reference it in the parameter list. */
   PROCEDURE open_query (curvar_out OUT curvar_type)
   IS
      local_cur curvar_type;
   BEGIN
      OPEN local_cur FOR SELECT * FROM company;
      curvar_out := local_cur;
   END;
BEGIN
   ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you are creating a standalone procedure or function, then the only way you can reference a pre-existing REF CURSOR type is by placing that type statement in a package. All variables declared in the specification of a package act as globals within your session, so you can then reference this cursor type using the dot notation as shown below: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Create the package with a REF CURSOR type declaration:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE company
IS
   /* Define the REF CURSOR type. */
   TYPE curvar_type IS REF CURSOR RETURN company%ROWTYPE;
END package;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In a standalone procedure, reference the REF CURSOR type by prefacing the name of the cursor type with the name of the package: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE open_company (curvar_out OUT company.curvar_type) IS
BEGIN
   ...
END;</PRE
></BLOCKQUOTE
></LI
></OL
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch16_01.htm"
>Chapter 16</A
> for more information on this feature.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.7.2"
>6.12.7.2 Setting the parameter mode</A
></H4
><P
CLASS="para"
>Just like other parameters, a cursor variable argument can have one of the following three modes: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>IN</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Can only be read by program</P
></DD
><DT
CLASS="term"
>OUT</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Can only be written to by program</P
></DD
><DT
CLASS="term"
>IN OUT</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Read/write in program</P
></DD
></DL
><P
CLASS="para"
>Remember that the value of a cursor variable is the reference to the cursor object and not the state of the cursor object. In other words, the value of a cursor variable does not change after you fetch from or close a cursor. </P
><P
CLASS="para"
>Only two operations, in fact, may change the value of a cursor variable change, that is, the cursor object to which the variable points: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>An assignment to the cursor variable</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An OPEN FOR statement</P
></LI
></UL
><P
CLASS="para"
>If the cursor variable already pointed to a cursor object, then the OPEN FOR wouldn't actually change the reference. It would simply change the query associated with the object. </P
><P
CLASS="para"
>The FETCH and CLOSE operations affect the state of the cursor object, but not the reference to the cursor object itself, which is the value of the cursor variable. </P
><P
CLASS="para"
>Here is an example of a program which has cursor variables as parameters: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE assign_curvar
   (old_curvar_in IN company.curvar_type,
    new_curvar_out OUT company.curvar_type)
IS
BEGIN
   new_curvar_out := old_curvar_in;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This procedure copies the old company cursor variable to the new variable. The first parameter is an IN parameter because it appears only on the right-hand side of the assignment. The second parameter must be an OUT (or IN OUT) parameter, because its value is changed inside the procedure. Notice that the curvar_type is defined within the company package. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-12.8"
>6.12.8 Cursor Variable Restrictions</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6288"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6292"
></A
> Cursor variables are subject to the following restrictions; Oracle may remove some of these in future releases. </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Cursor variables cannot be declared in a package since they do not have a persistent state. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot use RPCs (Remote Procedure Calls) to pass cursor variables from one server to another. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you pass a cursor variable as a bind or host variable to PL/SQL, you will not be able to fetch from it from within the server unless you also open it in that same server call. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The query you associate with a cursor variable in an OPEN-FOR statement cannot use the FOR UPDATE clause. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot test for cursor variable equality, inequality, or nullity using comparison operators. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot assign NULLs to a cursor variable.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Database columns cannot store cursor variable values. You will not be able to use REF CURSOR types to specify column types in statements to CREATE TABLEs or CREATE VIEWs. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The elements in a nested table, index-by table, or variable array (VARRAY) cannot store the values of cursor variables. You will not be able to use REF CURSOR types to specify the element type of a collection. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Cursor variables cannot be used with dynamic SQL (through use of the DBMS_SQL package).<A
CLASS="indexterm"
NAME="AUTOID-6315"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-6316"
></A
> </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_11.htm#SQL2-CH-6-SECT-11.1"
TITLE="6.11 SELECT FOR UPDATE in Cursors"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.11 SELECT FOR UPDATE in Cursors"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_13.htm#SQL2-CH-6-SECT-13.2"
TITLE="6.13 Working with Cursors "
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.13 Working with Cursors "
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.11 SELECT FOR UPDATE in Cursors</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.13 Working with Cursors </TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
