<HTML
><HEAD
><TITLE
>[Chapter 6] 6.9 Cursor Attributes</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:56:44Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. Database Interaction and Cursors"><LINK
REL="prev"
HREF="ch06_08.htm"
TITLE="6.8 Closing Cursors"><LINK
REL="next"
HREF="ch06_10.htm#SQL2-CH-6-SECT-10.2"
TITLE="6.10 Cursor Parameters"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_08.htm"
TITLE="6.8 Closing Cursors"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.8 Closing Cursors"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch06_01.htm"
TITLE="6. Database Interaction and Cursors"
>Chapter 6<BR>Database Interaction and Cursors</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_10.htm#SQL2-CH-6-SECT-10.2"
TITLE="6.10 Cursor Parameters"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.10 Cursor Parameters"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-9"
>6.9 Cursor Attributes</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-104751-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-104751-2"
></A
>You can manipulate cursors using the OPEN, FETCH, and CLOSE statements. When you need to get information about the current status of your cursor, or the result of the last fetch from a cursor, you will access cursor attributes. </P
><P
CLASS="para"
>Both explicit and implicit cursors have four attributes, as shown in <A
CLASS="xref"
HREF="ch06_09.htm#SQL2-CH-6-SECT-9.1"
>Table 6.1</A
>. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-6-TABLE-6"
>Table 6.1: Cursor Attributes </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Name</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>%FOUND</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns TRUE if record was fetched successfully, FALSE otherwise.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>%NOTFOUND</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns TRUE if record was not fetched successfully, FALSE otherwise.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>%ROWCOUNT </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns number of records fetched from cursor at that point in time.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>%ISOPEN</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns TRUE if cursor is open, FALSE otherwise.</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>To obtain information about the execution of the cursor, you append the cursor attribute name to the name of your cursor. For example, if you declare a cursor as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CURSOR caller_cur IS
   SELECT caller_id, company_id FROM caller;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>then the four attributes associated with the cursor are:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>caller_cur%FOUND
caller_cur%NOTFOUND
caller_cur%ROWCOUNT
caller_cur%ISOPEN</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Some of the ways you can access the attributes of an explicit cursor are shown below in bold: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR caller_cur IS
      SELECT caller_id, company_id FROM caller;
   caller_rec caller_cur%ROWTYPE;
BEGIN
   /* Only open the cursor if it is not yet open */
   IF NOT <B
CLASS="emphasis.bold"
>caller_cur%ISOPEN</B
>
   THEN
      OPEN caller_cur
   END IF;
   FETCH caller_cur INTO caller_rec;

   /* Keep fetching until no more records are FOUND */
   WHILE <B
CLASS="emphasis.bold"
>caller_cur%FOUND</B
>
   LOOP
      DBMS_OUTPUT.PUT_LINE
         ('Just fetched record number ' ||
          TO_CHAR <B
CLASS="emphasis.bold"
>(caller_cur%ROWCOUNT));</B
>
      FETCH caller_cur INTO caller_rec;
   END LOOP;
   <B
CLASS="emphasis.bold"
>CLOSE caller_cur;</B
>
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5663"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5666"
></A
>PL/SQL does provide these same attributes for an implicit cursor. Because an implicit cursor has no name, PL/SQL assigns the generic name SQL to it. Using this name, you can access the attributes of an implicit cursor. For more information on this topic, see <A
CLASS="xref"
HREF="ch06_09.htm#SQL2-CH-6-SECT-9.1"
>Section 6.9.5, "Implicit SQL Cursor Attributes"</A
> later in the chapter. </P
><P
CLASS="para"
>You can reference cursor attributes in your PL/SQL code, as shown in the preceding example, but you cannot use those attributes inside a SQL statement. If you try to use the %ROWCOUNT attribute in the WHERE clause of a SELECT, for example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT caller_id, company_id
  FROM caller
 WHERE company_id = company_cur%ROWCOUNT;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5673"
></A
>then you will get a compile error: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLS-00229: Attribute expression within SQL expression</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The four explicit cursor attributes are examined in detail in the following sections. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-9.1"
>6.9.1 The %FOUND Attribute</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5681"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5683"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-104754-3"
></A
>The %FOUND attribute reports on the status of your most recent FETCH against the cursor. The attribute evaluates to TRUE if the most recent FETCH against the explicit cursor returned a row, or FALSE if no row was returned. </P
><P
CLASS="para"
>If the cursor has not yet been opened, a reference to the %FOUND attribute raises the INVALID_CURSOR exception. You can evaluate the %FOUND attribute of any open cursor, because you reference the cursor by name. </P
><P
CLASS="para"
>In the following example, I loop through all the callers in the caller_cur cursor, assign all calls entered before today to that particular caller, and then fetch the next record. If I have reached the last record, then the %NOTFOUND attribute is set to TRUE and I exit the simple loop. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OPEN caller_cur;
LOOP
   FETCH caller_cur INTO caller_rec;
   EXIT WHEN NOT caller_cur%FOUND;

   UPDATE call
      SET caller_id = caller_rec.caller_id
    WHERE call_timestamp &lt; SYSDATE;
END LOOP;
CLOSE call_cur;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this next example, I keep a count of the total number of orders entered for a particular company. If I have fetched my last order (%FOUND is FALSE), then I display a message in Oracle Forms informing the user of the total number of orders: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OPEN order_cur;
LOOP
   FETCH order_cur INTO order_number, company_id;
   EXIT WHEN order_cur%NOTFOUND;
   do_other_stuff_then_keep_count;
   :order.count_orders := :order.count_orders + 1;
END LOOP;
CLOSE order_cur;

IF :order.count_orders &gt; 1
THEN
   DBMS_OUTPUT.PUT_LINE
      ('A total of ' || TO_CHAR (:order.count_orders) ||
       ' orders have been found.');
ELSE
   /*
   || I hate to code messages like 'A total of 1 orders was found.'
   || It makes me sound illiterate. So I will include a special-case
   || message when just one order is found.
   */
   DBMS_OUTPUT.PUT_LINE('Just one order was found.');
END IF;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-9.2"
>6.9.2 The %NOTFOUND Attribute</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5699"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5703"
></A
>The %NOTFOUND attribute is the opposite of %FOUND. It returns TRUE if the explicit cursor is unable to fetch another row because the last row was fetched. If the cursor is unable to return a row because of an error, the appropriate exception is raised. If the cursor has not yet been opened, a reference to the %NOTFOUND attribute raises the INVALID_CURSOR exception. You can evaluate the %NOTFOUND attribute of any open cursor, because you reference the cursor by name. </P
><P
CLASS="para"
>When should you use %FOUND and when should you use %NOTFOUND? The two attributes are directly, logically opposed, so whatever you can do with one you can also do with a NOT of the other. In other words, once a fetch has been performed against the open cursor &lt;cursor_name&gt;, the following expressions are equivalent: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;cursor_name&gt;%FOUND						= NOT &lt;cursor_name&gt;%NOTFOUND
&lt;cursor_name&gt;%NOTFOUND						= NOT &lt;cursor_name&gt;%FOUND</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Use whichever formulation fits most naturally in your code. In a previous example, I issued the following statement: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXIT WHEN NOT caller_cur%FOUND;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>to terminate the loop. <A
CLASS="indexterm"
NAME="AUTOID-5710"
></A
> A simpler and more direct statement would use the %NOTFOUND instead of %FOUND, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXIT WHEN caller_rec%NOTFOUND;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-9.3"
>6.9.3 The %ROWCOUNT Attribute</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5715"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5717"
></A
>The %ROWCOUNT attribute returns the number of records fetched from a cursor at the time that the attribute is queried. When you first open a cursor, its %ROWCOUNT is set to zero. If you reference the %ROWCOUNT attribute of a cursor that is not open, you will raise the INVALID_CURSOR exception. After each record is fetched, %ROWCOUNT is increased by one. This attribute can be referenced in a PL/SQL statement, but not in a SQL statement. </P
><P
CLASS="para"
>You can use %ROWCOUNT to limit the number of records fetched from a cursor. The following example retrieves only the first ten records from the cursor, providing the top ten companies placing orders in 1993: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR company_cur IS
      SELECT company_name, company_id, total_order
        FROM company_revenue_view
       WHERE TO_NUMBER (TO_CHAR (order_date)) = 1993
       ORDER BY total_order DESC;
   company_rec company_cur%ROWTYPE;
BEGIN
OPEN company_cur;
LOOP
   FETCH company_cur INTO company_rec;
   EXIT WHEN company_cur%ROWCOUNT &gt; 10 OR
             company_cur%NOTFOUND;

   DBMS_OUTPUT.PUT_LINE
      ('Company ' || company_rec.company_name ||
       ' ranked number ' || TO_CHAR (company_cur%ROWCOUNT) || '.');
END LOOP;
CLOSE company_cur;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-9.4"
>6.9.4 The %ISOPEN Attribute</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5726"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5728"
></A
>The %ISOPEN attribute returns TRUE if the cursor is open; otherwise, it returns FALSE. In most cases when you use a cursor, you open it, fetch from it, and close it, all within one routine. Most of the time it is easy to know whether your cursor is open or closed. In some cases, however, you will spread your cursor actions out over a wider area of code, perhaps across different routines (possible if the cursor is declared in a package). If so, it will make sense to use the %ISOPEN attribute to make sure that a cursor is open before you perform a fetch: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF NOT caller_cur%ISOPEN
THEN
   OPEN caller_cur;
END IF;
FETCH caller_cur INTO caller_rec;
...</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> <A
CLASS="indexterm"
NAME="AUTOID-5735"
></A
>Remember that if you try to open a cursor that has already been opened, you will receive a runtime error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-06511: PL/SQL: cursor already open</PRE
></BLOCKQUOTE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-9.5"
>6.9.5 Implicit SQL Cursor Attributes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5742"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5745"
></A
> When the RDBMS opens an implicit cursor to process your request (whether it is a query or an INSERT or an UPDATE), it makes cursor attributes available to you with the SQL cursor. This is not a cursor in the way of an explicit cursor. You cannot open, fetch from, or close the SQL cursor, but you can access information about the most recently executed SQL statement through SQL cursor attributes. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5749"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5751"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5753"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5755"
></A
>The SQL cursor has the same four attributes as an explicit cursor: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL%FOUND
SQL%NOTFOUND
SQL%ROWCOUNT
SQL%ISOPEN </PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-6-SECT-9.6"
>6.9.6 Differences Between Implicit and Explicit Cursor Attributes</A
></H3
><P
CLASS="para"
>The values returned by implicit cursor attributes differ from those of explicit cursor attributes in the following ways: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If the RDBMS has not opened an implicit SQL cursor in the session, then the SQL%ROWCOUNT attribute returns NULL instead of raising the INVALID_CURSOR error. References to the other attributes (ISOPEN, FOUND, NOTFOUND) all return FALSE. You will never raise the INVALID_CURSOR error with an implicit cursor attribute reference. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The %ISOPEN attribute will always return FALSE&nbsp;-- before and after the SQL statement. After the statement is executed (whether it is SELECT, UPDATE, DELETE, or INSERT), the implicit cursor will already have been opened and closed implicitly. An implicit cursor can never be open outside of the statement itself. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>SQL cursor attributes are always set according to the results of the most recently executed SQL statement. That SQL statement might have been executed in a stored procedure which your program called; you might not even be aware of that SQL statement execution. If you plan to make use of a SQL cursor attribute, make sure that you reference that attribute immediately after you execute the SQL statement. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The %FOUND attribute returns TRUE if an UPDATE, DELETE, or INSERT affected at least one record. It will return FALSE if those statements failed to affect any records. It returns TRUE if an implicit SELECT returns one row. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The behavior of the %NOTFOUND attribute for UPDATE, DELETE, or INSERT statements is the opposite of %FOUND. The situation for an implicit SELECT is a bit different: when you use an implicit SELECT statement, never rely on the %NOTFOUND and %FOUND attributes. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When an implicit SELECT statement does not return any rows, PL/SQL immediately raises the NO_DATA_FOUND exception. When an implicit SELECT statement returns more than one row, PL/SQL immediately raises the TOO_MANY_ROWS exception. <A
CLASS="indexterm"
NAME="AUTOID-5774"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5775"
></A
> In either case, once the exception is raised, control shifts to the exception section of the PL/SQL block. </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_08.htm"
TITLE="6.8 Closing Cursors"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.8 Closing Cursors"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_10.htm#SQL2-CH-6-SECT-10.2"
TITLE="6.10 Cursor Parameters"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.10 Cursor Parameters"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.8 Closing Cursors</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.10 Cursor Parameters</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
