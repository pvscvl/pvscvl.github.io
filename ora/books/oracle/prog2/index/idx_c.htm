<HTML>

<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
<HEAD>
<TITLE>Index</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<P><A HREF="../index.htm"><IMG SRC="../gifs/smbanns.gif" ALT="Book Home" BORDER=0 usemap="#srchmap"><MAP NAME="srchmap"><AREA SHAPE="RECT" COORDS="0,0,466,65" HREF="../index.htm" ALT="Book Home"><AREA SHAPE="RECT" COORDS="467,0,514,18" HREF="../jobjects/fsearch.htm" ALT="Search this book"></MAP></A><P><P>

<FONT SIZE="-1">
<A HREF="idx_0.htm">Symbols</A>
| <A HREF="idx_a.htm">A</A>
| <A HREF="idx_b.htm">B</A>
| C
| <A HREF="idx_d.htm">D</A>
| <A HREF="idx_e.htm">E</A>
| <A HREF="idx_f.htm">F</A>
| <A HREF="idx_g.htm">G</A>
| <A HREF="idx_h.htm">H</A>
| <A HREF="idx_i.htm">I</A>
| <A HREF="idx_j.htm">J</A>
| <A HREF="idx_k.htm">K</A>
| <A HREF="idx_l.htm">L</A>
| <A HREF="idx_m.htm">M</A>
| <A HREF="idx_n.htm">N</A>
| <A HREF="idx_o.htm">O</A>
| <A HREF="idx_p.htm">P</A>
| <A HREF="idx_q.htm">Q</A>
| <A HREF="idx_r.htm">R</A>
| <A HREF="idx_s.htm">S</A>
| <A HREF="idx_t.htm">T</A>
| <A HREF="idx_u.htm">U</A>
| <A HREF="idx_v.htm">V</A>
| <A HREF="idx_w.htm">W</A>
| <A HREF="idx_y.htm">Y</A>
| <A HREF="idx_z.htm">Z</A></FONT>

<H1>Index: C</H1>

<DL>
<DT><A NAME="calendar">calendar</A>
: (see <A HREF="idx_d.htm">date</A>)
<DT><A NAME="case">case</A>
<DD><DL>
  <DT>consistency of
: <A HREF="../ch22_07.htm#SQL2-CH-22-SECT-7.2">22.7.4. Ensure Case Consistency of Parameters</A>
  <DT>INITCAP function
: <A HREF="../ch11_01.htm">11.1.4. The INITCAP function</A>
  <DT>LOWER function
: <A HREF="../ch11_01.htm">11.1.7. The LOWER function</A>
  <DT>and readability
: <A HREF="../ch03_01.htm">3.1.2. Using Case to Aid Readability</A>
  <DT>sensitivity
  <DD><DL>
    <DT><A HREF="../ch02_01.htm">2.1. The PL/SQL Character Set</A>
    <DT><A HREF="../ch02_03.htm#SQL2-CH-2-SECT-3.1">2.3. Literals</A>
  </DL>
  <DT>UPPER function
: <A HREF="../ch11_01.htm">11.1.16. The UPPER function</A>
</DL>
<DT><A NAME="cast-procedure">CAST procedure</A>
<DD><DL>
  <DT>object views and
: <A HREF="../ch20_01.htm">20.1. Example: Using Object Views</A>
</DL>
<DT><A NAME="cast-pseudo.2dfunction">CAST pseudo-function</A>
: <A HREF="../ch19_05.htm#SQL2-CH-19-SECT-5.2">19.5.2. The CAST Pseudo-function</A>
<DT><A NAME="casting-collections">casting collections</A>
: <A HREF="../ch19_05.htm#SQL2-CH-19-SECT-5.2">19.5.2.1. Casting a named collection</A>
<DT><A NAME="cde">CDE</A>
: (see <A HREF="idx_c.htm">Cooperative Development Environment</A>)
<DT><A NAME="ceil">CEIL (ceiling) function</A>
: <A HREF="../ch13_01.htm">13.1.6. The CEIL function</A>
<DT><A NAME="century">century</A>
: (see <A HREF="idx_d.htm">date</A>)
<DT><A NAME="change-procedure">CHANGE procedure</A>
: <A HREF="../appc_05.htm#SQL2-AP-C-SECT-5.0.2">C.5.2. The CHANGE procedure</A>
<DT><A NAME="char-datatype">CHAR datatype</A>
<DD><DL>
  <DT><A HREF="../ch02_03.htm#SQL2-CH-2-SECT-3.1">2.3. Literals</A>
  <DT><A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.3.1. The CHAR datatype</A>
  <DT>converting to VARCHAR2
: <A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.3.2. The VARCHAR2 and VARCHAR datatypes</A>
  <DT>converting to/from ROWID
  <DD><DL>
    <DT><A HREF="../ch14_02.htm#SQL2-CH-14-SECT-2.0.1">14.2.1. The CHARTOROWID function</A>
    <DT><A HREF="../ch14_02.htm#SQL2-CH-14-SECT-2.0.1">14.2.5. The ROWIDTOCHAR function</A>
  </DL>
  <DT>with LENGTH function
: <A HREF="../ch11_01.htm">11.1.6. The LENGTH function</A>
</DL>
<DT><A NAME="character-datatypes">character datatypes</A>,

in overloaded modules
: <A HREF="../ch15_08.htm#SQL2-CH-15-SECT-8.4">15.8.4. Restrictions on Overloading</A>

<DT><A NAME="character-functions">character functions</A>
: <A HREF="../ch11_01.htm">11. Character Functions</A>
<DT><A NAME="character-sets">character sets</A>
: <A HREF="../ch14_02.htm#SQL2-CH-14-SECT-2.0.1">14.2.2. The CONVERT function</A>
<DT><A NAME="characters">characters</A>
<DD><DL>
  <DT>adding to strings
: <A HREF="../ch11_01.htm">11.1.11. The RPAD function</A>
  <DT>converting to numbers, package for
: <A HREF="../ch17_08.htm#SQL2-CH-17-SECT-8.4">17.8.7. Recursive Processing in a SQL Statement</A>
  <DT>datatypes for
: <A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.3. Character Datatypes</A>
  <DT>extracting from strings
: <A HREF="../ch11_01.htm">11.1.14. The SUBSTR function</A>
  <DT>NLS datatypes for
: <A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.6. NLS Character Datatypes</A>
  <DT>replacing in strings
  <DD><DL>
    <DT><A HREF="../ch11_01.htm">11.1.10. The REPLACE function</A>
    <DT><A HREF="../ch11_01.htm">11.1.15. The TRANSLATE function</A>
  </DL>
  <DT>stripping from strings
  <DD><DL>
    <DT><A HREF="../ch11_01.htm">11.1.12. The RTRIM function</A>
    <DT><A HREF="../ch11_01.htm">11.1.9. The LTRIM function</A>
  </DL>
  <DT>word wrap
: <A HREF="../ch11_02.htm#SQL2-CH-11-SECT-2.4">11.2.2. Implementing Word Wrap for Long Text</A>
</DL>
<DT><A NAME="charsetform-property">CHARSETFORM property</A>
: <A HREF="../ch21_04.htm#ch21-26-fm2xml">21.4.3.4. CHARSETID and   CHARSETFORM properties</A>
<DT><A NAME="charsetid-property">CHARSETID property</A>
: <A HREF="../ch21_04.htm#ch21-26-fm2xml">21.4.3.4. CHARSETID and   CHARSETFORM properties</A>
<DT><A NAME="chartorowid-function">CHARTOROWID function</A>
: <A HREF="../ch14_02.htm#SQL2-CH-14-SECT-2.0.1">14.2.1. The CHARTOROWID function</A>
<DT><A NAME="checking-for-null-values">checking for NULL values</A>
: <A HREF="../ch04_03.htm#SQL2-CH-4-SECT-3.3">4.3.2. Checking for NULL Values</A>
<DT><A NAME="child-block">child block</A>
: (see <A HREF="idx_n.htm">nested blocks</A>)
<DT><A NAME="child-records">child records</A>
: (see <A HREF="idx_r.htm">records</A>)
<DT><A NAME="chr-function">CHR function</A>
: <A HREF="../ch11_01.htm">11.1.2. The CHR function</A>
<DT><A NAME="class-instances">class instances</A>
: <A HREF="../ch18_01.htm">18.1.4.2. Classification </A>
<DT><A NAME="classes">classes</A>
: (see <A HREF="idx_o.htm">object types</A>)
<DT><A NAME="classification-of-objects">classification of objects</A>
: <A HREF="../ch18_01.htm">18.1.4.2. Classification </A>
<DT><A NAME="clearing-tables">clearing tables</A>
: <A HREF="../ch10_07.htm">10.7. Clearing the PL/SQL Table</A>
<DT><A NAME="client.2dside-sql">client-side SQL</A>
: <A HREF="../ch25_03.htm#SQL2-CH-25-SECT-3.4">25.3.3. Avoid Client-Side SQL</A>
<DT><A NAME="clob-datatype">CLOB datatype</A>
<DD><DL>
  <DT><A HREF="../ch01_04.htm#SQL2-CH-1-SECT-4.7.6">1.4.7.6. Large object support</A>
  <DT><A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.7.3. The CLOB datatype</A>
  <DT>EMPTY_CLOB function
: <A HREF="../ch13_02.htm#SQL2-CH-13-SECT-2.0.1">13.2.3. The EMPTY_CLOB function</A>
</DL>
<DT><A NAME="clock">clock</A>
: (see <A HREF="idx_t.htm">time</A>)
<DT><A NAME="close-statement">CLOSE statement</A>
<DD><DL>
  <DT>(see also <A HREF="idx_c.htm">cursors</A>)
  <DT><A HREF="../ch06_02.htm#SQL2-CH-6-SECT-2.2">6.2.2. Cursor Operations</A>
  <DT><A HREF="../ch06_08.htm">6.8. Closing Cursors</A>
</DL>
<DT><A NAME="close.5fcursor-procedure">CLOSE_CURSOR procedure</A>
: <A HREF="../appc_14.htm#SQL2-AP-C-SECT-14.0.2">C.14.3. The CLOSE_CURSOR procedure</A>
<DT><A NAME="close.5fdatabase.5flink-procedure">CLOSE_DATABASE_LINK procedure</A>
: <A HREF="../appc_12.htm#SQL2-AP-C-SECT-12.0.1">C.12.1. The CLOSE_DATABASE_LINK procedure</A>
<DT><A NAME="closing-cursors">closing cursors</A>
: <A HREF="../ch06_08.htm">6.8. Closing Cursors</A>
<DT><A NAME="code">code</A>
<DD><DL>
  <DT>compiled, tuning access to
: <A HREF="../ch25_02.htm#SQL2-CH-25-SECT-2.3">25.2. Tuning Access to Compiled Code</A>
  <DT>critical, pinning into SGA
: <A HREF="../ch25_02.htm#SQL2-CH-25-SECT-2.3">25.2.2. Pin Critical Code into the SGA</A>
  <DT>encrypting
: <A HREF="../ch23_07.htm#SQL2-CH-23-SECT-7.3">23.7. Encrypting Stored Code</A>
  <DT>memory-based architecture
: <A HREF="../ch23_01.htm">23.1.3. Memory-Based Architecture of PL/SQL Code </A>
  <DT>procedural, avoiding
: <A HREF="../ch25_03.htm#SQL2-CH-25-SECT-3.4">25.3.5. Avoid Procedural Code When Possible  </A>
  <DT>repetetive
: (see <A HREF="idx_r.htm">redundancy</A>)
  <DT>reusing
: <A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.1. Write as Little Code as Possible</A>
  <DT>shared, executing
: <A HREF="../ch23_01.htm">23.1. Executing Stored Code</A>
  <DT>structuring of
: <A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.5. Structured Code and Other Best Practices</A>
  <DT>style of
: <A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.4. Standardize Your PL/SQL Development Environment</A>
  <DT>testing
: <A HREF="../ch24_02.htm#SQL2-CH-24-SECT-2.6">24.2.5. Change and Test One Area of Code at a Time</A>
</DL>
<DT><A NAME="coding">coding</A>
: <A HREF="../ch01_02.htm">1.2. The Concept of Programming in Oracle Applications</A>
<DD><DL>
  <DT>analyzing size of
: <A HREF="../ch23_06.htm#SQL2-CH-23-SECT-6.3">23.6.3. Analyzing the Size of PL/SQL Code</A>
  <DT>anticipating errors
: (see <A HREF="idx_e.htm">exceptions</A>)
  <DT>avoiding repetitive
: <A HREF="../ch22_03.htm">22.3. Take Full Advantage of Local Modularization</A>
  <DT>comments in
: (see <A HREF="idx_c.htm">comments</A>)
  <DT>considering parameter case
: <A HREF="../ch22_07.htm#SQL2-CH-22-SECT-7.2">22.7.4. Ensure Case Consistency of Parameters</A>
  <DT>creating independent modules
: <A HREF="../ch22_05.htm#SQL2-CH-22-SECT-5.4">22.5. Create Independent Modules</A>
  <DT>cross-referencing source code
: <A HREF="../ch23_06.htm#SQL2-CH-23-SECT-6.3">23.6.5. Cross-Referencing Source Code</A>
  <DT>in databases
: <A HREF="../ch23_01.htm">23. Managing Code in the Database</A>
  <DT>documenting
: <A HREF="../ch24_02.htm#SQL2-CH-24-SECT-2.6">24.2.6. Document and Back Up Your Efforts</A>
  <DT>errors
: (see <A HREF="idx_e.htm">errors</A>; <A HREF="idx_e.htm">exceptions</A>)
  <DT>finding strings in
: <A HREF="../ch23_06.htm#SQL2-CH-23-SECT-6.3">23.6.4. Displaying and Searching Source Code</A>
  <DT>hints for effective
  <DD><DL>
    <DT><A HREF="../ch01_05.htm">1.5. Advice for Oracle Programmers</A>
    <DT><A HREF="../ch03_01.htm">3. Effective Coding Style</A>
    <DT><A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.8.3. Drawbacks of implicit conversions</A>
    <DT><A HREF="../ch22_01.htm">22. Code Design Tips</A>
    <DT>commenting
: <A HREF="../ch03_06.htm#SQL2-CH-3-SECT-6.4">3.6. Using Comments Effectively</A>
    <DT>exception handling
: <A HREF="../ch08_10.htm">8.10. RAISE Nothing but Exceptions</A>
    <DT>IF statements
: <A HREF="../ch05_01.htm">5.1.4. Nested IF Statements</A>
    <DT>loops
: <A HREF="../ch07_07.htm#SQL2-CH-7-SECT-7.2.2">7.7. Tips for PL/SQL Loops</A>
    <DT>nested records
: <A HREF="../ch09_07.htm">9.7.1. Example of Nested Records</A>
    <DT>parameters
: <A HREF="../ch22_07.htm#SQL2-CH-22-SECT-7.2">22.7. Tips for Parameter Design</A>
    <DT>records
: <A HREF="../ch09_01.htm">9.1.3.3. Leaner, cleaner code</A>
  </DL>
  <DT>increasing readability of code
: <A HREF="../ch05_02.htm#SQL2-CH-5-SECT-2.1">5.2.2.1. Improving the readability of your program </A>
  <DT>layout of
: <A HREF="../ch03_01.htm">3.1. Fundamentals of Effective Layout</A>
  <DT>recursive processing
: <A HREF="../ch17_08.htm#SQL2-CH-17-SECT-8.4">17.8.7. Recursive Processing in a SQL Statement</A>
  <DT>removing unused variables
: <A HREF="../ch04_07.htm#SQL2-CH-4-SECT-7.7">4.7.6. Remove Unused Variables from Programs</A>
  <DT>sequential processing
: <A HREF="../ch17_08.htm#SQL2-CH-17-SECT-8.4">17.8.6. Sequential Processing Against a Column's Value</A>
  <DT>simplifying logic with variables
: <A HREF="../ch04_07.htm#SQL2-CH-4-SECT-7.7">4.7.9. Use Variables to Hide Complex Logic</A>
  <DT>testing programs
: <A HREF="../ch02_05.htm#SQL2-CH-2-SECT-5.1">2.5.2. Multiline Comment Syntax</A>
</DL>
<DT><A NAME="collections">collections</A>
<DD><DL>
  <DT>adding/removing elements from
: <A HREF="../ch19_04.htm#SQL2-CH-19-SECT-4.1.3">19.4.3. Adding and Removing Elements</A>
  <DT>built-in methods for
: <A HREF="../ch19_06.htm#SQL2-CH-19-SECT-6.0.5">19.6. Collection Built-Ins</A>
  <DT>casting
: <A HREF="../ch19_05.htm#SQL2-CH-19-SECT-5.2">19.5.2.1. Casting a named collection</A>
  <DT>choosing which kind to use
: <A HREF="../ch19_09.htm">19.9. Which Collection Type Should I Use?</A>
  <DT>collection variables
  <DD><DL>
    <DT><A HREF="../ch19_02.htm#SQL2-CH-19-SECT-2.1.1">19.2.2.1. Collection variables</A>
    <DT><A HREF="../ch19_04.htm#SQL2-CH-19-SECT-4.1.3">19.4.1. Initializing Collection Variables</A>
  </DL>
  <DT>comparing
: <A HREF="../ch19_04.htm#SQL2-CH-19-SECT-4.1.3">19.4.4. Comparing Collections</A>
  <DT>creating
: <A HREF="../ch19_02.htm#SQL2-CH-19-SECT-2.1.1">19.2. Creating the New Collections</A>
  <DT>data dictionary entries for
: <A HREF="../ch19_08.htm#SQL2-CH-19-SECT-8.1">19.8.2. Data Dictionary</A>
  <DT>declaring as datatype
: <A HREF="../ch19_02.htm#SQL2-CH-19-SECT-2.1.1">19.2.2. Collections in PL/SQL</A>
  <DT>index-by tables
: (see <A HREF="idx_i.htm">index-by tables</A>)
  <DT>nested tables
: (see <A HREF="idx_n.htm">nested tables</A>)
  <DT>passing arguments of
: <A HREF="../ch19_08.htm#SQL2-CH-19-SECT-8.1">19.8.3. Call by Reference or Call by Value</A>
  <DT>PL/SQL-to-server integration example
: <A HREF="../ch19_07.htm">19.7. Example: PL/SQL-to-Server Integration</A>
  <DT>privileges
: <A HREF="../ch19_08.htm#SQL2-CH-19-SECT-8.1">19.8.1. Privileges</A>
  <DT>pseudo-functions
: <A HREF="../ch19_05.htm#SQL2-CH-19-SECT-5.2">19.5. Collection Pseudo-Functions</A>
  <DT>types of
: <A HREF="../ch19_01.htm">19.1. Types of Collections</A>
  <DT>VARRAYs
: (see <A HREF="idx_v.htm">VARRAYs</A>)
</DL>
<DT><A NAME="column.5fvalue-procedure">COLUMN_VALUE procedure</A>
: <A HREF="../appc_14.htm#SQL2-AP-C-SECT-14.0.2">C.14.4. The COLUMN_VALUE procedure</A>
<DT><A NAME="columns">columns</A>
<DD><DL>
  <DT>(see also <A HREF="idx_r.htm">records</A>)
  <DT><A HREF="../ch09_01.htm">9.1.1. Different Types of Records</A>
  <DT>abbreviations for
: <A HREF="../ch03_02.htm">3.2. Formatting SQL Statements</A>
  <DT>aliases for
  <DD><DL>
    <DT><A HREF="../ch03_02.htm">3.2. Formatting SQL Statements</A>
    <DT><A HREF="../ch06_07.htm">6.7. Column Aliases in Cursors</A>
    <DT><A HREF="../ch09_03.htm#SQL2-CH-9-SECT-3.2">9.3.2. Setting the Record's Column Names</A>
  </DL>
  <DT>BFILE, initializing
: <A HREF="../ch13_02.htm#SQL2-CH-13-SECT-2.0.1">13.2.1. The BFILENAME function</A>
  <DT>choosing for cursor-based record
: <A HREF="../ch09_03.htm#SQL2-CH-9-SECT-3.2">9.3.1. Choosing Columns for a Cursor Record</A>
  <DT>collections as
: <A HREF="../ch19_02.htm#SQL2-CH-19-SECT-2.1.1">19.2.1.1. Collection as a "column" in a conventional table</A>
  <DT>collections as datatypes for
: <A HREF="../ch19_01.htm">19.1. Types of Collections</A>
  <DT>names for
: <A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.5. Structured Code and Other Best Practices</A>
  <DT>naming procedure
: <A HREF="../ch17_06.htm">17.6. Column/Function Name Precedence</A>
  <DT>objects for
: <A HREF="../ch18_01.htm">18.1.2. Some Simple Examples</A>
  <DD><DL>
    <DT>VALUE operator with
: <A HREF="../ch18_04.htm#SQL2-CH-18-SECT-4.1.3">18.4.2.3. VALUE</A>
  </DL>
  <DT>partial values of
: <A HREF="../ch17_08.htm#SQL2-CH-17-SECT-8.4">17.8.5. GROUP BY Partial Column Values</A>
  <DT>represented by variables
: <A HREF="../ch04_07.htm#SQL2-CH-4-SECT-7.7">4.7.7. Use %TYPE When a Variable Represents a Column</A>
  <DT>sequential processing against value
: <A HREF="../ch17_08.htm#SQL2-CH-17-SECT-8.4">17.8.6. Sequential Processing Against a Column's Value</A>
  <DT>synchronization with
: <A HREF="../ch04_05.htm">4.5.1.1. Synchronization with database columns</A>
  <DT>where OIDS are stored
: <A HREF="../ch18_04.htm#SQL2-CH-18-SECT-4.1.3">18.4.2.1. Object identifiers (OIDs)</A>
</DL>
<DT><A NAME="comma.5fto.5ftable-procedure">COMMA_TO_TABLE procedure</A>
: <A HREF="../appc_16.htm#appc-133-fm2xml">C.16.2. The  COMMA_TO_TABLE procedure</A>
<DT><A NAME="comment-keyword">COMMENT keyword</A>
: <A HREF="../ch06_01.htm">6.1.1. The COMMIT Statement</A>
<DT><A NAME="comments">comments</A>
: <A HREF="../ch02_05.htm#SQL2-CH-2-SECT-5.1">2.5. Comments</A>
<DD><DL>
  <DT>associated with transactions
: <A HREF="../ch06_01.htm">6.1.1. The COMMIT Statement</A>
  <DT>describing parameters
: <A HREF="../ch22_07.htm#SQL2-CH-22-SECT-7.2">22.7.1. Document All Parameters and Their Functions</A>
  <DT>encrypted code and
: <A HREF="../ch23_07.htm#SQL2-CH-23-SECT-7.3">23.7.3. Impact of Encrypting Code</A>
  <DT>symbols for
: <A HREF="../ch02_01.htm">2.1. The PL/SQL Character Set</A>
  <DT>using effectively
: <A HREF="../ch03_06.htm#SQL2-CH-3-SECT-6.4">3.6. Using Comments Effectively</A>
</DL>
<DT><A NAME="commit-procedure">COMMIT procedure</A>
<DD><DL>
  <DT>(see also <A HREF="idx_d.htm">DBMS_PIPE</A>)
  <DT><A HREF="../appc_10.htm">C.10. DBMS_PIPE</A>
  <DT><A HREF="../appc_15.htm#appc-127-fm2xml">C.15.4. The  COMMIT procedure </A>
</DL>
<DT><A NAME="commit-statement">COMMIT statement</A>
<DD><DL>
  <DT><A HREF="../ch06_01.htm">6.1.1. The COMMIT Statement</A>
  <DT><A HREF="../ch06_11.htm#SQL2-CH-6-SECT-11.1">6.11.1. Releasing Locks with COMMIT</A>
</DL>
<DT><A NAME="commit.5fcomment-procedure">COMMIT_COMMENT procedure</A>
: <A HREF="../appc_15.htm#appc-127-fm2xml">C.15.5. The  COMMIT_COMMENT procedure </A>
<DT><A NAME="commit.5fforce-procedure">COMMIT_FORCE procedure</A>
: <A HREF="../appc_15.htm#appc-127-fm2xml">C.15.6. The  COMMIT_FORCE procedure</A>
<DT><A NAME="companion-utilities-guide">Companion Utilities Guide</A>
: <A HREF="../appa_01.htm">A. What's on the Companion Disk?</A>
<DT><A NAME="compare-function">COMPARE function</A>
: <A HREF="../appc_06.htm#appc-35-fm2xml">C.6.2. The  COMPARE function</A>
<DT><A NAME="comparing">comparing</A>
<DD><DL>
  <DT>collections
: <A HREF="../ch19_04.htm#SQL2-CH-19-SECT-4.1.3">19.4.4. Comparing Collections</A>
  <DT>with NULL
: <A HREF="../ch04_03.htm#SQL2-CH-4-SECT-3.3">4.3. NULLs in PL/SQL</A>
  <DT>objects
: <A HREF="../ch18_03.htm#SQL2-CH-18-SECT-3.6.1">18.3.6. Comparing Objects</A>
  <DT>records
: <A HREF="../ch09_01.htm">9.1.6. Comparing Two Records</A>
  <DT>strings
  <DD><DL>
    <DT><A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.3.2. The VARCHAR2 and VARCHAR datatypes</A>
    <DT><A HREF="../ch11_01.htm">11.1.13. The SOUNDEX function</A>
  </DL>
</DL>
<DT><A NAME="comparison-methods">comparison methods</A>
: <A HREF="../ch18_03.htm#SQL2-CH-18-SECT-3.6.1">18.3.1. About Object Types</A>
<DT><A NAME="compilation">compilation</A>
<DD><DL>
  <DT>automatic
: <A HREF="../ch23_03.htm">23.3.1. Interdependencies of Stored Objects</A>
  <DT>errors, viewing
: <A HREF="../ch23_05.htm#SQL2-CH-23-SECT-5.3">23.5.4. Viewing Compilation Errors in SQL*Plus</A>
  <DT>manual
: <A HREF="../ch23_03.htm">23.3.1. Interdependencies of Stored Objects</A>
  <DT>of modules
: <A HREF="../ch04_05.htm">4.5.2. Anchoring at Compile Time</A>
</DL>
<DT><A NAME="compile.5fschema-procedure">COMPILE_SCHEMA procedure</A>
: <A HREF="../appc_16.htm#appc-133-fm2xml">C.16.3. The  COMPILE_SCHEMA procedure</A>
<DT><A NAME="compiler-constructs">compiler constructs</A>
: (see <A HREF="idx_p.htm">pragmas</A>)
<DT><A NAME="compiling">compiling</A>
<DD><DL>
  <DT>forced
: <A HREF="../ch20_07.htm#SQL2-CH-20-SECT-7.3">20.7.3. Forcing Compilation</A>
  <DT>package specifications
: <A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.3. Center All Development Around Packages</A>
</DL>
<DT><A NAME="compound-symbols">compound symbols</A>
: (see <A HREF="idx_s.htm">symbols</A>)
<DT><A NAME="concat-function">CONCAT function</A>
<DD><DL>
  <DT><A HREF="../ch04_03.htm#SQL2-CH-4-SECT-3.3">4.3.3. Function Results with NULL Arguments</A>
  <DT><A HREF="../ch11_01.htm">11.1.3. The CONCAT function</A>
</DL>
<DT><A NAME="concatenation">concatenation (||) operator</A>
<DD><DL>
  <DT><A HREF="../ch04_03.htm#SQL2-CH-4-SECT-3.3">4.3.3. Function Results with NULL Arguments</A>
  <DT><A HREF="../ch11_01.htm">11.1.3. The CONCAT function</A>
</DL>
<DT><A NAME="concatenation">concatenation, string</A>
<DD><DL>
  <DT><A HREF="../ch04_03.htm#SQL2-CH-4-SECT-3.3">4.3.3. Function Results with NULL Arguments</A>
  <DT><A HREF="../ch11_01.htm">11.1.3. The CONCAT function</A>
</DL>
<DT><A NAME="conditional-control-structures">conditional control structures</A>
: <A HREF="../ch05_01.htm">5. Conditional and Sequential Control</A>
<DD><DL>
  <DT>formatting
: <A HREF="../ch03_03.htm#SQL2-CH-3-SECT-3.1">3.3. Formatting Control Structures</A>
</DL>
<DT><A NAME="conditional-loops">conditional loops</A>
: (see <A HREF="idx_l.htm">loops</A>)
<DT><A NAME="constants">constants</A>
: (see <A HREF="idx_l.htm">literals</A>; <A HREF="idx_n.htm">named constants</A>; <A HREF="idx_v.htm">variables</A>)
<DT><A NAME="constrained-datatypes">constrained datatypes</A>
<DD><DL>
  <DT><A HREF="../ch04_04.htm#SQL2-CH-4-SECT-4.3">4.4.1. Constrained Declarations</A>
  <DT><A HREF="../ch04_06.htm#SQL2-CH-4-SECT-6.1">4.6. Programmer-Defined Subtypes</A>
  <DT><A HREF="../ch04_06.htm#SQL2-CH-4-SECT-6.1">4.6.3. Emulating Constrained Subtypes</A>
</DL>
<DT><A NAME="constructor-methods">constructor methods</A>
<DD><DL>
  <DT><A HREF="../ch18_02.htm#SQL2-CH-18-SECT-2.3">18.2.2.1. PL/SQL usage </A>
  <DT><A HREF="../ch18_03.htm#SQL2-CH-18-SECT-3.6.1">18.3.1. About Object Types</A>
  <DT><A HREF="../ch18_04.htm#SQL2-CH-18-SECT-4.1.3">18.4.1.1. Constructors</A>
</DL>
<DT><A NAME="constructors">constructors</A>,
initializing collections
: <A HREF="../ch19_04.htm#SQL2-CH-19-SECT-4.1.3">19.4.1.1. Initializing with a constructor</A>

<DT><A NAME="control-structures">control structures</A>,
iterative
: (see <A HREF="idx_l.htm">loops</A>)

<DT><A NAME="conventions">conventions, naming</A>
: <A HREF="../ch04_07.htm#SQL2-CH-4-SECT-7.7">4.7.1. Establish Clear Variable Naming Conventions </A>
<DT><A NAME="conversion">conversion</A>
<DD><DL>
  <DT>and format models
: <A HREF="../ch14_01.htm">14.1. Conversion Formats</A>
  <DT>functions for
: <A HREF="../ch14_01.htm">14. Conversion Functions</A>
  <DT>implicit
: <A HREF="../ch14_01.htm">14. Conversion Functions</A>
</DL>
<DT><A NAME="convert-function">CONVERT function</A>
<DD><DL>
  <DT><A HREF="../appc_07.htm#SQL2-AP-C-SECT-7.0.1">C.7.2. The CONVERT function</A>
  <DT><A HREF="../ch14_02.htm#SQL2-CH-14-SECT-2.0.1">14.2.2. The CONVERT function</A>
</DL>
<DT><A NAME="converting">converting</A>
<DD><DL>
  <DT>between datatypes
: <A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.8. Conversion Between Datatypes</A>
  <DT>datatypes
  <DD><DL>
    <DT>external procedures and
: <A HREF="../ch21_04.htm#ch21-26-fm2xml">21.4.1. Datatype Conversion</A>
    <DT>performance and
: <A HREF="../ch25_04.htm#ch25-26-fm2xml">25.4.7. Avoid Type Conversions When Possible</A>
  </DL>
  <DT>explicitly versus implicitly
: <A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.8.1. Explicit data conversions</A>
  <DT>to/from hexadecimal
: <A HREF="../ch14_02.htm#SQL2-CH-14-SECT-2.0.1">14.2.3. The HEXTORAW function</A>
  <DT>to row numbers
: <A HREF="../ch10_05.htm">10.5.1. Automatic Conversion of Row Number Expressions</A>
  <DT>triggers to procedures
: <A HREF="../ch25_03.htm#SQL2-CH-25-SECT-3.4">25.3.7. Keep Database Triggers Small</A>
  <DT>variables to named constants
: <A HREF="../ch04_07.htm#SQL2-CH-4-SECT-7.7">4.7.5. Convert Variables into Named Constants </A>
</DL>
<DT><A NAME="cooperative-development-environment">Cooperative Development Environment (CDE)</A>
: <A HREF="../ch01_02.htm">1.2. The Concept of Programming in Oracle Applications</A>
<DT><A NAME="copy-procedure">COPY procedure</A>
: <A HREF="../appc_06.htm#appc-35-fm2xml">C.6.3. The  COPY procedure</A>
<DT><A NAME="correlated-subqueries">correlated subqueries</A>
: <A HREF="../ch17_08.htm#SQL2-CH-17-SECT-8.4">17.8.3. Replacing Correlated Subqueries</A>
<DT><A NAME="correlation-variables">correlation variables</A>
: <A HREF="../ch18_04.htm#SQL2-CH-18-SECT-4.1.3">18.4.2.2. REFs</A>
<DT><A NAME="cos-function">COS function</A>
: <A HREF="../ch13_01.htm">13.1.7. The COS function</A>
<DT><A NAME="cosh-function">COSH function</A>
: <A HREF="../ch13_01.htm">13.1.8. The COSH function</A>
<DT><A NAME="count-function">COUNT function</A>
<DD><DL>
  <DT><A HREF="../ch10_08.htm#SQL2-CH-10-SECT-8.2">10.8.2.1. The COUNT function</A>
  <DT><A HREF="../ch19_06.htm#SQL2-CH-19-SECT-6.0.5">19.6.1. COUNT</A>
</DL>
<DT><A NAME="counted-loops">counted loops</A>
: (see <A HREF="idx_n.htm">numeric FOR loops</A>)
<DT><A NAME="counting-substring-occurrences">counting substring occurrences</A>
: <A HREF="../ch11_02.htm#SQL2-CH-11-SECT-2.4">11.2.4. Counting Substring Occurrences in Strings</A>
<DT><A NAME="create-command">CREATE command</A>
: <A HREF="../ch23_05.htm#SQL2-CH-23-SECT-5.3">23.5.1. Creating Stored Objects</A>
<DT><A NAME="create-directory-command">CREATE DIRECTORY command</A>
: <A HREF="../ch04_02.htm#SQL2-CH-4-SECT-2.7.7">4.2.7.7. Working with BFILEs</A>
<DT><A NAME="create-library-command">CREATE LIBRARY command</A>
<DD><DL>
  <DT><A HREF="../ch21_02.htm#SQL2-CH-21-SECT-2.1">21.2.3. Step 3: Issue CREATE LIBRARY Statement</A>
  <DT><A HREF="../ch21_03.htm#SQL2-CH-21-SECT-3.2">21.3.1. CREATE LIBRARY: Creating the External Procedure Library</A>
</DL>
<DT><A NAME="create-or-replace-command">CREATE OR REPLACE command</A>
: <A HREF="../ch23_05.htm#SQL2-CH-23-SECT-5.3">23.5.3. Changing Stored Objects</A>
<DT><A NAME="create-type-body-statement">CREATE TYPE BODY statement</A>
: <A HREF="../ch18_03.htm#SQL2-CH-18-SECT-3.6.1">18.3.3. CREATE TYPE BODY: Creating a Body</A>
<DT><A NAME="create-type-command">CREATE TYPE command</A>
: <A HREF="../ch19_02.htm#SQL2-CH-19-SECT-2.1.1">19.2. Creating the New Collections</A>
<DD><DL>
  <DT>CREATE TYPE ... AS OBJECT statement
: <A HREF="../ch19_02.htm#SQL2-CH-19-SECT-2.1.1">19.2.1.2. Collection as an attribute of an object type</A>
</DL>
<DT><A NAME="create-type-statement">CREATE TYPE statement</A>
: <A HREF="../ch18_03.htm#SQL2-CH-18-SECT-3.6.1">18.3.2. CREATE TYPE and DROP TYPE: Creating and Dropping Types</A>
<DT><A NAME="create-view-statement">CREATE VIEW statement</A>
: <A HREF="../ch20_03.htm#SQL2-CH-20-SECT-3.3">20.3.1. CREATE VIEW: Creating an Object View</A>
<DT><A NAME="create.5fqueue-procedure">CREATE_QUEUE procedure</A>
: <A HREF="../appc_03.htm#appc-16-fm2xml">C.3.2.3. The  CREATE_QUEUE procedure</A>
<DT><A NAME="create.5fqueue.5ftable-procedure">CREATE_QUEUE_TABLE procedure</A>
: <A HREF="../appc_03.htm#appc-16-fm2xml">C.3.2.1. The  CREATE_QUEUE_TABLE procedure</A>
<DT><A NAME="cursor-for-loops">cursor FOR loops</A>
: <A HREF="../ch07_04.htm">7.4. The Cursor FOR Loop</A>
<DD><DL>
  <DT>formatting
: <A HREF="../ch03_03.htm#SQL2-CH-3-SECT-3.1">3.3.2. Formatting Loops</A>
  <DT>premature termination of
: <A HREF="../ch07_07.htm#SQL2-CH-7-SECT-7.2.2">7.7.2.1. Premature FOR loop termination</A>
  <DT>records in
: <A HREF="../ch07_04.htm">7.4.2. The Cursor FOR Loop Record</A>
  <DT>scope of
: <A HREF="../ch07_06.htm#SQL2-CH-7-SECT-6.1.2">7.6.2.1. Scope in FOR loops</A>
</DL>
<DT><A NAME="cursor-statement">CURSOR statement</A>
: <A HREF="../ch06_04.htm#SQL2-CH-6-SECT-4.3">6.4. Declaring Cursors</A>
<DT><A NAME="cursor-variables">cursor variables</A>
<DD><DL>
  <DT>aliases for
: <A HREF="../ch06_12.htm#SQL2-CH-6-SECT-12.5">6.12.6.3. Cursor variable aliases</A>
  <DT>as arguments
: <A HREF="../ch06_12.htm#SQL2-CH-6-SECT-12.5">6.12.7. Passing Cursor Variables as Arguments</A>
  <DT>attributes of
: <A HREF="../ch06_12.htm#SQL2-CH-6-SECT-12.5">6.12.2. Similarities to Static Cursors</A>
  <DT>scope of
: <A HREF="../ch06_12.htm#SQL2-CH-6-SECT-12.5">6.12.6.4. Scope of cursor object</A>
</DL>
<DT><A NAME="cursor.5falready.5fopen-exception">CURSOR_ALREADY_OPEN exception</A>
: <A HREF="../ch08_03.htm#SQL2-CH-8-SECT-3.2">8.3.1. Named System Exceptions </A>
<DT><A NAME="cursors">cursors</A>
: <A HREF="../ch06_02.htm#SQL2-CH-6-SECT-2.2">6.2. Cursors in PL/SQL</A>
<DD><DL>
  <DT>attributes of
: <A HREF="../ch06_09.htm#SQL2-CH-6-SECT-9.1">6.9. Cursor Attributes</A>
  <DD><DL>
    <DT>for cursor variables
: <A HREF="../ch06_12.htm#SQL2-CH-6-SECT-12.5">6.12.2. Similarities to Static Cursors</A>
    <DT>%FOUND
: <A HREF="../ch06_09.htm#SQL2-CH-6-SECT-9.1">6.9.1. The %FOUND Attribute</A>
    <DT>%ISOPEN
    <DD><DL>
      <DT><A HREF="../ch06_05.htm">6.5. Opening Cursors</A>
      <DT><A HREF="../ch06_09.htm#SQL2-CH-6-SECT-9.1">6.9.4. The %ISOPEN Attribute</A>
    </DL>
    <DT>%NOTFOUND
    <DD><DL>
      <DT><A HREF="../ch06_06.htm">6.6.2. Fetching Past the Last Row</A>
      <DT><A HREF="../ch06_09.htm#SQL2-CH-6-SECT-9.1">6.9.2. The %NOTFOUND Attribute</A>
    </DL>
    <DT>%ROWCOUNT
: <A HREF="../ch06_09.htm#SQL2-CH-6-SECT-9.1">6.9.3. The %ROWCOUNT Attribute</A>
  </DL>
  <DT>closing
: <A HREF="../ch06_08.htm">6.8. Closing Cursors</A>
  <DT>column aliases in
: <A HREF="../ch06_07.htm">6.7. Column Aliases in Cursors</A>
  <DT>corresponding to records
: <A HREF="../ch09_01.htm">9.1.4. Guidelines for Using Records</A>
  <DT>cursor variables
  <DD><DL>
    <DT><A HREF="../ch01_04.htm#SQL2-CH-1-SECT-4.7.6">1.4.5.2. Cursor variables</A>
    <DT><A HREF="../ch06_02.htm#SQL2-CH-6-SECT-2.2">6.2.1. Types of Cursors</A>
    <DT><A HREF="../ch06_12.htm#SQL2-CH-6-SECT-12.5">6.12. Cursor Variables</A>
    <DT>restrictions on
: <A HREF="../ch06_12.htm#SQL2-CH-6-SECT-12.5">6.12.8. Cursor Variable Restrictions</A>
  </DL>
  <DT>database access based on
: <A HREF="../ch01_04.htm#SQL2-CH-1-SECT-4.7.6">1.4.3.8. Cursor-based access to the database</A>
  <DT>declaring
: <A HREF="../ch06_04.htm#SQL2-CH-6-SECT-4.3">6.4. Declaring Cursors</A>
  <DD><DL>
    <DT>in packages
: <A HREF="../ch16_03.htm#SQL2-CH-16-SECT-3.1.2">16.3.2. Declaring Package Cursors</A>
  </DL>
  <DT>examples of using
: <A HREF="../ch06_13.htm#SQL2-CH-6-SECT-13.2">6.13. Working with Cursors </A>
  <DT>explicit
  <DD><DL>
    <DT><A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.4. Standardize Your PL/SQL Development Environment</A>
    <DT><A HREF="../ch06_02.htm#SQL2-CH-6-SECT-2.2">6.2.1. Types of Cursors</A>
    <DT><A HREF="../ch06_03.htm#SQL2-CH-6-SECT-3.1">6.3.3. Explicit Cursors</A>
    <DT>FETCH INTO from
: <A HREF="../ch09_05.htm">9.5.3. FETCH INTO from an Explicit Cursor</A>
  </DL>
  <DT>explicit, fetching from
: <A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.2. Synchronize Program and Data Structures</A>
  <DT>fetching from
: <A HREF="../ch06_06.htm">6.6. Fetching from Cursors</A>
  <DT>FOR loops for
  <DD><DL>
    <DT><A HREF="../ch01_06.htm#SQL2-CH-1-SECT-6.0.4">1.6.4. The cursor FOR loop</A>
    <DT><A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.1. Write as Little Code as Possible</A>
  </DL>
  <DT>group functions in
: <A HREF="../ch06_13.htm#SQL2-CH-6-SECT-13.2">6.13.1.1. Inefficiency of group functions in cursors</A>
  <DT>identifier precedence
: <A HREF="../ch06_04.htm#SQL2-CH-6-SECT-4.3">6.4.3. Identifier Precedence in a Cursor</A>
  <DT>implicit
  <DD><DL>
    <DT><A HREF="../ch01_07.htm#SQL2-CH-1-SECT-7.5">1.7.4. Standardize Your PL/SQL Development Environment</A>
    <DT><A HREF="../ch06_02.htm#SQL2-CH-6-SECT-2.2">6.2.1. Types of Cursors</A>
    <DT><A HREF="../ch06_03.htm#SQL2-CH-6-SECT-3.1">6.3.1. Implicit Cursors</A>
    <DT><A HREF="../ch06_09.htm#SQL2-CH-6-SECT-9.1">6.9. Cursor Attributes</A>
    <DT><A HREF="../ch06_09.htm#SQL2-CH-6-SECT-9.1">6.9.5. Implicit SQL Cursor Attributes</A>
    <DT>SELECT INTO from
: <A HREF="../ch09_05.htm">9.5.2. SELECT INTO from an Implicit Cursor</A>
  </DL>
  <DT>naming
: <A HREF="../ch06_04.htm#SQL2-CH-6-SECT-4.3">6.4.1. The Cursor Name</A>
  <DT>opening
  <DD><DL>
    <DT><A HREF="../ch06_02.htm#SQL2-CH-6-SECT-2.2">6.2.2. Cursor Operations</A>
    <DT><A HREF="../ch06_05.htm">6.5. Opening Cursors</A>
    <DT><A HREF="../ch06_10.htm#SQL2-CH-6-SECT-10.2">6.10.2. Opening Cursors with Parameters</A>
  </DL>
  <DT>parameters of
: <A HREF="../ch06_10.htm#SQL2-CH-6-SECT-10.2">6.10. Cursor Parameters</A>
  <DT>records based on
: <A HREF="../ch09_03.htm#SQL2-CH-9-SECT-3.2">9.3. Cursor-Based Records</A>
  <DT>RETURN statement
: <A HREF="../ch06_04.htm#SQL2-CH-6-SECT-4.3">6.4.4. The Cursor RETURN Clause</A>
  <DT>scope of
: <A HREF="../ch15_03.htm">15.3.5.4. Cursor scope</A>
  <DT>SELECT FOR UPDATE statement
: <A HREF="../ch06_11.htm#SQL2-CH-6-SECT-11.1">6.11. SELECT FOR UPDATE in Cursors</A>
  <DT>specifying in packages
: <A HREF="../ch16_03.htm#SQL2-CH-16-SECT-3.1.2">16.3. The Package Specification</A>
  <DT>static
: <A HREF="../ch06_02.htm#SQL2-CH-6-SECT-2.2">6.2.1. Types of Cursors</A>
  <DT>variables in
: <A HREF="../ch06_04.htm#SQL2-CH-6-SECT-4.3">6.4.2. PL/SQL Variables in a Cursor</A>
</DL>
</DL>

<P>
<HR WIDTH="515" ALIGN="LEFT">

<FONT SIZE="-1">
<A HREF="idx_0.htm">Symbols</A>
| <A HREF="idx_a.htm">A</A>
| <A HREF="idx_b.htm">B</A>
| C
| <A HREF="idx_d.htm">D</A>
| <A HREF="idx_e.htm">E</A>
| <A HREF="idx_f.htm">F</A>
| <A HREF="idx_g.htm">G</A>
| <A HREF="idx_h.htm">H</A>
| <A HREF="idx_i.htm">I</A>
| <A HREF="idx_j.htm">J</A>
| <A HREF="idx_k.htm">K</A>
| <A HREF="idx_l.htm">L</A>
| <A HREF="idx_m.htm">M</A>
| <A HREF="idx_n.htm">N</A>
| <A HREF="idx_o.htm">O</A>
| <A HREF="idx_p.htm">P</A>
| <A HREF="idx_q.htm">Q</A>
| <A HREF="idx_r.htm">R</A>
| <A HREF="idx_s.htm">S</A>
| <A HREF="idx_t.htm">T</A>
| <A HREF="idx_u.htm">U</A>
| <A HREF="idx_v.htm">V</A>
| <A HREF="idx_w.htm">W</A>
| <A HREF="idx_y.htm">Y</A>
| <A HREF="idx_z.htm">Z</A></FONT>

<HR WIDTH="515" ALIGN="LEFT"><IMG SRC="../../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../../copyrght.htm#copy">Copyright (c) 2000</A> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY>

<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML>
