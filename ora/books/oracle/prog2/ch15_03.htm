<HTML
><HEAD
><TITLE
>[Chapter 15] 15.3 The Anonymous PL/SQL Block</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein &amp; Bill Pribyl"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:02:50Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-335-9E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-335-9E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming, 2nd Edition"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch15_01.htm"
TITLE="15. Procedures and Functions"><LINK
REL="prev"
HREF="ch15_02.htm#SQL2-CH-15-SECT-2.1"
TITLE="15.2 Review of PL/SQL Block Structure"><LINK
REL="next"
HREF="ch15_04.htm#SQL2-CH-15-SECT-4.4"
TITLE="15.4 Procedures"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd Edition"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_02.htm#SQL2-CH-15-SECT-2.1"
TITLE="15.2 Review of PL/SQL Block Structure"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 15.2 Review of PL/SQL Block Structure"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch15_01.htm"
TITLE="15. Procedures and Functions"
>Chapter 15<BR>Procedures and Functions</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_04.htm#SQL2-CH-15-SECT-4.4"
TITLE="15.4 Procedures"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 15.4 Procedures"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3"
>15.3 The Anonymous PL/SQL Block</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948948-1"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948948-2"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948948-3"
></A
>When someone wishes to remain anonymous, that person goes unnamed. So it is with the anonymous PL/SQL block. Unlike the other two types of PL/SQL blocks (the procedure and the function), the anonymous block has no name associated with it. In fact, the anonymous block is missing the header section altogether. Instead it simply uses the DECLARE reserved word to mark the beginning of its optional declaration section. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-15-FIG-4"
>Figure 15.4: An anonymous block without declaration and exception sections</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1504.gif"
ALT="Figure 15.4"><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-15-FIG-5"
>Figure 15.5: An anonymous block defined inside a procedure</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1505.gif"
ALT="Figure 15.5"><P
CLASS="para"
>Without a name, the anonymous block cannot be called by any other block&nbsp;-- it doesn't have a handle for reference. Instead, anonymous blocks serve as scripts that execute PL/SQL statements, including calls to procedures and functions. Anonymous blocks can also serve as nested blocks inside procedures, functions, and other anonymous blocks, as shown in <A
CLASS="xref"
HREF="ch15_03.htm"
>Figure 15.5</A
>. </P
><P
CLASS="para"
>Because an anonymous block can have its own declaration and exception sections, developers use anonymous blocks to provide a scope for identifiers and exception handling within a larger program. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.1"
>15.3.1 The Structure of an Anonymous Block</A
></H3
><P
CLASS="para"
>The general format of an anonymous PL/SQL block is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>[ DECLARE
   ... optional declaration statements ... ]

BEGIN
   ... executable statements ...

[ EXCEPTION
   ... optional exception handler statements ... ]

END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The square brackets indicate an optional part of the syntax. As you can see, just about everything in an anonymous block is optional. You must have BEGIN and END statements and you must have at least one executable statement. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.2"
>15.3.2 Examples of Anonymous Blocks</A
></H3
><P
CLASS="para"
>The following examples show the different combinations of block sections, all of which comprise valid PL/SQL blocks: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>A block with BEGIN-END terminators, but no declaration or exception sections: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   hiredate := SYSDATE;
END</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An anonymous block with a declaration section, but no exception section: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   right_now DATE := SYSDATE;
BEGIN
   hiredate := right_now;
END</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An anonymous block containing declaration, execution, and exception sections: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   right_now DATE := SYSDATE;
   too_late EXCEPTION;
BEGIN
   IF :employee.hiredate &lt; ADD_MONTHS (right_now, 6)
   THEN
      RAISE too_late;
   ELSE
      :employee.hiredate := right_now;
   END IF;
EXCEPTION
   WHEN too_late
   THEN
      DBMS_OUTPUT.PUT_LINE
         ('You no longer qualify for free air.');
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE
         ('Error encountered: ' || SQLCODE);
END;</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>Anonymous blocks execute a series of statements and then terminate, thus acting like procedures. In fact, all anonymous blocks are anonymous block procedures. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.3"
>15.3.3 Anonymous Blocks in the Oracle Tools</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13329"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13332"
></A
>Anonymous blocks are used in Oracle tools where PL/SQL code is either executed immediately (SQL*Plus) or attached directly to objects in that tool environment (see <A
CLASS="xref"
HREF="ch15_03.htm"
>Table 15.1</A
>). That object then provides the context or name for the PL/SQL code, making the anonymous block both the most appropriate and the most efficient way to attach programmatic functionality to the object. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SQL2-CH-15-TABLE-2"
>Table 15.1: Anonymous Blocks in Oracle Tools </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Object Type</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Environment</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Trigger</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Oracle Developer/2000 </P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Place PL/SQL code directly in the Oracle Forms or Oracle Reports trigger, which is then packaged as an anonymous block by the tool and sent to the PL/SQL engine. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Database trigger</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Record or column of table</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>The body of the trigger is coded in PL/SQL. While the trigger has a name, the PL/SQL code itself is unnamed, hence anonymous. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Script</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>SQL*Plus and SQL*DBA</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Ad hoc programs and batch processing scripts written in SQL*Plus are always anonymous blocks (which may then call procedures or functions). </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Embedded PL/SQL programs</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Pro* embedded languages</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Embed PL/SQL blocks to execute statements inside the database server.</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Whenever you attach PL/SQL code to a trigger or field in a tool, that code forms an anonymous PL/SQL block. When you write this code you can enter a fully specified PL/SQL block (declaration, execution, and exception sections), or you can enter only the executable section. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.4"
>15.3.4 Nested Blocks </A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948950-1"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948950-2"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948950-3"
></A
>PL/SQL allows you to nest or embed anonymous blocks within another PL/SQL block. You can also nest anonymous blocks within anonymous blocks for more than one level, as shown in <A
CLASS="xref"
HREF="ch15_03.htm"
>Figure 15.6</A
>. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-15-FIG-6"
>Figure 15.6: Anonymous blocks nested three levels deep</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1506.gif"
ALT="Figure 15.6"><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.4.1"
>15.3.4.1 Nested block terminology</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13398"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13401"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13404"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13407"
></A
>A PL/SQL block nested within another PL/SQL block may be called by any of the following: nested block, enclosed block, child block or sub-block. </P
><P
CLASS="para"
>A PL/SQL block that calls another PL/SQL block (anonymous or named) may be referred to as either the enclosing block or the parent block. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.4.2"
>15.3.4.2 Nested blocks provide scope</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948952-1"
></A
>The general advantage of a nested block is that you create a scope for all the declared objects and executable statements in that block. You can use this scope to improve your control over activity in your program. For a discussion, see <A
CLASS="xref"
HREF="ch15_03.htm"
>Section 15.3.5, "Scope and Visibility"</A
> later in this chapter. </P
><P
CLASS="para"
>Consider the following procedure, in which the president and vice-president of the specified company request their salaries be cut in half if their current salaries are more than ten times the average salary in the company. It's the sort of incentive plan that would encourage executives to "share the wealth." </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE update_management
   (company_id_in IN NUMBER, avgsal_in IN NUMBER)
IS
BEGIN
   -- The vice-president shows his generosity...
   BEGIN
      SELECT salary INTO v_sal
        FROM employee
       WHERE company_id = company_id_in
         AND title = 'VICE-PRESIDENT';
      IF v_sal &gt; avgsal_in * 10
      THEN
         UPDATE employee SET salary := salary * .50
          WHERE company_id = company_id_in
            AND title = 'VICE-PRESIDENT';
      ELSE
         DBMS_OUTPUT.PUT_LINE ('The VP is OK!');
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN NULL;
   END;

   -- The president shows her generosity...
   BEGIN
      SELECT salary INTO v_sal
        FROM employee
       WHERE company_id = company_id_in
         AND title = 'PRESIDENT';
      IF v_sal &gt; avgsal_in * 10
      THEN
         UPDATE employee SET salary := salary * .50
          WHERE company_id = company_id_in
            AND title = `PRESIDENT';
      ELSE
         DBMS_OUTPUT.PUT_LINE ('The Prez is a pal!');
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN NULL;
   END;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Each of the two SELECT-UPDATE combinations is embedded in its own anonymous PL/SQL block. Each block has its own exception section. Why go to all this trouble? Why couldn't the programmer just create a little script that will update the salary for a specified title? The following statement, saved to the updemp.sql file, would "do the trick" (&amp;N is the syntax used to supply arguments to a SQL*Plus script): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UPDATE employee SET salary := salary * .50
 WHERE company_id = &amp;1
   AND title = '&amp;2'
   AND salary &gt; &amp;3 * 10;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and then execute the SQL script in SQL*Plus using the START command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; start updemp 1100 VICE-PRESIDENT
SQL&gt; start updemp 1100 PRESIDENT</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The programmer who was assigned this task took several things into account: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The executives might decide they will want to take such actions repeatedly in the coming years; better to package the steps into a reusable chunk of code like a procedure than simply execute a series of SELECT-UPDATEs in SQL*Plus. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Executives come and go frequently at the company. There is no guarantee that there will be a person in the employee table with a title of `PRESIDENT' or `VICE-PRESIDENT' at any given time. The first assumption argues for the encapsulation of these two SELECT-UPDATE steps into a procedure. This second assumption results in the need for embedded PL/SQL blocks around each UPDATE statement. Suppose that the procedure update_management did not make use of the embedded blocks. The code would then look like this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE update_management
   (company_id_in IN NUMBER, avgsal_in IN NUMBER)
IS
BEGIN
   SELECT salary INTO v_sal
     FROM employee
    WHERE company_id = company_id_in
      AND title = 'VICE-PRESIDENT';
   IF v_sal &gt; avgsal_in * 10
   THEN
      UPDATE employee SET salary := salary * .50
       WHERE company_id = company_id_in
         AND title = 'VICE-PRESIDENT';
   ELSE
      DBMS_OUTPUT.PUT_LINE ('The VP is OK!');
   END IF;
   SELECT salary INTO v_sal
     FROM employee
    WHERE company_id = company_id_in
      AND title = 'PRESIDENT';
   IF v_sal &gt; avgsal_in * 10
   THEN
      UPDATE employee SET salary := salary * .50
       WHERE company_id = company_id_in
         AND title = 'PRESIDENT';
   ELSE
      DBMS_OUTPUT.PUT_LINE ('The Prez is a pal!');
   END IF;
END;</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>If there is a record in the employee table with the title of "VICE-PRESIDENT" (for the appropriate company_id) and if there is a record in the employee table with the title of "PRESIDENT," then this procedure works just fine. But what if there is no record with a title of "VICE-PRESIDENT"? What if the Vice-President did not want to take a 50% cut in pay and instead quit in disgust? </P
><P
CLASS="para"
>When the WHERE clause of an implict SELECT statement does not identify any records, PL/SQL raises the NO_DATA_FOUND exception (for more details on this phenomenon see <A
CLASS="xref"
HREF="ch06_01.htm"
>Chapter 6, <CITE
CLASS="chapter"
>Database Interaction and Cursors</CITE
></A
>, and pay particular attention to the sections concerning implicit cursors). There is no exception handler section in this procedure. As a result, when there is no Vice-President in sight, the procedure will immediately complete (well, abort, actually) and transfer control to the calling block's exception section to see if the NO_DATA_FOUND exception is handled there. The SELECT-UPDATE for the President's salary is therefore not executed at all. </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> You don't actually need a BEGIN-END block around the second SELECT-UPDATE. This is the last statement, and if it fails nothing will be skipped. It is good practice, however, to include an exception statement for the procedure as a whole to trap errors and handle them gracefully. </P
></BLOCKQUOTE
><P
CLASS="para"
>Our programmer would hate to see an executive's wish go unfulfilled, so we need a mechanism to trap the failure of the first SELECT and allow PL/SQL procedure execution to continue on to the next SELECT-UPDATE. The embedded anonymous block offers this protection. By placing the first SELECT within a BEGIN-END envelope, you can also define an exception section just for the SELECT. Then, when the SELECT fails, control is passed to the exception handler for that specific block, not to the exception handler for the procedure as a whole (see <A
CLASS="xref"
HREF="ch15_03.htm"
>Figure 15.7</A
>). If you then code an exception to handle NO_DATA_FOUND which allows for continued processing, the next SELECT-UPDATE will be executed. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-15-FIG-7"
>Figure 15.7: An anonymous block "catches" the exception</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1507.gif"
ALT="Figure 15.7"></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.4.3"
>15.3.4.3 Named modules offer scoping effect of nested block</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13443"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13446"
></A
> You can also restructure the update_management procedure to avoid the problems addressed in the previous section, and also the redundancy in the code for that procedure. The following version of update_management uses an explicit cursor to avoid the problem of the NO_DATA_FOUND exception being raised. It also encapsulates the repetitive logic into a local or nested procedure. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE update_management
   (company_id_in IN NUMBER, avgsal_in IN NUMBER, decr_in IN NUMBER)
IS
   CURSOR salcur (title_in IN VARCHAR2)
   IS
      SELECT salary
        FROM employee
       WHERE company_id = company_id_in
         AND title = title_in
         AND salary &gt; avgsal_in * 10;

   PROCEDURE update_exec (title_in IN VARCHAR2)
   IS
      salrec salcur%ROWTYPE;
   BEGIN
      OPEN salcur (title_in);
      FETCH salcur INTO salrec;
      IF salcur%NOTFOUND
      THEN
         DBMS_OUTPUT.PUT_LINE ('The ' || title_in || ' is OK!');
      ELSE
         UPDATE employee SET salary := salary * decr_in
          WHERE company_id = company_id_in
            AND title = title_in;
      END IF;
      CLOSE salcur;
   END;
BEGIN
   update_exec ('VICE-PRESIDENT');
   update_exec ('PRESIDENT');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This final version also offers the advantage of consolidating the two SELECTs into a single explicit cursor, and the two UPDATEs into a single statement, thereby reducing the amount of code one would have to test and maintain. Whether you go with named or anonymous blocks, the basic concept of program (and therefore exception) scope remains the same. Use the scoping and visibility rules to your advantage by isolating areas of code and cleaning up the program flow. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.5"
>15.3.5 Scope and Visibility</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948955-1"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948955-2"
></A
>Two of the most important concepts related to a PL/SQL block are those of the scope and visibility of identifiers. An identifier is the name of a PL/SQL object, which could be anything from a variable to a program name. In order to manipulate a PL/SQL identifier (assign a value to it, pass it as a parameter, or call it in a module), you have to be able to reference that identifier in such a way that the code will compile. </P
><P
CLASS="para"
>The <EM
CLASS="emphasis"
>scope</EM
> of an identifier is the part of a program in which you can make a reference to the identifier and have that reference resolved by the compiler. An identifier is <EM
CLASS="emphasis"
>visible</EM
> in a program when it can be referenced using an unqualified name. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.5.1"
>15.3.5.1 Qualified identifiers</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948956-1"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948956-2"
></A
> A qualifier for an identifier can be a package name, module name (procedure or function), or loop label. You qualify the name of an identifer with dot notation, the same way you would qualify a column name with the name of its table. </P
><P
CLASS="para"
>The names of the following identifiers are qualified:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>:GLOBAL.company_id</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A global variable in Oracle Forms</P
></DD
><DT
CLASS="term"
>std_types.dollar_amount</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A subtype declared in a package</P
></DD
></DL
><P
CLASS="para"
>The scope of an identifier is generally the block in which that identifier is declared. The following anonymous block declares and then references two local variables: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   first_day DATE;
   last_day DATE;
BEGIN
   first_day := SYSDATE;
   last_day := ADD_MONTHS (first_day, 6);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Both the first_day and last_day variables are visible in this block. When I reference the variables in the assignment statements, I do not need to qualify their names. Also, the scope of the two variables is precisely this anonymous block. </P
><P
CLASS="para"
>I cannot make reference to either of those variables in a second anonymous block or in a procedure. Any attempt to do so will result in a compile failure, because the reference to those variables cannot be resolved. </P
><P
CLASS="para"
>If an identifier is declared or defined outside of the current PL/SQL block, it is visible (can be referenced without a qualifier) only under the following conditions: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The identifier is the name of a standalone procedure or function on which you have EXECUTE privilege. You can then include a call to this module in your block. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The identifier is declared in a block which encloses the current block. </P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.5.2"
>15.3.5.2 Scope and nested blocks</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13492"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13495"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13498"
></A
>Let's take a closer look at nested blocks and the impact on scope and visibility. When you declare a variable in a PL/SQL block, then that variable is local to that block, but is visible in or global to any blocks defined within the first, enclosing block. For example, in the following anonymous block, the variable last_date can be referenced anywhere inside the block: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* The enclosing or outer anonymous block. */
DECLARE
   last_date DATE;
BEGIN
   last_date := LAST_DAY (SYSDATE);

   /* The inner anonymous block. */
   BEGIN
      IF last_date &gt; :employee.hire_date
      THEN
         ...
      END IF;
   END;
   ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Even though last_date is not defined in the inner block, it can still be referenced there without qualification because the inner block is defined inside the outer block. The last_date variable is therefore considered a global variable in the inner block. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch15_03.htm"
>Figure 15.8</A
> shows additional examples illustrating the concept of scope in PL/SQL blocks. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SQL2-CH-15-FIG-8"
>Figure 15.8: Scope of identifiers in PL/SQL blocks</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sql2.1508.gif"
ALT="Figure 15.8"></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.5.3"
>15.3.5.3 Qualifying identifier names with module names</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13512"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13516"
></A
> When necessary, PL/SQL offers many ways to qualify an identifier so that a reference to the identifier can be resolved. Suppose I create a package called company_pkg and declare a variable named last_company_id in that package's specification, as follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE company_pkg
IS
   last_company_id NUMBER;
   ...
END company_pkg;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Then, when I reference that variable outside of the package, I must preface the identifer name with the package name: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF new_company_id = company_pkg.last_company_id THEN ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because a variable declared in a package specification is global in your session, the last_company_id variable can be referenced in any program, but it is not visible unless it is qualified. </P
><P
CLASS="para"
>I can also qualify the name of an identifier with the module in which it is defined: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE calc_totals
IS
   salary NUMBER;
BEGIN
   ...
   DECLARE
      salary NUMBER;
   BEGIN
      salary := calc_totals.salary;
   END;
   ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first declaration of salary creates an identifier whose scope is the entire procedure. Inside the inner anonymous block, however, I declare another identifer with the same name. So when I reference the variable "salary" inside the inner block, it will always be resolved first against the declaration in the inner block, where that variable is visible without any qualification. If I wish to make reference to the procedure-wide salary variable inside the inner block, I must qualify that variable name with the name of the procedure. </P
><P
CLASS="para"
>PL/SQL goes to a lot of trouble and has established many rules for determining how to resolve such naming conflicts. While it is good to be aware of such issues, you would be much better off never having to rely on these guidelines. Use unique names for your identifiers in different blocks so that you can avoid naming conflicts altogether.<A
CLASS="indexterm"
NAME="AUTOID-13527"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13528"
></A
> </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.5.4"
>15.3.5.4 Cursor scope</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-948960-1"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948960-2"
></A
> <A
CLASS="indexterm"
NAME="ch15-idx-948960-3"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-948960-4"
></A
>To use a cursor, you must declare it. But you cannot refer to that cursor&nbsp;-- whether to OPEN, CLOSE, or FETCH from it&nbsp;-- unless that cursor is accessible in your current PL/SQL block. The scope of a cursor is that part of a PL/SQL program in which you can refer to the cursor. </P
><P
CLASS="para"
>You can refer to a cursor in the code block in which it was declared and in all blocks defined within that declaring block. You cannot refer to the cursor outside of the declaring block unless the cursor is declared in a package (see <A
CLASS="xref"
HREF="ch16_01.htm"
>Chapter 16, <CITE
CLASS="chapter"
>Packages</CITE
></A
>, for more information on global variables and cursors). For example, if a cursor is declared in the get_employees procedure (see below) and within get_employees a second PL/SQL block is defined to calculate total compensation for each employee, the cursor and its attributes may still be referenced in that calculation block: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE get_employees
IS
   CURSOR emp_cur IS
      SELECT employee_id, sal + bonus FROM employee;
BEGIN
   OPEN emp_cur;
   DECLARE
      empid NUMBER;
      total_comp NUMBER;
   BEGIN
      FETCH emp_cur INTO empid, total_comp;
      IF total_comp &lt; 5000
      THEN
         MESSAGE (' I need a raise!');
      END IF;
   END;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If, on the other hand, the cursor is declared within an inner block, then that cursor cannot be referenced in an outer block. In the next procedure, the outer block declares the variables that receive the data fetched from the cursor. The inner block declares the cursor. While the inner block can open the cursor without error, the FETCH statement is outside the scope of the cursor-declaring block and will therefore fail: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE get_employees IS
   empid NUMBER;
   total_comp NUMBER;
BEGIN
   DECLARE
      CURSOR emp_cur IS
         SELECT employee_id, sal + bonus FROM employee;
   BEGIN
      OPEN emp_cur;
   END;

   /* This fetch will not be able to identify the cursor. */

   FETCH emp_cur INTO empid, total_comp; -- INVALID!
   IF total_comp &lt; 5000
   THEN
      MESSAGE (' I need a raise!');
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-13551"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13552"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13553"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13554"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13555"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13556"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13557"
></A
> The rules for cursor scope are, therefore, the same as those for all other identifiers.<A
CLASS="indexterm"
NAME="AUTOID-13558"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-13559"
></A
> </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SQL2-CH-15-SECT-3.6"
>15.3.6 Block Labels</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch15-idx-998478-1"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-998478-2"
></A
><A
CLASS="indexterm"
NAME="ch15-idx-998478-3"
></A
> Anonymous blocks don't have names under which they can be stored in the database. By using block labels, however, you can give a name to your block for the duration of its execution. A block label is a PL/SQL label which is placed directly in front of the first line of the block (either the DECLARE or the BEGIN keyword). You might use block labels for either of these reasons: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Improve the readability of your code. When you give something a name, you self-document that code. You also clarify your own thinking about what that code is supposed to do, sometimes ferreting out errors in the process. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Qualify the names of elements declared in the block to distinguish between references to elements with a different scope, but the same name. </P
></LI
></UL
><P
CLASS="para"
>A PL/SQL label has this format:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;&lt;identifer&gt;&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where identifier is a valid PL/SQL identifier (up to 30 characters in length, starting with a letter; see <A
CLASS="xref"
HREF="ch02_02.htm"
>Section 2.2, "Identifiers"</A
> in <A
CLASS="xref"
HREF="ch02_01.htm"
>Chapter 2</A
> in <A
CLASS="xref"
HREF="ch02_01.htm"
>Chapter 2, <CITE
CLASS="chapter"
>PL/SQL Language Fundamentals</CITE
></A
>, for a complete list of rules). </P
><P
CLASS="para"
>Let's look at a couple of examples of applying block labels. In the first example, I place a label in front of my block simply to give it a name and document its purpose: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;&lt;calc_dependencies&gt;&gt;
DECLARE
   v_senator VARCHAR2(100) := 'THURMOND, JESSE';
BEGIN
   IF total_contributions (v_senator, 'TOBACCO') &gt; 25000
   THEN
      DBMS_OUTPUT.PUT_LINE ('We''re smokin''!');
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the next example, I use my block labels to allow me to reference all variables declared in my outer and inner blocks: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;&lt;tobacco_dependency&gt;&gt;
DECLARE
   v_senator VARCHAR2(100) := 'THURMOND, JESSE';
BEGIN
   IF total_contributions (v_senator, 'TOBACCO') &gt; 25000
   THEN
      &lt;&lt;alochol_dependency&gt;&gt;
      DECLARE
         v_senator VARCHAR2(100) := 'WHATEVERIT, TAKES';
      BEGIN
         IF tobacco_dependency.v_senator =
            alcohol_dependency.v_senator
         THEN
            DBMS_OUTPUT.PUT_LINE
               ('Maximizing profits - the American way of life!');
         END IF;
      END;
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I have used my block labels in this case to distinguish between the two different v_senator variables. Without the use of block labels, there would be no way for me to reference the v_senator of the outer block within the inner block. Of course, I could simply give these variables different names, the much-preferred approach. </P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_02.htm#SQL2-CH-15-SECT-2.1"
TITLE="15.2 Review of PL/SQL Block Structure"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 15.2 Review of PL/SQL Block Structure"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming, 2nd Edition"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming, 2nd Edition"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch15_04.htm#SQL2-CH-15-SECT-4.4"
TITLE="15.4 Procedures"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 15.4 Procedures"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>15.2 Review of PL/SQL Block Structure</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>15.4 Procedures</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
