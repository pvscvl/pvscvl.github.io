<HTML
><HEAD
><TITLE
>[Chapter 10] Miscellaneous Packages</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:56:49Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part02.htm"
TITLE="II. Application Development Packages"><LINK
REL="prev"
HREF="ch09_02.htm#ch09-SECT-2.3.5"
TITLE="9.2 UTL_RAW: Manipulating Raw Data"><LINK
REL="next"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
TITLE="10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_02.htm#ch09-SECT-2.3.5"
TITLE="9.2 UTL_RAW: Manipulating Raw Data"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.2 UTL_RAW: Manipulating Raw Data"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 10</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
TITLE="10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="PACKAGES-CH-10"
>10. Miscellaneous Packages</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch10-15582"
TITLE="10.1 DBMS_UTILITY: Performing Miscellaneous Operations"
>DBMS_UTILITY: Performing Miscellaneous Operations</A
><BR><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
TITLE="10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
>DBMS_DESCRIBE: Describing PL/SQL Program Headers</A
><BR><A
CLASS="sect1"
HREF="ch10_03.htm#ch10-SECT-3.2"
TITLE="10.3 DBMS_DDL: Compiling and Analyzing Objects"
>DBMS_DDL: Compiling and Analyzing Objects</A
><BR><A
CLASS="sect1"
HREF="ch10_04.htm#ch10-SECT-4.2.1"
TITLE="10.4 DBMS_RANDOM: Generating Random Numbers (Oracle8 Only)"
>DBMS_RANDOM: Generating Random Numbers (Oracle8 Only)</A
></P
><P
></P
></DIV
><P
CLASS="para"
>You can't find a neat category for everything, can you? This chapter brings together a variety of useful packages you are sure to dip into on a regular basis:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>DBMS_UTILITY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The actual "miscellaneous" package. It offers programs to free unused user memory, parse comma-delimited lists, calculate the elapsed time of PL/SQL programs, and much more. You never know what you'll find popping up next in DBMS_UTILITY! </P
></DD
><DT
CLASS="term"
>DBMS_DESCRIBE </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Contains a single procedure, DESCRIBE_PROCEDURE, which you can use to get information about the parameters of a stored program.</P
></DD
><DT
CLASS="term"
>DBMS_DDL </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Contains programs to recompile stored code, analyze objects in your schema, and modify the referenceability of object identifiers in Oracle8. </P
></DD
><DT
CLASS="term"
>DBMS_RANDOM </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>New to Oracle8, supplies PL/SQL developers with a random number generator. </P
></DD
></DL
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch10-15582"
>10.1 DBMS_UTILITY: Performing Miscellaneous Operations</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch10-idx-15106-0"
></A
>DBMS_UTILITY package is the "miscellaneous package" for PL/SQL. It contains programs that perform a wide variety of operations (listed in <A
CLASS="xref"
HREF="ch10_01.htm"
>Table 10.1</A
>).</P
><BLOCKQUOTE
CLASS="tip"
><P
CLASS="para"
><STRONG
>TIP:</STRONG
> I recommend that whenever you install a new version of the Oracle database, you scan the contents of the <I
CLASS="filename"
>dbmsutil.sql</I
> file. Check to see if Oracle has added any new programs or changed the functionality of existing programs.</P
></BLOCKQUOTE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.1"
>10.1.1 Getting Started with DBMS_UTILITY</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13386-0"
></A
>The DBMS_UTILITY package is created when the Oracle database is installed. The <I
CLASS="filename"
>dbmsutil.sql </I
>script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1, <CITE
CLASS="chapter"
>Introduction</CITE
></A
>) contains the source code for this package's specification. This script is called by <EM
CLASS="emphasis"
>catproc.sql</EM
>, which is normally run immediately after database creation. The script creates the public synonym DBMS_UTILITY for the package and grants EXECUTE <A
CLASS="indexterm"
NAME="ch10-idx-15179-0"
></A
>privilege on the package to public. All Oracle users can reference and make use of this package. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch10_01.htm"
>Table 10.1</A
> <A
CLASS="indexterm"
NAME="ch10-idx-13388-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13388-1"
></A
>summarizes the programs available with DBMS_UTILITY.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch10-42956"
>Table 10.1: DBMS_UTILITY Programs</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13389-0"
></A
>ANALYZE_DATABASE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Analyzes all the tables, clusters, and indexes in a database</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13391-0"
></A
>ANALYZE_PART_OBJECT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Runs the equivalent of the SQL ANALYZE TABLE or ANALYZE INDEX command for each partition of the object, using parallel job queues (PL/SQL8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-15248-0"
></A
>ANALYZE_SCHEMA</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Analyzes all the tables, clusters, and indexes in the specified schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13392-0"
></A
>COMMA_TO_TABLE </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parses a comma-delimited list into a PL/SQL table (PL/SQL Release 2.1 and later)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13393-0"
></A
>COMPILE_SCHEMA</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Compiles all procedures, functions, and packages in the specified schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13394-0"
></A
>DATA_BLOCK_ADDRESS_BLOCK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Gets the block number part of a data block address</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13395-0"
></A
>DATA_BLOCK_ADDRESS_FILE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Gets the file number part of a data block address</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13396-0"
></A
>DB_VERSION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the database version and compatibility information for the current instance (PL/SQL8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13397-0"
></A
>EXEC_DDL_STATEMENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the provided DDL statement (PL/SQL8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13398-0"
></A
>FORMAT_CALL_STACK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the current module call stack in a formatted display</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-15259-0"
></A
>FORMAT_ERROR_STACK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the current error stack in a formatted display</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13400-0"
></A
>GET_HASH_VALUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns a hash value for a string; used to obtain unique (it is hoped) integer values for strings</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-15266-0"
></A
>GET_PARAMETER_VALUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Retrieves information about a parameter in the database parameter file, otherwise known as the INIT.ORA file (PL/SQL8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13407-0"
></A
>GET_TIME </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the elapsed time since an arbitrary time in 100ths of seconds</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13402-0"
></A
>IS_PARALLEL_SERVER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns TRUE if the database instance was started in parallel server mode</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13408-0"
></A
>MAKE_DATA_BLOCK_ADDRESS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Creates a data block address given a file number and a block number</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13409-0"
></A
>NAME_RESOLVE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Resolves the name of an object into its component parts</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13410-0"
></A
>NAME_TOKENIZE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the individual components or tokens in a string</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13411-0"
></A
>PORT_STRING</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns a string describing the platform and version of the current database</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13412-0"
></A
>TABLE_TO_COMMA</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Moves the names in a PL/SQL table into a comma-delimited list</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.1.1"
>10.1.1.1 DBMS_UTILITY nonprogram elements</A
></H4
><P
CLASS="para"
>In <A
CLASS="indexterm"
NAME="ch10-idx-13413-0"
></A
>addition to the functions and procedures defined in the package, DBMS_UTILITY also declares five PL/SQL tables that are used either as input into or output from the package's built-in modules. By the way, these tables are also used by <EM
CLASS="emphasis"
>other</EM
> built-in packages, such as DBMS_DEFER. See <CITE
CLASS="citetitle"
>Chapter 10</CITE
> of <CITE
CLASS="citetitle"
>Oracle PL/SQL Programming</CITE
> for more information about PL/SQL tables (also called index-by tables as of Oracle8).</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>DBMS_UTILITY.UNCL_ARRAY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This PL/SQL table type is used to store lists of strings in the format: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&quot;USER&quot;.&quot;NAME.&quot;COLUMN&quot;@LINK</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can use the array to store any strings you want up to the length determined in the following TABLE type statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE DBMS_UTILITY.UNCL_ARRAY IS 
   TABLE OF VARCHAR2(227) INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>DBMS_UTILITY.NAME_ARRAY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This PL/SQL table type is used to store names of identifiers and is defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE DBMS_UTILITY.NAME_ARRAY IS 
TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>DBMS_UTILITY.DBLINK_ARRAY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This PL/SQL table type is used to store database links and is defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE DBMS_UTILITY.DBLINK_ARRAY IS 
TABLE OF VARCHAR2(128) INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>DBMS_UTILITY.INDEX_TABLE_TYPE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This PL/SQL table type is declared within the package, but is not otherwise used. It is made available for use by other packages and programs.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE DBMS_UTILITY.INDEX_TABLE_TYPE IS 
TABLE OF BINARY_INTEGER INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>DBMS_UTILITY.NUMBER_ARRAY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This PL/SQL table type is declared within the package, but is not otherwise used. It is made available for use by other packages and programs.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE DBMS_UTILITY.NUMBER_ARRAY IS 
TABLE OF NUMBER INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DD
></DL
><P
CLASS="para"
>You can declare PL/SQL tables based on these TABLE type statements as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   short_name_list DBMS_UTILITY.NAME_ARRAY;
   long_name_list DBMS_UTILITY.INDEX_TABLE_TYPE;
BEGIN
...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Of course, if you do declare PL/SQL tables based on DBMS_UTILITY data structures, then those declarations will change with any changes in the <A
CLASS="indexterm"
NAME="ch10-idx-13415-0"
></A
>package.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.2"
>10.1.2 The DBMS_UTILITY Interface</A
></H3
><P
CLASS="para"
>This section describes each of the programs in the DBMS_UTILITY package; because of the miscellaneous nature of these programs, they are simply listed in alphabetical order.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.1"
>10.1.2.1 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13453-0"
></A
>ANALYZE_DATABASE procedure</A
></H4
><P
CLASS="para"
>This procedure analyzes all the tables, clusters, and indexes in the entire database. The header for the procedure follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.ANALYZE_DATABASE
   (method IN VARCHAR2
   ,estimate_rows IN NUMBER DEFAULT NULL
   ,estimate_percent IN NUMBER DEFAULT NULL
   ,method_opt IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in this table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>method</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Action to be taken by the program. ESTIMATE, DELETE,  and COMPUTE are accepted values and are explained later.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>estimate_rows</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The number of rows to be used to perform the statistics estimate. Cannot be less than 1. Used only if method is ESTIMATE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>estimate_percent</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The percentage of rows to be used to perform the statistics estimate. Ignored if estimate_rows is non-NULL. Must be between 1 and 99. Used only if method is ESTIMATE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>method_opt</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The method option, indicating which elements of the object will be analyzed.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Here are the valid entries for the method argument, and the resulting activity (when you pass one of these values, they must be enclosed in single quotes):</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>COMPUTE	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Exact statistics are computed based on the entire contents of the objects. These values are then placed in the data dictionary.</P
></DD
><DT
CLASS="term"
>ESTIMATE	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Statistics are estimated. With this option, either estimate_rows or estimate_percent must be non-NULL. These values are then placed in the data dictionary.</P
></DD
><DT
CLASS="term"
>DELETE	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The statistics for this object are deleted from the data dictionary.</P
></DD
></DL
><P
CLASS="para"
>Here are the valid method_opt entries and the resulting impact (when you pass one of these values, they must be enclosed in single quotes):</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>FOR TABLE	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects statistics for the table.</P
></DD
><DT
CLASS="term"
>FOR ALL COLUMNS [SIZE N]	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects column statistics for all columns and scalar attributes. The size is the maximum number of partitions in the histogram, with a default of 75 and a maximum of 254.</P
></DD
><DT
CLASS="term"
>FOR ALL INDEXED COLUMNS [SIZE N]	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects column statistics for all indexed columns in the table. The size is the maximum number of partitions in the histogram, with a default of 75 and a maximum of 254.</P
></DD
><DT
CLASS="term"
>FOR ALL INDEXES	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects statistics for all indexes associated with the table.</P
></DD
></DL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21350"
>10.1.2.1.1 Example</A
></H4
><P
CLASS="para"
>Here is an example of a request to this program to analyze all columns in <A
CLASS="indexterm"
NAME="ch10-idx-15166-0"
></A
>my database:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_UTILITY.ANALYZE_DATABASE (
      'ESTIMATE',
      100,
      50,
      'FOR ALL COLUMNS SIZE 200');
END;</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.2"
>10.1.2.2 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13457-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13457-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13457-2"
></A
>ANALYZE_SCHEMA procedure</A
></H4
><P
CLASS="para"
>This procedure analyzes all of the tables, clusters, and indexes in the specified schema. The header for the procedure follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.ANALYZE_SCHEMA
   (schema IN VARCHAR2
   ,method IN VARCHAR2
   ,estimate_rows IN NUMBER DEFAULT NULL
   ,estimate_percent IN NUMBER DEFAULT NULL
   ,method_opt IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in this table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameters</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the schema containing the object for which you wish to compute statistics. If NULL, then the current schema is used. This argument is case-sensitive.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>method</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Action to be taken by the program. ESTIMATE, DELETE, and COMPUTE are accepted values (explained later).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>estimate_rows</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The number of rows to be used to perform the statistics estimate. Cannot be less than 1. Used only if method is ESTIMATE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>estimate_percent</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The percentage of rows to be used to perform the statistics estimate. Ignored if estimate_rows is non-NULL. Must be between 1 and 99. Used only if method is ESTIMATE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>method_opt</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The method option, indicating which elements of the object will be analyzed.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Here are the valid entries for the method argument, and the resulting activity (when you pass one of these values, they must be enclosed in single quotes):</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>COMPUTE	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Exact statistics are computed based on the entire contents of the objects. These values are then placed in the data dictionary.</P
></DD
><DT
CLASS="term"
>ESTIMATE	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Statistics are estimated. With this option, either estimate_rows or estimate_percent must be non-NULL. These values are then placed in the data dictionary.</P
></DD
><DT
CLASS="term"
>DELETE	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The statistics for this object are deleted from the data dictionary.</P
></DD
></DL
><P
CLASS="para"
>Here are the valid method_opt entries and the resulting impact (when you pass one of these values, they must be enclosed in single quotes):</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>FOR TABLE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>	Collects statistics for the table.</P
></DD
><DT
CLASS="term"
>FOR ALL COLUMNS [SIZE N]	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects column statistics for all columns and scalar attributes. The size is the maximum number of partitions in the histogram, with a default of 75 and a maximum of 254.</P
></DD
><DT
CLASS="term"
>FOR ALL INDEXED COLUMNS [SIZE N]	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects column statistics for all indexed columns in the table. The size is the maximum number of partitions in the histogram, with a default of 75 and a maximum of 254.</P
></DD
><DT
CLASS="term"
>FOR ALL INDEXES	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects statistics for all indexes associated with the table.</P
></DD
></DL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21436"
>10.1.2.2.1 Example</A
></H4
><P
CLASS="para"
>Here is an example of a request to this program to analyze all indexes in my current <A
CLASS="indexterm"
NAME="ch10-idx-13465-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13465-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13465-2"
></A
>schema:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_UTILITY.ANALYZE_SCHEMA (
      USER, 
      'ESTIMATE',
      100,
      50,
      'FOR ALL INDEXES');
END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.3"
>10.1.2.3 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13478-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13478-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13478-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13478-3"
></A
>ANALYZE_PART_OBJECT procedure (Oracle8 Only)</A
></H4
><P
CLASS="para"
>This procedure analyzes the specified, partitioned object. Here's the header for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.ANALYZE_PART_OBJECT
   (schema IN VARCHAR2 DEFAULT NULL
   ,object_name IN VARCHAR2 DEFAULT NULL
   ,object_type IN CHAR DEFAULT 'T'
   ,command_type IN CHAR DEFAULT 'E'
   ,command_opt IN VARCHAR2 DEFAULT NULL
   ,sample_clause IN VARCHAR2 DEFAULT 'SAMPLE 5 PERCENT');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The schema containing the specified object.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>object_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the object to be analyzed. It must be partitioned.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>object_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The type of the object. Must be either T for TABLE or I for INDEX.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>command_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A code indicating the type of analysis to perform. Valid values: C for COMPUTE STATISTICS, E for ESTIMATE STATISTICS, D for DELETE STATISTICS, and V for VALIDATE STRUCTURE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>command_opt</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Options for the different command types. If command type is C or E, then command_opt can be any of the following: </P
><P
CLASS="para"
>FOR TABLE, FOR ALL LOCAL INDEXES, FOR ALL COLUMNS, or a combination of some of the FOR options of the ANALYZE STATISTICS command. If command_type is V, then command_opt can be CASCADE if the object_type is T for TABLE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>sample_clause</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies the sample clause to use when command_type is E for ESTIMATE.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Running this program is equivalent to executing this SQL command,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ANALYZE TABLE|INDEX [&lt;schema&gt;.]&lt;object_name&gt;
   PARTITION &lt;pname&gt; [&lt;command_type&gt;] [&lt;command_opt&gt;] [&lt;sample_clause&gt;]</PRE
></BLOCKQUOTE
><P
CLASS="para"
>for each partition of the specified object. DBMS_UTILITY will submit a job for each partition, so that the analysis can run in parallel using job queues. It is up to the user to control the number of concurrent jobs that will be started by setting correctly the initialization parameter JOB_QUEUE_PROCESSES.</P
><P
CLASS="para"
>Any syntax errors encountered for the object specification will be reported in SNP trace files.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21504"
>10.1.2.3.1 Example</A
></H4
><P
CLASS="para"
>Here is an example of a request to this program to delete the statistics associated with the columns of the emp <A
CLASS="indexterm"
NAME="ch10-idx-13480-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13480-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13480-2"
></A
>table: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_UTILITY.ANALYZE_PART_OBJECT (
      USER,
      'EMP', 
      'T',
      'DELETE STATISTICS',
      'FOR ALL COLUMNS');
END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.4"
>10.1.2.4 The DBMS_UTILITY.COMMA_TO_TABLE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch10-idx-13482-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13482-1"
></A
>COMMA_TO_TABLE procedure parses a comma-delimited list and places each name into a PL/SQL table. Here's the header for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>  PROCEDURE DBMS_UTILITY.COMMA_TO_TABLE
     (list IN VARCHAR2
     ,tablen OUT BINARY_INTEGER
     ,tab OUT UNCL_ARRAY);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table. </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>list</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Comma-delimited string</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>tablen</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of names found in the list and placed in the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>tab</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table declared using one of the package's predeclared <SPAN
CLASS="acronym"
>TABLE</SPAN
> types</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>This procedure uses the NAME_TOKENIZE procedure to determine which of the string's characters are names and which are commas.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21551"
>10.1.2.4.1 Example</A
></H4
><P
CLASS="para"
>COMMA_TO_TABLE is a handy utility if you happen to have a comma-delimited string; otherwise, it does you no good. Just think: with a tiny bit more effort, Oracle could have provided us with a much more general-purpose and useful string parsing engine. </P
><P
CLASS="para"
>In any case, here is a sample use of DBMS_UTILITY.COMMA_TO_TABLE. It takes two different lists of correlated information, parses them into rows in two different tables, and then uses that data in a series of UPDATE statements.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch10-idx-15185-0"
></A
> upddelist.sp */*
CREATE OR REPLACE PROCEDURE upd_from_list (
   empno_list IN VARCHAR2, 
   sal_list IN VARCHAR2)
IS
   empnos DBMS_UTILITY.UNCL_ARRAY;
   sals DBMS_UTILITY.UNCL_ARRAY;
   numemps INTEGER;
BEGIN
   DBMS_UTILITY.COMMA_TO_TABLE (empno_list, numemps, empnos);
   DBMS_UTILITY.COMMA_TO_TABLE (sal_list, numemps, sals);
   FOR rownum IN 1 .. numemps
   LOOP
      UPDATE emp SET sal = TO_NUMBER (sals(rownum))
       WHERE empno = TO_NUMBER (empnos(rownum));
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> If you are running Oracle8, you could even rewrite this program to use array processing in DBMS_SQL and replace this loop with a single, dynamic UPDATE statement. See <A
CLASS="xref"
HREF="ch02_01.htm"
>Chapter 2, <CITE
CLASS="chapter"
>Executing Dynamic SQL and PL/SQL</CITE
></A
>, for more information.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.5"
>10.1.2.5 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13483-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13483-1"
></A
>COMPILE_SCHEMA procedure</A
></H4
><P
CLASS="para"
>This procedure compiles all procedures, functions, and packages in the specified schema. The header for the procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.COMPILE_SCHEMA (schema VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where schema is the name of the schema.</P
><P
CLASS="para"
>I have heard reports from developers that it sometimes seems as though they run this program and it does not do anything at all. As I write this, though, I have requested that DBMS_UTILITY recompile my PL/Vision schema, and the buzzing of the hard drive light, as well as the delay in the resurfacing of my SQL*Plus prompt, attests to the fact that it is indeed recompiling the scores of packages in this schema.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21572"
>10.1.2.5.1 Example</A
></H4
><P
CLASS="para"
>I execute the following command in SQL*Plus to recompile all programs in my current schema. Notice that before the recompilation, I had a single invalid package. Afterwards, all objects are valid.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; select object_name from user_objects where status='INVALID';
OBJECT_NAME
---------------------------------------------------------------
PLGTE

SQL&gt; exec DBMS_UTILITY.COMPILE_SCHEMA(user)
PL/SQL procedure successfully completed.

SQL&gt; select object_name from user_objects where status='INVALID';
no rows selected</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.6"
>10.1.2.6 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13484-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13484-1"
></A
>DATA_BLOCK_ADDRESS_BLOCK function</A
></H4
><P
CLASS="para"
>This function extracts and returns the block number of a data block address. The header for this function is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.DATA_BLOCK_ADDRESS_BLOCK (dba IN NUMBER)
   RETURN NUMBER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where dba is the data block address.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.7"
>10.1.2.7 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13485-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13485-1"
></A
>DATA_BLOCK_ADDRESS_FILE function</A
></H4
><P
CLASS="para"
>This function extracts and returns the file number of a data block address. The header for this function is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.DATA_BLOCK_ADDRESS_FILE (dba IN NUMBER)
RETURN NUMBER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where dba is the data block address.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.8"
>10.1.2.8 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13491-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13491-1"
></A
>DB_VERSION procedure</A
></H4
><P
CLASS="para"
>This procedure (PL/SQL8 only) returns version information for the current database instance. Here's the header for this procedure: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.DB_VERSION
    (version OUT VARCHAR2
    ,compatibility OUT VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>version</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A string that represents the internal software version of the database. The length of this string is variable and is determined by the database version.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>compatibility</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The compatibility setting of the database determined by the INIT.ORA parameter, COMPATIBLE. If the parameter is not specified in the INIT.ORA file, NULL is returned.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21627"
>10.1.2.8.1 Example</A
></H4
><P
CLASS="para"
>Before this function was available, you had to build a query against a V$ table in order to obtain this information. Now it is easy to obtain your database version from within PL/SQL. In fact, you can make it even <EM
CLASS="emphasis"
>easier</EM
> to get this information by building a wrapper around DBMS_UTILITY.DB_VERSION, as shown here:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch10-idx-13486-0"
></A
> dbver.spp */*
CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch10-idx-13487-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13487-1"
></A
>db
IS
   FUNCTION version RETURN VARCHAR2;
   FUNCTION compatibility RETURN VARCHAR2;
END;
/
CREATE OR REPLACE PACKAGE BODY db
IS
   v VARCHAR2(100);
   c VARCHAR2(100);

   PROCEDURE <A
CLASS="indexterm"
NAME="ch10-idx-13488-0"
></A
>init_info
   IS
   BEGIN
      IF v IS NULL
      THEN
         DBMS_UTILITY.DB_VERSION (v, c);
      END IF;
   END;

   FUNCTION<A
CLASS="indexterm"
NAME="ch10-idx-13489-0"
></A
> version RETURN VARCHAR2
   IS
   BEGIN
      init_info;
      RETURN v;      
   END;

   FUNCTION <A
CLASS="indexterm"
NAME="ch10-idx-13490-0"
></A
>compatibility RETURN VARCHAR2
   IS
   BEGIN
      init_info;
      RETURN c;      
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that this very simple package also optimizes lookups against the DBMS_UTILITY package. The first time you call either the DB.VERSION or the DB.COMPATILITY functions, the private init_info procedure will detect that the v variable is NULL, and so it will call the built-in procedure. From that point on, however, whenever you call either of the DB functions, they will simply return the current value. After all, the version of the database is <EM
CLASS="emphasis"
>not</EM
> going to change during your connection to that database.</P
><P
CLASS="para"
>Here is the output I received from db.version on <A
CLASS="indexterm"
NAME="ch10-idx-13493-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13493-1"
></A
>Oracle8:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec DBMS_UTILITY.PUT_LINE (db.version)
8.0.3.0.0</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.9"
>10.1.2.9 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13495-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13495-1"
></A
>EXEC_DDL_STATEMENT procedure</A
></H4
><P
CLASS="para"
>Oracle has added a procedure to the DBMS_UTILITY package that allows you to execute a DDL statement easily. The header for this procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.EXEC_DDL_STATEMENT
    (parse_string IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here, for example, is all the code I need to write to create an index from within PL/SQL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_UTILITY.EXEC_DDL_STATEMENT
      ('create index so_easy on emp (hiredate, mgr, sal)');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can also use the DBMS_SQL package to perform the same functionality.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.10"
>10.1.2.10 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13500-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13500-1"
></A
>FORMAT_CALL_STACK function</A
></H4
><P
CLASS="para"
>This function formats and returns the current call stack. You can use this function to access the call stack in your program. The header for the function follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.FORMAT_CALL_STACK RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21671"
>10.1.2.10.1 Example</A
></H4
><P
CLASS="para"
>I generated the information in this next example with the following statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_OUTPUT.PUT_LINE (DBMS_UTILITY.FORMAT_CALL_STACK);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The code shows sample output from a call to FORMAT_CALL_STACK.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>----- PL/SQL Call Stack -----
  object      line  object
  handle    number  name
817efc90         3  procedure BOOK.CALC_TOTALS
817d99ec         3  function BOOK.NET_PROFIT
817d101c         4  anonymous block</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The output from this function can be up to 2000 bytes in length.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.11"
>10.1.2.11 The DBMS_UTILITY.FORMAT_ERROR_STACK function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch10-idx-13496-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13496-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13496-2"
></A
>FORMAT_ERROR_STACK function formats and returns the current error stack. You might use this function in an exception handler to examine the sequence of errors raised. The header for the function follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.FORMAT_ERROR_STACK RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The output from this function can be up to 2000 bytes in length.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21690"
>10.1.2.11.1 Example</A
></H4
><P
CLASS="para"
>The script file <I
CLASS="filename"
>errstk.sql</I
> creates three procedures, each of which raises a different exception, and then kicks off the nested execution of those programs.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch10-idx-13501-0"
></A
>errstk.sql */*
CREATE OR REPLACE PROCEDURE proc1
IS
BEGIN
   RAISE NO_DATA_FOUND;
END;
/
CREATE OR REPLACE PROCEDURE proc2 S
BEGIN
   proc1;
EXCEPTION
   WHEN OTHERS THEN RAISE VALUE_ERROR;
END;
/
CREATE OR REPLACE PROCEDURE proc2 IS
BEGIN
   proc1;
EXCEPTION
   WHEN OTHERS THEN RAISE VALUE_ERROR;
END;
/
CREATE OR REPLACE PROCEDURE proc3 IS
BEGIN
   proc2;
EXCEPTION
   WHEN OTHERS THEN RAISE DUP_VAL_ON_INDEX;
END;
/
BEGIN /* Now execute the top-level procedure. */
   proc3;
EXCEPTION
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE (DBMS_UTILITY.FORMAT_ERROR_STACK);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the output from this script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-00001: unique constraint (.) violated
ORA-06502: PL/SQL: numeric or value error
ORA-01403: no data found</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is my conclusion from this test: the DBMS_UTILITY.FORMAT_ERROR_STACK is of limited use in PL/SQL programs. You don't see the name of the program in which the error was raised, and you don't see the line number on which the error  <A
CLASS="indexterm"
NAME="ch10-idx-13498-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13498-1"
></A
>occurred. </P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.12"
>10.1.2.12 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13502-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13502-1"
></A
>GET_HASH_VALUE function</A
></H4
><P
CLASS="para"
>This function gives PL/SQL developers access to a hashing algorithm. You will generally use hashing to generate a unique (or at least likely to be unique) integer value for a string. Here's the header for this function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.GET_HASH_VALUE
    (name IN VARCHAR2
    ,base IN NUMBER
    ,hash_size IN NUMBER)
RETURN NUMBER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The string to be converted or hashed into an integer</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>base</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The base or starting value of integer values for the hashing algorithm</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>hash_size</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The size of the "hash table," meaning the total number of values that are available to the hashing algorithm as conversions from the string inputs</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The values of base and hash_size determine the range of integers that can be used as converted values. Clearly, the larger the hash size, the more likely it is that you will be able to obtain a unique integer for every string you pass to the program. </P
><P
CLASS="para"
>Here are some points to keep in mind when working with the GET_HASH_VALUE function:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Use a small prime number for the base parameter. This establishes the low point of the range of values for the hash table.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use a very large number, and, at Oracle's suggestion, a power of 2, for the hash size to obtain best results. I usually employ a number like 2<SUP
CLASS="superscript"
>30</SUP
>. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can never be sure that the function will actually return an integer value that is unique across the different strings you are converting or have already converted. You must always check to ensure that the value is unique.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you hit a conflict, you must rebuild your entire hash table (the list of integer values you have generated so far). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Since you want to make sure that your base and hash_size values are applied consistently to all hashings for a particular application, you should never call the GET_HASH_VALUE function directly. Instead, you should build a "wrapper" around it that presets all of the arguments <EM
CLASS="emphasis"
>except</EM
> the string that you are hashing. This technique is shown in the following example.</P
></LI
></UL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21753"
>10.1.2.12.1 Example</A
></H4
><P
CLASS="para"
>The following example demonstrates how to use the hash function. It also shows how to use the <A
CLASS="indexterm"
NAME="ch10-idx-13513-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13513-1"
></A
>function to build an alternative index on a PL/SQL table. Finally, it compares the <A
CLASS="indexterm"
NAME="ch10-idx-13514-0"
></A
>performance of hash-based lookups versus a "full table scan" of a PL/SQL table. Comments in the program should make it easy to follow the algorithm. </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> The demohash procedure makes use of the p.l procedure, the PL/Vision replacement for the much more awkward and limited DBMS_OUTPUT.PUT_LINE, as well as the PLVtmr package.[<A
CLASS="footnote"
HREF="#ch10-pgfId-11993"
>1</A
>]</P
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch10-idx-13518-0"
></A
> hashdemo.sp */</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE <A
CLASS="indexterm"
NAME="ch10-idx-13519-0"
></A
>demohash (counter IN INTEGER)
IS
   v_row PLS_INTEGER;
   v_name VARCHAR2(30);
   hashing_failure EXCEPTION;

   /* Define the PL/SQL table */
   TYPE string_tabtype IS TABLE OF VARCHAR2(60) 
      INDEX BY BINARY_INTEGER;
   names string_tabtype;

   /* A function which returns the hashed value. */
   FUNCTION <A
CLASS="indexterm"
NAME="ch10-idx-13520-0"
></A
>hashval (value IN VARCHAR2) RETURN NUMBER
   IS
   BEGIN
       RETURN DBMS_UTILITY.GET_HASH_VALUE 
          (value, 37, 1073741824);  /* POWER (2, 30) */
   END hashval;

   /* Add a name to the table, using the hash function to 
      determine the row in which the value is placed. Ah, 
      the beauty of sparse PL/SQL tables! */
   PROCEDURE <A
CLASS="indexterm"
NAME="ch10-idx-13521-0"
></A
>addname (nm IN VARCHAR2) IS
   BEGIN
       v_row := hashval (nm);
       names (v_row) := nm;
   END;

   /* Obtain the row for a name by scanning the table. */
   FUNCTION <A
CLASS="indexterm"
NAME="ch10-idx-13522-0"
></A
>rowbyscan (nm IN VARCHAR2) RETURN PLS_INTEGER
   IS
      v_row PLS_INTEGER := names.FIRST;
      retval PLS_INTEGER;
   BEGIN
      LOOP
         EXIT WHEN v_row IS NULL;
         IF names(v_row) = nm
         THEN
            retval := v_row;
            EXIT;
         ELSE
            v_row := names.NEXT (v_row);
         END IF;
      END LOOP;
      RETURN retval;
   END;

   /* Obtain the row for a name by hashing the string. */
  FUNCTION <A
CLASS="indexterm"
NAME="ch10-idx-13523-0"
></A
>rowbyhash (nm IN VARCHAR2) RETURN PLS_INTEGER
   IS
   BEGIN
      RETURN hashval (nm);
   END;
BEGIN 
   /* Load up the table with a set of strings based on the number
      of iterations requested. This allows us to easily test the
      scalability of the two algorithms. */
   FOR i IN 1 .. counter
   LOOP
       addname ('Steven' || i);
       addname ('Veva' || i);
       addname ('Eli' || i);
       addname ('Chris' || i);
   END LOOP;

   /* Verify that there were no hashing conflicts (the COUNT should
      be 4 x counter. */
   p.l ('Count in names', names.COUNT);

   IF names.COUNT != 4 * counter
   THEN
      p.l ('Hashing conflict! Test suspended...');
      RAISE hashing_failure;
   END IF;

   /* Verify that the two scans return matching values. */
   v_name := 'Eli' || TRUNC (counter/2);
   p.l ('scan',rowbyscan (v_name));
   p.l ('hash',rowbyhash (v_name));
   IF rowbyscan (v_name) != rowbyhash (v_name)
   THEN
      p.l ('Scanned row differs from hashed row. Test suspended...');
      RAISE hashing_failure;
   END IF;

   /* Time performance of retrieval via scan. */
   plvtmr.capture;
   FOR i IN 1 .. counter
   LOOP
      v_row := rowbyscan (v_name);
   END LOOP;
   plvtmr.show_elapsed ('scan');

   /* Time performance of retrieval via hashed value. */
   plvtmr.capture;
   FOR i IN 1 .. counter
   LOOP
      v_row := rowbyhash (v_name);
   END LOOP;
   plvtmr.show_elapsed ('hash');
EXCEPTION
   WHEN hashing_failure
   <A
CLASS="indexterm"
NAME="ch10-idx-13516-0"
></A
>THEN
      <A
CLASS="indexterm"
NAME="ch10-idx-13509-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13509-1"
></A
>NULL;
<A
CLASS="indexterm"
NAME="ch10-idx-13504-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13504-1"
></A
>END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.13"
>10.1.2.13 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13524-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13524-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13524-2"
></A
>GET_PARAMETER_VALUE function </A
></H4
><P
CLASS="para"
>Available first in PL/SQL8, this function allows you to retrieve the value of a database initialization parameter (set in the <I
CLASS="filename"
>INIT.ORA</I
> initialization file). Here's the header:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.GET_PARAMETER_VALUE
    (parnam IN VARCHAR2
    ,intval IN OUT BINARY_INTEGER
    ,strval IN OUT VARCHAR2)
RETURN BINARY_INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The value returned by the function is either of the following:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>0</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Indicating a numeric or Boolean parameter value</P
></DD
><DT
CLASS="term"
>1</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Indicating a string parameter value</P
></DD
></DL
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>parnam</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the initialization parameter (case-insensitive).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>intval</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The parameter value if that value is numeric. If the value is a Boolean (i.e., the value in the initialization file is TRUE or FALSE), then intval is set to 0 for FALSE and 1 for TRUE. If the value is a string, then this argument contains the length of that string value.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>strval</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The parameter value if that value is a string. Otherwise it is NULL.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Long desired by Oracle developers, the GET_PARAMETER_VALUE function now allows you to get critical information about the current database instance, including the default date format and lots of information about the way shared memory is configured. And you don't have to use UTL_FILE to read the initialization file. (Chances are your DBA would not enable the database directory holding this file for UTL_FILE access anyway!). Note that if you have more than one entry for the same parameter (certainly a possibility with a parameter such as UTL_FILE_DIR), then this built-in will retrieve only the value associated with the <EM
CLASS="emphasis"
>first</EM
> occurrence of the parameter.</P
><P
CLASS="para"
>You will probably want to build a wrapper around GET_PARAMETER_VALUE to make it easier to retrieve and interpret the results. Why? Whenever you call this built-in function, you must declare two variables to retrieve the OUT arguments. You must then interpret the results. Rather than write all this code and have to remember all these rules, you can build it into a package once and then simply call the appropriate program as needed. A prototype of such a package is shown later in this section.</P
><P
CLASS="para"
>My package specification contains these three sections: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Generic interfaces to the built-in, by datatype: return a string value, integer value, or Boolean value. You have to know which type of value <EM
CLASS="emphasis"
>should</EM
> be returned for the name you provide. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Functions returning the values of specific named (by the name of the function) entries in the initialization file. You should expand this section to make it easy to retrieve values for parameters you work with.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A display procedure to show the different values returned by the built-in for a particular parameter.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch10-idx-13528-0"
></A
>dbparm.spp */</PRE
></BLOCKQUOTE
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch10-idx-13534-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13534-1"
></A
>dbparm<A
CLASS="indexterm"
NAME="ch10-idx-13536-0"
></A
>
IS
   /* Generic (by datatype) interfaces to built-in. */
   FUNCTION strval (nm IN VARCHAR2) RETURN VARCHAR2;
   FUNCTION intval (nm IN VARCHAR2) RETURN INTEGER;
   FUNCTION boolval (nm IN VARCHAR2) RETURN BOOLEAN;

   /* Encapsulation for specific parameter retrieval */
   FUNCTION nls_date_format RETURN VARCHAR2;
   FUNCTION utl_file_dir RETURN VARCHAR2;
   FUNCTION db_block_buffers RETURN INTEGER;

   PROCEDURE showval (nm IN VARCHAR2);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Rather than show the entire package body (also found in <I
CLASS="filename"
>dbparm.spp</I
>), I will show you the two levels of encapsulation around DBMS_UTILITY.GET_PARAMETER_VALUE found in the package. You can then apply that technique to other parameters of interest. </P
><P
CLASS="para"
>Here is the dbparm.intval function. It calls the built-in procedure and then returns the integer value. You might want to enhance this procedure to check the datatype of the parameter and only return a value if it is in fact a numeric (or Boolean) type.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION <A
CLASS="indexterm"
NAME="ch10-idx-13530-0"
></A
>intval (nm IN VARCHAR2) RETURN INTEGER
IS
   valtype PLS_INTEGER;
   ival PLS_INTEGER;
   sval VARCHAR2(2000);
BEGIN
   valtype := DBMS_UTILITY.GET_PARAMETER_VALUE (nm, ival, sval);
   RETURN ival;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now I build my dbparm.db_block_buffers package on top of that one as <A
CLASS="indexterm"
NAME="ch10-idx-13526-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13526-1"
></A
>follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION <A
CLASS="indexterm"
NAME="ch10-idx-13537-0"
></A
>db_block_buffers RETURN INTEGER
IS
BEGIN
   RETURN intval ('db_block_buffers');
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.14"
>10.1.2.14 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13538-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13538-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13538-2"
></A
>GET_TIME function</A
></H4
><P
CLASS="para"
>This function returns the number of 100ths of seconds that have elapsed from an arbitrary time. The header for the function follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.GET_TIME RETURN NUMBER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You are probably wondering what this "arbitrary time" is and why I don't tell you about what that starting point is. Two reasons: I don't know and it doesn't matter. You should not use GET_TIME to establish the current time, but only to calculate the elapsed time <EM
CLASS="emphasis"
>between</EM
> two events.</P
><P
CLASS="para"
>The following example calculates the number of 100ths of elapsed seconds since the calc_totals procedure was executed:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   time_before BINARY_INTEGER;
   time_after BINARY_INTEGER;
BEGIN
   time_before := DBMS_UTILITY.GET_TIME;
   calc_totals;
   time_after := DBMS_UTILITY.GET_TIME;
   DBMS_OUTPUT.PUT_LINE (time_after - time_before);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Without GET_TIME, Oracle functions can only record and provide elapsed time in second intervals, which is a very coarse granularity in today's world of computing. With GET_TIME, you can get a much finer understanding of the processing times of lines in your program. </P
><P
CLASS="para"
>Notice that in my anonymous block I had to declare two local variables, make my calls to GET_TIME, and then compute the difference. I will probably need to perform those actions over and over again in my programs. I might even want to perform timings that cross product lines (e.g., start my timing in a form and then check elapsed time from inside a report module). To make it easier to use GET_TIME in these various ways, I built a package called sptimer ("stored package timer" mechanism), which you can find in the <I
CLASS="filename"
>sptimer.sps</I
><A
CLASS="indexterm"
NAME="ch10-idx-13546-0"
></A
> and<A
CLASS="indexterm"
NAME="ch10-idx-13547-0"
></A
> <I
CLASS="filename"
>sptimer.spb </I
> files on the companion <A
CLASS="indexterm"
NAME="ch10-idx-13540-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13540-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13540-2"
></A
>disk.[<A
CLASS="footnote"
HREF="#ch10-pgfId-12014"
>2</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch10-pgfId-12014"
>[2]</A
> PL/Vision also offers the PLVtmr package, a much more fully-realized timing utility. See the Preface ("About PL/Vision") for more information.</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.15"
>10.1.2.15 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13548-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13548-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13548-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13548-3"
></A
>IS_PARALLEL_SERVER function</A
></H4
><P
CLASS="para"
>This function helps determine whether the database is running in parallel server mode. The specification follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.IS_PARALLEL_SERVER  RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The function returns TRUE if the database is running in parallel server mode; otherwise, it returns FALSE.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.16"
>10.1.2.16 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13549-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13549-1"
></A
>MAKE_DATA_BLOCK_ADDRESS function</A
></H4
><P
CLASS="para"
>Use this function to obtain a valid data block address from a file number and block number. The header follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.MAKE_DATA_BLOCK_ADDRESS
   (file IN NUMBER
   ,block IN NUMBER)
RETURN NUMBER;</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-21925"
>10.1.2.16.1 Example</A
></H4
><P
CLASS="para"
>Here is an example of calling this function and displaying the resulting value:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; BEGIN
   2    DBMS_OUTPUT.PUT_LINE
   3      (DBMS_UTILITY.MAKE_DATA_BLOCK_ADDRESS (10000, 20000));
   4 END;
   5 /

268455456</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.17"
>10.1.2.17 The DBMS_UTILITY.<A
CLASS="indexterm"
NAME="ch10-idx-13550-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13550-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13550-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13550-3"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13550-4"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13550-5"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13550-6"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13550-7"
></A
>NAME_RESOLVE procedure</A
></H4
><P
CLASS="para"
>This procedure resolves the name of an object into its component parts, performing synonym translations as necessary. Here's the header for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.NAME_RESOLVE
   (name IN VARCHAR2, 
    context IN NUMBER,
    schema OUT VARCHAR2,
    part1 OUT VARCHAR2,
    part2 OUT VARCHAR2,
    dblink OUT VARCHAR2,
    part1_type OUT NUMBER, 
    object_number OUT NUMBER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the object to be resolved.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>context</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Present for future compatibility;  must be set to the value 1.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the object's schema.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>part1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The first part of the object's name.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>part2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The second part of the object's name (NULL unless the object is a package module, and then part1 is the package name).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dblink</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the database link for the object, if any.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>part1_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Indicates the type of object returned in part1.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>object_number</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The object number for the named object. When object_number is returned NOT NULL, the name was successfully resolved.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>An object type may have one of the following values:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>5</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Synonym</P
></DD
><DT
CLASS="term"
>7</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Standalone procedure</P
></DD
><DT
CLASS="term"
>8</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Standalone function</P
></DD
><DT
CLASS="term"
>9</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Package</P
></DD
></DL
><P
CLASS="para"
>The NAME_RESOLVE procedure has six OUT parameters, which means that in order to use this module you will have to declare six variables&nbsp;-- an annoying task that creates an obstacle to casual use of the procedure.</P
><P
CLASS="para"
>I built a procedure called show_name_components precisely to make it easier to take advantage of NAME_RESOLVE. The show_name_components accepts an object name, and then calls DBMS_OUTPUT.PUT_LINE to display the different components of the name. It shows information only if it is relevant; in other words, if there is no part2, then part2 is not displayed. The name of the database link is displayed only if there is a database link associated with that object.</P
><P
CLASS="para"
>Here are some examples of calls to show_name_components:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt;  execute show_name_components('do.pl');
Schema: BOOK
Package: DO
Name: PL

SQL&gt;  execute show_name_components('do');
Schema: BOOK
Package: DO

SQL&gt; execute show_name_components('show_name_components');
Schema: BOOK
Procedure: SHOW_NAME_COMPONENTS</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the show_name_components procedure in its entirety:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch10-idx-13558-0"
></A
> showcomp.sp */*
CREATE OR REPLACE PROCEDURE <A
CLASS="indexterm"
NAME="ch10-idx-13559-0"
></A
>show_name_components (name_in IN VARCHAR2)
IS
   /* variables to hold components of the name */
   schema VARCHAR2(100); 
   part1 VARCHAR2(100); 
   part2 VARCHAR2(100);
   dblink VARCHAR2(100); 
   part1_type NUMBER; 
   object_number NUMBER;

   /*--------------------- Local Module -----------------------*/
   FUNCTION object_type (type_in IN INTEGER) 
      RETURN VARCHAR2
   /* Return name for integer type */
   IS
      synonym_type CONSTANT INTEGER := 5;
      procedure_type CONSTANT INTEGER := 7;
      function_type CONSTANT INTEGER := 8;
      package_type CONSTANT INTEGER := 9;
   BEGIN
      IF type_in = synonym_type
      THEN
         RETURN 'Synonym';
      ELSIF type_in = procedure_type
      THEN
         RETURN 'Procedure';
      ELSIF type_in = function_type
      THEN
         RETURN 'Function';
      ELSIF type_in = package_type
      THEN
         RETURN 'Package';
      END IF;
   END;
BEGIN
   /* Break down the name into its components */
   DBMS_UTILITY.NAME_RESOLVE
      (name_in, 1,
       schema, part1, part2,
       dblink , part1_type, object_number);

   /* If the object number is NULL, name resolution failed. */
   IF object_number IS NULL
   THEN
      DBMS_OUTPUT.PUT_LINE 
         ('Name &quot;' || name_in || 
          '&quot; does not identify a valid object.');
   ELSE
      /* Display the schema, which is always available. */
      DBMS_OUTPUT.PUT_LINE ('Schema: ' || schema);

      /* If there is a first part to name, have a package module */
      IF part1 IS NOT NULL
      THEN
         /* Display the first part of the name */
         DBMS_OUTPUT.PUT_LINE
            (object_type (part1_type) || ': ' || part1);

         /* If there is a second part, display that. */
         IF part2 IS NOT NULL
         THEN
            DBMS_OUTPUT.PUT_LINE ('Name: ' || part2);
         END IF;
      ELSE
         /* No first part of name. Just display second part. */
         DBMS_OUTPUT.PUT_LINE
            (object_type (part1_type) || ': ' || part2);
      END IF;

      /* Display the database link if it is present. */
      IF dblink IS NOT NULL
      THEN
         DBMS_OUTPUT.PUT_LINE ('Database Link:' || dblink);
      END IF;
   END IF;
<A
CLASS="indexterm"
NAME="ch10-idx-13552-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13552-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13552-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13552-3"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13552-4"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13552-5"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13552-6"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13552-7"
></A
>END;
/</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.18"
>10.1.2.18 The DBMS_UTILITY.NAME_TOKENIZE procedure</A
></H4
><P
CLASS="para"
>This <A
CLASS="indexterm"
NAME="ch10-idx-13562-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13562-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13562-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13562-3"
></A
>procedure calls the PL/SQL parser to parse the given name that is in the following format,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>a [ . b [. c]] [@dblink ]</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where dblink is the name of a <A
CLASS="indexterm"
NAME="ch10-idx-13570-0"
></A
>database link. Here's the header for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.NAME_TOKENIZE
   (name  IN VARCHAR2,
    a OUT VARCHAR2,
    b OUT VARCHAR2,
    c OUT VARCHAR2,
    dblink OUT VARCHAR2,
    nextpos OUT BINARY_INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name being parsed</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>a, b, c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Components of name, if present</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dblink</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of database link</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>nextpos</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Position where next token starts</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>NAME_TOKENIZE follows these rules:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Strips off all double quotes</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Converts to uppercase if there are no quotes</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Ignores any inline comments</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Does no semantic analysis</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Leaves any missing values as <SPAN
CLASS="acronym"
>NULL</SPAN
></P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.19"
>10.1.2.19 The DBMS_UTILITY.PORT_STRING function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch10-idx-13571-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13571-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13571-2"
></A
>PORT_STRING function returns a string that uniquely identifies the version of Oracle Server and the platform or operating system of the current database instance. The specification for this function follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_UTILITY.PORT_STRING RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Running the PORT_STRING function in Oracle8 on Windows NT, for example, returns the following string:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IBMPC/WINNT-8.0.0</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The maximum length of the string returned by this function is operating <A
CLASS="indexterm"
NAME="ch10-idx-13573-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13573-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13573-2"
></A
>system-specific.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.2.20"
>10.1.2.20 The DBMS_UTILITY.TABLE_TO_COMMA procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch10-idx-13575-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13575-1"
></A
>TABLE_TO_COMMA procedure converts a PL/SQL table into a comma-delimited list. Here's the header for this procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_UTILITY.TABLE_TO_COMMA
  (tab IN UNCL_ARRAY,
   tablen OUT BINARY_INTEGER,
   list OUT VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following <A
CLASS="indexterm"
NAME="ch10-idx-13385-0"
></A
>table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>tab</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A PL/SQL table declared using the package's TABLE type</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>tablen</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The number of rows defined in the PL/SQL table (assumed to be densely packed, all rows contiguously defined)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>list</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The string that will contain a comma-delimited list of the names for the PL/SQL table</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_02.htm#ch09-SECT-2.3.5"
TITLE="9.2 UTL_RAW: Manipulating Raw Data"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.2 UTL_RAW: Manipulating Raw Data"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
TITLE="10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>9.2 UTL_RAW: Manipulating Raw Data</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
