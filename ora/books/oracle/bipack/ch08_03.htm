<HTML
><HEAD
><TITLE
>[Chapter 8] 8.3 DBMS_LOB Interface</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:55:43Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch08_01.htm"
TITLE="8. Managing Large Objects "><LINK
REL="prev"
HREF="ch08_02.htm#ch08-SECT-2.1"
TITLE="8.2 LOB Concepts"><LINK
REL="next"
HREF="ch09_01.htm"
TITLE="9. Datatype Packages"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_02.htm#ch08-SECT-2.1"
TITLE="8.2 LOB Concepts"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.2 LOB Concepts"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch08_01.htm"
TITLE="8. Managing Large Objects "
>Chapter 8<BR>Managing Large Objects </A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch09_01.htm"
TITLE="9. Datatype Packages"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 9. Datatype Packages"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch08-34683"
>8.3 DBMS_LOB Interface</A
></H2
><P
CLASS="para"
>This section describes the programs available through the DBMS_LOB packages in several categories.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch08-SECT-3.1"
>8.3.1 Working with BFILEs</A
></H3
><P
CLASS="para"
>The following sections describe the programs in the DBMS_LOB package that perform operations on BFILE objects.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.1.1"
>8.3.1.1 The DBMS_LOB.FILEEXISTS function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22507-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22507-1"
></A
>FILEEXISTS function indicates whether the given BFILE locator points to a file that exists in the operating system. Here's the specification for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOB.FILEEXISTS
   ( file_loc IN BFILE )
   RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The file_loc parameter is the name of the file locator. The function returns one of the following values:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Value</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The specified file does not exist</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The specified file exists</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.1.1"
>8.3.1.1.1 Exceptions</A
></H4
><P
CLASS="para"
>One of the following exceptions may be raised if the file_loc parameter contains an improper value (e.g., NULL):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
> DBMS_LOB.NOEXIST_DIRECTORY
 DBMS_LOB.NOPRIV_DIRECTORY
 DBMS_LOB.INVALID_DIRECTORY</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.1.2"
>8.3.1.1.2 Restrictions</A
></H4
><P
CLASS="para"
>The FILEEXISTS function asserts a purity level with the RESTRICT_REFERENCES pragma.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
> PRAGMA RESTRICT_REFERENCES (fileexists, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.1.3"
>8.3.1.1.3 Examples</A
></H4
><P
CLASS="para"
>This block uses the FILEEXISTS function to see if <I
CLASS="filename"
>chapter01.txt</I
> exists in the BOOK_TEXT directory:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc      BFILE := NULL;
   book_file_exists   BOOLEAN := FALSE;

BEGIN
   book_file_loc := BFILENAME( 'BOOK_TEXT', 'chapter01.txt' );
   book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc ) = 1;

   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE
         ('chapter01.txt exists in BOOK_TEXT directory');
   ELSE
      DBMS_OUTPUT.PUT_LINE
         ('chapter01.txt does not exist in BOOK_TEXT directory');
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>chapter01.txt exists in BOOK_TEXT directory</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following example selects the file locator for <I
CLASS="filename"
>chapter01.txt</I
> from the my_book_files table and checks to see if the file exists:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO my_book_files ( file_descr, book_file )
     VALUES ('Chapter 1', BFILENAME('BOOK_TEXT', 'chapter01.txt') );

DECLARE
   book_file_loc      BFILE := NULL;
   book_file_exists   BOOLEAN := FALSE;
BEGIN
   book_file_loc := book_file ('Chapter 1');
   IF book_file_loc IS NOT NULL
   THEN
      book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc ) = 1;
   END IF;
   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE('Chapter 1 exists');
   ELSE
      DBMS_OUTPUT.PUT_LINE('Chapter 1 does not exist');
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Chapter 1 exists</PRE
></BLOCKQUOTE
><P
CLASS="para"
>FILEEXISTS raises a VALUE_ERROR exception when passed a NULL file locator, so you should always include conditional logic and an exception section.</P
><P
CLASS="para"
>The next example raises the <A
CLASS="indexterm"
NAME="ch08-idx-22516-0"
></A
>NOEXIST_DIRECTORY exception. This can occur if the directory alias does not exist, or if the user has not been granted READ privilege on the directory.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc	 BFILE := NULL;
   book_file_exists   BOOLEAN := FALSE;
BEGIN
   book_file_loc :=  BFILENAME( 'NON_EXISTENT_DIRECTORY', 'chapter01.txt' );
   book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc ) = 1;
   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE('chapter01.txt exists');
   ELSE
      DBMS_OUTPUT.PUT_LINE('chapter01.txt does not exist');
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Running this script results in this unhandled exception:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-22285: non-existent directory or file for FILEEXISTS operation</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the directory exists and READ privileges have been granted to the user, but the specified file does not exist, FILEEXISTS returns zero.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc BFILE := NULL;

BEGIN
   book_file_loc := BFILENAME( 'BOOK_TEXT', 'non_existent_file.txt');

   IF DBMS_LOB.FILEEXISTS( book_file_loc ) = 0
   THEN
      DBMS_OUTPUT.PUT_LINE('non_existent_file.txt does not exist');
   END IF;

END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This script produces the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>non_existent_file.txt does not exist</PRE
></BLOCKQUOTE
><P
CLASS="para"
>FILEEXISTS can be called from SQL, for example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT DBMS_LOB.FILEEXISTS  ( BFILENAME ('BOOK_TEXT','chapter01.txt') )  fileexists
     FROM DUAL;

   FILEEXISTS
   ----------------
                  1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Calls to FILEEXISTS should trap and handle the NOEXIST_DIRECTORY exception (directory alias does not exist) and the VALUE_ERROR exception (input file locator is <A
CLASS="indexterm"
NAME="ch08-idx-22509-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22509-1"
></A
>NULL).</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.1.2"
>8.3.1.2 The DBMS_LOB.FILEGETNAME procedure</A
></H4
><P
CLASS="para"
>Given a file locator, the <A
CLASS="indexterm"
NAME="ch08-idx-22517-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22517-1"
></A
>FILEGETNAME procedure determines its associated directory alias and filename. The specification for this program follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.FILEGETNAME
   ( file_loc IN BFILE,
     dir_alias OUT VARCHAR2,
     filename OUT VARCHAR2 );</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>file_loc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>File locator</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dir_alias</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Directory alias for the file locator</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>filename</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>File name for the file locator</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.2.1"
>8.3.1.2.1 Exceptions</A
></H4
><P
CLASS="para"
>The following VALUE_ERROR exception is raised if the file_loc parameter contains an improper value (e.g., NULL):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INVALID_ARGVAL</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.2.2"
>8.3.1.2.2 Examples</A
></H4
><P
CLASS="para"
>The following example uses FILEGETNAME to get the directory alias and filename for the "Chapter 1" row in the my_book_files table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO my_book_files (file_descr, book_file)
     VALUES ( 'Chapter 1', BFILENAME('BOOK_TEXT', 'chapter01.txt') );
DECLARE
   book_file_exists   BOOLEAN := FALSE;
   book_file_loc      BFILE := NULL;
   book_file_dir      VARCHAR2(30) := NULL;
   book_file_name     VARCHAR2(2000) := NULL;
BEGIN
   book_file_loc := book_file ('Chapter 1');
   IF book_file_loc IS NOT NULL
   THEN
      book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc ) = 1;
   END IF;
   IF book_file_exists
   THEN
      DBMS_LOB.FILEGETNAME
         (book_file_loc, book_file_dir, book_file_name);
      DBMS_OUTPUT.PUT_LINE ('File name is: ' || book_file_name);
      DBMS_OUTPUT.PUT_LINE
         ('File is in Oracle directory: ' || book_file_dir);
   ELSE
      DBMS_OUTPUT.PUT_LINE('Chapter 1 does not exist');
   END IF;
EXCEPTION
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE('OTHERS Exception ' || sqlerrm );
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>File name is: chapter01.txt
File is in Oracle directory: BOOK_TEXT</PRE
></BLOCKQUOTE
><P
CLASS="para"
>FILEGETNAME raises a VALUE_ERROR exception when passed a NULL file locator, so be sure to check the value of the file locator and/or include an exception handler.</P
><P
CLASS="para"
>Note that FILEGETNAME does not actually confirm that the <EM
CLASS="emphasis"
>physical</EM
> file and directory alias exist. This can be done via <A
CLASS="indexterm"
NAME="ch08-idx-22519-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22519-1"
></A
>FILEEXISTS.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.1.3"
>8.3.1.3 The DBMS_LOB.FILEOPEN procedure</A
></H4
><P
CLASS="para"
>Given a file locator, the <A
CLASS="indexterm"
NAME="ch08-idx-22521-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22521-1"
></A
>FILEOPEN procedure opens the BFILE for read-only access. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.FILEOPEN
   ( file_loc IN OUT BFILE,
     open_mode IN BINARY_INTEGER := FILE_READONLY  )</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Purpose</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>file_loc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>File locator for the file to be opened</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>open_mode</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Indicates that file access will be read-only; this parameter can be omitted from calls to FILEOPEN because the program assigns a default value of FILE_READONLY</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.3.1"
>8.3.1.3.1 Exceptions</A
></H4
><P
CLASS="para"
>The following types of exceptions can be raised by the FILEOPEN procedure:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>NOEXIST_DIRECTORY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The directory alias associated with file_loc does not exist.</P
></DD
><DT
CLASS="term"
>OPEN_TOOMANY </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The number of open files exceeds the SESSION_MAX_OPEN_FILES limit.</P
></DD
><DT
CLASS="term"
>INVALID_ARGVAL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The open_mode value is not FILE_READONLY.</P
></DD
><DT
CLASS="term"
>INVALID_OPERATION</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The file does not exist or the user does not have privileges to access the file.</P
></DD
><DT
CLASS="term"
>VALUE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The file_loc parameter contains an improper value (e.g., NULL).</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.3.2"
>8.3.1.3.2 Examples</A
></H4
><P
CLASS="para"
>This example uses the FILEOPEN procedure to check whether <I
CLASS="filename"
>chapter01.txt</I
> exists in the BOOK_TEXT directory, then opens and closes the file:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc      BFILE := NULL;
   book_file_exists   BOOLEAN := FALSE;

BEGIN
   book_file_loc := BFILENAME('BOOK_TEXT','chapter01.txt');
   book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc ) = 1;

   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE('chapter01.txt exists');

      DBMS_OUTPUT.PUT_LINE('opening the file');
      DBMS_LOB.FILEOPEN( book_file_loc );

      DBMS_OUTPUT.PUT_LINE('closing the file');
      DBMS_LOB.FILECLOSE( book_file_loc );
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>chapter01.txt exists
opening the file
closing the file</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The FILEOPEN procedure raises a VALUE_ERROR exception when passed to a NULL file. The procedure raises a NOEXIST_DIRECTORY exception when passed to a file locator associated with a nonexistent directory alias.</P
><P
CLASS="para"
>Note that it is possible to open the same file using two different file locators, for example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc_1      BFILE := NULL;
   book_file_loc_2      BFILE := NULL;
   book_file_exists     BOOLEAN := FALSE;

BEGIN
   book_file_loc_1 := BFILENAME('BOOK_TEXT','chapter01.txt');
   book_file_loc_2 := BFILENAME('BOOK_TEXT','chapter01.txt');
   book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc_1 ) = 1;

   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE('chapter01.txt exists');

      DBMS_OUTPUT.PUT_LINE('opening the file via loc_1');
      DBMS_LOB.FILEOPEN( book_file_loc_1 );

      DBMS_OUTPUT.PUT_LINE('opening the file via loc_2');
      DBMS_LOB.FILEOPEN( book_file_loc_2 );

      DBMS_OUTPUT.PUT_LINE('closing the file via loc_1');
      DBMS_LOB.FILECLOSE( book_file_loc_1 );

      DBMS_OUTPUT.PUT_LINE('closing the file via loc_2');
      DBMS_LOB.FILECLOSE( book_file_loc_2 );

   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>chapter01.txt exists
opening the file via loc_1
opening the file via loc_2
closing the file via loc_1
closing the file via loc_2</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-22525-0"
></A
>To avoid exceeding the SESSION_MAX_OPEN_FILES limit, include a matching call to the FILECLOSE procedure for each BFILE that is opened. When an exception occurs <EM
CLASS="emphasis"
>after</EM
> opening a file, it is possible that execution continues without closing the file (i.e., the matching call to FILECLOSE is not executed due to abnormal termination). In this case, the file remains open, and we run the risk of exceeding the SESSION_MAX_OPEN_FILES limit. It is good practice to include a call to the FILECLOSEALL procedure within an exception handler whenever FILEOPEN is used. See the "<A
CLASS="xref"
HREF="ch08_03.htm#ch08-SECT-3.1.5"
>Section 8.3.1.6, "The DBMS_LOB.FILECLOSEALL procedure"</A
>" section for <A
CLASS="indexterm"
NAME="ch08-idx-22523-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22523-1"
></A
>details.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.1.4"
>8.3.1.4 The DBMS_LOB.FILEISOPEN function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22526-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22526-1"
></A
>FILEISOPEN function indicates whether the file was opened via the input file locator given by file_loc. The header for this program is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOB.FILEISOPEN
   ( file_loc IN BFILE )
   RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where file_loc is the file locator for the file to be opened. The function returns one of the following values:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Value</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0 </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The file is not open via the given file locator.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The file is open via the given file locator.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.4.1"
>8.3.1.4.1 Exceptions</A
></H4
><P
CLASS="para"
>The FILEISOPEN function will raise the VALUE_ERROR exception if the file_loc parameter contains an improper value (e.g., NULL).</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.4.2"
>8.3.1.4.2 Restrictions</A
></H4
><P
CLASS="para"
>The program asserts a purity level with the RESTRICT_REFERENCES pragma.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES (fileisopen, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.4.3"
>8.3.1.4.3 Examples</A
></H4
><P
CLASS="para"
>The following example uses the FILEISOPEN function to check whether <I
CLASS="filename"
>chapter01.txt</I
> in the <I
CLASS="filename"
>BOOK_TEXT</I
> directory is open. It opens the file if it is not already open.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc      BFILE := NULL;
   book_file_exists   BOOLEAN := FALSE;

BEGIN
   book_file_loc := BFILENAME('BOOK_TEXT','chapter01.txt');
   book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc ) = 1;

   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE('chapter01.txt exists');

      IF DBMS_LOB.FILEISOPEN( book_file_loc) = 1
      THEN
         DBMS_OUTPUT.PUT_LINE('file is open');

      ELSE
         DBMS_OUTPUT.PUT_LINE('file is not open');

         DBMS_OUTPUT.PUT_LINE('opening the file');
         DBMS_LOB.FILEOPEN( book_file_loc );

         IF DBMS_LOB.FILEISOPEN( book_file_loc) = 1
         THEN
            DBMS_OUTPUT.PUT_LINE('file is open');
            DBMS_OUTPUT.PUT_LINE('closing the file');
            DBMS_LOB.FILECLOSE( book_file_loc );
         END IF;
      END IF;

   END IF;

EXCEPTION
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE('OTHERS Exception ' || sqlerrm );
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>chapter01.txt exists
file is not open
opening the file
file is open
closing the file</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next example assigns two file locators to the same file, <I
CLASS="filename"
>chapter01.txt,</I
> in the <I
CLASS="filename"
>BOOK_TEXT</I
> directory. It opens the file using the first locator. When called with the first locator, FILEISOPEN indicates that the file is open. However, FILEISOPEN indicates that the file is <EM
CLASS="emphasis"
>not</EM
> open when called with the second locator. Hence, FILEISOPEN indicates whether a file is open <EM
CLASS="emphasis"
>with respect to a specific locator</EM
>.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc_1    BFILE := NULL;
   book_file_loc_2    BFILE := NULL;
   book_file_exists   BOOLEAN := FALSE;
   PROCEDURE check_open (loc IN BFILE, descr IN VARCHAR2)
   IS
BEGIN
   IF DBMS_LOB.FILEISOPEN (loc) = 1
   THEN
      DBMS_OUTPUT.PUT_LINE ('file is open via ' || descr);
   ELSE
      DBMS_OUTPUT.PUT_LINE ('file is not open via ' || descr);
   END IF;
END
BEGIN
   book_file_loc_1 := BFILENAME ('BOOK_TEXT', 'chapter01.txt');
   book_file_loc_2 := BFILENAME ('BOOK_TEXT', 'chapter01.txt');
   book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc_1 ) = 1;
   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE('chapter01.txt exists');
      IF DBMS_LOB.FILEISOPEN( book_file_loc_1 ) = 1
      THEN
         DBMS_OUTPUT.PUT_LINE('file is open via loc_1');
      ELSE
         DBMS_OUTPUT.PUT_LINE('file is not open via loc_1');
         DBMS_OUTPUT.PUT_LINE('opening the file via loc_1');
         DBMS_LOB.FILEOPEN( book_file_loc_1 );
         check_open (book_file_loc_1, 'loc_1');
         check_open (book_file_loc_2, 'loc_2');
         DBMS_OUTPUT.PUT_LINE('closing the file via loc_1');
         DBMS_LOB.FILECLOSE( book_file_loc_1 );
      END IF;
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>chapter01.txt exists
file is not open via loc_1
opening the file via loc_1
file is open via loc_1
file is not open via loc_2
closing the file via loc_1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>FILEISOPEN raises a VALUE_ERROR exception when passed a NULL file locator. On the other hand, FILEISOPEN does not raise an exception when passed a file locator having a nonexistent directory alias or nonexistent <A
CLASS="indexterm"
NAME="ch08-idx-22528-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22528-1"
></A
>file.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.1.5"
>8.3.1.5 The DBMS_LOB.FILECLOSE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22534-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22534-1"
></A
>FILECLOSE procedure is used to close a file that has been opened via the input file locator indicated by the file_loc parameter. The header for this program is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.FILECLOSE ( file_loc IN OUT BFILE );</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where file_loc is the file locator for the file to be opened.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.5.1"
>8.3.1.5.1 Exceptions</A
></H4
><P
CLASS="para"
>The FILECLOSE procedure may raise a VALUE_ERROR exception if the file_loc parameter contains an improper value (e.g., NULL).</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.5.2"
>8.3.1.5.2 Examples</A
></H4
><P
CLASS="para"
>The following example demonstrates that FILECLOSE can be called with a locator for a file that has <EM
CLASS="emphasis"
>not</EM
> been opened:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc      BFILE := NULL;
   book_file_exists   BOOLEAN := FALSE;
BEGIN
   book_file_loc := BFILENAME('BOOK_TEXT','chapter01.txt');
   book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc ) = 1;

   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE('chapter01.txt exists');

      IF DBMS_LOB.FILEISOPEN( book_file_loc ) = 1
      THEN
         DBMS_OUTPUT.PUT_LINE('file is open');
      ELSE
         DBMS_OUTPUT.PUT_LINE('file is not open');
      END IF;

      DBMS_OUTPUT.PUT_LINE('closing the file');
      DBMS_LOB.FILECLOSE( book_file_loc );

   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>chapter01.txt exists
file is not open
closing the file</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The FILECLOSE procedure can be called with a locator for a nonexistent file or directory, for example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc      BFILE := NULL;
BEGIN
   book_file_loc :=
      BFILENAME('NON_EXISTENT_DIRECTORY','non_existent_file.txt');

   DBMS_OUTPUT.PUT_LINE
      ('closing non_existent_file.txt in NON_EXISTENT_DIRECTORY');
   DBMS_LOB.FILECLOSE( book_file_loc );
EXCEPTION
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE('OTHERS Exception ' || sqlerrm );
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>closing non_existent_file.txt in NON_EXISTENT_DIRECTORY</PRE
></BLOCKQUOTE
><P
CLASS="para"
>FILECLOSE raises a VALUE_ERROR exception when passed a NULL file locator.</P
><P
CLASS="para"
>See the FILEOPEN and FILECLOSEALL sections for other examples of FILECLOSE <A
CLASS="indexterm"
NAME="ch08-idx-22536-0"
></A
>usage.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-36415"
>8.3.1.6 The DBMS_LOB.FILECLOSEALL procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22538-0"
></A
>FILECLOSEALL procedure is used to close all BFILEs that are open within a session. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.FILECLOSEALL;</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-36415.1"
>8.3.1.6.1 Exceptions</A
></H4
><P
CLASS="para"
>The FILECLOSEALL procedure raises an UNOPENED_FILE exception if no files are open.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-36415.2"
>8.3.1.6.2 Examples</A
></H4
><P
CLASS="para"
>When an <A
CLASS="indexterm"
NAME="ch08-idx-22542-0"
></A
>exception occurs <EM
CLASS="emphasis"
>after</EM
> opening a file, it is possible that execution continues without closing the file (i.e., a matching call to FILECLOSE is not executed due to abnormal termination of a block). In this case, the file remains open, and we run the risk of exceeding the SESSION_MAX_OPEN_FILES limit. It is good practice to include a call to FILECLOSEALL within an exception handler whenever FILEOPEN is used.</P
><P
CLASS="para"
>The following anonymous block shows how you might construct an exception section that will close any open files: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   book_file_loc      BFILE := NULL;
   book_file_exists   BOOLEAN := FALSE;
   x NUMBER;
BEGIN
   book_file_loc := BFILENAME('BOOK_TEXT','chapter01.txt');
   book_file_exists := DBMS_LOB.FILEEXISTS( book_file_loc ) = 1;
   IF book_file_exists
   THEN
      DBMS_OUTPUT.PUT_LINE ('opening chapter01.txt');
      DBMS_LOB.FILEOPEN (book_file_loc);
      /* Intentionally raise a ZERO_DIVIDE exception */
      x := 1 / 0;
      DBMS_LOB.FILECLOSE( book_file_loc );
   END IF;
EXCEPTION
   WHEN OTHERS
   THEN
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('Clean up using FILECLOSEALL');
         DBMS_LOB.FILECLOSEALL;
      EXCEPTION
         WHEN DBMS_LOB.UNOPENED_FILE
         THEN
            DBMS_OUTPUT.PUT_LINE
               ('No files to close, raising the UNOPENED_FILE exception.');
         WHEN OTHERS
         THEN
            DBMS_OUTPUT.PUT_LINE ('OTHERS Exception ' || sqlerrm );
      END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script: <A
CLASS="indexterm"
NAME="ch08-idx-22540-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22540-1"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>opening  chapter01.txt
Clean up using FILECLOSEALL</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.1.7"
>8.3.1.7 The DBMS_LOB.LOADFROMFILE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22543-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22543-1"
></A
>LOADFROMFILE procedure is used to load all or part of a external LOB (source BFILE) to a destination internal LOB. This is the procedure used to load binary data stored in operating system files into internal LOBs, which reside in the database. The specification for this program is overloaded as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.LOADFROMFILE
   (dest_lob IN OUT BLOB | CLOB CHARACTER SET ANY_CS,
    src_lob IN BFILE,
    amount IN INTEGER,
    dest_offset IN INTEGER := 1,
    src_offset IN INTEGER := 1);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows LOADFROMFILE to be used with BLOBs or CLOBs. The clause ANY_CS in the second specification allows acceptance of either CLOB or NCLOB locators as input.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dest_lob</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locator for the destination internal LOB</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>src_lob</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>File locator for the source external LOB</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>amount</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of bytes to copy from the source BFILE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dest_offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BLOB) or character (CLOB, NCLOB) in the destination LOB at which the copy operation begins; the default value is 1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>src_offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte in the source BFILE at which the load operation begins; the default value is 1</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.7.1"
>8.3.1.7.1 Exceptions</A
></H4
><P
CLASS="para"
>The LOADFROMFILE procedure raises a VALUE_ERROR exception if dest_lob, src_lob, or amount are NULL or invalid.</P
><P
CLASS="para"
>An INVALID_ARGVAL exception is raised if any of the following conditions are true:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>src_offset &lt; 1 or src_offset &gt; LOBMAXSIZE</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>dest_offset &lt; 1 or dest_offset &gt; LOBMAXSIZE</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>amount &lt; 1 or amount &gt; LOBMAXSIZE</P
></LI
></UL
><P
CLASS="para"
>LOADFROMFILE raises the ORA-22993 exception (specified input amount is greater than actual source amount) if the end of the source BFILE is reached before the specified amount of bytes has been copied.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.1.7.2"
>8.3.1.7.2 Examples</A
></H4
><P
CLASS="para"
>The following example loads the CLOB chapter_text column of the my_book_text table with the contents of the first 100 bytes of the file <I
CLASS="filename"
>chapter01.txt</I
> in the <I
CLASS="filename"
>BOOK_TEXT</I
> directory.</P
><P
CLASS="para"
>Note that the update of the chapter_text column occurs without the issue of an UPDATE statement. LOADFROMFILE accomplishes this via the chapter_text locator, which has been selected FOR UPDATE. LOB locators and DBMS_LOB allow changes to LOB columns in Oracle tables without issuing INSERT or UPDATE statements.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-22547-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22547-1"
></A
>If you want to take this approach, you <EM
CLASS="emphasis"
>must</EM
> lock the row that contains the LOB prior to modification. The best way to obtain this lock is to use the FOR UPDATE clause in the SELECT statement (in this example, this translates to calling the book_text_forupdate function):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO my_book_text (chapter_descr, chapter_text)
     VALUES ('Chapter 1', EMPTY_CLOB());
COMMIT;

DECLARE
   v_text_loc   CLOB;
   v_file_loc   BFILE;
BEGIN
   v_text_loc := book_text_forupdate ('Chapter 1');
   v_file_loc := BFILENAME('BOOK_TEXT','chapter01.txt');
   DBMS_LOB.LOADFROMFILE (v_text_loc, v_file_loc, 100);
   COMMIT;
END;
/
SET LONG 100
COL chapter_descr FOR A15
COL chapter_text FOR A40 WORD_WRAPPED
SELECT chapter_descr, chapter_text
  FROM my_book_text
 WHERE chapter_descr = 'Chapter 1';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 1       It was a dark and stormy night.
                Suddenly a scream rang out.  An
                EXCEPTION had not been handled.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next example also loads the CLOB chapter_text column of the my_book_text table with the contents of the first 100 bytes of the file <I
CLASS="filename"
>chapter01.txt</I
> in the <I
CLASS="filename"
>BOOK_TEXT</I
> directory. This time, the LOB locator is not selected FOR UPDATE, but has been returned via the RETURNING clause.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc   CLOB;
   v_file_loc   BFILE;
BEGIN
   INSERT INTO my_book_text (chapter_descr, chapter_text)
        VALUES ('Chapter 1', EMPTY_CLOB )
     RETURNING chapter_text INTO v_text_loc;

   v_file_loc := BFILENAME('BOOK_TEXT','chapter01.txt');

   DBMS_LOB.LOADFROMFILE(v_text_loc, v_file_loc, 100);

   COMMIT;
END;
/

SET LONG 100

COL chapter_descr FOR A15
COL chapter_text FOR A40 WORD_WRAPPED

SELECT chapter_descr, chapter_text
  FROM my_book_text
 WHERE chapter_descr = 'Chapter 1';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 1       It was a dark and stormy night.
                Suddenly a scream rang out.  An
                EXCEPTION had not been handled.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This example loads the BLOB diagram column of the by_book_diagrams table with the contents of the file <I
CLASS="filename"
>ch01_01.bmp</I
> in the <I
CLASS="filename"
>IMAGES</I
> directory. The LOB locator has been returned via the RETURNING clause.</P
><P
CLASS="para"
>Note that the update of the diagram column occurs without the issue of an UPDATE statement. LOADFROMFILE accomplishes this via the diagram locator, which has been returned by the RETURNING clause. LOB locators and DBMS_LOB allow changes to LOB columns in Oracle tables without issuing INSERT or UPDATE statements.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_file_loc       BFILE;

   v_diagram_loc    BLOB;
   v_diagram_size   INTEGER;
BEGIN
   v_file_loc := BFILENAME('IMAGES','ch01_01.bmp');

   v_diagram_size := DBMS_LOB.GETLENGTH(v_file_loc);
   DBMS_OUTPUT.PUT_LINE('Diagram size: ' || v_diagram_size);

   DBMS_OUTPUT.PUT_LINE('Inserting Empty Diagram Row');
   INSERT INTO my_book_diagrams (chapter_descr, diagram_no, diagram)
        VALUES ( 'Chapter 1', 1, EMPTY_BLOB )
     RETURNING diagram INTO v_diagram_loc;

   DBMS_OUTPUT.PUT_LINE('Loading Diagram From File');
   DBMS_LOB.LOADFROMFILE(v_diagram_loc, v_file_loc, v_diagram_size);

   COMMIT;
EXCEPTION
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE('OTHERS Exception ' || sqlerrm);

END;
/

SELECT chapter_descr,
       diagram_no,
       dbms_lob.getlength(diagram) diagram_size
  FROM my_book_diagrams
 WHERE chapter_descr = 'Chapter 1';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This <A
CLASS="indexterm"
NAME="ch08-idx-22545-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22545-1"
></A
>script produces the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Diagram size: 481078
Inserting Empty Diagram Row
Loading Diagram From File

CHAPTER_DESCR   DIAGRAM_NO DIAGRAM_SIZE
--------------- ---------- ------------
Chapter 1                1       481078</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch08-SECT-3.2"
>8.3.2 Reading and Examining LOBs</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-22548-0"
></A
>The following sections describe the programs in the DBMS_LOB package that are used to read and examine LOBs.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.2.1"
>8.3.2.1 The DBMS_LOB.COMPARE function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22554-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22554-1"
></A
>COMPARE function is used to compare two LOBs that are of the same type. Parts of LOBs can also be compared. The specification for this program takes the following forms for each LOB type that may be compared:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOB.COMPARE
   (lob_1 IN BLOB | CLOB CHARACTER SET ANY_CS,
    lob_2 IN BLOB | CLOB CHARACTER SET ANY_CS,
    amount IN INTEGER := 4294967295,
    offset_1 IN INTEGER := 1,
    offset_2 IN INTEGER := 1)
    RETURN INTEGER;

FUNCTION DBMS_LOB.COMPARE
   (lob_1 IN BFILE,
    lob_2 IN BFILE,
    amount IN INTEGER,
    offset_1 IN INTEGER := 1,
    offset_2 IN INTEGER := 1)
    RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows COMPARE to be used with all types of LOBs. The clause ANY_CS in the specification allows either CLOB or NCLOB locators as input.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lob_1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locator for the first LOB to be compared</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lob_2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locator for the second LOB to be compared</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>amount</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of bytes (BFILE, BLOB) or characters (CLOB, NCLOB) to compare</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>offset_1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BFILE, BLOB) or character (CLOB, NCLOB) in the first LOB at which the comparison begins; the default value is 1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>offset_2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BFILE, BLOB) or character (CLOB, NCLOB) in the second LOB at which the comparison begins; the default value is 1</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The function returns one of the following values:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Value</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Zero</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LOBs match exactly over the offsets and amountspecified.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Not Zero</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LOBs do not match exactly over the offsets and amountspecified.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NULL</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Either amount<EM
CLASS="emphasis"
>,</EM
> offset_1oroffset_2,is less than 1, or amount<EM
CLASS="emphasis"
>,</EM
> offset_1<EM
CLASS="emphasis"
>,</EM
> or offset_2is greater thanLOBMAXSIZE.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.1.1"
>8.3.2.1.1 Exceptions</A
></H4
><P
CLASS="para"
>The COMPARE function may raise the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>NOEXIST_DIRECTORY </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>UNOPENED_FILE </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs. Files must be open before comparison.</P
></DD
><DT
CLASS="term"
>NOPRIV_DIRECTORY </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>INVALID_DIRECTORY </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>INVALID_OPERATION </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.1.2"
>8.3.2.1.2 Restrictions</A
></H4
><P
CLASS="para"
>The program asserts a purity level with the RESTRICT_REFERENCES pragma.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES (compare, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.1.3"
>8.3.2.1.3 Examples</A
></H4
><P
CLASS="para"
>The following example compares two BFILE locators that are pointing to the same file. Note that for BFILEs we must provide a number of bytes (in the amount parameter) to compare, which is determined via the GETLENGTH function. Note also that for BFILES we must first open the files.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_file_loc_1      BFILE;
   v_file_1_length   INTEGER;

   v_file_loc_2      BFILE;
BEGIN
   v_file_loc_1 := BFILENAME ('IMAGES', 'ourlogo.bmp');
   v_file_loc_2 := BFILENAME ('IMAGES', 'ourlogo.bmp');

   DBMS_LOB.FILEOPEN(v_file_loc_1);
   DBMS_LOB.FILEOPEN(v_file_loc_2);

   v_file_1_length := DBMS_LOB.GETLENGTH( v_file_loc_1);

   IF DBMS_LOB.COMPARE
         ( v_file_loc_1, v_file_loc_2, v_file_1_length) = 0
   THEN
      DBMS_OUTPUT.PUT_LINE('file_loc_1 equals file_loc_2');
   ELSE
      DBMS_OUTPUT.PUT_LINE('file_loc_1 is not equal to file_loc_2');
   END IF;

   DBMS_LOB.FILECLOSEALL;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>file_loc_1 equals file_loc_2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This example compares two diagrams from the my_book_diagrams table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR diagram_cur (num IN INTEGER)
   IS
   SELECT diagram
     FROM my_book_diagrams
    WHERE chapter_descr = 'Chapter 1'
      AND diagram_no = num;
   v_diagram_1_loc   BLOB;
   v_diagram_2_loc   BLOB;
BEGIN
   OPEN diagram_cur (1);
   FETCH diagram_cur INTO v_diagram_1_loc;
   CLOSE diagram_cur;

   OPEN diagram_cur (2);
   FETCH diagram_cur INTO v_diagram_1_loc;
   CLOSE diagram_cur;

   IF DBMS_LOB.COMPARE (v_diagram_1_loc, v_diagram_2_loc) = 0
   THEN
      DBMS_OUTPUT.PUT_LINE ('diagrams are equal');
   ELSE
      DBMS_OUTPUT.PUT_LINE ('diagrams are different');
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script: <A
CLASS="indexterm"
NAME="ch08-idx-22557-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22557-1"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>diagrams are different</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.2.2"
>8.3.2.2 The DBMS_LOB.GETLENGTH function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-24651-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-24651-1"
></A
>GETLENGTH function returns the length of the input LOB. The length is in bytes for BFILEs and BLOBs, and in characters for CLOBs and NCLOBs. The headers for this program, for each corresponding LOB type, are the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOB.GETLENGTH (lob_loc IN BLOB) RETURN INTEGER;

FUNCTION DBMS_LOB.GETLENGTH (lob_loc IN CLOB CHARACTER SET ANY_CS)
   RETURN INTEGER;

FUNCTION DBMS_LOB.GETLENGTH (lob_loc IN BFILE) RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The lob_loc parameter is the locator of the LOB whose length is to be determined.</P
><P
CLASS="para"
>The overloaded specification allows GETLENGTH to be used with all types of LOBs. The clause ANY_CS in the specification allows either CLOB or NCLOB locators as input.</P
><P
CLASS="para"
>The function returns the length (in bytes or characters) of the input LOB, or it returns NULL if the input LOB is NULL or invalid.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.2.1"
>8.3.2.2.1 Restrictions</A
></H4
><P
CLASS="para"
>The program asserts a purity level with the RESTRICT_REFERENCES pragma.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES (getlength, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.2.2"
>8.3.2.2.2 Examples</A
></H4
><P
CLASS="para"
>The following example gets the size in bytes of the file <I
CLASS="filename"
>ch01_01.bmp </I
>in the <I
CLASS="filename"
>IMAGES</I
> directory:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_file_loc       BFILE;
   v_diagram_size   INTEGER;

BEGIN
   v_file_loc := BFILENAME('IMAGES','ch01_01.bmp');

   v_diagram_size := DBMS_LOB.GETLENGTH(v_file_loc);
   DBMS_OUTPUT.PUT_LINE('Diagram size: ' || v_diagram_size);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Diagram size: 481078</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This example gets the size in characters of "Chapter 1" from the my_book_text table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc      CLOB;
BEGIN
   v_text_loc := book_text ('Chapter 1');
   DBMS_OUTPUT.PUT_LINE
      ('Length of Chapter 1: ' || DBMS_LOB.GETLENGTH(v_text_loc));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script: <A
CLASS="indexterm"
NAME="ch08-idx-22561-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22561-1"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Length of Chapter 1: 100</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.2.3"
>8.3.2.3 The DBMS_LOB.READ procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22563-0"
></A
>READ procedure provides piece-wise read access to a LOB. A specified number of bytes (BFILE, BLOB) or characters (CLOB, NCLOB) is read into the buffer, starting from a specified location<EM
CLASS="emphasis"
>.</EM
> The number of bytes or characters actually read by the operation is returned. The headers for this program, corresponding to each type, are the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.READ
   (lob_loc IN BLOB | BFILE,
    amount IN OUT BINARY_INTEGER,
    offset IN INTEGER,
    buffer OUT RAW);

PROCEDURE DBMS_LOB.READ
   (lob_loc IN CLOB CHARACTER SET ANY_CS,
    amount IN OUT BINARY_INTEGER,
    offset IN INTEGER,
    buffer OUT VARCHAR2 CHARACTER SET lob_loc%CHARSET);
</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows READ to be used with all types of LOBs. The term ANY_CS in the specification allows either CLOB or NCLOB locators as input.</P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22567-0"
></A
>READ procedure and the DBMS_LOB<A
CLASS="indexterm"
NAME="ch08-idx-22568-0"
></A
>.SUBSTR function provide similar functionality. READ is a procedure, while SUBSTR is a function. However, READ will raise NO_DATA_FOUND and INVALID_ARGVAL exceptions, while SUBSTR will ignore these exceptions and return NULL when they occur. DBMS_LOB.SUBSTR can also be called from within a SQL statement, but READ cannot be, since it is a procedure.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lob_loc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A locator for the LOB to be read</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>amount</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of bytes (BFILE, BLOB) or characters (CLOB, NCLOB) to read; the number of bytes or characters actually read by the operation is returned in amount</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BFILE, BLOB) or character (CLOB, NCLOB) in the LOB at which the read begins</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Buffer where the results of the read operation are placed</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.3.1"
>8.3.2.3.1 Exceptions</A
></H4
><P
CLASS="para"
>The READ procedure may raise any of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>VALUE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>lob_loc, amount, or offset is NULL.</P
></DD
><DT
CLASS="term"
>INVALID_ARGVAL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>One of the following conditions exists:</P
></DD
></DL
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>amount&lt; 1 or amount&gt; 32767</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>offset&lt; 1 or offset&gt; LOBMAXSIZE</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>size of amount&gt; size of buffer</P
></LI
></UL
><DL
CLASS="variablelist"
><DT
CLASS="term"
>NO_DATA_FOUND</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The end of the LOB is reached.</P
></DD
><DT
CLASS="term"
>UNOPENED_FILE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs, files must be open before the read.</P
></DD
><DT
CLASS="term"
>NOEXIST_DIRECTORY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>NOPRIV_DIRECTORY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>INVALID_DIRECTORY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>INVALID_OPERATION</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.3.2"
>8.3.2.3.2 Examples</A
></H4
><P
CLASS="para"
>The following example reads the first 60 characters of the CLOB chapter_text column of the my_book_texttable using the "Chapter 1" row:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc      CLOB;
   v_text_amt      BINARY_INTEGER := 60;
   v_text_buffer   VARCHAR2(60);
BEGIN
   v_text_loc := book_text ('Chapter 1');
   DBMS_LOB.READ (v_text_loc, v_text_amt, 1, v_text_buffer);
   DBMS_OUTPUT.PUT_LINE('Chapter 1: ' || v_text_buffer);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Chapter 1: It was a dark and stormy night.  Suddenly a scream rang out.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next example reads sixty characters at a time from the CLOB chapter_text column of the my_book_text table using the "Chapter 1" row. Note that the loop continues until READ raises the NO_DATA_FOUND exception.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc      CLOB;
   v_text_amt      BINARY_INTEGER := 60;
   v_text_pos      INTEGER := 1;
   v_text_buffer   VARCHAR2(60);
BEGIN
   v_text_loc := book_text ('Chapter 1');
   LOOP
      DBMS_LOB.READ
         (v_text_loc, v_text_amt, v_text_pos, v_text_buffer);
      /* process the text and prepare to read again */
      DBMS_OUTPUT.PUT_LINE('Chapter 1: ' || v_text_buffer);
      v_text_pos := v_text_pos + v_text_amt;
   END LOOP;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      DBMS_OUTPUT.PUT_LINE('End of Chapter Reached.');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This script produces the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Chapter 1: It was a dark and stormy night.  Suddenly a scream rang out.
Chapter 1:   An EXCEPTION had not been handled.
End of Chapter Reached.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that the maximum size of a VARCHAR2 or RAW variable is 32767 bytes. This is the size limit of the buffer to be used with <A
CLASS="indexterm"
NAME="ch08-idx-22565-0"
></A
>READ.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.2.4"
>8.3.2.4 The DBMS_LOB.SUBSTR function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22569-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22569-1"
></A
>SUBSTR function provides piece-wise access to a LOB. The specified number of bytes (BFILE, BLOB) or characters (CLOB, NCLOB) is returned, starting from the specified location. The headers for this program, corresponding to each LOB type, are the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOB.SUBSTR
   (lob_loc IN BLOB | BFILE,
    amount IN INTEGER := 32767,
    offset IN INTEGER := 1)
    RETURN RAW;

FUNCTION DBMS_LOB.SUBSTR
   (lob_loc IN CLOB CHARACTER SET ANY_CS,
    amount IN INTEGER := 32767,
    offset IN INTEGER := 1)
    RETURN VARCHAR2 CHARACTER SET lob_loc%CHARSET;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows SUBSTR to be used with all types of LOBs. The term ANY_CS in the specification allows either CLOB or NCLOB locators as input.</P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22573-0"
></A
>SUBSTR function and DBMS_LOB<A
CLASS="indexterm"
NAME="ch08-idx-22574-0"
></A
>.READ procedure provide similar functionality. READ is a procedure, while SUBSTR is a function. However, READ will raise NO_DATA_FOUND and INVALID_ARGVAL exceptions, while SUBSTR will ignore these exceptions when they occur and will return NULL. SUBSTR can also be called from within a SQL statement, but DBMS_LOB.READ cannot, since it is a procedure.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lob_loc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locator for the LOB to be read</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>amount</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of bytes (BFILE, BLOB) or characters (CLOB, NCLOB) to read</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BFILE, BLOB) or character (CLOB, NCLOB) in the LOB at which the read begins</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The SUBSTR function returns a NULL value for any of the following conditions:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>One of the parameters is NULL or invalid</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>amount&lt; 1 or amount&gt; 32767</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>offset&lt; 1 or offset&gt; LOBMAXSIZE</P
></LI
></UL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.4.1"
>8.3.2.4.1 Exceptions</A
></H4
><P
CLASS="para"
>The SUBSTR function may raise one of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>UNOPENED_FILE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs. Files must be open before the SUBSTR operation.</P
></DD
><DT
CLASS="term"
>NOEXIST_DIRECTORY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>NOPRIV_DIRECTORY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>INVALID_DIRECTORY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>INVALID_OPERATION</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.4.2"
>8.3.2.4.2 Restrictions</A
></H4
><P
CLASS="para"
>The program asserts a purity level with the RESTRICT_REFERENCES pragma.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
> PRAGMA RESTRICT_REFERENCES (substr, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.4.3"
>8.3.2.4.3 Examples</A
></H4
><P
CLASS="para"
>The following example reads the first 60 characters of the CLOB chapter_text column of the my_book_texttable using the "Chapter 1" row:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc      CLOB;
   v_text_amt      BINARY_INTEGER := 60;
   v_text_buffer   VARCHAR2(60);
BEGIN
   v_text_loc := book_text ('Chapter 1');

   v_text_buffer := DBMS_LOB.SUBSTR (v_text_loc, v_text_amt, 1);
   DBMS_OUTPUT.PUT_LINE ('Chapter 1: ' || v_text_buffer);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Chapter 1: It was a dark and stormy night.  Suddenly a scream rang out.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next example reads 60 characters at a time from the CLOB chapter_text column of the my_book_text table using the "Chapter 1" row. Note that the loop continues until SUBSTR returns NULL (i.e., SUBSTR does not raise the NO_DATA_FOUND exception).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc      CLOB;
   v_text_amt      BINARY_INTEGER := 60;
   v_text_pos      INTEGER := 1;
   v_buffer   VARCHAR2(60);
BEGIN
   v_text_loc := book_text ('Chapter 1');

   LOOP
      v_buffer := DBMS_LOB.SUBSTR (v_text_loc, v_text_amt, v_text_pos);
      EXIT WHEN v_buffer IS NULL;

      /* process the text and prepare to read again */
      DBMS_OUTPUT.PUT_LINE('Chapter 1: ' || v_buffer);
      v_text_pos := v_text_pos + v_text_amt;
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script: <A
CLASS="indexterm"
NAME="ch08-idx-22571-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22571-1"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Chapter 1: It was a dark and stormy night.  Suddenly a scream rang out.
Chapter 1:   An EXCEPTION had not been handled.</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.2.5"
>8.3.2.5 The DBMS_LOB.INSTR function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22575-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22575-1"
></A
>INSTR function returns the matching offset location of the Nthoccurrence of the given pattern in the LOB. It returns zero if the pattern is not found. The headers for this program, corresponding to each LOB type, are the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOB.INSTR
   (lob_loc IN BLOB | BFILE,
    pattern IN RAW,
    offset IN INTEGER := 1,
    nth IN INTEGER := 1)
    RETURN INTEGER;

FUNCTION DBMS_LOB.INSTR
   (lob_loc IN CLOB CHARACTER SET ANY_CS,
    pattern IN VARCHAR2 CHARACTER SET lob_loc%CHARSET,
    offset IN INTEGER := 1,
    nth IN INTEGER := 1)
    RETURN INTEGER;
</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows INSTR to be used with all types of LOBs. The clause ANY_CS in the specification allows either CLOB or NCLOB locators as input.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lob_loc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A locator for the LOB to be searched</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>pattern</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The pattern to search for in the LOB</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BFILE, BLOB) or character (CLOB, NCLOB) in the LOB at which the search begins</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>nth</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Search for the Nth occurrence of the given pattern in the LOB</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The INSTR function returns NULL for any of the following conditions:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>file_loc or pattern is NULL</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>one of the parameters is invalid</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>offset &lt; 1 or offset &gt; LOBMAXSIZE</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>nth &lt; 1 or nth &gt; LOBMAXSIZE</P
></LI
></UL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.5.1"
>8.3.2.5.1 Exceptions</A
></H4
><P
CLASS="para"
>The INSTR function may raise any of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>UNOPENED_FILE </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs. Files must be open before the INSTR operation.</P
></DD
><DT
CLASS="term"
>NOEXIST_DIRECTORY </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>NOPRIV_DIRECTORY </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>INVALID_DIRECTORY </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
><DT
CLASS="term"
>INVALID_OPERATION</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>For BFILEs.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.5.2"
>8.3.2.5.2 Restrictions</A
></H4
><P
CLASS="para"
>The program asserts a purity level with the RESTRICT_REFERENCES pragma.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   PRAGMA RESTRICT_REFERENCES (instr, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.2.5.3"
>8.3.2.5.3 Example</A
></H4
><P
CLASS="para"
>The following example searches for the first occurrence of the string "dark" in the first sixty characters of the CLOB chapter_text column of the "Chapter 1" row of the my_book_texttable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc      CLOB;
   v_text_buffer   VARCHAR2(60);
   v_text_pattern  VARCHAR2(60) := 'dark';
BEGIN
   v_text_loc := book_text ('Chapter 1');
   v_text_buffer := DBMS_LOB.SUBSTR (v_text_loc, 60, 1);

   DBMS_OUTPUT.PUT_LINE ('buffer: ' || v_text_buffer);
   DBMS_OUTPUT.PUT_LINE
      ('location of &quot;' || v_text_pattern || '&quot;: ' || 
       DBMS_LOB.INSTR(v_text_loc, v_text_pattern));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This<A
CLASS="indexterm"
NAME="ch08-idx-22728-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22728-1"
></A
> is the output of the script: <A
CLASS="indexterm"
NAME="ch08-idx-22549-0"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>buffer: It was a dark and stormy night.  Suddenly a scream rang out.
location of &quot;dark&quot;: 10</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch08-SECT-3.3"
>8.3.3 Updating BLOBs, CLOBs, and NCLOBs</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-22579-0"
></A
>The following sections describe the programs in the DBMS_LOB package that are used to update or alter BLOB, CLOB, and NCLOB object types.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.3.1"
>8.3.3.1 The DBMS_LOB.APPEND procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22581-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22581-1"
></A
>APPEND procedure appends the contents of a source internal LOB to a destination internal LOB. The headers for this program, corresponding to each LOB type, are the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.APPEND
   (dest_lob IN OUT BLOB,
    src_lob IN BLOB);

PROCEDURE DBMS_LOB.APPEND
   (dest_lob IN OUT CLOB CHARACTER SET ANY_CS,
    src_lob IN CLOB CHARACTER SET dest_lob%CHARSET);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows APPEND to be used with BLOBs, CLOBs, and NCLOBs. The term ANY_CS in the specification allows either CLOB or NCLOB locators as input. APPEND cannot be used with BFILEs because access to BFILEs is read-only.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dest_lob</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A locator for the destination LOB</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>src_lob</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A locator for the source LOB</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.1.1"
>8.3.3.1.1 Exceptions</A
></H4
><P
CLASS="para"
>The program may raise any of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>VALUE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Either of the LOBs is NULL.</P
></DD
><DT
CLASS="term"
>ORA-22920</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>dest_lob is not locked for update.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.1.2"
>8.3.3.1.2 Examples</A
></H4
><P
CLASS="para"
>The following example shows that the destination LOB must be selected FOR UPDATE before calling APPEND. We attempt to append the chapter_textfor "Chapter 2" to the chapter_textfor "Chapter 1."</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc      CLOB;
   v_text_buffer   VARCHAR2(60);
   v_text_pattern  VARCHAR2(60) := 'dark';
BEGIN
   v_dest_loc := book_text ('Chapter 1');
   v_src_loc  := book_text ('Chapter 2');
   DBMS_LOB.APPEND (v_dest_loc, v_src_loc);
EXCEPTION
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE('OTHERS Exception ' || sqlerrm);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OTHERS Exception ORA-22920: row containing the LOB value is not locked</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the next example we append the chapter_textfor "Chapter" to the chapter_textfor "Chapter 1." We display the appended text, roll back the changes, and display the original text. Internal LOBs <EM
CLASS="emphasis"
>can</EM
> participate in database transactions.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_text_loc      CLOB;
   v_text_buffer   VARCHAR2(60);
   v_text_pattern  VARCHAR2(60) := 'dark';
BEGIN
   v_dest_loc := book_text_forupdate ('Chapter 1');
   v_src_loc  := book_text ('Chapter 2');
   DBMS_LOB.APPEND (v_dest_loc, v_src_loc);
END;
/

   SET LONG 200
   COL chapter_descr FOR A15
   COL chapter_text FOR A40 WORD_WRAPPED

@compare_text ('Chapter 1');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 1       It was a dark and stormy night.
                Suddenly a scream rang out.  An
                EXCEPTION had not been handled.  The sun
                shone brightly the following morning.
                All traces of the storm had disappeared.

Rollback complete.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 1       It was a dark and stormy night.
                Suddenly a scream rang out.  An
                EXCEPTION had not been <A
CLASS="indexterm"
NAME="ch08-idx-22583-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22583-1"
></A
>handled.</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.3.2"
>8.3.3.2 The DBMS_LOB.COPY procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22589-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22589-1"
></A
>COPY procedure copies all or part of the contents of a source internal LOB to a destination internal LOB. An offset location in each LOB can be specified. The headers for this program, corresponding to each LOB type, are the following: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.COPY
   (dest_lob IN OUT BLOB,
    src_lob IN BLOB,
    amount IN INTEGER,
    dest_offset IN INTEGER := 1,
    src_offset IN INTEGER := 1);

PROCEDURE DBMS_LOB.COPY
   (dest_lob IN OUT CLOB CHARACTER SET ANY_CS,
    src_lob IN CLOB CHARACTER SET dest_lob%CHARSET,
    amount IN INTEGER,
    dest_offset IN INTEGER := 1,
    src_offset IN INTEGER := 1);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows COPY to be used with BLOBs, CLOBs, and NCLOBs. The term ANY_CS in the specification allows either CLOB or NCLOB locators as input. COPY cannot be used with BFILEs, because access to BFILEs is read-only.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dest_lob</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locator for the destination LOB</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>src_lob</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locator for the source LOB</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>amount</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of bytes (BLOB) or characters (CLOB, NCLOB) to copy</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dest_offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BLOB) or character (CLOB, NCLOB) in the destination LOB at which the copy operation begins; the default value is 1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>src_offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BLOB) or character (CLOB, NCLOB) in the source LOB at which the copy operation begins; the default value is 1</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.2.1"
>8.3.3.2.1 Exceptions</A
></H4
><P
CLASS="para"
>The COPY procedure may raise one of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>VALUE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>One or both LOBs are NULL or invalid.</P
></DD
><DT
CLASS="term"
>INVALID_ARGVAL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>One of the following conditions exists:</P
></DD
></DL
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>src_offset &lt; 1 or src_offset &gt; LOBMAXSIZE</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>dest_offset &lt;1 or dest_offset &gt; LOBMAXSIZE</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>amount &lt; 1 or amount &gt; LOBMAXSIZE</P
></LI
></UL
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-22920 </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>dest_lob is not locked for update.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.2.2"
>8.3.3.2.2 Example</A
></H4
><P
CLASS="para"
>In the following example, the text "Suddenly a scream rang out..." is copied from the "Chapter 1" row of the my_book_text table to the "Chapter 2" row. Note that the COPY operation replaces (i.e., does not append) existing text. We display the copied text, roll back the changes, and display the original text. Internal LOBs <EM
CLASS="emphasis"
>can</EM
> participate in database transactions.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET LONG 200
COL chapter_descr FOR A15
COL chapter_text FOR A40 WORD_WRAPPED

SELECT chapter_descr, chapter_text
  FROM my_book_text;
 
DECLARE
   v_text_loc      CLOB;
   v_text_buffer   VARCHAR2(60);
   v_text_pattern  VARCHAR2(60) := 'dark';
BEGIN
   v_dest_loc := book_text_forupdate ('Chapter 2');
   v_src_loc  := book_text ('Chapter 1');
   DBMS_LOB.COPY(v_dest_loc, v_src_loc, 63, 47 ,34);
END;
/
@compare_text ('Chapter 2');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 1       It was a dark and stormy night.
                Suddenly a scream rang out.  An
                EXCEPTION had not been handled.

Chapter 2       The sun shone brightly the following
                morning.  All traces of the storm had
                disappeared.

PL/SQL procedure successfully completed.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 2       The sun shone brightly the following
                morning. Suddenly a scream rang out.  An
                EXCEPTION had not been handled.

Rollback complete.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 2       The sun shone brightly the following
                morning.  All traces of the storm had
                <A
CLASS="indexterm"
NAME="ch08-idx-22591-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22591-1"
></A
>disappeared.</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.3.3"
>8.3.3.3 The DBMS_LOB.ERASE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22593-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22593-1"
></A
>ERASE procedure removes all or part of the contents of an internal LOB. An offset location in the LOB can be specified. In the middle of a LOB, spaces are written for CLOBs and NCLOBs, and zero-byte filler is written for BLOBs.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.ERASE
   (lob_loc IN OUT BLOB | CLOB CHARACTER SET ANY_CS,
    amount IN OUT INTEGER,
    offset IN INTEGER := 1);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows ERASE to be used with BLOBs, CLOBs, and NCLOBs. The term ANY_CS in the specification allows either CLOB or NCLOB locators as input. ERASE cannot be used with BFILEs because access to BFILEs is read-only.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lob_loc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locator for the LOB to be erased</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>amount</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of bytes (BLOB) or characters (CLOB, NCLOB) to erase</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the byte (BLOB) or character (CLOB, NCLOB) in the LOB at which the erase operation begins; the default value is 1</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.3.1"
>8.3.3.3.1 Exceptions</A
></H4
><P
CLASS="para"
>The ERASE procedure may raise any of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>VALUE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>lob_loc or amount is NULL or invalid.</P
></DD
><DT
CLASS="term"
>INVALID_ARGVAL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>One of the following conditions exists:</P
></DD
></DL
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>amount &lt; 1 or amount &gt; LOBMAXSIZE</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>offset &lt; 1 or offset &gt; LOBMAXSIZE</P
></LI
></UL
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-22920</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>dest_lob is not locked for update.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.3.2"
>8.3.3.3.2 Example</A
></H4
><P
CLASS="para"
>In the following example, we erase the string "brightly" from the "Chapter 2" chapter_textcolumn in the my_book_text table. Note that the string is replaced with spaces. We display the erased text, roll back the changes, and display the original text. Internal LOBs <EM
CLASS="emphasis"
>can</EM
> participate in database transactions.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   SET LONG 200
   COL chapter_descr FOR A15
   COL chapter_text FOR A40 WORD_WRAPPED

   SELECT chapter_descr, chapter_text
     FROM my_book_text
    WHERE chapter_descr = 'Chapter 2';

DECLARE
   v_dest_loc      CLOB;
   v_erase_amt     INTEGER;
BEGIN
   v_dest_loc := book_text_forupdate ('Chapter 2');
   v_erase_amt := 9;
   DBMS_LOB.ERASE(v_dest_loc, v_erase_amt, 15);
END;
/

@compare_text ('Chapter 2');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 2       The sun shone brightly the following
                morning.  All traces of the storm had
                disappeared.

PL/SQL procedure successfully completed.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 2       The sun shone          the following
                morning.  All traces of the storm had
                disappeared.

Rollback complete.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 2       The sun shone brightly the following
                morning.  All traces of the storm had
                <A
CLASS="indexterm"
NAME="ch08-idx-22595-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22595-1"
></A
>disappeared.</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.3.5"
>8.3.3.4 The DBMS_LOB.TRIM procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22597-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22597-1"
></A
>TRIM procedure trims the contents of an internal LOB to a specified length. The headers for this program, corresponding to each LOB type, are the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.TRIM
   (lob_loc IN OUT BLOB|CLOB CHARACTER SET ANY_CS,
    newlen IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows TRIM to be used with BLOBs, CLOBs, and NCLOBs. The term ANY_CS in the specification allows either CLOB or NCLOB locators as input. TRIM cannot be used with BFILEs because access to BFILEs is read-only.</P
><P
CLASS="para"
>The parameters for this program are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lob_loc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locator for the LOB to be erased</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>newlen</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of bytes (BLOB) or characters (CLOB, NCLOB) to remain in the LOB</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.5.1"
>8.3.3.4.1 Exceptions</A
></H4
><P
CLASS="para"
>The TRIM procedure may raise any of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>VALUE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>lob_loc or newlen is NULL or invalid.</P
></DD
><DT
CLASS="term"
>INVALID_ARGVAL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>newlen &lt; 0 or newlen &gt; LOBMAXSIZE.</P
></DD
><DT
CLASS="term"
>ORA-22920</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>dest_lob is not locked for update.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.5.2"
>8.3.3.4.2 Example</A
></H4
><P
CLASS="para"
>In the following example, we trim the "Chapter 1" chapter_textcolumn in the my_book_text table to 31 characters. We display the trimmed text, roll back the changes, and display the original text. Internal LOBs <EM
CLASS="emphasis"
>can</EM
> participate in database transactions.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   SET LONG 200
   COL chapter_descr FOR A15
   COL chapter_text FOR A40 WORD_WRAPPED

   SELECT chapter_descr, chapter_text
     FROM my_book_text
    WHERE chapter_descr = 'Chapter 1';
DECLARE
   v_text_loc CLOB;
BEGIN
   v_text_loc := book_text ('Chapter 1');
   DBMS_LOB.TRIM (v_text_loc, 31);
END;
/
@compare_text ('Chapter 1');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 1       It was a dark and stormy night.
                Suddenly a scream rang out.  An
                EXCEPTION had not been handled.

PL/SQL procedure successfully completed.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 1       It was a dark and stormy night.

Rollback complete.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 1       It was a dark and stormy night.
                Suddenly a scream rang out.  An
                EXCEPTION had not been <A
CLASS="indexterm"
NAME="ch08-idx-22599-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22599-1"
></A
>handled.</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch08-SECT-3.3.6"
>8.3.3.5 The DBMS_LOB.WRITE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch08-idx-22615-0"
></A
>WRITE procedure writes a given number of bytes (BLOB) or characters (CLOB, NCLOB) to an internal LOB, beginning at a specified offset. The contents of the write operation are taken from the buffer. WRITE replaces (overlays) any data that exists in the LOB at the offset. The headers for this program, for each corresponding LOB type, are the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOB.WRITE
   (lob_loc IN OUT BLOB,
    amount IN BINARY_INTEGER,
    offset IN INTEGER,
    buffer IN RAW);

PROCEDURE DBMS_LOB.WRITE
   (lob_loc IN OUT CLOB CHARACTER SET ANY_CS,
    amount IN BINARY_INTEGER,
    offset IN INTEGER,
    buffer IN VARCHAR2 CHARACTER SET lob_loc%CHARSET);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The overloaded specification allows WRITE to be used with BLOBs, CLOBs, and NCLOBs. The term ANY_CS in the specification allows either CLOB or NCLOB locators as input. WRITE cannot be used with BFILEs, because access to BFILEs is read-only.</P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lob_loc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A locator for the target LOB</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>amount</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of bytes (BLOB) or characters (CLOB, NCLOB) to be written</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The location of the byte (BLOB) or character (CLOB, NCLOB) in the LOB at which the write begins</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Buffer holding the contents of the write operation</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.6.1"
>8.3.3.5.1 Exceptions</A
></H4
><P
CLASS="para"
>The WRITE procedure may raise any of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>VALUE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>lob_loc, amount, or offset is NULL or invalid.</P
></DD
><DT
CLASS="term"
>INVALID_ARGVAL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>One of the following conditions exists:</P
></DD
></DL
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>amount &lt; 1 or amount &gt; 32767</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>offset &lt; 1 or offset &gt; LOBMAXSIZE</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch08-SECT-3.3.6.2"
>8.3.3.5.2 Example</A
></H4
><P
CLASS="para"
>In the following example, we write the string "The End" to the end of the "Chapter 2" chapter_textcolumn in the my_book_text table. We display the new text, roll back the changes, and display the original text. Internal LOBs <EM
CLASS="emphasis"
>can</EM
> participate in database transactions.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   SET LONG 200
   COL chapter_descr FOR A15
   COL chapter_text FOR A40 WORD_WRAPPED

   SELECT chapter_descr, chapter_text
     FROM my_book_text
    WHERE chapter_descr = 'Chapter 2';

DECLARE
   v_text_loc CLOB;
   v_offset   INTEGER;
   v_buffer   VARCHAR2(100);
BEGIN
   v_text_loc := book_text_forupdate ('Chapter 1');
   v_offset := DBMS_LOB.GETLENGTH (v_text_loc) + 3;
   v_buffer := 'The End.';
   DBMS_LOB.WRITE (v_text_loc, 8, v_offset, v_buffer);
END;
/

@compare_text ('Chapter 2');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output of the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 2       The sun shone brightly the following
                morning.  All traces of the storm had
                disappeared.

PL/SQL procedure successfully completed.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 2       The sun shone brightly the following
                morning.  All traces of the storm had
                disappeared.  The End.

Rollback complete.

CHAPTER_DESCR   CHAPTER_TEXT
--------------- ----------------------------------------
Chapter 2       The sun shone brightly the following
                morning.  All traces of the <A
CLASS="indexterm"
NAME="ch08-idx-22617-0"
></A
>storm <A
CLASS="indexterm"
NAME="ch08-idx-22580-0"
></A
>had
                <A
CLASS="indexterm"
NAME="ch08-idx-22369-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-22369-1"
></A
>disappeared.</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch08_02.htm#ch08-SECT-2.1"
TITLE="8.2 LOB Concepts"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.2 LOB Concepts"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch09_01.htm"
TITLE="9. Datatype Packages"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 9. Datatype Packages"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.2 LOB Concepts</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>9. Datatype Packages</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
