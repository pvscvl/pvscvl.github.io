<HTML
><HEAD
><TITLE
>[Chapter 4] 4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:49:06Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. User Lock and Transaction Management"><LINK
REL="prev"
HREF="ch04_01.htm"
TITLE="4.1 DBMS_LOCK: Creating and Managing Resource Locks"><LINK
REL="next"
HREF="ch05_01.htm"
TITLE="5. Oracle Advanced Queuing"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_01.htm"
TITLE="4.1 DBMS_LOCK: Creating and Managing Resource Locks"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.1 DBMS_LOCK: Creating and Managing Resource Locks"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. User Lock and Transaction Management"
>Chapter 4<BR>User Lock and Transaction Management</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch05_01.htm"
TITLE="5. Oracle Advanced Queuing"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5. Oracle Advanced Queuing"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch04-11151"
>4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20270-0"
></A
>DBMS_TRANSACTION package provides a programmatic interface to a number of the SQL <A
CLASS="indexterm"
NAME="ch04-idx-20272-0"
></A
>transaction statements. The majority of the DBMS_TRANSACTION programs have SQL equivalents that you can utilize directly from within SQL. For this reason, developers and DBAs may choose to use the direct SQL equivalents rather than these procedures. A number of other procedures and functions have no equivalents, however, and nicely abstract the PL/SQL programmer or database administrator from the internal details managed by the database.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-2.1"
>4.2.1 Getting Started with DBMS_TRANSACTION</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20280-0"
></A
>DBMS_TRANSACTION package is created when the Oracle database is installed. The <I
CLASS="filename"
>dbmsutil.sql</I
> script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1</A
>) contain the source code for this package's specification. This script is called by <I
CLASS="filename"
>catproc.sql</I
>, which is normally run immediately after database creation. The script creates the public synonym <A
CLASS="indexterm"
NAME="ch04-idx-21502-0"
></A
>DBMS_TRANSACTION for the package and grants EXECUTE privilege on the package to public. All Oracle users can reference and make use of this package.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.1.1"
>4.2.1.1 DBMS_TRANSACTION programs</A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch04_02.htm#ch04-SECT-2.1.1"
>Table 4.4</A
> lists the procedures and functions available through <A
CLASS="indexterm"
NAME="ch04-idx-20286-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20286-1"
></A
>DBMS_TRANSACTION, along with their SQL equivalents (if applicable). </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch04-25067"
>Table 4.4: DBMS_TRANSACTION Programs </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in </P
><P
CLASS="para"
>SQL?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20289-0"
></A
>ADVISE_COMMIT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the ALTER SESSION ADVISE COMMIT command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20288-0"
></A
>ADVISE_NOTHING</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the ALTER SESSION ADVISE NOTHING command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20287-0"
></A
>ADVISE_ROLLBACK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the ALTER SESSION ADVISE ROLLBACK command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20300-0"
></A
>BEGIN_DISCRETE_TRANSACTION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sets the discrete transaction mode.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20290-0"
></A
>COMMIT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the COMMIT command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20291-0"
></A
>COMMIT_COMMENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the COMMIT COMMENT command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20292-0"
></A
>COMMIT_FORCE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the COMMIT FORCE command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20303-0"
></A
>LOCAL_TRANSACTION_ID</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns a local (to instance) unique identfier for the current transaction.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20301-0"
></A
>PURGE_MIXED</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Deletes information on a mixed outcome transaction (a possible scenario with two-phase commit).</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20302-0"
></A
>PURGE_LOST_DB_ENTRY</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Removes "lost database entries" otherwise used to control recovery in pending two-phase commit operations.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20298-0"
></A
>READ_ONLY</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the SET TRANSACTION READ ONLY command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20299-0"
></A
>READ_WRITE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the SET TRANSACTION READ WRITE command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20293-0"
></A
>ROLLBACK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the ROLLBACK command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20294-0"
></A
>ROLLBACK_FORCE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the ROLLBACK FORCE command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20296-0"
></A
>ROLLBACK_SAVEPOINT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the ROLLBACK TO command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20295-0"
></A
>SAVEPOINT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the SAVEPOINT command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20304-0"
></A
>STEP_ID</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns a local (to local transaction) unique positive integer that orders the DML operations of a transaction.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20297-0"
></A
>SEGMENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Executes the equivalent of the SET TRANSACTION USE ROLLBACK SEGMENT command.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.1.2"
>4.2.1.2 DBMS_TRANSACTION exceptions</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20305-0"
></A
>DBMS_TRANSACTION package gives names (using the EXCEPTION_INIT pragma) to Oracle exceptions -8175 and -8176 as follows:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description.</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DISCRETE_TRANSACTION_FAILED</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>-8175</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Discrete transaction restriction violated. An attempt was made to perform an action that is not currently supported in a discrete transaction. Roll back the transaction and retry it as a normal transaction.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CONSISTENT_READ_FAILURE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>-8176</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Cannot continue consistent read for the table/index&nbsp;-- no undo records. Oracle encountered an operation that does not generate undo records. Retry the operation with a different snapshot time. If an index is involved, retry the operation without using the index.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>These exceptions may be raised in calls to the BEGIN_DISCRETE_TRANSACTION procedure.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-2.2"
>4.2.2 Advising Oracle About In-Doubt Transactions</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-21458-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-21458-1"
></A
>DBMS_TRANSACTION <A
CLASS="indexterm"
NAME="ch04-idx-21461-0"
></A
>advise procedures (ADVISE_COMMIT, ADVISE_NOTHING, and ADVISE_ROLLBACK) specify what in-doubt transaction advice is sent to remote databases during distributed transactions. This advice appears on the remote database in the ADVICE column of the <A
CLASS="indexterm"
NAME="ch04-idx-21460-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-21460-1"
></A
>DBA_2PC_PENDING data dictionary view if the distributed transaction becomes in doubt (i.e., a network or machine failure occurs during the commit). The remote database administrator can then review the DBA_2PC_PENDING information and manually commit or roll back in-doubt transactions using the FORCE clause of the COMMIT or ROLLBACK commands.</P
><P
CLASS="para"
>Each call to an ADVISE procedure remains in effect for the duration of that connection or until a different ADVISE procedure call is made. This allows you to send different advice to various remote databases. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.2.1"
>4.2.2.1 The DBMS_TRANSACTION.<A
CLASS="indexterm"
NAME="ch04-idx-20319-0"
></A
>ADVISE_ROLLBACK, <A
CLASS="indexterm"
NAME="ch04-idx-20320-0"
></A
>and <A
CLASS="indexterm"
NAME="ch04-idx-20321-0"
></A
>ADVISE_COMMIT procedures</A
></H4
><P
CLASS="para"
>Here are the headers for the three advise procedures:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ADVISE_ROLLBACK;

PROCEDURE DBMS_TRANSACTION.ADVISE_NOTHING;

PROCEDURE DBMS_TRANSACTION.ADVISE_COMMIT;</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-2.2.1.1"
>4.2.2.1.1 Example</A
></H4
><P
CLASS="para"
>In the following example, we address a common data-warehousing scenario. We want to promote daily extract data from our legacy systems to each of our data marts and our corporate data warehouse. First, the extract data is summarized and loaded into a staging database copy of the fact table. Then, this fact table's data is promoted to each of the data marts and the data warehouse. The marketing department wants its data mart loaded very aggressively (i.e., ADVISE_COMMIT). The accounting department, being more conservative, wants its data mart loaded with caution (i.e., ADVISE_ROLLBACK). Finally, management does not have a preference for loading the data warehouse. We could run the following PL/SQL locally from our staging <A
CLASS="indexterm"
NAME="ch04-idx-20416-0"
></A
>database:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   FOR fact_rec IN (SELECT * FROM fact_load_table)
   LOOP
      DBMS_TRANSACTION.ADVISE_COMMIT;
      INSERT INTO fact_table@marketing_data_mart
         VALUES (fact_rec.product_id, fact_rec.location_id,
         fact_record.period_id, fact_rec.numeric_value1);

      DBMS_TRANSACTION.ADVISE_ROLLBACK;
      INSERT INTO fact_table@accounting_data_mart
         VALUES (fact_rec.product_id, fact_rec.location_id, 
         fact_record.period_id, fact_rec.numeric_value1);

       DBMS_TRANSACTION.ADVISE_NOTHING;
       INSERT INTO fact_table@corp_data_warehouse
         VALUES (fact_rec.product_id, fact_rec.location_id, 
         fact_record.period_id, fact_rec.numeric_value1);

      COMMIT;
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-2.3"
>4.2.3 Committing Data</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20322-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20322-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20322-2"
></A
>The DBMS_TRANSACTION package offers a number of programs you can use to issue COMMITs in your application.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.3.1"
>4.2.3.1 The DBMS_TRANSACTION.COMMIT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20326-0"
></A
>COMMIT procedure is provided primarily for completeness. It is equivalent to the COMMIT command of PL/SQL. Here's the header for this procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.COMMIT;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There is no advantage to using this program instead of the COMMIT command.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.3.2"
>4.2.3.2 The  DBMS_TRANSACTION.COMMIT_COMMENT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20327-0"
></A
>COMMIT_COMMENT procedure specifies what<A
CLASS="indexterm"
NAME="ch04-idx-20328-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20328-1"
></A
> in-doubt transaction comment is sent to remote databases during distributed transactions. The specification for the procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.COMMIT_COMMENT (cmnt IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This comment (cmnt parameter) appears on the remote database in the TRAN_COMMENT column of the <A
CLASS="indexterm"
NAME="ch04-idx-20330-0"
></A
>DBA_2PC_PENDING data dictionary view if the distributed transaction becomes in doubt (i.e., a network or machine failure occurs during the commit). The remote database administrator can then review the DBA_2PC_PENDING information and manually commit or roll back in-doubt transactions using the FORCE clause of the COMMIT or ROLLBACK commands.</P
><P
CLASS="para"
>In the following example, we update our previous data mart and data warehouse promotion PL/SQL code to utilize the COMMIT_COMMENT procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   FOR fact_rec IN (SELECT * FROM fact_load_table)
   LOOP
      DBMS_TRANSACTION.ADVISE_COMMIT;
      INSERT INTO fact_table@marketing_data_mart
         VALUES (fact_rec.product_id, 
             fact_rec.location_id, fact_record.period_id, 
             fact_record.numeric value1);

      DBMS_TRANSACTION.ADVISE_ROLLBACK;
      INSERT INTO fact_table@accounting_data_mart
         VALUES (fact_rec.product_id, fact_rec.location_id, 
             fact_record.period_id, 
             fact_rec.numeric_value1);

      DBMS_TRANSACTION.ADVISE_NOTHING;
       INSERT INTO fact_table@corp_data_warehouse
         VALUES (fact_rec.product_id, 
             fact_rec.location_id, fact_record.period_id, 
             fact_rec.numeric_value1);

      DBMS_TRANSACTION.COMMIT_COMMENT
         ('Fact Load for date: '||TO_CHAR(sysdate,'MON-DD-YYYY'));
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.3.3"
>4.2.3.3 The DBMS_TRANSACTION.COMMIT_FORCE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20331-0"
></A
>COMMIT_FORCE procedure manually commits local in doubt, distributed transactions. Here's the specification for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.COMMIT_FORCE
    (xid IN VARCHAR2
    ,scn IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>xid</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The transaction's local or global transaction ID. To find these transaction IDs, query the data dictionary view DBA_2PC_PENDING.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>scn</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>System change number (SCN) under which to commit the transaction.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Specifying a system change number (scn parameter) allows you to commit an in-doubt transaction with the same SCN assigned by other nodes, thus maintaining the synchronized commit time of the distributed transaction. If the scn parameter is omitted, the transaction is committed using the current SCN.</P
><P
CLASS="para"
>Any decisions to force in-doubt transactions should be made after consulting with the database administrator(s) at the remote database location(s). If the decision is made to locally force any transactions, the database administrator should either commit or roll back such transactions (as was done by nodes that successfully resolved the transactions). Otherwise, the administrator should query the <A
CLASS="indexterm"
NAME="ch04-idx-20353-0"
></A
>DBA_2PC_PENDING view's ADVICE and TRAN_COMMENT columns for further insight.</P
><P
CLASS="para"
>For more information on this topic, see "Manually Overriding In-Doubt Transactions" in the Oracle Corporation document <CITE
CLASS="citetitle"
>Oracle8 Server </CITE
><A
CLASS="indexterm"
NAME="ch04-idx-20425-0"
></A
><CITE
CLASS="citetitle"
>Distributed </CITE
><A
CLASS="indexterm"
NAME="ch04-idx-20324-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20324-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20324-2"
></A
><CITE
CLASS="citetitle"
>Systems.</CITE
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-2.4"
>4.2.4 Rolling Back Changes</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20354-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20354-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20354-2"
></A
>DBMS_TRANSACTION package offers a number of programs you can use to issue rollbacks in your application.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.4.1"
>4.2.4.1 The DBMS_TRANSACTION.ROLLBACK procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-21514-0"
></A
>ROLLBACK procedure is provided primarily for completelness. It is equivalent to the ROLLBACK command of PL/SQL. The header for this procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ROLLBACK;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There is no advantage to using this program instead of the ROLLBACK command.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.4.2"
>4.2.4.2 The DBMS_TRANSACTION.ROLLBACK_FORCE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20359-0"
></A
>ROLLBACK_FORCE procedure manually rolls back local <A
CLASS="indexterm"
NAME="ch04-idx-20364-0"
></A
> in-doubt, distributed transactions. The specification for the procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ROLLBACK_FORCE (xid IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where xid identifies the transaction's local or global transaction ID. To find these transaction IDs, query the data dictionary view <A
CLASS="indexterm"
NAME="ch04-idx-20366-0"
></A
>DBA_2PC_PENDING.</P
><P
CLASS="para"
>Any decisions to force in-doubt transactions should be made after consulting with the database administrator(s) at the remote database location(s). If the decision is made to locally force any transactions, the database administrator should either commit or roll back such transactions (as was done by nodes that successfully resolved the transactions). Otherwise, the administrator should query the DBA_2PC_PENDING view's ADVICE and TRAN_COMMENT columns for further insight.</P
><P
CLASS="para"
>For more information on this topic, see "Manually Overriding In-Doubt Transactions" in the Oracle Corporation document <CITE
CLASS="citetitle"
>Oracle8 Server Distributed Systems</CITE
>.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.4.3"
>4.2.4.3 The DBMS_TRANSACTION.SAVEPOINT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20367-0"
></A
>SAVEPOINT procedure is equivalent to the SAVEPOINT command, which is already implemented as part of PL/SQL. The header for this procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.SAVEPOINT (savept IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where savept specifies the savepoint.</P
><P
CLASS="para"
>Why would you use this procedure and not simply rely on the SAVEPOINT command? When you use SAVEPOINT, you must use an "undeclared identifier" for the savepoint:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   SAVEPOINT right_here;
   do_my_stuff;
EXCEPTION
   WHEN OTHERS
   THEN
      ROLLBACK TO right_here;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The "right_here" identifier is not declared anywhere; it is simply hard-coded into your application. With the DBMS_TRANSACTION programs, you can soft code these savepoint names, as you can see from the following block:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_sp VARCHAR2(30) := 'right_here';
BEGIN
   DBMS_TRANSACTION.SAVEPOINT (v_sp);
   do_my_stuff;

EXCEPTION
   WHEN OTHERS
   THEN
      /* Soft-coded rollback to, as well! */
      DBMS_TRANSACTION.ROLLBACK_SAVEPOINT (v_sp);
END;
/</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.4.4"
>4.2.4.4 The DBMS_TRANSACTION.ROLLBACK_SAVEPOINT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20368-0"
></A
>ROLLBACK_SAVEPOINT procedure is equivalent to the ROLLBACK TO command in PL/SQL. The header for this procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.ROLLBACK_SAVEPOINT (savept IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where savept specifies the savepoint.</P
><P
CLASS="para"
>You should use this program in coordination with the SAVEPOINT procedure, as illustrated in the example in the previous section. With this program, you can roll back to a savepoint that is not hard-coded into your application.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.4.5"
>4.2.4.5 The DBMS_TRANSACTION.USE_ROLLBACK_SEGMENT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20369-0"
></A
>USE_ROLLBACK_SEGMENT procedure assigns the current transaction to the specified rollback segment. This option also establishes the transaction as a read-write transaction. </P
><P
CLASS="para"
>Here's the specification for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.USE_ROLLBACK_SEGMENT (rb_name IN VARCHAR2); </PRE
></BLOCKQUOTE
><P
CLASS="para"
>The specified rollback segment (rb_name) must be online. Often, the rollback specified is a large one that is kept offline during the day and is specifically enabled at night for large batch jobs. You cannot use both the DBMS_TRANSACTION.READ_ONLY (see next section) and the USE_ROLLBACK_SEGMENT procedures within the same transaction. Read-only transactions do not generate rollback information and thus cannot be assigned rollback segments.</P
><P
CLASS="para"
>In the following example, we have modified our data warehousing extract promotion program to reference the staging fact table remotely in order to load our local fact table&nbsp;-- and to do so utilizing the big rollback segment. This version of the code has the advantage that it could be run without change from each remote database (assuming that each remote database had a big rollback segment named BIG_RBS).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_TRANSACTION.USE_ROLLBACK_SEGMENT('BIG_RBS');
   INSERT INTO fact_table
      SELECT * FROM fact_table@staging;
   COMMIT;
 <A
CLASS="indexterm"
NAME="ch04-idx-20356-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20356-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20356-2"
></A
>END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-2.5"
>4.2.5 Setting Transaction Characteristics</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20380-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20380-1"
></A
>DBMS_TRANSACTION offers several programs that set various characteristics of the transaction for your session.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.5.1"
>4.2.5.1 The DBMS_TRANSACTION.READ_ONLY procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20384-0"
></A
>READ_ONLY procedure establishes transaction-level read consistency (i.e., <A
CLASS="indexterm"
NAME="ch04-idx-20385-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20385-1"
></A
>repeatable reads). Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.READ_ONLY;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Once a transaction is designated as read-only, all queries within that transaction can see only changes committed prior to that transaction's start. Hence, read-only transactions permit you to issue two or more queries against tables that may be undergoing concurrent inserts or updates, and yet return results consistent as of the transaction's start. The READ_ONLY procedure is quite useful for reports. Long-running read-only transactions can receive a "snapshot too old" error (ORA-01555). If this occurs, increase rollback segment sizes. </P
><P
CLASS="para"
>In the following example, we can separately query the order and item tables successfully, regardless of other transactions. Even if someone deletes the item we are interested in while we query the order, a read-consistent image will be maintained in the rollback segments. So we will always be able to see the items for any order we look at.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   lv_order_count INTEGER := 0;
  lv_item_count INTEGER := 0;
BEGIN
   DBMS_TRANSACTION.READ_ONLY;
   SELECT COUNT(*) INTO lv_order_count FROM order WHERE order_number = 12345;
   SELECT COUNT(*) INTO lv_item_count FROM item WHERE order_number = 12345;
END;
/</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.5.2"
>4.2.5.2 The DBMS_TRANSACTION.READ_WRITE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20386-0"
></A
>READ_WRITE procedure establishes the current transaction as a<A
CLASS="indexterm"
NAME="ch04-idx-20387-0"
></A
> read-write transaction. As this is the default transaction mode, you will not often need to use this procedure. The header for this program follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.READ_WRITE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following example demonstrates using READ_WRITE in a transaction where we want to delete an order and its associated items. However, this example would execute in exactly the same way, even if the READ_WRITE procedure call were commented out. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_TRANSACTION.READ_WRITE;
   DELETE FROM item WHERE order_number = 12345;
   DELETE FROM order WHERE order_number = 12345;
END;
/</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.5.3"
>4.2.5.3 The DBMS_TRANSACTION.BEGIN_DISCRETE_TRANSACTION procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20392-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20392-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20392-2"
></A
>BEGIN_DISCRETE_TRANSACTION procedure streamlines transaction processing so that <A
CLASS="indexterm"
NAME="ch04-idx-20397-0"
></A
>short transactions can execute more rapidly. The header for this program follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.BEGIN_DISCRETE_TRANSACTION;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>During discrete transactions, normal redo information is generated, although it is stored in a separate location in memory. When the discrete transaction commits, the redo information is written to the redo log file and data block changes are applied directly. As a result, there is no need for undo information in rollback segments. The block is then written to the database file in the usual manner. The call to this procedure is effective only until the transaction is committed or rolled back; the next transaction is processed as a standard transaction.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-2.5.3.1"
>4.2.5.3.1 Restrictions</A
></H4
><P
CLASS="para"
>Although discrete transactions offer improved performance, there are numerous restrictions:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The database initialization parameter DISCRETE_TRANSACTIONS_ENABLED must be set to TRUE; otherwise, calls to this procedure are ignored and transactions function normally.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Discrete transactions cannot be distributed transactions.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Discrete transactions can change each database block only once.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Discrete transactions cannot see their own changes (since there are no rollback segments).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Discrete transactions cannot perform inserts or updates on both tables involved in a referential integrity constraint.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Discrete transactions cannot modify tables containing any LONG values.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-2.5.3.2"
>4.2.5.3.2 Exceptions</A
></H4
><P
CLASS="para"
>This procedure may raise either of the following exceptions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_TRANSACTION.DISCRETE_TRANSACTION_FAILED
DBMS_TRANSACTION.CONSISTENT_READ_FAILURE</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-2.5.3.3"
>4.2.5.3.3 Example</A
></H4
><P
CLASS="para"
>In the following example, we have modified the last version of our data warehousing extract promotion program to utilize discrete transactions. The code is written in such a way that it ensures that the transaction is attempted again in the event of a discrete transaction failure. This coding practice should be followed strictly.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   FOR fact_rec in (SELECT * FROM fact table@staging)
   LOOP
      DBMS_TRANSACTION. BEGIN_DISCRETE_TRANSACTION;
      FOR I in 1 .. 2
      LOOP
         BEGIN
            INSERT INTO fact_table
               VALUES (fact_rec.product_id, 
                  fact_rec.location_id,
                  fact_record.period_id, 
                  fact_rec.numeric_value1, 
                  fact_rec.numeric_value2);
            COMMIT;
            EXIT;
         EXCEPTION
            WHEN DBMS_TRANSACTION.DISCRETE_TRANSACTION_FAILED 
            THEN 
               ROLLBACK; 
         END;
      END LOOP;
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>For more information on this topic, see "Using Discrete Transactions" in the Oracle Corporation document <CITE
CLASS="citetitle"
>Oracle8 </CITE
><A
CLASS="indexterm"
NAME="ch04-idx-20395-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20395-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20395-2"
></A
><CITE
CLASS="citetitle"
>Server </CITE
><A
CLASS="indexterm"
NAME="ch04-idx-20382-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20382-1"
></A
><CITE
CLASS="citetitle"
>Tuning</CITE
>. </P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-2.6"
>4.2.6 Cleaning Up Transaction Details</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20398-0"
></A
>When performing two-phase commits, it is possible to "strand" information about recovery or resolution steps. The two procedures PURGE_MIXED and PURGE_LOST_DB_ENTRY are provided by Oracle to clean up that information.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.6.1"
>4.2.6.1 The DBMS_TRANSACTION.PURGE_MIXED procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20400-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20400-1"
></A
>PURGE_MIXED procedure deletes information about a given in-doubt, distributed transaction that has had mixed outcomes as the consequence of transaction resolution mismatch. This occurs when an in-doubt, distributed transaction is forced to commit or roll back on one node, and other nodes do the opposite. For example, we may force commit on node 1 a distributed transaction that rolled back on node 2. Oracle cannot automatically resolve such inconsistencies, but it does flag entries in the <A
CLASS="indexterm"
NAME="ch04-idx-20401-0"
></A
>DBA_2PC_PENDING view by setting the MIXED column to "yes." When the database administrator is sure that any inconsistencies for a transaction have been resolved, he or she can call PURGE_MIXED procedure. The specification for the procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.PURGE_MIXED (xid IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where xid identifies the mixed transaction's local transaction ID, which can be found in the LOCAL_TRAN_ID column of the data dictionary view DBA_2PC_PENDING.</P
><P
CLASS="para"
>For more information on this topic, see "Manually Overriding In-Doubt Transactions" in the Oracle Corporation document <CITE
CLASS="citetitle"
>Oracle8 Server Distributed Systems</CITE
>.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.6.2"
>4.2.6.2 The DBMS_TRANSACTION.PURGE_LOST_DB_ENTRY procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20402-0"
></A
>PURGE_LOST_DB_ENTRY procedure deletes information about a given in-doubt, distributed transaction that has had mixed outcomes as the consequence of a lost database. This occurs when an in-doubt, distributed transaction is able to commit or roll back on one node and other nodes have either destroyed or recreated their databases. For example, we may successfully commit on node 1 a distributed transaction that is no longer represented in the recreation of the database now on node 2. Oracle cannot automatically resolve such inconsistencies. The information in DBA_2PC_PENDING will never be deleted, and Oracle will try periodically to recover (even though it can't). </P
><P
CLASS="para"
>When the database administrator is sure that any inconsistencies for a transaction have been resolved, he or she can call the PURGE_MIXED procedure. </P
><P
CLASS="para"
>The specification for the procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_TRANSACTION.PURGE_LOST_DB_ENTRY (xid IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where xid identifies the mixed transaction's local transaction ID, which can be found in the LOCAL_TRAN_ID column of the data dictionary view DBA_2PC_PENDING.</P
><P
CLASS="para"
>Oracle's <I
CLASS="filename"
>dbmsutil.sql</I
> file, which contains the definition of the DBMS_TRANSACTION package, offers some insights into when and how you would use this program. According to that file, the DBMS_TRANSACTION.PURGE_LOST_DB_ENTRY procedure should only be used when the other database is lost or has been recreated. Any other use may leave that other database in an unrecoverable or inconsistent state. </P
><P
CLASS="para"
>Before you run <A
CLASS="indexterm"
NAME="ch04-idx-20407-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20407-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20407-2"
></A
>automatic recovery, the transaction appears in the <A
CLASS="indexterm"
NAME="ch04-idx-20406-0"
></A
>DBA_2PC_PENDING view in the state "collecting," "committed," or "prepared." If the DBA has forced an in-doubt transaction to have a particular result by using the COMMIT FORCE or ROLLBACK FORCE options, then the additional states FORCED COMMIT or FORCED ROLLBACK may also appear. </P
><P
CLASS="para"
>Automatic recovery will normally delete entries that are in any of these states. The only exception occurs when the recovery process finds a forced transaction that is in a state inconsistent with other sites in the transaction. In this case, the entry will be left in the table and the MIXED column will be given a value of "yes."</P
><P
CLASS="para"
>Under certain conditions, it may not be possible for an automatic recovery to execute without errors. For example, a remote database may have been permanently lost. In this case, even if it is recreated, it will be assigned a new database ID. As a result, recovery cannot identify it. (A possible symptom for this situation is when the ORA-02062 error is raised.)</P
><P
CLASS="para"
>In this case, the DBA may use the DBMS_TRANSACTION.PURGE_LOST_DB_ENTRY procedure to clean up any entries whose state is not "prepared." </P
><P
CLASS="para"
>The following table indicates what the various states indicate about the transaction and what the DBA actions should be. </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>State Column</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>State of Global Transaction</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>State of Local Transaction</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Normal DBA Action</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Alternative DBA Action</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Collecting</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Rolled back</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Rolled back</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>None</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PURGE_LOST_DB_ENTRY[<A
CLASS="footnote"
HREF="#ch04-pgfId-19994"
>1</A
>]</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Committed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Committed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Committed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>None</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PURGE_LOST_DB_ENTRY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Prepared</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unknown</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unknown</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>None</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COMMIT_FORCE or</P
><P
CLASS="para"
>ROLLBACK_FORCE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Forced commit</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unknown</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Committed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>None</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PURGE_LOST_DB_ENTRY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Forced rollback</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unknown</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Rolled back</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>None</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PURGE_LOST_DB_ENTRY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Forced commit (mixed)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Mixed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Committed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>[<A
CLASS="footnote"
HREF="#ch04-pgfId-20045"
>2</A
>]</P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Forced rollback (mixed)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Mixed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Rolled back</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
></TBODY
></TABLE
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch04-pgfId-19994"
>[1]</A
> Use only if significant reconfiguration has occurred so that automatic recovery cannot resolve the transaction.  Examples are total loss of the remote database, reconfiguration in software resulting in loss of two-phase commit capability, or loss of information from an external transaction coordinator such as a TP monitor.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch04-pgfId-20045"
>[2]</A
> Examine manual action to remove inconsistencies, then use the PROCEDURE_PURGE_MIXED. The xid argument must be set to the value of the LOCAL_TRAN_ID column in the DBA_2PC_PENDING table.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>For more information on this topic, see "Manually Overriding In-Doubt Transactions" in the Oracle Corporation document <CITE
CLASS="citetitle"
>Oracle8 Server Distributed Systems,</CITE
> and the dbmsutil file under <A
CLASS="indexterm"
NAME="ch04-idx-20409-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20409-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20409-2"
></A
>comments <A
CLASS="indexterm"
NAME="ch04-idx-20404-0"
></A
>for <A
CLASS="indexterm"
NAME="ch04-idx-20399-0"
></A
>PURGE_LOST_DB_ENTRY.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-2.7"
>4.2.7 Returning Transaction Identifiers</A
></H3
><P
CLASS="para"
>The functions described in this section return indentifiers used by DBMS_TRANSACTION.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.7.1"
>4.2.7.1 The DBMS_TRANSACTION.LOCAL_TRANSACTION_ID function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20411-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20411-1"
></A
>LOCAL_TRANSACTION_ID function returns the unique identifier for the current transaction. The specification for the function follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_TRANSACTION.LOCAL_TRANSACTION_ID
   (create_transaction IN BOOLEAN := FALSE)
RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The create_transaction parameter specifies whether to create a new transaction or use the current one. The function returns NULL if there is no current transaction.</P
><P
CLASS="para"
>So in your session, the transaction ID begins as NULL and is assigned a value upon first DML operation (transaction initiation). Transaction closure (COMMIT or ROLLBACK) nullifies the transaction ID. Explicit transaction initiation (passing TRUE for second argument to procedure call) assigns a new transaction ID value, regardless of whether you've actually started a transaction.</P
><P
CLASS="para"
>See an example of using this function in the next section (STEP_ID).</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-2.7.2"
>4.2.7.2 The DBMS_TRANSACTION.STEP_ID function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20412-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20412-1"
></A
>STEP_ID function returns the unique positive integer that orders the DML operations of the current transaction. Here's the specification for the function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_TRANSACTION.STEP_ID RETURN NUMBER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If a transaction has not been initiated, then this function returns NULL. Values of step ID across transactions do not appear to have any guaranteed relationship to each other. Within a transaction, however, they will always be increasing.</P
><P
CLASS="para"
>The following script (written by John Beresniewicz) demonstrates the usage and output of the LOCAL_TRANSACTION_ID and STEP_ID functions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch04-idx-21497-0"
></A
> transid.sql */*
set serveroutput on size 1000000
CREATE TABLE foo (col1 NUMBER);
DECLARE
   trx   VARCHAR2(200);
   step  NUMBER;

   PROCEDURE printem(message_IN IN VARCHAR2)
   IS
   BEGIN
      DBMS_OUTPUT.PUT_LINE(message_IN);
      DBMS_OUTPUT.PUT_LINE
         ('Trx id: '||RPAD(NVL(trx,'NULL'),30)||
          'Step: '||NVL(TO_CHAR(step),'NULL') );
   END printem;
   
   PROCEDURE getem
   IS 
   BEGIN
      trx := DBMS_TRANSACTION.local_transaction_id;
      step := DBMS_TRANSACTION.step_id;
   END getem;
        
BEGIN
   /* close any open transaction */
   COMMIT; 
   /* how does it look at start of trx? */
   getem; printem('BEGIN');
   /*
   || do some DML and see  how step changes
   */
   INSERT INTO foo SELECT ROWNUM FROM dictionary;
   getem; printem('INSERT');
   UPDATE foo SET col1 = col1 + 1;
   getem; printem('UPDATE');
   DELETE FROM foo WHERE MOD(col1,2) = 0;
   getem; printem('DELETE');
   /* 
   || now commit, they should be null
   */
   COMMIT;
   getem; printem('COMMIT');
   /*
   || now explicitly open a new transaction
   */ 
   trx := DBMS_TRANSACTION.local_transaction_id(TRUE);
   getem; printem('NEW TRX FORCED');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The results of this script follow:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @transid.sql
Table created.
BEGIN
Trx id: NULL                          Step: NULL
INSERT
Trx id: 1.6.28680                     Step: 42802896748631309
UPDATE
Trx id: 1.6.28680                     Step: 42802896748632625
DELETE
Trx id: 1.6.28680                     Step: 42802896748633616
COMMIT
Trx id: NULL                          Step: NULL
NEW TRX FORCED
<A
CLASS="indexterm"
NAME="ch04-idx-20274-0"
></A
>Trx id: 2.7.28508                     <A
CLASS="indexterm"
NAME="ch04-idx-20271-0"
></A
>Step: 42045333236522790</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_01.htm"
TITLE="4.1 DBMS_LOCK: Creating and Managing Resource Locks"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.1 DBMS_LOCK: Creating and Managing Resource Locks"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch05_01.htm"
TITLE="5. Oracle Advanced Queuing"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5. Oracle Advanced Queuing"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.1 DBMS_LOCK: Creating and Managing Resource Locks</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>5. Oracle Advanced Queuing</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
