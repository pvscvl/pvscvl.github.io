<HTML
><HEAD
><TITLE
>[Chapter 12] Managing Server Resources</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:58:39Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part03.htm"
TITLE="III. Server Management Packages"><LINK
REL="prev"
HREF="ch11_02.htm#ch11-SECT-2.2.1"
TITLE="11.2 DBMS_System: Setting Events for Debugging"><LINK
REL="next"
HREF="ch12_02.htm#ch12-SECT-2.1"
TITLE="12.2 DBMS_SHARED_POOL: Pinning Objects"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm#ch11-SECT-2.2.1"
TITLE="11.2 DBMS_System: Setting Events for Debugging"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 11.2 DBMS_System: Setting Events for Debugging"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 12</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch12_02.htm#ch12-SECT-2.1"
TITLE="12.2 DBMS_SHARED_POOL: Pinning Objects"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 12.2 DBMS_SHARED_POOL: Pinning Objects"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="PACKAGES-CH-12"
>12. Managing Server Resources</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch12-27596"
TITLE="12.1 DBMS_SPACE: Obtaining Space Information"
>DBMS_SPACE: Obtaining Space Information</A
><BR><A
CLASS="sect1"
HREF="ch12_02.htm#ch12-SECT-2.1"
TITLE="12.2 DBMS_SHARED_POOL: Pinning Objects"
>DBMS_SHARED_POOL: Pinning Objects</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch12-idx-12595-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12595-1"
></A
>Through built-in packages, Oracle is now exposing more information about database internals&nbsp;-- information that is not directly visible in the catalog. This chapter describes two packages that expose useful information.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>DBMS_SPACE </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Gives DBAs an analysis of the amount of space both used and free within a table, index, or cluster segment. It also provides information about segment free list sizes&nbsp;-- information of special interest to Oracle Parallel Server administrators. </P
></DD
><DT
CLASS="term"
>DBMS_SHARED_POOL </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>On the memory side, gives DBAs some measure of control over the Oracle System Global Area's (SGA's) shared pool. By pinning large packages into the shared pool, expensive runtime memory management (and even errors) can be avoided. </P
></DD
></DL
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch12-27596"
>12.1 DBMS_SPACE: Obtaining Space Information</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch12-idx-12603-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12603-1"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12603-2"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12603-3"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12603-4"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12603-5"
></A
>The DBMS_SPACE package provides procedures for obtaining space utilization information about table, index, and cluster segments. This information is not directly available through the Oracle data dictionary views. It can be used to report on and track segment space consumption in an Oracle database more accurately than by monitoring extent allocation alone. By measuring segment growth rates over time, DBAs can better predict the need for additional space in the database. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch12-SECT-1.1"
>12.1.1 Getting Started with DBMS_SPACE</A
></H3
><P
CLASS="para"
>The DBMS_SPACE package is <A
CLASS="indexterm"
NAME="ch12-idx-12607-0"
></A
>created when the Oracle database is installed. The <I
CLASS="filename"
>dbmsutil.sql </I
>script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1, <CITE
CLASS="chapter"
>Introduction</CITE
></A
>) contains the source code for this package's specification. This script is called by <I
CLASS="filename"
>catproc.sql</I
>, which is normally run immediately after database creation. The script creates the public synonym <A
CLASS="indexterm"
NAME="ch12-idx-13689-0"
></A
>DBMS_SPACE for the package and grants EXECUTE privilege on the package to public. All Oracle users can reference and make use of this package.</P
><P
CLASS="para"
>Table <A
CLASS="xref"
HREF="ch12_01.htm"
>Table 12.1</A
> <A
CLASS="indexterm"
NAME="ch12-idx-12615-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12615-1"
></A
>lists the programs in the DBMS_SPACE package.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch12-34461"
>Table 12.1: DBMS_SPACE Programs</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in</P
><P
CLASS="para"
>SQL?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>FREE_BLOCKS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns information on free blocks for a segment</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch12-idx-12617-0"
></A
>UNUSED_SPACE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns unused space information for a segment</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch12-idx-13690-0"
></A
>DBMS_SPACE package does not declare any exceptions or nonprogram elements.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch12-SECT-1.2"
>12.1.2 The DBMS_SPACE Interface</A
></H3
><P
CLASS="para"
>This section describes the programs defined in DBMS_SPACE.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch12-SECT-1.2.1"
>12.1.2.1 The DBMS_SPACE.FREE_BLOCKS procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch12-idx-12619-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12619-1"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12619-2"
></A
>FREE_BLOCKS procedure returns information about the number of blocks on Oracle's freelist groups for a table, index, or cluster segment. Specifications for Oracle7 and Oracle8 vary as follows.</P
><P
CLASS="para"
>Here is the Oracle 7.x specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SPACE.FREE_BLOCKS
   (segment_owner IN VARCHAR2
   ,segment_name IN VARCHAR2
   ,segment_type IN VARCHAR2
   ,freelist_group_id IN NUMBER
   ,free_blks OUT NUMBER
   ,scan_limit IN NUMBER DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the Oracle 8.0 specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SPACE.FREE_BLOCKS
   (segment_owner IN VARCHAR2
   ,segment_name IN VARCHAR2
   ,segment_type IN VARCHAR2
   ,freelist_group_id IN NUMBER
   ,free_blks OUT NUMBER
   ,scan_limit IN NUMBER DEFAULT NULL
   ,partition_name IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>segment_owner</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Schema of segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>segment_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>segment_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Type of segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>freelist_group_id</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Freelist group to compute</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>free_blks</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of blocks on freelist</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>scan_limit</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Maximum blocks to read</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>partition_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of partition (8.0 only)</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24701"
>12.1.2.1.1 Exceptions</A
></H4
><P
CLASS="para"
>The FREE_BLOCKS procedure does not raise any package exceptions. FREE_BLOCKS will raise the following Oracle exception if invalid segment data is passed in or if the executing user does not have privileges to use the procedure on the segment:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-00942 </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Table or view does not exist.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24709"
>12.1.2.1.2 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on using FREE_BLOCKS:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The user must have the ANALYZE ANY system privilege to use DBMS_SPACE.FREE_BLOCKS on segments from schemas other than the current session schema. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24717"
>12.1.2.1.3 Example</A
></H4
><P
CLASS="para"
>The following code block is a simple SQL*Plus report on the size of freelist number 0 for all tables in the current session schema:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: s<A
CLASS="indexterm"
NAME="ch12-idx-12626-0"
></A
>pcex1.sql */*
DECLARE
   free_blocks   NUMBER;
BEGIN
   DBMS_OUTPUT.PUT_LINE(RPAD('TABLE NAME',30)||' FREELIST BLOCKS');

   FOR user_tables_rec IN
      (SELECT table_name 
         FROM user_tables)
   LOOP
      DBMS_SPACE.FREE_BLOCKS
         (segment_owner =&gt; USER
         ,segment_name  =&gt; user_tables_rec.table_name
         ,segment_type  =&gt; 'TABLE'
         ,freelist_group_id  =&gt; 0
         ,free_blks =&gt; free_blocks
         ,scan_limit =&gt; NULL);
      
      DBMS_OUTPUT.PUT_LINE(RPAD(user_tables_rec.table_name,30)||' '||
                  TO_CHAR(free_blocks));
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is a sample of the report output:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TABLE NAME                     FREELIST BLOCKS
Q$BGP_CONFIG                   1
Q$BGP_DEBUG                    1
Q$DICACHE_DETL                 2
Q$INSTAT_DETL                  1
Q$INSTAT_LOG                   159
Q$IOWAITS_DETL                 1
Q$LATCHSTAT_DETL               2
Q$LIBCACHE_DETL                1
Q$MTSDISP_DETL                 1
Q$MTSSERV_DETL                 1
Q$PLAN_TABLE                   1
Q$SEG                          3
Q$SEGFAIL_DETL                 1
Q$SEGWATCH                     1
Q$SESSIONWAIT_DETL             1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Blocks are added to free lists when the percentage of free space in the block is less that the PCTUSE setting for the segment. These blocks are below the segment highwater mark, and thus are not included in the unused blocks reported by DBMS_SPACE.UNUSED_SPACE.</P
><P
CLASS="para"
>Freelist groups are used to reduce contention in Oracle Parallel Server installations by helping to partition data among the instances. Most DBAs will thus have less use for the FREE_BLOCKS procedure than for the UNUSED_SPACE procedure. </P
><P
CLASS="para"
>For more information about freelists and how they can be used to minimize contention, see the <EM
CLASS="emphasis"
>Oracle7 Parallel Server Concepts and Administration</EM
> <A
CLASS="indexterm"
NAME="ch12-idx-12621-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12621-1"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12621-2"
></A
>manual.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch12-SECT-1.2.2"
>12.1.2.2 The DBMS_SPACE.UNUSED_SPACE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch12-idx-12627-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12627-1"
></A
>UNUSED_SPACE procedure returns information about the unused space and the position of the highwater mark in a table, index, or cluster segment. Specifications for Oracle7 and Oracle8 differ as follows.</P
><P
CLASS="para"
>Here is the Oracle 7.x specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SPACE.UNUSED_SPACE
   (segment_owner IN VARCHAR2
   ,segment_name IN VARCHAR2
   ,segment_type IN VARCHAR2
   ,total_blocks OUT NUMBER
   ,total_bytes OUT NUMBER
   ,unused_blocks OUT NUMBER
   ,unused_bytes OUT NUMBER
   ,last_used_extent_file_id OUT NUMBER
   ,last_used_extent_block_id OUT NUMBER
   ,last_used_block OUT NUMBER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the Oracle 8.0 specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SPACE.UNUSED_SPACE
   (segment_owner IN VARCHAR2
   ,segment_name IN VARCHAR2
   ,segment_type IN VARCHAR2
   ,total_blocks OUT NUMBER
   ,total_bytes OUT NUMBER
   ,unused_blocks OUT NUMBER
   ,unused_bytes OUT NUMBER
   ,last_used_extent_file_id OUT NUMBER
   ,last_used_extent_block_id OUT NUMBER
   ,last_used_block OUT NUMBER
   ,partition_name IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>segment_owner</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Schema of segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>segment_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>segment_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Type of segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>total_blocks</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Total data blocks in segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>total_bytes</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Total bytes in segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>unused_blocks</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Total unused blocks in segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>unused_bytes</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Total unused bytes in segment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>last_used_extent_file_id</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>File id of last used extent</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>last_used_extent_block_id</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Block id of last used extent</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>last_used_block</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Last used block in extent</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>partition_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of partition (8.0 only)</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24811"
>12.1.2.2.1 Exceptions</A
></H4
><P
CLASS="para"
>The UNUSED_SPACE procedure does not raise any package exceptions. UNUSED_SPACE will raise the following Oracle exception if invalid segment data is passed in or if the executing user does not have privileges to use the procedure on the segment:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-00942</DT
><DD
CLASS="listitem"
><P
CLASS="para"
> Table or view does not exist.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24819"
>12.1.2.2.2 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling the UNUSED_SPACE procedure:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The user must have the ANALYZE ANY system privilege to use UNUSED_SPACE on segments from schemas other than the current session schema.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24827"
>12.1.2.2.3 Example</A
></H4
><P
CLASS="para"
>The following is a simple SQL*Plus report on space utilization by tables in the current session schema. It displays total space allocated, total unused space, and the percentage of allocated space that is unused.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>//* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch12-idx-12631-0"
></A
>spcex1.sql */*
DECLARE
   total_blocks  NUMBER;
   total_bytes   NUMBER;
   unused_blocks NUMBER;
   unused_bytes  NUMBER;
   last_extent_file  NUMBER;
   last_extent_block NUMBER;
   last_block    NUMBER;
   grand_total_blocks NUMBER := 0;
   grand_total_unused NUMBER := 0;

BEGIN
   FOR user_tables_rec IN
      (SELECT table_name 
         FROM user_tables)
   LOOP
      DBMS_SPACE.UNUSED_SPACE
         (segment_owner =&gt; USER
         ,segment_name  =&gt; user_tables_rec.table_name
         ,segment_type  =&gt; 'TABLE'
         ,total_blocks  =&gt; total_blocks
         ,total_bytes   =&gt; total_bytes
         ,unused_blocks =&gt; unused_blocks
         ,unused_bytes  =&gt; unused_bytes
         ,last_used_extent_file_id =&gt; last_extent_file
         ,last_used_extent_block_id =&gt; last_extent_block
         ,last_used_block  =&gt; last_block
         );

      grand_total_blocks := grand_total_blocks + total_blocks;
      grand_total_unused := grand_total_unused + unused_blocks;
   END LOOP;

   DBMS_OUTPUT.PUT_LINE('Space utilization (TABLES) ');
   DBMS_OUTPUT.PUT_LINE('total blocks: '||
                                 TO_CHAR(grand_total_blocks) );
   DBMS_OUTPUT.PUT_LINE('unused blocks: '||
                                 TO_CHAR(grand_total_unused) );
   DBMS_OUTPUT.PUT_LINE('pct unused: '||
      TO_CHAR(ROUND((grand_total_unused/grand_total_blocks)*100) ) );
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is a sample of the report output:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Space utilization (TABLES)
total blocks: 1237
unused blocks: 613
pct unused: 50</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In Oracle 8.0, the partition_name parameter was added to support space analysis for partitioned segments. Since the new parameter has a default value, calls to UNUSED_SPACE written to the version 7.x specification will continue to work under 8.0.</P
><BLOCKQUOTE
CLASS="warning"
><P
CLASS="para"
><STRONG
>WARNING:</STRONG
> Under Oracle 8.0, calling DBMS_SPACE.UNUSED_SPACE for a segment results in a DDL lock being held on the segment until the PL/SQL scope within which the call is made completes. This prevents any other DDL from being executed on the segment, so long-running programs that use the UNUSED_SPACE procedure could cause unexpected interference with other DDL operations in the database.</P
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch12-idx-12632-0"
></A
>Unused space can be deallocated from segments and returned to the free space for the segment's tablespace using the following SQL command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ALTER [ TABLE | INDEX | CLUSTER ] segment_name DEALLOCATE UNUSED;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>For information on how Oracle allocates and manages segment space, see the <EM
CLASS="emphasis"
>Oracle7 Server Concepts</EM
> manual. For information on the DEALLOCATE UNUSED clause of the ALTER TABLE statement, see the <EM
CLASS="emphasis"
>Oracle7 Server SQL</EM
> <A
CLASS="indexterm"
NAME="ch12-idx-12629-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12629-1"
></A
><EM
CLASS="emphasis"
>Reference</EM
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch12-SECT-1.3"
>12.1.3 DBMS_SPACE Examples</A
></H3
><P
CLASS="para"
>The DBMS_SPACE package is a good example of how Oracle Corporation is using the built-in packages to expose, in a controlled way, information about database internals not found in the data dictionary. </P
><P
CLASS="para"
>DBAs managing large transaction-oriented databases must pay attention to space utilization within segments. The UNUSED_SPACE procedure provides an additional level of detail that can help the DBAs make better use of space. For instance, wasted space that can be freed back to the tablespace for use by other segments can be detected and measured. Also, segment growth rates can be measured more accurately than by monitoring extent allocation, providing better information on the need to expand tablespaces.</P
><P
CLASS="para"
>DBAs, especially those with Oracle parallel server installations, will be interested additionally in monitoring the segment freelist information exposed by the FREE_BLOCKS procedure. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch12_01.htm"
>Figure 12.1</A
> illustrates how the blocks of a segment fall into one of three categories: used, unused (above the highwater mark), and on the free list. The latter two categories are the subject of the UNUSED_SPACE and FREE_BLOCKS procedures, respectively.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch12-13086"
>Figure 12.1: Space utilization in a segment</A
></H4
><IMG
CLASS="graphic"
SRC="figs/obip.1201.gif"
ALT="Figure 12.1"><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch12-idx-12633-0"
></A
>I really like the information available in the DBMS_SPACE programs. However, I find that the programs are very unwieldy to use, due to their long, cumbersome parameter lists. The UNUSED_SPACE procedure has at least three IN parameters and seven OUT parameters! Even the earlier simple illustrative example is many lines long. What if you're interested in only one of the OUT parameters&nbsp;-- say, unused_blocks? You still have to allocate variables to hold all the other OUT parameters just to make the procedure call. Wouldn't it be nice to simply call a function that returns the unused blocks number for a given segment? </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch12-SECT-1.3.1"
>12.1.3.1 The segspace package</A
></H4
><P
CLASS="para"
>As usual, the solution to such usability issues lies in creating a package to encapsulate those unwieldy program calls with an easier-to-use layer of programs. Here is the specification for my own package called <A
CLASS="indexterm"
NAME="ch12-idx-12640-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12640-1"
></A
>segspace:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>//* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch12-idx-12641-0"
></A
>segspace.sql */*
CREATE OR REPLACE PACKAGE segspace
   /*
   || Extends the DBMS_SPACE package by creating function
   || calls to return individual parameter values
   ||
   || Author:  John Beresniewicz, Savant Corp
   || Created: 07/29/97
   ||</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   || Compilation Requirements: 
   ||
   || Execution Requirements:
   ||
   || ANALYZE ANY system privilege
   ||
   */
AS

   /*
   || sets the specified segment as current context
   */
   PROCEDURE set_segment
      (name_IN IN VARCHAR2
      ,type_IN IN VARCHAR2
      ,schema_IN IN VARCHAR2
      ,partition_IN IN VARCHAR2 DEFAULT NULL);

   /* returns current segment name */
   FUNCTION current_name RETURN VARCHAR2;

   /* returns current segment type */
   FUNCTION current_type RETURN VARCHAR2;

   /* returns current segment schema */
   FUNCTION current_schema RETURN VARCHAR2;

   /* 
   || returns total_blocks from DBMS_SPACE.UNUSED_SPACE
   || for the segment specified
   */
   FUNCTION total_blocks
      (name_IN IN VARCHAR2 DEFAULT current_name
      ,type_IN IN VARCHAR2 DEFAULT current_type
      ,schema_IN IN VARCHAR2 DEFAULT current_schema)
   RETURN NUMBER;

   
   /* 
   || returns unused_blocks from DBMS_SPACE.UNUSED_SPACE
   || for the segment specified
   */
   FUNCTION unused_blocks
      (name_IN IN VARCHAR2 DEFAULT current_name
      ,type_IN IN VARCHAR2 DEFAULT current_type
      ,schema_IN IN VARCHAR2 DEFAULT current_schema)
   RETURN NUMBER;


   /* 
   || returns number of blocks on segment freelist using
   || DBMS_SPACE.FREE_BLOCKS
   */
   FUNCTION freelist_blocks
      (name_IN IN VARCHAR2 DEFAULT current_name
      ,type_IN IN VARCHAR2 DEFAULT current_type
      ,schema_IN IN VARCHAR2 DEFAULT current_schema
      ,freelist_group_IN IN NUMBER DEFAULT 0
      ,partition_IN IN VARCHAR2 DEFAULT NULL)
   RETURN NUMBER;

END segspace;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The segspace package has functions called total_blocks and unused_blocks. These functions both accept segment identification information as IN parameters and return the value of their corresponding OUT parameters from DBMS_SPACE.UNUSED_SPACE. So in SQL*Plus, you can use these functions as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; var tot_blks NUMBER
SQL&gt; execute :tot_blks := segspace.total_blocks('TENK','TABLE','LOAD1');

PL/SQL procedure successfully completed.

SQL&gt; print tot_blks

 TOT_BLKS
---------
      455</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Well, this sure is a lot easier than calling the UNUSED_SPACE procedure directly! Notice, however, that the IN parameters to these functions also all have default values, which means that they can be suppressed when making the function call (as long as the default is the desired value). The default values used are the segment identifiers (name, type, and schema) most recently specified. Thus we can find out the unused blocks for the LOAD1.TENK table by immediately following the preceding call with this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; var unused_blks number
SQL&gt; execute :unused_blks := segspace.unused_blocks;

PL/SQL procedure successfully completed.

SQL&gt; print unused_blks

UNUSED_BLKS
-----------
         10</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By retaining the current segment context set by the previous call and using default values, a complex procedure call (UNUSED_SPACE) with ten parameters is transformed into a simple function call requiring only a target variable for its result. </P
><P
CLASS="para"
>Now, this is something I might be able (and want) to actually use.</P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch12-idx-12657-0"
></A
>set_segment procedure is used to set the current segment context, which amounts to establishing the default IN parameters for all the functions.</P
><P
CLASS="para"
>Astute readers will suspect that private package globals play a part in this trickery, and they are correct. They may also raise questions about the performance implications of splitting the OUT parameters of UNUSED_SPACE into individual function calls, as this is a relatively "expensive" procedure call to make and should not be redundantly or needlessly invoked. Well, segspace is designed to be both useful and efficient. </P
><P
CLASS="para"
>Here is the package body for segspace (an explanation follows the code):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>//* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch12-idx-12658-0"
></A
>segspace.sql */*
CREATE OR REPLACE PACKAGE BODY <A
CLASS="indexterm"
NAME="ch12-idx-12659-0"
></A
>segspace
AS

   /* record type to hold data on segment */
   TYPE segdata_rectype IS RECORD
      (name    VARCHAR2(30)
      ,schema  VARCHAR2(30) DEFAULT USER
      ,type    VARCHAR2(30) DEFAULT 'TABLE'
      ,partition  VARCHAR2(30) DEFAULT NULL
      ,total_blocks  NUMBER
      ,total_bytes   NUMBER
      ,unused_blocks NUMBER
      ,unused_bytes  NUMBER
      ,last_extent_file  NUMBER
      ,last_extent_block NUMBER
      ,last_block    NUMBER
      ,last_segload  DATE := SYSDATE - 1
      );

   /* global rec for current segment data */
   segdata_rec  segdata_rectype;

   /* reload timeout in seconds */
   segload_timeout   INTEGER := 60;

   /* flag for new segment */
   newseg_TF   BOOLEAN := TRUE;

   /* 
   || returns the segment name from segdata_rec
   */
   FUNCTION <A
CLASS="indexterm"
NAME="ch12-idx-12660-0"
></A
>current_name RETURN VARCHAR2
   IS
   BEGIN
      RETURN segdata_rec.name;
   END current_name;

   /* 
   || returns the segment type from segdata_rec
   */
   FUNCTION c<A
CLASS="indexterm"
NAME="ch12-idx-12661-0"
></A
>urrent_type RETURN VARCHAR2
   IS
   BEGIN
      RETURN segdata_rec.type;
   END current_type;

   /* 
   || returns the segment schema from segdata_rec
   */
   FUNCTION <A
CLASS="indexterm"
NAME="ch12-idx-12662-0"
></A
>current_schema RETURN VARCHAR2
   IS
   BEGIN
      RETURN segdata_rec.schema;
   END current_schema;

   /*
   || sets specific segment as context
   */
   PROCEDURE <A
CLASS="indexterm"
NAME="ch12-idx-12663-0"
></A
>set_segment
      (name_IN IN VARCHAR2
      ,type_IN IN VARCHAR2
      ,schema_IN IN VARCHAR2
      ,partition_IN IN VARCHAR2 DEFAULT NULL)
   IS
   BEGIN
      /* check if new segment and set flag */
      IF ( segdata_rec.schema != schema_IN
        OR segdata_rec.name   != name_IN
        OR segdata_rec.type   != type_IN
        OR segdata_rec.partition != partition_IN
          )
      THEN
         newseg_TF := TRUE;
      ELSE
         newseg_TF := FALSE;
      END IF;

      /* set segment globals */
      segdata_rec.schema := schema_IN;
      segdata_rec.name   := name_IN;
      segdata_rec.type   := type_IN;
      segdata_rec.partition := partition_IN;
   END set_segment;


   FUNCTION <A
CLASS="indexterm"
NAME="ch12-idx-12664-0"
></A
>reload_TF RETURN BOOLEAN
   IS
   /*
   || returns TRUE if timed out or new segment since last load
   */
   BEGIN
      RETURN ( SYSDATE &gt; segdata_rec.last_segload +
                          segload_timeout/(24*60*60) 
             )
           OR newseg_TF;
   END reload_TF;


   PROCEDURE <A
CLASS="indexterm"
NAME="ch12-idx-12665-0"
></A
>load_unused
   IS
   /*
   || loads segment unused space data for current segment using 
   || DBMS_SPACE.UNUSED_SPACE if the segment is new or timeout limit
   || reached since last load
   */
   BEGIN
      IF reload_TF
      THEN
         DBMS_SPACE.UNUSED_SPACE
            (segment_owner =&gt; segdata_rec.schema
            ,segment_name  =&gt; segdata_rec.name
            ,segment_type  =&gt; segdata_rec.type
            ,total_blocks  =&gt; segdata_rec.total_blocks
            ,total_bytes   =&gt; segdata_rec.total_bytes
            ,unused_blocks =&gt; segdata_rec.unused_blocks
            ,unused_bytes  =&gt; segdata_rec.unused_bytes
            ,last_used_extent_file_id =&gt; segdata_rec.last_extent_file
            ,last_used_extent_block_id =&gt; segdata_rec.last_extent_block
            ,last_used_block  =&gt; segdata_rec.last_block
         /* -------------------------------------------- */
         /* NOTE: uncomment following line for Oracle 8  */
         /* -------------------------------------------- */
         /* ,partition_name  =&gt; segdata_rec.partition */
            );

         segdata_rec.last_segload := SYSDATE;
      END IF;
   END load_unused;


   FUNCTION<A
CLASS="indexterm"
NAME="ch12-idx-12666-0"
></A
> total_blocks
      (name_IN IN VARCHAR2
      ,type_IN IN VARCHAR2
      ,schema_IN IN VARCHAR2)
   RETURN NUMBER
   IS
   /* 
   || sets current segment and calls load_unused
   */
   BEGIN
      set_segment(name_IN, type_IN, schema_IN);
      load_unused;
      RETURN segdata_rec.total_blocks;
   END total_blocks;


   FUNCTION <A
CLASS="indexterm"
NAME="ch12-idx-12667-0"
></A
>unused_blocks
      (name_IN IN VARCHAR2
      ,type_IN IN VARCHAR2
      ,schema_IN IN VARCHAR2)
   RETURN NUMBER
   IS
   /* 
   || sets current segment and calls load_unused
   */
   BEGIN
      set_segment(name_IN, type_IN, schema_IN);
      load_unused;
      RETURN segdata_rec.unused_blocks;
   END unused_blocks;


   /* 
   || returns number of blocks on segment freelist using
   || DBMS_SPACE.FREE_BLOCKS
   */
   FUNCTION <A
CLASS="indexterm"
NAME="ch12-idx-12668-0"
></A
>freelist_blocks
      (name_IN IN VARCHAR2 DEFAULT current_name
      ,type_IN IN VARCHAR2 DEFAULT current_type
      ,schema_IN IN VARCHAR2 DEFAULT current_schema
      ,freelist_group_IN IN NUMBER DEFAULT 0
      ,partition_IN IN VARCHAR2 DEFAULT NULL)
   RETURN NUMBER
   IS
      /* variable to hold output from call to FREE_BLOCKS */
      temp_freelist_blocks NUMBER;

      /*
      || loads segment freelist size using DBMS_SPACE.FREE_BLOCKS
      || scan limit NULL means no limit
      */
      BEGIN
         DBMS_SPACE.FREE_BLOCKS
            (segment_owner =&gt; schema_IN
            ,segment_name  =&gt; name_IN
            ,segment_type  =&gt; type_IN
            ,freelist_group_id =&gt; freelist_group_IN
            ,free_blks =&gt; temp_freelist_blocks
            ,scan_limit =&gt; NULL
         /* -------------------------------------------- */
         /* NOTE: uncomment following line for Oracle 8  */
         /* -------------------------------------------- */
         /* ,partition_name  =&gt; partition_IN          */
            );
      
      RETURN temp_freelist_blocks;
   END freelist_blocks;

END segspace;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The segspace package body declares a record type called segdata_rectype and a private global of that type called segdata_rec. This record is designed to hold a copy of all parameters (both IN and OUT) used by the UNUSED_SPACE procedure. The name, schema, type, and partition fields in segdata_rec correspond to the IN parameters of UNUSED_SPACE. These are set using the set_segment procedure. Think of this as the current segment context&nbsp;-- the segment currently being analyzed. The functions current_name, current_schema, and current_type simply return the corresponding elements of the current segment context. </P
><P
CLASS="para"
>The l<A
CLASS="indexterm"
NAME="ch12-idx-12669-0"
></A
>oad_unused procedure is the one that actually calls UNUSED_SPACE. It takes as IN parameters the appropriate field values from segdata_rec, and assigns its OUT values to the corresponding fields in segdata_rec. Now the individual OUT parameters from UNUSED_SPACE can be exposed through individual function calls that return fields from segdata_rec. </P
><P
CLASS="para"
>So the basic logic is quite simple:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The set_segment procedure establishes a segment context in segdata_rec.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The load_unused procedure loads UNUSED_SPACE information for the current segment into segdata_rec.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Individual field values from segdata_rec are returned through functions such as total_blocks and unused_block.</P
></LI
></OL
><P
CLASS="para"
>Now, a three-step process to retrieve the data items individually does not really represent an increase in usability, so what really happens is that the functions total_blocks and <A
CLASS="indexterm"
NAME="ch12-idx-12675-0"
></A
>unused_blocks each do all three steps.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   FUNCTION unused_blocks
      (name_IN IN VARCHAR2
      ,type_IN IN VARCHAR2
      ,schema_IN IN VARCHAR2)
   RETURN NUMBER
   IS
   /* 
   || sets current segment and calls load_unused
   */
   BEGIN
      set_segment(name_IN, type_IN, schema_IN);
      load_unused;
      RETURN segdata_rec.unused_blocks;
   END unused_blocks;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Remember that calling DBMS_SPACE.UNUSED_SPACE is relatively expensive, and we want to avoid calling it more often than necessary. It would be nice to be able to do the following without calling UNUSED_SPACE twice:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   pct_free := 100*
               (segspace.unused_blocks('TABLENAME','TABLE','SCHEMA') /
                segspace.total_blocks('TABLENAME','TABLE','SCHEMA') 
                );
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch12-idx-12676-0"
></A
>load_unused procedure avoids calling UNUSED_SPACE too often by checking a function called <A
CLASS="indexterm"
NAME="ch12-idx-12677-0"
></A
>reload_TF, which returns a BOOLEAN indicating whether to reload segment data. The reload_TF function will return TRUE (reload) if either of the following is TRUE:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>It has been longer than segload_timeout seconds since the last call to DBMS_SPACE.LOAD_UNUSED.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The current segment context is different than the context for the last call to DBMS_SPACE.LOAD_UNUSED.</P
></LI
></UL
><P
CLASS="para"
>Thus the previous PL/SQL block will call UNUSED_SPACE at most once (and perhaps not at all, if it was recently called for the same segment). The private global newseg_TF is a BOOLEAN flag indicating a new context. This is maintained by the <A
CLASS="indexterm"
NAME="ch12-idx-12678-0"
></A
>set_segment procedure: whenever a context is established, the flag is set to TRUE, if it is a new context.</P
><P
CLASS="para"
>Additional usability in the <A
CLASS="indexterm"
NAME="ch12-idx-12679-0"
></A
>total_blocks and<A
CLASS="indexterm"
NAME="ch12-idx-12680-0"
></A
> unused_blocks functions is achieved by using default values for the IN parameters and careful ordering of the parameters. The default values for name_IN, type_IN, and schema_IN are assigned by the functions current_name, current_type, and current_schema. The parameters are ordered such that the most likely to change (name) is first, followed by type, and then schema. This is based on the reasonable assumption that when doing space analysis, the user will probably do all tables by schema or all indexes by schema. Additionally, the initial default prior to setting a context at all is the current user schema and segment type TABLE. </P
><P
CLASS="question"
><B
>Q: </B
><EM
CLASS="emphasis"
>Q: Why did I use functions for the default values instead of direct reference to segdata_rec?</EM
></P
><P
CLASS="answer"
><B
>A: </B
><EM
CLASS="emphasis"
>A:</EM
> In order to directly reference the segdata_rec components for parameter defaults in the package specification, I would have also had to declare segdata_rec in the specification. This would expose segdata_rec such that it could be inadvertently modified by other programs. By using functions for the default values, segdata_rec can be declared privately (and thus protected) in the package body.</P
><P
CLASS="answer"
><B
>A: </B
>The function freelist_blocks simply calls DBMS_SPACE.FREE_BLOCKS and returns its single OUT parameter free_blks. Because FREE_BLOCKS has only a single OUT parameter, it was not really necessary to implement the optimizations discussed previously to avoid redundant calls. The function does improve usability by supplying defaults for the IN parameters to FREE_BLOCKS, reducing the calling profile where the defaults are correct. Be careful, though, because freelist_blocks does not do a set_segment to establish a context. If it is used alone (i.e., not in conjunction with total_blocks or unused_blocks), it is best to specify a full segment context in the call.</P
><P
CLASS="question"
><B
>Q: </B
><EM
CLASS="emphasis"
>Q: Why did I choose to not have freelist_blocks call set_segment to establish a segment context?</EM
></P
><P
CLASS="answer"
><B
>A: </B
><EM
CLASS="emphasis"
>A:</EM
> The unused_blocks function relies on segdata_rec to provide information about the current segment context loaded by the load_unused procedure. If the freelist_blocks function were to call set_segment to establish a context, it would also have to call load_unused to keep segdata_rec in synch with the context. This would introduce significant and unnecessary overhead, when only freelist information is desired.</P
><P
CLASS="para"
>Here is an example of using the segspace package in a SQL*Plus script to report on unused space in segments for a specific tablespace:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch12-idx-13783-0"
></A
>spcex2.sql */*
undefine tablespace_name
set serveroutput on size 100000
set verify off

DECLARE
   total_blocks NUMBER :=0;
   unused_blocks NUMBER :=0;
BEGIN
   DBMS_OUTPUT.PUT_LINE('TABLESPACE: '||UPPER('&amp;&amp;tablespace_name'));
   FOR seg_rec IN 
      (SELECT segment_name, segment_type, owner
         FROM dba_segments
        WHERE tablespace_name = UPPER('&amp;&amp;tablespace_name') )
   LOOP
      total_blocks := total_blocks +
                        segspace.total_blocks
                           (seg_rec.segment_name
                           ,seg_rec.segment_type
                           ,seg_rec.owner);

      unused_blocks := unused_blocks + segspace.unused_blocks;
   END LOOP;
   DBMS_OUTPUT.PUT_LINE('Total Blocks: '||TO_CHAR(total_blocks));
   DBMS_OUTPUT.PUT_LINE('Unused Blocks: '||TO_CHAR(unused_blocks));
   DBMS_OUTPUT.PUT_LINE('Pct Unused: '||
            TO_CHAR(ROUND(unused_blocks/total_blocks*100)) );
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is sample output from executing the script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Enter value for tablespace_name: LOAD_DATA
TABLESPACE: LOAD_DATA
Total Blocks: 9195
Unused Blocks: 1300
Pct Unused: 14

PL/SQL procedure successfully completed.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I like using segspace to probe space utilization within segments. With segspace, I can obtain useful reports like the previous one with a few quick lines. Direct use of DBMS_SPACE would require much more <A
CLASS="indexterm"
NAME="ch12-idx-12670-0"
></A
>time <A
CLASS="indexterm"
NAME="ch12-idx-12638-0"
></A
>and <A
CLASS="indexterm"
NAME="ch12-idx-12605-0"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12605-1"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12605-2"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12605-3"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12605-4"
></A
><A
CLASS="indexterm"
NAME="ch12-idx-12605-5"
></A
>effort.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm#ch11-SECT-2.2.1"
TITLE="11.2 DBMS_System: Setting Events for Debugging"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 11.2 DBMS_System: Setting Events for Debugging"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch12_02.htm#ch12-SECT-2.1"
TITLE="12.2 DBMS_SHARED_POOL: Pinning Objects"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 12.2 DBMS_SHARED_POOL: Pinning Objects"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>11.2 DBMS_System: Setting Events for Debugging</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>12.2 DBMS_SHARED_POOL: Pinning Objects</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
