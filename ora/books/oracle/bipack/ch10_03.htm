<HTML
><HEAD
><TITLE
>[Chapter 10] 10.3 DBMS_DDL: Compiling and Analyzing Objects</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:57:30Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch10_01.htm"
TITLE="10. Miscellaneous Packages"><LINK
REL="prev"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
TITLE="10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"><LINK
REL="next"
HREF="ch10_04.htm#ch10-SECT-4.2.1"
TITLE="10.4 DBMS_RANDOM: Generating Random Numbers (Oracle8 Only)"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
TITLE="10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch10_01.htm"
TITLE="10. Miscellaneous Packages"
>Chapter 10<BR>Miscellaneous Packages</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_04.htm#ch10-SECT-4.2.1"
TITLE="10.4 DBMS_RANDOM: Generating Random Numbers (Oracle8 Only)"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.4 DBMS_RANDOM: Generating Random Numbers (Oracle8 Only)"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch10-30992"
>10.3 DBMS_DDL: Compiling and Analyzing Objects</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13678-0"
></A
>The DBMS_DDL package provides access from within PL/SQL to two DDL (Data Definition Language) statements. It also offers special administrative services that are not available through DDL syntax (Oracle8 only). </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-3.1"
>10.3.1 Getting Started with DBMS_DDL</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-15342-0"
></A
>This DBMS_DDL package is created when the Oracle database is installed. The <I
CLASS="filename"
>dbmsdesc.sql</I
><A
CLASS="indexterm"
NAME="ch10-idx-15344-0"
></A
> script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1</A
>) contains the source code for this package's specification. This script is called by <EM
CLASS="emphasis"
>catproc.sql</EM
>, which is normally run immediately after database creation. The script creates the public synonym DBMS.DDL for the package and grants EXECUTE privilege on the package to public. All Oracle users can reference and make use of this package.</P
><P
CLASS="para"
>DBMS_DDL programs "run as user," which means that they execute with the <A
CLASS="indexterm"
NAME="ch10-idx-13682-0"
></A
>privileges of the user who calls that program.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> All programs in DBMS_DDL first <A
CLASS="indexterm"
NAME="ch10-idx-13683-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13683-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13683-2"
></A
>commit the current transaction, then perform the specified operation. When the operation is completed, another commit is performed.</P
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-3.1.1"
>10.3.1.1 DBMS_DDL programs</A
></H4
><P
CLASS="para"
>Table 10-3 <A
CLASS="indexterm"
NAME="ch10-idx-13684-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13684-1"
></A
>shows the programs defined in DBMS_DDL.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch10-14240"
>Table 10.3: DBMS_DDL Programs</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER_COMPILE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Compiles the specified PL/SQL object.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13686-0"
></A
>ANALYZE_OBJECT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Computes statistics for the specified database object.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13687-0"
></A
>REFERENCEABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Makes the specified table referenceable for object identifiers (OIDs) in existing data structures. Available in Oracle8 only.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13688-0"
></A
>ALTER_TABLE_NOT_REFERENCEABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Undoes the action of the previous procedure, ALTER_TABLE_REFERENCEABLE. Available in Oracle8 only.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>DBMS_DDL does not define any <A
CLASS="indexterm"
NAME="ch10-idx-15176-0"
></A
>exceptions or nonprogram elements.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-3.2"
>10.3.2 Compiling PL/SQL Objects</A
></H3
><P
CLASS="para"
>You can recompile PL/SQL objects that are already stored in the database by calling the <A
CLASS="indexterm"
NAME="ch10-idx-13689-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13689-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13689-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13689-3"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13689-4"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13689-5"
></A
>ALTER_COMPILE procedure. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-3.2.1"
>10.3.2.1 The DBMS_DDL.ALTER_COMPILE procedure</A
></H4
><P
CLASS="para"
>Here's the header for this procedure: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_DDL.ALTER_COMPILE
   (type IN VARCHAR2
   ,schema IN VARCHAR2
   ,name IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are the possible values you can provide for the type parameter (enclosed in single quotes when you pass them to the procedure) and the actions that result: </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Type</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Action</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PROCEDURE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Recompiles the specified procedure</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>FUNCTION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Recompiles the specified function</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PACKAGE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Recompiles the specified package specification and body</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PACKAGE BODY</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Recompiles the specified package body</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PACKAGE SPECIFICATION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Recompiles the specified package specification</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The schema and name arguments are case-sensitive. In almost every instance, the names of your PL/SQL objects are stored in uppercase (you must enclose those names in double quotes when creating the objects if you want mixed case). You will therefore need to specify the names in uppercase when you call ALTER_COMPILE. </P
><P
CLASS="para"
>Note the following about using this package:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If you pass NULL for the schema, then the current schema (the same value returned by a call to the built-in function USER) will be used.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you try to recompile DBMS_DDL, STANDARD, or DBMS_STANDARD (assuming that you have the privileges to do so), this procedure will return without taking any action.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When you request recompilation of a program, Oracle will first recompile any objects upon which that program depends, and which are marked invalid.</P
></LI
></UL
><P
CLASS="para"
>In order to compile a program, you must own that program (in other words, the schema you specify is the owner of the program for which you request compilation) or your schema must have been granted the ALTER ANY PROCEDURE privilege to compile another schema's programs.</P
><P
CLASS="para"
>The following command from a DBA account in SQL*Plus enables the SCOTT account to compile the programs of other schemas:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; GRANT ALTER ANY PROCEDURE TO SCOTT;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are a few examples of usage, assuming that SCOTT has been granted the ALTER ANY PROCEDURE privilege:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Recompile the procedure in the SCOTT schema that shows employees.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>    SQL&gt; exec DBMS_DDL.ALTER_COMPILE ('PROCEDURE', USER, 'SHOWEMPS');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that I pass in all arguments in uppercase to ensure a match.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Recompile the body of the empmaint package in the SALLY schema.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>    SQL&gt; exec DBMS_DDL.ALTER_COMPILE ('PACKAGE BODY', 'SALLY, 'EMPMAINT');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here too, I pass in all arguments in uppercase to ensure a match.</P
></LI
></OL
><OL
CLASS="orderedlist"
START="3"
><LI
CLASS="listitem"
><P
CLASS="para"
>Suppose that I had created a procedure as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>    CREATE OR REPLACE PROCEDURE &quot;%$^abc&quot; IS
    BEGIN
     ...
    END;
    /</PRE
></BLOCKQUOTE
><P
CLASS="para"
>(Try it! You will discover that this syntax will be acceptable to the compiler! It turns out that if you enclose your identifier&nbsp;-- be it a table name, column name, program name or variable name&nbsp;-- in double quotes, <EM
CLASS="emphasis"
>all</EM
> of the normal rules are suspended.)</P
><P
CLASS="para"
>Then I can recompile this program with the following command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>    SQL&gt; exec DBMS_DDL.ALTER_COMPILE ('PROCEDURE', USER, '%$^abc');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Strange, but true!</P
></LI
></OL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-22955"
>10.3.2.1.1 Exceptions</A
></H4
><P
CLASS="para"
>The ALTER_COMPILE procedure may raise any of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-20000</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Insufficient privileges or object does not exist. You must either own the specified object or be granted the CREATE ANY PROCEDURE privilege.</P
></DD
><DT
CLASS="term"
>ORA-20001</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Remote object, cannot compile. You can only recompile objects on the local database instance.</P
></DD
><DT
CLASS="term"
>ORA-20002</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Bad value for object type. You need to provide one of the values listed in the previous section.</P
></DD
></DL
><P
CLASS="para"
>Notice that these exceptions are not defined in the specification of the package. Instead, ALTER_COMPILE simply calls RAISE_APPLICATION_ERROR with one of the above error numbers. These error numbers may therefore conflict with your own -20NNN error number usages. If you embed calls to ALTER_COMPILE inside your application or utility, watch out for the confusion such conflicts can cause.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-22972"
>10.3.2.1.2 Example</A
></H4
><P
CLASS="para"
>At first glance, you might say this of the ALTER_COMPILE procedure: "Why bother? The command is available in SQL*Plus. I'll just execute the ALTER PROCEDURE XXX COMPILE command when I need to recompile."</P
><P
CLASS="para"
>The big difference between that command and the ALTER_COMPILE procedure, of course, is that you can run the latter within a PL/SQL block or program. This allows you to apply the full power and flexibility of a procedural language to make the utility more useful. This technique is demonstrated by my recompile procedure, which follows. This program recompiles all stored PL/SQL objects that are identified by the parameters you provide to it.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch10-idx-13700-0"
></A
>recmpile.sp */*
CREATE OR REPLACE PROCEDURE<A
CLASS="indexterm"
NAME="ch10-idx-13701-0"
></A
> recompile 
   (status_in IN VARCHAR2 := 'INVALID',
    name_in IN VARCHAR2 := '%',
    type_in IN VARCHAR2 := '%',
    schema_in IN VARCHAR2 := USER)
IS
   v_objtype VARCHAR2(100);

   CURSOR obj_cur IS   
      SELECT owner, object_name, object_type
        FROM ALL_OBJECTS
       WHERE status LIKE UPPER (status_in)
         AND object_name LIKE UPPER (name_in)
         AND object_type LIKE UPPER (type_in)
         AND owner LIKE UPPER (schema_in)
       ORDER BY 
         DECODE (object_type, 
            'PACKAGE', 1, 
            'FUNCTION', 2, 
            'PROCEDURE', 3,
            'PACKAGE BODY', 4);
BEGIN
   FOR rec IN obj_cur
   LOOP
      IF rec.object_type = 'PACKAGE'
      THEN
         v_objtype := 'PACKAGE SPECIFICATION';
      ELSE
         v_objtype := rec.object_type;
      END IF;  

      DBMS_DDL.ALTER_COMPILE (v_objtype, rec.owner, rec.object_name); 

      DBMS_OUTPUT.PUT_LINE 
         ('Compiled ' || v_objtype || ' of ' || 
          rec.owner || '.' || rec.object_name);  
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are a few interesting aspects to this procedure:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The default values are set up so that if you call recompile without any arguments, it will recompile all objects marked INVALID in your own schema. That seemed to be the most common usage for this utility, so why not design the interface to make that the easiest usage as well?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I translate the PACKAGE type to PACKAGE SPECIFICATION. I also order the objects retrieved so that they are compiled in the following order: package, function, procedure, and finally package body. I do this so that package specifications are compiled first, putting in place as many of the <EM
CLASS="emphasis"
>interfaces</EM
> as possible, before moving on to the implementations of standalone programs and then package bodies.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>It was necessary to declare a local variable for the object type because the definition of the OBJECT_TYPE column in ALL_OBJECTS is as VARCHAR2(12). When I combine PACKAGE and SPECIFICATION into a single "type" for purposes of the recompilation, the new type is too big for the record-based field.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I call DBMS_OUTPUT.PUT_LINE to provide a "trace" of the recompilations that have taken place.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can use wildcarded values in just about all of the arguments (name, type, owner) in order to perform just those recompilations that you need to perform.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I apply the UPPER function to all arguments. This will work (and make it easier to specify objects for recompilation) unless you use mixed case in your object names.</P
></LI
></UL
><P
CLASS="para"
>So to recompile all invalid programs in my schema, I would enter this command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec recompile</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To recompile only package bodies that are invalid, I <A
CLASS="indexterm"
NAME="ch10-idx-13702-0"
></A
>would <A
CLASS="indexterm"
NAME="ch10-idx-13691-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13691-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13691-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13691-3"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13691-4"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13691-5"
></A
>execute the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec recompile (type_in =&gt; 'PACKAGE BODY')</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-3.3"
>10.3.3 Computing Statistics for an Object</A
></H3
><P
CLASS="para"
>Use the ANALYZE_OBJECT procedure to compute statistics for the specified table, index, or cluster.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-3.3.1"
>10.3.3.1 The DBMS_DDL.<A
CLASS="indexterm"
NAME="ch10-idx-13708-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13708-1"
></A
>ANALYZE_OBJECT procedure</A
></H4
><P
CLASS="para"
>Here is the header for this procedure: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_DDL.ANALYZE_OBJECT
   (type IN VARCHAR2
   ,schema IN VARCHAR2
   ,name IN VARCHAR2
   ,method IN VARCHAR2
   ,estimate_rows IN NUMBER DEFAULT NULL
   ,estimate_percent IN NUMBER DEFAULT NULL
   ,method_opt IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The type of the database object. Legal values are TABLE, CLUSTER, or INDEX.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the schema containing the object for which you wish to compute statistics. If NULL, then the current schema is used.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the object for which you wish to compute statistics. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>method</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Action to be taken by the program. ESTIMATE, DELETE, and COMPUTE are accepted values and are explained following.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>estimate_rows</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The number of rows to be used to perform the statistics estimate. Cannot be less than 1. Used only if method is ESTIMATE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>estimate_percent</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The percentage of rows to be used to perform the statistics estimate. Ignored if estimate_rows is non-NULL. Must be between 1 and 99. Used only if method is ESTIMATE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>method_opt</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The method option, indicating which elements of the object will be analyzed.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The schema and name arguments are case-sensitive. In almost every instance, the names of your PL/SQL objects are stored in uppercase. (Enclose those names in double quotes when creating the objects if you want mixed case). You will therefore need to specify the names in uppercase when you call COMPUTE_STATISTICS.</P
><P
CLASS="para"
>This procedure offers a procedural equivalent to the SQL DDL statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ANALYZE TABLE|CLUSTER|INDEX [&lt;schema&gt;.]&lt;name&gt;
   [&lt;method&gt;] STATISTICS [SAMPLE &lt;n&gt; [ROWS|PERCENT]]</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the type you specify is not one of TABLE, CLUSTER, or INDEX, the procedure returns without taking action. </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> The type is <EM
CLASS="emphasis"
>not</EM
> case-sensitive; it is always converted to uppercase.</P
></BLOCKQUOTE
><P
CLASS="para"
>Here are the valid entries for the method argument, and the resulting activity. (Remember that when you pass one of these values, they must be enclosed in single quotes.)</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>COMPUTE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Exact statistics are computed based on the entire contents of the specified object. These values are then placed in the data dictionary.</P
></DD
><DT
CLASS="term"
>ESTIMATE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Statistics are estimated. With this option, either estimate_rows or estimate_percent must be non-NULL. These values are then placed in the data dictionary.</P
></DD
><DT
CLASS="term"
>DELETE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The statistics for this object are deleted from the data dictionary.</P
></DD
></DL
><P
CLASS="para"
>Here are the valid method_opt entries and the resulting impact:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>FOR TABLE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects statistics for the table.</P
></DD
><DT
CLASS="term"
>FOR ALL COLUMNS [SIZE N]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects column statistics for all columns and scalar attributes. The size is the maximum number of partitions in the histogram, with a default of 75 and a maximum of 254.</P
></DD
><DT
CLASS="term"
>FOR ALL INDEXED COLUMNS [SIZE N}</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects column statistics for all indexed columns in the table. The size is the maximum number of partitions in the histogram, with a default of 75 and a maximum of 254.</P
></DD
><DT
CLASS="term"
>FOR ALL INDEXES</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Collects statistics for all indexes associated with the table.</P
></DD
></DL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23105"
>10.3.3.1.1 Exceptions</A
></H4
><P
CLASS="para"
>DBMS_DDL.ANALYZE_OBJECT may raise any of the following exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-20000</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Insufficient privileges or object does not exist. You must either own the specified object or be granted the CREATE ANY PROCEDURE privilege.</P
></DD
><DT
CLASS="term"
>ORA-20001</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Bad value for object type. You must specify TABLE, INDEX, or CLUSTER.</P
></DD
></DL
><P
CLASS="para"
>Notice that these exceptions are not defined in the specification of the package. Instead, ANALYZE_OBJECT simply calls RAISE_APPLICATION_ERROR with one of the above error numbers. These error numbers may therefore conflict with your own -20NNN error number usages. If you embed calls to ANALYZE_OBJECT inside your application or utility, watch out for the confusion such conflicts can <A
CLASS="indexterm"
NAME="ch10-idx-13710-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13710-1"
></A
>cause.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-3.4"
>10.3.4 Setting Referenceability of Tables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13716-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13716-1"
></A
>When you create an object table, it automatically becomes referenceable, unless you use the OID AS clause when creating the table. The OID AS clause allows you to create an object table and to assign to the new table the same embedded object ID (EOID) as another object table of the same type. After you create a new table using the OID AS clause, you end up with two object tables with the same EOID; the new table is not referenceable, the original one is. All references that previously pointed to the objects in the original table still reference the same objects in the same original table. If you execute the ALTER_TABLE_REFERENCEABLE procedure of the DBMS_DDL package on the new table, it will make that table the referenceable table replacing the original one. Any references will then point to the objects in the new table instead of to the objects in the original table.</P
><P
CLASS="para"
>With DBMS_DDL, available only in Oracle8, you can both make a table referenceable and reverse that step.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-3.4.1"
>10.3.4.1 The DBMS_DDL. <A
CLASS="indexterm"
NAME="ch10-idx-13721-0"
></A
>(Oracle8 only)</A
></H4
><P
CLASS="para"
>To make a table referenceable, call the following procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_DDL.ALTER_TABLE_REFERENCEABLE
   (table_name IN VARCHAR2
   ,table_schema IN VARCHAR2 DEFAULT NULL
   ,affected_schema IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>table_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the table to be made referenceable. You cannot use a synonym. The argument is case-sensitive.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>table_schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The schema containing the table to be made referenceable. If NULL, then the current schema is used. The argument is case-sensitive.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>affected_schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The schema that is to be affected by this change. If NULL, then the PUBLIC schema is used. In other words, the change takes effect in all schemas. The argument is case-sensitive.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>This program alters the specified object table, table_schema.table_name, so it becomes the referenceable table for the specified schema, affected_schema. This program is the equivalent of the following SQL statement,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ALTER TABLE [&lt;table_schema&gt;.]&lt;table_name&gt;
   REFERENCEABLE FOR &lt;affected_schema&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>which is currently neither supported nor available as a DDL statement. You can obtain this effect only through a call to the ALTER_TABLE_REFERENCEABLE built-in package.</P
><P
CLASS="para"
>Notice that each argument to this program is case-sensitive. ALTER_TABLE_REFERENCEABLE will <EM
CLASS="emphasis"
>not</EM
> automatically convert to uppercase the table name you pass to it. You must make sure that the table and schema names you provide match exactly the case of the objects found inside the database. </P
><P
CLASS="para"
>You will be able to execute this procedure successfully only if you have the appropriate privileges. Here are some rules to keep in mind:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The user who executes this procedure must own the new table, and the affected schema must be the same as the user or PUBLIC; alternatively, the user must have ALTER ANY TABLE, SELECT ANY TABLE, and DROP ANY TABLE privileges. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the affected schema is PUBLIC (and the user does <EM
CLASS="emphasis"
>not</EM
> have ALTER ANY TABLE, SELECT ANY TABLE, and DROP ANY TABLE privileges), then the user must own the old mapping table (the table upon which the new table is based) for PUBLIC as well.</P
></LI
></UL
><P
CLASS="para"
>One tricky aspect to the way this built-in is defined: the default affected_schema is PUBLIC. Combine this fact with the previous rules, and you discover that the simplest form of calling the built-in (providing only the table name),</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXECUTE DBMS_DDL.ALTER_TABLE_REFERENCEABLE ('EMPOBJTAB');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>will quite often fail with this error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-20000: insufficient privileges, invalid schema name or 
           table does not exist</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You will say to yourself, "But I own the table!" And then you will realize, "Oh, if I don't specify the affected schema, then PUBLIC is used and I do <EM
CLASS="emphasis"
>not</EM
> have ALTER ANY TABLE or any of the other privileges needed." So all I can really do is this,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXECUTE DBMS_DDL.ALTER_TABLE_REFERENCEABLE ('EMPOBJTAB', USER, USER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and make sure that the command is applied only to my schema.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23182"
>10.3.4.1.1 Example</A
></H4
><P
CLASS="para"
>Generally, <A
CLASS="indexterm"
NAME="ch10-idx-13728-0"
></A
>you will use the ALTER_TABLE_REFERENCEABLE procedure when you want to replace an existing object table with a new table of the same structure. In this scenario, you will want to make sure that all EOIDS point to this new table. </P
><P
CLASS="para"
>Here are the steps you would take to use ALTER_TABLE_REFERENCEABLE to make this "switch." (These steps are collected together using an employee table as an example in <I
CLASS="filename"
>tabref.sql</I
><A
CLASS="indexterm"
NAME="ch10-idx-13725-0"
></A
> on the companion disk.)</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>First, you must have an object table already in place. Here is the code to create an employee object and then an object table for that object: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE empobj AS OBJECT (ename VARCHAR2(100), empno INTEGER);
/
CREATE TABLE emp OF empobj
/</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Now I will create a new object table based on the same object as the original table like this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE empNew OF empobj OID AS emp
/</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Next, I transfer the contents of the original emp table to the empNew table. In Oracle8, unique object identifiers are automatically assigned to objects when they are stored as "table objects." It turns out that this identifier is stored in a hidden 16-byte RAW field, SYS_NC_OID$. This ID or OID can be referenced from columns in other tables, much like a foreign key. I use this in my INSERT to make sure the new table has the same identifier as the old. I also must use aliases for my table names for this process to work correctly.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO empNew en (SYS_NC_OID$, en)
  SELECT SYS_NC_OID$, VALUE (eo) FROM emp eo
/</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Now I make the new table referenceable. Notice that the name of the table is passed in upper case and I explicitly pass USER as the schema to avoid the inadvertent usage of PUBLIC.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXECUTE DBMS_DDL.ALTER_TABLE_REFERENCEABLE ('EMPNEW', USER, USER);</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>For my final trick, I swap the names of the tables so that I end up with a new emp table.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>RENAME emp TO empOld;
RENAME empNew TO emp;</PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23208"
>10.3.4.1.2 Exceptions</A
></H4
><P
CLASS="para"
>The ALTER_TABLE_REFERENCEABLE procedure may raise the following exception:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-20000</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Insufficient privileges; invalid schema name, or table does not exist.</P
></DD
></DL
><P
CLASS="para"
>Notice that this exception is not defined in the specification of the package. Instead, this program simply calls RAISE_APPLICATION_ERROR with the previous error number. This error number may therefore conflict with your own -20NNN error number usages. If you embed calls to this procedure inside your application or utility, watch out for the confusion such a conflict <A
CLASS="indexterm"
NAME="ch10-idx-13730-0"
></A
>can <A
CLASS="indexterm"
NAME="ch10-idx-13723-0"
></A
>cause.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-3.4.2"
>10.3.4.2 The DBMS_DDL.<A
CLASS="indexterm"
NAME="ch10-idx-13736-0"
></A
>ALTER_TABLE_NOT_REFERENCEABLE procedure (Oracle8 only)</A
></H4
><P
CLASS="para"
>For the affected schema, this procedure simply reverts to the default table referenceable for PUBLIC; that is, it simply undoes the previous ALTER_TABLE_REFERCEABLE call for this specific schema. The header follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_DDL.ALTER_TABLE_NOT_REFERENCEABLE
   (table_name IN VARCHAR2
   ,table_schema IN VARCHAR2 DEFAULT NULL
   ,affected_schema IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>table_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the table to be made nonreferenceable. You cannot use a synonym. The argument is case-sensitive.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>table_schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The schema containing the table to be made nonreferenceable. If NULL, then the current schema is used. The argument is case-sensitive.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>affected_schema</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The schema that is to be affected by this change. If NULL, then the current schema is used. PUBLIC may not be specified. The argument is case-sensitive.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>This procedure is equivalent to the following SQL statement,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ALTER TABLE [&lt;table_schema&gt;.]&lt;table_name&gt;
   NOT REFERENCEABLE FOR &lt;affected_schema&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>which is currently neither supported nor available as a DDL statement.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23255"
>10.3.4.2.1 Exceptions</A
></H4
><P
CLASS="para"
>The ALTER_TABLE_NOT_REFERENCEABLE procedure may raise the following exception:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-20000</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Insufficient privileges; invalid schema name or table does not exist.</P
></DD
></DL
><P
CLASS="para"
>Notice that this exception is not defined in the specification of the package. Instead, this program simply calls RAISE_APPLICATION_ERROR with the preceding error number. This error number may therefore conflict with your own -20NNN error number usages. If you embed calls to this procedure inside your application or utility, watch out for the confusion such <A
CLASS="indexterm"
NAME="ch10-idx-13748-0"
></A
>conflicts <A
CLASS="indexterm"
NAME="ch10-idx-13718-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13718-1"
></A
>can <A
CLASS="indexterm"
NAME="ch10-idx-13679-0"
></A
>cause.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
TITLE="10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_04.htm#ch10-SECT-4.2.1"
TITLE="10.4 DBMS_RANDOM: Generating Random Numbers (Oracle8 Only)"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.4 DBMS_RANDOM: Generating Random Numbers (Oracle8 Only)"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10.4 DBMS_RANDOM: Generating Random Numbers (Oracle8 Only)</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
