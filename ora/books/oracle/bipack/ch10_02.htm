<HTML
><HEAD
><TITLE
>[Chapter 10] 10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:57:10Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch10_01.htm"
TITLE="10. Miscellaneous Packages"><LINK
REL="prev"
HREF="ch10_01.htm"
TITLE="10.1 DBMS_UTILITY: Performing Miscellaneous Operations"><LINK
REL="next"
HREF="ch10_03.htm#ch10-SECT-3.2"
TITLE="10.3 DBMS_DDL: Compiling and Analyzing Objects"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_01.htm"
TITLE="10.1 DBMS_UTILITY: Performing Miscellaneous Operations"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.1 DBMS_UTILITY: Performing Miscellaneous Operations"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch10_01.htm"
TITLE="10. Miscellaneous Packages"
>Chapter 10<BR>Miscellaneous Packages</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_03.htm#ch10-SECT-3.2"
TITLE="10.3 DBMS_DDL: Compiling and Analyzing Objects"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.3 DBMS_DDL: Compiling and Analyzing Objects"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch10-33685"
>10.2 DBMS_DESCRIBE: Describing PL/SQL Program Headers</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch10-idx-13576-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13576-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13576-2"
></A
>DBMS_DESCRIBE package contains a single procedure used to describe the arguments of a stored PL/SQL object.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-2.1"
>10.2.1 Getting Started with DBMS_DESCRIBE</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13580-0"
></A
>The DBMS_DESCRIBE package is created when the Oracle database is installed. The <I
CLASS="filename"
>dbmsdesc.sql</I
><A
CLASS="indexterm"
NAME="ch10-idx-13581-0"
></A
> script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1</A
>) contains the source code for this package's specification. This script is called by <EM
CLASS="emphasis"
>catproc.sql</EM
>, which is normally run immediately after database creation. The script creates the public synonym DMS_DESCRIBE for the package and grants EXECUTE <A
CLASS="indexterm"
NAME="ch10-idx-15177-0"
></A
>privilege on the package to public. All Oracle users can reference and make use of this package.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.1.1"
>10.2.1.1 DBMS_DESCRIBE program</A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
>Table 10.2</A
> <A
CLASS="indexterm"
NAME="ch10-idx-13582-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13582-1"
></A
>summarizes the single procedure available through DBMS_DESCRIBE.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch10-19245"
>Table 10.2: DBMS_DESCRIBE Program</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DESCRIBE_PROCEDURE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Describes the specified PL/SQL object by returning all of the information for the object in a set of scalar and PL/SQL table parameters.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.1.2"
>10.2.1.2 DBMS_DESCRIBE nonprogram elements</A
></H4
><P
CLASS="para"
>In addition to the DESCRIBE_PROCEDURE procedure, DBMS_DESCRIBE defines two PL/SQL table types you can use when calling or describing a PL/SQL object. These are described in the following table. </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name/Type</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_DESCRIBE.VARCHAR2_TABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Table TYPE of 30-character strings; used to declare PL/SQL tables to hold string information returned by DBMS_DESCRIBE.DESCRIBE_PROCEDURE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_DESCRIBE.NUMBER_TABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Table TYPE of numbers; used to declare PL/SQL tables to hold numeric information returned by DBMS_DESCRIBE.DESCRIBE_PROCEDURE.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The two table TYPES are defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE DBMS_DESCRIBE.VARCHAR2_TABLE IS 
   TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;

TYPE DBMS_DESCRIBE.NUMBER_TABLE 
   IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.1.3"
>10.2.1.3 The DBMS_DESCRIBE.<A
CLASS="indexterm"
NAME="ch10-idx-13583-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13583-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13583-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13583-3"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13583-4"
></A
>DESCRIBE_PROCEDURE procedure</A
></H4
><P
CLASS="para"
>The DESCRIBE_PROCEDURE procedure describes the specified PL/SQL object (currently only procedures and functions are supported). It returns information about the parameters of the program in a series of PL/SQL tables. The header for this procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_DESCRIBE.DESCRIBE_PROCEDURE
    (object_name IN VARCHAR2
    ,reserved1 IN VARCHAR2
    ,reserved2 IN VARCHAR2
    ,overload OUT NUMBER_TABLE
    ,position OUT NUMBER_TABLE
    ,level OUT NUMBER_TABLE
    ,argument_name OUT VARCHAR2_TABLE
    ,datatype OUT NUMBER_TABLE
    ,default_value OUT NUMBER_TABLE
    ,in_out OUT NUMBER_TABLE
    ,length OUT NUMBER_TABLE
    ,precision OUT NUMBER_TABLE
    ,scale OUT NUMBER_TABLE
    ,radix OUT NUMBER_TABLE
    ,spare OUT NUMBER_TABLE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Paremeters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>object_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the program being described. The form of the name is [[part1.]part2.]part3. The syntax for this name follows the rules for <A
CLASS="indexterm"
NAME="ch10-idx-13840-0"
></A
>identifiers in SQL. This name can be a synonym and may also contain delimited identifiers (double-quoted strings). This parameter is required and may not be NULL. The total length of the name is limited to 197 bytes.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>reserved1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Reserved for future use. Must be set to NULL or an empty string, as in <CODE
CLASS="literal"
>``</CODE
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>reserved2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Reserved for future use. Must be set to NULL or an empty string, as in <CODE
CLASS="literal"
>``</CODE
>.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>overload</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers containing the unique number assigned to the program "signature." If the program is overloaded, the value in this array will indicate the specific overloading to which the argument belongs.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>position</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers showing the position of the argument in the parameter list. The first argument is always in position 1. A value of 0 indicates that the "argument" is actually the RETURN value of the function.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>level</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers describing the level of the argument. This is relevant when describing a procedure with a composite datatype, such as a record or PL/SQL table. For specific level values, see "<A
CLASS="xref"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
>Section 10.2.2.2, "The <A
CLASS="indexterm"
NAME="ch10-idx-13622-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13622-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13622-2"
></A
>DESCRIBE level"</A
>" later in this chapter.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>argument_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of strings containing the names of the arguments. This entry is NULL if the argument is the RETURN value of a function.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>datatype</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers describing the datatypes of the arguments. For specific datatype values, see the next table.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>default_value</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers indicating whether the argument has a default value. If 1, then a default value is present; if 0, then no default value.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>in_out</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers indicating the parameter mode: </P
><P
CLASS="para"
>0 = IN mode</P
><P
CLASS="para"
>1 = OUT mode</P
><P
CLASS="para"
>2 = IN OUT mode</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>length</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers indicating the length of the argument. For string types, the length is the "N" in CHAR(N) or VARCHAR2(N). Currently, this value represents the number of bytes (not characters) on the server-side. (For a multibyte datatype, this may be different from the number of bytes on the client side.) </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>precision</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers containing the precisions of the arguments. Relevant only for numeric arguments.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>scale</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers containing the scales of the arguments. Relevant only for numeric arguments.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>radix</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An array of integers containing the radixes of the arguments. Relevant only for numeric arguments.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>spare</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Reserved for future usage (but you still have to declare a PL/SQl table to hold it!).</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The values for <A
CLASS="indexterm"
NAME="ch10-idx-13904-0"
></A
>parameter <A
CLASS="indexterm"
NAME="ch10-idx-13905-0"
></A
>datatypes are listed in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Datatype</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VARCHAR2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NVARCHAR2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NUMBER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>2</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>2</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>3</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PLS_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>3</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LONG</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>8</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>11</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DATE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>12</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>RAW</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>23</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LONGRAW</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>24</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CHAR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>96</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NCHAR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>96</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>MLSLABEL</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>106</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CLOB</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>112</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NCLOB</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>112</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BLOB</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>113</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BFILE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>114</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Object type (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>121</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Nested table type (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>122</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Variable array (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>123</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Record type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>250</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Index-by (PL/SQL) table type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>251</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BOOLEAN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>252</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.1.4"
>10.2.1.4 <A
CLASS="indexterm"
NAME="ch10-idx-15208-0"
></A
>Exceptions</A
></H4
><P
CLASS="para"
>DBMS_DESCRIBE.DESCRIBE_PROCEDURE may raise any of the exceptions listed in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Error Code</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ORA-20000</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A package was specified. DESCRIBE_PROCEDURE currently allows you to request only describes for top-level ("standalone") programs (procedure and functions) or programs within a package.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ORA-20001</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You requested a describe of a procedure or function that does not exist within the package.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ORA-20002</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You requested a describe of a procedure or function that is remote (either by including a database link or by passing a program name that is actually a synonym for a program defined using a database link). DESCRIBE_PROCEDURE is currently unable to describe remote objects.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ORA-20003</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You requested describe of an object that is marked invalid. You can  describe only valid objects. Recompile the object and then describe it.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ORA-20004</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>There was a syntax error in the specification of the object's name.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Notice that these exceptions are not defined in the specification of the package. Instead, DESCRIBE_PROCEDURE simply calls RAISE_APPLICATION_ERROR with the error numbers listed earlier. These error numbers may therefore conflict with your own -20NNN error number usages (this is a very bad design decision on Oracle's part). If you embed calls to DESCRIBE_PROCEDURE inside your application or utility, watch out for the confusion such conflicts can cause.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.1.5"
>10.2.1.5 Restrictions</A
></H4
><P
CLASS="para"
>There are several limitations on using DESCRIBE_PROCEDURE:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot describe remote objects (i.e., PL/SQL program elements that are defined in another database instance).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot get a describe or a listing of all elements defined in a package specification. You need to know the name of the procedure or function within the package in other to get a describe of it.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>DBMS_DESCRIBE.DESCRIBE_PROCEDURE will not show you the internal structure (attributes) of Oracle8 elements such as object types, variable arrays, and nested tables.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-2.2"
>10.2.2 Explaining DBMS_DESCRIBE Results</A
></H3
><P
CLASS="para"
>In <A
CLASS="indexterm"
NAME="ch10-idx-13598-0"
></A
>the following sections and in subsequent examples I will demonstrate different ways of using DBMS_DESCRIBE.DESCRIBE_PROCEDURE. I will be working with the following objects:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE account 
   (account_no number, 
    person_id number,
    balance number(7,2));

CREATE TABLE person 
   (person_id number(4), 
    person_nm varchar2(10));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I will also describe objects in a package called desctest, which is defined in the <I
CLASS="filename"
>psdesc.tst</I
><A
CLASS="indexterm"
NAME="ch10-idx-15193-0"
></A
> file on the companion disk. The output I display from the DESCRIBE_PROCEDURE is generated by the psdesc (PL/SQL DESCribe) package, which is explained in the "<A
CLASS="xref"
HREF="ch10_02.htm#ch10-SECT-2.3.2"
>Section 10.2.3, "DBMS_DESCRIBE Example"</A
>" section and is defined in the <I
CLASS="filename"
>psdesc.spp</I
> <A
CLASS="indexterm"
NAME="ch10-idx-13593-0"
></A
>file.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.2.1"
>10.2.2.1 Specifying a program name</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13621-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13621-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13621-2"
></A
>The valid syntax for a PL/SQL object to be described follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>[[part1.]part2.]part3</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are various valid object specifications for DBMS_DESCRIBE.DESCRIBE_PROCEDURE:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Object Specification</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>showemps</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Standalone procedure or synonym to same</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>emppkg.employee_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Function inside a package</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>scott.delete_dept</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Standalone procedure in the SCOTT schema</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>scott.emppkg.update_salary</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Procedure inside a package in the SCOTT schema</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>You can also describe procedures and functions in the STANDARD and DBMS_STANDARD packages (the default packages of PL/SQL, containing the core elements of the language). To do this, you must prefix the name of the built-in with its package name, as in:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>'STANDARD.TO_CHAR'</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-22318"
>10.2.2.2 The <A
CLASS="indexterm"
NAME="ch10-idx-13622-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13622-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13622-2"
></A
>DESCRIBE level</A
></H4
><P
CLASS="para"
>The level array discloses the hierarchy of the elements in a program's arguments. The level applies only to the following subset of composite datatypes: records and PL/SQL tables. The default level of 0 means that it is the top level. For scalars, that is the only level. For composites, 0 indicates that you are pointing to the actual composite argument. Each successive value of level (positive integers: 1, 2, etc.) indicates that the argument attribute or field is a child of the previous level.</P
><P
CLASS="para"
>The following example demonstrates how DESCRIBE_PROCEDURE generates its levels. Suppose that I have the following elements defined inside a package:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch10-idx-15196-0"
></A
> psdesc.tst */*
CREATE OR REPLACE PACKAGE desctest
IS
   TYPE number_table IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;

   TYPE myrec1 IS RECORD (empno NUMBER, indsal NUMBER);
   TYPE myrec2 IS RECORD 
      (ename VARCHAR2(20), hiredate DATE, empno_info myrec1);
   TYPE myrec3 IS RECORD 
      (deptno NUMBER, totsal NUMBER, all_emp_info myrec2);

   TYPE myrec_table IS TABLE OF myrec1 INDEX BY BINARY_INTEGER;

   PROCEDURE composites (account_in NUMBER,
     person person%ROWTYPE,
     multirec myrec3, 
     num_table number_table,
     recs_table myrec_table);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I have double-nested a record (myrec1 inside myrec2 inside myrec3), a table based on a record (myrec_table), and a "simple" table-based record (person%ROWTYPE). Here are the results from <A
CLASS="indexterm"
NAME="ch10-idx-13624-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13624-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13624-2"
></A
>DBMS_DESCRIBE.DESCRIBE_PROCEDURE:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt;  exec psdesc.showargs ('desctest.composites')
OvLd Pos Lev Type            Name                   
---- --- --- --------------- -----------------------

   0   1   0 NUMBER          ACCOUNT_IN             
   0   2   0 RECORD          PERSON                 
   0   1   1 NUMBER          PERSON_ID            
   0   2   1 VARCHAR2        PERSON_NM            
   0   3   0 RECORD          MULTIREC               
   0   1   1 NUMBER          DEPTNO               
   0   2   1 NUMBER          TOTSAL               
   0   3   1 RECORD          ALL_EMP_INFO         
   0   1   2 VARCHAR2        ENAME              
   0   2   2 DATE            HIREDATE           
   0   3   2 RECORD          EMPNO_INFO         
   0   1   3 NUMBER          EMPNO            
   0   2   3 NUMBER          INDSAL           
   0   4   0 INDEX-BY TABLE  NUM_TABLE              
   0   1   1 NUMBER          RETURN Value         
   0   5   0 INDEX-BY TABLE  RECS_TABLE             
   0   1   1 RECORD          RETURN Value         
   0   1   2 NUMBER          EMPNO              
   0   2   2 NUMBER          INDSAL</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.2.3"
>10.2.2.3 How overloading is handled</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13626-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13626-1"
></A
>When you overload, you define more than one program with the same name. You will usually do this in packages. DESCRIBE_PROCEDURE creates a set of rows in the arrays for each overloading of a program. It then generates a unique, sequential number in the overload array to indicate that (a) the program is overloaded (a value of 0 indicates no overloading), and (b) to which overloading the arguments belong. </P
><P
CLASS="para"
>Suppose that the desctest package has two overloaded versions of the upd function (the only difference is in the datatype of the last parameter, NUMBER vs. DATE).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PACKAGE desctest
IS
   FUNCTION upd (account_in NUMBER, 
     person person%ROWTYPE, 
     amounts number_table,
     trans_date DATE) RETURN account.balance%TYPE;
     
   FUNCTION upd (account_in NUMBER, 
     person person%ROWTYPE, 
     amounts number_table,
     trans_no NUMBER) RETURN account.balance%TYPE;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Then the output from DBMS_DESCRIBE.DESCRIBE_PROCEDURE would be <A
CLASS="indexterm"
NAME="ch10-idx-13628-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13628-1"
></A
>as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec psdesc.showargs ('desctest.upd')
OvLd Pos Lev Type            Name               
---- --- --- --------------- -------------------

   1   0   0 NUMBER          RETURN Value       
   1   1   0 NUMBER          ACCOUNT_IN         
   1   2   0 RECORD          PERSON             
   1   1   1 NUMBER          PERSON_ID        
   1   2   1 VARCHAR2        PERSON_NM        
   1   3   0 INDEX-BY TABLE  AMOUNTS            
   1   1   1 NUMBER          RETURN Value     
   1   4   0 DATE            TRANS_DATE         
---- --- --- --------------- -------------------
   2   0   0 NUMBER          RETURN Value       
   2   1   0 NUMBER          ACCOUNT_IN         
   2   2   0 RECORD          PERSON             
   2   1   1 NUMBER          PERSON_ID        
   2   2   1 VARCHAR2        PERSON_NM        
   2   3   0 INDEX-BY TABLE  AMOUNTS            
   2   1   1 NUMBER          RETURN Value     
   2   4   0 NUMBER          TRANS_NO</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-15339"
>10.2.3 DBMS_DESCRIBE Example</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13634-0"
></A
>The most important example I can think of for DBMS_DESCRIBE.DESCRIBE_PROCEDURE is the construction of a utility that makes it easier to <EM
CLASS="emphasis"
>use</EM
> this procedure. Without such a utility, you must declare a set of PL/SQL tables every time you want to call the DESCRIBE_PROCEDURE. You must then also interpret the results. By encapsulating all of this information and these data structures inside the package, you can take advantage of DBMS_DESCRIBE.DESCRIBE_PROCEDURE much more easily, and also interpret the results with greater accuracy and understanding.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.3.1"
>10.2.3.1 Features of the psdesc package</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch10-idx-13647-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13647-1"
></A
>psdesc package offers those features (PL/SQL Release 2.3 or later is needed to compile and use this package). Found in the <I
CLASS="filename"
>psdesc.spp</I
><A
CLASS="indexterm"
NAME="ch10-idx-13651-0"
></A
> file, it contains the following elements:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>A set of constants that give names to each of the different datatype values. These constants allow you to write code without having to remember specific hard-coded values. Here are a few lines from that code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   c_varchar2       CONSTANT PLS_INTEGER := 1;
   c_number         CONSTANT PLS_INTEGER := 2;
   c_object_type    CONSTANT PLS_INTEGER := 121;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A PL/SQL table containing names to go along with those datatype constants (numbers). The psdesc.showargs program uses this table to display more descriptive information about the argument (for example, more than simply saying that it is type 121).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A set of constants that give names to the values for the different parameter modes. These are defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   c_in CONSTANT PLS_INTEGER := 0;
   c_out CONSTANT PLS_INTEGER := 1;
   c_inout CONSTANT PLS_INTEGER := 2;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A user-defined record type that parallels the set of PL/SQL tables populated by the DESCRIBE_PROCEDURE procedure. This record type is defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   TYPE arglist_rt IS RECORD (
     overload NUMBER,
     position NUMBER
    ,level NUMBER
    ,argument_name VARCHAR2 (30)
    ,datatype NUMBER
    ,default_value NUMBER
    ,in_out NUMBER
    ,length NUMBER
    ,precision NUMBER
    ,scale NUMBER
    ,radix NUMBER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This record type is the RETURN value for the psdesc.arg function.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A procedure that acts as a wrapper around the DESCRIBE_PROCEDURE procedure. The psdesc.args procedure has a much simpler interface.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   PROCEDURE psdesc.args (obj IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you call it, you don't need to provide a set of predeclared PL/SQL tables. Those arrays are already defined in the psdesc package specification.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A procedure that displays all of the argument information in a very readable format. You have seen the output (or part of it) in a number of earlier sections in this chapter.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   PROCEDURE psdesc.showargs (obj IN VARCHAR2 := NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that this procedure has an optional object name; if you don't provide one, it will show you the arguments for whatever program was last processed in a call to psdesc.args. In other words, it will examine whatever is sitting in the individual arrays.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A procedure that returns information about a specified argument (by position in the arrays).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   FUNCTION psdesc.<A
CLASS="indexterm"
NAME="ch10-idx-13654-0"
></A
>arg (pos IN INTEGER) RETURN arglist_rt;</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>For reasons of space, I will not show the entire package specification and body. You can examine both of those in the <I
CLASS="filename"
>psdesc.spp</I
> file. You will notice that I have placed all of the predefined PL/SQL tables in the package specification, even though the programs of psdesc offer a programmatic interface to those tables. I did that to make it easier to examine and manipulate the contents of the argument information.</P
><P
CLASS="para"
>Just to give you a sense of how psdesc does its job, here is the implementation of psdesc.args (my "substitute" for the original DESCRIBE_PROCEDURE):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch10-idx-15198-0"
></A
>psdesc.spp */*
PROCEDURE <A
CLASS="indexterm"
NAME="ch10-idx-13657-0"
></A
>args (obj IN VARCHAR2)
IS
BEGIN
   g_object_name := obj;

   DBMS_DESCRIBE.DESCRIBE_PROCEDURE (obj, NULL, NULL,
      g_overload,
      g_position,
      g_level,
      g_argument_name,
      g_datatype,
      g_default_value,
      g_in_out,
      g_length,
      g_precision,
      g_scale,
      g_radix,
      g_spare);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I save the object name you specify in a package variable. I then call DESCRIBE_PROCEDURE, dumping all of the retrieved information into the predeclared PL/SQL tables.</P
><P
CLASS="para"
>To display all of the argument information for a program, you would call psdesc.showargs. Here is a simplified presentation of this procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch10-idx-13660-0"
></A
>showargs (obj IN VARCHAR2 := NULL)
IS
   v_onearg arglist_rt;
BEGIN
   IF obj IS NOT NULL
   THEN
      args (obj);
   END IF;

   IF g_position.COUNT &gt; 0
   THEN
      display_header;

      FOR argrow IN g_position.FIRST .. g_position.LAST
      LOOP
         v_onearg := arg (argrow);

         display_argument_info (v_onearg);
      END LOOP;
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, if the object name is specified, call psdesc.args to fill up the pre-defined arrays. Then, if there is anything in those arrays (g_position.COUNT is greater than 0), proceed from the first to the last argument and (a) call psdesc.arg to retrieve all the information for the Nth argument, and (b) display that information&nbsp;-- all the details of which are left to the <I
CLASS="filename"
>psdesc.spp</I
> file. That was easy enough!</P
><P
CLASS="para"
>Here are some other aspects of psdesc you might find interesting:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Use of the package initialization section to fill g_datatype_names and g_mode_names, which are lists of "translations" for the numeric codes.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The use of a local function, strval, defined inside psdesc.showargs, which consolidates otherwise redundant logic used to format output for display.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The check for a non-NULL g_object_name in the psdesc.arg function to make sure that you have used psdesc.args or psdesc.showargs to fill up the predefined PL/SQL tables. This is a sure-fire validation step, since the g_object_name variable is defined in the package <EM
CLASS="emphasis"
>body</EM
>. It is private data and is only modified by a call to psdesc.arg. </P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-2.3.2"
>10.2.3.2 Using psdesc.args as a quality assurance tool</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13661-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13661-1"
></A
>Rather than spend any more space on the implementation of psdesc, I will show you how you might put it to use. </P
><P
CLASS="para"
>Suppose that you want to perform quality assurance checks on your code (what a concept, eh?). One rule that you have established for all your developers is that no function should have OUT or IN OUT parameters. The only way that data is to be returned from a function is through the RETURN clause. This guideline improves the reusability and maintainability of the function. It also makes that function a candidate for execution within SQL.</P
><P
CLASS="para"
>How can you make sure that everyone is following this rule?</P
><P
CLASS="para"
>Sure, you could run some queries against ALL_SOURCE, which contains all the source code, but what would you look for? "IN OUT" and "OUT" are good candidates, but only when they are inside the parameter lists of functions. Hmmm. That actually involves some parsing. What's a software manager interested in code quality to do?</P
><P
CLASS="para"
>Let's see if DESCRIBE_PROCEDURE and the psdesc package can help. The following hasout function satisfies the request by obtaining all arguments with a call to psdesc.args and then scanning the PL/SQL table filled from DBMS_DESCRIBE.DESCRIBE_PROCEDURE for the offending parameter mode. This function returns TRUE if the program named by the string that I pass to it contains an OUT or IN OUT argument.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch10-idx-13665-0"
></A
>hasout.sf */*
CREATE OR REPLACE FUNCTION <A
CLASS="indexterm"
NAME="ch10-idx-13666-0"
></A
>hasout (obj IN VARCHAR2) RETURN BOOLEAN
IS
   v_onearg psdesc.arglist_rt;
   v_argrow PLS_INTEGER;
   retval BOOLEAN := NULL;
BEGIN
   psdesc.args (obj);

   v_argrow := psdesc.numargs;

   IF v_argrow = 0
   THEN
      retval := NULL;
   ELSE
      retval := FALSE;
      LOOP
         v_onearg := psdesc.arg (v_argrow);
         IF v_onearg.argument_name IS NOT NULL
         THEN
            retval := v_onearg.in_out IN (psdesc.c_out, psdesc.c_inout);
         END IF;
         EXIT WHEN retval OR v_argrow = 1;
         v_argrow := v_argrow - 1;
      END LOOP;
   END IF;
   RETURN retval;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This function works as advertised, even for overloaded programs. Suppose, for example, that I run this function against the desctst.upd function (overloaded earlier in two versions). These functions do not contain an OUT or IN OUT parameter. I run the following script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch10-idx-13667-0"
></A
>hasout.tst */*
BEGIN
   /* I need to call hasout with an IF statement if I am going to use
      DBMS_OUTPUT.PUT_LINE to show the results; that built-in is very 
      sadly not overloaded for Booleans... */
   IF hasout ('&amp;1')
   THEN
      DBMS_OUTPUT.PUT_LINE ('&amp;1 contains OUT or IN OUT argument(s).');
   ELSE  
      DBMS_OUTPUT.PUT_LINE ('&amp;1 contains only IN argument(s).');
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Calling this function, I get the following results:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @hasout.tst desctest.upd
desctest.upd contains only IN argument(s).</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If I now add an additional overloading of the desctest.upd function as follows,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch10-idx-15338-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-15338-1"
></A
>desctest
IS
   FUNCTION<A
CLASS="indexterm"
NAME="ch10-idx-13669-0"
></A
> upd (account_in NUMBER, 
     person person%ROWTYPE, 
     amounts number_table,
     trans_no NUMBER,
     maxsal OUT NUMBER) RETURN account.balance%TYPE;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I then get this result from running the hasout function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @hasout.tst desctest.upd
desctest.upd contains OUT or IN OUT argument(s).</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And I bet you thought you wouldn't ever find any reason to use DESCRIBE_PROCEDURE! This handy little utility points the way to many other kinds of analyses you can perform on your code. Once you have the psdesc package in place, it becomes easy to construct these higher-level programs.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-13670-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13670-1"
></A
>Now all you have to do is come up with a way to feed your full list of functions (both standalone and packaged) into the hasout function for its quality check. This sounds easier than it actually is. Why? Because Oracle does not offer any utilities that provide you with the list of programs defined inside of a package. </P
><P
CLASS="para"
>You cannot, in other words, do a describe on a package and see the list of elements defined in that package's specification. I hope that this is a shortcoming Oracle will correct, both through the provision of an API (perhaps by adding another procedure to the DBMS_DESCRIBE package) and the extension of the DESCRIBE command in SQL*Plus.</P
><P
CLASS="para"
>In the meantime, though, you have some options. You can get all of the stand-alone functions from ALL_OBJECTS, and that will be a start. Furthermore, if you are using PL/Vision from RevealNet (see the Preface, "About PL/Vision"), you can use the PLVcat utility to catalog your package specifications. This process will extract the names of all procedures and functions and deposit them in the plvctlg table. If that is not available, you will have to come up with a list by performing a code review on all your packages. Then put those function names (with their package names prefixed) into a database table or file. Once you have that, you can easily construct a script to read those <A
CLASS="indexterm"
NAME="ch10-idx-13672-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13672-1"
></A
>names <A
CLASS="indexterm"
NAME="ch10-idx-13663-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13663-1"
></A
>and <A
CLASS="indexterm"
NAME="ch10-idx-13649-0"
></A
>pass <A
CLASS="indexterm"
NAME="ch10-idx-13645-0"
></A
>them <A
CLASS="indexterm"
NAME="ch10-idx-13586-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13586-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13586-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13586-3"
></A
>to <A
CLASS="indexterm"
NAME="ch10-idx-13578-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13578-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-13578-2"
></A
>hasout.</P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_01.htm"
TITLE="10.1 DBMS_UTILITY: Performing Miscellaneous Operations"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.1 DBMS_UTILITY: Performing Miscellaneous Operations"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_03.htm#ch10-SECT-3.2"
TITLE="10.3 DBMS_DDL: Compiling and Analyzing Objects"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.3 DBMS_DDL: Compiling and Analyzing Objects"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>10.1 DBMS_UTILITY: Performing Miscellaneous Operations</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10.3 DBMS_DDL: Compiling and Analyzing Objects</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
