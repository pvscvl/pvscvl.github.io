<HTML
><HEAD
><TITLE
>[Chapter 6] Generating Output from PL/SQL Programs</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:54:00Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part02.htm"
TITLE="II. Application Development Packages"><LINK
REL="prev"
HREF="ch05_07.htm#ch05-SECT-7.5.1"
TITLE="5.7 Oracle AQ Examples"><LINK
REL="next"
HREF="ch06_02.htm#ch06-SECT-2.1.1"
TITLE="6.2 UTL_FILE: Reading and Writing Server-side Files"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_07.htm#ch05-SECT-7.5.1"
TITLE="5.7 Oracle AQ Examples"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.7 Oracle AQ Examples"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 6</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_02.htm#ch06-SECT-2.1.1"
TITLE="6.2 UTL_FILE: Reading and Writing Server-side Files"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.2 UTL_FILE: Reading and Writing Server-side Files"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="PACKAGES-CH-6"
>6. Generating Output from PL/SQL Programs</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch06-33749"
TITLE="6.1 DBMS_OUTPUT: Displaying Output"
>DBMS_OUTPUT: Displaying Output</A
><BR><A
CLASS="sect1"
HREF="ch06_02.htm#ch06-SECT-2.1.1"
TITLE="6.2 UTL_FILE: Reading and Writing Server-side Files"
>UTL_FILE: Reading and Writing Server-side Files</A
></P
><P
></P
></DIV
><P
CLASS="para"
>The built-in packages offer a number of ways to generate output from within your PL/SQL program. While updating a database table is, of course, a form of "output" from PL/SQL, this chapter shows you how to use two packages that explicitly generate output. UTL_FILE reads and writes information in server-side files, and DBMS_OUTPUT displays information to your screen.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch06-33749"
>6.1 DBMS_OUTPUT: Displaying Output</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13616-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13616-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13616-2"
></A
>DBMS_OUTPUT provides a mechanism for displaying information from your PL/SQL program on your screen (your session's output device, to be more specific). As such, it serves as just about the only immediately accessible (meaning "free with PL/SQL") means of <A
CLASS="indexterm"
NAME="ch06-idx-13624-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13624-1"
></A
>debugging your PL/SQL stored code.[<A
CLASS="footnote"
HREF="#ch06-pgfId-10213"
>1</A
>] It is certainly your "lowest common denominator" debugger, similar to the used-and-abused MESSAGE built-in of Oracle Forms. DBMS_OUTPUT is also the package you are most likely to use to generate <A
CLASS="indexterm"
NAME="ch06-idx-13625-0"
></A
>reports from PL/SQL scripts run in SQL*Plus. </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch06-pgfId-10213"
>[1]</A
> As this book is going to press, the following PL/SQL debuggers are now available: SQL-Station Debugger from Platinum Technology; SQL Navigator from Quest; Xpediter/SQL from Compuware; and Procedure Builder from Oracle Corporation.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Of all the built-in packages, the DBMS_OUTPUT package (and its PUT_LINE procedure, in particular) is likely to be the one you will find yourself using most frequently. You may therefore find it strange that I never call DBMS_OUTPUT.PUT_LINE. I find the design and functionality of DBMS_OUTPUT to be substandard and very frustrating.</P
><P
CLASS="para"
>In fact, I recommend that you never use this package&nbsp;-- at least, not directly. You should instead encapsulate calls to DBMS_OUTPUT (and the PUT_LINE procedure, in particular) inside a package of your own construction. This technique is discussed in the <A
CLASS="xref"
HREF="ch06_01.htm"
>Section 6.1.6, "DBMS_OUTPUT Examples"</A
>" section later in this chapter.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-1.1"
>6.1.1 Getting Started with DBMS_OUTPUT</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13632-0"
></A
>DBMS_OUTPUT package is created when the Oracle database is installed. The <I
CLASS="filename"
>dbmsoutp.sql</I
><A
CLASS="indexterm"
NAME="ch06-idx-13633-0"
></A
> script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1, <CITE
CLASS="chapter"
>Introduction</CITE
></A
>) contains the source code for this package's specification. This script is called by the <I
CLASS="filename"
>catproc.sql</I
> script, which is normally run immediately after database creation. The script creates the public synonym <A
CLASS="indexterm"
NAME="ch06-idx-15335-0"
></A
>DBMS_OUTPUT for the package. Instance-wise access to this package is provided on installation, so no additional steps should be necessary in order to use DBMS_OUTPUT. As far as package usage is concerned, you will almost always be using only the DBMS_OUTPUT.PUT_LINE procedure and only in SQL*Plus. The section <A
CLASS="xref"
HREF="ch06_01.htm"
>Section 6.1.2, "Enabling and Disabling Output"</A
>" later in this chapter shows how you set up DBMS_OUTPUT for use in SQL*Plus.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.1.1"
>6.1.1.1 DBMS_OUTPUT programs</A
></H4
><P
CLASS="para"
>Table 6-1 <A
CLASS="indexterm"
NAME="ch06-idx-13635-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13635-1"
></A
>shows the DBMS_OUTPUT program names and descriptions. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="AUTOID-14363"
>Table 6.1: DBMS_OUTPUT Programs</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13637-0"
></A
>DISABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Disables output from the package; the DBMS_OUTPUT buffer will not be flushed to the screen</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13636-0"
></A
>ENABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Enables output from the package</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13641-0"
></A
>GET_LINE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Gets a single line from the buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13642-0"
></A
>GET_LINES</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Gets specified number of lines from the buffer and passes them into a PL/SQL table</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13640-0"
></A
>NEW_LINE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Inserts an end-of-line mark in the buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13638-0"
></A
>PUT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Puts information into the buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13639-0"
></A
>PUT_LINE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Puts information into the buffer and appends an end-of-line marker after that data</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
></TBODY
></TABLE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> All procedures in DBMS_OUTPUT have been enabled for indirect usage in SQL (that is, they can be called by a function that is then executed in a SQL statement), but only for <A
CLASS="indexterm"
NAME="ch06-idx-13643-0"
></A
>Oracle 7.3 and later.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.1.2"
>6.1.1.2 DBMS_OUTPUT concepts</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13644-0"
></A
>Each user has a DBMS_OUTPUT buffer of up to 1,000,000 bytes in size. Write information to this buffer by calling the DBMS_OUTPUT.PUT and DBMS_OUTPUT.PUT_LINE programs. If you are using DBMS_OUTPUT from within SQL*Plus, this information will be displayed automatically when your program terminates. You can (optionally) explicitly retrieve information from the buffer with calls to DBMS_OUTPUT.GET and DBMS_OUTPUT.GET_LINE. </P
><P
CLASS="para"
>The DBMS_OUTPUT buffer can be set to a size between 2,000 and 1,000,000 bytes with the DBMS_OUTPUT.ENABLE procedure. If you do not enable the package, no information will be displayed or be retrievable from the buffer. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13648-0"
></A
>The buffer stores three different types of data&nbsp;-- VARCHAR2, NUMBER, and DATE&nbsp;-- in their internal representations. These types match the overloading available with the PUT and PUT_LINE procedures. Note that DBMS_OUTPUT does <EM
CLASS="emphasis"
>not</EM
> support Boolean data in either its buffer or its overloading of the PUT procedures.</P
><P
CLASS="para"
>The following anonymous PL/SQL block uses DBMS_OUTPUT to display the name and salary of each employee in department 10:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR emp_cur 
   IS
      SELECT ename, sal
        FROM emp
       WHERE deptno = 10
       ORDER BY sal DESC;
BEGIN
   FOR emp_rec IN emp_cur
   LOOP
      DBMS_OUTPUT.PUT_LINE 
         ('Employee ' || emp_rec.ename || ' earns ' || 
          TO_CHAR (emp_rec.sal) || ' dollars.');
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This program generates the following output when executed in SQL*Plus:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Employee KING earns 5000 dollars.
Employee SCOTT earns 3000 dollars.
Employee JONES earns 2975 dollars.
Employee ADAMS earns 1100 dollars.
Employee JAMES earns 950 dollars.</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.1.3"
>6.1.1.3 DBMS_OUTPUT exceptions</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13653-0"
></A
>DBMS_OUTPUT does not contain any declared exceptions. Instead, Oracle designed the package to rely on two error numbers in the -20 NNN range (usually reserved for Oracle customers). You may, therefore, encounter one of these two exceptions when using the DBMS_OUTPUT package (no names are associated with these exceptions). </P
><P
CLASS="para"
>The -20000 error number indicates that these package-specific exceptions were raised by a call to RAISE_APPLICATION_ERROR, which is in the DBMS_STANDARD package. </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>-20000</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>ORU-10027: buffer overflow, limit of &lt;buf_limit&gt; bytes. </P
><P
CLASS="para"
>If you receive the -10027 error, you should see if you can increase the size of your buffer with another call to DBMS_OUTPUT.ENABLE. </P
></DD
><DT
CLASS="term"
>-20000</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>ORU-10028: line length overflow, limit of 255 bytes per line.</P
><P
CLASS="para"
>If you receive the -10028 error, you should restrict the amount of data you are passing to the buffer in a single call to PUT_LINE, or in a batch of calls to PUT followed by NEW_LINE.</P
></DD
></DL
><P
CLASS="para"
>You may also receive the ORA-06502 error:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-06502</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Numeric or value error.</P
><P
CLASS="para"
>If you receive the -06502 error, you have tried to pass more than 255 bytes of data to DBMS_OUTPUT.PUT_LINE. You must break up the line into more than one <A
CLASS="indexterm"
NAME="ch06-idx-13655-0"
></A
>string.</P
></DD
></DL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.1.4"
>6.1.1.4 DBMS_OUTPUT nonprogram elements</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13656-0"
></A
>DBMS_OUTPUT package defines a PL/SQL table TYPE as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE chararr IS TABLE OF VARCHAR2(255) INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The DBMS_OUTPUT.GET_LINES procedure returns its lines in a PL/SQL table of this type.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.1.5"
>6.1.1.5 Drawbacks of DBMS_OUTPUT</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13657-0"
></A
>Before learning all about this package, and rushing to use it, you should be aware of several drawbacks with the implementation of this functionality:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The "put" procedures that place information in the buffer are overloaded only for strings, dates, and numbers. You cannot request the display of Booleans or any other types of data. You cannot display combinations of data (a string and a number, for instance), without performing the conversions and concatentations yourself.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You will see output from this package only after your program completes its execution. You <EM
CLASS="emphasis"
>cannot</EM
> use DBMS_OUTPUT to examine the results of a program while it is running. And if your program terminates with an unhandled exception, you may not see anything at all!</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you try to display strings longer than 255 bytes, DBMS_OUTPUT will raise a VALUE_ERROR exception.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>DBMS_OUTPUT is not a strong choice as a report generator, because it can handle a maximum of only 1,000,000 bytes of data in a session before it raises an exception.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you use DBMS_OUTPUT in SQL*Plus, you may find that any leading blanks are automatically truncated. Also, attempts to display blank or NULL lines are completely ignored.</P
></LI
></UL
><P
CLASS="para"
>There are workarounds for almost every one of these drawbacks. The solution invariably requires the construction of a package that encapsulates and hides DBMS_OUTPUT. This technique is explained in the <A
CLASS="xref"
HREF="ch06_01.htm"
>Section 6.1.6</A
>" <A
CLASS="indexterm"
NAME="ch06-idx-13659-0"
></A
>section.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-11537"
>6.1.2 Enabling and Disabling Output</A
></H3
><P
CLASS="para"
>The ENABLE and DISABLE procedures enable and disable output from the DBMS_OUTPUT.PUT_LINE (and PUT and PUTF) procedure.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.2.1"
>6.1.2.1 The DBMS_OUTPUT.ENABLE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13661-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13661-1"
></A
>ENABLE procedure enables calls to the other DBMS_OUTPUT modules. If you do not first call ENABLE, then any other calls to the package modules are ignored. The specification for the procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_OUTPUT.ENABLE  (buffer_size IN INTEGER DEFAULT 20000);</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13662-0"
></A
>where buffer_size is the size of the buffer that will contain the information stored by calls to PUT and PUT_LINE. The buffer size can be as large as 1,000,000 bytes. You can pass larger values to this procedure without raising an error, but doing so will have no effect besides setting the buffer size to its maximum. </P
><P
CLASS="para"
>You can call ENABLE more than once in a session. The buffer size will be set to the largest size passed in any call to ENABLE. In other words, the buffer size is not necessarily set to the size specified in the last call.</P
><P
CLASS="para"
>If you want to make sure that the DBMS_OUTPUT package is enabled in a program you are testing, add a statement like this one to the start of the program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   ... declarations ...
BEGIN
   DBMS_OUTPUT.ENABLE (1000000);
   ...
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.2.2"
>6.1.2.2 The DBMS_OUTPUT.DISABLE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13663-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13663-1"
></A
>DISABLE procedure disables all calls to the DBMS_OUTPUT package (except for ENABLE). It also purges the buffer of any remaining lines of information. Here's the specification for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_OUTPUT.DISABLE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13668-0"
></A
>SQL*Plus and SQL*DBA offer a native command, <A
CLASS="indexterm"
NAME="ch06-idx-13699-0"
></A
>SET SERVEROUTPUT, with which you can disable the package without having to execute the DISABLE procedure directly. You can use the command as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SET SERVEROUTPUT OFF</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This command is equivalent to the following PL/SQL statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_OUTPUT.DISABLE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>After you execute this command, any calls to PUT_LINE and other modules will be ignored, and you will not see any output.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.2.3"
>6.1.2.3 Enabling output in SQL*Plus</A
></H4
><P
CLASS="para"
>Most developers use DBMS_OUTPUT almost exclusively in the SQL*Plus environment. To enable output from calls to PUT_LINE in SQL*Plus, you will use the SET SERVEROUTPUT command,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET SERVEROUTPUT ON SIZE 1000000</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET SERVEROUTPUT ON</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Each of these calls the DBMS_OUTPUT.ENABLE procedure.</P
><P
CLASS="para"
>I have found it useful to add SET SERVEROUTPUT ON SIZE 1000000 to my <I
CLASS="filename"
>login.sql</I
> file, so that the package is automatically enabled whenever I go into SQL*Plus. (I guess that tells you how often I have to debug my code!) </P
><P
CLASS="para"
>You should also check the Oracle documentation for SQL*Plus to find out about the latest set of options for the SET SERVEROUTPUT command. As of Oracle8, the documentation shows the following syntax for this SET command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET SERVEROUT[PUT] {OFF|ON} 
   [SIZE n] [FOR[MAT] {WRA[PPED]| WOR[D_WRAPPED]|TRU[NCATED]}] </PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, you have these options when you enable DBMS_OUTPUT in SQL*Plus:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>SET SERVEROUTPUT OFF</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Turns off the display of text from DBMS_OUTPUT.</P
></DD
><DT
CLASS="term"
>SET SERVEROUTPUT ON</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Turns on the display of text from DBMS_OUTPUT with the default 2000-byte buffer. This is a very small size for the buffer; I recommend that you always specify a size when you call this command.</P
></DD
><DT
CLASS="term"
>SET SERVEROUTPUT ON SIZE NNNN</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Turns on the display of text from DBMS_OUTPUT with the specified buffer size (maximum of 1,000,000 bytes).</P
></DD
><DT
CLASS="term"
>SET SERVEROUTPUT ON FORMAT WRAPPED</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(Available in Oracle 7.3 and later only.) Specifies that you want the text displayed by DBMS_OUTPUT wrapped at the SQL*Plus line length. The wrapping occurs regardless of word separation. This will also stop SQL*Plus from stripping leading blanks from your text. You can also specify a SIZE value with this variation.</P
></DD
><DT
CLASS="term"
>SET SERVEROUTPUT ON FORMAT WORD_WRAPPED</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(Available in Oracle 7.3 and later only.) Specifies that you want the text displayed by DBMS_OUTPUT wrapped at the SQL*Plus line length. This version respects integrity of "words." As a result, lines will be broken in a way that keeps separate tokens intact. This will also stop SQL*Plus from stripping leading blanks from your text. You can also specify a SIZE value with this variation.</P
></DD
><DT
CLASS="term"
><A
CLASS="indexterm"
NAME="ch06-idx-13700-0"
></A
>SET SERVEROUTPUT ON FORMAT TRUNCATED</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(Available in Oracle 7.3 and later only.) Specifies that you want the text displayed by DBMS_OUTPUT to be truncated at the SQL*Plus line length; the rest of the text will not be displayed. This will also stop SQL*Plus from stripping leading blanks from your text. You can also specify a SIZE value with this <A
CLASS="indexterm"
NAME="ch06-idx-13671-0"
></A
>variation.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-1.3"
>6.1.3 Writing to the DBMS_OUTPUT Buffer</A
></H3
><P
CLASS="para"
>You can write information to the buffer with calls to the PUT, NEW_LINE, and PUT_LINE procedures.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.3.1"
>6.1.3.1 The DBMS_OUTPUT.PUT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13675-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13675-1"
></A
>PUT procedure puts information into the buffer, but does not append a newline marker into the buffer. Use PUT if you want to place information in the buffer (usually with more than one call to PUT), but not also automatically issue a newline marker. The specification for PUT is overloaded, so that you can pass data in its native format to the package without having to perform conversions,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_OUTPUT.PUT (A VARCHAR2);
PROCEDURE DBMS_OUTPUT.PUT (A NUMBER);
PROCEDURE DBMS_OUTPUT.PUT (A DATE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where A is the data being passed. </P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-1.3.1.1"
>6.1.3.1.1 Example</A
></H4
><P
CLASS="para"
>In the following example, three simultaneous calls to PUT place the employee name, department ID number, and hire date into a single line in the DBMS_OUTPUT buffer:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_OUTPUT.PUT (:employee.lname || ', ' || :employee.fname);
DBMS_OUTPUT.PUT (:employee.department_id);
DBMS_OUTPUT.PUT (:employee.hiredate);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you follow these PUT calls with a NEW_LINE call, that information can then be retrieved with a single call to <A
CLASS="indexterm"
NAME="ch06-idx-13676-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13676-1"
></A
>GET_LINE.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.3.2"
>6.1.3.2 The DBMS_OUTPUT.PUT_LINE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13677-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13677-1"
></A
>PUT_LINE procedure puts information into the buffer and then appends a <A
CLASS="indexterm"
NAME="ch06-idx-13680-0"
></A
>newline marker into the buffer. The specification for PUT_LINE is overloaded, so that you can pass data in its native format to the package without having to perform conversions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_OUTPUT.PUT_LINE (A VARCHAR2);
PROCEDURE DBMS_OUTPUT.PUT_LINE (A NUMBER);
PROCEDURE DBMS_OUTPUT.PUT_LINE (A DATE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The PUT_LINE procedure is the one most commonly used in SQL*Plus to debug PL/SQL programs. When you use PUT_LINE in these situations, you do not need to call GET_LINE to extract the information from the buffer. Instead, SQL*Plus will automatically dump out the DBMS_OUTPUT buffer when your PL/SQL block finishes executing. (You will not see any output until the program ends.)</P
><P
CLASS="para"
>Of course, you can also call DBMS_OUTPUT programs directly from the SQL*Plus command prompt, and not from inside a PL/SQL block, as shown in the following example.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-1.3.2.1"
>6.1.3.2.1 Example</A
></H4
><P
CLASS="para"
>Suppose that you execute the following three statements in SQL*Plus:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec DBMS_OUTPUT.PUT ('I am');
SQL&gt; exec DBMS_OUTPUT.PUT (' writing ');
SQL&gt; exec DBMS_OUTPUT.PUT ('a ');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You will not see anything, because PUT will place the information in the buffer, but will not append the newline marker. When you issue this next PUT_LINE command,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec DBMS_OUTPUT.PUT_LINE ('book!');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>you will then see the following output:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>I am writing a book!</PRE
></BLOCKQUOTE
><P
CLASS="para"
>All of the information added to the buffer with the calls to PUT waited patiently to be flushed out with the call to PUT_LINE. This is the behavior you will see when you execute individual calls at the SQL*Plus command prompt to the put programs. </P
><P
CLASS="para"
>If you place these same commands in a PL/SQL block,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_OUTPUT.PUT ('I am');
   DBMS_OUTPUT.PUT (' writing ');
   DBMS_OUTPUT.PUT ('a ');
   DBMS_OUTPUT.PUT_LINE ('book');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>the output from this script will be exactly the same as that generated by this single <A
CLASS="indexterm"
NAME="ch06-idx-13678-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13678-1"
></A
>call:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec DBMS_OUTPUT.PUT_LINE ('I am writing a book!');</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.3.3"
>6.1.3.3 The DBMS_OUTPUT.NEW_LINE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13679-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13679-1"
></A
>NEW_LINE procedure inserts an end-of-line marker in the buffer. Use NEW_LINE after one or more calls to PUT in order to terminate those entries in the buffer with a newline marker. Here's the specification for <A
CLASS="indexterm"
NAME="ch06-idx-15286-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-15286-1"
></A
>NEW_LINE:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_OUTPUT.NEW_LINE;</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-1.4"
>6.1.4 Retrieving Data from the DBMS_OUTPUT Buffer</A
></H3
><P
CLASS="para"
>You can use the GET_LINE and GET_LINES procedures to extract information from the DBMS_OUTPUT buffer. If you are using DBMS_OUTPUT from within SQL*Plus, however, you will never need to call either of these procedures. Instead, SQL*Plus will automatically extract the information and display it on the screen for you.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.4.1"
>6.1.4.1 The DBMS_OUTPUT.GET_LINE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13685-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13685-1"
></A
>GET_LINE procedure retrieves one line of information from the buffer. Here's the specification for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_OUTPUT.GET_LINE 
   (line OUT VARCHAR2, 
    status OUT INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>line</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Retrieved line of text</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>status</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET request status</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The line can have up to 255 bytes in it, which is not very long. If GET_LINE completes successfully, then status is set to 0. Otherwise, GET_LINE returns a status of 1. </P
><P
CLASS="para"
>Notice that even though the PUT and PUT_LINE procedures allow you to place information into the buffer in their native representations (dates as dates, numbers and numbers, and so forth), GET_LINE always retrieves the information into a character string. The information returned by GET_LINE is everything in the buffer up to the next newline character. This information might be the data from a single PUT_LINE or from multiple calls to PUT.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-1.4.1.1"
>6.1.4.1.1 Example</A
></H4
><P
CLASS="para"
>The following call to GET_LINE extracts the next line of information into a local PL/SQL variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION get_next_line RETURN VARCHAR2 
IS
   return_value VARCHAR2(255);
   get_status INTEGER;
BEGIN
   DBMS_OUTPUT.GET_LINE (return_value, get_status);
   IF get_status = 0
   THEN
      RETURN return_value;
   ELSE
      RETURN NULL;
   END IF;
<A
CLASS="indexterm"
NAME="ch06-idx-13686-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13686-1"
></A
>END;</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.4.2"
>6.1.4.2 The DBMS_OUTPUT.GET_LINES procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13687-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13687-1"
></A
>GET_LINES procedure retrieves multiple lines from the buffer with one call. It reads the buffer into a PL/SQL string table. Here's the specification for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <CODE
CLASS="literal"
>DBMS_OUTPUT.GET_LINE</CODE
>S 
   (lines OUT DBMS_OUTPUT.CHARARR, 
    numlines IN OUT INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this procedure are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lines</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PL/SQL array where retrieved lines are placed</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>numlines</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of individual lines retrieved from the buffer and placed into the array</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The lines parameter is a PL/SQL table TYPE declared in the specification of the package. It is described at the beginning of this chapter.</P
><P
CLASS="para"
>The values retrieved by GET_LINES are placed in the first numlines rows in the table, starting from row one. As indicated in the PL/SQL table structure, each line (row in the table) may contain up to 255 bytes.</P
><P
CLASS="para"
>Notice that numlines is an IN OUT parameter. The IN aspect of the parameter specifies the number of lines to retrieve. Once GET_LINES is done retrieving data, however, it sets numlines to the number of lines actually placed in the table. If you ask for ten rows and there are only six in the buffer, then you need to know that only the first six rows of the table are defined.</P
><P
CLASS="para"
>Notice also that even though the PUT and PUT_LINE procedures allow you to place information into the buffer in their native representations (dates as dates, numbers and numbers, and so forth), GET_LINES always retrieves the information into a character string. The information in each line returned by GET_LINES is everything in the buffer up to the next newline character. This information might be the data from a single PUT_LINE or from multiple calls to PUT.</P
><P
CLASS="para"
>While GET_LINES is provided with the DBMS_OUTPUT package, it is not needed to retrieve information from the DBMS_OUTPUT buffer&nbsp;-- at least when used inside SQL*Plus. In this interactive query tool, you simply execute calls to PUT_LINE, and when the PL/SQL block terminates, SQL*Plus will automatically dump the buffer to the screen.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-1.4.2.1"
>6.1.4.2.1 Example</A
></H4
><P
CLASS="para"
>The following script demonstrates both the kind of code you would write when using the GET_LINES procedure, and also the way in which the PL/SQL table is filled:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch06-idx-15315-0"
></A
> getlines.tst */*
DECLARE
  output_table DBMS_OUTPUT.CHARARR;  /* output_buf_tab */
  a_line VARCHAR2(10) := RPAD('*',10,'*');
  status INTEGER;
  max_lines CONSTANT NUMBER := 15;
BEGIN
   output_table (0) := 'ABC';
   output_table (12) := 'DEF';
   
   /* Output 10 lines */
   FOR linenum IN 1..10 
   LOOP
      DBMS_OUTPUT.PUT_LINE (a_line ||  TO_CHAR (linenum);
   END LOOP;
   /* retrieve 15 lines, status will receive the line count */
   status := max_lines;
   DBMS_OUTPUT.GET_LINES ( output_table, status);
   DBMS_OUTPUT.PUT_LINE ('lines retrieved= ' || status));
 
   FOR linenum in 0..max_lines 
   LOOP
       BEGIN
          DBMS_OUTPUT.PUT_LINE
             (linenum || ':' || NVL (output_table(linenum),'&lt;null&gt;') );
       EXCEPTION
          WHEN OTHERS 
          THEN
             DBMS_OUTPUT.PUT_LINE (linenum || ':' || sqlerrm );
       END;
    END LOOP;
EXCEPTION
   WHEN OTHERS 
   THEN
       DBMS_OUTPUT.PUT_LINE ('Exception, status=' || status);
       DBMS_OUTPUT.PUT_LINE (SQLERRM );
END;
/ </PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the output from the execution of this script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>lines retrieved= 10
0:ORA-01403: no data found
1:**********1
2:**********2
3:**********3
4:**********4
5:**********5
6:**********6
7:**********7
8:**********8
9:**********9
10:**********10
11:&lt;null&gt;
12:ORA-01403: no data found
13:ORA-01403: no data found
14:ORA-01403: no data found
15:ORA-01403: no data found</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can therefore deduce the following rules:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The PL/SQL table is filled starting with row 1.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If DBMS_OUTPUT.GET_LINES finds N lines of data to pass to the PL/SQL table, it sets row N+1 in that table to NULL. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>All other rows in the PL/SQL table are set to "undefined." In other words, any other rows that might have been defined before the call to GET_LINES <A
CLASS="indexterm"
NAME="ch06-idx-13689-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13689-1"
></A
>are deleted.</P
></LI
></OL
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-1.5"
>6.1.5 Tips on Using DBMS_OUTPUT</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13695-0"
></A
>As noted at the beginning of the chapter, DBMS_OUTPUT comes with several handicaps. The best way to overcome these handicaps is to create your own layer of code over the built-in package. This technique is explored in the <A
CLASS="xref"
HREF="ch06_01.htm"
>Section 6.1.6</A
>" section. </P
><P
CLASS="para"
>Regardless of the use of an encapsulation package, you should keep the following complications in mind as you work with DBMS_OUTPUT:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13697-0"
></A
>If your program raises an unhandled exception, you may not see any executed output from PUT_LINE, even if you enabled the package for output<B
CLASS="emphasis.bold"
>.</B
> </P
><P
CLASS="para"
>This can happen because the DBMS_OUTPUT buffer will not be flushed until it is full or until the current PL/SQL block completes its execution. If a raised exception never gets handled, the buffer will not be flushed. As a result, calls to the DBMS_OUTPUT.PUT_LINE module might never show their data. So if you are working with DBMS_OUTPUT.PUT_LINE and are frustrated because you are not seeing the output you would expect, make sure that you have: </P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
> Enabled output from the package by calling <A
CLASS="indexterm"
NAME="ch06-idx-13701-0"
></A
>SET SERVEROUTPUT ON in SQL*Plus. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> Placed an exception section with a WHEN OTHERS handler in the outer block of your code (usually some sort of test script) so that your output can be flushed to your terminal by SQL*Plus. </P
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13707-0"
></A
>When package state has been reinitialized in your session, DBMS_OUTPUT is reset to "not enabled." </P
><P
CLASS="para"
>Packages can be reset to their initial state with a call to DBMS_SESSION.RESET_PACKAGE. (See <A
CLASS="xref"
HREF="ch11_01.htm"
>Chapter 11, <CITE
CLASS="chapter"
>Managing Session Information</CITE
></A
>, for more information about this program.) You might call this procedure yourself, but that is unlikely. A more common scenario for resetting package states is when an error is raised in your session that <EM
CLASS="emphasis"
>causes</EM
> packages to be reset to their initial state. Here is the error for which you need to beware:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	ERROR at line 1:/*
	ORA-04068: existing state of packages has been discarded
	ORA-04061: existing state of package &quot;PKG.PROC&quot; has been invalidated
	ORA-04065: not executed, altered or dropped package &quot;PKG.PROC&quot;
	ORA-06508: PL/SQL: could not find program unit being called</PRE
></BLOCKQUOTE
></LI
></OL
><P
CLASS="para"
>If you get this error and simply continue with your testing, you may be surprised to find that you are not getting any output. If you remember that DBMS_OUTPUT relies on package variables for its settings, this makes perfect sense. So when you get the preceding error, you should immediately "re-enable" DBMS_OUTPUT with a command such as the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; set serveroutput on size 1000000 format wrapped</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I usually just re-execute my <I
CLASS="filename"
>login.sql</I
> script, since I may be initializing several different packages:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @login.sql</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When will you get this error? I have found that it occurs when I have multiple sessions connected to Oracle. Suppose that I am testing program A in session USER1. I run it and find a bug. I fix the bug and recompile program A in session USER2 (the owner of the code). When I try to execute program A from session USER1 again, it raises the ORA-04068 error. </P
><P
CLASS="para"
>If you do encounter this error, don't panic. Just reset your package variables and run the program again. It will now work fine; the error is simply the result of a quirk in Oracle's automatic <A
CLASS="indexterm"
NAME="ch06-idx-13710-0"
></A
>recompilation <A
CLASS="indexterm"
NAME="ch06-idx-13696-0"
></A
>feature.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-24586"
>6.1.6 DBMS_OUTPUT Examples</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13716-0"
></A
>This section contains several longer examples of DBMS_OUTPUT operations.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.6.1"
>6.1.6.1 Encapsulating DBMS_OUTPUT</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13718-0"
></A
>Sure, it was nice of Oracle Corporation to give us the DBMS_OUTPUT package. Without it, as users of PL/SQL 1.0 found, we are running blind when we execute our code. As is the case with many of the developer-oriented utilities from Oracle, however, the DBMS_OUTPUT package is not a polished and well-planned tool. It offers nothing more than the most basic functionality, and even then it is crippled in some important ways. When I started to use it in real life (or whatever you might call the rarified atmosphere of authoring a book on software development), I found DBMS_OUTPUT.PUT_LINE to be cumbersome and limiting in ways.</P
><P
CLASS="para"
>I hated having to type "DBMS_OUTPUT.PUT_LINE" whenever I simply wanted to display some information. That's a mouthful and a keyboardful. I felt insulted that they hadn't even taken the time to overload for Booleans, requiring me to write silly IF logic just to see the value of a Boolean variable or function. I also found myself growing incensed that DBMS_OUTPUT would actually raise a VALUE_ERROR exception if I tried to pass it a string with more than 255 characters. I had enough errors in my code without having to worry about DBMS_OUTPUT adding to my troubles.</P
><P
CLASS="para"
>I decided that all this anger and frustration was not good for me. I needed to move past this nonconstructive lashing out at Oracle. I needed, in short, to <EM
CLASS="emphasis"
>fix</EM
> my problem. So I did&nbsp;-- with a package of my own. I am not going to provide a comprehensive explanation of my replacement package, but you can read about it (there are actually two of them) in my other books as follows:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CITE
CLASS="citetitle"
>Oracle PL/SQL Programming</CITE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The Companion Disk section on "Package Examples" introduces you to the <A
CLASS="indexterm"
NAME="ch06-idx-13720-0"
></A
>do package, which contains the do.<A
CLASS="indexterm"
NAME="ch06-idx-13725-0"
></A
>pl procedure, a substitute for DBMS_OUTPUT.PUT_LINE. The <EM
CLASS="emphasis"
>do.sps</EM
> and <EM
CLASS="emphasis"
>do.spb</EM
> files in the book you are reading also contain the source code for this package.</P
></DD
><DT
CLASS="term"
><CITE
CLASS="citetitle"
>Advanced Oracle PL/SQL Programming with Packages</CITE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><CITE
CLASS="citetitle"
>Chapter 7, p: A Powerful Substitute for DMBS_OUTPUT</CITE
>, presents the <A
CLASS="indexterm"
NAME="ch06-idx-13737-0"
></A
>p package and the p.<A
CLASS="indexterm"
NAME="ch06-idx-13742-0"
></A
>l procedure (I told you I didn't like typing those long program names!), a component of the PL/Vision library.[<A
CLASS="footnote"
HREF="#ch06-pgfId-13741"
>2</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch06-pgfId-13741"
>[2]</A
> A version of PL/Vision is available through a free download from the <A
CLASS="systemitem.url"
HREF="../../../../../../../www.revealnet.com/"
>http://www.revealnet.com</A
> site.</P
></DIV
></BLOCKQUOTE
></DD
></DL
><P
CLASS="para"
>The following section shows you the basic elements involved in constructing an encapsulation around DBMS_OUTPUT.PUT_LINE, which compensates for many of its problems. You can pursue building one of these for yourself, but I would strongly suggest that you check out the PL/Vision p package. That will leave you more time to build your own application-specific code.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-1.6.2"
>6.1.6.2 Package specification for a DBMS_OUTPUT encapsulator</A
></H4
><P
CLASS="para"
>The absolute minimum you need for such an encapsulator package is an overloading of the "print" procedure for dates, strings, and numbers. Let's at least add Booleans to the mix in this prototype:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch06-idx-13743-0"
></A
>prt.spp */*
CREATE OR REPLACE PACKAGE prt
IS
   c_prefix CONSTANT CHAR(1) := '*';
   c_linelen CONSTANT INTEGER := 80;

   PROCEDURE ln (val IN VARCHAR2);
   PROCEDURE ln (val IN DATE);
   PROCEDURE ln (val IN NUMBER);
   PROCEDURE ln (val IN BOOLEAN);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The prefix constant is concatenated to the beginning of any string to be displayed to avoid the problem of truncated spaces and ignored lines in SQL*Plus. The line length constant is used when the string is longer than 255 bytes. Finally, each of the prt.ln procedures prints a different type of data.</P
><P
CLASS="para"
>A complete implementation of this package would allow you to change the line length and the prefix, specify a date format for conversion, and so on. Again, check out the p package of PL/Vision for such a package.</P
><P
CLASS="para"
>Here is the body of the <A
CLASS="indexterm"
NAME="ch06-idx-13744-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13744-1"
></A
>prt package:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch06-idx-15319-0"
></A
>prt.spp */*
CREATE OR REPLACE PACKAGE BODY prt
IS
   PROCEDURE <A
CLASS="indexterm"
NAME="ch06-idx-13745-0"
></A
>ln (val IN VARCHAR2)
   IS
   BEGIN
      IF LENGTH (val) &gt; 255
      THEN
         PLVprs.display_wrap (val, c_linelen);
      ELSE
         DBMS_OUTPUT.PUT_LINE (c_prefix || val);
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         DBMS_OUTPUT.ENABLE (1000000);
         DBMS_OUTPUT.PUT_LINE (c_prefix || val);
   END;
   PROCEDURE ln (val IN DATE) 
   IS
   BEGIN
      ln (TO_CHAR (val));
   END;
   PROCEDURE ln (val IN NUMBER) 
   IS
   BEGIN
      ln (TO_CHAR (val));
   END;
   PROCEDURE ln (val IN BOOLEAN) 
   IS
   BEGIN
      IF val
      THEN
         ln ('TRUE');
      ELSIF NOT val
      THEN
         ln ('FALSE');
      ELSE
         ln ('NULL BOOLEAN');
      END IF;
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are a few things to notice about the package implementation:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The string version of prt.ln is the "core" print procedure. The other three programs all call that one, after they have formatted the string appropriately.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The Boolean version of prt.ln simply performs the same IF logic you would have to write if you were using DBMS_OUTPUT. By hiding it inside the prt procedure, though, nobody else has to write that kind of code again. Plus, it handles NULL values.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The string version of prt.ln contains all the complex logic. For long strings, it relies on the PL/Vision display wrap procedure of the PLVprs package.[<A
CLASS="footnote"
HREF="#ch06-pgfId-12899"
>3</A
>] For strings with fewer than 256 characters, it calls DBMS_OUTPUT.PUT_LINE.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch06-pgfId-12899"
>[3]</A
> Available through a free download from the <A
CLASS="systemitem.url"
HREF="../../../../../../../www.revealnet.com/"
>http://www.revealnet.com</A
> site.</P
></DIV
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>As an added feature, if the attempt to display using DBMS_OUTPUT.PUT_LINE raises an exception, prt.ln assumes that the problem might be that the buffer is too small. So it increases the buffer to the maximum possible value and then tries again. I believe that it is very important for developers to make the extra effort to increase the usefulness of our code.</P
></LI
></UL
><P
CLASS="para"
>The prt package should give you a solid idea about the way to encapsulate a built-in package inside a package <A
CLASS="indexterm"
NAME="ch06-idx-13747-0"
></A
>of <A
CLASS="indexterm"
NAME="ch06-idx-13719-0"
></A
>your <A
CLASS="indexterm"
NAME="ch06-idx-13717-0"
></A
>own <A
CLASS="indexterm"
NAME="ch06-idx-13618-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13618-1"
></A
>construction.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_07.htm#ch05-SECT-7.5.1"
TITLE="5.7 Oracle AQ Examples"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.7 Oracle AQ Examples"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_02.htm#ch06-SECT-2.1.1"
TITLE="6.2 UTL_FILE: Reading and Writing Server-side Files"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.2 UTL_FILE: Reading and Writing Server-side Files"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.7 Oracle AQ Examples</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.2 UTL_FILE: Reading and Writing Server-side Files</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
