<HTML
><HEAD
><TITLE
>[Chapter 13] 13.2 Job Queue Architecture</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:59:17Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch13_01.htm"
TITLE="13. Job Scheduling in the Database"><LINK
REL="prev"
HREF="ch13_01.htm"
TITLE="13.1 Getting Started with DBMS_ JOB"><LINK
REL="next"
HREF="ch13_03.htm#ch13-SECT-3.2"
TITLE="13.3 Tips on Using DBMS_JOB"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch13_01.htm"
TITLE="13.1 Getting Started with DBMS_ JOB"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 13.1 Getting Started with DBMS_ JOB"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch13_01.htm"
TITLE="13. Job Scheduling in the Database"
>Chapter 13<BR>Job Scheduling in the Database</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch13_03.htm#ch13-SECT-3.2"
TITLE="13.3 Tips on Using DBMS_JOB"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 13.3 Tips on Using DBMS_JOB"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch13-29769"
>13.2 Job Queue Architecture</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8438-0"
></A
>job queue is really a subsystem within an Oracle database, which uses dedicated background processes and catalog tables to execute user PL/SQL procedures automatically without user intervention. It is useful to get a good conceptual understanding of the job queue, because some of the behavior of this queue is not obvious. Figure <A
CLASS="xref"
HREF="ch13_02.htm#ch13-SECT-2.6.1"
>Figure 13.1</A
> shows a schematic of the job queue architecture.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch13-40105"
>Figure 13.1: . Schematic of job queue architecture</A
></H4
><IMG
CLASS="graphic"
SRC="figs/obip.1301.gif"
ALT="Figure 13.1"><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-SECT-2.1"
>13.2.1 INIT.ORA Parameters and Background Processes</A
></H3
><P
CLASS="para"
>These three <A
CLASS="indexterm"
NAME="ch13-idx-8440-0"
></A
>INIT.ORA parameters are instrumental in controlling the job queue:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>JOB_QUEUE_PROCESSES</TD
></TR
><TR
><TD
CLASS="member"
>JOB_QUEUE_INTERVAL</TD
></TR
><TR
><TD
CLASS="member"
>JOB_QUEUE_KEEP_CONNECTIONS</TD
></TR
></TABLE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.1.1"
>13.2.1.1 <A
CLASS="indexterm"
NAME="ch13-idx-8444-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8444-1"
></A
>JOB_QUEUE_PROCESSES </A
></H4
><P
CLASS="para"
>The job queue (or <A
CLASS="indexterm"
NAME="ch13-idx-8445-0"
></A
>SNP[<A
CLASS="footnote"
HREF="#ch13-pgfId-5860"
>1</A
>]) background processes are started when the Oracle instance is started. There are as many SNP processes started as specified in the INIT.ORA parameter JOB_QUEUE_PROCESSES. The range of valid values is from 0 to 36, so there can be a maximum of 36 SNP processes per Oracle instance. Under most operating systems, the characters SNP will appear as part of the process name. For example, under UNIX, an Oracle instance called DEV with three job queue processes would show the following process names:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch13-pgfId-5860"
>[1]</A
> The SNP acronym results from the fact that these special background processes were originally developed to refresh Oracle snapshots.</P
></DIV
></BLOCKQUOTE
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>ora_DEV_snp0</TD
></TR
><TR
><TD
CLASS="member"
>ora_DEV_snp1</TD
></TR
><TR
><TD
CLASS="member"
>ora_DEV_snp2</TD
></TR
></TABLE
><P
CLASS="para"
>One significant difference between the SNP background processes and other Oracle background processes is that killing an SNP process will not crash the instance. While you're not likely to want to do this very often, this behavior is useful to know in case a job queue process "runs away" and consumes excessive resources. When an SNP process is killed or fails on its own, Oracle automatically starts a new one to replace it.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.1.2"
>13.2.1.2 <A
CLASS="indexterm"
NAME="ch13-idx-8446-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8446-1"
></A
>JOB_QUEUE_INTERVAL</A
></H4
><P
CLASS="para"
>The job queue processes "wake up" periodically and check the job queue catalog to see if any jobs are due to execute. The INIT.ORA parameter JOB_QUEUE_INTERVAL controls how long the SNP processes "sleep" (in seconds) between catalog checks. Setting the interval too low can cause unnecessary overhead as SNP processes constantly check the catalog. Setting the interval too high can keep jobs from executing at the expected time if an SNP process does not awaken promptly enough. The proper balance will depend on the specific mix of jobs in a given environment. For most purposes, the default setting of 60 seconds is adequate.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.1.3"
>13.2.1.3 <A
CLASS="indexterm"
NAME="ch13-idx-9912-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-9912-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-9912-2"
></A
>JOB_QUEUE_KEEP_CONNECTIONS</A
></H4
><P
CLASS="para"
>The third INIT.ORA parameter that supposedly affects the behavior of the SNP processes is JOB_QUEUE_KEEP_CONNECTIONS. This parameter has been made obsolete in Oracle8i. In fact, it apparently never actually had any effect under previous releases, although it has been documented as having various effects. Some sources say that it controlled the database sessions held by the SNP background processes; others say that it controlled the sessions in remote databases for jobs using database links. </P
><P
CLASS="para"
>Although setting this parameter appears to do no harm, it is best to leave it alone.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-SECT-2.2"
>13.2.2 Job Execution and the Job Execution Environment</A
></H3
><P
CLASS="para"
>When an SNP process wakes up, it looks in the catalog to see if the current date exceeds the next execution date for any jobs in the queue. If a job is due to execute, the SNP process will dynamically do the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Become a database session with the username of the job's owner </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Alter session <A
CLASS="indexterm"
NAME="ch13-idx-8448-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8448-1"
></A
>NLS (National Language Support) settings to match those in place when the job was submitted or last modified</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Calculate the next execution date by applying the interval date expression to SYSDATE</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Execute the PL/SQL job definition</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If execution succeeds, upate next_date for the job with the previously calculated next execution date; otherwise, increment the number of failures</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Repeat if another job is due to run or sleep for JOB_QUEUE_INTERVAL seconds</P
></LI
></UL
><P
CLASS="para"
>In the first two steps, the SNP process creates a job execution environment that mimics that of a real user session that is executing the job definition's PL/SQL. This includes setting the following NLS settings:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>NLS_LANGUAGE</TD
></TR
><TR
><TD
CLASS="member"
>NLS_TERRITORY</TD
></TR
><TR
><TD
CLASS="member"
>NLS_CURRENCY</TD
></TR
><TR
><TD
CLASS="member"
>NLS_ISO_CURRENCY</TD
></TR
><TR
><TD
CLASS="member"
>NLS_NUMERIC_CHARACTERS</TD
></TR
><TR
><TD
CLASS="member"
>NLS_DATE_FORMAT</TD
></TR
><TR
><TD
CLASS="member"
>NLS_DATE_LANGUAGE</TD
></TR
><TR
><TD
CLASS="member"
>NLS_SORT</TD
></TR
></TABLE
><P
CLASS="para"
>In <A
CLASS="indexterm"
NAME="ch13-idx-8449-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8449-1"
></A
>Trusted Oracle databases, the session also sets the session label and high/low clearances.</P
><P
CLASS="para"
>The execution environment does not exactly mimic a user session, and this has some consequences worth noting. First, any nondefault <A
CLASS="indexterm"
NAME="ch13-idx-8450-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8450-1"
></A
>roles that were enabled when the job was submitted will not be enabled in the job execution environment. Therefore, jobs that rely on privileges obtained through nondefault roles should not be submitted, and modification of user default roles can compromise the future execution of existing jobs. Also, any <A
CLASS="indexterm"
NAME="ch13-idx-9853-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-9853-1"
></A
>database links used in the job definition itself, or the procedures executed by it, must be fully qualified with a remote username and password. The SNP process is not able to initiate a remote session without an explicit password. Apparently, it does not assume the local user's password as part of the execution environment session settings. </P
><P
CLASS="para"
>When job execution fails, the SNP processes attempts to rerun the job one minute later. If this run fails, another attempt is made in two minutes and another in four minutes. The job queue doubles the retry interval until it exceeds the normal execution interval, which is then used. After 16 consecutive failures, the job is flagged as broken and will not be re-executed by the job queue without user intervention.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-SECT-2.3"
>13.2.3 Miscellaneous Notes</A
></H3
><P
CLASS="para"
>The Oracle export and import utilities preserve <A
CLASS="indexterm"
NAME="ch13-idx-8452-0"
></A
>job numbers. Therefore, when you are importing into a database with jobs in the job queue, job number conflicts are possible. The same consideration applies when using DBMS_JOB.USER_EXPORT to transfer jobs from one database to another.</P
><P
CLASS="para"
>The job queue is not designed to function well under <A
CLASS="indexterm"
NAME="ch13-idx-8453-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8453-1"
></A
>Oracle Parallel Server configurations. In particular, here are two significant limitations:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
> Jobs cannot be specified to run in a specific Oracle instance.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The SYS.JOB$ catalog table is not partitioned by instance and will be subject to "pinging" by job queue processes from different instances.</P
></LI
></UL
><P
CLASS="para"
>The workaround to these problems is to only run the job queue in a single instance of an OPS environment. This is done by setting JOB_QUEUE_PROCESSES to zero in all but one of the Oracle <A
CLASS="indexterm"
NAME="ch13-idx-8439-0"
></A
>instances.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-SECT-2.4"
>13.2.4 DBMS_JOB Interface</A
></H3
><P
CLASS="para"
>This section describes the programs available in the DBMS_JOB package. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-40355"
>13.2.5 Submitting Jobs to the Job Queue</A
></H3
><P
CLASS="para"
>Use the SUBMIT and ISUBMIT procedures to submit jobs to the job queue.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.5.1"
>13.2.5.1 The DBMS_JOB.SUBMIT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8454-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8454-1"
></A
>SUBMIT procedure submits a new job to the job queue. The <A
CLASS="indexterm"
NAME="ch13-idx-8466-0"
></A
>job number is obtained from the sequence SYS.JOBSEQ and returned as an OUT parameter. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.SUBMIT
   (job OUT BINARY_INTEGER
   ,what IN VARCHAR2
   ,next_date IN DATE DEFAULT SYSDATE
   ,interval IN VARCHAR2 DEFAULT 'null'
   ,no_parse IN BOOLEAN DEFAULT FALSE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>job</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique identifier of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>what</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PL/SQL code to execute as a job </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>next_date</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Next execution date of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>interval</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Date expression to compute next execution date of job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>no_parse</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Flag indicating whether to parse job PL/SQL at time of submission (FALSE) or execution (TRUE)</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-25944"
>13.2.5.1.1 Exceptions.</A
></H4
><P
CLASS="para"
>The program does not raise any package exceptions. The interval date expression must evaluate to a future date or the following Oracle exception will be raised:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-23420</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Interval must evaluate to a time in the future.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-25952"
>13.2.5.1.2 Example.</A
></H4
><P
CLASS="para"
>This SQL*Plus script submits a job that uses DBMS_DDL.ANALYZE_OBJECT to analyze a particular table every day at midnight: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>var jobno NUMBER

BEGIN
   DBMS_JOB.SUBMIT
      (job =&gt; :jobno
      ,what =&gt; 'DBMS_DDL.ANALYZE_OBJECT(''TABLE'',''LOAD1'',''TENK'',
                   ''ESTIMATE'',null,estimate_percent=&gt;50);'
      ,next_date =&gt; TRUNC(SYSDATE+1)
      ,interval =&gt; 'TRUNC(SYSDATE+1)'
      );
END;
/
print jobno</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The what parameter must be enclosed in single quotes and the PL/SQL call terminated with a semicolon. To embed literal strings in the PL/SQL call, use two single quotes around the literal.</P
><P
CLASS="para"
>The no_parse parameter controls when the job's PL/SQL definition is actually parsed. The default value of FALSE specifies that the PL/SQL is parsed immediately when the job is submitted. Alternatively, if you specify TRUE, parsing can be deferred until the first execution of the job. This allows jobs to be submitted into the queue for future execution where objects necessary for execution (tables, packages, etc.) are not in place at the time of submission.</P
><BLOCKQUOTE
CLASS="tip"
><P
CLASS="para"
><STRONG
>TIP:</STRONG
> <A
CLASS="indexterm"
NAME="ch13-idx-9876-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-9876-1"
></A
>On some platforms and versions of Oracle, a COMMIT is required for the job to be picked up by the job queue for execution. If submitted jobs do not seem to be executing at all, this may be the cause. The workaround for this problem is to always COMMIT immediately after calling SUBMIT.</P
><P
CLASS="para"
>To execute a job one time only, pass a NULL value for the interval <A
CLASS="indexterm"
NAME="ch13-idx-9874-0"
></A
>parameter.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.5.2"
>13.2.5.2 The DBMS_JOB.ISUBMIT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8462-0"
></A
>ISUBMIT procedure submits a new job to the job queue with the specified <A
CLASS="indexterm"
NAME="ch13-idx-8467-0"
></A
>job number. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.ISUBMIT
   (job IN BINARY_INTEGER
   ,what IN VARCHAR2
   ,next_date IN VARCHAR2
   ,interval IN VARCHAR2 DEFAULT 'null'
   ,no_parse IN BOOLEAN DEFAULT FALSE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>job</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique identifier of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>what</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PL/SQL code to execute as a job </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>next_date</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Next execution date of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>interval</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Date expression to compute next execution date of job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>no_parse</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Flag indicating whether to parse job PL/SQL at time of submission (FALSE) or execution (TRUE)</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26013"
>13.2.5.2.1 Exceptions</A
></H4
><P
CLASS="para"
>The program does not raise any packaged exceptions. The interval date expression must evaluate to a future date or the following Oracle exception will be raised:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-23420</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Interval must evaluate to a time in the future.</P
></DD
></DL
><P
CLASS="para"
>The catalog table that records job queue entries is protected by a unique constraint on the job number. Therefore, using the ISUBMIT procedure to submit a job number that already exists results in the following error:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-00001 </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Unique constraint (SYS.I_JOB_JOB) violated.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26027"
>13.2.5.2.2 Example</A
></H4
><P
CLASS="para"
>The following example submits three jobs to the job queue, numbered 1, 2, and 3. Job 1 passes a string and number into procedure my_job1, runs it in one hour, and executes it every day thereafter. Job 2 passes a date into procedure my_job2, executes for the first time tomorrow, and execute it every 10 minutes thereafter. Job 3 is a PL/SQL block that does nothing, executes immediately, and will be removed from the queue automatically.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_JOB.ISUBMIT
      (job  =&gt; 1
      ,what =&gt; 'my_job1(''string_parm_value'',120);'
      ,next_date =&gt; SYSDATE + 1/24
      ,interval =&gt; 'SYSDATE +1');

   DBMS_JOB.ISUBMIT
      (2, 'my_job2(date_IN=&gt;SYSDATE);'
        ,SYSDATE+1,'SYSDATE+10/1440');

   DBMS_JOB.ISUBMIT(3,'BEGIN null; END;',SYSDATE,null);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The ISUBMIT procedure allows the calling user or application to decide the <A
CLASS="indexterm"
NAME="ch13-idx-8468-0"
></A
>job identification number. Collisions in job numbers will result in the unique constraint violation noted earlier. Therefore, it is probably better not to embed fixed job numbers into applications (as this will increase the chances for collisions) and to use SUBMIT instead of ISUBMIT. If specific job numbering is required, then you can minimize job number collisions by pushing the SYS.JOBSEQ sequence out to a number greater than those used in calls to ISUBMIT. This can be accomplished by consuming sequence numbers as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT SYS.JOBSEQ.NEXTVAL
  FROM dictionary
 WHERE rownum &lt; 101;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>After issuing the previous command, DBMS_JOB.SUBMIT will always return job numbers higher than 100. Note that in this command, the dictionary view is not special, but is used because it is publicly accessible and contains more than 100 rows. You can substitute any table or view accessible to the user.</P
><BLOCKQUOTE
CLASS="warning"
><P
CLASS="para"
><STRONG
>WARNING:</STRONG
> <A
CLASS="indexterm"
NAME="ch13-idx-8469-0"
></A
>When you are using the ISUBMIT procedure, a subtle problem can arise from the fact that next_date has datatype VARCHAR2 instead of DATE (as in SUBMIT).  When DATE values are assigned to next_date in calls to ISUBMIT, an implicit conversion to VARCHAR2 is done using the session's current NLS_DATE_FORMAT as the date mask.  This can result in unexpected truncation of next_date. For instance, if the session NLS_DATE_FORMAT is `YY-MM-DD', dates assigned to next_date will be truncated to 12:00 a.m. To avoid this problem, either make sure that the session NLS_DATE_FORMAT includes all date components or supply next_date as a fully specified VARCHAR2. <A
CLASS="indexterm"
NAME="ch13-idx-8464-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8464-1"
></A
></P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-40268"
>13.2.6 Modifying Job Characteristics</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-8470-0"
></A
>This section describes the procedures you use to modify job characteristics: CHANGE, INTERVAL, NEXT_DATE, and WHAT.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.6.1"
>13.2.6.1 The DBMS_JOB.CHANGE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8474-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8474-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8474-2"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8474-3"
></A
>CHANGE procedure alters one or more of the user-definable parameters of a job. When a null value is passed for any of these parameters (what, next_date, or interval) the current setting is not modified. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.CHANGE
   (job IN BINARY_INTEGER
   ,what IN VARCHAR2
   ,next_date IN DATE
   ,interval IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>job</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique identifier of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>what</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PL/SQL code to execute as a job </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>next_date</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Next execution date of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>interval</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Date expression to compute next execution date of job</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26100"
>13.2.6.1.1 Exceptions</A
></H4
><P
CLASS="para"
>The program does not raise any packaged exceptions. The interval date function must evaluate to a future date or the following Oracle exception will be raised:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-23420</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Interval must evaluate to a time in the future.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26108"
>13.2.6.1.2 Restrictions</A
></H4
><P
CLASS="para"
>The CHANGE procedure can be executed only for jobs owned by the username to which the session is connected. These jobs are visible in the dictionary view USER_JOBS. The USER_JOBS dictionary view is discussed in the <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3, "Tips on Using DBMS_JOB"</A
>" section.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26112"
>13.2.6.1.3 Example</A
></H4
><P
CLASS="para"
>The execution schedule of job 100 can be changed to next execute tomorrow at 6:00 a.m. and every two hours after that, as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_JOB.CHANGE(100,null,TRUNC(SYSDATE+1)+6/24,'SYSDATE+2/24');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When the what parameter is changed to modify the actual job to execute, the user's current session <A
CLASS="indexterm"
NAME="ch13-idx-8505-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8505-1"
></A
>NLS settings are also recorded and become part of the job's <A
CLASS="indexterm"
NAME="ch13-idx-8506-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8506-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8506-2"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8506-3"
></A
>execution environment.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.6.2"
>13.2.6.2 The DBMS_JOB.INTERVAL procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8479-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8479-1"
></A
>INTERVAL procedure changes the date expression, which is used to determine the next execution date of a job. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.INTERVAL
   (job IN BINARY_INTEGER
   ,interval IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>job</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique identifier of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>interval</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Date expression to compute next execution date of job</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26159"
>13.2.6.2.1 Exceptions</A
></H4
><P
CLASS="para"
>The program does not raise any package exceptions. The interval date expression must evaluate to a future date or the following Oracle exception will be raised:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-23420</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Interval must evaluate to a time in the future.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26167"
>13.2.6.2.2 Restrictions</A
></H4
><P
CLASS="para"
>The INTERVAL procedure can be executed only for jobs owned by the username to which the session is connected. These jobs are visible in the dictionary view USER_JOBS. The USER_JOBS dictionary view is discussed in the <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3</A
>" section.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26171"
>13.2.6.2.3 Example</A
></H4
><P
CLASS="para"
>The following SQL*Plus command will modify job 100 to execute every day at 6:00 a.m.:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute DBMS_JOB.INTERVAL(100, 'TRUNC(SYSDATE+1)+6/24');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The date expression must be specified as a string literal or a VARCHAR2 variable containing a string literal. Literals that evaluate to PL/SQL functions are accepted by DBMS_JOB, but have been observed to cause erratic job execution behavior.</P
><P
CLASS="para"
>A job can be removed automatically from the job queue after its next execution by passing NULL for the interval <A
CLASS="indexterm"
NAME="ch13-idx-8481-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8481-1"
></A
>parameter.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.6.3"
>13.2.6.3 The DBMS_JOB.NEXT_DATE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8483-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8483-1"
></A
>NEXT_DATE procedure changes the job's next scheduled date of execution. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.NEXT_DATE
   (job IN BINARY_INTEGER
   ,next_date IN DATE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>job</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique identifier of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>next_date</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Next execution date of the job</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The program does not raise any named exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26212"
>13.2.6.3.1 Restrictions</A
></H4
><P
CLASS="para"
>The NEXT_DATE procedure can be executed only for jobs owned by the username to which the session is connected. These jobs are visible in the dictionary view USER_JOBS. The USER_JOBS dictionary view is discussed in the <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3</A
>" section.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26216"
>13.2.6.3.2 Example</A
></H4
><P
CLASS="para"
>This example shows a SQL*Plus example of how to schedule the next execution of job 100 for next Monday:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute DBMS_JOB.NEXT_DATE(100, NEXT_DAY(SYSDATE,'MONDAY'));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When a NULL value is passed for the next_date parameter, the next execution date for the job is set to January 1, 4000. This effectively keeps the job from being executed without removing it from the job <A
CLASS="indexterm"
NAME="ch13-idx-8485-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8485-1"
></A
>queue.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.6.4"
>13.2.6.4 The DBMS_JOB.WHAT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8487-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8487-1"
></A
>WHAT procedure changes the PL/SQL call that comprises the job's PL/SQL definition. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.WHAT
   (job IN BINARY_INTEGER
   ,what IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>job</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique identifier of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>what</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PL/SQL code to execute as a job </P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26255"
>13.2.6.4.1 Restrictions</A
></H4
><P
CLASS="para"
>The WHAT procedure can be executed only for jobs owned by the username to which the session is connected. These jobs are visible in the dictionary view USER_JOBS. The USER_JOBS dictionary view is discussed in the <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3</A
>" section.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26259"
>13.2.6.4.2 Example</A
></H4
><P
CLASS="para"
>In this example, job 100 is modified to execute a procedure called my_package.proc1. When the job is run by the job queue, it will run in a session that has NLS_DATE_FORMAT set as in the ALTER SESSION command.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT='YYYY:MM:DD:HH24:MI:SS';

SQL&gt; execute dbms_job.what(100,'my_package.proc1;');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When the what parameter is changed to modify the actual job to execute, the user's current session <A
CLASS="indexterm"
NAME="ch13-idx-8488-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8488-1"
></A
>NLS settings are also recorded and become part of the job's execution environment.</P
><P
CLASS="para"
>The what parameter must be enclosed in single quotes and the PL/SQL call must be terminated with a semicolon. To embed literal strings in the PL/SQL call, use two single quotes around the <A
CLASS="indexterm"
NAME="ch13-idx-8472-0"
></A
>literal.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-19048"
>13.2.7 Removing Jobs and Changing Job Execution Status</A
></H3
><P
CLASS="para"
>The REMOVE, BROKEN, and RUN procedures let you remove jobs from the job queue and change the execution status of jobs.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.7.1"
>13.2.7.1 The DBMS_JOB.REMOVE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8514-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8514-1"
></A
>REMOVE procedure removes an existing job from the job queue. If the job is currently executing, it will run to normal completion, but will not be rescheduled. The header for this procedure is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.REMOVE
   (job IN BINARY_INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where job is the unique identifier of the job. This program does not raise any package exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26285"
>13.2.7.1.1 Restrictions</A
></H4
><P
CLASS="para"
>The REMOVE procedure can be executed only for jobs owned by the username to which the session is connected. These jobs are visible in the dictionary view USER_JOBS. The USER_JOBS dictionary view is discussed in the <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3</A
>" section.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26289"
>13.2.7.1.2 Example</A
></H4
><P
CLASS="para"
>To remove job number 100 from the job queue in SQL*Plus, specify the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute DBMS_JOB.REMOVE(100);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When REMOVE is executed for a job that is currently executing, the job is removed from the job queue, but the current execution is allowed to complete. Terminating a running job and removing it from the job queue is described in the <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3</A
>" section later in this chapter.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.7.2"
>13.2.7.2 The DBMS_JOB.BROKEN procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8515-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8515-1"
></A
>BROKEN procedure is used to set or unset the broken flag for a job. Jobs flagged as broken are not automatically re-executed. Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.BROKEN
   (job IN BINARY_INTEGER
   ,broken IN BOOLEAN
   ,next_date IN DATE DEFAULT SYSDATE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>job</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique identifier of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>broken</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Flag indicating job is broken (TRUE) or not broken (FALSE)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>next_date</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Next execution date of the job</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The program does not raise any package exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26333"
>13.2.7.2.1 Restrictions</A
></H4
><P
CLASS="para"
>The BROKEN procedure can be executed only for jobs owned by the username to which the session is connected. These jobs are visible in the dictionary view USER_JOBS. The USER_JOBS dictionary view is discussed in the <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3</A
>" section.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26337"
>13.2.7.2.2 Example</A
></H4
><P
CLASS="para"
>All jobs owned by the current user are set to broken by this PL/SQL block:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   FOR job_rec IN (SELECT job FROM user_jobs) 
   LOOP
      DBMS_JOB.BROKEN(job_rec.job,TRUE);
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Jobs are marked as broken by passing TRUE for the broken parameter. In this case, the next execution for the job date is automatically set to January 1, 4000, regardless of the value of the next_date parameter passed. Although it looks strange, this is not a problem and is merely another safeguard preventing the job queue processes from executing broken jobs.</P
><P
CLASS="para"
>When marking jobs as not broken by passing the value FALSE for the broken parameter, the value of next_date becomes the next execution date for the job. Since next_date has a default value of SYSDATE, marking a job as unbroken without specifying next_date explicitly indicates that the job should execute immediately. Be careful to pass an explicit value for next_date if immediate execution is not the desired behavior. Note also that DBMS_JOB.BROKEN (job,FALSE) will always modify the next execution date of the job, regardless of whether it was marked <A
CLASS="indexterm"
NAME="ch13-idx-8517-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8517-1"
></A
>broken. </P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.7.3"
>13.2.7.3 The DBMS_JOB.RUN procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8519-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8519-1"
></A
>RUN procedure immediately executes the job in the current session. The header for this program follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.RUN
   (job IN BINARY_INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The job parameter is the unique identifier for the job. The program does not raise any package exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26355"
>13.2.7.3.1 Restrictions</A
></H4
><P
CLASS="para"
>The RUN procedure can be executed only for jobs owned by the username to which the session is connected. These jobs are visible in the dictionary view USER_JOBS. The USER_JOBS dictionary view is discussed in the <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3</A
>" section.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26359"
>13.2.7.3.2 Example</A
></H4
><P
CLASS="para"
>To run job number 100 immediately in the current session, specify the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute DBMS_JOB.RUN(100);</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-8523-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8523-1"
></A
>The RUN procedure performs an implicit COMMIT in the current session. It runs the job with the current session's settings and privileges as the execution environment. Be aware that these could be different from the execution environment settings specified for the job and used by the job queue when it runs the job. This could cause unexpected results, so it is best to execute RUN from a session with the same environment as the job.</P
><P
CLASS="para"
>Also, issuing the RUN procedure computes the next execution date for the job using the current SYSDATE as the seed value. This could throw off the execution schedule of some jobs, depending on how the interval is defined. See <A
CLASS="xref"
HREF="ch13_03.htm#ch13-SECT-3.2"
>Section 13.3</A
>" for a discussion of job intervals and date <A
CLASS="indexterm"
NAME="ch13-idx-8521-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8521-1"
></A
>arithmetic.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-34039"
>13.2.8 Transferring Jobs</A
></H3
><P
CLASS="para"
>The USER_EXPORT procedure lets you export jobs in the job queue to a file for re-creation or transfer to another database.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch13-SECT-2.8.1"
>13.2.8.1 The DBMS_JOB.USER_EXPORT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch13-idx-8524-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8524-1"
></A
>USER_EXPORT procedure produces a character string that can be used to re-create an existing job in the job queue. The string contains a call to the ISUBMIT procedure for the job, which specifies the current values for the job definition parameters. Here's the header for the program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_JOB.USER_EXPORT
   (job IN BINARY_INTEGER
   ,mycall IN OUT VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>job</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique identifier of the job</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>mycall</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>String containing call to the ISUBMIT procedure to re-create job</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The program does not raise any package exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-26409"
>13.2.8.1.1 Example.</A
></H4
><P
CLASS="para"
>This SQL*Plus script shows that current settings for the job definition parameters are placed into the mycall parameter of USER_EXPORT:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch13-idx-9762-0"
></A
>job1.sql */*
set array 1
var job number
var jobstring VARCHAR2(2000)
col jobstring format a50 word_wrap
col what format a25 word_wrap
col interval format a20

ALTER SESSION SET NLS_DATE_FORMAT='YYYY:MM:DD:HH24:MI:SS';

BEGIN
   /* submit no-op job to execute every 30 seconds */
   DBMS_JOB.SUBMIT(:job,'begin null;end;',SYSDATE,'SYSDATE+1/2880');

   /* commit to make sure the submit &quot;takes&quot; */
   COMMIT;
   /* sleep for two minutes to let job execute a few times */
   DBMS_LOCK.SLEEP(120);
END;
/

SELECT job,what,next_date,interval
  FROM dba_jobs
 WHERE job = :job;

BEGIN
   /* export the job */
   DBMS_JOB.USER_EXPORT(:job,:jobstring);
END;
/

print jobstring</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following output was generated by the script. Notice that the current value of NEXT_DATE (as shown by querying DBA_JOBS) is extracted and placed into the string value returned in the mycall parameter as the value for next_date in the call to <A
CLASS="indexterm"
NAME="ch13-idx-8526-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-8526-1"
></A
>ISUBMIT.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Session altered.


PL/SQL procedure successfully completed.


   JOB WHAT                      NEXT_DATE           INTERVAL
------ ------------------------- ------------------- --------------
   175 begin null;end;           1997:11:16:16:22:59 SYSDATE+1/2880


PL/SQL procedure successfully completed.


JOBSTRING
-------------------------------------------------- 
dbms_job.isubmit(job=&gt;175,what=&gt;'begin
null;end;',next_date=&gt;to_date('1997-11-16:16:22:59
','YYYY-MM-DD:HH24:MI:SS'),interval=&gt;'SYSDATE+1/28
80',no_parse=&gt;TRUE);</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch13_01.htm"
TITLE="13.1 Getting Started with DBMS_ JOB"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 13.1 Getting Started with DBMS_ JOB"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch13_03.htm#ch13-SECT-3.2"
TITLE="13.3 Tips on Using DBMS_JOB"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 13.3 Tips on Using DBMS_JOB"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>13.1 Getting Started with DBMS_ JOB</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>13.3 Tips on Using DBMS_JOB</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
