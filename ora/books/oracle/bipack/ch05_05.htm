<HTML
><HEAD
><TITLE
>[Chapter 5] 5.5 DBMS_AQADM: Performing AQ  Administrative Tasks (Oracle8 only)</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:52:47Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch05_01.htm"
TITLE="5. Oracle Advanced Queuing"><LINK
REL="prev"
HREF="ch05_04.htm#ch05-SECT-4.1.1"
TITLE="5.4 DBMS_AQ: Interfacing to Oracle AQ (Oracle8 only)"><LINK
REL="next"
HREF="ch05_06.htm#ch05-SECT-6.2.3"
TITLE="5.6 Oracle AQ Database Objects"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_04.htm#ch05-SECT-4.1.1"
TITLE="5.4 DBMS_AQ: Interfacing to Oracle AQ (Oracle8 only)"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.4 DBMS_AQ: Interfacing to Oracle AQ (Oracle8 only)"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch05_01.htm"
TITLE="5. Oracle Advanced Queuing"
>Chapter 5<BR>Oracle Advanced Queuing</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_06.htm#ch05-SECT-6.2.3"
TITLE="5.6 Oracle AQ Database Objects"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.6 Oracle AQ Database Objects"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch05-16574"
>5.5 DBMS_AQADM: Performing AQ  Administrative Tasks (Oracle8 only)</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-18723-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-18723-1"
></A
>Before AQ users can enqueue and dequeue, they must have queues with which to work. The AQ administrator must create queue tables and queues within those tables and then start the queues. Additional administrative tasks include stopping queues and removing queue tables, managing lists of subscribers, and starting and stopping the Queue Monitor. </P
><P
CLASS="para"
>The DBMS_AQADM package provides an interface to the administrative tasks of Oracle AQ. The DBMS_AQADM programs are listed in <A
CLASS="xref"
HREF="ch05_05.htm"
>Table 5.2</A
>. In order to use these procedures, a DBMS_AQADM user must have been granted the <A
CLASS="indexterm"
NAME="ch05-idx-16078-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16078-1"
></A
>role AQ_ADMINISTRATOR_ROLE from the SYS account.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> None of the DBMS_AQADM programs may be used inside SQL, directly or indirectly. The reason for this restriction is that many of these programs perform a COMMIT (unless you have set the auto_commit parameter to FALSE).</P
></BLOCKQUOTE
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch05-35772"
>Table 5.2: DBMS_AQADM <A
CLASS="indexterm"
NAME="ch05-idx-19144-0"
></A
>Programs </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16079-0"
></A
>ADD_SUBSCRIBER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Adds a subscriber to a queue.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16080-0"
></A
>ALTER_QUEUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Alters limited set of properties of an existing queue.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16081-0"
></A
>CREATE_QUEUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Creates a queue within the specified queue table.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16082-0"
></A
>CREATE_QUEUE_TABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Creates a queue table in which queues can be defined.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16083-0"
></A
>DROP_QUEUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Drops an existing queue table.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16084-0"
></A
>DROP_QUEUE_TABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Drops an existing queue from a queue table.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16085-0"
></A
>GRANT_TYPE_ACCESS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Grants access to multiple consumer tasks.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16086-0"
></A
>QUEUE_SUBSCRIBERS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Retrieves the list of subscribers associated with a queue.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16087-0"
></A
>REMOVE_SUBSCRIBER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Removes a subscriber from a queue.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16088-0"
></A
>SCHEDULE_PROPAGATION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Schedules propagation of messages from a source queue to a destination queue (either in the same or a remote database).</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16089-0"
></A
>START_QUEUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Enables the queue (i.e., permits enqueue and/or dequeue operations).</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16090-0"
></A
>START_TIME_MANAGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Starts the Queue Monitor process.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16091-0"
></A
>STOP_QUEUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Disables the queue for enqueuing, dequeuing, or both.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16092-0"
></A
>STOP_TIME_MANAGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Stops the Queue Monitor process.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16093-0"
></A
>UNSCHEDULE_PROPAGATION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unschedules the propagation of messages from a source queue to a destination queue.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16094-0"
></A
>VERIFY_QUEUE_TYPES</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Determines whether two different queues have the same payload type. You can perform this verification for two local queues or for a local and a remote <A
CLASS="indexterm"
NAME="ch05-idx-19145-0"
></A
>queue.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The following sections describe these programs in a number of categories.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-5.1"
>5.5.1 Creating Queue Tables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16095-0"
></A
>First, you need to create your queue tables and grant the necessary capabilities.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.1.1"
>5.5.1.1 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16103-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16103-1"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16103-2"
></A
>GRANT_TYPE_ACCESS procedure</A
></H4
><P
CLASS="para"
>If you would like to support <A
CLASS="indexterm"
NAME="ch05-idx-16104-0"
></A
>multiple consumers with your queue (that is, so that the same or different messages can be dequeued by more than one agent), call the GRANT_TYPE_ACCESS program to grant that capability,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.GRANT_TYPE_ACCESS (user_name IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where user_name is the name of the user who needs to perform multiple consumer queue activities.</P
><P
CLASS="para"
>The SYS account must call this procedure to grant the privilege to the AQ administrator. The AQ administrator then runs this program to grant the privilege to AQ users. Here is an example of granting multiple consumer capabilities to the SCOTT account:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec DBMS_AQADM.GRANT_TYPE_ACCESS ('scott');</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.1.2"
>5.5.1.2 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16111-0"
></A
>CREATE_QUEUE_TABLE procedure</A
></H4
><P
CLASS="para"
>The CREATE_QUEUE_TABLE procedure creates a <A
CLASS="indexterm"
NAME="ch05-idx-16117-0"
></A
>queue table. A queue table is the named repository for a set of queues and their messages. A queue table may contain numerous queues, each of which may have many messages. But a given queue and its messages may exist in only one queue table. The specification for the procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.CREATE_QUEUE_TABLE
    (queue_table IN VARCHAR2
    ,queue_payload_type IN VARCHAR2
    ,storage_clause IN VARCHAR2 DEFAULT NULL
    ,sort_list IN VARCHAR2 DEFAULT NULL
    ,multiple_consumers IN BOOLEAN DEFAULT FALSE
    ,message_grouping IN BINARY_INTEGER DEFAULT NONE
    ,comment IN VARCHAR2 DEFAULT NULL
    ,auto_commit IN BOOLEAN DEFAULT TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_table</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of a queue table to be created. Maximum of 24 characters in length, unless you have combined the schema and the table name, as in `SCOTT.MSG_TABLE', in which case the maximum length of the argument is 49 characters.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_payload_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Type of the user data stored. This is either the name of an already defined object type or it is the string "RAW," indicating that the payload for this queue table will consist of a single LOB column.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>storage_clause</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Storage parameter, which will be included in the CREATE TABLE statement when the queue table is created. The storage parameter can be made up of any combination of the following parameters: PCTFREE, PCTUSED, INITRANS, MAXTRANS, TABLEPSACE, LOB, and a table storage clause. Refer to the <CITE
CLASS="citetitle"
>Oracle SQL Reference Guide</CITE
> for more information about defining a storage parameter.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>sort_list</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Columns to be used as the sort key in ascending order; see the following discussion. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>multiple_consumers</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies whether queues created in this table can have more than one consumer per message. The default is FALSE (only one consumer per message). If a value of TRUE is passed for this argument, the user must have been granted type access by executing the DBMS_AQADM.GRANT_TYPE_ACCESS procedure. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>message_grouping</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Message grouping behavior for queues created in the table. Valid arguments for this parameter:</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>DBMS_AQADM.NONE</EM
></P
><P
CLASS="para"
>Each message is treated individually (this is the default).</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>DBMS_AQADM.TRANSACTIONAL</EM
></P
><P
CLASS="para"
>Messages enqueued as part of one transaction are considered  part of the same group and must be dequeued as a group of related messages. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>comment</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>User-specified description of the queue table. This user comment will be added to the queue catalog. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>auto_commit</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies the transaction behavior for queues associated with this table. Valid arguments:</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>TRUE</EM
></P
><P
CLASS="para"
>Causes the current transaction, if any, to commit before the operation is carried out. The operation becomes persistent when the call returns. This is the default. </P
><P
CLASS="para"
><EM
CLASS="emphasis"
>FALSE</EM
></P
><P
CLASS="para"
>Any administrative operation on a queue is part of the current transaction and will become persistent only when the caller issues a commit. In other words, this argument does not apply to enqueue/dequeue operations performed on the queue.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch05-idx-16121-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16121-1"
></A
>sort_list has the following format, </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>'&lt;sort_column_1&gt;,&lt;sort_column_2&gt;' </PRE
></BLOCKQUOTE
><P
CLASS="para"
>where each sort_column_N is either PRIORITY or ENQ_TIME. If both columns are specified, then &lt;sort_column_1&gt; defines the most significant order. In other words, these are the only valid values for sort_list besides NULL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>'PRIORITY'	
'PRIORITY,ENQ_TIME'
'ENQ_TIME' (this is the default)	
'ENQ_TIME,PRIORITY'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Once a queue table is created with a specific ordering mechanism, all queues in the queue table inherit the same default ordering. This order cannot be altered once the queue table has been created. If no sort list is specified, all the queues in this queue table will be sorted by the enqueue time in ascending order. This order is equivalent to FIFO (first-in-first-out) order. </P
><P
CLASS="para"
>Even with the default ordering defined, a consumer can override this order by specifying the msgid or correlation value for a specific message. The msgid, correlation, and sequence_deviation take precedence over the default dequeueing order if they are specified. </P
><P
CLASS="para"
>When you create a queue table, the following objects are created:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The default <A
CLASS="indexterm"
NAME="ch05-idx-16122-0"
></A
>exception queue associated with the queue table. It is named,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	aq$_&lt;queue_table_name&gt;_e </PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <CODE
CLASS="literal"
>&lt;queue_table_name&gt;</CODE
> is the name of the queue table just created. So if my queue table is named msg, then my exception queue table is named <CODE
CLASS="literal"
>aq$_msg_e</CODE
> (and now you can see why the maximum length name for a queue table is 24 characters!).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16123-0"
></A
>A read-only view that is used by AQ applications for querying queue data called:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	 aq$&lt;queue_table_name&gt;. </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16124-0"
></A
>An index for the Queue Monitor operations called:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	aq$_&lt;queue_table_name&gt;_t. </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An index (or an index organized table [IOT] in the case of multiple consumer queues) for dequeue operations. It is named:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>aq$_&lt;queue_table_name&gt;_i</PRE
></BLOCKQUOTE
></LI
></UL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.1.2.1"
>5.5.1.2.1 Example</A
></H4
><P
CLASS="para"
>In the following example, I construct a basic queue table in the current schema with a comment as to when it was created:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_AQADM.CREATE_QUEUE_TABLE
      (queue_table =&gt; 'msg',
       queue_payload_type =&gt; 'message_type',
       comment =&gt; 'General message queue table created on ' || 
          TO_CHAR(SYSDATE,'MON-DD-YYYY HH24:MI:SS'));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that I pass the payload type as a string: the name of the object type I defined in the section explaining how to enqueue messages. I can verify the creation of this queue table by querying the USER_QUEUE_TABLES. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT queue_table, user_comment FROM USER_QUEUE_TABLES;
<I
CLASS="replaceable"
>QUEUETABLE	</I
>	<I
CLASS="replaceable"
>USER_COMMENT</I
>
MSG				General message queue table created on JUN-08-1997 14:22:01</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following request to create a queue table specifies support for multiple consumers of a single message and also enables message grouping:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_AQADM.CREATE_QUEUE_TABLE
      (queue_table =&gt; 'msg',
       queue_payload_type =&gt; 'message_type',
       multiple_consumers =&gt; TRUE,
       message_grouping =&gt; DBMS_AQADM.TRANSACTIONAL,
       comment =&gt; 'Specialized queue table created on ' || 
          TO_CHAR(SYSDATE,'MON-DD-YYYY HH24:MI:SS'));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice the extensive use of <A
CLASS="indexterm"
NAME="ch05-idx-16125-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16125-1"
></A
>named notation (the "=&gt;" symbols). This feature of  PL/SQL comes in very handy when working with programs that have long lists of parameters, or with programs that are used infrequently. The named notation approach, which explicitly associates a parameter with an argument value, documents more clearly how the program is being used.</P
><P
CLASS="para"
>See the <A
CLASS="xref"
HREF="ch05_07.htm#ch05-SECT-7.5.1"
>Section 5.7</A
>" section for a more thorough explanation of the message grouping and multiple consumers feature.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.1.2.2"
>5.5.1.2.2 Notes on usage</A
></H4
><P
CLASS="para"
>Note the following about using the <A
CLASS="indexterm"
NAME="ch05-idx-16126-0"
></A
>CREATE_QUEUE_TABLE procedure:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If you specify a schema for your queue table, then the payload type (if an object type) must also be defined in that schema. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You do not need to specify the schema for the payload type, but you can. If you do specify the object type schema for the payload type, it must be the same schema as that of the queue table or you will receive an ORA-00902: invalid datatype error. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you are going to create your queue tables from one (administrator) account and manage those queues from another (user) account, then you will need to grant EXECUTE privilege to the administrator account on the queue message types from the <A
CLASS="indexterm"
NAME="ch05-idx-16119-0"
></A
>user <A
CLASS="indexterm"
NAME="ch05-idx-16115-0"
></A
>account.</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-5.2"
>5.5.2 Creating and Starting Queues</A
></H3
><P
CLASS="para"
>Once a queue table has been created, you can create and then start individual queues in that queue table. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.2.1"
>5.5.2.1 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16131-0"
></A
>CREATE_QUEUE procedure</A
></H4
><P
CLASS="para"
>Call the CREATE_QUEUE to create a <A
CLASS="indexterm"
NAME="ch05-idx-16163-0"
></A
>queue in the specified queue table. All queue names must be unique within a schema. Once a queue is created, it can be enabled by calling DBMS_AQADM.START_QUEUE. By default, the queue is created with both enqueue and dequeue disabled.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.CREATE_QUEUE 
   (queue_name IN VARCHAR2,
    queue_table IN VARCHAR2,
    queue_type IN BINARY_INTEGER default DBMS_AQADM.NORMAL_QUEUE,
    max_retries IN NUMBER default 0,
    retry_delay IN NUMBER default 0,
    retention_time IN NUMBER default 0,
    dependency_tracking IN BOOLEAN default FALSE,
    comment IN VARCHAR2 default NULL,
    auto_commit IN BOOLEAN default TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue to be created. All queue names must be unique within a schema. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_table</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue table in which this queue is to be created.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies the type of queue. Valid options for this parameter:</P
><P
CLASS="para"
><I
CLASS="filename"
>DBMS_AQADM.NORMAL_QUEUE</I
></P
><P
CLASS="para"
>The default, a normal queue. </P
><P
CLASS="para"
><I
CLASS="filename"
>DBMS_AQADM.EXCEPTION_QUEUE</I
></P
><P
CLASS="para"
>An exception queue. Only dequeue operations are valid on an exception queue. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>max_retries</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Maximum number of times a dequeue with the REMOVE mode can be attempted on a message. The count is incremented when the application issues a rollback after executing a dequeue (but before a commit is performed). The message is moved to the exception queue when the number of failed attempts reaches its max_retries. Specify 0, the default, to indicate that no retries are allowed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>retry_delay</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Delay in seconds to wait after an application rollback before the message is scheduled for processing again. The default of 0 means that the dequeue operation should be retried as soon as possible. The retry parameters in effect allow you to control the fault tolerance of the message queue. This value is ignored if max_retries is set to 0 (the default). This value may not be specified if this is a multiple consumer queue table.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>retention_time</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of seconds for which a message will be retained in the queue table after being dequeued from the queue. The default is 0, meaning no retention. You can also specify the DBMS_AQADM.INFINITE packaged constant to request that the message be retained forever.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dependency_tracking</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Reserved for future use by Oracle Corporation. FALSE is the default, and TRUE is not permitted.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>comment</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>User comment to associate with the message queue in the queue catalog.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>auto_commit</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specify TRUE (the default) to cause the current transaction, if any, to commit before the operation is carried out. The operation becomes persistent when the call returns. Specify FALSE to make this operation part of the current transaction. In this case, it will become persistent only when the caller issues a commit.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.2.1.1"
>5.5.2.1.1 Example</A
></H4
><P
CLASS="para"
>In the following example, I create a new message queue within the previously created message queue table. I want it to allow for up to ten retries at hourly delays and keep ten days worth of history before deleting processed messages.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
  DBMS_AQADM.CREATE_QUEUE(
      queue_name =&gt; 'never_give_up_queue',
      queue_table =&gt; 'msg',
      max_retries =&gt; 10,
      retry_delay =&gt; 3600,
      retention_time =&gt; 10 * 24 * 60 * 60,
      comment =&gt; 'Test Queue Number 1');
<A
CLASS="indexterm"
NAME="ch05-idx-16140-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16140-1"
></A
>END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.2.2"
>5.5.2.2 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16144-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16144-1"
></A
>START_QUEUE procedure</A
></H4
><P
CLASS="para"
>It is not enough to simply create a queue inside a queue table. You must also enable it for enqueuing and/or dequeuing operation, with the START_QUEUE procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.START_QUEUE 
   (queue_name IN VARCHAR2,
    enqueue IN BOOLEAN DEFAULT TRUE,
    dequeue  IN BOOLEAN DEFAULT TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue to be started. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>enqueue</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Flag indicating whether the queue should be enabled for enqueuing (TRUE means enable, the default; FALSE means do not alter the current setting.)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dequeue</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Flag indicating whether the queue should be enabled for dequeuing (TRUE means enable, the default; FALSE means do not alter the current setting.)</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Notice that a value of FALSE for either of the Boolean parameters does not disable a queue for the respective operation. It simply does not change the current status of that operation on the specified queue. To disable queuing or enqueuing on a queue, you must call the DBMS_AQADM.STOP_QUEUE procedure.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.2.2.2"
>5.5.2.2.1 Example</A
></H4
><P
CLASS="para"
>The following block starts a queue for enqueuing actions only:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
VP   DBMS_AQADM.START_QUEUE ('number_stack', dequeue=&gt;FALSE);

<A
CLASS="indexterm"
NAME="ch05-idx-16152-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16152-1"
></A
>END;VPU
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You will often want to perform the following steps in sequence:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>DBMS_AQADMP.CREATE_QUEUE_TABLE</TD
></TR
><TR
><TD
CLASS="member"
>DBMS_AQADM.CREATE_QUEUE</TD
></TR
><TR
><TD
CLASS="member"
>DBMS_AQADM.START_QUEUE</TD
></TR
></TABLE
><P
CLASS="para"
>The following files on the companion disk provide various examples of these steps: </P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
><EM
CLASS="emphasis"
>aqcrepq.sql</EM
><A
CLASS="indexterm"
NAME="ch05-idx-19617-0"
></A
></TD
></TR
><TR
><TD
CLASS="member"
><EM
CLASS="emphasis"
>aqcreq.sql</EM
><A
CLASS="indexterm"
NAME="ch05-idx-19619-0"
></A
></TD
></TR
><TR
><TD
CLASS="member"
><EM
CLASS="emphasis"
>aqcref.sql</EM
><A
CLASS="indexterm"
NAME="ch05-idx-19621-0"
></A
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.2.3"
>5.5.2.3 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16165-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16165-1"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16165-2"
></A
>ALTER_QUEUE procedure</A
></H4
><P
CLASS="para"
>The ALTER_QUEUE procedure of the DBMS_AQADM package modifies an existing message queue. An error is returned if the message queue does not exist. The specification for the procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.ALTER_QUEUE 
   queue_name IN VARCHAR2,
   max_retries IN NUMBER default NULL,
   retry_delay IN NUMBER default NULL,
   retention_time IN NUMBER default NULL,
   auto_commit IN BOOLEAN default TRUE);</PRE
></BLOCKQUOTE
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
></TD
></TR
></TABLE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the message queue to be altered.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>max_retries</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies the maximum number of times a dequeue with the REMOVE mode can be attempted on a message. The count is incremented when the application issues a rollback after executing a dequeue (but before a commit is performed). The message is moved to the exception queue when the number of failed attempts reach its max_retries. Specify 0, the default, to indicate that no retries are allowed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>retry_delay</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies the delay in seconds to wait after an application rollback before the message is scheduled for processing again. The default of 0 means that the dequeue operation should be retried as soon as possible. The retry parameters in effect allow you to control the fault tolerance of the message queue. This value is ignored if max_retries is set to 0 (the default). This value may not be specified if this is a multiple consumer queue table.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>retention_time</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies the number of seconds for which a message will be retained in the queue table after being dequeued from the queue. The default is 0, meaning no retention. You can also specify the DBMS_AQADM.INFINITE packaged constant to request that the message be retained forever.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>auto_commit</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies the transaction behavior for queues associated with this table. Specify TRUE (the default) to cause the current transaction, if any, to commit before the operation is carried out. The operation becomes persistent when the call returns. If you specify FALSE, any administrative operation on a queue is part of the current transaction and will become persistent only when the caller issues a commit. In other words, this argument does not apply to enqueue/dequeue operations performed on the queue.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.2.3.1"
>5.5.2.3.1 Example</A
></H4
><P
CLASS="para"
>In the following example, I modify the properties of the queue created under CREATE_QUEUE. I now want it to allow for up to 20 retries at hourly delays and to keep 30 days worth of history before deleting processed messages.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
  DBMS_AQADM.ALTER_QUEUE(
      queue_name =&gt; 'never_give_up_queue',
      max_retries =&gt; 20,
      retention_time =&gt; 30 * 24 * 60 * 60);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I can verify the impact of this call by querying the <A
CLASS="indexterm"
NAME="ch05-idx-16174-0"
></A
>USER_QUEUES data dictionary view.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT name, max_retries, retention FROM USER_QUEUES;

NAME                            MAX_RETRIES        RETENTION
------------------------------     -----------          ----------
AQ$_MSG_E                       0                  0
MSGQUEUE                        0                  0
NEVER_GIVE_UP_QUEUE             20	           2592000</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first line in the listing is the exception queue for the "msg" queue table. The "msgqueue" queue in the "msg" queue table is a previously defined queue. The third line displays the information for the queue modified by the call to DBMS_AQADM.ALTER_QUEUE.<A
CLASS="indexterm"
NAME="ch05-idx-16172-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16172-1"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-5.3"
>5.5.3 Managing Queue Subscribers</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16198-0"
></A
>A program can enqueue messages to a specific list of recipients or to the default list of subscribers. A subscriber to a queue is an agent that is registered to dequeue messages from a queue.</P
><P
CLASS="para"
>You can add and remove subscribers, as well as retrieve the current set of subscribers for a queue. These operations will work only with queues that allow multiple consumers (i.e., the multiple_consumers parameter is set to TRUE when you called DBMS_AQADM.CREATE_QUEUE_TABLE). The command takes effect immediately, and the containing transaction is committed. Enqueue requests executed after the completion of this call will reflect the new behavior. Users attempting to modify the <A
CLASS="indexterm"
NAME="ch05-idx-16206-0"
></A
>subscriber list of a queue must have been granted type access by executing the DBMS_AQADM.GRANT_TYPE_ACCESS procedure.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.3.1"
>5.5.3.1 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16207-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16207-1"
></A
>ADD_SUBSCRIBER procedure</A
></H4
><P
CLASS="para"
>To add a subscriber to a queue, call the ADD_SUBSCRIBER procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.ADD_SUBSCRIBER
   (queue_name IN VARCHAR2, subscriber IN SYS.AQ$_AGENT);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_table</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue to which the subscriber is being added.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>subscriber</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Subscriber to be added. Not the actual name of the subscriber, but an object of type SYS.AQ$_AGENT. If you try to add a subscriber that is already on the list, AQ will raise the ORA-24034 <A
CLASS="indexterm"
NAME="ch05-idx-19484-0"
></A
>exception. Agent names are case-insensitive. </P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.3.1.1"
>5.5.3.1.1 Example</A
></H4
><P
CLASS="para"
>Here is an example of adding a subscriber to a queue:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_AQADM.ADD_SUBSCRIBER 
      ('msgqueue', SYS.AQ$_AGENT ('multiconsqueue', NULL, NULL));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this case, I have embedded the call to the object constructor method to convert a name to an agent. You can also perform this task in two steps as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_agent SYS.AQ$_AGENT;
BEGIN
   v_agent := SYS.AQ$_AGENT ('Danielle', NULL, NULL);
   DBMS_AQADM.ADD_SUBSCRIBER ('multiconsqueue', v_agent);</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.3.2"
>5.5.3.2 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16208-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16208-1"
></A
>REMOVE_SUBSCRIBER procedure</A
></H4
><P
CLASS="para"
>To remove a default subscriber from a queue, call the REMOVE_SUBSCRIBER procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.REMOVE_SUBSCRIBER
   (queue_name IN VARCHAR2, subscriber IN SYS.AQ$_AGENT);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_table</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue from which the subscriber is being removed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>subscriber</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Subscriber to be removed. Not the actual name of the subscriber, but an object of type SYS.AQ$_AGENT. Agent names are case-insensitive. </P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.3.2.1"
>5.5.3.2.1 Example</A
></H4
><P
CLASS="para"
> Here is an example of removing a subscriber from a queue:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_AQADM.REMOVE_SUBSCRIBER 
      ('multiconsqueue', SYS.AQ$_AGENT ('CEO', NULL, NULL));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this case I have embedded the call to the object constructor method to convert a name to an agent. You can also perform this task in two steps as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_agent SYS.AQ$_AGENT;
BEGIN
   v_agent := SYS.AQ$_AGENT ('CEO', NULL, NULL);
   DBMS_AQADM.REMOVE_SUBSCRIBER ('multiconsqueue', v_agent);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>All references to the subscriber in existing messages are removed as part of the operation.</P
><P
CLASS="para"
>If you try to remove a subscriber that does not exist for this queue, you will receive this error message:<A
CLASS="indexterm"
NAME="ch05-idx-16215-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16215-1"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-24035: application &lt;subscriber&gt; is not a subscriber for queue &lt;queue&gt;</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.3.3"
>5.5.3.3 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16218-0"
></A
>QUEUE_SUBSCRIBERS procedure</A
></H4
><P
CLASS="para"
>The QUEUE_SUBSCRIBERS function returns the list of <A
CLASS="indexterm"
NAME="ch05-idx-16222-0"
></A
>subscribers associated with the specified queue. This list is an index-by table, as shown in the header,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_AQADM.QUEUE_SUBSCRIBERS
   (queue_name IN VARCHAR2)
RETURN DBMS_AQADM.AQ$_SUBSCRIBER_LIST_T;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where queue_name is the name of the queue.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.3.3.1"
>5.5.3.3.1 Example</A
></H4
><P
CLASS="para"
>The following procedure encapsulates the steps needed to obtain this list and then to display it:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19332-0"
></A
>showsubs.sp */*
CREATE OR REPLACE PROCEDURE showsubs (qname IN VARCHAR2)
IS
   sublist DBMS_AQADM.AQ$_SUBSCRIBER_LIST_T;
   v_row PLS_INTEGER;
BEGIN
   /* Retrieve the list. */
   sublist := DBMS_AQADM.QUEUE_SUBSCRIBERS (qname);

   v_row := sublist.FIRST;
   LOOP
      EXIT WHEN v_row IS NULL;
      DBMS_OUTPUT.PUT_LINE (v_row);
      DBMS_OUTPUT.PUT_LINE (sublist(v_row).name);
      v_row := sublist.NEXT (v_row);
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now let's put the procedure to use. First of all, you can associate a set of subscribers only with a queue that supports multiple consumers. Here are the steps:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19304-0"
></A
>aqcremq.sql */*
BEGIN
   DBMS_AQADM.CREATE_QUEUE_TABLE
      (queue_table =&gt; 'multicons',
       queue_payload_type =&gt; 'message_type',
       multiple_consumers =&gt; TRUE);

   DBMS_AQADM.CREATE_QUEUE
      (queue_name =&gt; 'multiconsqueue',
       queue_table =&gt; 'multicons');

   DBMS_AQADM.START_QUEUE (queue_name =&gt; 'multiconsqueue');

END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can then add subscribers to the multicons queue and display the results:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19307-0"
></A
>showsubs.sql */*
DECLARE
   v_queue VARCHAR2(10) := 'multiconsqueue';
BEGIN
   DBMS_AQADM.ADD_SUBSCRIBER 
      (v_queue, SYS.AQ$_AGENT ('Danielle', NULL, NULL));
   DBMS_AQADM.ADD_SUBSCRIBER 
      (v_queue, SYS.AQ$_AGENT ('Benjamin', NULL, NULL));
   DBMS_AQADM.ADD_SUBSCRIBER 
      (v_queue, SYS.AQ$_AGENT ('Masada', NULL, NULL));
   DBMS_AQADM.ADD_SUBSCRIBER 
      (v_queue, SYS.AQ$_AGENT ('Timnah', NULL, NULL));

   <A
CLASS="indexterm"
NAME="ch05-idx-16224-0"
></A
>showsubs (v_queue);
<A
CLASS="indexterm"
NAME="ch05-idx-16220-0"
></A
>END;
/<A
CLASS="indexterm"
NAME="ch05-idx-16200-0"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-5.4"
>5.5.4 Stopping and Dropping Queues</A
></H3
><P
CLASS="para"
>DBMS_AQADM offers two programs to clean up queues: STOP_QUEUE and DROP_QUEUE. The stop program disables activity on the queue. The drop program actually removes that queue from the queue table.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.4.1"
>5.5.4.1 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16533-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16533-1"
></A
>STOP_QUEUE procedure</A
></H4
><P
CLASS="para"
>To disable enqueuing and/or dequeuing on a particular queue, call the STOP_QUEUE procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.STOP_QUEUE 
   (queue_name IN VARCHAR2,
    enqueue IN BOOLEAN DEFAULT TRUE,
    dequeue IN BOOLEAN DEFAULT TRUE,
    wait IN BOOLEAN DEFAULT TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue to be stopped.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>enqueue</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specify TRUE (the default) if you want to disable enqueuing on this queue. FALSE means that the current setting will not be altered. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dequeue</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specify TRUE (the default) if you want to disable dequeuing on this queue. FALSE means that the current setting will not be altered.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>wait</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If you specify TRUE (the default), then your program will wait for any outstanding transactions to complete. While waiting, no new transactions are allowed to enqueue to or dequeue from this queue. If you specify FALSE, then the program will return immediately and raise ORA-24023 if it was unable to stop the queue.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.4.1.1"
>5.5.4.1.1 Example</A
></H4
><P
CLASS="para"
>The following example shows the disabling of a queue for enqueuing purposes only. I also request that the program wait until all outstanding transactions are completed. You might take these steps in order to allow consumers to empty the queue, while not allowing any new messages to be placed on the queue.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_AQADM.STOP_QUEUE 
      ('msgqueue', enqueue=&gt;TRUE, dequeue=&gt;FALSE, wait=&gt;TRUE);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can check the status of your queue by querying the USER_QUEUES data dictionary <A
CLASS="indexterm"
NAME="ch05-idx-16535-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16535-1"
></A
>view:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT name, enqueue, dequeue FROM USER_QUEUES
  2   WHERE name = 'MSGQUEUE';

<B
CLASS="emphasis.bold"
>NAME</B
>         <B
CLASS="emphasis.bold"
>ENQUEUE</B
>   <B
CLASS="emphasis.bold"
>DEQUEUE</B
>		
MSGQUEUE         NO   YES</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.4.2"
>5.5.4.2 The DBMS_AQADM.DROP_QUEUE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch05-idx-16537-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16537-1"
></A
>DROP_QUEUE procedure drops an existing message queue. An error is returned if the message queue does not exist. In addition, this operation is not allowed unless DBMS_AQADM.STOP_QUEUE has been called to disable both enqueuing and dequeuing. If the message queue has not been stopped, then DROP_QUEUE returns an error of queue resource (ORA-24023). Here's the header for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.DROP_QUEUE 
   (queue_name  IN VARCHAR2,
    auto_commit IN BOOLEAN DEFAULT TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following <A
CLASS="indexterm"
NAME="ch05-idx-16539-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16539-1"
></A
>table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue to be dropped.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>auto_commit</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specify TRUE (the default) to cause the current transaction, if any, to commit before the operation is carried out. The operation becomes persistent when the call returns. Specify FALSE if you want the drop action to be part of the current transaction, thereby taking effect only when the calling session issues a commit. </P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.4.3"
>5.5.4.3 The DBMS_AQADM.DROP_QUEUE_TABLE procedure</A
></H4
><P
CLASS="para"
>Once you have stopped and dropped all queues in a queue table, you can remove that entire queue table with the <A
CLASS="indexterm"
NAME="ch05-idx-16541-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16541-1"
></A
>DROP_QUEUE_TABLE procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.DROP_QUEUE_TABLE 
   (queue_table IN VARCHAR2,
    force IN BOOLEAN default FALSE,
    auto_commit IN BOOLEAN default TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_table</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue table to be dropped.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>force</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specify FALSE (the default) to ensure that the drop action will not succeed unless all queues have been dropped. Specify TRUE if you want to force the dropping of this queue table. In this case, any remaining queues will be automatically stopped and dropped. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>auto_commit</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specify TRUE (the default) to cause the current transaction, if any, to commit before the operation is carried out. The operation becomes persistent when the call returns. Specify FALSE if you want the drop action to be part of the current transaction, thereby taking effect only when the calling session issues a commit.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.4.3.1"
>5.5.4.3.1 Example</A
></H4
><P
CLASS="para"
>The following example forces the dropping of the msg queue table, stopping and dropping all queues along the way.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_AQADM.DROP_QUEUE_TABLE ('msg', force =&gt; TRUE);
END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-5.5"
>5.5.5 Managing Propagation of Messages</A
></H3
><P
CLASS="para"
>In order to propagate messages from one queue to another (an Oracle 8.0.4 and later feature), you need to schedule propagation between queues. You can also unschedule propagation of those messages.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.5.1"
>5.5.5.1 The DBMS_AQADM.SCHEDULE_PROPAGATION procedure</A
></H4
><P
CLASS="para"
>Call the <A
CLASS="indexterm"
NAME="ch05-idx-16544-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16544-1"
></A
>SCHEDULE_PROPAGATION procedure to schedule propagation of messages. The header for this procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.SCHEDULE_PROPAGATION
   (src_queue_name IN VARCHAR2,
    destination IN VARCHAR2 DEFAULT NULL,
    start_time IN DATE DEFAULT SYSDATE,
    duration IN NUMBER DEFAULT NULL,
    next_time IN VARCHAR2 DEFAULT NULL,
    latency IN NUMBER DEFAULT 60);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>src_queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the source queue whose messages are to be propagated. This name should include the schema name, if the queue is not located in the default schema, which is the schema name of the Oracle AQ administrator.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>destination</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Database link for the destination. If this argument is NULL, then the destination is the local database; messages will be propagated to other queues in the local database as determined by the subscription or recipient lists. The maximum length for the destination is currently 128 bytes. If the name is not fully qualified, then the default domain named will be used.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>start_time</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Initial start date-time for the window of time in which messages are propagated from the source queue to the destination queue.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>duration</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Length of time in seconds that the propagation window will be open. If you supply a NULL value (the default), then the propagation window is open continually, or at least until the propagation is unscheduled through a call to DBMS_AQ.UNSCHEDULE_PROPAGATION.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>next_time</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An expression returning a date value that is used to compute the start of the next propagation window. If you supply a NULL value (the default), then propagation will stop when the current (initial) window closes. As an example, suppose you want to make sure the next propagation doesn't start until 24 hours after the last propagation window closed. You would then set next_time to SYSDATE + 1 - duration/86400. If you want to make sure the next propagation starts 24 hours after the last propagation window closed, provide a next_time value of `SYSDATE + 1'. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>latency</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The maximum wait in seconds that a message may sit in a queue after the start of a propagation window before it is propagated. The default amount of time is 60 seconds. This would mean, for example, that when the propagation window opens, the Queue Monitor propagates any messages present. It would then wait 60 seconds (or until the window closes due to the duration setting) before checking for the presence of and propagating any other messages.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>To summarize that relatively complex set of parameters and their interactions, when you schedule propagation you identify an initial start date/time and a span of time (number of seconds) in which messages are available to be propagated out of the queue to other queues. You can request that this window of time be opened on a regular basis (every day, once a week, every morning at 10 a.m., etc.). Finally, you can specify that the Queue Monitor check no less frequently than every N seconds (latency) during the time the propagation window is open to see if there are messages to propagate.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch05-SECT-5.5.1.1"
>5.5.5.1.1 Example</A
></H4
><P
CLASS="para"
>In this example, I schedule the propagation of a queue to the Boston brokerage office to occur every two hours. The propagation window is five minutes, and during that period of time, I want messages to be flushed out at least every 30 seconds.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_AQADM.SCHEDULE_PROPAGATION
      ('sell_orders', 
       'broker@boston',
       SYSDATE,
       5 * 60,
       'SYSDATE + 2/24', 
       30);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If I do not specify a destination, then propagation occurs to the same database in which the source queue is defined. The following call to DBMS_AQADM.SCHEDULE_PROPAGATION takes all default values (including a local destination database), except that it requests a latency of ten minutes by using named notation:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_AQADM.SCHEDULE_PROPAGATION
      ('share_the_blame', 
       latency =&gt; 60 * 10);
<A
CLASS="indexterm"
NAME="ch05-idx-16546-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16546-1"
></A
>END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.5.2"
>5.5.5.2 The DBMS_AQADM.UNSCHEDULE_PROPAGATION procedure </A
></H4
><P
CLASS="para"
>You can stop or unschedule propagation of a queue with the <A
CLASS="indexterm"
NAME="ch05-idx-16548-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16548-1"
></A
>UNSCHEDULE_PROPAGATION procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.UNSCHEDULE_PROPAGATION
   (src_queue_name IN VARCHAR2,
    destination IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>src_queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the source queue whose messages are no longer to be propagated. This name should include the schema name if the queue is not located in the default schema, which is the schema name of the Oracle AQ administrator.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>destination</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Database link for the destination for which propagation will be terminated. If this argument is NULL, then the destination is the local database; messages will no longer be propagated to other queues in the local database as determined by the subscription or recipient lists. The maximum length for destination is currently 128 bytes. If the name is not fully qualified, then the default domain named will be used.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-5.6"
>5.5.6 Verifying Queue Types</A
></H3
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.6.1"
>5.5.6.1 The DBMS_AQADM.VERIFY_QUEUE_TYPES procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch05-idx-16549-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16549-1"
></A
>VERIFY_QUEUE_TYPES procedure allows you to determine whether two different queues have the same payload type. Here's the header:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.VERIFY_QUEUE_TYPES
   (src_queue_name IN VARCHAR2,
    dest_queue_name IN VARCHAR2
    destination IN VARCHAR2 DEFAULT NULL,
    rc OUT BINARY_INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>src_queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the source queue, usually one from which messages are to be propagated. This name should include the schema name if the queue is not located in the default schema, which is the schema name of the user.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dest_queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the destination queue, usually one to which messages are to be propagated. This name should include the schema name if the queue is not located in the default schema, which is the schema name of the user.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>destination</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Database link for the destination queue. If this argument is NULL, then the destination queue is located in the same database as the source queue. The maximum length for destination is currently 128 bytes. If the name is not fully qualified, then the default domain named will be used.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>rc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Status code returned by the procedure. If there is no problem verifying the queue types and if the source and destination queue types match, then the result code is 0. If the queue types do not match (and there is no error), then the result code is 1. If an Oracle exception is raised, the SQLCODE is returned in rc.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Whenever this program is run (either by Oracle AQ itself or by an AQ administrator), it updates the SYS.AQ$_MESSAGE_TYPES table. You can access this table (to verify the success of the type match after propagation has taken place) using the OID (Object ID) of the source queue and the address of the destination <A
CLASS="indexterm"
NAME="ch05-idx-16551-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16551-1"
></A
>queue.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-5.7"
>5.5.7 Starting and Stopping the Queue Monitor</A
></H3
><P
CLASS="para"
>If you want to use the delay and expiration features of AQ, you must have the Queue Monitor process running in the background. Before you can do this, you must add an AQ_TM_PROCESS parameter to your database initialization file (see <A
CLASS="xref"
HREF="ch05_02.htm#ch05-SECT-2.2.3"
>Section 5.2, "Getting Started with Oracle AQ"</A
>" at the beginning of this chapter for more information). </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.7.1"
>5.5.7.1 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16553-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16553-1"
></A
>START_TIME_MANAGER procedure</A
></H4
><P
CLASS="para"
>To start the Queue Monitor process, call the START_TIME_MANAGER procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.START_TIME_MANAGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The operation takes effect when the call completes; there are no transactional dependencies.</P
><P
CLASS="para"
>You can use the START_TIME_MANAGER to restart the Queue Monitor after you stopped it with a call to STOP_TIME_MANAGER. You can also use it to start the Queue Monitor process if the database initialization parameter was set to 0. In other words, you can override the default state of the database with this programmatic call.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-5.7.2"
>5.5.7.2 The DBMS_AQADM.<A
CLASS="indexterm"
NAME="ch05-idx-16554-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16554-1"
></A
>STOP_TIME_MANAGER procedure</A
></H4
><P
CLASS="para"
>To stop the Queue Monitor process, call the STOP_TIME_MANAGER procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQADM.STOP_TIME_MANAGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The operation takes effect when the call completes; there are no transactional dependencies.</P
><P
CLASS="para"
>The STOP_TIME_MANAGER procedure does not actually stop the physical process running in the background. This process is started when the database is initialized. The procedure simply disables the time management features of Oracle AQ in that database instance.<A
CLASS="indexterm"
NAME="ch05-idx-16076-0"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_04.htm#ch05-SECT-4.1.1"
TITLE="5.4 DBMS_AQ: Interfacing to Oracle AQ (Oracle8 only)"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.4 DBMS_AQ: Interfacing to Oracle AQ (Oracle8 only)"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_06.htm#ch05-SECT-6.2.3"
TITLE="5.6 Oracle AQ Database Objects"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.6 Oracle AQ Database Objects"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.4 DBMS_AQ: Interfacing to Oracle AQ (Oracle8 only)</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>5.6 Oracle AQ Database Objects</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
