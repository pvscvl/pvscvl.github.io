<HTML
><HEAD
><TITLE
>[Chapter 6] 6.2 UTL_FILE: Reading and Writing Server-side Files</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:54:33Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. Generating Output from PL/SQL Programs"><LINK
REL="prev"
HREF="ch06_01.htm"
TITLE="6.1 DBMS_OUTPUT: Displaying Output"><LINK
REL="next"
HREF="ch07_01.htm"
TITLE="7. Defining an Application Profile"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_01.htm"
TITLE="6.1 DBMS_OUTPUT: Displaying Output"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.1 DBMS_OUTPUT: Displaying Output"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch06_01.htm"
TITLE="6. Generating Output from PL/SQL Programs"
>Chapter 6<BR>Generating Output from PL/SQL Programs</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch07_01.htm"
TITLE="7. Defining an Application Profile"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7. Defining an Application Profile"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch06-19503"
>6.2 UTL_FILE: Reading and Writing Server-side Files</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13754-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13754-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13754-2"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13754-3"
></A
>UTL_FILE is a package that has been welcomed warmly by PL/SQL developers. It allows PL/SQL programs to both read from and write to any operating system files that are accessible from the server on which your database instance is running. File I/O was a feature long desired in PL/SQL, but available only with PL/SQL Release 2.3 and later (Oracle 7.3 or Oracle 8.0). You can now read <I
CLASS="filename"
>ini </I
>files and interact with the operating system a <EM
CLASS="emphasis"
>little</EM
> more easily than has been possible in the past. You can load data from files directly into database tables while applying the full power and flexibility of PL/SQL programming. You can generate reports directly from within PL/SQL without worrying about the maximum buffer restrictions of DBMS_OUTPUT</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-2.1"
>6.2.1 Getting Started with UTL_FILE</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13749-0"
></A
>UTL_FILE package is created when the Oracle database is installed. The <A
CLASS="indexterm"
NAME="ch06-idx-15184-0"
></A
>utlfile.sql script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1</A
>) contains the source code for this package's specification. This script is called by<I
CLASS="filename"
> catproc.sql</I
>, which is normally run immediately after database creation. The script creates the public synonym UTL_FILE for the package and grants EXECUTE <A
CLASS="indexterm"
NAME="ch06-idx-13752-0"
></A
>privilege on the package to public. All Oracle users can reference and make use of this package.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.1"
>6.2.1.1 UTL_FILE programs</A
></H4
><P
CLASS="para"
>Table 6-2 <A
CLASS="indexterm"
NAME="ch06-idx-15350-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-15350-1"
></A
>shows the UTL_FILE program names and descriptions.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch06-56685"
>Table 6.2: UTL_FILE Programs </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15370-0"
></A
>FCLOSE </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Closes the specified files</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15377-0"
></A
>FCLOSE_ALL </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Closes all open files</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15384-0"
></A
>FFLUSH </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Flushes all the data from the UTL_FILE buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15391-0"
></A
>FOPEN </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Opens the specified file</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15398-0"
></A
>GET_LINE </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Gets the next line from the file</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15405-0"
></A
>IS_OPEN </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns TRUE if the file is already open</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15412-0"
></A
>NEW_LINE </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Inserts a newline mark in the file at the end of the current line</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15419-0"
></A
>PUT </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Puts text into the buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15426-0"
></A
>PUT_LINE </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Puts a line of text into the file</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15433-0"
></A
>PUTF </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Puts formatted text into the buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.2"
>6.2.1.2 Trying out UTL_FILE</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13772-0"
></A
>Just getting to the point where your first call to UTL_FILE's FOPEN function works can actually be a pretty frustrating experience. Here's how it usually goes.</P
><P
CLASS="para"
>You read about UTL_FILE and you are excited. So you dash headlong into writing some code like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   config_file UTL_FILE.FILE_TYPE;
BEGIN
   config_file := UTL_FILE.FOPEN ('/tmp', 'newdata.txt', 'W');

   ... lots of write operations ...

   ... and no exception section ...
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and then this is all you get from your "quick and dirty script" in SQL*Plus:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @writefile.sql
DECLARE
*
ERROR at line 1:
ORA-06510: PL/SQL: unhandled user-defined exception
ORA-06512: at &quot;SYS.UTL_FILE&quot;, line 91
ORA-06512: at &quot;SYS.UTL_FILE&quot;, line 146
ORA-06512: at line 4</PRE
></BLOCKQUOTE
><P
CLASS="para"
>What is going wrong? This error message certainly provides little or no useful information. So you go back to the documentation, thoroughly chastened, and (over time) discover the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You need to modify the INIT.ORA parameter initialization file of your instance. You will have to contact your database administrator and have him or her make the changes (if willing) and then "bounce" the database.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You need to get the format of the parameter entries correct. That alone used to take me days!</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You need to add exception sections to your programs to give yourself a fighting chance at figuring out what is going on.</P
></LI
></UL
><P
CLASS="para"
>I hope that the information in this chapter will help you avoid most, if not all, of these frustrations and gotchas. But don't give up! This package is well worth the <A
CLASS="indexterm"
NAME="ch06-idx-13773-0"
></A
>effort.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.3"
>6.2.1.3 File security</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13774-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13774-1"
></A
>UTL_FILE lets you read and write files accessible from the server on which your database is running. So you could theoretically use UTL_FILE to write right over your tablespace data files, control files, and so on. That is of course a very bad idea. Server security requires the ability to place restrictions on where you can read and write your files.</P
><P
CLASS="para"
>UTL_FILE implements this security by limiting access to files that reside in one of the directories specified in the INIT.ORA file for the database instance on which UTL_FILE is running.</P
><P
CLASS="para"
>When you call FOPEN to open a file, you must specify both the location and the name of the file, in separate arguments. This file location is then checked against the list of accessible directories. </P
><P
CLASS="para"
>Here's the format of the parameter for file access in the INIT.ORA file:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>utl_file_dir = &lt;directory&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Include a parameter for utl_file_dir for each directory you want to make accessible for UTL_FILE operations. The following entries, for example, enable four different directories in UNIX:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>utl_file_dir = /tmp
utl_file_dir = /ora_apps/hr/time_reporting
utl_file_dir = /ora_apps/hr/time_reporting/log
utl_file_dir = /users/test_area</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To bypass server security and allow read/write access to all directories, you can use this special syntax:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>utl_file_dir = *</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You should not use this option on production systems. In a development system, this entry certainly makes it easier for developers to get up and running on UTL_FILE and test their code. However, you should allow access to only a few specific directories when you move the application to production.</P
><P
CLASS="para"
>Some observations on working with and setting up accessible directories with UTL_FILE follow:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Access is not recursive through subdirectories. If the following lines were in your INIT.ORA file, for example,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	utl_file_dir = c:\group\dev1
	utl_file_dir = c:\group\prod\oe
	utl_file_dir = c:\group\prod\ar</PRE
></BLOCKQUOTE
><P
CLASS="para"
>then you would not be able to open a file in the <EM
CLASS="emphasis"
>c:\group\prod\oe\reports</EM
> subdirectory.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not include the following entry in UNIX systems:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	utl_file_dir = .</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This would allow you to read/write on the current directory in the operating system.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not enclose the directory names within single or double quotes. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In the UNIX environment, a file created by FOPEN has as its owner the shadow process running the Oracle instance. This is usually the "oracle" owner. If you try to access these files outside of UTL_FILE, you will need the correct <A
CLASS="indexterm"
NAME="ch06-idx-13779-0"
></A
>privileges (or be logged in as "oracle") to access or change these files.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You should not end your directory name with a delimiter, such as the forward slash in UNIX. The following specification of a directory will result in problems when trying to read from or write to the <A
CLASS="indexterm"
NAME="ch06-idx-13776-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13776-1"
></A
>directory:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	utl_file_dir = /tmp/orafiles/</PRE
></BLOCKQUOTE
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.4"
>6.2.1.4 Specifying file locations</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13780-0"
></A
>The location of the file is an operating system-specific string that specifies the directory or area in which to open the file. The location you provide must have been listed as an accessible directory in the INIT.ORA file for the database instance.</P
><P
CLASS="para"
>The INIT.ORA location is a valid directory or area specification, as shown in these examples:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In Windows NT:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	'k:\common\debug'</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In UNIX:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	'/usr/od2000/admin'</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>Notice that in Windows NT, the backslash character (\) is used as a delimiter. In UNIX, the forward slash (/) is the delimiter. When you pass the location in the call to UTL_FILE.FOPEN, you provide the location specification as it appears in the INIT.ORA file (unless you just provided * for all directories in the initialization file). And remember that in case-sensitive operating systems, the case of the location specification in the initialization file must match that used in the call to UTL_FILE.FOPEN.</P
><P
CLASS="para"
>Here are some examples:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In Windows NT:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	file_id := UTL_FILE.FOPEN ('k:\common\debug', 'trace.lis', 'R');</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In UNIX:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	file_id := UTL_FILE.FOPEN ('/usr/od2000/admin', 'trace.lis', 'W');</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>Your location must be an explicit, complete path to the file. You cannot use operating system-specific parameters such as environment variables in UNIX to specify file <A
CLASS="indexterm"
NAME="ch06-idx-13782-0"
></A
>locations.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.5"
>6.2.1.5 UTL_FILE exceptions</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13785-0"
></A
>The package specification of UTL_FILE defines seven exceptions. The cause behind a UTL_FILE exception can often be difficult to understand. Here are the explanations Oracle provides for each of the exceptions:</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> As a result of the way these exceptions are declared (as "user-defined exceptions"), there is no error number associated with any of the exceptions. Thus you must include explicit exception handlers in programs that call UTL_FILE if you wish to find out which error was raised. See the section <A
CLASS="xref"
HREF="ch06_02.htm#ch06-SECT-2.1.1"
>Section 6.2.6.1, "Handling file I/O errors"</A
>" for more details on this process.</P
></BLOCKQUOTE
><DL
CLASS="variablelist"
><DT
CLASS="term"
>INVALID_PATH</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The file location or the filename is invalid. Perhaps the directory is not listed as a utl_file_dir parameter in the INIT.ORA file (or doesn't exist as all), or you are trying to read a file and it does not exist.</P
></DD
><DT
CLASS="term"
>INVALID_MODE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The value you provided for the open_mode parameter in UTL_FILE.FOPEN was invalid. It must be "A," "R," or "W."</P
></DD
><DT
CLASS="term"
>INVALID_FILEHANDLE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The file handle you passed to a UTL_FILE program was invalid. You must call UTL_FILE.FOPEN to obtain a valid file handle.</P
></DD
><DT
CLASS="term"
>INVALID_OPERATION</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>UTL_FILE could not open or operate on the file as requested. For example, if you try to write to a read-only file, you will raise this exception.</P
></DD
><DT
CLASS="term"
>READ_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The operating system returned an error when you tried to read from the file. (This does not occur very often.)</P
></DD
><DT
CLASS="term"
>WRITE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The operating system returned an error when you tried to write to the file. (This does not occur very often.)</P
></DD
><DT
CLASS="term"
>INTERNAL_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Uh-oh. Something went wrong and the PL/SQL runtime engine couldn't assign blame to any of the previous exceptions. Better call Oracle Support!</P
></DD
></DL
><P
CLASS="para"
>Programs in UTL_FILE may also raise the following standard system exceptions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>NO_DATA_FOUND</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Raised when you read past the end of the file with UTL_FILE.GET_LINE.</P
></DD
><DT
CLASS="term"
>VALUE_ERROR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Raised when you try to read or write lines in the file which are too long. The current implementation of UTL_FILE limits the size of a line read by UTL_FILE.GET_LINE to 1022 bytes.</P
></DD
><DT
CLASS="term"
>INVALID_MAXLINESIZE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Oracle 8.0 and above: raised when you try to open a file with a maximum linesize outside of the valid range (between 1 through 32767).</P
></DD
></DL
><P
CLASS="para"
>In the following descriptions of the UTL_FILE programs, I list the exceptions that can be raised by each individual <A
CLASS="indexterm"
NAME="ch06-idx-13786-0"
></A
>program.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.6"
>6.2.1.6 UTL_FILE nonprogram elements</A
></H4
><P
CLASS="para"
>When you open a file, PL/SQL returns a handle to that file for use within your program. This handle has a datatype of UTL_FILE.FILE_TYPE currently defined as the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE UTL_FILE.FILE_TYPE IS RECORD (id BINARY_INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, UTL_FILE.FILE_TYPE is actually a PL/SQL record whose fields contain all the information about the file needed by UTL_FILE. However, this information is for use only by the UTL_FILE package. You will reference the handle, but not any of the individual fields of the handle. (The fields of this record may expand over time as UTL_FILE becomes more sophisticated.)</P
><P
CLASS="para"
>Here is an example of how to declare a local file handle based on this type:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   file_handle UTL_FILE.FILE_TYPE;
BEGIN
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.7"
>6.2.1.7 UTL_FILE restrictions and limitations</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13787-0"
></A
>While UTL_FILE certainly extends the usefulness of PL/SQL, it does have its drawbacks, including:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13788-0"
></A
>Prior to Oracle 8.0, you cannot read or write a line of text with more than 1023 bytes. In Oracle 8.0 and above, you can specify a maximum line size of up to 32767 when you open a file..</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13789-0"
></A
>You cannot delete files through UTL_FILE. The best you can do is <EM
CLASS="emphasis"
>empty</EM
> a file, but it will still be present on the disk.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13790-0"
></A
>You cannot rename files. The best you can do is copy the contents of the file to another file with that new name. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13791-0"
></A
>You do not have random access to lines in a file. If you want to read the 55th line, you must read through the first 54 lines. If you want to insert a line of text between the 1,267th and 1,268th lines, you will have to (a) read those 1,267 lines, (b) write them to a new file, (c) write the inserted line of text, and (d) read/write the remainder of the file. Ugh. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot change the security on files through UTL_FILE.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13792-0"
></A
>You cannot access mapped files. Generally, you will need to supply real directory locations for files if you want to read from or write to them.</P
></LI
></UL
><P
CLASS="para"
>You are probably getting the idea. UTL_FILE is a basic facility for reading and writing server-side files. Working with UTL_FILE is not always pretty, but you can usually get what you need done with a little or a lot of code.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.8"
>6.2.1.8 The UTL_FILE process flow</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13793-0"
></A
>The following sections describe each of the UTL_FILE programs, following the process flow for working with files. That flow is described for both writing and reading files.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13795-0"
></A
>In order to write to a file you will (in most cases) perform the following steps:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Declare a file handle. This handle serves as a pointer to the file for subsequent calls to programs in the UTL_FILE package to manipulate the contents of this file.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Open the file with a call to FOPEN, which returns a file handle to the file. You can open a file to read, replace, or append text.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Write data to the file using the PUT, PUTF, or PUT_LINE procedures. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Close the file with a call to FCLOSE. This releases resources associated with the <A
CLASS="indexterm"
NAME="ch06-idx-15279-0"
></A
>file.</P
></LI
></OL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-15281-0"
></A
>To read data from a file you will (in most cases) perform the following steps: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Declare a file handle.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Declare a VARCHAR2 string buffer that will receive the line of data from the file. You can also read directly from a file into a numeric or date buffer. In this case, the data in the file will be converted implicitly, and so it must be compatible with the datatype of the buffer.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Open the file using FOPEN in read mode.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use the GET_LINE procedure to read data from the file and into the buffer. To read all the lines from a file, you would execute GET_LINE in a loop.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Close the file with a call to <A
CLASS="indexterm"
NAME="ch06-idx-13794-0"
></A
>FCLOSE. </P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-2.2"
>6.2.2 Opening Files</A
></H3
><P
CLASS="para"
>Use the FOPEN and IS_OPEN functions when you open files via UTL_FILE.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Using the UTL-FILE package, you can only open a maximum of ten files for each Oracle session.</P
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.2.1"
>6.2.2.1 The UTL_FILE.FOPEN function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13803-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13803-1"
></A
>FOPEN function opens the specified file and returns a file handle that you can then use to manipulate the file. Here's the header for the function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
> All PL/SQL versions:           Oracle 8.0 and above only:
 FUNCTION UTL_FILE.FOPEN (      FUNCTION UTL_FILE.FOPEN (
    location     IN VARCHAR2,      location     IN VARCHAR2,
    filename     IN VARCHAR2,      filename     IN VARCHAR2,
    open_mode    IN VARCHAR2)      open_mode    IN VARCHAR2,
 RETURN file_type;                 max_linesize IN BINARY_INTEGER)
                                RETURN file_type;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>location</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Location of the file</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>filename</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the file</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>openmode</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Mode in which the file is to be opened (see the following modes)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>max_linesize</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The maximum number of characters per line, including the newline character, for this file. Minimum is 1, maximum is 32767</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>You can open the <A
CLASS="indexterm"
NAME="ch06-idx-13807-0"
></A
>file in one of three modes:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>R</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Open the file read-only. If you use this mode, use UTL_FILE's GET_LINE procedure to read from the file.</P
></DD
><DT
CLASS="term"
>W</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Open the file to read and write in replace mode. When you open in replace mode, all existing lines in the file are removed. If you use this mode, then you can use any of the following UTL_FILE programs to modify the file: PUT, PUT_LINE, NEW_LINE, PUTF, and FFLUSH.</P
></DD
><DT
CLASS="term"
>A</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Open the file to read and write in append mode. When you open in append mode, all existing lines in the file are kept intact. New lines will be appended after the last line in the file. If you use this mode, then you can use any of the following UTL_FILE programs to modify the file: PUT, PUT_LINE, NEW_LINE, PUTF, and <A
CLASS="indexterm"
NAME="ch06-idx-13809-0"
></A
>fFFLUSH.</P
></DD
></DL
><P
CLASS="para"
>Keep the following points in mind as you attempt to open files:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The file location and the filename joined together must represent a legal filename on your operating system. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The file location specified must be accessible and must already exist; FOPEN will not create a directory or subdirectory for you in order to write a new file, for example.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you want to open a file for read access, the file must already exist. If you want to open a file for write access, the file will either be created, if it does not exist, or emptied of all its contents, if it does exist.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you try to open with append, the file must already exist. UTL_FILE will not treat your append request like a write access request. If the file is not present, UTL_FILE will raise the INVALID_OPERATION exception.</P
></LI
></UL
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.2.1.1"
>6.2.2.1.1 Exceptions</A
></H4
><P
CLASS="para"
>FOPEN may raise any of the following exceptions, described earlier:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.INVALID_MODE
UTL_FILE.INVALID_OPERATION
UTL_FILE.INVALID_PATH
UTL_FILE.INVALID_MAXLINESIZE</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.2.1.2"
>6.2.2.1.2 Example</A
></H4
><P
CLASS="para"
>The following example shows how to declare a file handle and then open a configuration file for that handle in read-only <A
CLASS="indexterm"
NAME="ch06-idx-13805-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13805-1"
></A
>mode: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   	config_file UTL_FILE.FILE_TYPE;
BEGIN
   	config_file := UTL_FILE.FOPEN ('/maint/admin', 'config.txt', 'R');
   	...</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.2.2"
>6.2.2.2 The UTL_FILE.IS_OPEN function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13811-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13811-1"
></A
>IS_OPEN function returns TRUE if the specified handle points to a file that is already open. Otherwise, it returns false. The header for the function is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_FILE.IS_OPEN (file IN UTL_FILE.FILE_TYPE) RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where file is the file to be checked.</P
><P
CLASS="para"
>Within the context of UTL_FILE, it is important to know what this means. The IS_OPEN function does not perform any operating system checks on the status of the file. In actuality, it merely checks to see if the id field of the file handle record is not NULL. If you don't play around with these records and their contents, then this id field is only set to a non-NULL value when you call FOPEN. It is set back to NULL when you <A
CLASS="indexterm"
NAME="ch06-idx-13813-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13813-1"
></A
>call FCLOSE.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-2.3"
>6.2.3 Reading from Files</A
></H3
><P
CLASS="para"
>UTL_FILE provides only one program to retrieve data from a file: the GET_LINE procedure.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.3.1"
>6.2.3.1 The UTL_FILE.GET_LINE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13819-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13819-1"
></A
>GET_LINE procedure reads a line of data from the specified file, if it is open, into the provided line buffer. Here's the header for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_FILE.GET_LINE 
   (file IN UTL_FILE.FILE_TYPE, 
    buffer OUT VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>file</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The file handle returned by a call to FOPEN</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The buffer into which the line of data is read</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The variable specified for the buffer parameter must be large enough to hold all the data up to the next carriage return or end-of-file condition in the file. If not, PL/SQL will raise the VALUE_ERROR exception. The line terminator character is not included in the string passed into the buffer.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.3.1.1"
>6.2.3.1.1 Exceptions</A
></H4
><P
CLASS="para"
>GET_LINE may raise any of the following exceptions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NO_DATA_FOUND 
VALUE_ERROR 
UTL_FILE.INVALID_FILEHANDLE
UTL_FILE.INVALID_OPERATION
UTL_FILE.READ_ERROR</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.3.1.2"
>6.2.3.1.2 Example</A
></H4
><P
CLASS="para"
>Since GET_LINE reads data only into a string variable, you will have to perform your own <A
CLASS="indexterm"
NAME="ch06-idx-13823-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13823-1"
></A
>conversions to local variables of the appropriate datatype if your file holds numbers or dates. Of course, you could call this procedure and read data directly into string and numeric variables as well. In this case, PL/SQL will be performing a runtime, implicit conversion for you. In many situations, this is fine. I generally recommend that you avoid implicit conversions and perform your own conversion instead. This approach more clearly documents the steps and dependencies. Here is an example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   fileID UTL_FILE.FILE_TYPE;
   strbuffer VARCHAR2(100);
   mynum NUMBER;
BEGIN
   fileID := UTL_FILE.FOPEN ('/tmp', 'numlist.txt', 'R');
   UTL_FILE.GET_LINE (fileID, strbuffer);
   mynum := TO_NUMBER (strbuffer);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When GET_LINE attempts to read past the end of the file, the NO_DATA_FOUND exception is raised. This is the same exception that is raised when you (a) execute an implicit (SELECT INTO) cursor that returns no rows or (b) reference an undefined row of a PL/SQL (nested in PL/SQL8) table. If you are performing more than one of these operations in the same PL/SQL block, remember that this same exception can be caused by very different <A
CLASS="indexterm"
NAME="ch06-idx-15090-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-15090-1"
></A
>parts of <A
CLASS="indexterm"
NAME="ch06-idx-13821-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13821-1"
></A
>your program. </P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-2.4"
>6.2.4 Writing to Files</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13827-0"
></A
>In contrast to the simplicity of reading from a file, UTL_FILE offers a number of different procedures you can use to write to a file:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>UTL_FILE.PUT</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Puts a piece of data (string, number, or date) into a file in the current line.</P
></DD
><DT
CLASS="term"
>UTL_FILE.NEW_LINE	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Puts a newline or line termination character into the file at the current position.</P
></DD
><DT
CLASS="term"
>UTL_FILE.PUT_LINE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Puts a string into a file, followed by a platform-specific line termination character.</P
></DD
><DT
CLASS="term"
>UTL_FILE.PUTF</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Puts up to five strings out to the file in a format based on a template string, similar to the printf function in C.</P
></DD
></DL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13836-0"
></A
>You can use these procedures only if you have opened your file with modes W or A; if you opened the file for read-only, the runtime engine will raise the UTL_FILE.INVALID_OPERATION exception.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13837-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13837-1"
></A
>Starting with Oracle 8.0.3, the maximum size of a file string is 32K; the limit for earlier versions is 1023 bytes.  If you have longer strings, you must break them up into individual lines, perhaps using a special continuation character to notify a post-processor to recombine those lines.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.4.1"
>6.2.4.1 The UTL_FILE.PUT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13838-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13838-1"
></A
>PUT procedure puts data out to the specified open file. Here's the header for this procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_FILE.PUT 
    (file IN UTL_FILE.FILE_TYPE, 
    buffer OUT VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>file</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The file handle returned by a call to FOPEN</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The buffer containing the text to be written to the file; maximum size allowed is 32K for Oracle 8.0.3 and above; for earlier versions, it is 1023 bytes</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The PUT procedure adds the data to the current line in the opened file, but does not append a line terminator. You must use the NEW_LINE procedure to terminate the current line or use PUT_LINE to write out a complete line with a line termination character.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.4.1.1"
>6.2.4.1.1 Exceptions</A
></H4
><P
CLASS="para"
>PUT may raise any of the following exceptions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.INVALID_FILEHANDLE
UTL_FILE.INVALID_OPERATION
UTL_FILE.WRITE_ERROR</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.4.2"
>6.2.4.2 The UTL_FILE.NEW_LINE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13839-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13839-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13839-2"
></A
>NEW_LINE procedure inserts one or more newline characters in the specified file. Here's the header for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_FILE.NEW_LINE 
   (file IN UTL_FILE.FILE_TYPE, 
    lines IN NATURAL := 1); </PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>file</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The file handle returned by a call to FOPEN</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lines</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number of lines to be inserted into the file</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>If you do not specify a number of lines, NEW_LINE uses the default value of 1, which places a newline character (<A
CLASS="indexterm"
NAME="ch06-idx-13847-0"
></A
>carriage return) at the end of the current line. So if you want to insert a blank line in your file, execute the following call to NEW_LINE:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.NEW_LINE (my_file, 2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you pass 0 or a negative number for lines, nothing is written into the file. </P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.4.2.1"
>6.2.4.2.1 Exceptions</A
></H4
><P
CLASS="para"
>NEW_LINE may raise any of the following exceptions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>VALUE_ERROR
UTL_FILE.INVALID_FILEHANDLE
UTL_FILE.INVALID_OPERATION
UTL_FILE.WRITE_ERROR</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.4.2.2"
>6.2.4.2.2 Example</A
></H4
><P
CLASS="para"
>If you frequently wish to add an end-of-line marker after you PUT data out to the file (see the PUT procedure information), you might bundle two calls to UTL_FILE modules together, as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE add_line (file_in IN UTL_FILE.FILE_TYPE, line_in IN VARCHAR2)
IS
BEGIN
   UTL_FILE.PUT (file_in, line_in);
   UTL_FILE.NEW_LINE (file_in);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By using add_line instead of PUT, you will not have to worry about remembering to call NEW_LINE to finish off the line. Of course, you could also simply call the PUT_LINE <A
CLASS="indexterm"
NAME="ch06-idx-13841-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13841-1"
></A
>procedure.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.4.3"
>6.2.4.3 The UTL_FILE.<A
CLASS="indexterm"
NAME="ch06-idx-13848-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13848-1"
></A
>PUT_LINE procedure</A
></H4
><P
CLASS="para"
>This procedure writes data to a file and then immediately appends a newline character after the text. Here's the header for PUT_LINE:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_FILE.PUT_LINE 
    (file IN UTL_FILE.FILE_TYPE, 
    buffer IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>file</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The file handle returned by a call to FOPEN</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>buffer</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Text to be written to the file; maximum size allowed is 32K for Oracle 8.0. 3 and above; for earlier versions, it is 1023 bytes</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Before you can call UTL_FILE.PUT_LINE, you must have already opened the file.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.4.3.1"
>6.2.4.3.1 Exceptions</A
></H4
><P
CLASS="para"
>PUT_LINE may raise any of the following exceptions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.INVALID_FILEHANDLE
UTL_FILE.INVALID_OPERATION
UTL_FILE.WRITE_ERROR</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.4.3.2"
>6.2.4.3.2 Example</A
></H4
><P
CLASS="para"
>Here is an example of using PUT_LINE to dump the contents of the emp table to a file:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE emp2file 
IS
   fileID UTL_FILE.FILE_TYPE;
BEGIN
   fileID := UTL_FILE.FOPEN ('/tmp', 'emp.dat', 'W');

   /* Quick and dirty construction here! */
   FOR emprec IN (SELECT * FROM emp)
   LOOP
      UTL_FILE.PUT_LINE 
         (TO_CHAR (emprec.empno) || ',' ||
          emprec.ename || ',' ||
          ...
          TO_CHAR (emprec.deptno));
   END LOOP;

   UTL_FILE.FCLOSE (fileID);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A call to PUT_LINE is equivalent to a call to PUT followed by a call to NEW_LINE. It is also equivalent to a call to PUTF with a format string of "%s\n" (see the description of PUTF in the next <A
CLASS="indexterm"
NAME="ch06-idx-13850-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13850-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13850-2"
></A
>section).</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.4.4"
>6.2.4.4 The UTL_FILE.PUTF procedure</A
></H4
><P
CLASS="para"
>Like PUT, <A
CLASS="indexterm"
NAME="ch06-idx-13852-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13852-1"
></A
>PUTF puts data into a file, but it uses a message format (hence, the "F" in "PUTF") to interpret the different elements to be placed in the file. You can pass between one and five different items of data to PUTF. Here's the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_FILE.PUTF
    (file IN FILE_TYPE
    ,format IN VARCHAR2
    ,arg1 IN VARCHAR2 DEFAULT NULL
    ,arg2 IN VARCHAR2 DEFAULT NULL
    ,arg3 IN VARCHAR2 DEFAULT NULL
    ,arg4 IN VARCHAR2 DEFAULT NULL
    ,arg5 IN VARCHAR2 DEFAULT NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>file</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The file handle returned by a call to FOPEN</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>format</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The string that determines the format of the items in the file; see the following options</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>argN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>An optional argument string; up to five may be specified</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13856-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13856-1"
></A
>format string allows you to substitute the argN values directly into the text written to the file. In addition to "boilerplate" or literal text, the format string may contain the following patterns:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>%s</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>	Directs PUTF to put the corresponding item in the file. You can have up to five %s patterns in the format string, since PUTF will take up to five items.</P
></DD
><DT
CLASS="term"
>\n	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Directs PUTF to put a newline character in the file. There is no limit to the number of \n patterns you may include in a format string.</P
></DD
></DL
><P
CLASS="para"
>The %s formatters are replaced by the argument strings in the order provided. If you do not pass in enough values to replace all of the formatters, then the %s is simply removed from the string before writing it to the file.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.4.4.1"
>6.2.4.4.1 Exceptions</A
></H4
><P
CLASS="para"
>UTL_FILE.PUTF may raise any of the following exceptions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.INVALID_FILEHANDLE
UTL_FILE.INVALID_OPERATION
UTL_FILE.WRITE_ERROR</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.4.4.2"
>6.2.4.4.2 Example</A
></H4
><P
CLASS="para"
>The following example illustrates how to use the format string. Suppose you want the contents of the file to look like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Employee: Steven Feuerstein
Soc Sec #: 123-45-5678
Salary: $1000</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This single call to PUTF will accomplish the task:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.PUTF 
   (file_handle, 'Employee: %s\nSoc Sec #: %s\nSalary: %s',
    'Steven Feuerstein', 
    '123-45-5678', 
    TO_CHAR (:employee.salary, '$9999'));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you need to write out more than five items of data, you can simply call PUTF twice consecutively to finish the job, as shown <A
CLASS="indexterm"
NAME="ch06-idx-13854-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13854-1"
></A
>here:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.PUTF 
   (file_handle, '%s\n%s\n%s\n%s\n%s\n',
    TO_DATE (SYSDATE, 'MM/DD/YYYY'),
    TO_CHAR (:pet.pet_id),
    :pet.name,
    TO_DATE (:pet.birth_date, 'MM/DD/YYYY'),
    :pet.owner);

UTL_FILE.PUTF 
   (file_handle, '%s\n%s\n',
    :pet.bites_mailperson,
    :pet.does_tricks);</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.4.5"
>6.2.4.5 The UTL_FILE.<A
CLASS="indexterm"
NAME="ch06-idx-13857-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13857-1"
></A
>FFLUSH procedure</A
></H4
><P
CLASS="para"
>This procedure makes sure that all pending data for the specified file is written physically out to a file. The header for FFLUSH is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_FILE.FFLUSH (file IN UTL_FILE.FILE_TYPE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where file is the file handle. </P
><P
CLASS="para"
>Your operating system probably buffers physical I/O to improve performance. As a consequence, your program may have called one of the "put" procedures, but when you look at the file, you won't see your data. UTL_FILE.FFLUSH comes in handy when you want to read the contents of a file before you have closed that file. Typical scenarios include analyzing execution trace and debugging <A
CLASS="indexterm"
NAME="ch06-idx-13834-0"
></A
>logs. </P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.4.5.1"
>6.2.4.5.1 Exceptions</A
></H4
><P
CLASS="para"
>FFLUSH may raise any of the following exceptions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.INVALID_FILEHANDLE
UTL_FILE.INVALID_OPERATION
UTL_FILE.WRITE_ERROR</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-2.5"
>6.2.5 Closing Files</A
></H3
><P
CLASS="para"
>Use the FCLOSE and FCLOSE_ALL procedures in closing files.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.5.1"
>6.2.5.1 The UTL_FILE.<A
CLASS="indexterm"
NAME="ch06-idx-13862-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13862-1"
></A
>FCLOSE procedure</A
></H4
><P
CLASS="para"
>Use FCLOSE to close an open file. The header for this procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_FILE.FCLOSE (file IN OUT FILE_TYPE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where file is the file handle. </P
><P
CLASS="para"
>Notice that the argument to UTL_FILE.FCLOSE is an IN OUT parameter, because the procedure sets the id field of the record to NULL after the file is closed.</P
><P
CLASS="para"
>If there is buffered data that has not yet been written to the file when you try to close it, UTL_FILE will raise the WRITE_ERROR exception.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.5.1.1"
>6.2.5.1.1 Exceptions</A
></H4
><P
CLASS="para"
>FCLOSE may raise any of the following exceptions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.INVALID_FILEHANDLE
UTL_FILE.WRITE_ERROR </PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.5.2"
>6.2.5.2 The UTL_FILE.<A
CLASS="indexterm"
NAME="ch06-idx-13863-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13863-1"
></A
>FCLOSE_ALL procedure</A
></H4
><P
CLASS="para"
>FCLOSE_ALL closes all of the opened files. The header for this procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_FILE.FCLOSE_ALL;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This procedure will come in handy when you have opened a variety of files and want to make sure that none of them are left open when your program terminates. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13867-0"
></A
>In programs in which files have been opened, you should also call FCLOSE_ALL in exception handlers in programs. If there is an abnormal termination of the program, files will then still be closed.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN OTHERS
   
THEN
      UTL_FILE.FCLOSE_ALL;
      ... other clean up activities ...
END;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> <A
CLASS="indexterm"
NAME="ch06-idx-13868-0"
></A
>When you close your files with the FCLOSE_ALL procedure, none of your file handles will be marked as closed (the id field, in other words, will still be non-NULL). The result is that any calls to IS_OPEN for those file handles will <EM
CLASS="emphasis"
>still</EM
> return TRUE. You will not, however, be able to perform any read or write operations on those files (unless you reopen <A
CLASS="indexterm"
NAME="ch06-idx-13865-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13865-1"
></A
>them).</P
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch06-SECT-2.5.2.1"
>6.2.5.2.1 Exceptions</A
></H4
><P
CLASS="para"
>FCLOSE_ALL may raise the following exception:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UTL_FILE.WRITE_ERROR </PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-2.6"
>6.2.6 Tips on Using UTL_FILE</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13869-0"
></A
>This section contains a variety of tips on using UTL_FILE to its full potential.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-21255"
>6.2.6.1 Handling file I/O errors</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13871-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13871-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13871-2"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13871-3"
></A
>You may encounter a number of difficulties (and therefore raise exceptions) when working with operating system files. The good news is that Oracle has predefined a set of exceptions specific to the UTL_FILE package, such as UTL_FILE.INVALID_FILEHANDLE. The bad news is that these are all "user-defined exceptions," meaning that if you call <A
CLASS="indexterm"
NAME="ch06-idx-13879-0"
></A
>SQLCODE to see what the error is, you get a value of 1, regardless of the exception. And a call to <A
CLASS="indexterm"
NAME="ch06-idx-13880-0"
></A
>SQLERRM returns the less-than-useful string "User-Defined Exception."</P
><P
CLASS="para"
>To understand the problems this causes, consider the following program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE file_action 
IS
   fileID UTL_FILE.FILE_TYPE;
BEGIN
   fileID := UTL_FILE.FOPEN ('c:/tmp', 'lotsa.stf', 'R');
   UTL_FILE.PUT_LINE (fileID, 'just the beginning');
   UTL_FILE.FCLOSE (fileID);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It is filled with errors, as you can see when I try to execute the program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec file_action
declare
*
ERROR at line 1:
ORA-06510: PL/SQL: unhandled user-defined exception
ORA-06512: at &quot;SYS.UTL_FILE&quot;, line 91
ORA-06512: at &quot;SYS.UTL_FILE&quot;, line 146
ORA-06512: at line 4</PRE
></BLOCKQUOTE
><P
CLASS="para"
>But what error or errors? Notice that the only information you get is that it was an "unhandled user-defined exception"&nbsp;-- even though Oracle defined the exception! </P
><P
CLASS="para"
>The bottom line is that if you want to get more information out of the UTL_FILE-related errors in your code, you need to add exception handlers designed explicitly to trap UTL_FILE exceptions and <EM
CLASS="emphasis"
>tell you</EM
> which one was raised. The following template exception section offers that capability. It includes an exception handler for each UTL_FILE exception. The handler writes out the name of the exception and then reraises the exception. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch06-idx-15321-0"
></A
>fileexc.sql */*
EXCEPTION
   WHEN UTL_FILE.INVALID_PATH
   THEN 
       DBMS_OUTPUT.PUT_LINE ('invalid_path'); RAISE;

   WHEN UTL_FILE.INVALID_MODE
   THEN 
       DBMS_OUTPUT.PUT_LINE ('invalid_mode'); RAISE;

   WHEN UTL_FILE.INVALID_FILEHANDLE
   THEN 
       DBMS_OUTPUT.PUT_LINE ('invalid_filehandle'); RAISE;

   WHEN UTL_FILE.INVALID_OPERATION
   THEN 
       DBMS_OUTPUT.PUT_LINE ('invalid_operation'); RAISE;

   WHEN UTL_FILE.READ_ERROR
   THEN  
       DBMS_OUTPUT.PUT_LINE ('read_error'); RAISE;

   WHEN UTL_FILE.WRITE_ERROR
   THEN 
      DBMS_OUTPUT.PUT_LINE ('write_error'); RAISE;

   WHEN UTL_FILE.INTERNAL_ERROR
   THEN 
      DBMS_OUTPUT.PUT_LINE ('internal_error'); RAISE;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If I add this exception section to my file_action procedure, I get this message,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @temp
invalid_operation
declare
*
ERROR at line 1:
ORA-06510: PL/SQL: unhandled user-defined exception</PRE
></BLOCKQUOTE
><P
CLASS="para"
>which helps me realize that I am trying to write to a read-only file. So I change the file mode to "W" and try again, only to receive the same error again! Additional analysis reveals that my file location is not valid. It should be "C:\temp" instead of "C:/tmp". So why didn't I get a UTL_FILE.INVALID_PATH exception? Who is to say? With those two changes made, file_action then ran without error.</P
><P
CLASS="para"
>I suggest that whenever you work with UTL_FILE programs, you include either all or the relevant part of <EM
CLASS="emphasis"
>fileexc.sql</EM
>. (See each program description earlier in this chapter to find out which exceptions each program might raise.) Of course, you might want to change my template. You may not want to reraise the exception. You may want to display other information. Change whatever you need to change&nbsp;-- just remember the basic rule that if you don't handle the UTL_FILE exception by name in the block in which the error was raised, you won't be able to tell what went <A
CLASS="indexterm"
NAME="ch06-idx-13873-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13873-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13873-2"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13873-3"
></A
>wrong.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.6.2"
>6.2.6.2 Closing unclosed files</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13882-0"
></A
>As a corollary to the last section on handling I/O errors, you must be very careful to close files when you are done working with them, or when errors occur in your program. If not, you may sometimes have to resort to UTL_FILE.FCLOSE_ALL to close <EM
CLASS="emphasis"
>all</EM
> your files before you can get your programs to work properly.</P
><P
CLASS="para"
>Suppose you open a file (and get a handle to that file) and then your program hits an error and fails. Suppose further that you do <EM
CLASS="emphasis"
>not</EM
> have an exception section, so the program simply fails. So let's say that you fix the bug and rerun the program. Now it fails with UTL_FILE.INVALID_OPERATION. The problem is that your file is still open&nbsp;-- and you have lost the handle to the file, so you cannot explicitly close just that one file.</P
><P
CLASS="para"
>Instead, you must now issue this command (here, from SQL*Plus):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec UTL_FILE.FCLOSE_ALL</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With any luck, you won't close files that you wanted to be left open in your session. As a consequence, I recommend that you always include calls to UTL_FILE.FCLOSE in each of your exception sections to avoid the need to call FCLOSE_ALL and to minimize extraneous INVALID_OPERATION exceptions.</P
><P
CLASS="para"
>Here is the kind of exception section you should consider including in your programs. (I use the PLVexc.recNstop handler from PL/Vision as an example of a high-level program to handle exceptions, in this case requesting that the program "record and then stop.")</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN OTHRES
   THEN
      UTL_FILE.FCLOSE (ini_fileID);
      UTL_FILE.FCLOSE (new_fileID);
      PLVexc.recNstop;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, I close the two files I've been working with, and then handle the <A
CLASS="indexterm"
NAME="ch06-idx-13884-0"
></A
>exception.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.6.3"
>6.2.6.3 Combining locations and filenames</A
></H4
><P
CLASS="para"
>I wonder if anyone else out there in the PL/SQL world finds UTL_FILE as frustrating as I do. I am happy that Oracle built the package, but I sure wish they'd given us more to work with. I am bothered by these things:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The need to separate my filename from the location. Most of the time when I work with files, those two pieces are stuck together. With UTL_FILE, I have to split them apart. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The lack of support for paths. It would be nice to not have to provide a file location and just let UTL_FILE <EM
CLASS="emphasis"
>find</EM
> my file for me. </P
></LI
></UL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13886-0"
></A
>This section shows you how to enhance UTL_FILE to allow you to pass in a "combo" filename: location and name joined together, as we so often encounter them. The next section explains the steps for adding path support to your manipulation of files with UTL_FILE.</P
><P
CLASS="para"
>If you are going to specify your file specification (location and name) in one string, what is the minimum information needed in order to separate these two elements to pass to FOPEN? The delimiter used to separate directories from filenames. In DOS (and Windows) that delimiter is "\". In UNIX it is "/". In VAX/VMS it is "]". Seems to me that I just have to find the <EM
CLASS="emphasis"
>last</EM
> occurrence of this delimiter in your string and that will tell me where to break apart the string.</P
><P
CLASS="para"
>So to allow you to get around splitting up your file specification in your call to FOPEN, I can do the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Give you a way to tell me in advance the operating system delimiter for directories&nbsp;-- and store that value for use in future attempts to open files.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Offer you a substitute FOPEN procedure that uses that delimiter.</P
></LI
></UL
><P
CLASS="para"
>Since I want to store that value for your entire session, I will need a package. (You can also use a database table so that you do not have to specify this value each time you start up your application.) Here is the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch06-idx-13890-0"
></A
>onestring.spp */*
CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch06-idx-13891-0"
></A
>fileIO
IS
   PROCEDURE setsepchar (str IN VARCHAR2);
   FUNCTION sepchar RETURN VARCHAR2;

   FUNCTION open (file IN VARCHAR2, filemode IN VARCHAR2)
      RETURN UTL_FILE.FILE_TYPE;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, I set the separation character or delimiter with a call to fileIO.setsepchar, and I can retrieve the current value with a call to the fileIO.sepchar function. Once I have that value, I can call fileIO.open to open a file without having to split apart the location and name. I show an example of this program in use here:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   fid UTL_FILE.FILE_TYPE;
BEGIN
   fileIO.setsepchar ('\');
   fid := fileio.open ('c:\temp\newone.txt', 'w'));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The body of this package is quite straightforward:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PACKAGE BODY fileIO
IS
   g_sepchar CHAR(1) := '/'; /* Unix is, after all, dominant. */

   PROCEDURE <A
CLASS="indexterm"
NAME="ch06-idx-13895-0"
></A
>setsepchar (str IN VARCHAR2)
   IS
   BEGIN
      g_sepchar := NVL (str, '/');
   END;

   FUNCTION<A
CLASS="indexterm"
NAME="ch06-idx-13896-0"
></A
> sepchar RETURN VARCHAR2
   IS
   BEGIN
      RETURN g_sepchar;
   END;

   FUNCTION <A
CLASS="indexterm"
NAME="ch06-idx-13897-0"
></A
>open (file IN VARCHAR2, filemode IN VARCHAR2)
      RETURN UTL_FILE.FILE_TYPE
   IS
      v_loc PLS_INTEGER := INSTR (file, g_sepchar, -1);
      retval UTL_FILE.FILE_TYPE;
   BEGIN
      RETURN UTL_FILE.FOPEN 
         (SUBSTR (file, 1, v_loc-1),
          SUBSTR (file, v_loc+1),
          filemode);
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that when I call INSTR I pass -1 for the third argument. This negative value tells the built-in to scan from the end of string backwards to the <EM
CLASS="emphasis"
>first</EM
> occurrence of the <A
CLASS="indexterm"
NAME="ch06-idx-13893-0"
></A
>specified <A
CLASS="indexterm"
NAME="ch06-idx-13888-0"
></A
>character.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.6.4"
>6.2.6.4 Adding support for paths</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13898-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13898-1"
></A
>Why should I have to provide the directory name for my file each time I call FOPEN to read that file? It would be so much easier to specify a path, a list of possible directories, and then just let UTL_FILE scan the different directories in the specified order until the file is found. </P
><P
CLASS="para"
>Even though the notion of a path is not built into UTL_FILE, it is easy to add this feature. The structure of the implementation is very similar to the package built to combine file locations and names. I will need a package to receive and store the path, or list of directories. I will need an alternative open procedure that uses the path instead of a provided location. Here is the package specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch06-idx-13902-0"
></A
> filepath.spp */*
CREATE OR REPLACE PACKAGE<A
CLASS="indexterm"
NAME="ch06-idx-13903-0"
></A
> fileIO
IS
   c_delim CHAR(1) := ';';

   PROCEDURE setpath (str IN VARCHAR2);
   FUNCTION path RETURN VARCHAR2;

   FUNCTION open (file IN VARCHAR2, filemode IN VARCHAR2) 
      RETURN UTL_FILE.FILE_TYPE;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I define the path delimiter as a constant so that a user of the package can see what he should use to separate different directories in his path. I provide a procedure to set the path and a function to get the path&nbsp;-- but the variable containing the path is hidden away in the package body to protect its integrity.</P
><P
CLASS="para"
>Before exploring the implementation of this package, let's see how you would use these programs. The following test script sets a path with two directories and then displays the first line of code in the file containing the previous package:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch06-idx-13904-0"
></A
> filepath.tst */*
DECLARE
   fID UTL_FILE.FILE_TYPE;
   v_line VARCHAR2(2000);
BEGIN
   fileio.setpath ('c:\temp;d:\oreilly\builtins\code');
   fID := fileIO.open ('filepath.spp');
   UTL_FILE.GET_LINE (fID, v_line);
   DBMS_OUTPUT.PUT_LINE (v_line);
   UTL_FILE.FCLOSE (fID);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I include a trace message in the package (commented out on the companion disk) so that we can watch the path-based open doing its work:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @filepath.tst
...looking in c:\temp
...looking in d:\oreilly\builtins\code
CREATE OR REPLACE PACKAGE fileIO</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It's nice having programs do your work for you, isn't it? Here is the implementation of the fileIO package with path usage:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch06-idx-13905-0"
></A
> filepath.spp */*
CREATE OR REPLACE PACKAGE BODY<A
CLASS="indexterm"
NAME="ch06-idx-13906-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13906-1"
></A
> fileIO
IS
   g_path VARCHAR2(2000);

   PROCEDURE <A
CLASS="indexterm"
NAME="ch06-idx-13907-0"
></A
>setpath (str IN VARCHAR2)
   IS 
   BEGIN
      g_path := str;
   END;

   FUNCTION <A
CLASS="indexterm"
NAME="ch06-idx-13908-0"
></A
>path RETURN VARCHAR2
   IS
   BEGIN
      RETURN g_path;
   END;

   FUNCTION<A
CLASS="indexterm"
NAME="ch06-idx-13909-0"
></A
> open (file IN VARCHAR2, filemode IN VARCHAR2) 
      RETURN UTL_FILE.FILE_TYPE
   IS
      /* Location of next path separator */
      v_lastsep PLS_INTEGER := 1;
      v_sep PLS_INTEGER := INSTR (g_path, c_delim);
      v_dir VARCHAR2(500);
      retval UTL_FILE.FILE_TYPE;
   BEGIN     
      /* For each directory in the path, attempt to open the file. */ 
      LOOP
         BEGIN
            IF v_sep = 0
            THEN
               v_dir := SUBSTR (g_path, v_lastsep);
            ELSE
               v_dir := SUBSTR (g_path, v_lastsep, v_sep - v_lastsep);
            END IF;
            retval := UTL_FILE.FOPEN (v_dir, file, 'R');
            EXIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               IF v_sep = 0
               THEN
                  RAISE;
               ELSE
                  v_lastsep := v_sep + 1;
                  v_sep := INSTR (g_path, c_delim, v_sep+1); 
               END IF;
         END;
      END LOOP;
      RETURN retval;
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The logic in this fileio.open is a little bit complicated, because I need to parse the semicolon-delimited list. The v_sep variable contains the location in the path of the next delimiter. The v_lastsep variable contains the location of the last delimiter. I have to include special handling for recognizing when I am at the last directory in the path (v_sep equals 0). Notice that I do not hard-code the semi-colon into this program. Instead, I reference the c_delim constant. </P
><P
CLASS="para"
>The most important implementation detail is that I place the call to FOPEN inside a <EM
CLASS="emphasis"
>loop</EM
>. With each iteration of the loop body, I extract a directory from the path. Once I have the next directory to search, I call the FOPEN function to see if I can read the file. If I am able to do so successfully, I will reach the next line of code inside my loop, which is an EXIT statement: I am done and can leave. This drops me down to the RETURN statement to send back the handle to the file. </P
><P
CLASS="para"
>If I am unable to read the file in that directory, UTL_FILE raises an exception. Notice that I have placed the entire body of my loop inside its own anonymous block. This allows me to trap the open failure and process it. If I am on my last directory (no more delimiters, as in v_sep equals 0), I will simply reraise the exception from UTL_FILE. This will cause the loop to terminate, and then end the function execution as well. Since the fileIO.open does not have its own exception section, the error will be propagated out of the function unhandled. Even with a path, I was unable to locate the file. If, however, there are more directories, I set my start and end points for the next SUBSTR from the path and go back to the top of the loop so that FOPEN can try again.</P
><P
CLASS="para"
>If you do decide to use utilities like the path-based open shown previously, you should consider the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Combine the logic in <EM
CLASS="emphasis"
>filepath.spp</EM
> with <EM
CLASS="emphasis"
>onestring.spp</EM
> (a version of open that lets you pass the location and name in a single string). I should be able to <EM
CLASS="emphasis"
>override</EM
> the path by providing a location; the version shown in this section assumes that the filename never has a location in it.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Allow users to add a directory to the path without having to concatenate it to a string with a semicolon between them. Why not build a procedure called fileIO.adddir that does the work for the user and allows an application to modify the path at <A
CLASS="indexterm"
NAME="ch06-idx-13900-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13900-1"
></A
>runtime?</P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.6.5"
>6.2.6.5 You closed what?</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13910-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13910-1"
></A
>You might run into some interesting behavior with the IS_OPEN function if you treat your file handles as variables. You are not likely to do this, but I did, so I thought I would pass on my findings to you.</P
><P
CLASS="para"
>In the following script, I define two file handles. I then open a file, assigning the handle record generated by FOPEN to fileID1. I immediately assign that record to fileID2. They now both have the same record contents. I then close the file by passing fileID2 to FCLOSE and check the status of the file afterwards. Finally, I assign a value of NULL to the id field of fileID1 and call IS_OPEN again.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   fileID1 UTL_FILE.FILE_TYPE;
   fileID2 UTL_FILE.FILE_TYPE;
BEGIN
   fileID1 := UTL_FILE.FOPEN ('c:\temp', 'newdata.txt', 'W');
   fileID2 := fileID1;
   UTL_FILE.FCLOSE (fileID2);

   IF UTL_FILE.IS_OPEN (fileid1)
   THEN
      DBMS_OUTPUT.PUT_LINE ('still open');
   END IF;

   fileid1.id := NULL;
   IF NOT UTL_FILE.IS_OPEN (fileid1)
   THEN
      DBMS_OUTPUT.PUT_LINE ('now closed');
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Let's run the script and check out the results:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @temp
still open
now closed</PRE
></BLOCKQUOTE
><P
CLASS="para"
>We can conclude from this test that the IS_OPEN function returns TRUE if the id field of a UTL_FILE.FILE_TYPE record is NULL. It doesn't check the status of the file with the operating system. It is a check totally internal to UTL_FILE. </P
><P
CLASS="para"
>This will not cause any problems as long as (a) you don't muck around with the id field of your file handle records and (b) you are consistent with your use of file handles. In other words, if you assign one file record to another, use that new record for all operations. Don't go back to using the <A
CLASS="indexterm"
NAME="ch06-idx-13870-0"
></A
>original.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-2.7"
>6.2.7 UTL_FILE Examples</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13911-0"
></A
>So you've got a file (or a dozen files) out on disk, filled with all sorts of good information you want to access from your PL/SQL-based application. You will find yourself performing the same kinds of operations against those files over and over again. </P
><P
CLASS="para"
>After you work your way through this book, I hope that you will recognize almost without conscious thought that you do not want to repeatedly build the open, read, and close operations for each of these files, for each of the various recurring operations. Instead, you will instantly say to yourself, "Hot diggity! This is an opportunity to build a set of standard, generic modules that will help manage my files." </P
><P
CLASS="para"
>This section contains a few of my candidates for the first contributions to a UTL_FILE toolbox of utilities. I recommend that you consider building a single package to contain all of these utilities.[<A
CLASS="footnote"
HREF="#ch06-pgfId-5829"
>4</A
>] </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch06-pgfId-5829"
>[4]</A
> You will find an example of such a package in <CITE
CLASS="citetitle"
>Chapter 13</CITE
> of <CITE
CLASS="citetitle"
>Advanced Oracle PL/SQL Programming with Packages</CITE
>.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.7.1"
>6.2.7.1 Enhancing UTL_FILE.GET_LINE</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch06-idx-13913-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13913-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13913-2"
></A
>GET_LINE procedure is simple and straightforward. It gets the next line from the file. If the pointer to the file is already located at the last line of the file, UTL_FILE.GET_LINE does not return data, but instead raises the NO_DATA_FOUND exception. Whenever you write programs using GET_LINE, you will therefore need to handle this exception. Let's explore the different ways you can do this.</P
><P
CLASS="para"
>The following example uses a loop to read the contents of a file into a PL/SQL table (whose type definition, tabpkg.names_tabtype, has been declared previously):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch06-idx-13921-0"
></A
>file2tab.sp */*
CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch06-idx-13922-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13922-1"
></A
>tabpkg 
IS
   TYPE names_tabtype IS TABLE OF VARCHAR2(100)
      INDEX BY BINARY_INTEGER;
END;
/
CREATE OR REPLACE PROCEDURE <A
CLASS="indexterm"
NAME="ch06-idx-13923-0"
></A
>file_to_table 
   (loc_in IN VARCHAR2, file_in IN VARCHAR2, 
    table_in IN OUT tabpkg.names_tabtype)
IS
	/* Open file and get handle right in declaration */
	names_file UTL_FILE.FILE_TYPE := UTL_FILE.FOPEN (loc_in, file_in, 'R');
	/* Counter used to store the Nth name. */
	line_counter INTEGER := 1;
BEGIN
	LOOP
		UTL_FILE.GET_LINE (names_file, table_in(line_counter));
		line_counter := line_counter + 1;
	END LOOP;
EXCEPTION
	WHEN NO_DATA_FOUND
	THEN
		UTL_FILE.FCLOSE (names_file);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The file_to_table procedure uses an infinite loop to read through the contents of the file. Notice that there is no EXIT statement within the loop to cause the loop to terminate. Instead I rely on the fact that the UTL_FILE package raises a NO_DATA_FOUND exception once it goes past the end-of-file marker and short-circuits the loop by transferring control to the exception section. The exception handler then traps that exception and closes the file.</P
><P
CLASS="para"
>I am not entirely comfortable with this approach. I don't like to code infinite loops without an EXIT statement; the termination condition is not structured into the loop itself. Furthermore, the end-of-file condition is not really an exception; every file, after all, must end at some point. </P
><P
CLASS="para"
>I believe that a better approach to handling the end-of-file condition is to build a layer of code around GET_LINE that immediately checks for end-of-file and returns a Boolean value (TRUE or FALSE). The<A
CLASS="indexterm"
NAME="ch06-idx-13924-0"
></A
>get_nextline procedure shown here embodies this principle.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: g<A
CLASS="indexterm"
NAME="ch06-idx-13928-0"
></A
>etnext.sp */*
PROCEDURE get_nextline 
   (file_in IN UTL_FILE.FILE_TYPE, 
    line_out OUT VARCHAR2, 
    eof_out OUT BOOLEAN)
IS
BEGIN
   UTL_FILE.GET_LINE (file_in, line_out);
   eof_out := FALSE;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      line_out := NULL;
      eof_out  := TRUE;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The get_nextline procedure accepts an already assigned file handle and returns two pieces of information: the line of text (if there is one) and a Boolean flag (set to TRUE if the end-of-file is reached, FALSE otherwise). Using get_nextline, I can now read through a file with a loop that has an EXIT statement. </P
><P
CLASS="para"
>My file_to_table procedure will look like the following after adding get_nextline:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: f<A
CLASS="indexterm"
NAME="ch06-idx-13929-0"
></A
>il2tab2.sp */*
PROCEDURE <A
CLASS="indexterm"
NAME="ch06-idx-13930-0"
></A
>file_to_table 
   (loc_in IN VARCHAR2, file_in IN VARCHAR2, 
   table_in IN OUT names_tabtype)
IS
   /* Open file and get handle right in declaration */
   names_file CONSTANT UTL_FILE.FILE_TYPE := 
      UTL_FILE.FOPEN (loc_in, file_in, 'R');

   /* counter used to create the Nth name. */
   line_counter INTEGER := 1;

   end_of_file BOOLEAN := FALSE;
BEGIN
   WHILE NOT end_of_file
   LOOP
      get_nextline (names_file, table_in(line_counter), end_of_file);
      line_counter := line_counter + 1;
   END LOOP;
   UTL_FILE.FCLOSE (names_file);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With get_nextline, I no longer treat end-of-file as an exception. I read a line from the file until I am done, and then I close the file and exit. This is, I believe, a more straightforward and easily <A
CLASS="indexterm"
NAME="ch06-idx-13926-0"
></A
>understood <A
CLASS="indexterm"
NAME="ch06-idx-13944-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13944-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13944-2"
></A
>program. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.7.2"
>6.2.7.2 Creating a file</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13931-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13931-1"
></A
>A common way to use files does not involve the contents of the file as much as a confirmation that the file does in fact exist. You can use the two modules defined next to create a file and then check to see if that file exists. Notice that when I create a file in this type of situation, I do not even bother to return the handle to the file. The purpose of the first program, create_file, is simply to make sure that a file with the specified name (and optional line of text) is out there on disk.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch06-idx-13946-0"
></A
> crefile.sp */*
PROCEDURE <A
CLASS="indexterm"
NAME="ch06-idx-13947-0"
></A
>create_file 
   (loc_in IN VARCHAR2, file_in IN VARCHAR2, line_in IN VARCHAR2 := NULL)
IS
   file_handle UTL_FILE.FILE_TYPE;
BEGIN
   /* 
   || Open the file, write a single line and close the file.
   */
   file_handle := UTL_FILE.FOPEN (loc_in, file_in, 'W');
   IF line_in IS NOT NULL
   THEN
      UTL_FILE.PUT_LINE (file_handle, line_in);
   ELSE
      UTL_FILE.PUT_LINE 
         (file_handle, 'I make my disk light blink, therefore I am.');
   END IF;
   UTL_FILE.FCLOSE (file_handle);
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.7.3"
>6.2.7.3 Testing for a file's existence</A
></H4
><P
CLASS="para"
>The second program checks to see if a file exists. Notice that it creates a local procedure to handle the close logic (which is called both in the body of the function and in the exception section). </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companon disk: <A
CLASS="indexterm"
NAME="ch06-idx-13948-0"
></A
>filexist.sf */*
CCREATE OR REPLACE FUNCTION<A
CLASS="indexterm"
NAME="ch06-idx-13949-0"
></A
> file_exists 
   (loc_in IN VARCHAR2, 
    file_in IN VARCHAR2,
    close_in IN BOOLEAN := FALSE)
   RETURN BOOLEAN
IS
   file_handle UTL_FILE.FILE_TYPE;
   retval BOOLEAN;

   PROCEDURE closeif IS
   BEGIN
      IF close_in AND UTL_FILE.IS_OPEN (file_handle) 
      THEN
         UTL_FILE.FCLOSE (file_handle);
      END IF;
   END;
BEGIN
   /* Open the file. */
   file_handle := UTL_FILE.FOPEN (loc_in, file_in, 'R');

   /* Return the result of a check with IS_OPEN. */
   retval := UTL_FILE.IS_OPEN (file_handle);

   closeif;

   RETURN retval;
EXCEPTION
   WHEN OTHERS 
   THEN
      closeif;
      <A
CLASS="indexterm"
NAME="ch06-idx-13939-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13939-1"
></A
>RETURN FALSE;
 END;
/
</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.7.4"
>6.2.7.4 Searching a file for a string</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13958-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13958-1"
></A
>Because I found the INSTR function to be so useful, I figured that this same kind of operation would also really come in handy with operating system files. The line_with_text function coming up shortly returns the line number in a file containing the specified text. The simplest version of such a function would have a specification like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION <A
CLASS="indexterm"
NAME="ch06-idx-13960-0"
></A
>line_with_text 
   (loc_in IN VARCHAR2, file_in IN VARCHAR2, text_in IN VARCHAR2)
RETURN INTEGER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, given a location, a filename, and a chunk of text, find the first line in the file that contains the text. You could call this function as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF line_with_text ('h:\pers', 'names.vp', 'Hanubi') &gt; 0
THEN
   MESSAGE ('Josephine Hanubi is a vice president!');
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The problem with this version of line_with_text is its total lack of vision. What if I want to find the second occurrence in the file? What if I need to start my search from the tenth line? What if I want to perform a case-insensitive search? None of these variations are supported.</P
><P
CLASS="para"
>I urge you strongly to think through all the different ways a utility like line_with_text might be used before you build it. Don't just build for today's requirement. Anticipate what you will need tomorrow and next week as well. </P
><P
CLASS="para"
>For line_with_text, a broader vision would yield a specification like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION line_with_text 
   (loc_in IN VARCHAR2,
    file_in IN VARCHAR2, 
    text_in IN VARCHAR2, 
    occurrence_in IN INTEGER := 1,
    start_line_in IN INTEGER := 1,
    end_line_in IN INTEGER := 0,
    ignore_case_in IN BOOLEAN := TRUE)
RETURN INTEGER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Wow! That's a lot more parameter passing. Let's take a look at the kind of flexibility we gain from these additional arguments. First, the following table provides a description of each parameter.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>loc_in</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The location of the file on the operating system</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>file_in</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the file to be opened</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>text_in</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The chunk of text to be searched for in each line of the file</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>occurrence_in</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The number of times the text should be found in distinct lines in the file before the function returns the line number</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>srart_line_in</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The first line in the file from which the function should start its search</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>end_line_in</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The last line in the file to which the function should continue its search; if zero, then search through end of file</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ignore_case_in</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Indicates whether the case of the file contents and text_in should be ignored when checking for its presence in the line</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Notice that all the new parameters, occurrence_in through ignore_case_in, have default values, so I can call this function in precisely the same way and with the same results as the first, limited version:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF line_with_text ('names.vp', 'Hanubi') &gt; 0
THEN
   MESSAGE ('Josephine Hanubi is a vice president!');
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now, however, I can also do so much more:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Confirm that the role assigned to this user is SUPERVISOR:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	line_with_text ('c:\temp', 'config.usr', 'ROLE=SUPERVISOR')</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Find the second occurrence of DELETE starting with the fifth line:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	line_with_text ('/tmp', 'commands.dat', 'delete', 2, 5)</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Verify that the third line contains a terminal type specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>	line_with_text ('g:\apps\user\', 'setup.cfg', 'termtype=', 1, 3, 3)</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
>Here is the code for the line_with_text function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch06-idx-13966-0"
></A
> linetext.sf */*
CREATE OR REPLACE FUNCTION line_with_text 
   (loc_in IN VARCHAR2,
    file_in IN VARCHAR2, 
    text_in IN VARCHAR2, 
    occurrence_in IN INTEGER := 1,
    start_line_in IN INTEGER := 1,
    end_line_in IN INTEGER := 0,
    ignore_case_in IN BOOLEAN := TRUE)
RETURN INTEGER
/*
|| An &quot;INSTR&quot; for operating system files. Returns the line number of
|| a file in which a text string was found.
*/
IS
   /* Handle to the file. Only will open if arguments are valid. */
   file_handle UTL_FILE.FILE_TYPE;

   /* Holds a line of text from the file. */
   line_of_text VARCHAR2(1000);

   text_loc INTEGER;
   found_count INTEGER := 0;

   /* Boolean to determine if there are more values to read */
   no_more_lines BOOLEAN := FALSE;

   /* Function return value */
   return_value INTEGER := 0;
BEGIN
   /* Assert valid arguments. If any fail, return NULL. */
   IF loc_in IS NULL OR
      file_in IS NULL OR
      text_in IS NULL OR
      occurrence_in &lt;= 0 OR
      start_line_in &lt; 1 OR
      end_line_in &lt; 0
   THEN
      return_value := NULL;
   ELSE
      /* All arguments are fine. Open and read through the file. */
      file_handle := UTL_FILE.FOPEN (loc_in, file_in, 'R');
      LOOP
         /* Get next line and exit if at end of file. */
         get_nextline (file_handle, line_of_text, no_more_lines);
         EXIT WHEN no_more_lines;

         /* Have another line from file. */
         return_value := return_value + 1;

         /* If this line is between the search range... */
         IF (return_value BETWEEN start_line_in AND end_line_in) OR
            (return_value &gt;= start_line_in AND end_line_in = 0)
         THEN
            /* Use INSTR to see if text is present. */
            IF NOT ignore_case_in
            THEN
               text_loc := INSTR (line_of_text, text_in);
            ELSE
               text_loc := INSTR (UPPER (line_of_text), UPPER (text_in));
            END IF;

            /* If text location is positive, have a match. */
            IF text_loc &gt; 0
            THEN
               /* Increment found counter. Exit if matches request. */
               found_count := found_count + 1;
               EXIT WHEN found_count = occurrence_in;
            END IF;
         END IF;
      END LOOP;
      UTL_FILE.FCLOSE (file_handle);
   END IF;

   IF no_more_lines
   THEN
      /* read through whole file without success. */
      return_value := NULL;
   END IF;

   <A
CLASS="indexterm"
NAME="ch06-idx-13964-0"
></A
>RETURN return_value;
<A
CLASS="indexterm"
NAME="ch06-idx-13952-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13952-1"
></A
>END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.7.5"
>6.2.7.5 Getting the nth line from a file</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-13968-0"
></A
>What if you want to get a specific line from a file? The following function takes a filename and a line number and returns the text found on that line:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:<A
CLASS="indexterm"
NAME="ch06-idx-15333-0"
></A
> nthline.sf */*
CREATE OR REPLACE FUNCTION get_nth_line 
   (loc_in IN VARCHAR2, file_in IN VARCHAR2, line_num_in IN INTEGER)
IS
   /* Handle to the file. Only will open if arguments are valid. */
   file_handle UTL_FILE.FILE_TYPE;

   /* Count of lines read from the file. */
   line_count INTEGER := 0;

   /* Boolean to determine if there are more values to read */
   no_more_lines BOOLEAN := FALSE;

   /* Function return value */
   return_value VARCHAR2(1000) := NULL;
BEGIN
   /* Need a file name and a positive line number. */
   IF file_in IS NOT NULL AND line_num_in &gt; 0
   THEN
      /* All arguments are fine. Open and read through the file. */
      file_handle := UTL_FILE.FOPEN (loc_in, file_in, 'R');
      LOOP
         /* Get next line from file. */
         get_nextline (file_handle, return_value, no_more_lines);

         /* Done if no more lines or if at the requested line. */
         EXIT WHEN no_more_lines OR line_count = line_num_in - 1;

         /* Otherwise, increment counter and read another line. */
         line_count := line_count + 1;
      END LOOP;
      UTL_FILE.FCLOSE (file_handle);
   END IF;

   /* Either NULL or contains last line read from file. */
   <A
CLASS="indexterm"
NAME="ch06-idx-13912-0"
></A
>RETURN return_value;
<A
CLASS="indexterm"
NAME="ch06-idx-13756-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-13756-1"
></A
>END;

</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_01.htm"
TITLE="6.1 DBMS_OUTPUT: Displaying Output"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.1 DBMS_OUTPUT: Displaying Output"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch07_01.htm"
TITLE="7. Defining an Application Profile"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7. Defining an Application Profile"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.1 DBMS_OUTPUT: Displaying Output</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>7. Defining an Application Profile</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
