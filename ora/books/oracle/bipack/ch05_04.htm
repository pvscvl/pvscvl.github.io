<HTML
><HEAD
><TITLE
>[Chapter 5] 5.4 DBMS_AQ: Interfacing to Oracle AQ (Oracle8 only)</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:50:57Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch05_01.htm"
TITLE="5. Oracle Advanced Queuing"><LINK
REL="prev"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
TITLE="5.3 Oracle AQ Nonprogram Elements"><LINK
REL="next"
HREF="ch05_05.htm"
TITLE="5.5 DBMS_AQADM: Performing AQ  Administrative Tasks (Oracle8 only)"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
TITLE="5.3 Oracle AQ Nonprogram Elements"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.3 Oracle AQ Nonprogram Elements"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch05_01.htm"
TITLE="5. Oracle Advanced Queuing"
>Chapter 5<BR>Oracle Advanced Queuing</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_05.htm"
TITLE="5.5 DBMS_AQADM: Performing AQ  Administrative Tasks (Oracle8 only)"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.5 DBMS_AQADM: Performing AQ  Administrative Tasks (Oracle8 only)"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch05-21214"
>5.4 DBMS_AQ: Interfacing to Oracle AQ (Oracle8 only)</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch05-idx-15997-0"
></A
>DBMS_AQ package provides an interface to the operational tasks of Oracle AQ as performed by the <A
CLASS="indexterm"
NAME="ch05-idx-19047-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-19047-1"
></A
>programs listed in <A
CLASS="xref"
HREF="ch05_04.htm#ch05-SECT-4.1.1"
>Table 5.1</A
>. To use these programs, you must have been granted the new <A
CLASS="indexterm"
NAME="ch05-idx-16001-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16001-1"
></A
>role AQ_USER_ROLE.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch05-21303"
>Table 5.1: DBMS_AQ Programs </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SQL?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ENQUEUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Adds a message to the specified queue.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16074-0"
></A
>DEQUEUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Retrieves a message from the specified queue.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The following sections describe how to call these programs.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-4.1"
>5.4.1 Enqueuing Messages</A
></H3
><P
CLASS="para"
>The ENQUEUE procedure allows you to add a message to a specified queue. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-4.1.1"
>5.4.1.1 The DBMS_AQ.<A
CLASS="indexterm"
NAME="ch05-idx-16002-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16002-1"
></A
>ENQUEUE procedure</A
></H4
><P
CLASS="para"
>Use the ENQUEUE procedure to add a <A
CLASS="indexterm"
NAME="ch05-idx-16006-0"
></A
>message to a particular queue. Here's the header for the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQ.ENQUEUE 
   (queue_name IN VARCHAR2,
    enqueue_options IN DBMS_AQ.ENQUEUE_OPTIONS_T,
    message_properties IN DBMS_AQ.MESSAGE_PROPERTIES_T,
    payload IN &lt;type_name&gt;,
    msgid OUT RAW);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Specifies the name of the queue to which this message should be enqueued. The queue cannot be an exception queue and must have been previously defined by a call to DBMS_AQADM.CREATE_QUEUE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>enqueue_options</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A record containing the enqueuing options, defined using the specified record type. See <A
CLASS="xref"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
>Section 5.3.7, "Enqueue Options Record Type"</A
>" for more details.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>message_properties</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A record containing the message properties, defined using the specified record type. See <A
CLASS="xref"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
>Section 5.3.6, "Message Properties Record Type"</A
>" for more details.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>payload</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The data or payload that is placed on the queue. This is either an object (an instance of an object type), a RAW value, or NULL. The payload must match the specification in the associated queue table. This value is not interpreted by Oracle AQ, so any object type can be passed into the procedure. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>msgid</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>This is the ID number of the message generated by AQ. It is a globally unique identifier that can be used to identify the message at dequeue time. In other words, you can specifically request that the message with this message ID be dequeued next.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-4.1.2"
>5.4.1.2 Examples</A
></H4
><P
CLASS="para"
>The <A
CLASS="xref"
HREF="ch05_07.htm#ch05-SECT-7.5.1"
>Section 5.7</A
> section at the end of this chapter offers many different illustrations of using DBMS_AQ.ENQUEUE to send messages through a queue. In this section, I offer some initial examples to get you familiar with the kind of code you would write when enqueuing messages. In all these cases, assume that I have defined an object type as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE message_type AS OBJECT
   (title VARCHAR2(30),
    text VARCHAR2(2000));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>My AQ administrator created a queue table and a message queue as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXEC DBMS_AQADM.CREATE_QUEUE_TABLE
   (queue_table =&gt; 'msg',
    queue_payload_type =&gt; 'message_type');

EXEC DBMS_AQADM.CREATE_QUEUE
   (queue_name =&gt; 'msgqueue',
    queue_table =&gt; 'msg');

EXEC DBMS_AQADM.START_QUEUE (queue_name =&gt; 'msgqueue');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So now I can enqueue a message to this queue as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19282-0"
></A
>aqenq1.sql */*
DECLARE
   queueopts DBMS_AQ.ENQUEUE_OPTIONS_T;
   msgprops DBMS_AQ.MESSAGE_PROPERTIES_T;
   msgid RAW(16);
   my_msg message_type;
BEGIN
   my_msg := message_type ('First Enqueue', 'May there be many more...');

   DBMS_AQ.ENQUEUE ('msgqueue',
      queueopts,
      msgprops,
      my_msg,
      msgid);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the simplest usage possible of DBMS_AQ.ENQUEUE. I declare my two record structures, because I <EM
CLASS="emphasis"
>must</EM
> pass them in as arguments. I do not, however, modify any of the values in the fields; all have the default values documented in the <A
CLASS="xref"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
>Section 5.3, "Oracle AQ Nonprogram Elements"</A
>" section for the message properties record type. </P
><P
CLASS="para"
>As you can see, the message ID is a RAW of length 16. Rather than hard-coding that declaration again and again in your application, I suggest that you instead declare a subtype that hides that information. My <A
CLASS="indexterm"
NAME="ch05-idx-16008-0"
></A
>aq package (<I
CLASS="filename"
>aq.spp</I
>), for example, offers this predefined type:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>v_msgid RAW(16);
SUBTYPE msgid_type IS v_msgid%TYPE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So when you want to declare a variable to store AQ message IDs, you can do the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   mymsgid aq.msgid_type;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Are you curious about those message IDs? When I ran the previous script, I also asked PL/SQL to display the msgid value with the following statement,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_OUTPUT.PUT_LINE (RAWTOHEX (msgid));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and this is what I saw:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>E2CEA14B51F411D1B977E59CD6EE8E46</PRE
></BLOCKQUOTE
><P
CLASS="para"
>That is certainly a mouthful. When would you use this ID? Well, I can go right back to the data dictionary and ask to see all the <A
CLASS="indexterm"
NAME="ch05-idx-16016-0"
></A
>information about this message. Every time you create a queue table, Oracle AQ creates an underlying database view with the name aq$&lt;queue_table_name&gt;. So if I created a queue table named "msg," I should be able to examine the contents of a table called aq$msg in my own schema.</P
><P
CLASS="para"
>I put together a little SQL*Plus script to show the status and user data for a message:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19252-0"
></A
>aqshomsg.sql */*
SELECT msg_state, user_data
  FROM aq$&amp;1
 WHERE msg_id = HEXTORAW ('&amp;2');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I can then call this script in SQL*Plus to show me the information about the just-queued message as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @aqshomsg msg E2CEA14B51F411D1B977E59CD6EE8E46

MSG_STATE USER_DATA(TITLE, TEXT)
--------- ------------------------------------------------------------------
READY     MESSAGE_TYPE('First Enqueue', 'May there be many more...')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that the query automatically detected the fact that my user_data is in fact an object, and showed me the full contents of that object quite neatly. You can, of course, also see other attributes of the message; see the later section entitled <A
CLASS="xref"
HREF="ch05_06.htm#ch05-SECT-6.2.3"
>Section 5.6</A
> for more details on this table and how best to retrieve information from it.</P
><P
CLASS="para"
>Of course, you will sometimes want to modify the <A
CLASS="indexterm"
NAME="ch05-idx-16021-0"
></A
>message properties or enqueue options before performing your enqueue. To do this, simply change the values of the fields in the record. The following example shows how you can delay the availability of a message for dequeuing by three days and also request that one message be dequeued before another:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19286-0"
></A
>aqenq2.sql */*
DECLARE
   queueopts DBMS_AQ.ENQUEUE_OPTIONS_T;
   msgprops DBMS_AQ.MESSAGE_PROPERTIES_T;
   msgid1 aq.msgid_type;
   msgid2 aq.msgid_type;
   my_msg message_type;
BEGIN
   my_msg := message_type ('First Enqueue', 'May there be many more...');

   /* Delay first message by three days, but otherwise rely on defaults. */

   msgprops.delay := 3 * 60 * 60  * 24; 
 
   DBMS_AQ.ENQUEUE ('msgqueue', queueopts, msgprops, my_msg, msgid1);

   /* Now use the same properties record, but modify the enqueue options
      to deviate from the normal sequence. */

   my_msg := message_type ('Second Enqueue', 'And this one goes first...');

   queueopts.sequence_deviation := DBMS_AQ.BEFORE;
   queueopts.relative_msgid := msgid1;

   <A
CLASS="indexterm"
NAME="ch05-idx-16007-0"
></A
>DBMS_AQ.ENQUEUE ('msgqueue', queueopts, msgprops, my_msg, msgid2);
<A
CLASS="indexterm"
NAME="ch05-idx-16004-0"
></A
>END;
/ </PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch05-SECT-4.2"
>5.4.2 Dequeuing Messages</A
></H3
><P
CLASS="para"
>Once you have placed a message on a queue, you need to extract that message from the queue. This is done with the DEQUEUE procedure.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-4.2.1"
>5.4.2.1 The DBMS_AQ.DEQUEUE procedure </A
></H4
><P
CLASS="para"
>Use the <A
CLASS="indexterm"
NAME="ch05-idx-16031-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16031-1"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16031-2"
></A
>DEQUEUE procedure to extract a message from a particular queue. Here's the header for this procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_AQ.DEQUEUE 
   (queue_name IN VARCHAR2,
    dequeue_options IN DBMS_AQ.DEQUEUE_OPTIONS_T,
    message_properties OUT DBMS_AQ.MESSAGE_PROPERTIES_T,
    payload OUT &lt;type_name&gt;,
    msgid OUT RAW)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>queue_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the queue from which the message should be dequeued. The queue cannot be an exception queue and must have been previously defined by a call to DBMS_AQADM.CREATE_QUEUE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dequeue_options</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Record containing the dequeuing options, defined using the specified record type. See <A
CLASS="xref"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
>Section 5.3.8, "Dequeue Options Record Type"</A
>" for more details.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>message_properties</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Record containing the message properties supplied when the message was enqueued. See <A
CLASS="xref"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
>Section 5.3.6</A
>" for more details.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>payload</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Data or "payload" that is associated with this message on the queue. This is an object (an instance of an object type), a RAW value, or NULL. The payload must match the specification in the associated queue table. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>msgid</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ID number of the message generated by AQ.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-4.2.2"
>5.4.2.2 Examples</A
></H4
><P
CLASS="para"
>The <A
CLASS="xref"
HREF="ch05_07.htm#ch05-SECT-7.5.1"
>Section 5.7</A
>" section at the end of this chapter offers many different illustrations of using DBMS_AQ.DEQUEUE to retrieve messages from a queue. In the remainder of this section, though, I offer some examples to get you familiar with the kind of code you would write when dequeuing messages. In all of these cases, assume that I have defined an object type as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE message_type AS OBJECT
   (title VARCHAR2(30),
    text VARCHAR2(2000));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Assume further that my AQ administrator has created a queue table and a message queue as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXEC DBMS_AQADM.CREATE_QUEUE_TABLE
   (queue_table =&gt; 'msg',
    queue_payload_type =&gt; 'message_type');

EXEC DBMS_AQADM.CREATE_QUEUE
   (queue_name =&gt; 'msgqueue',
    queue_table =&gt; 'msg');

EXEC DBMS_AQADM.START_QUEUE (queue_name =&gt; 'msgqueue');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now I can dequeue a message that has previously been placed in this queue as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19256-0"
></A
>aqdeq1.sql */*
DECLARE
   queueopts DBMS_AQ.DEQUEUE_OPTIONS_T;
   msgprops DBMS_AQ.MESSAGE_PROPERTIES_T;
   msgid aq.msgid_type; /* defined in aq.spp */
   my_msg message_type;
BEGIN
   DBMS_AQ.DEQUEUE ('msgqueue',
      queueopts,
      msgprops,
      my_msg,
      msgid);

   /* Now display some of the information. */
   DBMS_OUTPUT.PUT_LINE ('Dequeued message id is ' || RAWTOHEX (msgid));
   DBMS_OUTPUT.PUT_LINE ('Dequeued title is ' || my_msg.title);
   DBMS_OUTPUT.PUT_LINE ('Dequeued text is ' || my_msg.text);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is an example of output from this script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @aqdeq1
Dequeued message id is E2CEA14C51F411D1B977E59CD6EE8E46
Dequeued title is First Enqueue
Dequeued text is May there be many more...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the simplest possible usage of DBMS_AQ.DEQUEUE. I declare my two record structures, because I <EM
CLASS="emphasis"
>must</EM
> pass them in as arguments. However, I do not modify any of the values in the fields; all have the default values documented in the <A
CLASS="xref"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
>Section 5.3</A
>" section for the message properties record type. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16036-0"
></A
>You can also modify the dequeue properties to change the behavior of the dequeue operation. The full set of options is explained in the <A
CLASS="xref"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
>Section 5.3.8</A
>" section under <A
CLASS="xref"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
>Section 5.3</A
>." The following script demonstrates how you can request that messages not be removed from the queue after they are dequeued. You would do this when you want to search through a queue for a specific message, leaving all the others in place.</P
><P
CLASS="para"
>The following script dequeues a message once in BROWSE mode, then dequeues the same message in the default REMOVE mode, and then dequeues with REMOVE again:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-16037-0"
></A
>aqdeq2.sql */*
DECLARE
   queueopts DBMS_AQ.DEQUEUE_OPTIONS_T;
   msgprops DBMS_AQ.MESSAGE_PROPERTIES_T;
   msgid aq.msgid_type; /* defined in aq.spp */
   my_msg message_type;

   /* A nested procedure to minimize code redundancy! */
   PROCEDURE getmsg (mode_in IN INTEGER)
   IS
   BEGIN
      queueopts.dequeue_mode := mode_in;

      DBMS_AQ.DEQUEUE ('msgqueue', queueopts, msgprops, my_msg, msgid);

      /* Now display some of the information. */
      DBMS_OUTPUT.PUT_LINE ('Dequeued msg id is ' || RAWTOHEX (msgid));
      DBMS_OUTPUT.PUT_LINE ('Dequeued title is ' || my_msg.title);
   END;
BEGIN
   /* Request browse, not remove, for dequeue operation. */
   getmsg (DBMS_AQ.BROWSE);

   /* Do the same thing again, this time with remove. You will dequeue
      the same entry as before. */
   getmsg (DBMS_AQ.REMOVE);

   /* Dequeue a third time, again with remove, and notice the different
      message ID. The previous message was, in fact, removed. */
   getmsg (DBMS_AQ.REMOVE);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the output from running the <I
CLASS="filename"
>aqdeq2.sql</I
><A
CLASS="indexterm"
NAME="ch05-idx-19444-0"
></A
> script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @aqdeq2
Dequeued msg id is E2CEA15251F411D1B977E59CD6EE8E46
Dequeued title is TWO EGGS OVER MEDIUM
Dequeued msg id is E2CEA15251F411D1B977E59CD6EE8E46
Dequeued title is TWO EGGS OVER MEDIUM
Dequeued msg id is E2CEA15351F411D1B977E59CD6EE8E46
Dequeued title is TWO EGGS OVER EASY</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-4.2.3"
>5.4.2.3 Dequeue search criteria</A
></H4
><P
CLASS="para"
>When you request a <A
CLASS="indexterm"
NAME="ch05-idx-16038-0"
></A
>dequeue operation, you can specify search criteria. These criteria are used to determine which message is dequeued. The search criteria are established by the following fields in the dequeue options record: consumer_name, msgid, and correlation.</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If you specify a message ID in the dequeue options record, the message with that ID will be dequeued, regardless of its place in the queue.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you specify a correlation value, only those messages that have a correlation value matching the one you specify will be candidates for dequeuing. A match can be specified as an exact match or a pattern match.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you provide a value for the consumer_name field, only those messages that were enqueued for that consumer (a subscriber either to the queue as a whole or specified in the recipient list at enqueue time) are considered for dequeuing. </P
></LI
></UL
><P
CLASS="para"
>The <A
CLASS="xref"
HREF="ch05_07.htm#ch05-SECT-7.5.1"
>Section 5.7</A
>" section shows you the kind of code you need to write to support these different kinds of search criteria.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-4.2.4"
>5.4.2.4 Dequeue order </A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16045-0"
></A
>The order in which messages are generally dequeued is determined by the characteristics of the queue table, established at the time of creation. For example, you can define a queue table in which the messages are ordered by the priority associated with the message.</P
><P
CLASS="para"
>You can override the default order by specifying the message ID or a correlation value in the dequeue options record. Remember that a message must be in the READY state to be dequeued&nbsp;-- unless you specify the message ID explicitly. When you use that ID, you override any other search criteria and restrictions.</P
><P
CLASS="para"
>Here is an example of dequeuing a message from the msg queue by specifying a message ID number (passed in as an argument to the procedure):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19292-0"
></A
>aqdeq3.sql */*
CREATE OR REPLACE PROCEDURE getmsg (msgid_in IN RAW)
IS
   queueopts DBMS_AQ.DEQUEUE_OPTIONS_T;
   msgprops DBMS_AQ.MESSAGE_PROPERTIES_T;
   msgid aq.msgid_type; /* defined in aq.spp */
   my_msg message_type;
BEGIN
   queueopts.msgid := msgid_in;

   DBMS_AQ.DEQUEUE ('msgqueue',
      queueopts, msgprops, my_msg, msgid);

   /* Now display some of the information. */
   DBMS_OUTPUT.PUT_LINE 
      ('Requested message id is ' || RAWTOHEX (msgid_in));
   DBMS_OUTPUT.PUT_LINE 
      ('Dequeued message id is  ' || RAWTOHEX (msgid));
   DBMS_OUTPUT.PUT_LINE ('Dequeued title is ' || my_msg.title);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is an example of using this procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch05-idx-19295-0"
></A
>aqdeq4.sql */*
DECLARE
   enqueue_opts DBMS_AQ.ENQUEUE_OPTIONS_T;
   dequeue_opts DBMS_AQ.DEQUEUE_OPTIONS_T;
   msgprops DBMS_AQ.MESSAGE_PROPERTIES_T;
   msgid1 aq.msgid_type;
   msgid2 aq.msgid_type;
   my_msg message_type;
BEGIN
   /* Enqueue two messages */

   my_msg := message_type 
      ('Joy of Cooking', 'Classic Recipes for Oral Delight');
   DBMS_AQ.ENQUEUE ('msgqueue', enqueue_opts, msgprops, my_msg, msgid1);

   my_msg := message_type ('Joy of Sex', 'Classic Recipes for Delight');
   DBMS_AQ.ENQUEUE ('msgqueue', enqueue_opts, msgprops, my_msg, msgid2);

   /* Now dequeue the first by its message ID explicitly. */
   getmsg (msgid1);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And the results from executing <I
CLASS="filename"
>aqdeq4.sql</I
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @aqdeq4
Requested message id is E2CEA16351F411D1B977E59CD6EE8E46
Dequeued message id is  E2CEA16351F411D1B977E59CD6EE8E46
Dequeued title is Joy of Cooking</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-4.2.5"
>5.4.2.5 Dequeue navigation</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16054-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16054-1"
></A
>You specify the navigation method by setting a value in the navigation field of the dequeue options record.</P
><P
CLASS="para"
>The default navigation through a queue for dequeuing is "next message." This means that each subsequent dequeue retrieves messages from the queue based on the snapshot or view of the queue as it appeared when the first dequeue was performed. This approach offers a read <A
CLASS="indexterm"
NAME="ch05-idx-16064-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16064-1"
></A
>consistency model similar to that of the Oracle RDBMS. For example, if you enqueue a message after you have issued a dequeue command, that message will not be dequeued (or even checked for availability for dequeuing) until all messages already in the queue have been processed.</P
><P
CLASS="para"
>Specifying DBMS_AQ.<A
CLASS="indexterm"
NAME="ch05-idx-16066-0"
></A
>NEXT_MESSAGE for message navigation (the default) is often sufficient for dequeue operations. If either of the following conditions occur, however, you may need to change the navigation:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You enqueue messages after dequeues have occurred, and you want those newly enqueued messages to be immediately considered for a dequeue.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You have a nondefault (i.e., <A
CLASS="indexterm"
NAME="ch05-idx-16065-0"
></A
>priority-based) ordering in your queue. In this case, if a higher-priority message enters the queue at any time, you want to consider that message for dequeuing immediately.</P
></LI
></UL
><P
CLASS="para"
>In either of these situations you should set the navigation method as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   queueopts DBMS_AQ.DEQUEUE_OPTIONS_T;
BEGIN
   queueopts.navigation := DBMS_AQ.<A
CLASS="indexterm"
NAME="ch05-idx-16067-0"
></A
>FIRST_MESSAGE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you use "first message" navigation, you tell Oracle AQ that you want it to consider the entire set of messages in the queue for every dequeue command. Internally, this means that AQ will create a new "snapshot" view of the queue whenever you request a dequeue.</P
><P
CLASS="para"
>You will find many illustrations of the use of "first message" navigation in the <A
CLASS="xref"
HREF="ch05_07.htm#ch05-SECT-7.5.1"
>Section 5.7</A
>" section.<A
CLASS="indexterm"
NAME="ch05-idx-16062-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16062-1"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16062-2"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch05-SECT-4.2.6"
>5.4.2.6 Dequeuing with message grouping</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch05-idx-16072-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16072-1"
></A
>When you create a queue table specifying DBMS_AQADM.TRANSACTIONAL for the message_  grouping argument, any messages enqueued in the same transaction are considered part of a <EM
CLASS="emphasis"
>group</EM
> of messages. This group may consist of only one message; there is also no upper limit on the number of messages allowed in a group. </P
><P
CLASS="para"
>When you work with queues that are not enabled for message grouping, a dequeue operation that specified LOCKED or REMOVE mode will only affect a single message. In a message grouping queue, on the other hand, a dequeue operation on one message in a group will lock the entire group. This allows you to treat all the messages in a group as a single unit or transaction.</P
><P
CLASS="para"
>When you are dequeuing against a message group, keep the following rules in mind:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>When you dequeue the last message in the current message group, Oracle AQ will raise the ORA-25235 <A
CLASS="indexterm"
NAME="ch05-idx-19473-0"
></A
>exception.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When you dequeue the last message in a message group, you must specify NEXT_TRANSACTION navigation in a dequeue options record in order to start dequeuing messages from the next available group.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If there aren't any more message groups available in the queue, then the dequeue operation will time out after the period of time specified in the WAIT field of the dequeue options <A
CLASS="indexterm"
NAME="ch05-idx-16034-0"
></A
><A
CLASS="indexterm"
NAME="ch05-idx-16034-1"
></A
>record.<A
CLASS="indexterm"
NAME="ch05-idx-15999-0"
></A
></P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_03.htm#ch05-SECT-3.1.1"
TITLE="5.3 Oracle AQ Nonprogram Elements"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.3 Oracle AQ Nonprogram Elements"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_05.htm"
TITLE="5.5 DBMS_AQADM: Performing AQ  Administrative Tasks (Oracle8 only)"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.5 DBMS_AQADM: Performing AQ  Administrative Tasks (Oracle8 only)"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.3 Oracle AQ Nonprogram Elements</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>5.5 DBMS_AQADM: Performing AQ  Administrative Tasks (Oracle8 only)</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
