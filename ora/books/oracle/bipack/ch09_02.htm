<HTML
><HEAD
><TITLE
>[Chapter 9] 9.2 UTL_RAW: Manipulating Raw Data</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:56:17Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch09_01.htm"
TITLE="9. Datatype Packages"><LINK
REL="prev"
HREF="ch09_01.htm"
TITLE="9.1 DBMS_ROWID: Working with the ROWID Pseudo-Column (Oracle8 only)"><LINK
REL="next"
HREF="ch10_01.htm"
TITLE="10. Miscellaneous Packages"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_01.htm"
TITLE="9.1 DBMS_ROWID: Working with the ROWID Pseudo-Column (Oracle8 only)"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.1 DBMS_ROWID: Working with the ROWID Pseudo-Column (Oracle8 only)"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch09_01.htm"
TITLE="9. Datatype Packages"
>Chapter 9<BR>Datatype Packages</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch10_01.htm"
TITLE="10. Miscellaneous Packages"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10. Miscellaneous Packages"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch09-39921"
>9.2 UTL_RAW: Manipulating Raw Data</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18416-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18416-1"
></A
>UTL_RAW package contains a set of programs that allow you to manipulate raw data. This package was originally written as a component of the Oracle Server's advanced replication option, and it supported procedural <A
CLASS="indexterm"
NAME="ch09-idx-18418-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18418-1"
></A
>replication of data across different <A
CLASS="indexterm"
NAME="ch09-idx-18419-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18419-1"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18419-2"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18419-3"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18419-4"
></A
>NLS (National Language Support) language databases. By converting data to RAW, the remote procedure calls would not perform NLS conversion, thus preserving the nature of some special data. The functions included in this package actually go beyond this original functionality and provide a toolkit for the manipulation of raw data that is not otherwise available in the Oracle Server product. These functions perform a number of special operations: conversion and coercion, slicing and dicing of raw data, and bit-fiddling, all described in the next section. </P
><P
CLASS="para"
>Other than replication support, there are a number of advantages Oracle can offer in storing raw data in the database, such as tighter integration with the rest of the application, transaction-level <A
CLASS="indexterm"
NAME="ch09-idx-18421-0"
></A
>consistency, <A
CLASS="indexterm"
NAME="ch09-idx-18422-0"
></A
>concurrency, and <A
CLASS="indexterm"
NAME="ch09-idx-18423-0"
></A
>recoverability. One of the difficulties in the use of raw data in an Oracle database has been in the poor support for manipulation of this data. The UTL_RAW package provides this support. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch09-SECT-2.1"
>9.2.1 Getting Started with UTL_RAW</A
></H3
><P
CLASS="para"
>The UTL_RAW package is <A
CLASS="indexterm"
NAME="ch09-idx-20443-0"
></A
>created when the Oracle database is installed. The <I
CLASS="filename"
>utlraw.sql</I
><A
CLASS="indexterm"
NAME="ch09-idx-18425-0"
></A
> script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1</A
>) contains the source code for this package's specification and body. This script is called by <I
CLASS="filename"
>catrep.sql</I
>, which is run when the advanced replication option of the Oracle database is installed. If this package is not already installed, check to see if these files are in your <I
CLASS="filename"
>admin</I
> subdirectory. If so, you can connect as SYS and install this package by running the two scripts in the following order:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @utlraw.sql
SQL&gt; @prvtrawb.plb</PRE
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.1.1"
>9.2.1.1 UTL_RAW programs</A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch09_02.htm#ch09-SECT-2.3.5"
>Table 9.4</A
> lists the programs provided by the UTL_RAW package. For a discussion of some of the concepts underlying the operations performed by these programs, see the next section, "<A
CLASS="xref"
HREF="ch09_02.htm#ch09-SECT-2.3.5"
>Section 9.2.2, "Raw Data Manipulation Concepts"</A
>."</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch09-39655"
>Table 9.4: UTL_RAW <A
CLASS="indexterm"
NAME="ch09-idx-18427-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18427-1"
></A
>Programs </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use In SQL</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BIT_AND</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Performs bitwise logical AND of the values in raw r1 with raw r2 and returns the ANDed result raw.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BIT_COMPLEMENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Performs bitwise logical "complement" of the values in raw r and returns the "complemented" result raw.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BIT_OR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Performs bitwise logical OR of the values in raw r1 with raw r2 and returns the ORed result raw.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BIT_XOR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Performs bitwise logical "exclusive or" (XOR) of the values in raw r1 with raw r2 and returns the XORed result raw.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CAST_TO_RAW</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Converts a VARCHAR2 string represented using N data bytes into a raw with N data bytes.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CAST_TO_VARCHAR2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Converts a raw represented using N data bytes into a VARCHAR2 string with N data bytes.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COMPARE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Compares raw r1 against raw r2. Returns 0 if r1 and r2 are identical; otherwise, returns the position of the first byte from r1 that does not match r2.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CONCAT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Concatenates a set of up to 12 raws into a single raw.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CONVERT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Converts a raw from one character set to another character set.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COPIES</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns N copies of the original raw concatenated together.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LENGTH</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the length in bytes of a raw.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>OVERLAY</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Overlays the specified portion of a raw with a different raw value.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>REVERSE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Reverses the byte sequence in the raw from end to end.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SUBSTR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the specified sub-portion of a raw.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRANSLATE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Translates original bytes in the raw with the specified replacement set.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRANSLITERATE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Translates original bytes in the raw with the specified replacement set following rules, which result in the transliterated raw always being the same length as the original raw.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>XRANGE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns a raw containing all valid 1-byte encodings in succession beginning with the value start_byte and ending with the value end_byte.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>UTL_RAW does not declare any <A
CLASS="indexterm"
NAME="ch09-idx-20445-0"
></A
>exceptions or nonprogram elements.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch09-35727"
>9.2.2 Raw Data Manipulation Concepts</A
></H3
><P
CLASS="para"
>This section provides an overview of the types of data manipulation you might perform on <A
CLASS="indexterm"
NAME="ch09-idx-18428-0"
></A
>raw data.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.2.1"
>9.2.2.1 Conversion and coercion</A
></H4
><P
CLASS="para"
><EM
CLASS="emphasis"
>Conversion</EM
> <A
CLASS="indexterm"
NAME="ch09-idx-18436-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18436-1"
></A
>refers to functions that convert raw byte strings to other values. <EM
CLASS="emphasis"
>Coercion</EM
><A
CLASS="indexterm"
NAME="ch09-idx-18437-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18437-1"
></A
> is a specialized conversion that changes the datatype but not the data itself. UTL_RAW has functions that convert from one NLS language set to another, from one set of raw byte strings to another, and from raw datatypes to VARCHAR2 datatypes (as well as from VARCHAR2 to raw). The coercion operations supported by Oracle involving raw datatypes via the standard SQL functions are <A
CLASS="indexterm"
NAME="ch09-idx-18439-0"
></A
>raw-to-hex and <A
CLASS="indexterm"
NAME="ch09-idx-18440-0"
></A
>hex-to-raw; via UTL_RAW functions, they are <A
CLASS="indexterm"
NAME="ch09-idx-18441-0"
></A
>raw-to-VARCHAR2 and <A
CLASS="indexterm"
NAME="ch09-idx-18442-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18442-1"
></A
>VARCHAR2-to-raw. Notably unsupported are <A
CLASS="indexterm"
NAME="ch09-idx-18448-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18448-1"
></A
>raw-to/from-numeric datatypes and <A
CLASS="indexterm"
NAME="ch09-idx-18444-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18444-1"
></A
>raw-to/from-date datatypes.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.2.2"
>9.2.2.2 Slicing and dicing</A
></H4
><P
CLASS="para"
><EM
CLASS="emphasis"
>Slicing and dicing</EM
> <A
CLASS="indexterm"
NAME="ch09-idx-18454-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18454-1"
></A
>refers to functions that divide and combine <A
CLASS="indexterm"
NAME="ch09-idx-18459-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18459-1"
></A
>raw byte strings in various ways. These functions include COMPARE, CONCATENATE, COPY, LENGTH, OVERLAY, REVERSE, and SUBSTRING.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.2.3"
>9.2.2.3 Bit-fiddling</A
></H4
><P
CLASS="para"
><EM
CLASS="emphasis"
>Bit-fiddling</EM
><A
CLASS="indexterm"
NAME="ch09-idx-18461-0"
></A
> refers to the manipulation of individual bits. Because bits are the smallest possible unit of storage, bit-fiddling provides a highly efficient storage mechanism. Bitmap indexes take advantage of this and offer substantial disk savings over traditional Btree indexes. The Oracle kernel supports the bitwise AND function natively via the undocumented function BITAND(x,x),[<A
CLASS="footnote"
HREF="#ch09-pgfId-17790"
>1</A
>] but the other bitwise operations needed to support <A
CLASS="indexterm"
NAME="ch09-idx-18462-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18462-1"
></A
>bitmasks are supported only via the UTL_RAW package. </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch09-pgfId-17790"
>[1]</A
> See the definitions of some V$ tables, such as V$session_wait, in the V$fixed_view_definition view.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Bitmasks are commonly used to combine a number of flags or semaphores into a single object as follows:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>To see if a bit/flag/semaphore is set, use the bitwise AND function.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>To turn a bit on or combine bitmasks, use the bitwise OR function. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>To turn a bit off, use the bitwise OR and NOT functions together. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>To toggle a bit, use the bitwise XOR function. </P
></LI
></UL
><P
CLASS="para"
>Other bitwise functions, such as shift left and shift right, are supported in C and other languages, but not in PL/SQL or UTL_RAW.</P
><P
CLASS="para"
>To better understand bitmasks and what these functions do, let's look at some examples of their use. A mask is a bit that represents some data; for example, each day of the month can be represented by one bit as follows. </P
><P
CLASS="para"
>The first of the month is the bit mask:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>0000 0000 0000 0000 0000 0000 0000 0001 or hex 0000 0001</PRE
></BLOCKQUOTE
><P
CLASS="para"
></P
><P
CLASS="para"
>The second of the month is the bit mask:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>0000 0000 0000 0000 0000 0000 0000 0010 or hex 0000 0002
....</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The 26th of the month is the bit mask:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>0000 0010 0000 0000 0000 0000 0000 0000 or hex 0200 0000</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And so on. In a single 32-bit string (4 bytes), any combination of days of the month can be set. In a scheduling application, we may want to find out if the variable DayInQuestion has the bit set for the 26th. We can perform a bitwise AND on the variable and the mask like this: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DayInQuestion      <CODE
CLASS="literal"
>0000 0111 1111 1000 0000 0000 0000 0000</CODE
>  Bits 20-27 set   
                                AND
Mask for the 26th  <CODE
CLASS="literal"
>0000 0010 0000 0000 0000 0000 0000 0000</CODE
>
-----------------------------------------------------------------------------
Result             <CODE
CLASS="literal"
>0000 0010 0000 0000 0000 0000 0000 0000</CODE
>  True</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Likewise, if the variable needs to be checked for any of the bits 14th through 21st, then the masks for the 14th through 21st can be combined (via bitwise OR) and compared to the variable.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DayInQuestion      <CODE
CLASS="literal"
>0000 0111 1111 1000 0000 0000 0000 0000  </CODE
> Bits 20-27 set
                                 AND
Mask               <CODE
CLASS="literal"
>0000 0000 0001 1111 1110 0000 0000 0000 </CODE
>  Bits 14-21 set
-----------------------------------------------------------------------------
Result             <CODE
CLASS="literal"
>0000 0000 0001 1000 0000 0000 0000 0000 </CODE
>  True</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The UTL_RAW package can also be used separately from replication, and offers facilities for manipulating raw data types that are not found elsewhere in the Oracle Server product. Oracle has a robust set of functions available for the structured datatypes RAW, CHARACTER, NUMERIC, and DATE.<A
CLASS="indexterm"
NAME="ch09-idx-18429-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch09-SECT-2.3"
>9.2.3 The UTL_RAW Interface</A
></H3
><P
CLASS="para"
>This section describes the programs available through the UTL_RAW package.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.1"
>9.2.3.1 <A
CLASS="indexterm"
NAME="ch09-idx-18496-0"
></A
>The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18463-0"
></A
>BIT_AND function</A
></H4
><P
CLASS="para"
>The BIT_AND function performs a bitwise logical <A
CLASS="indexterm"
NAME="ch09-idx-18476-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18476-1"
></A
>AND of two input raw strings. If input strings are different lengths, the return value is the same length as the longer input string. The return value is the bitwise AND of the two inputs up to the length of the shorter input string, with the remaining length filled from the unprocessed data in the longer input string. If either input string is NULL, the return value is NULL. Here's the specification for this function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.BIT_AND
   (r1 IN RAW 
   ,r2 IN RAW)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Raw string to AND with r2</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Raw string to AND with r1</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.1.1"
>9.2.3.1.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(BIT_AND, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.1.2"
>9.2.3.1.2 Example</A
></H4
><P
CLASS="para"
>To check if a bit is turned on in a bit flag variable using a bitmask, you can use the BIT_AND function. This section of example code also uses the BIT_OR function to merge bitmasks:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
  fourteenth     VARCHAR2(8);
  fifteenth      VARCHAR2(8);
  twentieth      VARCHAR2(8);
  mask           RAW(4);
  bitfield1      VARCHAR2(8);
  bitfield2      VARCHAR2(8);
BEGIN
  /* set bitfield1 for the 15th through 18th */
  bitfield1 := '0003C000';

  /* set bitfield2 for the 26st */
  bitfield2 := '02000000';

  /* set the mask for the 14th */
  fourteenth := '00002000';

  /* set the mask for the 15th */
  fifteenth := '00004000';

  /* set the mask for the 20th */
  twentieth := '00080000';

  /* merge the masks for the 14th, 15th and 20th */
  mask := UTL_RAW.BIT_OR(hextoraw(fourteenth),hextoraw(fifteenth));
  mask := UTL_RAW.BIT_OR(mask,hextoraw(twentieth));

  /* check to see if the bitfields have the 14th, 15th, or 20th set */
  if <B
CLASS="emphasis.bold"
>UTL_RAW.BIT_AND</B
>(mask,hextoraw(bitfield1)) = '00000000' then
    dbms_output.put_line('bitfield1 is not set');
  else
    dbms_output.put_line('bitfield1 is set');
  end if;

  if UTL_RAW.BIT_AND(mask,hextoraw(bitfield2)) = '00000000' then
    dbms_output.put_line('bitfield2 is not set');
  else
    dbms_output.put_line('bitfield2 is set');
  end if;

END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output from this code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Bitfield1 is set 
Bitfield2 is <A
CLASS="indexterm"
NAME="ch09-idx-18484-0"
></A
>Anot <A
CLASS="indexterm"
NAME="ch09-idx-18479-0"
></A
>set</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.2"
>9.2.3.2 The UTL_RAW.BIT_COMPLEMENT function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18486-0"
></A
>BIT_COMPLEMENT function performs a logical <A
CLASS="indexterm"
NAME="ch09-idx-18490-0"
></A
>NOT, or one's complement, of the raw input string r1. The complement of a raw string flips all 0 bits to 1 and all 1 bits to 0,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.COMPLEMENT
   (r1 IN RAW)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where r1 is the raw input string.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.2.1"
>9.2.3.2.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(BIT_COMPLEMENT, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.2.2"
>9.2.3.2.2 Example</A
></H4
><P
CLASS="para"
>To turn off a bit, regardless of its original state, in a bit flag variable using a bitmap, you can use the BIT_COMPLEMENT function together with the BIT_AND function.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
  fourteenth     VARCHAR2(8);
  fifteenth      VARCHAR2(8);
  twentieth      VARCHAR2(8);
  mask           RAW(4);
  bitfield1      VARCHAR2(8);
  bitfield2      VARCHAR2(8);
BEGIN
  /* set the bitfield for the 15th through 18th */
  bitfield1 := '0003C000';

  /* set the bitfield for the 26st */
  bitfield2 := '02000000';

  /* set the mask for the 14th */
  fourteenth := '00002000';

  /* set the mask for the 15th */
  fifteenth := '00004000';

  /* set the mask for the 20th */
  twentieth := '00080000';

  /* merge the masks for the 14th, 15th and 20th */
  mask := UTL_RAW.BIT_OR(hextoraw(fourteenth),hextoraw(fifteenth));
  mask := UTL_RAW.BIT_OR(mask,hextoraw(twentieth));
  mask := UTL_RAW.BIT_OR(mask,hextoraw(twentieth));

  /* check to see if the bitfields have the 14th, 15th, or 20th set */
  if UTL_RAW.BIT_AND(mask,hextoraw(bitfield1)) = '00000000' then
    dbms_output.put_line('bitfield1 is not set');
  else
    dbms_output.put_line('bitfield1 is set');
  end if;

  if UTL_RAW.BIT_AND(mask,hextoraw(bitfield2)) = '00000000' then
    dbms_output.put_line('bitfield2 is not set');
  else
    dbms_output.put_line('bitfield2 is set');
  end if;

  /* turn off bit 15 in the mask */
  mask := UTL_RAW.BIT_AND(mask,UTL_RAW.BIT_COMPLEMENT(hextoraw(fifteenth)));

  /* check to see if the bitfield1 has the 14th, 15th, or 20th set */
  if UTL_RAW.BIT_AND(mask,hextoraw(bitfield1)) = '00000000' then
    dbms_output.put_line('bitfield1 is not set');
  else
    dbms_output.put_line('bitfield1 is set');
  end if;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output from the above code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>bitfield1 is set
bitfield2 is not set
bitfield1 is not set<A
CLASS="indexterm"
NAME="ch09-idx-18488-0"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.3"
>9.2.3.3 The UTL_RAW.BIT_OR function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18491-0"
></A
>BIT_OR function performs a bitwise logical <A
CLASS="indexterm"
NAME="ch09-idx-18492-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18492-1"
></A
>OR of the two input raw strings r1 and r2. If r1 and r2 are of different length, the return value is the same length as the longer input string. The return value is the bitwise OR of the two inputs up to the length of the shorter input string, with the remaining length filled from the unprocessed data in the longer input string. If either input string is NULL, the return value is NULL.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.BIT_OR
   (r1 IN RAW
   ,r2 IN RAW)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Raw string to OR with r2</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Raw string to OR with r1</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.3.1"
>9.2.3.3.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(BIT_OR, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.3.2"
>9.2.3.3.2 Example</A
></H4
><P
CLASS="para"
>To turn on a bit in a bit flag variable using a bitmask, or to merge bitmasks, you can use the BIT_OR function, as shown in the example from BIT_AND.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.4"
>9.2.3.4 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18509-0"
></A
>BIT_XOR function</A
></H4
><P
CLASS="para"
>The BIT_XOR function performs a bitwise logical <A
CLASS="indexterm"
NAME="ch09-idx-18511-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18511-1"
></A
>XOR of the two input raw strings r1 and r2. If r1 and r2 are of different lengths, the return value is the same length as the longer input string. The return value is the bitwise XOR of the two inputs, up to the length of the shorter input string with the remaining length filled from the unprocessed data in the longer input string. If either input string is NULL, the return value is NULL. Here's the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.BIT_XOR
   (r1 IN RAW 
   ,r2 IN RAW)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Raw string to XOR with r2</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Raw string to XOR with r1</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.4.1"
>9.2.3.4.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(BIT_XOR, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.4.2"
>9.2.3.4.2 Example</A
></H4
><P
CLASS="para"
>To <A
CLASS="indexterm"
NAME="ch09-idx-18516-0"
></A
>toggle a bit (if it is off, turn it on, and if it is on, turn it off) in a bit flag variable using a bitmask, use the BIT_XOR function as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
  fourteenth     VARCHAR2(8);
  fifteenth      VARCHAR2(8);
  twentieth      VARCHAR2(8);
  mask           RAW(4);
  bitfield1      VARCHAR2(8);
  bitfield2      VARCHAR2(8);
BEGIN
  /* set the bitfield for the 15th through 18th */
  bitfield1 := '0003C000';
  /* set the bitfield for the 26st */
  bitfield2 := '02000000';
  /* set the mask for the 14th */
  fourteenth := '00002000';
  /* set the mask for the 15th */
  fifteenth := '00004000';
  /* set the mask for the 20th */
  twentieth := '00080000';
  /* merge the masks for the 14th, 15th and 20th */
  mask := UTL_RAW.BIT_OR (HEXTORAW (fourteenth),HEXTORAW (fifteenth));
  mask := UTL_RAW.BIT_OR (mask, HEXTORAW (twentieth));
  /* check to see IF the bitfields have the 14th  or 20th set */
  IF UTL_RAW.BIT_AND (mask, HEXTORAW (bitfield1)) = '00000000' THEN
    DBMS_OUTPUT.PUT_LINE ('bitfield1 is not set');
  ELSE
    DBMS_OUTPUT.PUT_LINE ('bitfield1 is set');
  END IF;
  IF UTL_RAW.BIT_AND (mask, HEXTORAW (bitfield2)) = '00000000' THEN
    DBMS_OUTPUT.PUT_LINE ('bitfield2 is not set');
  ELSE
    DBMS_OUTPUT.PUT_LINE ('bitfield2 is set');
  END IF;
  /* toggle bit 15 in the mask */
  mask := UTL_RAW.BIT_XOR (mask, HEXTORAW (fifteenth));
  /* check to see IF the bitfield1 has the 14th, 15th, or 20th set */
  IF UTL_RAW.BIT_AND (mask, HEXTORAW (bitfield1)) = '00000000' THEN
    DBMS_OUTPUT.PUT_LINE ('bitfield1 is not set');
  ELSE
    DBMS_OUTPUT.PUT_LINE ('bitfield1 is set');
  END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output from the previous example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>bitfield1 is set
bitfield2 is not set
bitfield1 is <A
CLASS="indexterm"
NAME="ch09-idx-18514-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18514-1"
></A
>not <A
CLASS="indexterm"
NAME="ch09-idx-18505-0"
></A
>set<A
CLASS="indexterm"
NAME="ch09-idx-18498-0"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.5"
>9.2.3.5 The UTL_RAW.CAST_TO_RAW function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18517-0"
></A
>CAST_TO_RAW <A
CLASS="indexterm"
NAME="ch09-idx-18809-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18809-1"
></A
>function <A
CLASS="indexterm"
NAME="ch09-idx-18519-0"
></A
>converts the <A
CLASS="indexterm"
NAME="ch09-idx-18518-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18518-1"
></A
>VARCHAR2 input string into a raw datatype. The data is not altered; only the data type is changed. This is essentially a VARCHAR2_to_RAW function,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.CAST_TO_RAW
   (c IN VARCHAR2)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where c is the text string that should be converted to a raw datatype.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.5.1"
>9.2.3.5.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(CAST_TO_RAW, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.5.2"
>9.2.3.5.2 Example</A
></H4
><P
CLASS="para"
>For an example of CAST_TO_RAW, see "<A
CLASS="xref"
HREF="ch09_02.htm#ch09-SECT-2.3.5"
>Section 9.2.3.15, "The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18573-0"
></A
>TRANSLATE function"</A
>" later in this chapter.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.6"
>9.2.3.6 The UTL_RAW.CAST_TO_VARCHAR2 function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18520-0"
></A
>CAST_TO_VARCHAR2 function converts the raw input string into a <A
CLASS="indexterm"
NAME="ch09-idx-18525-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18525-1"
></A
>VARCHAR2 datatype. The data is not altered; only the data type is changed. The current NLS language is used. The specification is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.CAST_TO_VARCHAR2
   (r IN RAW)
RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where r is the raw string that should be converted into a VARCHAR2.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.6.1"
>9.2.3.6.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(CAST_TO_VARCHAR2, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.6.2"
>9.2.3.6.2 Example</A
></H4
><P
CLASS="para"
>The data dictionary views USER_TAB_COLUMNS, ALL_TAB_COLUMNS, and DBA_TAB_COLUMNS have the first 32 bytes of the lowest and highest data values for each column in analyzed tables. Unfortunately, this data is of data type RAW and not very readable by humans. The CAST_TO_VARCHAR2 function can be used on character datatype columns to see these data in more readable form.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT column_name, UTL_RAW.CAST_TO_VARCHAR2(low_value)
      ,UTL_RAW.CAST_TO_VARCHAR2(high_value)
FROM  user_tab_columns
WHERE table_name = 'FOO_TAB'
 AND  column_name = 'VCHAR1'<A
CLASS="indexterm"
NAME="ch09-idx-18678-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18678-1"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.7"
>9.2.3.7 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18527-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18527-1"
></A
>COMPARE function</A
></H4
><P
CLASS="para"
>The COMPARE function does a binary compare of the two raw input strings and returns the number of the first byte position where the two strings differ. If the two strings are identical, a zero is returned. If the two input strings are different lengths, then the pad character is repeatedly appended to the shorter string, extending it to the length of the longer string. The default pad character is 0x00 (binary zero).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.COMPARE
   (r1 IN RAW 
   ,r2 IN RAW 
   ,pad IN RAW DEFAULT NULL)
RETURN NUMBER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this program are summarized in this table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The first input string to compare</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The second input string to compare</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>pad</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The single character used to right pad the shorter of two unequal length strings</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.7.1"
>9.2.3.7.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(COMPARE, WNDS, RNDS, WNPS, RNPS);<A
CLASS="indexterm"
NAME="ch09-idx-18529-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18529-1"
></A
></PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.7.2"
>9.2.3.7.2 Example</A
></H4
><P
CLASS="para"
>Here is an example of the COMPARE function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
  r_string1      RAW(16);
  r_string2      RAW(16);
  diff_position  INTEGER;

BEGIN
  r_string1 := UTL_RAW.CAST_TO_RAW('test string1');
  r_string2 := UTL_RAW.CAST_TO_RAW('test string2');
  diff_position := UTL_RAW.COMPARE(r_string1,r_string2);
  DBMS_OUTPUT.PUT_LINE (
     'r_string1='|| UTL_RAW.CAST_TO_VARCHAR2(r_string1));
  DBMS_OUTPUT.PUT_LINE (
     'r_string2='|| UTL_RAW.CAST_TO_VARCHAR2(r_string2));
  DBMS_OUTPUT.PUT_LINE ('diff_position='|| diff_position);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sample output follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>r_string1=test string1
r_string2=test string2
diff_position=12</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.8"
>9.2.3.8 The UTL_RAW.CONCAT function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18532-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18532-1"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18532-2"
></A
>CONCAT function is used to concatenate a set of 12 raw strings into a single raw string. The size of the concatenated result must not exceed 32K or the procedure will raise the ORA-6502 exception.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.CONCAT
   (r1 IN RAW DEFAULT NULL
   ,r2 IN RAW DEFAULT NULL
   ,r3 IN RAW DEFAULT NULL
   ,r4 IN RAW DEFAULT NULL
   ,r5 IN RAW DEFAULT NULL
   ,r6 IN RAW DEFAULT NULL
   ,r7 IN RAW DEFAULT NULL
   ,r8 IN RAW DEFAULT NULL
   ,r9 IN RAW DEFAULT NULL
   ,r10 IN RAW DEFAULT NULL
   ,r11 IN RAW DEFAULT NULL
   ,r12 IN RAW DEFAULT NULL)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this program are summarized in this table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>First piece of raw data to be concatenated </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Second piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r3</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Third piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r4</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fourth piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r5</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fifth piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r6</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sixth piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r7</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Seventh piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r8</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Eighth piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r9</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Ninth piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r10</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Tenth piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r11</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Eleventh piece of raw data to be concatenated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r12</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Twelfth piece of raw data to be concatenated</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.8.1"
>9.2.3.8.1 Exceptions</A
></H4
><P
CLASS="para"
>The VALUE_ERROR exception (ORA-6502) is raised if the returned raw string exceeds 32K. The documentation from Oracle 7.3 and 8.0 indicates that this <EM
CLASS="emphasis"
>is to be revised in a future release</EM
>, so don't count on this exception to remain unchanged.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.8.2"
>9.2.3.8.2 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(CONCAT, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.8.3"
>9.2.3.8.3 Example</A
></H4
><P
CLASS="para"
>For an example of CONCAT, see the example for TRANSLATE.<A
CLASS="indexterm"
NAME="ch09-idx-18534-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18534-1"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18534-2"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.9"
>9.2.3.9 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18539-0"
></A
>CONVERT function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18820-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18820-1"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18820-2"
></A
>CONVERT function converts the input raw string r from one installed <A
CLASS="indexterm"
NAME="ch09-idx-18540-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18540-1"
></A
>NLS character set to another installed NLS character set. Here's the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.CONVERT
   (r IN RAW 
   ,to_charset IN VARCHAR2 
   ,from_charset IN VARCHAR2)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The raw string to be converted</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>to_charset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the output NLS character set</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>from_charset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the input NLS character set</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.9.1"
>9.2.3.9.1 Exceptions</A
></H4
><P
CLASS="para"
>The VALUE_ERROR exception (ORA-6502) is raised if the input raw string is missing, NULL, or has zero length. This exception is also raised if the from_charset or to_charset parameters are missing, NULL, zero length, or name an invalid character set. The documentation from both Oracle 7.3 and 8.0 indicates that this <EM
CLASS="emphasis"
>is to be revised in a future release</EM
>, so don't count on this exception  to remain unchanged.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.9.2"
>9.2.3.9.2 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES <A
CLASS="indexterm"
NAME="ch09-idx-20437-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-20437-1"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-20437-2"
></A
>pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(CONVERT, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.10"
>9.2.3.10 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18541-0"
></A
>COPIES function</A
></H4
><P
CLASS="para"
>The COPIES function <A
CLASS="indexterm"
NAME="ch09-idx-18542-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18542-1"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18542-2"
></A
>concatenates the input raw string r, n number of times. Here's the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.COPIES
   (r IN RAW 
   ,n IN NUMBER)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this program are summarized in this table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The input raw string that is to be copied</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>n</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The number of copies of the input string to make (must be positive)</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.10.1"
>9.2.3.10.1 Exceptions</A
></H4
><P
CLASS="para"
>The VALUE_ERROR exception (ORA-6502) is raised if the input raw string r is missing, NULL, or has zero length. This exception is also raised if the input number of copies n is less than 1 (n &lt; 1). The documentation from both Oracle 7.3 and 8.0 indicates that this <EM
CLASS="emphasis"
>is to be revised in a future release</EM
>, so don't count on this exception to remain unchanged.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.10.2"
>9.2.3.10.2 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(COPIES, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.10.3"
>9.2.3.10.3 Example</A
></H4
><P
CLASS="para"
>Here is an example of the COPIES function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
  r_string1      RAW(64);
  r_repeat       RAW(16);

BEGIN
  r_repeat := UTL_RAW.CAST_TO_RAW('Test ');
  r_string1 := UTL_RAW.COPIES(r_repeat,4);
  DBMS_OUTPUT.PUT_LINE (
     'r_string1='||UTL_RAW.CAST_TO_VARCHAR2(r_string1));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sample output follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>r_string1=Test Test Test Test</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.11"
>9.2.3.11 The UTL_RAW.L<A
CLASS="indexterm"
NAME="ch09-idx-18543-0"
></A
>ENGTH function</A
></H4
><P
CLASS="para"
>The LENGTH function returns the number of bytes in the <A
CLASS="indexterm"
NAME="ch09-idx-18544-0"
></A
>raw input string given by the r parameter,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.LENGTH
   (r IN RAW)
RETURN NUMBER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where r is the raw input string.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.11.1"
>9.2.3.11.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(LENGTH, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.11.2"
>9.2.3.11.2 Example</A
></H4
><P
CLASS="para"
>Here is an example of the LENGTH function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>  r_1            RAW(32000);
  r_2            RAW(32000);
  r_3            RAW(32000);
BEGIN
  r_1 := UTL_RAW.XRANGE (hextoraw('00'),hextoraw('FF'));
  r_2 := UTL_RAW.CONCAT (r_1,r_1,r_1,r_1,r_1,r_1,r_1,r_1);
  r_3 := UTL_RAW.CONCAT (r_2,r_2,r_2,r_2,r_2,r_2,r_2,r_2);
  DB&lt;S_OUTPUT.PUT_LINE ('Length of r_1='||UTL_RAW.LENGTH(r_1));
  DBMS_OUTPUT.PUT_LINE ('Length of r_2='||UTL_RAW.LENGTH(r_2));
  DBMS_OUTPUT.PUT_LINE ('Length of r_3='||UTL_RAW.LENGTH(r_3));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sample output follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Length of r_1=256
Length of r_2=2048
Length of r_3=16384</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.12"
>9.2.3.12 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18549-0"
></A
>OVERLAY function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18560-0"
></A
>OVERLAY function overwrites the specified section of the target raw string with the string specified in the overlay_str parameter and returns the overwritten raw string. The overwriting starts pos bytes into the target string and continues for len bytes, right-padding the target with the pad parameter as needed to extend the target, if necessary. The len parameter must be greater than 0 and pos must be greater than 1. If pos is greater than the length of the target string, then the target is right-padded with pad before the overlaying begins. Here's the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.OVERLAY
   (overlay_str IN RAW
   ,target IN RAW
   ,pos IN BINARY_INTEGER DEFAULT 1
   ,len IN BINARY_INTEGER DEFAULT NULL
   pad IN RAW DEFAULT NULL)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this program are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>overlay_str</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The raw string used to overwrite to target</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>target</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The raw string that is to be overlaid/overwritten</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>pos</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The byte position in the target to begin overlaying; the default is 1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>len</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The number of bytes to overwrite; the default is the length of overlay_str</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>pad</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The pad character to fill in extra space if needed; the default is 0x00</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.12.1"
>9.2.3.12.1 Exceptions</A
></H4
><P
CLASS="para"
>The VALUE_ERROR exception (ORA-6502) is raised if one of the folowing occurs:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The input raw string overlay is NULL or has zero length</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The input target is missing or undefined</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The length of the target exceeds the maximum length of a raw, len &lt; 0, or pos &lt; 1 </P
></LI
></UL
><P
CLASS="para"
>The documentation from both version 7.3 and 8.0 indicates that this <EM
CLASS="emphasis"
>is to be revised in a future release</EM
>, so don't count on this exception to remain unchanged.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.12.2"
>9.2.3.12.2 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(OVERLAY, WNDS, RNDS, WNPS, <A
CLASS="indexterm"
NAME="ch09-idx-18562-0"
></A
>RNPS)<A
CLASS="indexterm"
NAME="ch09-idx-18556-0"
></A
>;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.12.3"
>9.2.3.12.3 Example</A
></H4
><P
CLASS="para"
>Here is an example of the OVERLAY function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
  r_input        RAW(40);
  r_overlay      RAW(40);
  start_position INTEGER;
  overlay_length INTEGER;
  r_pad          RAW(2);
  r_output       RAW(40);

BEGIN
  -- set the parameters
  r_input := UTL_RAW.CAST_TO_RAW (
     'This is the full length text string');
  r_overlay := UTL_RAW.CAST_TO_RAW ('overlaid part');
  start_position := 13;
  overlay_length := 8;
  r_pad := UTL_RAW.CAST_TO_RAW ('.');
  r_output := UTL_RAW.OVERLAY (
     r_overlay, r_input, start_position, overlay_length,r_pad);

  DBMS_OUTPUT.PUT_LINE (
     'r_input        ='|| utl_raw.cast_to_varchar2(r_input));
  DBMS_OUTPUT.PUT_LINE (
     'r_output(len 8)='|| UTL_RAW.CAST_TO_VARCHAR2(r_output));
  overlay_length := 16;
  r_output := UTL_RAW.OVERLAY (
     r_overlay, r_input, start_position , overlay_length, r_pad);
  DBMS_OUTPUT.PUT_LINE (
     'r_output(len16)='|| UTL_RAW.CAST_TO_VARCHAR2(r_output));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sample output follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>r_input        =This is the full length text string
r_output(len 8)=This is the overlaidgth text string
r_output(len16)=This is the overlaid part... string</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.13"
>9.2.3.13 The UTL_RAW.REVERSE function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18564-0"
></A
>REVERSE function<A
CLASS="indexterm"
NAME="ch09-idx-18565-0"
></A
> reverses the input raw string and returns this reversed string.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.REVERSE
   (r IN RAW)
RETURN RAW;</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.13.1"
>9.2.3.13.1 Exceptions</A
></H4
><P
CLASS="para"
>The VALUE_ERROR exception (ORA-6502) is raised if the input raw string (r) is null or has zero length. The documentation from both Oracle 7.3 and 8.0 indicates that this <EM
CLASS="emphasis"
>is to be revised in a future release</EM
>, so don't count on this exception to remain unchanged.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.13.2"
>9.2.3.13.2 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(REVERSE, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.13.3"
>9.2.3.13.3 Example</A
></H4
><P
CLASS="para"
>Here is an example of the REVERSE function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
  r_string       RAW(16);
  r_reverse      RAW(16);

BEGIN
  r_string := UTL_RAW.CAST_TO_RAW('Java Beans');
  r_reverse := UTL_RAW.REVERSE(r_string);
  DBMS_OUTPUT.PUT_LINE (
     'r_string='|| UTL_RAW.CAST_TO_VARCHAR2(r_string));
  DBMS_OUTPUT.PUT_LINE (
     'r_reverse='|| UTL_RAW.CAST_TO_VARCHAR2(r_reverse));
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sample output follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>r_string=Java Beans
r_reverse=snaeB avaJ</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.14"
>9.2.3.14 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18566-0"
></A
>SUBSTR function</A
></H4
><P
CLASS="para"
>The SUBSTR function returns a <A
CLASS="indexterm"
NAME="ch09-idx-18567-0"
></A
>substring of the input raw string r beginning at pos and extending for len bytes. If pos is positive, the substring extends len bytes from the left; if pos is negative, the substring extends len bytes from the right (the end backwards). The value of pos cannot be 0. The default for len is to the end of the string r. If r is NULL, then NULL is returned. Here's the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.SUBSTR
    (r IN RAW
    ,pos IN BINARY_INTEGER
    ,len IN BINARY_INTEGER DEFAULT NULL)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The input raw string, from which the substring is extracted</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>pos</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The starting position for the substring extraction</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>len</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The length of the substring to extract; the default is to the end of the input string r</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.14.1"
>9.2.3.14.1 Exceptions</A
></H4
><P
CLASS="para"
>The VALUE_ERROR exception (ORA-6502) is raised if pos is 0 or len is less than 0. The documentation from both Oracle 7.3 and 8.0 indicates that this <EM
CLASS="emphasis"
>is to be revised in a future release</EM
>, so don't count on this exception to remain unchanged.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.14.2"
>9.2.3.14.2 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(SUBSTR, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.14.3"
>9.2.3.14.3 Example</A
></H4
><P
CLASS="para"
>Here is an example of the SUBSTR function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
  r_string       RAW(32);
  r_substring    RAW(16);

BEGIN
  r_string := UTL_RAW.CAST_TO_RAW('This is the test string');
  r_substring := UTL_RAW.SUBSTR(r_string,9,8);
  DBS_OUTPUT.PUT_LINE (
     'r_string='|| UTL_RAW.CAST_TO_VARCHAR2(r_string));
  DBMS_OUTPUT,PUT_LINE (
     'r_substring='|| UTL_RAW.CAST_TO_VARCHAR2(r_substring));
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sample output follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>r_string=This is the test string
r_substring=the test</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-18878"
>9.2.3.15 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18573-0"
></A
>TRANSLATE function</A
></H4
><P
CLASS="para"
>The TRANSLATE function <A
CLASS="indexterm"
NAME="ch09-idx-18585-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18585-1"
></A
>translates bytes in the input raw sting r, substituting bytes found in from_set with positionally corresponding bytes in to_set. The translated string is returned. Bytes in r that do not appear in from_set are not modified. If from_set is longer than to_set, then the unmatched bytes in from_set are removed from the return string. Here's the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.TRANSLATE
   (r IN RAW 
   ,from_set IN RAW
   ,to_set IN RAW)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The input raw string to be translated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>from_set</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The list of bytes to translate</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>to_set</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The list of bytes that from_set bytes are translated to</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>TRANSLATE is similar to TRANSLITERATE; however, with TRANSLATE, the return string can be shorter than the input string r. TRANSLITERATE return strings are always the same length as the input string r. Also, TRANSLATE requires values for from_set, and to_set while TRANSLITERATE has defaults for these inputs.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-18878.1"
>9.2.3.15.1 Exceptions</A
></H4
><P
CLASS="para"
>The VALUE_ERROR exception (ORA-6502) is raised if the r, from_set, or to_set parameters are NULL or have zero length. The documentation from both Oracle 7.3 and 8.0 indicates that this <EM
CLASS="emphasis"
>is to be revised in a future release</EM
>, so don't count on this exception to remain unchanged.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-18878.2"
>9.2.3.15.2 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(TRANSLATE, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-18878.3"
>9.2.3.15.3 Example</A
></H4
><P
CLASS="para"
>An example use of TRANSLATE is a switch case function that switches the case of every character in a text string, swapping upper and lowercase characters. This function also makes use of other UTL_RAW functions: CAST_TO_RAW, XRANGE, and CONCAT. This method may not be the most efficient case-switching technique, but it serves to demonstrate the functions nicely.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE FUNCTION switch_case(c_in IN VARCHAR2)
RETURN VARCHAR2
IS
  r_in           RAW(2000);
  r_out          RAW(2000);
  r_upper        RAW(32);
  r_lower        RAW(32);
  r_upper_lower  RAW(64);
  r_lower_upper  RAW(64);

BEGIN
  /* Convert input to raw */
  r_in := UTL_RAW.CAST_TO_RAW(c_in);

  /* Get raw string of uppercase letters from 'A' to 'Z' */
  r_upper := UTL_RAW.XRANGE(UTL_RAW.CAST_TO_RAW('A'),
     UTL_RAW.CAST_TO_RAW('Z'));
  
  /* Get raw string of lowercase letters from 'a' to 'z' */
  r_lower := UTL_RAW.XRANGE(UTL_RAW.CAST_TO_RAW('a'),
     UTL_RAW.CAST_TO_RAW('z'));

 /* Create a raw string of uppercase followed by lowercase letters */
  r_upper_lower := UTL_RAW.CONCAT(r_upper , r_lower);

 /* Create a raw string of lowercase followed by uppercase letters */
  r_lower_upper := UTL_RAW.CONCAT(r_lower , r_upper);

  /* Translate upper to lower and lower to upper for the input string */
  r_out := UTL_RAW.TRANSLATE(r_in , r_upper_lower , r_lower_upper );

  /* Convert the result back to varchar2 and return the result */
  return(UTL_RAW.CAST_TO_VARCHAR2(r_out));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sample output  follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; select switch_case('This Is A Test') from dual;

SWITCH_CASE('THISISATEST')
----------------------------------------------------
tHIS iS a tEST<A
CLASS="indexterm"
NAME="ch09-idx-18588-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18588-1"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18577-0"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.16"
>9.2.3.16 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-18591-0"
></A
>TRANSLITERATE function</A
></H4
><P
CLASS="para"
>The TRANSLITERATE function translates <A
CLASS="indexterm"
NAME="ch09-idx-18595-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18595-1"
></A
>bytes in the input raw sting r, substituting bytes found in from_set with positionally corresponding bytes in to_set. The translated string is returned. Bytes in r that do not appear in from_set are not modified. If from_set is longer than to_set, then the unmatched bytes in from_set are right-padded with the pad byte. The return string is always the same length as the input string r. The specification follows: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.TRANSLITERATE
   (r IN RAW 
   ,to_set IN RAW DEFAULT NULL
   ,from_set IN RAW DEFAULT NULL
   ,pad IN RAW DEFAULT NULL)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>TRANSLITERATE is similar to TRANSLATE, but it differs in that the return string is always the same length as the input string (r). TRANSLITERATE is just like TRANSLATE if to_set and from_set are the same length. If from_set is longer than to_set, then to_set is right-padded with the pad byte. TRANSLITERATE allows NULL from_set, to_set, and pad parameters. </P
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>r</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Input string to be translated</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>from_set</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The list of bytes to be translated; the default is 0x00 through 0xFF</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>to_set</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The list of bytes that from_set bytes are translated to; the default is NULL</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>pad</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If from_set is shorter than to_set, then this pad byte is the translation character for any unmatched bytes in from_set; the default is 0x00</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.16.1"
>9.2.3.16.1 Exceptions</A
></H4
><P
CLASS="para"
>The VALUE_ERROR exception (ORA-6502) is raised if r is null or has 0 length. The documentation from both Oracle 7.3 and 8.0 indicates that this <EM
CLASS="emphasis"
>is to be revised in a future release</EM
>, so don't count on this exception to remain unchanged.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.16.2"
>9.2.3.16.2 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(TRANSLITERATE, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.16.3"
>9.2.3.16.3 Example</A
></H4
><P
CLASS="para"
>An example use of TRANSLITERATE is a make_lower function that switches uppercase characters in a text string to lowercase characters, converting spaces, dashes, and dots to underscores. This function also makes use of other UTL_RAW functions: CAST_TO_RAW, XRANGE, and CONCAT. This method may not be the most efficient technique for this conversion, but it serves to demonstrate some UTL_RAW functions in an easily understandable context. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE FUNCTION make_lower(c_in IN VARCHAR2)
RETURN VARCHAR2
IS
  r_in           RAW(2000);
  r_out          RAW(2000);
  r_upper        RAW(48);
  r_lower        RAW(32);
  r_underscore   RAW(1);
BEGIN
  -- convert the input to raw
  r_in := UTL_RAW.CAST_TO_RAW(c_in);
  r_underscore := UTL_RAW.CAST_TO_RAW('_');
  -- start the from characters with the uppercase letters
  r_upper :=
UTL_RAW.XRANGE(UTL_RAW.CAST_TO_RAW('A'),UTL_RAW.CAST_TO_RAW('Z'));
  -- space, dash and dot to the from list of characters
  r_upper := UTL_RAW.CONCAT(r_upper,UTL_RAW.CAST_TO_RAW(' ')
            ,UTL_RAW.CAST_TO_RAW('-'),UTL_RAW.CAST_TO_RAW('.'));
  -- set the to characters to be lowercase letters
  r_lower :=
UTL_RAW.XRANGE(UTL_RAW.CAST_TO_RAW('a'),UTL_RAW.CAST_TO_RAW('z'));
  -- convert the uppercase to lowercase and punctuation marks to underscores
  r_out := UTL_RAW.TRANSLITERATE(r_in , r_lower , r_upper, r_underscore);
  -- return the character version
  return(UTL_RAW.CAST_TO_VARCHAR2(r_out));
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sample output <A
CLASS="indexterm"
NAME="ch09-idx-19271-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-19271-1"
></A
>follows:<A
CLASS="indexterm"
NAME="ch09-idx-19278-0"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec DBMS_OUTPUT.PUT_LINE (make_lower('This.is-A tEst'));
this_is_a_test</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-2.3.17"
>9.2.3.17 The UTL_RAW.<A
CLASS="indexterm"
NAME="ch09-idx-19170-0"
></A
>XRANGE function</A
></H4
><P
CLASS="para"
>The XRANGE function returns a <A
CLASS="indexterm"
NAME="ch09-idx-18603-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18603-1"
></A
>raw string containing all bytes in order beginning with the start_byte parameter and ending with end_byte. If start_byte is greater than end_byte, then the return string wraps from 0XFF to 0X00.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION UTL_RAW.XRANGE
   (start_byte IN RAW DEFAULT 0x00
   ,end_byte IN RAW DEFAULT 0xFF)
RETURN RAW;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this program are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>start_byte</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Start byte; the default is 0x00.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>end_byte</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>End byte; the default is 0xFF.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.17.1"
>9.2.3.17.1 Restrictions</A
></H4
><P
CLASS="para"
>This program asserts the following purity level with the RESTRICT_REFERENCES pragma:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(XRANGE, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-2.3.17.2"
>9.2.3.17.2 Example</A
></H4
><P
CLASS="para"
>For an example of XRANGE, see the example for TRANSLATE or TRANSLITERATE.<A
CLASS="indexterm"
NAME="ch09-idx-18417-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18417-1"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch09-38293"
>9.2.4 UTL_REF: Referencing Objects (Oracle8.0.4)</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18604-0"
></A
>UTL_REF package provides a PL/SQL interface that allows you to select and modify <A
CLASS="indexterm"
NAME="ch09-idx-18606-0"
></A
>objects (instances of an object type) in an object table without having to specify or know about the underlying database table. With UTL_REF, you only need a <EM
CLASS="emphasis"
>reference</EM
> to the object in order to identify it in the database and perform the desired operations. With UTL_REF, you can do any of the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Select or retrieve an object from the database</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Lock an object so that no other session can make changes to the object</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Select and lock an object in a single operation (similar to SELECT FOR UPDATE)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Update the contents of an object</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Delete an object</P
></LI
></UL
><P
CLASS="para"
>You will typically use UTL_REF programs when you have references to an object and one of the following is true: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You do not want to have to resort to an SQL statement to perform the needed action.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You do not even <EM
CLASS="emphasis"
>know</EM
> the name of the table that contains the object, and therefore cannot rely on SQL to get your job done.</P
></LI
></UL
><P
CLASS="para"
>Before getting into the details, let's start with an initial example of how you might use the UTL_REF packages.</P
><P
CLASS="para"
>You will be able to use UTL_REF programs only to select or modify objects in an object table. An <A
CLASS="indexterm"
NAME="ch09-idx-18610-0"
></A
>object table is a table in which each row of the table is an object. Here are the steps one might take to create an object table.</P
><P
CLASS="para"
>First, create an object type:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE hazardous_site_t IS OBJECT (
   name VARCHAR2(100),
   location VARCHAR2(100),
   dixoin_level NUMBER,
   pcb_level NUMBER,
   METHOD FUNCTION cleanup_time RETURN NUMBER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now you can create a table of these objects:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE hazardous_sites OF hazardous_site_t;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you will see in the headers for the UTL_REF programs, Oracle has provided a special parameter-passing syntax called <A
CLASS="indexterm"
NAME="ch09-idx-18611-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18611-1"
></A
>ANY. This syntax allows us to pass references and objects of any object type in and out of the programs. This behavior is not otherwise available in Oracle8 built-in packages or the code that you yourself can write using object types.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-3.1"
>9.2.4.1 Getting Started with UTL_REF</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch09-idx-18612-0"
></A
>UTL_REF package is created when the Oracle8.0.4 (or later) database is installed. The <EM
CLASS="emphasis"
>utlref.sql</EM
><A
CLASS="indexterm"
NAME="ch09-idx-20460-0"
></A
> script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1</A
>) contains the source code for this package's specification. The script is called by <EM
CLASS="emphasis"
>catproc.sql</EM
>, which is normally run immediately after the database is created. The script creates the public synonym UTL_REF for the package and grants EXECUTE <A
CLASS="indexterm"
NAME="ch09-idx-20450-0"
></A
>privilege on the package to public. All Oracle users can reference and make use of the package.</P
><P
CLASS="para"
>Every program in this package runs as "owner." This means that programs in the UTL_REF package operate within the privileges of the session running those programs. You will be able to select and modify only objects to which your session has been granted the necessary privileges.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-3.1.1"
>9.2.4.1.1 UTL_REF programs</A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch09_02.htm#ch09-SECT-2.3.5"
>Table 9.5</A
> lists the programs defined for the UTL_REF packages.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch09-38754"
>Table 9.5: UTL_REF <A
CLASS="indexterm"
NAME="ch09-idx-18614-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18614-1"
></A
>Programs</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DELETE_OBJECT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Deletes an object from the underlying object table</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LOCK_OBJECT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locks an object so that another session cannot change the object</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SELECT_OBJECT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Selects an object based on its reference, returning that object as an OUT argument</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UPDATE_OBJECT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Updates the object specified by the reference by replacing it with the object you pass to the program</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>UTL_REF does not declare any nonprogram elements.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-3.1.2"
>9.2.4.1.2 UTL_REF exceptions</A
></H4
><P
CLASS="para"
>UTL_REF does not declare any <A
CLASS="indexterm"
NAME="ch09-idx-18622-0"
></A
>exceptions. However, you may encounter any of the following Oracle exceptions when running the UTL_REF programs:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-00942	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Insufficient privileges. You must have the appropriate privileges on the underlying database table.</P
></DD
><DT
CLASS="term"
>ORA-01031	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Insufficient privileges. You attempted to update an object table on which you have only SELECT privileges. You must have the appropriate privileges on the underlying database table.</P
></DD
><DT
CLASS="term"
>ORA-08177	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Cannot serialize access for this transaction. You have tried to change data after the start of a serialized transaction.</P
></DD
><DT
CLASS="term"
>ORA-00060	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Deadlock detected while waiting for resource. Your session and another session are waiting for a resource locked by the other. You will need to wait or ROLLBACK.</P
></DD
><DT
CLASS="term"
>ORA-01403	</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>No data found. The REF is NULL or otherwise not associated with an object in the database.<A
CLASS="indexterm"
NAME="ch09-idx-18625-0"
></A
></P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch09-SECT-3.2"
>9.2.5 UTL_REF Interface</A
></H3
><P
CLASS="para"
>This section describes the programs available through the UTL_REF package. A single, extended example at the end of the chapter shows how you might be able to take advantage of the UTL_REF programs in your own applications.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-3.2.1"
>9.2.5.1 The UTL_REF.<A
CLASS="indexterm"
NAME="ch09-idx-18627-0"
></A
>DELETE_OBJECT procedure</A
></H4
><P
CLASS="para"
>Use the DELETE_OBJECT procedure to delete an <A
CLASS="indexterm"
NAME="ch09-idx-18628-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18628-1"
></A
>object (actually, the row containing that object) specified by the given reference. The header is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_REF.DELETE_(reference IN REF ANY);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where reference identifies the object.</P
><P
CLASS="para"
>This program effectively substitutes for the following kind of SQL statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DELETE FROM the_underlying_object_table t
 WHERE REF (t) = reference;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In contrast to this SQL statement, with DELETE_OBJECT you will not need to specify the name of the underlying database object table to retrieve the object.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-3.2.1.2"
>9.2.5.1.1 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling DELETE_OBJECT:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot call this program from within an SQL statement, either directly or indirectly.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-3.2.2"
>9.2.5.2 The UTL_REF.<A
CLASS="indexterm"
NAME="ch09-idx-18629-0"
></A
>LOCK_OBJECT procedure</A
></H4
><P
CLASS="para"
>Use the LOCK_OBJECT procedure to lock or lock and retrieve an <A
CLASS="indexterm"
NAME="ch09-idx-18630-0"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18630-1"
></A
><A
CLASS="indexterm"
NAME="ch09-idx-18630-2"
></A
>object for a given reference. The header is overloaded as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_REF.LOCK_OBJECT (reference IN REF ANY);

PROCEDURE UTL_REF.LOCK_OBJECT 
   (reference IN REF ANY
   ,object IN OUT ANY);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>reference</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The reference to the object</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>object</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The value of the object selected from the database (if supplied)</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>If you call LOCK_OBJECT and do not provide a second argument, then the object will be locked, but that object will not be returned to the calling program.</P
><P
CLASS="para"
>This program effectively substitutes for the following type of SQL statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT VALUE (t)
  INTO object
  FROM the_underlying_object_table t
 WHERE REF (t) = reference
   FOR UPDATE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In contrast to this SQL statement, with LOCK_OBJECT you will not need to specify the name of the underlying database object table to retrieve the object.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> It is not necessary to lock an object before you update or delete it. By requesting a lock, however, you ensure that another session cannot even attempt to make changes to that same object until you commit or roll back.</P
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-3.2.2.1"
>9.2.5.2.1 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling LOCK_OBJECT:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot call this program from within an SQL statement, either directly or indirectly.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-3.2.3"
>9.2.5.3 The UTL_REF.<A
CLASS="indexterm"
NAME="ch09-idx-18636-0"
></A
>SELECT_OBJECT procedure</A
></H4
><P
CLASS="para"
>Use the SELECT_OBJECT procedure to retrieve an <A
CLASS="indexterm"
NAME="ch09-idx-18638-0"
></A
>object for a given reference. The header follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_REF.SELECT_OBJECT 
   (reference IN REF ANY
   ,object IN OUT ANY);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>reference</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The reference to the object</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>object</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The value of the object selected from the database</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>This program effectively substitutes for the following type of SQL statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT VALUE (t)
  INTO object
  FROM the_underlying_object_table t
 WHERE REF (t) = reference;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In contrast to this SQL statement, with SELECT_OBJECT you will not need to specify the name of the underlying database object table to retrieve the object.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-3.2.3.1"
>9.2.5.3.1 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling SELECT_OBJECT:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot call this program from within an SQL statement, either directly or indirectly.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-3.2.3.2"
>9.2.5.3.2 Example</A
></H4
><P
CLASS="para"
>In the following procedure, I use the SELECT_OBJECT built-in to retrieve the object based on the passed-in reference:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE show_emp (emp_in IN REF employee_t)
IS
   emp_obj employee_t
BEGIN
   UTL_REF.SELECT_OBJECT (emp_in, emp_obj);
   DBMS_OUTPUT.PUT_LINE (emp_obj.name);
<A
CLASS="indexterm"
NAME="ch09-idx-18644-0"
></A
>END;.<A
CLASS="indexterm"
NAME="ch09-idx-18641-0"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch09-SECT-3.2.4"
>9.2.5.4 The UTL_REF.<A
CLASS="indexterm"
NAME="ch09-idx-18646-0"
></A
>UPDATE_OBJECT procedure</A
></H4
><P
CLASS="para"
>Use the UPDATE_OBJECT procedure to replace an <A
CLASS="indexterm"
NAME="ch09-idx-18650-0"
></A
>object in the database specified by a given reference with your "replacement" object. Here's the header:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE UTL_REF.UPDATE_OBJECT 
   (reference IN REF ANY
   ,object IN ANY);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>reference</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The reference to the object</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>object</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The object that is to be placed in the row of the object table specified by the reference</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>This program effectively substitutes for the following type of SQL statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UPDATE the_underlying_object_table t 
   SET VALUE (t) = object
 WHERE REF (t) = reference;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In contrast to this SQL statement, with UPDATE_OBJECT you will not need to specify the name of the underlying database object table to retrieve the object.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch09-SECT-3.2.4.1"
>9.2.5.4.1 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling UPDATE_OBJECT:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot call this program from within an SQL statement, either directly or  <A
CLASS="indexterm"
NAME="ch09-idx-18652-0"
></A
>indirectly.<A
CLASS="indexterm"
NAME="ch09-idx-18648-0"
></A
></P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch09-SECT-3.3"
>9.2.6 UTL_REF Example</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch09-idx-18654-0"
></A
>Let's start with an object type that can hold various types of documents</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE TYPE Document_t AS OBJECT (
   doc_id NUMBER,
   author VARCHAR2(65),
   created DATE,
   revised DATE,
   body BLOB,
   MEMBER PROCEDURE update_revised
);
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To keep this example simple, we'll implement only a single object method:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE TYPE BODY Document_t
AS
   MEMBER PROCEDURE update_revised
   IS
   BEGIN
      revised := SYSDATE;
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here's a table that will hold any kind of document:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE documents OF Document_t;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>We might have a requisition type that has a special type of document. Each requisition contains a REF to a particular document.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE TYPE Requisition_t AS OBJECT (
   doc_ref REF Document_t,
   needed DATE,
   approved DATE,
   MEMBER PROCEDURE update_revision_date,
   MEMBER FUNCTION has_valid_need_date RETURN BOOLEAN
);
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In a moment, we're going to look at an example of UTL_REF that implements the type body of Requisition_t. But let's first look at life without UTL_REF. Not only do we have to write SQL, we also have to know the table name in each statement where we need access to a persistent object. In fact, the following methods are hard-coded to work with only one particular table implementation (not good): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE TYPE BODY Requisition_t
AS
   MEMBER FUNCTION has_valid_need_date RETURN BOOLEAN
   IS
      document Document_t;
      CURSOR doc_cur IS                /* Ugly! */
         SELECT VALUE(d) 
           FROM documents d
          WHERE REF(d) = SELF.doc_ref;
   BEGIN
      OPEN doc_cur;
      FETCH doc_cur INTO document;    /* Ditto */
      CLOSE doc_cur;
      IF document.created &gt; SELF.approved
      THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END;
   MEMBER PROCEDURE update_revision_date
   IS
   BEGIN
      UPDATE documents d            /* Even uglier */
         SET revised = SYSDATE
       WHERE REF(d) = SELF.doc_ref;
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Let's turn now to see what UTL_REF can do for us:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE TYPE BODY Requisition_t
AS
   MEMBER FUNCTION has_valid_need_date RETURN BOOLEAN
   IS
      document Document_t;
   BEGIN
      /* UTL_REF.SELECT_OBJECT allows us to retrieve the document object 
      || from persistent database storage into a local variable.  No muss, 
      || no fetch, no bother!  SELECT_OBJECT finds the table and object 
      || for us.
      */
      UTL_REF.SELECT_OBJECT (SELF.doc_ref, document);
      /* Now that we have retrieved the document object, we can
      || easily gain access to its attributes:
      */
      IF document.created &gt; SELF.approved
      THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END;
   MEMBER PROCEDURE update_revision_date
   IS
      document Document_t;
   BEGIN
      /* To update the revision date of the requisition object,
      || we'll simply &quot;delegate&quot; to the referenced document.
      || First we retrieve it...
      */
      UTL_REF.SELECT_OBJECT (SELF.doc_ref, document);
      /* ...then we can invoke a method on the newly retrieved
      || (but transient) object.  Notice that we do NOT update
      || the attribute directly, but rely instead on the public
      || method supplied for this purpose.
      */
      document.update_revised;
      /* ...and now we easily update the data in the underlying table
      || (whatever table it is...we don't know or care!)
      */
      UTL_REF.UPDATE_OBJECT(SELF.doc_ref, document);
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since UTL_REF frees us from dependence on the specific underlying table, it allows us to achieve greater reuse, portability, modularity, and <A
CLASS="indexterm"
NAME="ch09-idx-18656-0"
></A
>resilience <A
CLASS="indexterm"
NAME="ch09-idx-18608-0"
></A
>to change.<A
CLASS="indexterm"
NAME="ch09-idx-18605-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_01.htm"
TITLE="9.1 DBMS_ROWID: Working with the ROWID Pseudo-Column (Oracle8 only)"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.1 DBMS_ROWID: Working with the ROWID Pseudo-Column (Oracle8 only)"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch10_01.htm"
TITLE="10. Miscellaneous Packages"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10. Miscellaneous Packages"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>9.1 DBMS_ROWID: Working with the ROWID Pseudo-Column (Oracle8 only)</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10. Miscellaneous Packages</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
