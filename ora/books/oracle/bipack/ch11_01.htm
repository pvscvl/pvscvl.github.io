<HTML
><HEAD
><TITLE
>[Chapter 11] Managing Session Information</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:58:13Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part03.htm"
TITLE="III. Server Management Packages"><LINK
REL="prev"
HREF="part03.htm"
TITLE="III. Server Management Packages"><LINK
REL="next"
HREF="ch11_02.htm#ch11-SECT-2.2.1"
TITLE="11.2 DBMS_System: Setting Events for Debugging"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part03.htm"
TITLE="III. Server Management Packages"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: III. Server Management Packages"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 11</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm#ch11-SECT-2.2.1"
TITLE="11.2 DBMS_System: Setting Events for Debugging"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 11.2 DBMS_System: Setting Events for Debugging"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="PACKAGES-CH-11"
>11. Managing Session Information</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch11-41051"
TITLE="11.1 DBMS_SESSION: Managing Session Information"
>DBMS_SESSION: Managing Session Information</A
><BR><A
CLASS="sect1"
HREF="ch11_02.htm#ch11-SECT-2.2.1"
TITLE="11.2 DBMS_System: Setting Events for Debugging"
>DBMS_System: Setting Events for Debugging</A
></P
><P
></P
></DIV
><P
CLASS="para"
>Oracle technologies allow for a great deal of user customization and security. Language preferences can be specified at the session level using the NLS (National Language Support) options of the ALTER SESSION command. Roles can be used to distinguish groups of users from each other and to modify application behavior accordingly. This chapter describes the following two packages that allow you to perform these operations:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>DBMS_SESSION  </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Contains programs that can modify and inspect session roles and settings from within PL/SQL. This package also contains programs for manipulating session memory and package states; even if they aren't used very often, these programs are very instructive to understand. </P
></DD
><DT
CLASS="term"
>DBMS_SYSTEM </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Lets administrators set various trace events in other users' sessions. Setting these events can be invaluable when tracking down difficult application performance or database issues. </P
></DD
></DL
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch11-41051"
>11.1 DBMS_SESSION: Managing Session Information</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-15703-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15703-1"
></A
>DBMS_SESSION package lets you access and alter session-level settings, including features of the ALTER SESSION and SET ROLE commands in SQL. Some of the session modifications that can be made using DBMS_SESSION include the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
> Enabling and disabling roles</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> Setting National Language Support (NLS) characteristics</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> Resetting package states and releasing session package memory</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> Setting Trusted Oracle label characteristics</P
></LI
></UL
><P
CLASS="para"
>DBMS_SESSION is used primarily to set preferences and security levels for a user's current database session. For instance, if an application requires specific roles to be set prior to performing specific tasks, this can be done using DBMS_SESSION's SET_ROLE procedure. </P
><P
CLASS="para"
>Most of the programs in DBMS_SESSION would not likely be called deep in the processing layers of application code, but rather invoked early in the application to establish a necessary, appropriate, or preferred context for the user of the application. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-SECT-1.1"
>11.1.1 Getting Started with DBMS_SESSION</A
></H3
><P
CLASS="para"
>The DBMS_SESSION package is <A
CLASS="indexterm"
NAME="ch11-idx-16428-0"
></A
>created when the Oracle database is installed. The <I
CLASS="filename"
>dbmsutil.sql</I
> script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1, <CITE
CLASS="chapter"
>Introduction</CITE
></A
>), contains the source code for this package's specification. This script is called by <I
CLASS="filename"
>catproc.sql</I
>, which is normally run immediately after database creation. The script creates the public synonym DBMS_SESSION for the package and grants EXECUTE <A
CLASS="indexterm"
NAME="ch11-idx-17153-0"
></A
>privilege on the package to public. This way, all Oracle users can reference and make use of this package.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.1.1"
>11.1.1.1 DBMS_SESSION programs </A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch11_01.htm"
>Table 11.1</A
> <A
CLASS="indexterm"
NAME="ch11-idx-15990-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15990-1"
></A
>lists the programs found in the DBMS_SESSION package. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch11-38401"
>Table 11.1: DBMS_SESSION Programs </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15720-0"
></A
>CLOSE_DATABASE_LINK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Closes an inactive but open database link</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15721-0"
></A
>FREE_UNUSED_USER_MEMORY</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Releases unused session memory</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15718-0"
></A
>IS_ROLE_ENABLED</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns TRUE if role enabled</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15722-0"
></A
>RESET_PACKAGE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Clears all persistent package state</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15723-0"
></A
>SET_CLOSE_CACHED_OPEN_CURSORS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Turns automatic closing of cached cursors on or off</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15714-0"
></A
>SET_LABEL</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sets Trusted Oracle label</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15715-0"
></A
>SET_MLS_LABEL_FORMAT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sets Trusted Oracle MLS label format</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15716-0"
></A
>SET_NLS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sets National Language Support characteristics for the session</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15717-0"
></A
>SET_ROLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Enables or disables roles for the session</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15724-0"
></A
>SET_SQL_TRACE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Turns session SQL tracing on or off</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15719-0"
></A
>UNIQUE_SESSION_ID</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns a unique character string for the session </P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-17154-0"
></A
>DBMS_SESSION does not declare any exceptions of its own or any nonprogram elements.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-SECT-1.2"
>11.1.2 Modifying Session Settings</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15726-0"
></A
>This section describes the procedures you can use to modify various session settings: SET_LABEL, SET_MLS_LABEL_FORMAT, SET_NLS, and SET_ROLE.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.2.1"
>11.1.2.1 The DBMS_SESSION.<A
CLASS="indexterm"
NAME="ch11-idx-15730-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15730-1"
></A
>SET_LABEL procedure</A
></H4
><P
CLASS="para"
>The SET_LABEL procedure sets the session's label used by Trusted Oracle databases. The header looks like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.SET_LABEL
    (lbl IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The lbl parameter contains the label for the session.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23622"
>11.1.2.1.1 Exceptions</A
></H4
><P
CLASS="para"
>The SET_LABEL procedure does not raise any package exceptions. If Trusted Oracle is not installed, calling SET_LABEL results in the following Oracle exception:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-02248</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Invalid option for ALTER SESSION.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23630"
>11.1.2.1.2 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling SET_LABEL: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>DBMS_SESSION.SET_LABEL is not allowed in remote sessions. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23638"
>11.1.2.1.3 Example</A
></H4
><P
CLASS="para"
>This example uses the SET_LABEL procedure to set the session label to DBHIGH:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.SET_LABEL('DBHIGH');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>For more information on SET_LABEL parameters, see the <EM
CLASS="emphasis"
>Trusted Oracle7 Server Administrator's Guide</EM
>.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.2.2"
>11.1.2.2 DBMS_SESSION.SET_MLS_LABEL_FORMAT procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-15731-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15731-1"
></A
>SET_MLS_LABEL_FORMAT procedure sets the session's default format for the labels used by Trusted Oracle databases.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.SET_MLS_LABEL_FORMAT
   (fmt IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The fmt parameter is a VARCHAR2 that contains the label format for the session.</P
><P
CLASS="para"
>The program does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23655"
>11.1.2.2.1 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling SET_MLS_LABEL_FORMAT: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>DBMS_SESSION.SET_MLS_LABEL_FORMAT is not allowed in remote sessions. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23663"
>11.1.2.2.2 Example</A
></H4
><P
CLASS="para"
>For more information on MLS label formats, see the <EM
CLASS="emphasis"
>Trusted Oracle7 Server Administrator's</EM
> <A
CLASS="indexterm"
NAME="ch11-idx-15733-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15733-1"
></A
><EM
CLASS="emphasis"
>Guide</EM
>.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.2.3"
>11.1.2.3 The DBMS_SESSION.SET_NLS procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-15735-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15735-1"
></A
>SET_NLS procedure sets or alters National Language Support characteristics for the current session. The SET_NLS header looks like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.SET_NLS
   (param IN VARCHAR2
   ,value IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table. </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>param</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NLS parameter being set for the session (see following list of values)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>value</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Value of the specified parameter</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The following session NLS characteristics can be set via this procedure; specify the desired one as the value of the param parameter:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
> <A
CLASS="indexterm"
NAME="ch11-idx-15754-0"
></A
>NLS_CALENDAR
 <A
CLASS="indexterm"
NAME="ch11-idx-15756-0"
></A
>NLS_CURRENCY
 <A
CLASS="indexterm"
NAME="ch11-idx-15745-0"
></A
>NLS_DATE_FORMAT
 NLS_DATE_LANGUAGE
 NLS_ISO_CURRENCY
 <A
CLASS="indexterm"
NAME="ch11-idx-15746-0"
></A
>NLS_LANGUAGE
 <A
CLASS="indexterm"
NAME="ch11-idx-15747-0"
></A
>NLS_NUMERIC_CHARACTERS
 <A
CLASS="indexterm"
NAME="ch11-idx-15748-0"
></A
>NLS_SORT
 <A
CLASS="indexterm"
NAME="ch11-idx-15749-0"
></A
>NLS_SPECIAL_CHARS
 <A
CLASS="indexterm"
NAME="ch11-idx-15750-0"
></A
>NLS_TERRITORY</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23719"
>11.1.2.3.1 Exceptions</A
></H4
><P
CLASS="para"
>The DBMS_SESSION.SET_NLS procedure does not raise any exceptions. However, if the value parameter represents a format mask (which would be double-quoted in the ALTER SESSION command) it needs to be enclosed in triple quotes. Otherwise, the following Oracle error will be raised:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-00922</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Missing or invalid option.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23727"
>11.1.2.3.2 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling this procedure:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>SET_NLS cannot be called from <A
CLASS="indexterm"
NAME="ch11-idx-15758-0"
></A
>triggers.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>SET_NLS is not allowed in remote sessions.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The procedure does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23740"
>11.1.2.3.3 Examples</A
></H4
><P
CLASS="para"
>To change the default date format for the current session, as used by the TO_CHAR and TO_DATE functions, specify the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.SET_NLS('NLS_DATE_FORMAT','''YYYY:MM:DD''');
   DBMS_OUTPUT.PUT_LINE(TO_CHAR(SYSDATE));
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The above PL/SQL block produces a result similar to this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>1997:07:26</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Enclose the NLS parameter name in single quotes if it is passed as a string literal. Another option is to initialize a VARCHAR2 variable to the parameter value and pass the variable name for the param parameter. In this case, the variable name is not quoted in the call to SET_NLS.</P
><P
CLASS="para"
>As mentioned previously, if the value parameter represents a format mask (which would be double-quoted in the ALTER SESSION command) it needs to be enclosed in triple quotes. Otherwise, the ORA-00092 Oracle error will be raised.</P
><BLOCKQUOTE
CLASS="warning"
><P
CLASS="para"
><STRONG
>WARNING:</STRONG
> The following sample code and output reveals a problem with the Oracle7.3 DBMS_SESSION.SET_NLS procedure. The NLS_DATE_FORMAT being passed in is valid, yet the procedure will generate an unhandled exception. This problem appears to have been fixed in the Oracle 8.0 package.</P
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT='YYYY:MM:DD:HH24:MI:SS';
Session altered.

SQL&gt; BEGIN
  2  DBMS_SESSION.SET_NLS('NLS_DATE_FORMAT','&quot;YYYY:MM:DD:HH24:MI:SS&quot;');
  3  END;
  4  /
BEGIN
*
ORA-06510: PL/SQL: unhandled user-defined exception 
ORA-06512: at &quot;SYS.DBMS_SESSION&quot;, line 46 
ORA-06512: at line 2 </PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can query the NLS settings for the current session from the V$NLS_PARAMETERS virtual table as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT parameter, value
  FROM v$nls_parameters;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>See the <EM
CLASS="emphasis"
>Oracle7 Server Reference Manual</EM
> for information on the possible meanings and values for the various NLS <A
CLASS="indexterm"
NAME="ch11-idx-15737-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15737-1"
></A
>settings.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.2.4"
>11.1.2.4 The DBMS_SESSION.SET_ROLE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-15759-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15759-1"
></A
>SET_ROLE procedure enables and disables roles for the current session. It is equivalent to executing the SET ROLE command in SQL. The procedure call simply appends the text of the single parameter, role_cmd, to the string "SET ROLE" and executes the resulting SQL command. The SET_ROLE header looks like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.SET_ROLE
       (role_cmd IN VARCHAR2);</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23767"
>11.1.2.4.1 Exceptions</A
></H4
><P
CLASS="para"
>The program does not raise any package exceptions. It can raise the following Oracle exceptions due to improper data in the role_cmd parameter:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-01919 </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Role "rolename" does not exist.</P
></DD
><DT
CLASS="term"
>ORA-01979 </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Missing or invalid password for role "rolename."</P
></DD
><DT
CLASS="term"
>ORA-01924</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Role "rolename" not granted or does not exist.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23783"
>11.1.2.4.2 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling the SET_ROLE procedure:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>SET_ROLE cannot be called from <A
CLASS="indexterm"
NAME="ch11-idx-15763-0"
></A
>triggers.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>SET_ROLE cannot be called from PL/SQL stored procedures or functions.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>SET_ROLE does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
><P
CLASS="para"
>To successfully enable a role, the user must already have been granted the role. After executing the SET_ROLE procedure, only the roles specified in the procedure call will be enabled.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23797"
>11.1.2.4.3 Examples</A
></H4
><P
CLASS="para"
>Set the password-protected role SPECIAL_ROLE in the current session like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.SET_ROLE('SPECIAL_ROLE IDENTIFIED BY password');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Disable all roles in the current session like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.SET_ROLE('NONE');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Set multiple roles for the current session like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.SET_ROLE('ROLE1, ROLE2, ROLE3');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The role_cmd parameter is case-insensitive, which is the default behavior for role names in the Oracle catalog. To set a case-sensitive role, the role name must be double-quoted in the role_cmd parameter. For example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.SET_ROLE('&quot;special_role&quot;');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that the lowercase role name special_role is double-quoted and also contained in a string literal delimited by single quotes.</P
><P
CLASS="para"
>See the <EM
CLASS="emphasis"
>Oracle7 Server SQL Reference</EM
> for more details about the SET <A
CLASS="indexterm"
NAME="ch11-idx-15761-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15761-1"
></A
>ROLE <A
CLASS="indexterm"
NAME="ch11-idx-15728-0"
></A
>command.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-SECT-1.3"
>11.1.3 Obtaining Session Information</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15764-0"
></A
>This section describes the functions you can use to obtain information about a session: IS_ROLE_ENABLED and UNIQUE_SESSION_ID.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.3.1"
>11.1.3.1 The DBMS_SESSION.IS_ROLE_ENABLED function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-15775-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15775-1"
></A
>IS_ROLE_ENABLED function returns TRUE or FALSE depending on whether the role specified in the rolename parameter is enabled. The header for this function follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SESSION.IS_ROLE_ENABLED
   (rolename IN VARCHAR2)
RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The rolename parameter specifies the name of the role. </P
><P
CLASS="para"
>The IS_ROLE_ENABLED function does not raise any declared exceptions and does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23831"
>11.1.3.1.1 Example</A
></H4
><P
CLASS="para"
>The following PL/SQL block will detect whether the user's session currently has the CONNECT role enabled:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   IF DBMS_SESSION.IS_ROLE_ENABLED('CONNECT');
   THEN
      DBMS_OUTPUT.PUT_LINE('CONNECT IS ENABLED');
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>An application might use this function to implement role-dependent behavior as in the following code fragment:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF DBMS_SESSION.IS_ROLE_ENABLED('APP_ADMIN')
THEN
   /*
   || do special administrative logic here
   */
   app_admin_setup;
ELSE
   /*
   || do the normal user logic here
   */
   user_setup;
END IF;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> The IS_ROLE_ENABLED function is case-sensitive on the rolename parameter, so beware of unexpected results. The default behavior is for role names to be uppercase in the Oracle catalog, so it is probably best to cast the rolename to uppercase prior to calling this function.</P
></BLOCKQUOTE
><P
CLASS="para"
>For example, in the following block, the variable return_TF will be set to FALSE when CONNECT is enabled for the session because the CONNECT role is uppercase in the <A
CLASS="indexterm"
NAME="ch11-idx-15770-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15770-1"
></A
>catalog:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   return_TF   BOOLEAN;
BEGIN
   return_TF := DBMS_SESSION.IS_ROLE_ENABLED('connect');
END;</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.3.2"
>11.1.3.2 The DBMS_SESSION.UNIQUE_SESSION_ID function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-15777-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15777-1"
></A
>UNIQUE_SESSION_ID function returns a character string unique to the session among all sessions currently connected to the database. The return string can be up to 24 bytes in length. Multiple calls to the function from the same session will always return the same string. The program header follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SESSION.UNIQUE_SESSION_ID
RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The UNIQUE_SESSION_ID function does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23853"
>11.1.3.2.1 Restrictions</A
></H4
><P
CLASS="para"
>Prior to Oracle 7.3.3, this function did not assert a purity level with the RESTRICT_REFERENCES pragma. In Oracle 7.3.3 and above, the program asserts the following purity:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES(UNIQUE_SESSION_ID,WNDS,RNDS,WNPS);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Thus, you can call the UNIQUE_SESSION_ID function directly in SQL for Oracle databases at release 7.3.3 and later.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23858"
>11.1.3.2.2 Example</A
></H4
><P
CLASS="para"
>To display the value of the unique id for the current session, specify the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE 
   my_unique_id   VARCHAR2(30);
BEGIN
   my_unique_id := DBMS_SESSION.UNIQUE_SESSION_ID;
   DBMS_OUTPUT.PUT_LINE('UNIQUE ID: '||my_unique_id);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>An example of output from executing the preceding PL/SQL block follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UNIQUE ID: F000E4020000</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15778-0"
></A
>UNIQUE_SESSION_ID is functionally identical to the DBMS_PIPE.UNIQUE_SESSION_NAME function; however, their return values are <EM
CLASS="emphasis"
>not</EM
> identical. Be very careful not to write code that assumes that these two functions <A
CLASS="indexterm"
NAME="ch11-idx-15867-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15867-1"
></A
>are <A
CLASS="indexterm"
NAME="ch11-idx-15766-0"
></A
>equivalent.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Ace technical reviewer Phil Pitha points out that the two functions may be related. He writes that it appears that DBMS_PIPE.UNIQUE_SESSION_NAME returns an id of the format: `ORA$PIPE$' || DBMS_SESSION.UNIQUE_SESSION_ID.</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-SECT-1.4"
>11.1.4 Managing Session Resources</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15784-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15784-1"
></A
>This section describes the procedures you can use to manage your session resources: CLOSE_DATABASE_LINK, FREE_UNUSED_USER_MEMORY, RESET_PACKAGE, SET_CLOSE_CACHED_OPEN_CURSORS, and SET_SQL_TRACE. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.4.1"
>11.1.4.1 The DBMS_SESSION.<A
CLASS="indexterm"
NAME="ch11-idx-15789-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15789-1"
></A
>CLOSE_DATABASE_LINK procedure</A
></H4
><P
CLASS="para"
>The CLOSE_DATABASE_LINK procedure is used to close an open but inactive database link in the session. The header for the program is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.CLOSE_DATABASE_LINK
   (dblink IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where dblink specifies the name of the database link.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23892"
>11.1.4.1.1 Exceptions</A
></H4
><P
CLASS="para"
>The CLOSE_DATABASE_LINK procedure does not raise any package exceptions. It can raise the following Oracle exceptions when the referenced database link cannot be closed:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-02080</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Database link is in use.</P
></DD
><DT
CLASS="term"
>ORA-02081</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Database link is not open.</P
></DD
></DL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23904"
>11.1.4.1.2 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling CLOSE_DATABASE_LINK:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>All cursors using the database link must be closed, and any transactions that reference the link (for UPDATE or SELECT purposes) must be ended (with COMMIT or ROLLBACK).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23912"
>11.1.4.1.3 Example</A
></H4
><P
CLASS="para"
>To close a database link named LOOPBACK, specify the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.CLOSE_DATABASE_LINK('LOOPBACK');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Use of database links establishes a proxy session for the local user on the remote database, and this is a relatively expensive process. This is why Oracle keeps database links open rather than closing them immediately upon completion of the remote operation. Therefore, the CLOSE_DATABASE_LINK procedure probably should not be routinely called, especially for database links that are likely to be referenced again in the current <A
CLASS="indexterm"
NAME="ch11-idx-15791-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15791-1"
></A
>session.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.4.2"
>11.1.4.2 The DBMS_SESSION.FREE_UNUSED_USER_MEMORY procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-15793-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15793-1"
></A
>FREE_UNUSED_USER_MEMORY procedure is used to reclaim user session memory, especially when memory-intensive operations have been performed in the session. The header for this procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.FREE_UNUSED_USER_MEMORY;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The FREE_UNUSED_USER_MEMORY procedure does not raise any exceptions and does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
><P
CLASS="para"
>Oracle Corporation recommends that this procedure be used only when memory is at a premium and the session has allocated large (greater than 100 Kb) amounts. This caution indicates that calling the FREE_UNUSED_USER_MEMORY procedure is itself a relatively expensive operation and should be done only when really necessary. Calling the procedure forces Oracle to deallocate any session memory previously allocated but currently unused.</P
><P
CLASS="para"
>The following examples are the kinds of operations that can lead to large memory allocations:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In-memory sorts where the SORT_AREA_SIZE initialization parameter is large</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Compilation of large PL/SQL packages, procedures, and functions</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use of PL/SQL tables to store large amounts of data</P
></LI
></UL
><P
CLASS="para"
>In each of these cases, memory allocated for a specific purpose can only be re-used by Oracle for that same purpose. For example, memory allocated to the session for large PL/SQL compilations will not be reused later for anything but compilation of PL/SQL. If no more compilation is anticipated and memory is scarce, this is a good time to call FREE_UNUSED_USER_MEMORY.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15797-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15797-1"
></A
>In the case of PL/SQL tables, the scope of the table determines when memory allocated to the table is no longer in use and can be freed. Memory allocated for tables declared locally by procedures and functions becomes unused once the module completes execution. Other PL/SQL tables (local or global) can then make use of this memory. However, the memory remains allocated to the session. Global tables (i.e., tables declared at the package level) have persistent scope, and the memory associated with them can be made reusable only by assigning a NULL table to them. In either case, once the memory is made reusable, it is also eligible to be freed (deallocated from the session) using the FREE_UNUSED_USER_MEMORY procedure. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch11_01.htm"
>Figure 11.1</A
> illustrates the relationship between session memory and local versus global PL/SQL tables. In the figure, after package1.procedure1 executes and FREE_UNUSED_USER_MEMORY is called, the memory for PL/SQL table2 is still allocated to the session. On the other hand, package2.procedure1 declares both tables locally, so that all the memory they use can be freed after the procedure completes. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch11-24162"
>Figure 11.1: Package architecture and persistent session memory</A
></H4
><IMG
CLASS="graphic"
SRC="figs/obip.1101.gif"
ALT="Figure 11.1"><P
CLASS="para"
>Memory freed by calling this procedure is returned to either the operating system or the Oracle shared pool. This depends on the Oracle configuration and session connection as follows:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Sessions connected through multithreaded servers return memory to the <A
CLASS="indexterm"
NAME="ch11-idx-15798-0"
></A
>shared pool.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Sessions with dedicated server connections return memory to the operating system.</P
></LI
></UL
><P
CLASS="para"
>Session memory can be monitored through the statistics for "session uga memory" and "session pga memory" found in the V$SESSTAT virtual table. </P
><P
CLASS="para"
>See the DBMS_SESSION package specification in the <I
CLASS="filename"
>dbmsutil.sql</I
> file for more information on session memory and the effects of the FREE_UNUSED_USER_MEMORY <A
CLASS="indexterm"
NAME="ch11-idx-15795-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15795-1"
></A
>procedure. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.4.3"
>11.1.4.3 The DBMS_SESSION.RESET_PACKAGE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-15799-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15799-1"
></A
>RESET_PACKAGE procedure resets all package states for the session. The values of any persistent package variables will be lost after execution of this procedure. The header for this procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.RESET_PACKAGE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
> The RESET_PACKAGE procedure does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23975"
>11.1.4.3.1 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling RESET_PACKAGE:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Use the RESET_PACKAGE procedure with great caution, as it will cause the loss of package state in all packages for the current session. Applications making use of persistent package variables may be compromised and fail to work properly after calls to RESET_PACKAGE. Therefore, in general, don't embed calls to this procedure in application programs. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The program does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-23983"
>11.1.4.3.2 Example</A
></H4
><P
CLASS="para"
>The output buffer used by DBMS_OUTPUT is actually a global package data structure that is initialized when either DBMS_OUTPUT.ENABLE or SET SERVEROUTPUT ON is called in PL/SQL or SQL*Plus, respectively.</P
><P
CLASS="para"
>The following PL/SQL block will not display the message, because the call to RESET_PACKAGE clears out the DBMS_OUTPUT buffer: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.RESET_PACKAGE;
   DBMS_OUTPUT.PUT_LINE('This is an invisible message');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15807-0"
></A
>Although calling RESET_PACKAGE will clear all persistent package variables, including PL/SQL tables and records, it will not automatically release the session memory used by these structures. To release session memory back to the operating system (or Oracle shared pool), use the FREE_UNUSED_USER_MEMORY procedure.</P
><P
CLASS="para"
>Note that package states cannot be reinstantiated until the outermost PL/SQL calling scope within which RESET_PACKAGE was called completes. This variation on the previous example illustrates the effect of RESET_PACKAGE within its calling scope:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch11-idx-15808-0"
></A
>sess1.sql */*
set serveroutput on size 1000000
BEGIN
   DBMS_SESSION.RESET_PACKAGE;
   DBMS_OUTPUT.PUT_LINE('You will not see this');
   DBMS_OUTPUT.ENABLE;
   DBMS_OUTPUT.PUT_LINE('Also invisible, since in same scope '||
                        'as RESET_PACKAGE call');
END;
/
set serveroutput on size 1000000
BEGIN
   DBMS_OUTPUT.PUT_LINE('New package states instantiated '||
                        'messages visible again!');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Output from running this script follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @c:\opbip\examples\sess1.sql

PL/SQL procedure successfully completed.

New package states instantiated messages visible again!                                             

PL/SQL procedure successfully completed.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, only the final call to DBMS_OUTPUT.PUT_LINE displays its message. The second call to DBMS_OUTPUT.PUT_LINE in the first block fails to produce output because the buffer used by DBMS_OUTPUT cannot be reinitialized within the same calling scope as <A
CLASS="indexterm"
NAME="ch11-idx-15801-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15801-1"
></A
>RESET_PACKAGE. </P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.4.4"
>11.1.4.4 The DBMS_SESSION.<A
CLASS="indexterm"
NAME="ch11-idx-15809-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15809-1"
></A
>SET_CLOSE_CACHED_OPEN_CURSORS procedure</A
></H4
><P
CLASS="para"
>The SET_CLOSE_CACHED_OPEN_CURSORS procedure is used to set the close_cached_open_cursors property at the session level, overriding the database-wide setting established by the CLOSE_CACHED_OPEN_CURSORS initialization parameter. The header for this procedure looks like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.SET_CLOSE_CACHED_OPEN_CURSORS
   (close_cursors IN BOOLEAN);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The close_cursors parameter causes cached PL/SQL cursors to be automatically closed with a value of TRUE or kept open with a value of FALSE.</P
><P
CLASS="para"
>The SET_CLOSE_CACHED_OPEN_CURSORS procedure does not raise any declared exceptions and does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24013"
>11.1.4.4.1 Example</A
></H4
><P
CLASS="para"
>To set CLOSE_CACHED_OPEN_CURSORS to on for the current session, specify the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.SET_CLOSE_CACHED_OPEN_CURSORS(TRUE);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Most applications will probably have no need to use this procedure. When set to TRUE, the Oracle database will automatically close any cached PL/SQL cursors after a COMMIT or ROLLBACK, which releases the memory used by these cursors. When set to FALSE, cursors are held open in the cache across transactions, making subsequent executions somewhat faster. Applications that tend to use large cursors in a one-time or infrequent fashion (e.g., ad hoc query systems against a data warehouse) may benefit from setting this value to TRUE.</P
><P
CLASS="para"
>See the <EM
CLASS="emphasis"
>Oracle7 Server Reference Manual</EM
> for more information on the CLOSE_CACHED_OPEN_CURSORS initialization parameter.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.4.5"
>11.1.4.5 The DBMS_SESSION.<A
CLASS="indexterm"
NAME="ch11-idx-15810-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15810-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15810-2"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15810-3"
></A
>SET_SQL_TRACE procedure</A
></H4
><P
CLASS="para"
>The SET_SQL_TRACE procedure is equivalent to the ALTER SESSION SET SQL_TRACE command. It is used to turn the Oracle SQL trace facility on or off for the session, primarily while debugging application problems. The SET_SQL_TRACE header looks like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SESSION.SET_SQL_TRACE
    (sql_trace IN BOOLEAN);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The sql_trace parameter sets the trace on if TRUE, off if FALSE.</P
><P
CLASS="para"
>The SET_SQL_TRACE procedure does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24038"
>11.1.4.5.1 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling SET_SQL_TRACE:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In general, use the SET_SQL_TRACE procedure only when debugging application problems. Tracing session SQL calls adds overhead to the database and can generate numerous and sizable trace files on the host server.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The SET_SQL_TRACE procedure does not assert a purity level with the RESTRICT_REFERENCES pragma.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-24046"
>11.1.4.5.2 Example</A
></H4
><P
CLASS="para"
>Generate a trace file for the execution of a specific PL/SQL procedure call like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SESSION.SET_SQL_TRACE(TRUE);
   <I
CLASS="replaceable"
>plsql_procedure_call</I
>;
   DBMS_SESSION.SET_SQL_TRACE(FALSE);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The trace files generated when SQL tracing is turned on are created in the directory specified by the USER_DUMP_DEST initialization parameter for the Oracle database to which the session is connected. </P
><P
CLASS="para"
>Trace file naming conventions often make it difficult to identify the correct trace file when there are many in the directory specified by USER_DUMP_DEST. Executing a "tag" SQL statement after turning tracing on can facilitate trace file identification.</P
><P
CLASS="para"
>The trace files generated when SQL tracing is turned on are not directly readable. The Oracle utility program TKPROF can be used to generate a formatted summary of the trace file contents. The TKPROF output contains statistics on CPU time, elapsed time, and disk reads for the parse, execute, and fetch steps of each SQL statement in the trace file. This information can be invaluable when tracking down performance problems in complex applications. See the <EM
CLASS="emphasis"
>Oracle7 Server Tuning</EM
> manual for instructions on <A
CLASS="indexterm"
NAME="ch11-idx-15812-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15812-1"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15812-2"
></A
>using <A
CLASS="indexterm"
NAME="ch11-idx-15787-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15787-1"
></A
>TKPROF.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-SECT-1.5"
>11.1.5 DBMS_SESSION Examples</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-17117-0"
></A
>The DBMS_SESSION package is a kind of grab bag of ways to alter the user's current session characteristics in an Oracle database. Oracle provides a great deal of flexibility with respect to language settings and security. DBMS_SESSION includes several programs that are equivalent to the SQL commands SET ROLE and ALTER SESSION normally used to establish these settings. The following programs in DBMS_SESSION fall into this category:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>SET_LABEL</TD
></TR
><TR
><TD
CLASS="member"
>SET_MLS_LABEL_FORMAT</TD
></TR
><TR
><TD
CLASS="member"
>SET_NLS </TD
></TR
><TR
><TD
CLASS="member"
>SET_ROLE</TD
></TR
></TABLE
><P
CLASS="para"
>These programs are "high-level," in that they would normally be called directly from an application program and not be buried deep inside layers of PL/SQL code. In fact, the SET_ROLE procedure can only be called from anonymous PL/SQL blocks and not from within stored program (procedures and functions) code. So in practice, an application would begin by prompting the user for preferences, issue the appropriate DBMS_SESSION.SET procedure calls, and then move on to the real work.</P
><P
CLASS="para"
>Other programs in DBMS_SESSION are geared toward manipulating session-level resource utilization, particularly memory. In this category are the following DBMS_SESSION programs:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>SET_CLOSE_CACHED_OPEN_CURSORS</TD
></TR
><TR
><TD
CLASS="member"
>CLOSE_DATABASE_LINK</TD
></TR
><TR
><TD
CLASS="member"
>FREE_UNUSED_USER_MEMORY</TD
></TR
><TR
><TD
CLASS="member"
>RESET_PACKAGE</TD
></TR
></TABLE
><P
CLASS="para"
>These are also quite "high-level" routines, but more likely to find their way into application code under the right <A
CLASS="indexterm"
NAME="ch11-idx-17124-0"
></A
>circumstances. </P
><P
CLASS="para"
>One thing that DBMS_SESSION does not have (and that it should) is a function to return the current session id. This is frequently asked for by developers and DBAs and is relatively easy to provide. </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> The source code for all of the examples is in a file called <I
CLASS="filename"
>mysess.sql,</I
> which creates the package called my_session shown in this section that includes these examples.</P
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.5.1"
>11.1.5.1 Adding value to DBMS_SESSION</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15820-0"
></A
>Let's take a look at how we can use DBMS_SESSION and add a little value along the way. I've created a package called my_session to do just that. Here is the package specification: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch11-idx-15824-0"
></A
>mysess.sql */*
CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch11-idx-15859-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15859-1"
></A
>my_session
   /*
   || Extends some of the functionality of DBMS_SESSION
   || and provides access to additional session-level 
   || information.
   ||
   || Author:  John Beresniewicz, Savant Corp
   ||
   || 12/22/97: exposed load_unique_id as/per Phil Pitha
   || 09/07/97: modified function SID to assert WNPS
   ||           and not call load_my_session_rec 
   || 07/27/97: created
   ||
   || Compilation Requirements: 
   ||
   || SELECT on sys.v_$session   
   || SELECT on sys.v_$sesstat
   || SELECT on sys.v_$statname
   || 
   || Execution Requirements:
   ||
   || ALTER SESSION
   */
AS
   /* same as DBMS_SESSION.UNIQUE_SESSION_ID but callable in SQL */
   FUNCTION <A
CLASS="indexterm"
NAME="ch11-idx-15860-0"
></A
>unique_id RETURN VARCHAR2;
   PRAGMA RESTRICT_REFERENCES(unique_id, WNDS,WNPS);

   /*
   || loads unique_session_id into global variable, must be called 
   || prior to using function unique_id  
   */
   PROCEDURE <A
CLASS="indexterm"
NAME="ch11-idx-15861-0"
></A
>load_unique_id;

   /* returns session id of current session, callable in SQL */
   FUNCTION sid RETURN NUMBER;
   PRAGMA RESTRICT_REFERENCES(sid,WNDS,WNPS);

   /* closes any open database links not in use */
   PROCEDURE <A
CLASS="indexterm"
NAME="ch11-idx-15862-0"
></A
>close_links
      (force_with_commit_TF IN BOOLEAN DEFAULT FALSE);

   /* loads session data, should be private but needs to assert purity */
   PROCEDURE <A
CLASS="indexterm"
NAME="ch11-idx-15863-0"
></A
>load_my_session_rec;
   PRAGMA RESTRICT_REFERENCES(load_my_session_rec,WNDS);

   /* resets package states and frees memory */
   PROCEDURE <A
CLASS="indexterm"
NAME="ch11-idx-15864-0"
></A
>reset;

   /* returns current stat value from V$SESSTAT for this session */
   FUNCTION statval(statname_IN IN VARCHAR2) RETURN NUMBER;

   /* displays session uga and pga using DBMS_OUTPUT */
   PROCEDURE memory;

   /* turns SQL tracing on/off with tag for file identification */
   PROCEDURE <A
CLASS="indexterm"
NAME="ch11-idx-15865-0"
></A
>set_sql_trace
      (trace_TF IN  BOOLEAN
      ,tag_IN  IN  VARCHAR2 DEFAULT USER);

END my_session;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You will notice that several of the programs seem very similar to programs in DBMS_SESSION. Well, they are, but with some important differences.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.5.2"
>11.1.5.2 The unique_id function</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15869-0"
></A
>Prior to Oracle 7.3.3, the DBMS.SESSION.UNIQUE_SESSION_ID function did not assert any purity level using the RESTRICT_REFERENCES pragma and thus could not be called directly from SQL statements. This is unfortunate, because one nice potential use of the function is as an identifier for applications making use of shared temporary tables. In other words, some applications will find it useful to do things like the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO temp_table (session_id, other_columns...) 
VALUES (DBMS_SESSION.UNIQUE_SESSION_ID, other_columns...);</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DELETE FROM temp_table 
 WHERE session_id = DBMS_SESSION.UNIQUE_SESSION_ID;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Thankfully, Oracle Corporation has corrected this shortcoming in the latest releases of DBMS_SESSION. For those not fortunate enough to be using 7.3.3 or 8.0, the my_session.unique_id function can be used as a workaround. This function returns the same string as DBMS_SESSION.UNIQUE_SESSION_ID, yet it asserts a purity level of WNDS and can thus be called from SQL.</P
><P
CLASS="para"
>Here is the source to unique_id and its companion procedure load_unique_id:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: mysess.sql */</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* private global to hold DBMS_SESSION.UNIQUE_SESSION_ID */
   unique_id_  VARCHAR2(40);

   /*
   || loads unique_session_id into global variable, must be called 
   || prior to using function unique_id  
   */
   PROCEDURE <A
CLASS="indexterm"
NAME="ch11-idx-15877-0"
></A
>load_unique_id
   IS
   BEGIN
	unique_id_ := DBMS_SESSION.UNIQUE_SESSION_ID;
   END load_unique_id;


   /* 
   || returns unique_id_ loaded by call to load_unique_id 
   */
   FUNCTION <A
CLASS="indexterm"
NAME="ch11-idx-15878-0"
></A
>unique_id RETURN VARCHAR2
   IS</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   BEGIN   
      RETURN unique_id_;
   END unique_id;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, unique_id simply returns the value of a private package global variable that is set by the load_unique_id procedure to the value returned by DBMS_SESSION.UNIQUE_SESSION_ID. The only caveat is that load_unique_id must be called in the session prior to calling unique_id (or a NULL value will be returned). Note that using a private global and function is safer than using a public global, since the public global cannot be protected from inadvertent <A
CLASS="indexterm"
NAME="ch11-idx-15871-0"
></A
>modification.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.5.3"
>11.1.5.3 The load_my_session_rec procedure</A
></H4
><P
CLASS="para"
>Each session has a unique row in the V$SESSION virtual table with various columns containing identification and activity information about the session. The <A
CLASS="indexterm"
NAME="ch11-idx-17233-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-17233-1"
></A
>load_my_session_rec procedure selects the row in V$SESSION corresponding to the current session and loads it into a package global record called my_session_rec. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: mysess.sql */*
/*
|| my_session_cur and my_session_rec are both declared
|| to always hold all columns of V$SESSION
*/
CURSOR my_session_cur
IS
SELECT  *
	FROM  sys.v_$session
	WHERE  audsid = USERENV('SESSIONID');

my_session_rec  sys.v_$session%ROWTYPE;

/*
|| loads V$SESSION data into global record for current session 
*/ 
PROCEDURE load_my_session_rec
IS
BEGIN
	OPEN my_session_cur;
	FETCH my_session_cur INTO my_session_rec;
	CLOSE my_session_cur;
END load_my_session_rec;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that load_my_session_rec is written in a way that ensures it always gets all columns of V$SESSION. This is accomplished by anchoring the package global my_session_rec to V$SESSION using %ROWTYPE in the declaration. Similarly, the cursor my_session_cur used to fetch into my_session_rec is anchored to V$SESSION by using the SELECT * syntax. This is a nice technique. Since V$SESSION can change with Oracle versions, writing the procedure in this way allows it to adjust itself to the particular version of Oracle under which it is <A
CLASS="indexterm"
NAME="ch11-idx-17261-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-17261-1"
></A
>executing.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.5.4"
>11.1.5.4 The <A
CLASS="indexterm"
NAME="ch11-idx-15884-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15884-1"
></A
>sid function</A
></H4
><P
CLASS="para"
>Several of the Oracle dynamic performance (V$) views are keyed by session id because they contain session-level performance data. Many developers and DBAs have had to answer the question "What is my current sid?" when delving into these performance tables. I don't know why DBMS_SESSION does not come with a sid function, but my_session sure does. Here is the relevant source code: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: mysess.sql */   /*
/* 
	|| returns the session id of current session 
*/
FUNCTION sid RETURN NUMBER
	temp_session_rec sys.v_$session%ROWTYPE;
BEGIN
	IF my_session_rec.sid IS NULL
	THEN
		OPEN my_session_cur;
		FETCH my_session_cur INTO temp_session_rec;
		CLOSE my_session_cur;
	ELSE
		temp_session_rec := my_session_rec;
      END IF;
      RETURN temp_session_rec.sid;
END sid;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-15888-0"
></A
>The sid function itself is quite simple, yet it has a subtle but important performance optimization. Since the session id will never change for the duration of the session, it is necessary to load it only once, and this can be done using the load_my_session_rec procedure. The IF statement checks to see if we've already loaded the my_session_rec.sid and bypasses opening my_session_cur in that case. Remember that we intend to use the function in SQL statements, and it will be executed for every row returned in which the function is referenced. That simple IF statement could save hundreds (or even thousands) of scans on the V$SESSION view per SQL statement. Be sure to execute load_my_session_rec before using the sid function to avoid the unnecessary performance penalty.</P
><P
CLASS="para"
>We can use the my_session.sid function to view our current performance statistics from V$SESSTAT as <A
CLASS="indexterm"
NAME="ch11-idx-15886-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15886-1"
></A
>follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT n.name,s.value
  FROM v$statname n, v$sesstat s
 WHERE n.statistic# = s.statistic#
   AND s.sid = my_session.sid;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Astute readers may ask: Why not just call load_my_session_rec from the sid function if my_session_rec.sid has not been initialized? Well, originally this is exactly the way sid was written. However, since load_my_session_rec modifies package state, this meant that WNPS (Writes No Package State) purity could not be asserted for the sid function. In order to use a PL/SQL function in the WHERE clause of a SQL statement, the function must assert WNPS, so sid had to be modified to not call load_my_session_rec.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.5.5"
>11.1.5.5 The <A
CLASS="indexterm"
NAME="ch11-idx-15889-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15889-1"
></A
>close_links procedure</A
></H4
><P
CLASS="para"
>The Oracle initialization parameter OPEN_LINKS controls the maximum number of concurrent open connections to remote databases per user session. When a session exceeds this number, the following Oracle error is raised:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>ORA-02020</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Too many database links in use.</P
></DD
></DL
><P
CLASS="para"
>Generally, the database administrator should set the OPEN_LINKS parameter to a value that will accommodate the needs of distributed applications accessing the database. However, in highly distributed environments with multiple applications, it's possible that users could receive the ORA-02020 error. Presumably, this is the purpose of the CLOSE_DATABASE_LINK procedure; however, there is a serious problem. Quite simply, users should not have to know anything about database links nor, for that matter, should applications. Database links are an implementation detail that should be kept transparent to users and applications. The real question is: When an ORA-02020 is incurred, how is a user or application supposed to know which links are open and can be closed?</P
><P
CLASS="para"
>Well, it's my opinion that users should not have to know about specific database links and yet should be able to do something in case of an ORA-02020 error. That is precisely the purpose of my_session.close_links. That procedure will close any open links that are not in use and can be closed. A link is considered in use if it has been referenced within the current transaction (i.e., since the last COMMIT or ROLLBACK). Alternatively, close_links will close all open links by issuing a COMMIT to terminate the current transaction and free all links for closure.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: mysess.sql */*
/*
|| closes all open database links not in use by session, 
|| or all if forced_with_commit_TF is TRUE 
*/
PROCEDURE close_links 
   (force_with_commit_TF IN BOOLEAN DEFAULT FALSE) </PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   IS

      /* declare exceptions for ORA errors */
      dblink_in_use EXCEPTION;
      PRAGMA EXCEPTION_INIT(dblink_in_use,-2080);

      dblink_not_open EXCEPTION;
      PRAGMA EXCEPTION_INIT(dblink_not_open,-2081);

      /* cursor of all db links available to user */
      CURSOR all_links_cur
      IS 
      SELECT db_link 
        FROM all_db_links;

   BEGIN
      /* try all links and close the ones you can */
      FOR dblink_rec IN all_links_cur
      LOOP
         BEGIN
            DBMS_SESSION.CLOSE_DATABASE_LINK(dblink_rec.db_link);
         EXCEPTION
            WHEN dblink_not_open
               THEN null;
            WHEN dblink_in_use 
               THEN 
                  IF force_with_commit_TF
                  THEN
                     COMMIT;
                     DBMS_SESSION.CLOSE_DATABASE_LINK(dblink_rec.db_link);
                  END IF;
            WHEN OTHERS 
               THEN null;
         END;
      END LOOP;
   END close_links;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There are a few things to note in this procedure. First, exceptions are declared and assigned to the two Oracle errors that can be raised by the DBMS_SESSION.CLOSE_DATABASE_LINK procedure. This is done using PRAGMA EXCEPTION_INIT compiler directives. Next comes a loop through all database links available to the user. For each link in the loop, we execute DBMS_SESSION.CLOSE_DATABASE_LINK in a BEGIN...END block and trap the exceptions raised by links that were not open or in use. Trapping the exceptions allows the loop to continue until all links have been processed.</P
><P
CLASS="para"
>Originally, the procedure would close only links that were not in use. I decided to enhance it to accept a BOOLEAN parameter called force_with_commit_TF. When this parameter is TRUE, the dblink_in_use exception handler issues a COMMIT. This terminates the current transaction and frees all database links to be closed, including the one that raised the exception that is closed in the exception handler. This enhancement allows the procedure to close all database links for the <A
CLASS="indexterm"
NAME="ch11-idx-15891-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15891-1"
></A
>session.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> The V$DBLINK virtual table shows database links that the current session has open. The IN_TRANSACTION column indicates whether the open link is in use or can be closed using DBMS_SESSION.CLOSE_DATABASE_LINK.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.5.6"
>11.1.5.6 The <A
CLASS="indexterm"
NAME="ch11-idx-15894-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15894-1"
></A
>set_sql_trace procedure</A
></H4
><P
CLASS="para"
>The SQL trace facility is an invaluable tool for debugging application performance problems. However, one problem that developers and DBAs often run into when using SQL trace is identifying the correct trace file from among the possibly hundreds of trace files that tend to collect and hang around in the directory specified by the USER_DUMP_DEST parameter. One technique is to put a literal tag in trace files by executing a SQL command such as the following: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT 'JOHN B: TRACE 1' FROM DUAL; </PRE
></BLOCKQUOTE
><P
CLASS="para"
>When issued immediately after setting SQL_TRACE to TRUE, the statement will appear in the trace file, and a utility like <I
CLASS="filename"
>grep</I
> or <I
CLASS="filename"
>awk</I
> can be used to scan the directory for the file with the correct literal tag. In my_session.set_sql_trace, I've enhanced DBMS_SESSION.SET_SQL_TRACE to accept a string tag and place it into the trace file when turning trace on. The DBMS_SQL package is used to  build and parse a SQL statement dynamically with the tag literal in it.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: mysess.sql */*
/*
|| turns SQL tracing on/off with tag for file identification 
*/
PROCEDURE set_sql_trace
	(trace_TF IN  BOOLEAN
	,tag_IN  IN  VARCHAR2 DEFAULT USER)
IS
	cursor_id  INTEGER;
BEGIN
	DBMS_SESSION.SET_SQL_TRACE(trace_TF);

	IF trace_TF
	THEN
		cursor_id := DBMS_SQL.OPEN_CURSOR;

		/* parse a SQL stmt with the tag in it */
		DBMS_SQL.PARSE
			(cursor_id
			,'SELECT '''||tag_IN||''' FROM DUAL'
			,DBMS_SQL.native);
  
	DBMS_SQL.CLOSE_CURSOR(cursor_id);</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>      END IF;
   END set_sql_trace;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that it is not necessary to execute the tag SQL statement; the parse will get it into the trace file. After all, there is no need to do more work than absolutely <A
CLASS="indexterm"
NAME="ch11-idx-15896-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15896-1"
></A
>required.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.5.7"
>11.1.5.7 The <A
CLASS="indexterm"
NAME="ch11-idx-15898-0"
></A
>reset procedure </A
></H4
><P
CLASS="para"
>The DBMS_SESSION.RESET_PACKAGE procedure invalidates all package states, including all global variables and PL/SQL tables. However, it does not free the memory associated with these now empty structures; that is the job of DBMS_SESSION.FREE_UNUSED_USER_MEMORY. The my_session.reset procedure combines these into a single call.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: mysess.sql */*
/*
|| resets all package states and frees memory 
*/
PROCEDURE<A
CLASS="indexterm"
NAME="ch11-idx-15899-0"
></A
> reset
IS
BEGIN
	DBMS_SESSION.RESET_PACKAGE;
	DBMS_SESSION.FREE_UNUSED_USER_MEMORY;
END reset;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Originally, I designed the reset procedure to call load_unique_id and load_my_session_rec immediately after initializing the package and freeing memory. The idea was that some package states should always be available, so why not reinitialize them immediately? However, I had stepped into the DBMS_SESSION.RESET_PACKAGE trap, which prevents any package state from being established within the same calling scope as the call to RESET_PACKAGE.</P
><P
CLASS="para"
>It is good practice for programs that rely on package state to check expected package variables and initialize them if necessary. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch11-SECT-1.5.8"
>11.1.5.8 The <A
CLASS="indexterm"
NAME="ch11-idx-15905-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15905-1"
></A
>memory procedure</A
></H4
><P
CLASS="para"
>The my_session.memory procedure was developed to provide experimental results from using DBMS_SESSION.RESET and DBMS_SESSION.FREE_UNUSED_USER_MEMORY. It uses DBMS_OUTPUT to display the current session memory's UGA and PGA sizes. If you ever wondered how much memory that big package really uses, check it out with my_session.memory. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: mysess.sql */*
/*
|| displays session uga and pga using DBMS_OUTPUT 
*/
PROCEDURE memory
IS
BEGIN
	DBMS_OUTPUT.ENABLE;
	DBMS_OUTPUT.PUT_LINE('session UGA: '||
		TO_CHAR(my_session.statval('session uga memory') ) );
	DBMS_OUTPUT.PUT_LINE('session PGA: '||
		TO_CHAR(my_session.statval('session pga memory') ) );
END memory;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The memory procedure uses a function called statval, which returns the value of a V$SESSTAT statistic for the current session by name. It's a handy little function.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch11-idx-15855-0"
></A
>mysess.sql */*
/* 
|| returns current value of a statistic from 
|| V$SESSTAT for this session 
*/
FUNCTION <A
CLASS="indexterm"
NAME="ch11-idx-15915-0"
></A
>statval(statname_IN IN VARCHAR2) RETURN NUMBER
IS
	CURSOR sesstat_cur (statname VARCHAR2)
	IS
		SELECT  s.value
  			FROM  sys.v_$sesstat  s
 				,sys.v_$statname n
		WHERE  s.statistic# = n.statistic#
			AND  s.sid  = my_session.sid
			AND  n.name = statname;
	return_temp  NUMBER;
BEGIN
	OPEN sesstat_cur(statname_IN);
	FETCH sesstat_cur INTO return_temp;
	CLOSE sesstat_cur;
	RETURN return_temp;
EXCEPTION
	WHEN OTHERS THEN
		IF sesstat_cur%ISOPEN
		THEN
			CLOSE sesstat_cur;
		END IF;
		RETURN NULL;
END statval;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that statval uses the my_session.sid funtion in the cursor sesstat_cur.</P
><P
CLASS="para"
>The following script demonstrates the inefficiency of PL/SQL tables of VARCHAR2 under Oracle 7.3 using my_session.memory:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch11-idx-17147-0"
></A
>sess2.sql */*
set serveroutput on size 100000

DECLARE
	TYPE my_tabtype IS TABLE OF VARCHAR2(2000)
		INDEX BY BINARY_INTEGER;

	my_tab my_tabtype;
BEGIN
	my_session.memory;
	FOR i IN 1..1000
	LOOP
		my_tab(i) := TO_CHAR(i);
	END LOOP;
	my_session.memory;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is sample output from executing this script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>session UGA: 36048                                                                                  
session PGA: 103328                                                                                
session UGA: 36048                                                                                  
session PGA: 2248352
                                                                                
PL/SQL procedure successfully completed.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Even though each entry in the PL/SQL table my_tab has at most three characters, session PGA memory grew by more than two megabytes! Luckily, this problem <A
CLASS="indexterm"
NAME="ch11-idx-15907-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15907-1"
></A
>is <A
CLASS="indexterm"
NAME="ch11-idx-15822-0"
></A
>fixed in <A
CLASS="indexterm"
NAME="ch11-idx-15705-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-15705-1"
></A
>PL/SQL8.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part03.htm"
TITLE="III. Server Management Packages"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: III. Server Management Packages"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_02.htm#ch11-SECT-2.2.1"
TITLE="11.2 DBMS_System: Setting Events for Debugging"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 11.2 DBMS_System: Setting Events for Debugging"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>III. Server Management Packages</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>11.2 DBMS_System: Setting Events for Debugging</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
