<HTML
><HEAD
><TITLE
>[Chapter 4] User Lock and Transaction Management</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:48:43Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part02.htm"
TITLE="II. Application Development Packages"><LINK
REL="prev"
HREF="ch03_02.htm"
TITLE="3.2 DBMS_ALERT: Broadcasting Alerts to Users"><LINK
REL="next"
HREF="ch04_02.htm#ch04-SECT-2.1.1"
TITLE="4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch03_02.htm"
TITLE="3.2 DBMS_ALERT: Broadcasting Alerts to Users"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 3.2 DBMS_ALERT: Broadcasting Alerts to Users"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 4</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_02.htm#ch04-SECT-2.1.1"
TITLE="4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="PACKAGES-CH-4"
>4. User Lock and Transaction Management</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch04-20223"
TITLE="4.1 DBMS_LOCK: Creating and Managing Resource Locks"
>DBMS_LOCK: Creating and Managing Resource Locks</A
><BR><A
CLASS="sect1"
HREF="ch04_02.htm#ch04-SECT-2.1.1"
TITLE="4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements"
>DBMS_TRANSACTION: Interfacing to SQL Transaction Statements</A
></P
><P
></P
></DIV
><P
CLASS="para"
>Complex, multiuser applications that manage new types of resources (objects, BLOBs, etc.) require the ability to manage contention for those resources. The Oracle database manages concurrent, multiuser contention for data using sophisticated locking mechanisms. This chapter describes two packages that provide interfaces to the Oracle lock and transaction management facilities:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>DBMS_LOCK</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Oracle now provides developers with the "keys" to its locking mechanisms through the DBMS_LOCK package; watch out, though, this deceptively powerful package might also put your applications to "sleep!" </P
></DD
><DT
CLASS="term"
>DBMS_TRANSACTION </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Complements DBMS_LOCK by providing a programmatic interface to a number of transaction-oriented SQL statements.</P
></DD
></DL
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch04-20223"
>4.1 DBMS_LOCK: Creating and Managing Resource Locks</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20157-0"
></A
>DBMS_LOCK package makes Oracle lock management services available to PL/SQL developers. User locks created and managed using DBMS_LOCK are functionally identical to native RDBMS locks, even down to the various sharing modes and the deadlock detection.</P
><P
CLASS="para"
>Locks are typically used to provide <A
CLASS="indexterm"
NAME="ch04-idx-20165-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20165-1"
></A
>serialized access to some resource. Within the database, the most familiar use of locking is to prevent multiple users from updating the same row in a table at the same time. Using DBMS_LOCK, applications can be written that serialize and coordinate access or usage of nondata resources. For instance, user locks can be used to do the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Provide exclusive access to an external device or service (e.g., a printer)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Coordinate or synchronize parallelized applications</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Disable or enable execution of programs at specific times</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Detect whether a session has ended a transaction using COMMIT or ROLLBACK</P
></LI
></UL
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-1.1"
>4.1.1 Getting Started with DBMS_LOCK</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20166-0"
></A
>DBMS_LOCK package is created when the Oracle database is installed. The <I
CLASS="filename"
>dbmslock.sql</I
><A
CLASS="indexterm"
NAME="ch04-idx-20167-0"
></A
> script (found in the built-in packages source code directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1, <CITE
CLASS="chapter"
>Introduction</CITE
></A
>) contains the source code for this package's specification. This script is called by <I
CLASS="filename"
>catproc.sql</I
>, which is normally run immediately after database creation. The script creates the public synonym DBMS_LOCK for the package. Under Oracle7, no <A
CLASS="indexterm"
NAME="ch04-idx-20169-0"
></A
>privileges are automatically granted on DBMS_LOCK. Under Oracle8, the EXECUTE_CATALOG_ROLE role is granted EXECUTE privilege on DBMS_LOCK. Thus, the DBMS_LOCK programs are not generally available to users. Access to DBMS_LOCK is obtained by granting EXECUTE privilege explicitly to users or roles that require use of the package.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.1.1"
>4.1.1.1 DBMS_LOCK programs</A
></H4
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch04_01.htm"
>Table 4.1</A
> lists the <A
CLASS="indexterm"
NAME="ch04-idx-20171-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20171-1"
></A
>programs available in the DBMS_LOCK package.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch04-13442"
>Table 4.1: DBMS_LOCK Programs</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in </P
><P
CLASS="para"
>SQL?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20172-0"
></A
>ALLOCATE_UNIQUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Generates a unique lock ID for a given lock name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20174-0"
></A
>CONVERT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Converts lock to specified mode</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20175-0"
></A
>RELEASE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Releases previously acquired lock</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20173-0"
></A
>REQUEST</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Requests lock with specified mode</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20176-0"
></A
>SLEEP</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Suspends the session for a specified time</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-21501-0"
></A
>DBMS_LOCK does not declare any package exceptions, and none of its programs assert a purity level with the RESTRICT_REFERENCES pragma.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.1.2"
>4.1.1.2 DBMS_LOCK nonprogram elements</A
></H4
><P
CLASS="para"
>DBMS_LOCK declares a number of constants, most of which identify specific locking modes. <A
CLASS="xref"
HREF="ch04_01.htm"
>Table 4.2</A
> describes these elements.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch04-11470"
>Table 4.2: DBMS_LOCK Declared Constants</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Constant</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>nl_mode CONSTANT INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Null lock mode</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ss_mode CONSTANT INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sub-shared lock mode</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>sx_mode CONSTANT INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sub-exclusive lock mode</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>s_mode CONSTANT INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Shared lock mode</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ssx_mode CONSTANT INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sub-shared exclusive lock mode</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>x_mode CONSTANT INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Exclusive lock mode</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>maxwait CONSTANT INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Used as default for timeout parameters</P
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.1.3"
>4.1.1.3 Lock compatibility rules</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20177-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20177-1"
></A
>A lock held by one user session in a certain mode may prevent another session from being able to obtain that lock in the same or another mode. There are lock compatibility rules determining the success or failure of acquiring and converting locks from one mode to another, depending on the modes in which the same lock is held by other sessions. <A
CLASS="xref"
HREF="ch04_01.htm"
>Table 4.3</A
> indicates the compatibility rules for the various lock modes. The HELD MODE column indicates the mode in which the lock is currently held by some session. The other columns indicate whether the lock can be obtained by other sessions in the mode specified by the column header. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch04-26046"
>Table 4.3: Lock Mode Compatibility</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>HELD MODE</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET NL</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET SS</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET SX</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET S</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET SSX</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET X</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NL</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SX</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>S</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SSX</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Succeed</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fail</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-1.2"
>4.1.2 The DBMS_LOCK Interface</A
></H3
><P
CLASS="para"
>This section contains descriptions of all of the procedures and functions available through DBMS_LOCK.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.2.1"
>4.1.2.1 The DBMS_LOCK.ALLOCATE_UNIQUE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20178-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20178-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20178-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20178-3"
></A
>ALLOCATE_UNIQUE procedure returns a unique "handle" to a lock specified by the lockname parameter. The handle can be used to safely identify locks in calls to other DBMS_LOCK programs. Using lockhandles avoids the potential for lock identifier collisions that exists when identifiers are determined by applications. The header for this program follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOCK.ALLOCATE_UNIQUE
    (lockname IN VARCHAR2
    ,lockhandle OUT VARCHAR2
    ,expiration_secs IN INTEGER DEFAULT 864000);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters for this procedure are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lockname</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the lock</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lockhandle</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique handle to lock by name</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>expiration_secs</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Length of time to leave lock allocated </P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The program does not raise any package exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.1.1"
>4.1.2.1.1 Restrictions</A
></H4
><P
CLASS="para"
>Note the following restrictions on calling ALLOCATE_UNIQUE:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20185-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20185-1"
></A
>Lock names can be up to 128 characters in length and are case-sensitive. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Lock names must not begin with "ORA$", as these names are reserved for use by Oracle Corporation.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20186-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20186-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20186-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20186-3"
></A
>The ALLOCATE_UNIQUE procedure always performs a COMMIT, so it cannot be called from a database trigger.</P
></LI
></UL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.1.2"
>4.1.2.1.2 Example</A
></H4
><P
CLASS="para"
>The following function returns the lockhandle of a specific named lock. It calls ALLOCATE_UNIQUE only if the lockhandle has not already been determined, and avoid the COMMIT unless it is necessary. The function manipulates global variables and thus needs to be included in a PL/SQL package.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE BODY printer_access
IS
   /* global variables for lock name and handle */
   printer_lockname  VARCHAR2(128) := 'printer_lock';
   printer_lockhandle  VARCHAR2(128);

   FUNCTION get_printer_lockhandle
   RETURN VARCHAR2
   IS
   BEGIN
      IF printer_lockhandle IS NULL
      THEN
         DBMS_LOCK.ALLOCATE_UNIQUE
            (lockname =&gt; printer_lockname
            ,lockhandle =&gt; printer_lockhandle);
      END IF;

      RETURN printer_lockhandle;
   END get_printer_lockhandle;

END printer_access;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As illustrated in the example, it is a good idea to call ALLOCATE_UNIQUE only once for any given lockname per session. This is why the function stashes the lockhandle in the global variable, printer_lockhandle, and calls ALLOCATE_UNIQUE only if this global has not been initialized. There are two reasons for using this technique: efficiency and avoidance of extra COMMITs. Remember that ALLOCATE_UNIQUE will always return the same handle for a given lockname and that it always performs a COMMIT. Thus, best practice for using DBMS_LOCK includes calling ALLOCATE_UNIQUE only once per named lock.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20187-0"
></A
>Locks allocated using ALLOCATE_UNIQUE can be viewed in the Oracle data dictionary via the DBMS_LOCK_ALLOCATED view.</P
><P
CLASS="para"
>It is good practice to avoid the possibility of lockname conflicts between applications by adopting standard naming conventions for locknames. Just as Oracle reserves names that begin with "ORA$", you may want to prefix locknames with your own company and application identifier <A
CLASS="indexterm"
NAME="ch04-idx-20180-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20180-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20180-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20180-3"
></A
>string.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-35617"
>4.1.2.2 The DBMS_LOCK.REQUEST function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20188-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20188-1"
></A
>REQUEST function is used to acquire a lock in the mode specified by the lockmode parameter. If the lock cannot be acquired in the requested mode within the specified time, the function call completes with a nonzero return value (see the parameter table).</P
><P
CLASS="para"
>The REQUEST function is overloaded on the first parameter, which is used to identify the lock by either an INTEGER identifier or by a VARCHAR2 lockhandle. <A
CLASS="indexterm"
NAME="ch04-idx-20192-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20192-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20192-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20192-3"
></A
>The release_on_commit parameter indicates whether the lock should persist across RDBMS transactions or be automatically released upon COMMIT or ROLLBACK. The headers for this program, corresponding to each type, are as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOCK.REQUEST
    (id IN INTEGER
    ,lockmode IN INTEGER DEFAULT X_MODE
    ,timeout IN INTEGER DEFAULT MAXWAIT
    ,release_on_commit IN BOOLEAN DEFAULT FALSE)
RETURN INTEGER;

FUNCTION DBMS_LOCK.REQUEST
    (lockhandle IN VARCHAR2
    ,lockmode IN INTEGER DEFAULT X_MODE
    ,timeout IN INTEGER DEFAULT MAXWAIT
    ,release_on_commit IN BOOLEAN DEFAULT FALSE)
RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters for this function are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>id</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Numeric identifier of the lock</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lockhandle</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Handle for lock returned by DBMS_LOCK.ALLOCATE_UNIQUE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lockmode</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locking mode requested for lock</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>timeout</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Time in seconds to wait for successful conversion</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>release_on_commit</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If TRUE, release lock automatically on COMMIT or ROLLBACK</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The following table summarizes the return values of the function. 		</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return Value</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Success</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Timed out</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Deadlock</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>3</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter error</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>4</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Do not own lock; cannot convert</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>5</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Illegal lockhandle</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The program does not raise any package exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-35617-1"
>4.1.2.2.1 Restrictions</A
></H4
><P
CLASS="para"
>User-defined <A
CLASS="indexterm"
NAME="ch04-idx-20193-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20193-1"
></A
>lock identifiers must be in the range 0 to 1073741823. Lock identifiers in the range 2000000000 to 2147483647 are reserved for use by Oracle Corporation.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-41288"
>4.1.2.2.2 Example</A
></H4
><P
CLASS="para"
>The following procedure calls the REQUEST function to get exclusive access to a lock designated to serialize access to a printer by Oracle sessions. It uses the get_printer_lockhandle function (see the example for the ALLOCATE_UNIQUE procedure) to identify the correct value for the lockhandle parameter.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE lock_printer
   (return_code_OUT OUT INTEGER)
IS
   /* initialize variable with desired lockhandle */
   temp_lockhandle printer_lockhandle%TYPE := get_printer_lockhandle;

   call_status  INTEGER;
BEGIN

   /*
   || lock in exclusive mode, wait for up to 5 seconds
   */
   call_status := DBMS_LOCK.REQUEST
                     (lockhandle =&gt; temp_lockhandle
                     ,lockmode =&gt; DBMS_LOCK.x_mode
                     ,timeout =&gt; 5
                     ,release_on_commit =&gt; TRUE);

   return_code_OUT := call_status;
END lock_printer;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It is safest to use the form of REQUEST that identifies the lock by a lockhandle (returned by ALLOCATE_UNIQUE). This minimizes the potential for inadvertent use of the same lock by different applications for different purposes, which is possible when locks are identified by integer values chosen by the application.</P
><P
CLASS="para"
>Sessions connected to Oracle using the <A
CLASS="indexterm"
NAME="ch04-idx-20194-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20194-1"
></A
>multithreaded server configuration will not be released from their shared server until all held locks are released. Thus, be careful of specifying FALSE for the release_on_commit parameter in MTS (multithreaded server) environments, as holding locks for long periods could have a negative impact on MTS efficiency.</P
><P
CLASS="para"
>Be sure that <A
CLASS="indexterm"
NAME="ch04-idx-20195-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20195-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20195-2"
></A
>distributed transactions specify TRUE for the release_on_commit parameter. If a distributed transaction does not release locks after COMMIT, it is possible for a distributed deadlock to occur, which will be undetectable by either of the databases involved.</P
><P
CLASS="para"
>When two sessions request locks with modes resulting in a <A
CLASS="indexterm"
NAME="ch04-idx-20196-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20196-1"
></A
>deadlock, this is detected by Oracle, and one of the sessions is notified of the deadlock <A
CLASS="indexterm"
NAME="ch04-idx-20190-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20190-1"
></A
>status.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.2.3"
>4.1.2.3 The DBMS_LOCK.CONVERT function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20197-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20197-1"
></A
>CONVERT function is used to convert a previously acquired lock to the mode specified by the lockmode parameter. If the mode conversion cannot be granted within the specified time, the function call completes with a nonzero return value (see the following parameter table). CONVERT is overloaded on the first parameter, which is used to identify the lock by either an INTEGER identifier or a VARCHAR2 lockhandle. The headers for this program, corresponding to each type, follow:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOCK.CONVERT
    (id IN INTEGER
    ,lockmode IN INTEGER
    ,timeout IN NUMBER DEFAULT MAXWAIT)
RETURN INTEGER;

FUNCTION DBMS_LOCK.CONVERT
    (lockhandle IN VARCHAR2
    ,lockmode IN INTEGER
    ,timeout IN NUMBER DEFAULT MAXWAIT)
RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters for this program are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>id</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Numeric identifier of the lock</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lockhandle</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Handle for lock returned by ALLOCATE_UNIQUE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lockmode</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Locking mode to which to convert the lock </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>timeout</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Time in seconds to wait for successful conversion</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The return values for this function are summarized in the following table. </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return Value</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Success</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Timed out</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Deadlock</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>3</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter error</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>4</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Do not own lock, cannot convert</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>5</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Illegal lockhandle</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The program does not raise any package exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.3.1"
>4.1.2.3.1 Restrictions</A
></H4
><P
CLASS="para"
>User-defined lock identifiers must be in the range 0 to 1073741823. Lock identifiers in the range 2000000000 to 2147483647 are reserved for use by Oracle Corporation.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.3.2"
>4.1.2.3.2 Example</A
></H4
><P
CLASS="para"
>The following anonymous PL/SQL block converts a previously acquired lock to null mode, reporting success or failure to the screen:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   call_status INTEGER;
BEGIN
   /* convert lock 9999 down to null mode with no wait */
   call_status := DBMS_LOCK.CONVERT(9999,DBMS_LOCK.nl_mode,0);

   IF call_status = 0
   THEN
      DBMS_OUTPUT.PUT_LINE('SUCCESS');
   ELSE
      DBMS_OUTPUT.PUT_LINE('FAIL, RC = '||TO_CHAR(call_status));
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>See the discussion in the "<A
CLASS="xref"
HREF="ch04_01.htm"
>Section 4.1.2.2.2, "Example"</A
>" section for the <A
CLASS="xref"
HREF="ch04_01.htm"
>Section 4.1.2.2, "The DBMS_LOCK.REQUEST function"</A
>; all of that discussion also applies to <A
CLASS="indexterm"
NAME="ch04-idx-20199-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20199-1"
></A
>CONVERT.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.2.4"
>4.1.2.4 The DBMS_LOCK.RELEASE function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20203-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20203-1"
></A
>RELEASE function releases a previously acquired lock. RELEASE is overloaded on the first parameter, which is used to identify the lock by either an INTEGER identifier or a VARCHAR2 lockhandle. The program headers for each corresponding type follow:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_LOCK.RELEASE
    (id IN INTEGER)
RETURN INTEGER;

FUNCTION DBMS_LOCK.RELEASE
    (lockhandle IN VARCHAR2)
RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>id</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Numeric identifier of the lock</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lockhandle</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Handle for lock returned by ALLOCATE_UNIQUE</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The return values for this function are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return Value</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Success</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>3</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter error</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>4</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Do not own lock; cannot release</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>5</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Illegal lockhandle</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The program does not raise any package exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.4.1"
>4.1.2.4.1 Restrictions</A
></H4
><P
CLASS="para"
>User-defined lock identifiers must be in the range 0 to 1073741823. Lock identifiers in the range 2000000000 to 2147483647 are reserved for use by Oracle Corporation.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.4.2"
>4.1.2.4.2 Example</A
></H4
><P
CLASS="para"
>The following procedure calls the RELEASE function to relinquish control of the printer lock (see also the example for the REQUEST function):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE release_printer
   (return_code_OUT OUT INTEGER)
IS
   /* initialize variable with desired lockhandle */
   temp_lockhandle printer_lockhandle%TYPE := get_printer_lockhandle;

   call_status  INTEGER;
BEGIN

   /*
   || release the printer lock 
   */
   call_status := DBMS_LOCK.RELEASE
                     (lockhandle =&gt; temp_lockhandle);

   return_code_OUT := call_status;
END release_printer;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It is good practice to release locks as soon as possible. Doing so minimizes the potential for unnecessary wait times or deadlocks in applications where concurrent access to resources is serialized using <A
CLASS="indexterm"
NAME="ch04-idx-20205-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20205-1"
></A
>DBMS_LOCK.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.2.5"
>4.1.2.5 The DBMS_LOCK.SLEEP procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20207-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20207-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20207-2"
></A
>SLEEP procedure suspends the session for the number of seconds specified in the seconds parameter. Sleep periods can be specified with accuracy down to the hundredth of a second (e.g., 1.35 and 1.29 are recognized as distinct sleep times). Here's the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_LOCK.SLEEP
    (seconds IN NUMBER);</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.5.1"
>4.1.2.5.1 Exceptions</A
></H4
><P
CLASS="para"
>This program does not raise any package exceptions.</P
><BLOCKQUOTE
CLASS="warning"
><P
CLASS="para"
><STRONG
>WARNING:</STRONG
> The following nasty Oracle exception was raised on Windows NT when the SLEEP procedure was called with a NULL value for seconds: ORA-00600: internal error code, arguments: [15454], [0], [ ], [ ], [ ], [ ], [ ], [ ].</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.5.2"
>4.1.2.5.2 Restrictions</A
></H4
><P
CLASS="para"
>Do not specify a null value for the seconds parameter; this may result in an ORA-00600 error, as noted previously.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.2.5.3"
>4.1.2.5.3 Example</A
></H4
><P
CLASS="para"
>The following SQL*Plus script displays a screen message and pauses for ten seconds before continuing:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>prompt **************************************
prompt * This is a very important message
prompt * ************************************

BEGIN
   DBMS_LOCK.SLEEP(10);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Applications using resources to which concurrent access is restricted may need to try again later if the resource is busy. The SLEEP procedure provides a mechanism for including low-overhead wait times into PL/SQL programs. After waiting, an application can retry the operation that failed to acquire the busy resource.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-1.3"
>4.1.3 Tips on Using DBMS_LOCK</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20208-0"
></A
>In this section I've pulled together a number of best practices for using the DBMS_LOCK package.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.3.1"
>4.1.3.1 Named locks or lock ids?</A
></H4
><P
CLASS="para"
>Oracle provides two methods of identifying and manipulating user locks: integer lock identifiers and handles for named locks. Using names and lockhandles to identify locks is considered safer than using integer identifiers directly because naming standards can be adopted to virtually guarantee that different applications will not use the same lock for different purposes. Therefore, best practices for using DBMS_LOCK include the use of named locks and lockhandles.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.3.2"
>4.1.3.2 Issues with named locks</A
></H4
><P
CLASS="para"
>There are a couple of drawbacks to using named locks that are worth pointing out. In particular:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Named locks are recorded in the catalog, and thus may be slower.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The DBMS_LOCK.ALLOCATE_UNIQUE procedure issues a COMMIT.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Applications need to keep track of lockhandles for each named lock used.</P
></LI
></UL
><P
CLASS="para"
>It is worth investigating these drawbacks and developing techniques to minimize their impact, thus further encouraging the use of named locks.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.3.3"
>4.1.3.3 Performance of named locks</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-21377-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-21377-1"
></A
>We can investigate the performance penalty for using named locks, and quantify that penalty in a relatively straightforward manner. Consider the following PL/SQL script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:  <A
CLASS="indexterm"
NAME="ch04-idx-21382-0"
></A
>lock1.sql */*
set timing on
set serveroutput on size 100000

DECLARE

   lockname VARCHAR2(30) := 'OPBIP_TEST_LOCK_10';
   lockhandle VARCHAR2(128);
   lockid  INTEGER := 99999;

   call_status  INTEGER;
   timer NUMBER;

BEGIN

   /*
   || timed test using lockhandles
   */
   timer := DBMS_UTILITY.GET_TIME;
   DBMS_LOCK.ALLOCATE_UNIQUE(lockname,lockhandle);
   FOR i IN 1..10000
   LOOP
      call_status := DBMS_LOCK.REQUEST(lockhandle,timeout=&gt;0);
      call_status := DBMS_LOCK.RELEASE(lockhandle);
   END LOOP;
   DBMS_OUTPUT.PUT_LINE('Using lockhandles: '||
      TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-timer)/100,2)) ||' secs');

   /*
   || timed test using lockids
   */
   timer := DBMS_UTILITY.GET_TIME;
   FOR i IN 1..10000
   LOOP
      call_status := DBMS_LOCK.REQUEST(lockid,timeout=&gt;0);
      call_status := DBMS_LOCK.RELEASE(lockid);
   END LOOP;
   DBMS_OUTPUT.PUT_LINE('Using lockids: '||
      TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-timer)/100,2)) ||' secs');

END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The PL/SQL block reports on the elapsed times to request and release a lock 10,000 times using either a lockhandle or an integer lock identifier. The test yielded the following results on a Personal Oracle7 database with no other activity:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @l2
Using lockhandles: 9.57 secs
Using lockids: 3.02 secs

PL/SQL procedure successfully completed.

 real: 12740
SQL&gt; spool off</PRE
></BLOCKQUOTE
><P
CLASS="para"
>These results confirm that use of lockhandles is significantly slower than use of lock identifiers. However, the results also indicate that the overhead of named locks was less than one-thousandth of a second per usage. Thus, the performance impact of using named locks is negligible and is probably not a legitimate concern for most <A
CLASS="indexterm"
NAME="ch04-idx-20221-0"
></A
>applications.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.3.4"
>4.1.3.4 ALLOCATE_UNIQUE drawbacks</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20223-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20223-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20223-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20223-3"
></A
>The other issues mentioned with named locks are usage related. The ALLOCATE_UNIQUE procedure needs to be called to identify a lockhandle for each named lock. This procedure issues a COMMIT, which presents some usability issues. For one, the procedure cannot be called from a database trigger, so using named locks from a database trigger requires that the lockhandle be acquired outside of the trigger and saved for use in the trigger. Another problem is the COMMIT itself: an application may want to utilize a named lock but not necessarily COMMIT the current transaction. Thus, it is desirable when using named locks to limit the number of calls to ALLOCATE_UNIQUE to exactly one call per named <A
CLASS="indexterm"
NAME="ch04-idx-20225-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20225-1"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20225-2"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20225-3"
></A
>lock used.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.3.5"
>4.1.3.5 Optimizing named locks</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20229-0"
></A
>One way to achieve the objective of minimizing calls to ALLOCATE_UNIQUE is to use private package global variables to store lockhandles for each named lock. A function that will return the lockhandle can then be written, calling ALLOCATE_UNIQUE only if the lockhandle has not been previously identified. This technique is illustrated as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE BODY print_pkg
IS
   /* private globals for lock identification */
   printer_lockname  VARCHAR2(128) := 'printer_lock';
   printer_lockhandle  VARCHAR2(128);

   FUNCTION get_printer_lockhandle
   RETURN VARCHAR2
   IS
   BEGIN
      IF printer_lockhandle IS NULL
      THEN
         DBMS_LOCK.ALLOCATE_UNIQUE
            (lockname =&gt; printer_lockname
            ,lockhandle =&gt; printer_lockhandle);
      END IF;

      RETURN printer_lockhandle;
   END get_printer_lockhandle;

END print_pkg;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Using this technique ensures that the ALLOCATE_UNIQUE procedure is called only once per session requiring use of the printer lock. The lock can even be used in a database trigger if the function get_printer_lockhandle has been called prior to the triggering event.</P
><P
CLASS="para"
>One drawback to this technique is code redundancy: each named lock used by an application requires adding a specific package global variable for the lockhandle and an associated function to return it. Referencing a new named lock in an application involves adding a nontrivial amount of code before it can be used.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.3.6"
>4.1.3.6 REQUEST or CONVERT?</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20239-0"
></A
>Another usability issue with DBMS_LOCK (not specific to named locks): applications using multiple lock modes need to have intelligence about whether to call the REQUEST function or the CONVERT function. If the user has requested and received a lock in a specific mode, then that mode can only be changed by calling CONVERT. On the other hand, a lock conversion can only take place if it is preceded by a successful call to REQUEST. Getting it right can mean developing code that checks and tracks return codes from the calls to these <A
CLASS="indexterm"
NAME="ch04-idx-20241-0"
></A
>two <A
CLASS="indexterm"
NAME="ch04-idx-20210-0"
></A
>procedures.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-1.4"
>4.1.4 DBMS_LOCK Examples</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20247-0"
></A
>In response to the usability issues described in the previous section, I have developed a utility package called dblock to simplify, and consequently encourage, the use of named locks in PL/SQL applications. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.4.1.1"
>4.1.4.1 The dblock package</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch04-idx-20249-0"
></A
><A
CLASS="indexterm"
NAME="ch04-idx-20249-1"
></A
>dblock package specification follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on on companion disk: <A
CLASS="indexterm"
NAME="ch04-idx-20253-0"
></A
>dblock.sql */*
CREATE OR REPLACE PACKAGE dblock
   /*
   || Adds value to DBMS_LOCK by allowing easier manipulation
   || of named locks. Calling programs use lock names only,
   || corresponding lockhandles are automatically identified,
   || used and saved for subsequent use.
   ||
   ||
   || Author:  John Beresniewicz, Savant Corp
   ||
   || 10/26/97: added expiration_secs_IN to lockhandle
   || 10/21/97: added release
   || 10/21/97: added dump_lockhandle_tbl
   || 10/17/97: created
   ||
   || Compilation Requirements:
   ||
   || EXECUTE on DBMS_LOCK
   || EXECUTE on DBMS_SESSION
   ||
   || Execution Requirements:
   ||
   */
AS
   /* variables to anchor other variables */
   lockname_var  VARCHAR2(128);
   lockhandle_var VARCHAR2(128);

   /*
   || returns TRUE if a COMMIT has taken place between
   || subsequent calls to the function
   || NOTE: returns TRUE on first call in session
   */
   FUNCTION committed_TF RETURN BOOLEAN;

   /*
   || returns lockhandle for given lockname, only calls
   || DBMS_LOCK.ALLOCATE_UNIQUE if lockhandle has not been
   || previously determined
   */
   FUNCTION lockhandle
      (lockname_IN IN lockname_var%TYPE
      ,expiration_secs_IN IN INTEGER := 864000)
   RETURN lockhandle_var%TYPE;

   /*
   || returns TRUE if named lock is acquired in mode
   || specified
   */
   FUNCTION get_lock_TF
      (lockname_IN IN lockname_var%TYPE
      ,mode_IN IN INTEGER := DBMS_LOCK.x_mode
      ,timeout_IN IN INTEGER := 1
      ,release_on_commit_TF IN BOOLEAN := FALSE)
   RETURN BOOLEAN;

   /* releases named lock */
   PROCEDURE release (lockname_IN IN lockname_var%TYPE);

   /* print contents of lockhandle_tbl for debugging */
   PROCEDURE dump_lockhandle_tbl;

END dblock;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The dblock programs allow the user to identify and acquire locks by name only. Lockhandles for each named lock are managed within the package, transparent to the application. The package associates locknames with lockhandles by using a private global PL/SQL table called lockhandle_tbl. The table is defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   /* rectype to pair handles with names */
   TYPE handle_rectype IS RECORD
      (name   lockname_var%TYPE
      ,handle lockhandle_var%TYPE
      );

   /* table to store lockhandles by name */
   TYPE handle_tbltype IS TABLE OF handle_rectype
      INDEX BY BINARY_INTEGER;

   lockhandle_tbl handle_tbltype;</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.4.1.2"
>4.1.4.1.1 The lockhandle function</A
></H4
><P
CLASS="para"
> The <A
CLASS="indexterm"
NAME="ch04-idx-21418-0"
></A
>lockhandle function takes a lockname as an IN parameter and returns the associated lockhandle. If the lockhandle has already been identified and stored in the lockhandle_tbl table, it is returned directly. Otherwise, DBMS_LOCK.ALLOCATE_UNIQUE is called to determine the lockhandle, which is then stored in lockhandle_tbl and is also returned to the caller. Here is the body of lockhandle:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: dblock.sql */*
   FUNCTION lockhandle
      (lockname_IN IN lockname_var%TYPE
      ,expiration_secs_IN IN INTEGER := 864000)
   RETURN lockhandle_var%TYPE
   IS
      call_status INTEGER;
      temp_lockhandle  lockhandle_var%TYPE;

      temp_index  BINARY_INTEGER;

   BEGIN
      /*
      || if lockhandle_tbl empty must call ALLOCATE_UNIQUE
      */
      IF lockhandle_tbl.COUNT = 0
      THEN

         DBMS_LOCK.ALLOCATE_UNIQUE
            (lockname =&gt; lockname_IN
            ,lockhandle =&gt; temp_lockhandle
            ,expiration_secs =&gt; expiration_secs_IN);

         lockhandle_tbl(1).handle := temp_lockhandle;
         lockhandle_tbl(1).name := lockname_IN;

      /*
      || check lockhandle_tbl for matching lockname
      */
      ELSE
         FOR i IN lockhandle_tbl.FIRST..lockhandle_tbl.LAST
         LOOP
            IF lockhandle_tbl(i).name = lockname_IN
            THEN
               temp_lockhandle := lockhandle_tbl(i).handle;
            END IF;
         END LOOP;
      END IF;

      /*
      || if temp_lockhandle still null, call ALLOCATE_UNIQUE
      || and load entry into lockhandle_tbl
      */
      IF temp_lockhandle IS NULL
      THEN
         DBMS_LOCK.ALLOCATE_UNIQUE
            (lockname =&gt; lockname_IN
            ,lockhandle =&gt; temp_lockhandle);

         /*
         || add to end of lockhandle_tbl
         */
         temp_index := lockhandle_tbl.LAST+1;
         lockhandle_tbl(temp_index).handle := temp_lockhandle;
         lockhandle_tbl(temp_index).name := lockname_IN;

      END IF;

      RETURN temp_lockhandle;
   END lockhandle;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The lockhandle function alone is enough to make using named locks much easier. It relieves the programmer of having to create lockhandle variables for each named lock and also guarantees that the ALLOCATE_UNIQUE procedure is called only once per named lock. New named locks can be used immediately without coding supporting routines, as these are handled generically in the function. Furthermore, the lockhandle function can be invoked directly in calls to REQUEST or CONVERT. In the following procedure, the printer_lockname variable holds the name of a lock being used to serialize access to a <A
CLASS="indexterm"
NAME="ch04-idx-20256-0"
></A
>printer:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   PROCEDURE get_printer_lock
      (lock_status_OUT OUT INTEGER)
   IS
   BEGIN
      lock_status_OUT := DBMS_LOCK.REQUEST
                            (dblock.lockhandle(printer_lockname));
   END get_printer_lock;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.4.1.3"
>4.1.4.1.2 <A
CLASS="indexterm"
NAME="ch04-idx-20257-0"
></A
>get_lock_TF function</A
></H4
><P
CLASS="para"
>Applications using DBMS_LOCK usually must check return values from calls to the REQUEST or CONVERT functions to determine if access to the locked resource has been acquired. The dblock package includes a function called get_lock_TF, which takes a lockname and lock mode as IN parameters and returns the Boolean value TRUE if the named lock has been acquired in the desired mode. Using get_lock_TF, we can write code like the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   IF dblock.get_lock_TF
         (printer_lockname,DBMS_LOCK.x_mode)
   THEN
      /* invoke print routine here */
   ELSE
      /* cannot print, tell user to try later */
   END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Code like this is far easier to understand and maintain than code that calls DBMS_LOCK programs directly. All the complexity of using DBMS_LOCK is eliminated; the program merely calls get_lock_TF and proceeds directly to appropriate logic based on the return value. Here is the body of get_lock_TF:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk:  <A
CLASS="indexterm"
NAME="ch04-idx-20261-0"
></A
>dblock.sql */*
   FUNCTION get_lock_TF
      (lockname_IN IN lockname_var%TYPE
      ,mode_IN IN INTEGER := DBMS_LOCK.x_mode
      ,timeout_IN IN INTEGER := 1
      ,release_on_commit_TF IN BOOLEAN := FALSE)
   RETURN BOOLEAN
   IS
      call_status INTEGER;

      /* handle for the named lock */
      temp_lockhandle lockhandle_var%TYPE := lockhandle(lockname_IN);

   BEGIN
      call_status := DBMS_LOCK.REQUEST
                        (lockhandle =&gt; temp_lockhandle
                        ,lockmode =&gt; mode_IN
                        ,timeout =&gt; timeout_IN
                        ,release_on_commit =&gt; release_on_commit_TF
                        );
      /*
      || if lock already owned, convert to requested mode
      */
      IF call_status = 4
      THEN
         call_status := DBMS_LOCK.CONVERT
                           (lockhandle =&gt; temp_lockhandle
                           ,lockmode =&gt; mode_IN
                           ,timeout =&gt; timeout_IN
                           );
      END IF;

      RETURN (call_status = 0);
   END get_lock_TF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that get_lock_TF first calls REQUEST and then CONVERT if the lock is already owned. This relieves the programmer of yet another bit of housekeeping, and the return value accurately reflects whether the lock is owned in the requested mode. The temp_lockhandle variable is used in the calls to DBMS_LOCK programs to avoid calling the lockhandle function more than <A
CLASS="indexterm"
NAME="ch04-idx-20259-0"
></A
>once.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch04-SECT-1.4.1.4"
>4.1.4.1.3 The committed_TF and release functions</A
></H4
><P
CLASS="para"
>The dblock package also includes a procedure called release, which releases a named lock, and a function called <A
CLASS="indexterm"
NAME="ch04-idx-20262-0"
></A
>committed_TF. The latter demonstrates using the release_on_commit parameter of the REQUEST function to determine whether a COMMIT has taken place in the session. The body of committed_TF looks like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
> /* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch04-idx-21495-0"
></A
> dblock.sql */*
 /* used by committed_TF, unique to each session */
   commit_lockname  lockname_var%TYPE :=
                        DBMS_SESSION.UNIQUE_SESSION_ID;

   FUNCTION committed_TF RETURN BOOLEAN
   IS
      call_status INTEGER;
   BEGIN
      /* get unique lock, expire in one day */
      call_status := DBMS_LOCK.REQUEST
                     (lockhandle =&gt;
                     lockhandle(commit_lockname,86400)
                     ,lockmode =&gt; DBMS_LOCK.x_mode
                     ,timeout =&gt; 0
                     ,release_on_commit =&gt; TRUE);

      RETURN (call_status = 0);
   END committed_TF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The committed_TF function uses a named lock called commit_lockname that is unique to each session, having been initialized by calling DBMS_SESSION.UNIQUE_SESSION_ID. It then calls DBMS_LOCK.REQUEST to acquire an exclusive lock on commit_lockname, making sure to specify TRUE for the release_on_commit parameter. Once the lock has been acquired initially, the success of subsequent calls indicates that the lock has been released, and thus a COMMIT (or ROLLBACK) has taken place. The function is probably not that useful in practice, but it makes a nice academic <A
CLASS="indexterm"
NAME="ch04-idx-20264-0"
></A
>exercise.</P
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch04-SECT-1.4.2"
>4.1.4.2 Using locks to signal service availability</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch04-idx-20266-0"
></A
>One way in which DBMS_LOCK can be usefully employed is to indicate the availability of service programs to database sessions. The basic steps are quite simple:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Assign specific locks to the server and/or each service provided.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The server process holds the lock(s) in exclusive mode when services are available.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Client programs request the lock to determine service availability.</P
></LI
></OL
><P
CLASS="para"
>To make this more concrete, the following code fragments might be part of a package used to coordinate access to a computation server called calcman:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE calcman
IS
   /* the actual service provider program */
   PROCEDURE calcman_driver;

   /* function called by clients to determine availability */
   FUNCTION calcman_available RETURN BOOLEAN;

END calcman;

PACKAGE BODY calcman
IS
   /* lock name used to flag service availability */
   calcman_lockname  VARCHAR2(100):= 'CALCMAN_LOCK';

   PROCEDURE calcman_driver
   IS
   BEGIN
      /*
      || get the special lock in exclusive mode
      */
      IF dblock.get_lock_TF
            (lockname_IN =&gt; calcman_lockname
            ,mode_IN =&gt; DBMS_LOCK.x_mode
            ,timeout_IN =&gt; 1
            ,release_on_commit_TF =&gt; FALSE)
      THEN
         /*
         || execute the service loop here, which probably
         || involves listening on a database pipe for
         || service requests and sending responses on pipes
         */
         /* 
         || loop forever and process calc requests 
         */
         WHILE NOT terminate_TF 
         LOOP
            receive_unpack_calc_request
               (timeout_IN =&gt; DBMS_PIPE.maxwait
               ,request_rec_OUT=&gt; request_rec
               ,return_code_OUT =&gt; temp_return_code);
            IF temp_return_code != 0
            THEN
               DBMS_PIPE.PURGE(request_pipe);
            ELSE
               process_request(request_rec);
            END IF;
         END LOOP;
      ELSE
         /* service is already running in another process, exit */
         RETURN;
      END IF:
   END calcman_driver;


   FUNCTION calcman_available RETURN BOOLEAN
   IS
      got_lock  BOOLEAN;
   BEGIN
      got_lock := dblock.get_lock_TF
                     (lockname =&gt; calcman_lockname
                     ,mode_IN =&gt; DBMS_LOCK.sx_mode
                     ,timeout_IN =&gt; 0
                     ,release_on_commit_TF =&gt; TRUE);

      /*
      || do not hold lock, this could conflict with
      || starting service
      */
      dblock.release(calcman_lockname);

      /* failure to get lock indicates server available */
      RETURN NOT got_lock;
   END calcman_available;

END calcman;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The calcman_driver procedure grabs and holds the lock as long as it is executing. If the lock is not available within one second, the procedure is already running in another session and exits silently in the current session. Thus, the lock ensures that only one calcman_driver will be executing at any time. Note the importance of not releasing the lock at COMMIT, ensuring that the lock is held as long as the service process is alive. The service can make itself unavailable at any time by simply releasing the lock.</P
><P
CLASS="para"
>The service that calcman_driver provides is not specified in the previous code fragments. It could be a complex calculation requiring large PL/SQL tables for which the overhead of having all users execute the calculation individually is too great. Or it could be connected to an external service routine of some kind. A fuller discussion of how to implement such service procedures using database pipes can be found in <A
CLASS="xref"
HREF="ch03_01.htm"
>Chapter 3, <CITE
CLASS="chapter"
>Intersession Communication</CITE
></A
>.</P
><P
CLASS="para"
>Client programs call the calcman_available function to determine whether the server is executing and providing its computation services. The function attempts to get the lock and, if it succeeds, this indicates that the service is not available. The lock is requested in shared mode exclusive; as a consequence, concurrent calls to the get_lock_TF function from different sessions may all succeed and indicate unavailability. If the lock is requested in exclusive mode, there is a chance that simultaneous execution of the function by two users could falsely indicate to one user that the service is available. The calcman_available function also releases the lock immediately to keep it from interfering with the calcman_driver program, which is attempting <A
CLASS="indexterm"
NAME="ch04-idx-20268-0"
></A
>to <A
CLASS="indexterm"
NAME="ch04-idx-20251-0"
></A
>secure <A
CLASS="indexterm"
NAME="ch04-idx-20248-0"
></A
>the <A
CLASS="indexterm"
NAME="ch04-idx-20159-0"
></A
>lock.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch03_02.htm"
TITLE="3.2 DBMS_ALERT: Broadcasting Alerts to Users"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 3.2 DBMS_ALERT: Broadcasting Alerts to Users"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_02.htm#ch04-SECT-2.1.1"
TITLE="4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>3.2 DBMS_ALERT: Broadcasting Alerts to Users</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.2 DBMS_TRANSACTION: Interfacing to SQL Transaction Statements</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
