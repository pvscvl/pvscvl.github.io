<HTML
><HEAD
><TITLE
>[Chapter 14] Snapshots</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:00:54Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part04.htm"
TITLE="IV. Distributed Database Packages"><LINK
REL="prev"
HREF="part04.htm"
TITLE="IV. Distributed Database Packages"><LINK
REL="next"
HREF="ch14_02.htm#ch14-SECT-2.1"
TITLE="14.2 DBMS_REFRESH: Managing Snapshot Groups"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part04.htm"
TITLE="IV. Distributed Database Packages"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: IV. Distributed Database Packages"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 14</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch14_02.htm#ch14-SECT-2.1"
TITLE="14.2 DBMS_REFRESH: Managing Snapshot Groups"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 14.2 DBMS_REFRESH: Managing Snapshot Groups"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch14-26044"
>14. Snapshots</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch14-10408"
TITLE="14.1 DBMS_SNAPSHOT: Managing Snapshots"
>DBMS_SNAPSHOT: Managing Snapshots</A
><BR><A
CLASS="sect1"
HREF="ch14_02.htm#ch14-SECT-2.1"
TITLE="14.2 DBMS_REFRESH: Managing Snapshot Groups"
>DBMS_REFRESH: Managing Snapshot Groups</A
><BR><A
CLASS="sect1"
HREF="ch14_03.htm#ch14-SECT-3.1.1"
TITLE="14.3 DBMS_OFFLINE_SNAPSHOT: Performing Offline Snapshot Instantiation"
>DBMS_OFFLINE_SNAPSHOT: Performing Offline Snapshot Instantiation</A
><BR><A
CLASS="sect1"
HREF="ch14_04.htm#ch14-SECT-4.1.1"
TITLE="14.4 DBMS_REPCAT: Managing Snapshot Replication Groups"
>DBMS_REPCAT: Managing Snapshot Replication Groups</A
></P
><P
></P
></DIV
><P
CLASS="para"
>Oracle provides a number of packages that let you perform various types of administrative operations on snapshots and snapshot logs. Most of these administrative operations are relevant only if you are using snapshot groups or the Oracle advanced replication option. This chapter describes the following packages:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>DBMS_SNAPSHOT </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Lets you maintain snapshots and snapshot logs. </P
></DD
><DT
CLASS="term"
>DBMS_OFFLINE_SNAPSHOT</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Allows you to instantiate snapshots without having to run the CREATE SNAPSHOT command over the network. This package is particularly useful if you need to instantiate extremely large snapshots.</P
></DD
><DT
CLASS="term"
>DBMS_REFRESH</DT
><DD
CLASS="listitem"
><P
CLASS="para"
> Administers snapshot groups at a snapshot site.</P
></DD
><DT
CLASS="term"
>DBMS_REPCAT</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Performs a number of advanced replication operations. This chapter describes only the DBMS_REPCAT programs that deal with snapshots; all other programs are described in <A
CLASS="xref"
HREF="ch15_01.htm"
>Chapter 15, <CITE
CLASS="chapter"
>Advanced Replication</CITE
></A
>.</P
></DD
></DL
><P
CLASS="para"
>Even if you are using PL/SQL's built-in snapshot packages, you will continue to use the CREATE SNAPSHOT command to create your snapshots. </P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch14-10408"
>14.1 DBMS_SNAPSHOT: Managing Snapshots</A
></H2
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch14-idx-946299-0"
></A
>DBMS_SNAPSHOT package contains programs that allow you to maintain snapshots and snapshot logs, and to set and query package state variables associated with the advanced replication option. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch14-SECT-1.1"
>14.1.1 Getting Started with DBMS_SNAPSHOT</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch14-idx-946306-0"
></A
>DBMS_SNAPSHOT package is created when the Oracle database is installed. The <I
CLASS="filename"
>dbmssnap.sql</I
><A
CLASS="indexterm"
NAME="ch14-idx-946307-0"
></A
> script (found in the built-in packages source directory, as described in <A
CLASS="xref"
HREF="ch01_01.htm"
>Chapter 1, <CITE
CLASS="chapter"
>Introduction</CITE
></A
>) contains the source code for this package's specification. This script is called by <I
CLASS="filename"
>catproc.sql</I
>, which is normally run immediately after database creation. The script creates the public synonym <A
CLASS="indexterm"
NAME="ch14-idx-947952-0"
></A
>DBMS_SNAPSHOT for the package and grants EXECUTE privilege on the package to public. All Oracle users can reference and make use of this package.</P
><P
CLASS="para"
>Table 14-1 <A
CLASS="indexterm"
NAME="ch14-idx-946508-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946508-1"
></A
>lists the programs contained in the DBMS_SNAPSHOT package.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="AUTOID-26970"
>Table 14.1: DBMS_SNAPSHOT Packages </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use in SQL?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946312-0"
></A
>BEGIN_TABLE_REORGANIZATION (Oracle8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Called prior to reorganizing a master table (e.g., through export/import); saves data required to refresh snapshots</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946313-0"
></A
>END_TABLE_REORGANIZATION (Oracle8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Called after reorganizing a master table (e.g., through export/import); validates data required to refresh snapshots</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946308-0"
></A
>I_AM_A_REFRESH</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns value of REP$WHAT_AM_I.I_AM_A_SNAPSHOT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946311-0"
></A
>PURGE_LOG</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Purges snapshot log</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946310-0"
></A
>REFRESH</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Refreshes a snapshot</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946314-0"
></A
>REGISTER_SNAPSHOT</P
><P
CLASS="para"
>(Oracle8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Records information about snapshots at the master site in the DBA_REGISTERED_SNAPSHOTS data dictionary view</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946309-0"
></A
>SET_I_AM_A_REFRESH</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sets REP$WHAT_AM_I.I_AM_A_SNAPSHOT to specified value</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946315-0"
></A
>UNREGISTER_SNAPSHOT</P
><P
CLASS="para"
>(Oracle8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Removes information about snapshots at the master site from the DBA_REGISTERED_SNAPSHOTS data dictionary view</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>DBMS_SNAPSHOT does not define any exceptions.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> All of the programs in DBMS_SNAPSHOT are available regardless of whether you are using snapshot groups or the advanced replication option.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch14-SECT-1.2"
>14.1.2 <A
CLASS="indexterm"
NAME="ch14-idx-946509-0"
></A
>Using the I_AM_A_REFRESH Package State Variable</A
></H3
><P
CLASS="para"
>The I_AM_A_REFRESH and SET_I_AM_A_REFRESH programs query and set Oracle's REP$I_AM_A_REFRESH package variable. Oracle uses this variable in replication triggers and elsewhere internally to determine whether a given DML statement should be replicated to other master sites.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch14-SECT-1.2.1"
>14.1.2.1 The DBMS_SNAPSHOT.I_AM_A_REFRESH function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch14-idx-946316-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946316-1"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946316-2"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946316-3"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946316-4"
></A
>I_AM_A_REFRESH function queries the REP$I_AM_A_REFRESH package variable. If this variable equals "Y," then the session is refreshing a snapshot or applying propagated DML to a replicated table. The header for the function follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SNAPSHOT.I_AM_A_REFRESH RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The function does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27087"
>14.1.2.1.1 Examples</A
></H4
><P
CLASS="para"
>Let's look at several examples of querying the I_AM_A_REFRESH package variable.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27090"
>14.1.2.1.2 Generating replication support</A
></H4
><P
CLASS="para"
>Suppose now that you are replicating a table named COUNTRIES in the SPROCKET schema:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; DESC sprocket.countries
Name               Null?        Type
---------------    ---------    --------------
COUNTRY_ID         NOT NULL     NUMBER(6)
ISO3166_NUMBER     NOT NULL     NUMBER(3)
ISO3166_NAME       NOT NULL     VARCHAR2(50)
ISO2_CODE          NOT NULL     VARCHAR2(2)
ISO3_CODE          NOT NULL     VARCHAR2(3)
AUDIT_DATE         NOT NULL     DATE
AUDIT_USER         NOT NULL     VARCHAR2(30)
GLOBAL_NAME        NOT NULL     VARCHAR2(20)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you generate replication support for this table with DBMS_REPCAT.GENERATE_REPLICATION_SUPPORT (described in <A
CLASS="xref"
HREF="ch15_01.htm"
>Chapter 15</A
>), Oracle creates an AFTER ROW <A
CLASS="indexterm"
NAME="ch14-idx-946320-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946320-1"
></A
>trigger named COUNTRIES$RT, which queues DML to other master sites. The text of the trigger follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>    after delete or insert or update on &quot;SPROCKET&quot;.&quot;COUNTRIES&quot;
  for each row
declare
  flag char;
begin
  if &quot;COUNTRIES$TP&quot;.active then
    if inserting then
      flag := 'I';
    elsif updating then
      flag := 'U';
    elsif deleting then
      flag := 'D';
    end if;
    &quot;COUNTRIES$TP&quot;.replicate(
      :old.&quot;AUDIT_DATE&quot;,:new.&quot;AUDIT_DATE&quot;,
      :old.&quot;AUDIT_USER&quot;,:new.&quot;AUDIT_USER&quot;,
      :old.&quot;COUNTRY_ID&quot;,:new.&quot;COUNTRY_ID&quot;,
      :old.&quot;GLOBAL_NAME&quot;,:new.&quot;GLOBAL_NAME&quot;,
      :old.&quot;ISO2_CODE&quot;,:new.&quot;ISO2_CODE&quot;,
      :old.&quot;ISO3166_NAME&quot;,:new.&quot;ISO3166_NAME&quot;,
      :old.&quot;ISO3166_NUMBER&quot;,:new.&quot;ISO3166_NUMBER&quot;,
      :old.&quot;ISO3_CODE&quot;,:new.&quot;ISO3_CODE&quot;,
      flag);
  end if;
end;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, this trigger replicates DML only if the function COUNTRIES$TP.active is TRUE. This ACTIVE function uses DBMS_SNAPSHOT.I_AM_A_REFRESH as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>function active return boolean
is
begin
return (not((is_snapshot and dbms_snapshot.I_am_a_refresh) or
not dbms_reputil.replication_is_on));
end active;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Oracle uses the active function, which calls DBMS_SNAPSHOT.I_AM_A_REFRESH, to distinguish between your application's DML operations and the DML that is being propagated from another master site.</P
><P
CLASS="para"
>The base table of an updateable snapshot has a trigger that also uses the I_AM_A_REFRESH function. </P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27107"
>14.1.2.1.3 Auditing triggers</A
></H4
><P
CLASS="para"
>Under some circumstances, you may need to determine the source of DML statements. For example, you will notice that the countries table has a number of fields used for auditing: audit_date, audit_user, and global_name. We have a BEFORE ROW trigger that populates these fields.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE TRIGGER countries_audit
BEFORE INSERT OR UPDATE ON countries
FOR EACH ROW

DECLARE
        vGlobalName     VARCHAR2(30) := DBMS_REPUTIL.GLOBAL_NAME;
BEGIN
        IF NOT (DBMS_SNAPSHOT.I_AM_A_REFRESH) THEN
        BEGIN 
                :new.audit_date         := SYSDATE;
                :new.audit_user         := USER;
                :new.global_name      := vGlobalName;
        END IF;

END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This trigger fires when an application performs an INSERT or UPDATE, but not when the DML is propagated from other sites.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> All row-level replication triggers are AFTER ROW triggers. Although a table can have multiple triggers of the same type, you cannot control the order in which they are fired. Therefore, it is safest to use BEFORE ROW triggers to perform auditing on replicated tables; in this way, you are guaranteed that BEFORE ROW triggers fire before AFTER ROW  <A
CLASS="indexterm"
NAME="ch14-idx-946327-0"
></A
>triggers.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch14-SECT-1.2.2"
>14.1.2.2 The DBMS_SNAPSHOT.SET_I_AM_A_REFRESH procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch14-idx-946330-0"
></A
>SET_I_AM_A_REFRESH procedure sets the I_AM_A_REFRESH package variable. The header for the procedure is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SNAPSHOT.SET_I_AM_A_REFRESH  (value IN  BOOLEAN);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where value is the value (Y or N) being set. This procedure does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27122"
>14.1.2.2.1 Example</A
></H4
><P
CLASS="para"
>If you need to enable and disable replication triggers at the session level, you can do so with the SET_I_AM_A_REFRESH procedure. To enable the triggers, specify the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SNAPSHOT.SET_I_AM_A_REFRESH( value =&gt; FALSE )</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To disable them, specify the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SNAPSHOT.SET_I_AM_A_REFRESH( value =&gt; TRUE )</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Use this package carefully, because disabling replication triggers effectively disables any <A
CLASS="indexterm"
NAME="ch14-idx-946331-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946331-1"
></A
>conflict resolution mechanisms you may have <A
CLASS="indexterm"
NAME="ch14-idx-946513-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946513-1"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946513-2"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946513-3"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946513-4"
></A
>defined. (See <A
CLASS="xref"
HREF="ch17_01.htm"
>Chapter 17, <CITE
CLASS="chapter"
>Deferred  Transactions and Remote Procedure Calls</CITE
></A
>, for a discussion of these  mechanisms.)</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch14-SECT-1.3"
>14.1.3 Refreshing Snapshots</A
></H3
><P
CLASS="para"
>Calling the <A
CLASS="indexterm"
NAME="ch14-idx-946332-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946332-1"
></A
>REFRESH procedure from a snapshot site forces the refresh of the specified snapshot(s). Typically, this procedure is used to refresh an individual snapshot, or a group of snapshots that are not in the same snapshot refresh group. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch14-SECT-1.3.1"
>14.1.3.1 The DBMS_SNAPSHOT.REFRESH procedure</A
></H4
><P
CLASS="para"
>Call the REFRESH procedure to force a snapshot refresh. The specifications for the Oracle7 and Oracle8 versions of the REFRESH procedure differ. Note that the Version 8.0 implementation adds parameters that support parallelism, and drops the execute_as_user parameter. Both versions are overloaded, allowing you to specify the list of snapshots as a comma-delimited string in the list parameter, or as a PL/SQL table in the tab parameter. The other parameters are identical for the two versions. </P
><P
CLASS="para"
>Here is the Oracle7 specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SNAPSHOT.REFRESH
   (list IN VARCHAR2,
    method IN VARCHAR2 DEFAULT NULL,
    rollback_seg IN VARCHAR2 DEFAULT NULL,
    push_deferred_rpc IN BOOLEAN DEFAULT TRUE,
    refresh_after_errors IN BOOLEAN DEFAULT FALSE,
    execute_as_user IN BOOLEAN DEFAULT FALSE );

PROCEDURE DBMS_SNAPSHOT.REFRESH
   (tab IN OUT dbms_utility.uncl_array,
    method  IN VARCHAR2 DEFAULT NULL,
    rollback_seg IN VARCHAR2 DEFAULT NULL,
    push_deferred_rpc IN BOOLEAN DEFAULT TRUE,
    refresh_after_errors IN BOOLEAN DEFAULT FALSE,
    execute_as_user IN BOOLEAN DEFAULT FALSE );</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the Oracle8 specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SNAPSHOT.REFRESH
   (list IN VARCHAR2,
    method  IN VARCHAR2 := NULL,
    rollback_seg IN VARCHAR2 := NULL,
    push_deferred_rpc IN BOOLEAN := TRUE,
    refresh_after_errors IN BOOLEAN := FALSE,
    purge_option IN BINARY_INTEGER := 1,
    parallelism IN BINARY_INTEGER := 0,
    heap_size IN BINARY_INTEGER := 0);
 
  PROCEDURE DBMS_SNAPSHOT.REFRESH
    (tab IN OUT dbms_utility.uncl_array,
     method IN VARCHAR2 := NULL,
     rollback_seg IN VARCHAR2 := NULL,
     push_deferred_rpc IN BOOLEAN := TRUE,
     refresh_after_errors IN BOOLEAN := FALSE,
     purge_option IN BINARY_INTEGER := 1,
     parallelism IN BINARY_INTEGER := 0,
     heap_size  IN BINARY_INTEGER := 0);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>list</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Comma-separated list of snapshots to be refreshed. Use list or tab.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>tab</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PL.SQL table of snapshots to be refreshed. Use list or tab.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>method</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Refresh method:</P
><P
CLASS="para"
>`?' uses the default refresh method. If you specified a refresh method when you created the snapshot, that is the default method. Otherwise, Oracle uses a fast refresh if possible, and a complete refresh if not.</P
><P
CLASS="para"
>`F' or `f' uses fast refresh if possible, and returns ORA-12004 if not.</P
><P
CLASS="para"
>`C' or `c' uses a COMPLETE refresh. This parameter should include a single character for each snapshot specified in list or tab, in the same order as the snapshot names appear. If list or tab contains more snapshots than the method list, the additional snapshots are refreshed with their default method.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>rollback_seg</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Optional; specifies the rollback segment to use for the refresh.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>push_deferred_rpc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Optional; for updateable snapshots only. If TRUE (the default), then local updates are sent back to the master site before the snapshot is refreshed (otherwise, local updates will be temporarily overwritten).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>refresh_after_errors</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Optional; for updateable snapshots only. If TRUE, proceed with the refresh even if outstanding errors (conflicts) are logged in the DEFERROR data dictionary view at the master site. Default is FALSE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>execute_as_user</P
><P
CLASS="para"
>(Version 7 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If FALSE (the default) then the call to the remote system is performed under the privilege domain of the user that created the snapshot. If TRUE, the call is performed as the user calling the refresh procedure.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>purge_option</P
><P
CLASS="para"
>(Oracle8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If push_deferred_rpc is TRUE, this designates the purge method; default is 1.</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>0 No purge</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>1 Lazy purge (optimized for time)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>2 Aggressive purge (complete)</P
></LI
></UL
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>parallelism</P
><P
CLASS="para"
>(Oracle8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If push_defered_rpc is TRUE, this determines the maximum degree of parallelism; default is 1.</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>0 Serial</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>1 Parallel with one slave</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>N Parallel with N slaves (N &gt; 1)</P
></LI
></UL
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>heap_size</P
><P
CLASS="para"
>(Oracle8 only)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Used only if parallelism &gt; 0. Sets the maximum number of transactions to be examined simultaneously for determining parallel scheduling. Oracle determines this value internally; you are advised not to use it.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The REFRESH procedure does not raise any exceptions.</P
><P
CLASS="para"
>All of the snapshots passed to list or tab are refreshed as a single transaction; all or none are refreshed. In addition, the refreshed snapshots will respect all integrity constraints that exist among the master tables.</P
><P
CLASS="para"
>You might want to force a manual refresh of a snapshot if the next scheduled refresh is too far in the future, or if you have repaired a problem that caused the scheduled refresh job to break. Forcing a manual refresh of a snapshot does not alter its refresh schedule.</P
><P
CLASS="para"
>A FAST refresh requires a <A
CLASS="indexterm"
NAME="ch14-idx-946336-0"
></A
>snapshot log on the master table, and is possible only for simple snapshots in Oracle7; Oracle8 supports fast refreshes subquery snapshots meeting certain conditions. Fast refreshes read the snapshot log to determine which rows have changed since the last refresh, and only those rows are updated.</P
><P
CLASS="para"
>If you are concerned about the amount of <A
CLASS="indexterm"
NAME="ch14-idx-946337-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946337-1"
></A
>rollback the refresh will require, you can use the rollback_seg parameter to designate a rollback segment that is suitably sized for the transaction. However, you are not guaranteed that no other transactions will use this rollback segment. In general, you should consider making relatively large rollback segments if you anticipate frequent refreshes of large snapshots.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27254"
>14.1.3.1.1 Restrictions</A
></H4
><P
CLASS="para"
>You can call REFRESH only from a snapshot site.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27257"
>14.1.3.1.2 Examples</A
></H4
><P
CLASS="para"
>Once you are familiar with the various parameters to the REFRESH procedure, it becomes simple to use, as the following examples illustrate.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27260"
>14.1.3.1.3 Read-only snapshot</A
></H4
><P
CLASS="para"
>This example shows a refresh as a read-only snapshot named PRICE_LIST:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	DBMS_SNAPSHOT.REFRESH (list =&gt; 'PRICES');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the simplest possible refresh method. Note that since we have not provided a schema name, this would have to be executed from the snapshot owner's account.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27265"
>14.1.3.1.4 Related read-only snapshots</A
></H4
><P
CLASS="para"
>In the next example, we refresh a set of related read-only snapshots.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
vSnapshotList dbms_utility.uncl_array
BEGIN
	vSnapshotList(1) = 'COUNTRIES'
	vSnapshotList(2) = 'STATES'
	vSnapshotList(3) = 'POSTAL_CODES'
	vSnapshotList(4) = 'CUSTOMER_ADDRESSES'

	DBMS_SNAPSHOT.REFRESH(	tab =&gt; vSnapShotList,
				method =&gt; 'CCF?',
				rollback_segment =&gt; 'RB1'
				execute_as_user =&gt; FALSE);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This example illustrates several points:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You can provide the list of snapshots as a PL/SQL table. Oracle will refresh all of the snapshots in one atomic transaction; either all or none of the snapshots are refreshed. All referential consistencies among the master tables will be preserved in the snapshot tables.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can specify different refresh methods for each snapshot. This example performs a complete refresh on COUNTRIES and STATES, a full refresh on POSTAL_CODES, and a fast refresh (if possible) on CUSTOMER_ADDRESSES. If Oracle cannot use a fast refresh on the CUSTOMER_ADDRESS table, it will perform a complete refresh instead.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can designate a specific, suitably sized rollback segment for the refresh.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can set the parameter, execute_as_user, to FALSE to force Oracle to refresh the snapshot under the privilege domain of the snapshot owner.</P
></LI
></OL
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27279"
>14.1.3.1.5 Updateable snapshot.  </A
></H4
><P
CLASS="para"
>In the next example, we refresh the updateable snapshot DAILY_STORE_SALES.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
vSnapshotList dbms_utility.uncl_array
BEGIN
	vSnapshotList(1) = 'DAILY_STORE_SALES'
	
	DBMS_SNAPSHOT.REFRESH(	tab =&gt; vSnapShotList,
				method =&gt; '?'
				push_deferred_rpc =&gt; FALSE);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since we set push_deferred_rpc to FALSE (the default is TRUE), the refresh will overwrite any local changes. The local changes will be visible again after the remote procedure call (RPC) pushes them to the master site and snapshot is refreshed again.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27284"
>14.1.3.1.6 Parallel refreshes</A
></H4
><P
CLASS="para"
>In this example, the parallelism feature of Oracle8 allows us to use four processes to refresh the updateable snapshot DAILY_STORE_SALES:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
vSnapshotList dbms_utility.uncl_array
BEGIN
	vSnapshotList(1) = 'DAILY_STORE_SALES'
	
	DBMS_SNAPSHOT.REFRESH(	tab =&gt; vSnapShotList,
				method =&gt; '?'
				parallelism =&gt; 4,
				purge_option = 2);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The purge_option parameter controls how Oracle purges the snapshot site's deferred transaction queue; Oracle8 does not purge the queue automatically when the transactions propagate, so you must use DBMS_DEFER_SYS.SCHEDULE_PURGE (described in <A
CLASS="xref"
HREF="ch17_01.htm"
>Chapter 17</A
>) to schedule a job to purge the queue, lest it become large and unmanageable. The purge_option parameter in REFRESH provides an opportunity to purge the queue of transactions associated with the updateable snapshot(s) you are refreshing.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Purging the deferred transaction queue is not the same thing as purging a snapshot log!</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch14-SECT-1.4"
>14.1.4 Purging the Snapshot Log</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch14-idx-946338-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946338-1"
></A
>PURGE_LOG procedure deletes records from the snapshot log on a master table. You may wish to do this if the snapshot log becomes very large, or if you drop a subset of the snapshots for which the table is a master. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch14-SECT-1.4.1"
>14.1.4.1 The DBMS_SNAPSHOT.PURGE.LOG procedure</A
></H4
><P
CLASS="para"
>Call the PURGE_LOG procedure to delete snapshot log records. The specification for the PURGE_LOG procedure follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SNAPSHOT.PURGE_LOG
   (master VARCHAR2
   ,num BINARY_INTEGER DEFAULT 1
   ,flag VARCHAR2 DEFAULT 'NOP' );</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>master</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the master table</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>num</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Delete records required to refresh the oldest number of unrefreshed snapshot; default is 1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>flag</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Set to DELETE to guarantee that records are deleted for at least one snapshot regardless of the setting of num</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The PURGE_LOG procedure does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27332"
>14.1.4.1.1 Examples</A
></H4
><P
CLASS="para"
>The following examples illustrate the use of the PURGE_LOG procedure. The first example shows the simplest form of the procedure; the only parameter is master:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	DBMS_REFRESH.PURGE_LOG( master =&gt; 'COUNTRIES' );
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since the call uses the default value for num, 1, it will purge the snapshot log records required for a fast refresh of the least recently refreshed snapshot&nbsp;-- that is, the most stale snapshot.</P
><P
CLASS="para"
>This example shows the use of several parameters:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	DBMS_REFRESH.PURGE_LOG
        ( master =&gt; 'COUNTRIES', num =&gt; 5, flag =&gt; 'DELETE' );
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this example, the procedure deletes snapshot log records required for a fast refresh of the five most stale snapshots. However, since we have set the flag parameter to DELETE, the call is guaranteed to delete the records for at least one snapshot, even if the table masters fewer than <A
CLASS="indexterm"
NAME="ch14-idx-946340-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946340-1"
></A
>five <A
CLASS="indexterm"
NAME="ch14-idx-946334-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946334-1"
></A
>snapshots.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> To delete all records from a snapshot log, set the num parameter to a high value (greater than the number of snapshots mastered to the master table, specified in the master parameter).</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch14-SECT-1.5"
>14.1.5 Reorganizing Tables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946350-0"
></A
>Occasionally a DBA must reorganize a table&nbsp;-- in other words, coalesce its extents and reduce row chaining. Two new programs in Oracle8 allow you to reorganize a master table without invalidating its snapshot log: BEGIN_TABLE_REORGANIZATION and END_TABLE_REORGANIZATION. Therefore, you do not have to perform complete refreshes of the table's snapshots after it is reorganized. To take advantage of this new feature, you must be using primary key snapshots. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch14-SECT-1.5.1"
>14.1.5.1 The DBMS_SNAPSHOT.BEGIN_TABLE_REORGANIZATION procedure (Oracle8 only)</A
></H4
><P
CLASS="para"
>If you are reorganizing a table, call the <A
CLASS="indexterm"
NAME="ch14-idx-946354-0"
></A
>BEGIN_TABLE_REORGANIZATION procedure before reorganizing the table, and the END_TABLE_REORGANIZATION procedure when you are finished. The specification for BEGIN_TABLE_REORGANIZATION follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SNAPSHOT.BEGIN_TABLE_REORGANIZATION
   (tabowner IN VARCHAR2
   ,tabname  IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>tabowner</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Owner of the master table</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>tabname</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the master table being reorganized</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>This procedure does not raise any exceptions.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch14-SECT-1.5.2"
>14.1.5.2 The DBMS_SNAPSHOT.END_TABLE_REORGANIZATION procedure (Oracle8 only)  </A
></H4
><P
CLASS="para"
>Call the <A
CLASS="indexterm"
NAME="ch14-idx-946358-0"
></A
>END_TABLE_REORGANIZATION procedure when you are finished reorganizing a table. The specification for END_TABLE_REORGANIZATION follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SNAPSHOT.END_TABLE_REORGANIZATION
   (tabowner IN VARCHAR2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are the same as those for BEGIN_TABLE_REORGANIZATION. This procedure does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27388"
>14.1.5.2.1 Examples</A
></H4
><P
CLASS="para"
>The following examples illustrate how to use these procedures as part of a table reorganization. The first example shows the steps for reorganizing a master table using truncation.</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Call DBMS_SNAPSHOT.BEGIN_TABLE_REORGANIZATION:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	EXECUTE DBMS_SNAPSHOT.BEGIN_TABLE_REORGANIZATION (
		tabowner =&gt; 'SPROCKET', tabname =&gt; 'COUNTRIES');
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Back up the table by exporting it, or spooling it to a flat file.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Truncate the master table, preserving the snapshot log:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TRUNCATE TABLE countries PRESERVE SNAPSHOT LOG;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Restore the table from the export file or flat file.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Call DBMS_SNAPSHOT.END_TABLE_REORGANIZATION:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	EXECUTE DBMS_SNAPSHOT.END_TABLE_REORGANIZATION (
		tabowner =&gt; 'SPROCKET', tabname =&gt; 'COUNTRIES');
END;</PRE
></BLOCKQUOTE
></LI
></OL
><P
CLASS="para"
>The next example shows the steps for reorganizing a master table using RENAME TABLE.</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Call DBMS_SNAPSHOT.BEGIN_TABLE_REORGANIZATION:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	EXECUTE DBMS_SNAPSHOT.BEGIN_TABLE_REORGANIZATION (
		tabowner =&gt; 'SPROCKET', tabname =&gt; 'COUNTRIES');
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Rename the table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>RENAME TABLE countries TO countries_pre_reorg;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Create a new version of the table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE countries AS SELECT * FROM countrie_pre_reorg;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Call DBMS_SNAPSHOT.END_TABLE_REORGANIZATION:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	EXECUTE DBMS_SNAPSHOT.END_TABLE_REORGANIZATION (
		tabowner =&gt; 'SPROCKET', tabname =&gt; 'COUNTRIES');
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Recreate any triggers that were defined on the table.</P
></LI
></OL
><P
CLASS="para"
>In both of these examples, snapshots will be able to use the snapshot log for fast refreshes after the table <A
CLASS="indexterm"
NAME="ch14-idx-946365-0"
></A
>reorganization <A
CLASS="indexterm"
NAME="ch14-idx-946360-0"
></A
>is <A
CLASS="indexterm"
NAME="ch14-idx-946352-0"
></A
>complete.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch14-SECT-1.6"
>14.1.6 Registering Snapshots</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch14-idx-946367-0"
></A
>One of the most significant improvements in Oracle8 is the automatic registration of snapshots at the master site. In Oracle7, there was no easy way to determine the location&nbsp;-- or even the existence&nbsp;-- of snapshots with master table(s) in your instance. But when you create a snapshot in Oracle8, Oracle puts a record in the <A
CLASS="indexterm"
NAME="ch14-idx-946371-0"
></A
>DBA_REGISTERED_SNAPSHOTS data dictionary view. Similarly, when you drop a snapshot, Oracle deletes the record from DBA_REGISTERED_SNAPSHOTS.</P
><P
CLASS="para"
>The REGISTER and UNREGISTER procedures let you manually maintain this data dictionary view, shown in Table <A
CLASS="xref"
HREF="ch14_01.htm"
>Table 14.2</A
>.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch14-12544"
>Table 14.2: DBA_REGISTERED_SNAPSHOTS Data Dictionary View </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Column Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>OWNER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Snapshot owner.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NAME</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Snapshot name.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SNAPSHOT_SITE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Global name of database where snapshot resides.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CAN_USE_LOG</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If YES, then snapshot refreshes can use snapshot log.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UPDATABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If YES, then snapshot is an updateable snapshot.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>REFRESH_METHOD</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Refresh method; either ROWID or PRIMARY KEY.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SNAPSHOT_ID</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unique ID of snapshot used for fast refreshes.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VERSION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Version of the snapshot. Possible values are REG_UNKNOWN, REG_V7_GROUP, REG_V8_GROUP, and REG_REPAPI_GROUP.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>QUERY_TXT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Text of the snapshot's query.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch14-SECT-1.6.1"
>14.1.6.1 The DBMS_SNAPSHOT.<A
CLASS="indexterm"
NAME="ch14-idx-946372-0"
></A
>REGISTER_SNAPSHOT procedure (Oracle 8 only)  </A
></H4
><P
CLASS="para"
>Generally, the registration and unregistration of snapshots is automatic if both the master and snapshot databases are Oracle8. However, in case the snapshot site is running Oracle7, or if the automatic registration fails, you can use the Oracle8 procedure, REGISTER_SNAPSHOT, to register the snapshot manually.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> <A
CLASS="indexterm"
NAME="ch14-idx-946378-0"
></A
>The registration of snapshots is not mandatory; it records data in DBA_REGISTERED_SNAPSHOTS that is for informational use only. You should not rely on the contents of this data dictionary view.</P
></BLOCKQUOTE
><P
CLASS="para"
>The specification for the REGISTER_SNAPSHOT procedure is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SNAPSHOT.REGISTER_SNAPSHOT
   (snapowner   IN VARCHAR2,
    snapname    IN VARCHAR2,
    snapsite    IN VARCHAR2,
    snapshot_id IN DATE | BINARY_INTEGER,
    flag        IN BINARY_INTEGER,
    qry_txt     IN VARCHAR2,
    rep_type    IN BINARY_INTEGER := dbms_snapshot.reg_unknown);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The REGISTER_SNAPSHOT procedure is overloaded; snapshot_id is a DATE type if the snapshot site is an Oracle7 database, and BINARY_INTEGER if it is an Oracle8 database. Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>snapowner</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Owner of the snapshot.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>snapname</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the snapshot.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>snapsite</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Global name of snapshot site database instance.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>snapshot_id</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ID of the snapshot. Use DATE datatype for Oracle7 snapshot sites, BINARY_INTEGER for Oracle8 snapshot sites. The snapshot_id and flag parameters are mutually exclusive.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>flag</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PL/SQL variable dictating whether future moves and creates are registered in the qry_text parameter; this flag does not appear to be used.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>qry_text</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Up to 32000 characters of the text of the snapshot query.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>rep_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Binary integer indicating the version of the snapshot. Possible values are:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>reg_unknown = 0 (the default)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>reg_v7_group = 1</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>reg_v8_group = 2</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>reg_repapi_group = 3</P
></LI
></UL
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>REGISTER_SNAPSHOT does not raise any exceptions.</P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27559"
>14.1.6.1.1 Example</A
></H4
><P
CLASS="para"
>Registration of Oracle7 snapshots is never automatic; you must call REGISTER_SNAPSHOT if you want to see Oracle7 snapshots in the DBA_REGISTERED_SNAPSHOTS data dictionary view. You must provide all of the information you want to see. In the following example, you register a snapshot from an Oracle7 snapshot site to an <A
CLASS="indexterm"
NAME="ch14-idx-946374-0"
></A
>Oracle8 <A
CLASS="indexterm"
NAME="ch14-idx-946370-0"
></A
>master:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	DBMS_SNAPSHOT.REGISTER_SNAPSHOT(
		snapowner	=&gt; 'SPROCKET',
		snapname	=&gt; 'COUNTRIES',
		snapsite	=&gt; 'D7CA.BIGWHEEL.COM',
		snapshot_id	=&gt; sysdate,
		flag		=&gt; 0,
		qry_text	=&gt; 'SELECT * FROM countries@D8CA.BIGWHEEL.COM',
		rep_typ	e	=&gt; reg_v7_group);
END;
</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch14-SECT-1.6.2"
>14.1.6.2 The DBMS_SNAPSHOT.UNREGISTER_SNAPSHOT procedures (Oracle8 only)</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch14-idx-946379-0"
></A
><A
CLASS="indexterm"
NAME="ch14-idx-946379-1"
></A
>UNREGISTER_SNAPSHOT procedure is the flip side of the REGISTER_SNAPSHOT procedure. You use UNREGISTER_SNAPSHOT when you need to manually unregister a snapshot. This procedure unregisters snapshots at the master site, regardless of whether they were registered manually or automatically. </P
><P
CLASS="para"
>The specification is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SNAPSHOT.UNREGISTER_SNAPSHOT
   (snapowner IN VARCHAR,
    snapname IN VARCHAR2,
    snapsite IN VARCHAR2)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>See the description of parameters under the REGISTER procedure.</P
><P
CLASS="para"
>UNREGISTER_SNAPSHOT does not raise any exceptions.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Unregistering a snapshot has no effect on the snapshot itself.</P
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="AUTOID-27579"
>14.1.6.2.1 Example</A
></H4
><P
CLASS="para"
>In this example, we unregister the snapshot that we created in the previous section:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
	DBMS_SNAPSHOT.UNREGISTER_SNAPSHOT(
		snapowner	=&gt; 'SPROCKET',
		snapname	=&gt; 'COUNTRIES',
		snapsite	=&gt; 'D7CA.BIGWHEEL.COM');
END</PRE
></BLOCKQUOTE
><P
CLASS="para"
>For a detailed example, see the <I
CLASS="filename"
>mastsnap.sql</I
><A
CLASS="indexterm"
NAME="ch14-idx-947928-0"
></A
> file on the companion disk. This script lists registered snapshots at a master site, including their last refresh time. It requires <A
CLASS="indexterm"
NAME="ch14-idx-946305-0"
></A
>Oracle8.</P
></DIV
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part04.htm"
TITLE="IV. Distributed Database Packages"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: IV. Distributed Database Packages"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch14_02.htm#ch14-SECT-2.1"
TITLE="14.2 DBMS_REFRESH: Managing Snapshot Groups"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 14.2 DBMS_REFRESH: Managing Snapshot Groups"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>IV. Distributed Database Packages</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>14.2 DBMS_REFRESH: Managing Snapshot Groups</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
