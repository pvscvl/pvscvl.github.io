<HTML
><HEAD
><TITLE
>[Chapter 1] 1.3 Using Built-in Packages</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:38:05Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Introduction"><LINK
REL="prev"
HREF="ch01_02.htm"
TITLE="1.2 Built-in Packages Covered in This Book"><LINK
REL="next"
HREF="ch01_04.htm"
TITLE="1.4 Examining Built-in Package Source Code"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.2 Built-in Packages Covered in This Book"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.2 Built-in Packages Covered in This Book"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Introduction"
>Chapter 1<BR>Introduction</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_04.htm"
TITLE="1.4 Examining Built-in Package Source Code"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.4 Examining Built-in Package Source Code"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch01-32001"
>1.3 Using Built-in Packages</A
></H2
><P
CLASS="para"
>There are several steps involved in using a built-in package:</P
><OL
CLASS="orderedlist"
START="1"
><LI
CLASS="listitem"
><P
CLASS="para"
>Install the built-in package into the database. In most cases, this will be done for you automatically. However, some packages, such as UTL_RAW, are not automatically installed or made publicly accessible, at least in the most recent version of Oracle as this book went to press. The individual chapters in this book will tell you about any special steps you need to take to ensure that the package is installed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Learn about what is available in the package. You can do this by reading the appropriate section of this book and also by looking at the source code (explained later in this chapter).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Place references to elements of the package in your own code. To do this, you need to know the correct syntax for referencing package elements (read on to find out how to do this).</P
></LI
></OL
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.1"
>1.3.1 What Is a Package?</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10269-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10269-1"
></A
>This section offers a brief introduction to packages. You can find more detailed treatments in both <CITE
CLASS="citetitle"
>Oracle PL /SQL Programming</CITE
> (O'Reilly &amp; Associates, 1995 and 1997), and <CITE
CLASS="citetitle"
>Advanced Oracle PL /SQL Programming with Packages </CITE
>(O'Reilly &amp; Associates, 1996), my two previous books on PL /SQL. </P
><P
CLASS="para"
>A package is a <EM
CLASS="emphasis"
>collection</EM
> of PL /SQL elements that are "packaged" or grouped together within a special BEGIN-END syntax, a kind of "meta-block" of code. Here is a partial list of the kinds of elements you can place in a package:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Cursors</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Variables (scalars, records, tables, etc.) and constants</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Exception names and PRAGMAs for associating an error number with an exception</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>PL /SQL table and record TYPE statements</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Procedures and functions</P
></LI
></UL
><P
CLASS="para"
>Packages are among the least understood and most underutilized features of    PL /SQL. That's a shame, because the package structure is also one of the most useful constructs for building well-designed PL /SQL-based applications. Packages provide a structure in which you can organize your modules and other PL /SQL elements. They encourage proper structured programming techniques in an environment that often befuddles the implementation of structured programming. When you place a program unit into a package, you automatically create a "context" for that program. By collecting related PL /SQL elements in a package, you express that relationship <EM
CLASS="emphasis"
>in the very structure of the code itself</EM
>. Packages are often called "the poor man's objects" because they support some, but not all, object-oriented rules.</P
><P
CLASS="para"
>The PL /SQL package is a deceptively simple yet powerful construct. It consists of up to two distinct parts: the specification and the body. The <EM
CLASS="emphasis"
>package specification</EM
> <A
CLASS="indexterm"
NAME="ch01-idx-10270-0"
></A
>defines the public interface or API (Application Programming Interface) of the package: those elements that can be referenced outside of the package. The <EM
CLASS="emphasis"
>package body</EM
><A
CLASS="indexterm"
NAME="ch01-idx-10271-0"
></A
> contains the implementation of the package. In just a few hours you can learn the basic elements of package syntax and rules; there's not all that much to it. You can spend weeks and months, however, uncovering all the nuances and implications of the package structure. </P
><P
CLASS="para"
>Of course, if you are working with built-in packages, you can leave those details to Oracle. You just have to figure out how to make the best use of the packages provided.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.2"
>1.3.2 Controlling Access with Packages</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10272-0"
></A
>Probably the most important implication of package structure is how the builder of the package has complete control over what you can see or do. The users of a package can do either of the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Execute programs listed in the package specification</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Reference elements (variables, constants, exceptions, etc.) listed in the package specification</P
></LI
></UL
><P
CLASS="para"
>What <EM
CLASS="emphasis"
>can't</EM
> a user of a package do? You can't look inside the package and see how the code was implemented. You can't bypass the programs in the package specification in order to modify (corrupt) data structures managed <EM
CLASS="emphasis"
>inside</EM
> the package body. </P
><P
CLASS="para"
>These restrictions are closely tied to the power and usefulness of the package structure. To illustrate this point, consider the following simple timer package. First, the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE tmr
IS
   PROCEDURE capture;
   PROCEDURE show_elapsed;
END tmr;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The tmr.capture procedure captures the current time. The tmr.show_elapsed procedure shows the elapsed time. The following script, for example, displays the amount of time it takes to run the calc_totals procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   tmr.capture;
   calc_totals;
   tmr.show_elapsed;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now let's take a look at the package body (where all the code for those two procedures resides):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE BODY tmr
IS
   last_timing NUMBER := NULL;

   PROCEDURE capture IS
   BEGIN
      last_timing := DBMS_UTILITY.GET_TIME;
   END;

   PROCEDURE show_elapsed IS
   BEGIN
      DBMS_OUTPUT.PUT_LINE (DBMS_UTILITY.GET_TIME - last_timing);
   END;
END tmr;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The DBMS_UTILITY.GET_TIME program is a function from the built-in package, DBMS_UTILITY, which returns the number of hundredths of seconds that have elapsed since an arbitrary point in time. DBMS_OUTPUT is another built-in package; its PUT_LINE procedure displays output from a PL /SQL program to your screen. </P
><P
CLASS="para"
>Notice that there is another code element defined inside the package body besides the capture and show_elapsed procedures: the last_timing variable. This variable holds the timing value from the last call to tmr.capture. Since last_timing does not appear in the package specification, an external program (i.e., one that is not defined in this package) cannot directly reference that variable. This restriction is illustrated in the Booch diagram[<A
CLASS="footnote"
HREF="#ch01-pgfId-6135"
>2</A
>] <A
CLASS="xref"
HREF="ch01_03.htm#ch01-SECT-3.5"
>Figure 1.1</A
>.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-6135"
>[2]</A
> This diagram is named after Grady Booch, who pioneered many of the ideas of the package, particularly in the context of object-oriented design.</P
></DIV
></BLOCKQUOTE
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch01-34271"
>Figure 1.1: Booch diagram of tmr package</A
></H4
><IMG
CLASS="graphic"
SRC="figs/obip.0101.gif"
ALT="Figure 1.1"><P
CLASS="para"
>So if I try to access the last_timing variable from outside the tmr package, I get an error. This is shown as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec tmr.last_timing := 100;
begin tmr.last_timing := 100; end;
*
ERROR at line 1:
ORA-06550: line 1, column 14:
PLS-00302: component 'LAST_TIMING' must be declared</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Why should you or anyone else care about where you define the last_timing variable? Because it illustrates a critical aspect of a package's value: integrity. If I had placed the variable in the specification, then a user of the package could write over the value of last_timing&nbsp;-- and completely invalidate the integrity of the package. Suppose my package specification looked like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE tmr
IS
   last_timing NUMBER;
   PROCEDURE capture;
   PROCEDURE show_elapsed;
END tmr;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The package compiles and seems to work as before. But consider the following rewrite of my script to time the calc_totals procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   tmr.capture;
   calc_totals;

   tmr.last_timing := DBMS_UTILITY.GET_TIME;

   tmr.show_elapsed;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since tmr.last_timing is now in the package specification, this code will compile, and completely subvert the usefulness of the tmr package. For no matter how much time calc_totals actually takes to execute, the tmr.show_elapsed procedure will always display 0&nbsp;-- or <EM
CLASS="emphasis"
>very</EM
> close to 0&nbsp;-- hundredths of seconds for elapsed time. </P
><P
CLASS="para"
>If, on the other hand, I keep last_timing inside the body of the package, only the tmr.capture procedure can modify its value. A user of tmr is, therefore, guaranteed to get dependable results.</P
><P
CLASS="para"
>This absolute control is the reason that the package structure has been so useful to Oracle Corporation&nbsp;-- and one of the reasons the company has constructed dozens of built-in packages. Since you can perform only the operations and access the data structures listed in the package specification, Oracle can make technology available in a highly controlled fashion. As long as <EM
CLASS="emphasis"
>its</EM
> developers write their code properly, there will never be any danger that we can disrupt Oracle Server internals by calling built-in packaged <A
CLASS="indexterm"
NAME="ch01-idx-10274-0"
></A
>functionality.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.3"
>1.3.3 Referencing Built-in Package Elements</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10280-0"
></A
>As noted earlier, a package can have up to two parts: the specification and the body. When it comes to built-in packages, you really don't need to concern yourself with the package body. That is the <EM
CLASS="emphasis"
>implementation</EM
> of the package, and something that is the responsibility of Oracle Corporation. With very few exceptions, those package bodies are "<A
CLASS="indexterm"
NAME="ch01-idx-10284-0"
></A
>wrapped," which means that they are distributed in an encrypted format that you cannot read. This is just as well, because what you really need to do is study the specification to learn about the capabilities offered in that package. </P
><P
CLASS="para"
>There are two ways to use a built-in package in your own code:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Run a<A
CLASS="indexterm"
NAME="ch01-idx-10295-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10295-1"
></A
> function or <A
CLASS="indexterm"
NAME="ch01-idx-10299-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10299-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10299-2"
></A
>procedure defined in the package specification.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Reference a <A
CLASS="indexterm"
NAME="ch01-idx-10286-0"
></A
>nonprogram element defined in the package specification.</P
></LI
></OL
><P
CLASS="para"
>Notice that you never actually execute a package itself. The package is simply a "container" for the various code elements defined in the package. Let's take a look at an example to make all this very clear. The DBMS_SQL package (examined at great length in <A
CLASS="xref"
HREF="ch02_01.htm"
>Chapter 2</A
>) allows you to execute dynamic SQL (SQL statements constructed at runtime), a feature previously unavailable in the PL /SQL language. Here is a portion of the specification of that package:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PACKAGE DBMS_SQL 
IS
  --  CONSTANTS
  --
  v6 constant integer := 0;
  native constant integer := 1;
  v7 constant integer := 2;
  --
  --  PROCEDURES AND FUNCTIONS
  --
  FUNCTION open_cursor RETURN INTEGER;

  PROCEDURE parse
     (c IN INTEGER, 
      statement IN VARCHAR2, 
      language_flag IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>What this tells you is that there are three different constants, one procedure, and one function defined in the package. (There is actually much, much more, of course, but this is all we need to get the point across.) To reference any of the elements, you will use the same "<A
CLASS="indexterm"
NAME="ch01-idx-10303-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10303-1"
></A
>dot notation" used to specify columns in tables. </P
><P
CLASS="para"
>So if I want to open a dynamic cursor, I use this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   dyncur PLS_INTEGER;
BEGIN
   dyncur := DBMS_SQL.OPEN_CURSOR;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And if I want to parse a string using the "native" database method, I would write the following code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE showemps (where_in IN VARCHAR2)
IS
   dyncur PLS_INTEGER := DBMS_SQL.OPEN_CURSOR;
BEGIN
   DBMS_SQL.PARSE (dyncur, 
      'SELECT ename FROM emp WHERE ' || NVL (where_in, '1=1'),
      DBMS_SQL.NATIVE);
   ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this case, I have qualified my references to the OPEN_CURSOR, PARSE, and NATIVE elements of the DBMS_SQL <A
CLASS="indexterm"
NAME="ch01-idx-10305-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10305-1"
></A
>package. The first two instances are programs (a <A
CLASS="indexterm"
NAME="ch01-idx-10297-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10297-1"
></A
>function and a <A
CLASS="indexterm"
NAME="ch01-idx-10301-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10301-1"
></A
>procedure). The third instance is a <A
CLASS="indexterm"
NAME="ch01-idx-10293-0"
></A
>constant, passed as the third argument in my call to <A
CLASS="indexterm"
NAME="ch01-idx-10282-0"
></A
>DBMS_SQL.PARSE.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-18126"
>1.3.4 Exception Handling and Built-in Packages</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10307-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10307-1"
></A
>Programs in built-in packages can raise exceptions. You will often want to write code to check for and handle these exceptions. You should know about the different ways that exceptions can be defined and raised by programs in the built-in packages. This will affect the way you write your exception handlers.</P
><P
CLASS="para"
>At the beginning of each package's coverage, you will find a description of the exceptions defined within that package. Within the documentation of many of the programs within a package, you will also find an explanation of the specific exceptions that may be raised by those individual programs. When references are made to named exceptions in these explanations, they will appear in one of two forms:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE.exception_name</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>exception_name</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the exception name is unqualified (i.e., no package name appears before the exception name), then this exception is defined either:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In the package currently under discussion, or </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In the STANDARD package; examples are VALUE_ERROR and NO_DATA_FOUND.</P
></LI
></UL
><P
CLASS="para"
>In this section, I will review the four types of exceptions you may encounter when working with built-in packages. I will then show you the kind of code you will need to write to handle exceptions properly when they propagate out from built-in packages. The following sections demonstrate how to write code to work with these different types of exceptions.</P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch01_03.htm#ch01-SECT-3.5"
>Table 1.2</A
> summarizes these types.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch01-18771"
>Table 1.2: Types of Exceptions </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Type</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>How Exception Is Defined </P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>How Exception Is Raised </P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10340-0"
></A
>SQLCODE Behavior</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10341-0"
></A
>SQLERRM Behavior</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>How to Handle Exception</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Package-named system <A
CLASS="indexterm"
NAME="ch01-idx-10316-0"
></A
>exception</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The package gives a name to a specific Oracle error number using the PRAGMA EXCEPTION_INIT statement.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The packaged program issues a RAISE statement.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the Oracle error number.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the standard Oracle error message text.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You can handle it by number within a WHEN OTHERS clause, or by name with its own exception handler; the latter improves the readability of your code.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Package-defined <A
CLASS="indexterm"
NAME="ch01-idx-10326-0"
></A
>exception</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The package declares one or more exceptions; these exceptions have names, but no message text and no unique number.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The packaged program RAISEs that exception by name.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns 1.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns "Unhandled user-defined exception" message.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You can only handle it by name or with a WHEN OTHERS clause, in which case it is impossible to tell which exception was raised.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Standard system <A
CLASS="indexterm"
NAME="ch01-idx-10332-0"
></A
>exception</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>It is previously given a name in the STANDARD package or it is simply an error number.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The packaged program issues a RAISE statement.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the Oracle error number.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the standard Oracle error message text.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You can handle it by name in its own exception handler, if a name has been associated with that error number. Otherwise, you handle the exception by number in a WHEN OTHERS clause.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Package-specific <A
CLASS="indexterm"
NAME="ch01-idx-10338-0"
></A
>exception</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>In this case, Oracle has rudely appropriated for itself one or more of the application-specific error numbers between -20,999 and -20,000 set aside for customers.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The packaged program calls RAISE_APPLICATION_ERROR.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the number in the -20NNN range.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the message text provided in the call to RAISE_APPLICATION_ERROR.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You can handle these exceptions by number within a WHEN OTHERS clause.</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.4.1"
>1.3.4.1 <A
CLASS="indexterm"
NAME="ch01-idx-10342-0"
></A
>Package-named system exception</A
></H4
><P
CLASS="para"
>In this scenario, the package gives a name to a specific Oracle error number using the PRAGMA EXCEPTION_INIT statement. You can then handle the exception by name with its own exception handler or by number within a <A
CLASS="indexterm"
NAME="ch01-idx-10355-0"
></A
>WHEN OTHERS clause. Let's look at an example.</P
><P
CLASS="para"
>The DBMS_DEFER package associates names with a number of Oracle errors. Here is an example of one such association:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>updateconflict EXCEPTION;
PRAGMA EXCEPTION_INIT (updateconflict, -23303);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If a program in DBMS_DEFER raises this exception, you can handle it in either of the following ways:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN DBMS_DEFER.UPDATECONFLICT
   THEN
      /* SQLCODE returns -23303 and SQLERRM returns the standard 
         Oracle error message */</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;EXCEPTION
   WHEN OTHERS
   THEN
      IF SQLCODE = -23303
      THEN
         /* SQLERRM returns the standard Oracle error message */</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> You will not be able to write a statement like WHEN DBMS_DEFER.UPDATECONFLICT in the Oracle Developer/2000 Release 1 environment. See <A
CLASS="xref"
HREF="ch01_03.htm#ch01-SECT-3.5"
>Section 1.3.6, "Calling Built-in Packaged Code from Oracle Developer/2000 Release 1"</A
>"  for more information on this <A
CLASS="indexterm"
NAME="ch01-idx-10344-0"
></A
>restriction.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.4.2"
>1.3.4.2 <A
CLASS="indexterm"
NAME="ch01-idx-10346-0"
></A
>Package-defined exception</A
></H4
><P
CLASS="para"
>In this scenario, the package declares one or more exceptions by name only; these exceptions do not have message text or a unique number associated with them. When this exception has been raised, SQLCODE will always return 1 and SQLERRM will always return the "Unhandled user-defined exception" message. As a consequence, you have two basic options for handling these exceptions:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You handle by name; write an exception handler that references the packaged exception by name.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You rely on the <A
CLASS="indexterm"
NAME="ch01-idx-10350-0"
></A
>WHEN OTHERS clause, in which case there is no way for you to know precisely which exception was raised.</P
></LI
></UL
><P
CLASS="para"
>Let's look at the UTL_FILE package for an example. The following exceptions are defined in the package specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE UTL_FILE   
IS
   invalid_path EXCEPTION;
   invalid_mode EXCEPTION;
   invalid_filehandle EXCEPTION;
   invalid_operation EXCEPTION;
   read_error EXCEPTION;
   write_error EXCEPTION;
   internal_error EXCEPTION;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The UTL_FILE.FOPEN function can raise the INVALID_MODE, INVALID_OPERATION, or INVALID_PATH exceptions. I can write an exception section for a program using UTL_FILE.FOPEN in one of two ways:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE my_program
IS
   fid UTL_FILE.FILE_TYPE;
BEGIN
   fid := UTL_FILE.FOPEN ('/tmp', 'myfile.txt', 'R');
   ...
EXCEPTION
   WHEN UTL_FILE.INVALID_OPERATION
   THEN
      ...
   WHEN UTL_FILE.INVALID_MODE
   THEN
      ...
   WHEN UTL_FILE.INVALID_PATH
   THEN
      ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE my_program
IS
   fid UTL_FILE.FILE_TYPE;
BEGIN
   fid := UTL_FILE.FOPEN ('/tmp', 'myfile.txt', 'R');
   ...
EXCEPTION
   WHEN OTHERS /* Not recommended! Information is lost... */
   THEN
      ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When working with this kind of exception, always use the first approach. With the WHEN OTHERS clause, there is no way for you to know <EM
CLASS="emphasis"
>which</EM
> of the three UTL_FILE exceptions was raised. SQLCODE returns the same value of 1 regardless of the specific exception raised.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> You will not be able to write a statement like WHEN UTL_FILE.INVALID_MODE in the Oracle Developer/2000 Release 1 environment. See <A
CLASS="xref"
HREF="ch01_03.htm#ch01-SECT-3.5"
>Section 1.3.6</A
>" for more information on this <A
CLASS="indexterm"
NAME="ch01-idx-10348-0"
></A
>restriction.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.4.3"
>1.3.4.3 <A
CLASS="indexterm"
NAME="ch01-idx-10351-0"
></A
>Standard system exception</A
></H4
><P
CLASS="para"
>In this scenario, the package does not contain any statements that define new exceptions, nor does it give names to existing Oracle error numbers. Instead, a program in the package simply raises one of the errors defined in the Oracle documentation. You can then handle this exception by its name (if there is one) or by its number within a <A
CLASS="indexterm"
NAME="ch01-idx-10356-0"
></A
>WHEN OTHERS clause. Let's look at an example.</P
><P
CLASS="para"
>The UTL_FILE.GET LINE procedure raises the NO_DATA_FOUND exception (ORA-01403, but SQLCODE actually returns a value of 100) if you try to read past the end of a file. You can handle this error in either of the following ways:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
  WHEN NO_DATA_FOUND
  THEN
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN OTHERS
   THEN
      IF SQLCODE = 100
      THEN
         /* SQLERRM returns the standard Oracle error message */
         ...
END;     </PRE
></BLOCKQUOTE
><P
CLASS="para"
>Of course, if you need to handle an exception that does not have a name associated with it, you can only rely on the WHEN OTHERS clause and an IF statement with SQLCODE to handle that error <A
CLASS="indexterm"
NAME="ch01-idx-10353-0"
></A
>specifically.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.4.4"
>1.3.4.4 <A
CLASS="indexterm"
NAME="ch01-idx-10357-0"
></A
>Package-specific exception</A
></H4
><P
CLASS="para"
>In some packages, Oracle developers decided to appropriate for their own use error numbers in the range set aside by Oracle Corporation for customer use       (-20999 through -20000). This is very poor practice, as it can cause conflicts with your ownuse of these values. Unfortunately, it does happen and you need to know what to do about it.</P
><P
CLASS="para"
>For example, the DBMS_OUTPUT package uses the -20000 error number to communicate back to the calling program either one of these errors:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORU-10027: buffer overflow, limit of &lt;buf_limit&gt; bytes.
ORU-10028: line length overflow, limit of 255 bytes per line.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is a attempt to call DBMS_OUTPUT.PUT_LINE that raises an unhandled exception in a SQL*Plus session:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec dbms_output.put_line (rpad ('abc', 300, 'def'))
*
ERROR at line 1:
ORA-20000: ORU-10028: line length overflow, limit of 255 bytes per line
ORA-06512: at &quot;SYS.DBMS_OUTPUT&quot;, line 99
ORA-06512: at &quot;SYS.DBMS_OUTPUT&quot;, line 65
ORA-06512: at line 1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I can handle this error if I call the built-in procedure from within a PL /SQL block as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: myput.sp /*
CREATE OR REPLACE PROCEDURE myput (str IN VARCHAR2)
IS
BEGIN
   DBMS_OUTPUT.PUT_LINE (str);
EXCEPTION
   WHEN OTHERS
   THEN 
      IF SQLCODE = -20000 
      THEN 
         IF SQLERRM LIKE '%ORU-10027%'
         THEN            
            DBMS_OUTPUT.ENABLE (1000000);
            myput (str);

         ELSIF SQLERRM LIKE '%ORU-10028%'
         THEN   
            myput (SUBSTR (str, 1, 255));
            myput (SUBSTR (str, 256));
         END IF;
      END IF;
END;
/
</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The myput procedure implements the following logic: try to display the string. If an exception is raised, check to see if it is a -20000 error. If so, see if the error message indicates that it is a "buffer too small" error. If so, expand the buffer to the maximum size and try again to display the string. If the error message indicates a "string too long" error, display the first 255 bytes and then call myput again recursively to display the rest of the <A
CLASS="indexterm"
NAME="ch01-idx-10359-0"
></A
>string. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.4.5"
>1.3.4.5 Same exception, different causes</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-11613-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-11613-1"
></A
>One interesting situation you may run into when working with some of the built-in packages is that the same exception can be raised from different circumstances. Specifically, the NO_DATA_FOUND exception is raised by the PL /SQL runtime engine under any of these conditions:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You execute a SELECT INTO query (an implicit cursor) that does not identify any rows.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You attempt to access a row in a PL /SQL or index-by table that is not yet defined.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You try to read past the end of a file using UTL_FILE.GET_LINE.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You read past the end of a large object with DBMS_LOB.READ.</P
></LI
></UL
><P
CLASS="para"
>If you are writing code that could raise NO_DATA_FOUND for different reasons, you may not be able to get by with a single exception handler like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      /* ?? What caused the problem? */
      ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You will want to know in the exception handler whether the problem was that the query returned no rows, or you read past the end of the file, or you tried to access an undefined row in an index-by table, or something else. If you face this problem, you may want to use a technique I call <EM
CLASS="emphasis"
>exception aliasing</EM
><A
CLASS="indexterm"
NAME="ch01-idx-10366-0"
></A
>. Consider the very short program below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE just_a_demo
   (file IN UTL_FILE.FILE_TYPE, empno_in IN emp.empno%TYPE)
IS
   line VARCHAR2(1000);
   end_of_file EXCEPTION;
   v_ename emp.ename%TYPE;
BEGIN
   SELECT ename
     INTO v_ename
     FROM emp
    WHERE empno = empno_in;

   BEGIN
      UTL_FILE.GET_LINE (file, line);
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RAISE end_of_file;
   END;
EXCEPTION
   WHEN end_of_file
   THEN
      DBMS_OUTPUT.PUT_LINE ('Read past end of file!');

   WHEN NO_DATA_FOUND
   THEN
      DBMS_OUTPUT.PUT_LINE 
         ('No employee found for ' || TO_CHAR (empno_in));
END:
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I have embedded the call to UTL_FILE.GET_LINE inside its own block. If that program reads past the end of a file and raises NO_DATA_FOUND, that block's exception section "translates" NO_DATA_FOUND into another, distinct exception: end_of_file (declared in the procedure itself ). The exception section of the procedure as a whole can then distinguish between the  <EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch01-idx-10368-0"
></A
>two <A
CLASS="indexterm"
NAME="ch01-idx-10364-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10364-1"
></A
>different NO_DATA_FOUND <A
CLASS="indexterm"
NAME="ch01-idx-10309-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10309-1"
></A
>scenarios.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.5"
>1.3.5 Encapsulating Access to the Built-in Packages</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10370-0"
></A
>You will discover (both through reading this book and through your own experience) that there are many reasons to avoid directly accessing built-in packaged functionality. In a number of cases, you will want to build your own package <EM
CLASS="emphasis"
>on top of</EM
> the built-in package. This process is usually referred to as <EM
CLASS="emphasis"
>encapsulation</EM
>.</P
><P
CLASS="para"
>Why would you bother with an encapsulation package? Any of the following reasons will do:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The built-in packages offer lots of interesting technology, but they are not always very easy to use. You can hide the complexity, or in some cases, the poor design, and make it much easier for yourself and others to reap the benefits. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Some of the packages contain programs that you would not want to make generally or widely available. Conversely, other programs in that same package might be very useful for the "general public." An encapsulation package can offer only those programs that <EM
CLASS="emphasis"
>should</EM
> be available, while hiding the others. (In this case, you will want to revoke any EXECUTE privileges on the underlying package.)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Write less code. Have you ever noticed the really impressive lengths of the names of Oracle built-in packages and their programs? Studies conducted by the <A
CLASS="indexterm"
NAME="ch01-idx-10371-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10371-1"
></A
>Institute for Study Conduction estimate that by the year 2000, developers using PL /SQL will have experienced a $150 trillion loss in productivity due to having to type names like DBMS_DESCRIBE.DESCRIBE_PROCEDURE. Your encapsulations can use shorter names and thereby erase the federal deficit.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Take full advantage of built-in packages from Oracle Developer/2000 Release 1. As you will read in the next section, there are many restrictions on accessing stored code from products like Oracle Forms. Encapsulation can help you work around these restrictions.</P
></LI
></UL
><P
CLASS="para"
>Roughly speaking, there are two types of encapsulation to consider when working with the built-in packages:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><A
CLASS="indexterm"
NAME="ch01-idx-10372-0"
></A
>Extension encapsulation</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This is the most common type of encapsulation for built-in packages. In this case, you provide one or more programs that <EM
CLASS="emphasis"
>extend</EM
> the functionality or usability of the underlying package. </P
></DD
><DT
CLASS="term"
><A
CLASS="indexterm"
NAME="ch01-idx-10373-0"
></A
>Covering encapsulation</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>When you create a cover for a built-in package, you create a package with a specification that matches that of the built-in package (same program names, same parameter lists). You can even give your package the same name as the built-in package, but you install it in a schema other than SYS. </P
><P
CLASS="para"
>When you revoke EXECUTE authority on the built-in package and grant EXECUTE authority on your package, users of the built-in package will automatically be directed to your replacement. Oracle recommends this technique, for example, with the DBMS_APPLICATION_INFO package. </P
></DD
></DL
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.5.1"
>1.3.5.1 Examples of encapsulation packages</A
></H4
><P
CLASS="para"
>This book (and the accompanying disk) contains many packages that encapsulate or cover an underlying built-in package (or, in some cases, a subset of the package). <A
CLASS="xref"
HREF="ch01_03.htm#ch01-SECT-3.5"
>Table 1.3</A
> shows the <A
CLASS="indexterm"
NAME="ch01-idx-10380-0"
></A
>encapsulation packages in the book.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch01-13710"
>Table 1.3: Encapsulation Packages for Built-ins </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Built-in Package/</P
><P
CLASS="para"
>Program</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Encapsulation </P
><P
CLASS="para"
>Package Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>File </P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_AQ</P
><P
CLASS="para"
>DBMS_AQADM</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10384-0"
></A
>aq</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>aq.spp</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Hides details of creating, starting, stopping, and dropping queues and queue tables. The package allows you to write less code and also handles common errors.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_APPLICATION_</P
><P
CLASS="para"
>INFO</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10385-0"
></A
>register_app</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>register.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Allows developers to easily register applications and track resource usage statistics.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_APPLICATION_</P
><P
CLASS="para"
>INFO.SET_SESSION_</P
><P
CLASS="para"
>LONGOPS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10386-0"
></A
>longops</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>longops.sql</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Simplifies use of this difficult procedure.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_UTILITY.</P
><P
CLASS="para"
>GET_PARAMETER_</P
><P
CLASS="para"
>VALUE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10387-0"
></A
>dbparm</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>dbparm.spp</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Makes it easier to obtain specific initialization values from the database instance.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_UTILITY.</P
><P
CLASS="para"
>DB_VERSION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10388-0"
></A
>db</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>dbver.spp</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Converts through encapsulation the DB_VERSION procedure into two separate functions, so you can ask for the version or the compatibility value, as desired.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_SQL.</P
><P
CLASS="para"
>DESCRIBE_</P
><P
CLASS="para"
>COLUMNS</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10389-0"
></A
>desccols</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>desccols.spp</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Provides a general, flexible interface to DBMS_SQL.DESCRIBE_COLUMNS so you don't need to declare PL /SQL tables and call that wordy built-in procedure to obtain the column information.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_SQL.PARSE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10390-0"
></A
>dynconst</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>dynconst.spp</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Hides the need to provide a DBMS_SQL database mode when you parse a SQL statement. This technique is especially useful when you are writing code in Oracle Developer/2000 Release 1. (See the next section for details.) </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_DESCRIBE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10391-0"
></A
>psdesc</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>psdesc.spp</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Hides the need to declare a dozen different PL /SQL tables just so you can use DBMS_DESCRIBE.</P
><P
CLASS="para"
>DESCRIBE_PROCEDURE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_IJOB.REMOVE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10392-0"
></A
>remove_all_jobs </P
><P
CLASS="para"
>(procedure)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>job3.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Allows the DBA to remove all jobs regardless of owner.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_LOCK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10393-0"
></A
>dblock</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>dblock.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Simplifies the use of user-named locks, as well as maximizing their efficiency.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_IJOB.BROKEN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10394-0"
></A
>break_all_jobs </P
><P
CLASS="para"
>(procedure)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>job3.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Allows the DBA to set the broken flag in all jobs regardless of owner.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_PIPE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10395-0"
></A
>dbpipe</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>dbpipe.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Provides some useful and interesting pipe utilities, including generic message pack/unpack and message forwarding. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_SESSION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10396-0"
></A
>my_session</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>mysess.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Simplifies use of some of the programs and adds some additional conveniences.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_SHARED_POOL.</P
><P
CLASS="para"
>KEEP</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10397-0"
></A
>object_keeper</P
><P
CLASS="para"
> (procedure)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>keeper.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Allows configurable auto-keeping of packages in database startup scripts.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_SPACE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10398-0"
></A
>segspace</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>segspace.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Transforms the unwieldy procedure calls into simple, SQL-callable functions.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_SYSTEM.</P
><P
CLASS="para"
>SET_SQL_TRACE_</P
><P
CLASS="para"
>IN_SESSION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10399-0"
></A
>trace</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><EM
CLASS="emphasis"
>trace.sql</EM
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Allows the DBA to set SQL tracing on or off in other sessions by username or <A
CLASS="indexterm"
NAME="ch01-idx-10382-0"
></A
>session  <A
CLASS="indexterm"
NAME="ch01-idx-10379-0"
></A
>id.</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-29306"
>1.3.6 Calling Built-in Packaged Code from Oracle Developer/2000 Release 1</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10400-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10400-1"
></A
>If you use Oracle Developer/2000 Release 1 to build your client-side application, you can use the built-in packages, but you should be aware of the following restrictions:[<A
CLASS="footnote"
HREF="#ch01-pgfId-5991"
>3</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-5991"
>[3]</A
> These restrictions are not likely to affect you when you work with Oracle Developer/2000 Release 2 or above.</P
></DIV
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You can reference only packaged procedures and functions. You cannot, for example, make reference in your client-side code to DBMS_SQL.NATIVE (a constant) or UTL_FILE.INVALID_OPERATION (an exception).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You must supply a value for each argument in a packaged procedure or function. You cannot rely on default values in the headers of those programs. This is true even if those default values do not reference elements in the built-in packages (in other words, are literal values).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You must be connected to the Oracle database before you can compile program units that reference built-in packages. While it is possible to work on your client-side module without connecting to Oracle, the PL /SQL compiler cannot resolve references to server-side objects like built-in packages unless you are connected.</P
></LI
></UL
><P
CLASS="para"
>The following sections explore these restrictions in more detail and suggest work-arounds for making full use of the built-in packages from within products like Oracle Forms and Oracle Reports.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.6.1"
>1.3.6.1 Referencing packaged constants and variables</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10404-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10404-1"
></A
>Consider the DBMS_SQL.PARSE procedure. Here is the header for this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.PARSE
  (c IN INTEGER,
   statement IN VARCHAR2,
   language_flag IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The third argument, language_flag, can be any of the following values, as defined by constants in the DBMS_SQL specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.V6
DBMS_SQL.V7
DBMS_SQL.NATIVE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now, if you try to execute this program in an Oracle Forms program unit, as in the following,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SQL.PARSE (cur, 'SELECT ...', DBMS_SQL.NATIVE);
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>you will receive this error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Error 302: component NATIVE must be declared</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Oracle Forms simply does not know how to interpret anything but procedures and functions in stored packages. So what's a developer to do? You have several options:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Find out the literal value <EM
CLASS="emphasis"
>behind</EM
> the named constant and use that, or</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Create a stored function that encapsulates the constant and call that, or</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Create a stored procedure that calls DBMS_SQL.PARSE and hides the use of the constant.</P
></LI
></UL
><P
CLASS="para"
>The first option would result in code like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SQL.PARSE (cur, 'SELECT ...', 1);
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I suggest that you do not take this approach. You are always better off not proliferating the use of literals like this one in your code. They are hard to understand and leave you vulnerable to errors caused by changes in the way that DBMS_SQL behaves.</P
><P
CLASS="para"
>The second option (encapsulating the constant inside a function) is better. I could, for example, create a tiny package as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch01-idx-10408-0"
></A
>dynconst.spp */*
CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch01-idx-10409-0"
></A
>dynsql_value
IS
    FUNCTION v6 RETURN INTEGER;
    FUNCTION v7 RETURN INTEGER;
    FUNCTION native RETURN INTEGER;
END;
/
CREATE OR REPLACE PACKAGE BODY dynsql_value
IS
    FUNCTION v6 RETURN INTEGER
       IS BEGIN RETURN DBMS_SQL.V6; END;

    FUNCTION v7 RETURN INTEGER
       IS BEGIN RETURN DBMS_SQL.V7; END;

    FUNCTION native RETURN INTEGER
       IS BEGIN RETURN DBMS_SQL.NATIVE; END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With this code in place on the server, I can then call DBMS_SQL.PARSE as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   DBMS_SQL.PARSE (cur, 'SELECT ...', dynsql_value.native);
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This code is almost identical to my first example, but I am calling a function rather than referencing a literal, and that makes all the difference. </P
><P
CLASS="para"
>The third option, encapsulating the call to DBMS_SQL.PARSE, is perhaps the optimal solution. Why should you even have to bother passing the database mode? You might as well just always make it "native." Here is some code that hides this argument entirely:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>*Filename on companion disk: <A
CLASS="indexterm"
NAME="ch01-idx-10410-0"
></A
>dynconst.spp */
CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch01-idx-10411-0"
></A
>dynsql_value
IS
   PROCEDURE parse (cur IN INTEGER, sql_str IN VARCHAR2);
END;
/
CREATE OR REPLACE PACKAGE BODY dynsql_value
IS
   PROCEDURE parse (cur IN INTEGER, sql_str IN VARCHAR2)
   IS
   BEGIN
      DBMS_SQL.PARSE (cur, sql_str, DBMS_SQL.NATIVE)
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now I can parse a SQL statement from within Oracle Forms as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   dynsql_value.parse (cur, 'SELECT ...');
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I recommend this last technique, because you will inevitably find other workaround needs having to do with DBMS_SQL or another built-in package. Why not collect them all together in a single encapsulator package? This point is driven home in the next <A
CLASS="indexterm"
NAME="ch01-idx-10406-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10406-1"
></A
>section.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.6.2"
>1.3.6.2 Handling exceptions in Oracle Developer/2000 Release 1</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10416-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10416-1"
></A
>An earlier section in this chapter ("Exception Handling and Built-in Packages") explored the different types of exceptions that can be raised from within built-in packages. One type in particular, the <A
CLASS="indexterm"
NAME="ch01-idx-10421-0"
></A
>package-specific exception, presents a challenge to Oracle Developer/2000 programmers.</P
><P
CLASS="para"
>Consider once again the UTL_FILE package. It declares a number of exceptions and, as noted previously, the only way to handle those exceptions (and know which exception was raised) is to create an explicit exception handler, as in:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN UTL_FILE.INVALID_MODE
   THEN
      ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Unfortunately, you cannot write this kind of code from Oracle Forms. It cannot resolve the reference to UTL_FILE.INVALID_MODE. What can you do? If you are going to make extensive use of UTL_FILE from Oracle Forms (or Oracle Reports), and you want to build in some robust error handling, you should probably consider building a wrapper package around UTL_FILE. </P
><P
CLASS="para"
>Instead of calling UTL_FILE.FOPEN directly, for example, and risk raising an exception you cannot interpret accurately, you might want to consider something like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch01-idx-10422-0"
></A
>myfile.spp */
CREATE OR REPLACE PACKAGE <A
CLASS="indexterm"
NAME="ch01-idx-10423-0"
></A
>myfile
IS
   /* Document in the package specification that:
      - INVALID_MODE is returned as -20100.
      - INVALID_PATH is returned as -20101.
      - INVALID_OPERATION is returned as -20102.
   */
   PROCEDURE fopen 
     (loc IN VARCHAR2, file IN VARCHAR2, fmode IN VARCHAR2);
END;
/
CREATE OR REPLACE PACKAGE BODY myfile
IS
   g_file UTL_FILE.FILE_TYPE;

   PROCEDURE fopen 
     (loc IN VARCHAR2, file IN VARCHAR2, fmode IN VARCHAR2)
   IS
   BEGIN
      g_file := UTL_FILE.FOPEN (loc, file, fmode);
   EXCEPTION
      WHEN UTL_FILE.INVALID_MODE
      THEN
         RAISE_APPLICATION_ERROR (-20100, 'Invalid mode ' || fmode);

      WHEN UTL_FILE.INVALID_PATH
      THEN
         RAISE_APPLICATION_ERROR (-20101, 'Invalid path ' || loc);

      WHEN UTL_FILE.INVALID_MODE
      THEN
         RAISE_APPLICATION_ERROR (-20102, 'Invalid operation);

   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I accomplish two things with this prototype package:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>I translate the package-specific exceptions to -20NNN exceptions. Therefore, my UTL_FILE exception now has a number. I can check for that number within my client-side application and take appropriate action.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I hide the UTL_FILE.FILE_TYPE record. From Oracle Forms, I cannot even declare a record of this type (it is not a program, so UTL_FILE.FILE_TYPE cannot be referenced from within Oracle Developer/2000 Release 1). </P
></LI
></OL
><P
CLASS="para"
>With this wrapper approach, you can build a package that allows you to read and write a particular server-side file from Oracle Forms. You would still need to build read, write, and close procedures, but the technique should <A
CLASS="indexterm"
NAME="ch01-idx-10419-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10419-1"
></A
>be <A
CLASS="indexterm"
NAME="ch01-idx-10402-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-10402-1"
></A
>clear.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.7"
>1.3.7 Accessing Built-in Packaged Technology from Within SQL</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10424-0"
></A
>Throughout this book, you will find documentation indicating whether a particular packaged function can be called from within an SQL statement, or whether a packaged procedure can be called by a function that, in turn, is called from within SQL. This section explains the significance of that capability.</P
><P
CLASS="para"
>If you are running a version of Oracle Server 7.1 and beyond, you can call       PL /SQL functions from within SQL statements. (If you are not running at least Oracle Server 7.1, you can skip this section&nbsp;-- but you should also certainly upgrade your database software as soon as possible!) Let's take a look at an example to give you a feel for this capability.</P
><P
CLASS="para"
>Suppose that my formula for calculating total compensation for an employee is "salary plus commission." Here is that formula implemented in PL /SQL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE FUNCTION totcomp
  (sal_in IN NUMBER, comm_in IN NUMBER)
RETURN NUMBER
IS
BEGIN
   RETURN sal_in + NVL (comm_in, 0);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Once this program is stored in the database, I can call it from within a query as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT ename, totcomp (sal, comm) total_compensation FROM emp;

ENAME      TOTAL_COMPENSATION
---------- ------------------
SMITH                     800
...
MILLER                   1300</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can also call a packaged function from within a SQL statement. In this case, however, you must also provide a special statement, the RESTRICT_REFERENCES <A
CLASS="indexterm"
NAME="ch01-idx-10428-0"
></A
>pragma, to enable that function for use inside SQL. Here, for example, is the code you would have to write to place totcomp inside a package and still call it from a query:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PACKAGE empcomp
IS
   FUNCTION totcomp
     (sal_in IN NUMBER, comm_in IN NUMBER)
   RETURN NUMBER;

<B
CLASS="emphasis.bold"
>   PRAGMA RESTRICT_REFERENCES (total, WNDS, RNDS, WNPS, RNPS);</B
>
END;
/
CREATE OR REPLACE PACKAGE BODY empcomp
IS
   FUNCTION totcomp
     (sal_in IN NUMBER, comm_in IN NUMBER)
   RETURN NUMBER
   IS
   BEGIN
      RETURN (sal_in + NVL (comm_in, 0));
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The line in bold is the statement asserting that the empcomp.total function does not violate any of the restrictions on functions in SQL. Here is how you would call this packaged function inside SQL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT ename, empcomp.total (sal, comm) total_comp from emp;

ENAME      TOTAL_COMP
---------- ----------
SMITH             800
...
MILLER           1300</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The same rules apply for built-in packaged programs callable from SQL. Oracle Corporation itself must provide a RESTRICT_REFERENCES pragma in its own package specifications for any procedure or function that is to be used from within SQL. And since Oracle did not pragmatize built-in packages prior to Oracle 7.3.3, you will not be able to call built-in packaged programs from SQL (directly or indirectly) until you install Oracle 7.3.4 or later.</P
><P
CLASS="para"
>If you try to call a packaged function in SQL that does not have such a pragma, you will receive this error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT utl_file.fopen ('/tmp', ename || '.dat', 'R') 
  2    FROM employee;
select utl_file.fopen ('a', 'b', 'r') from employee
       *
ERROR at line 1:
ORA-06571: Function FOPEN does not guarantee not to update database</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Don't you hate those double negatives? </P
><P
CLASS="para"
>You will also encounter this same error if you try to execute a function in SQL that, in turn, calls a packaged procedure that does not have a pragma. For example, the DBMS_JOB.SUBMIT procedure is not "pragma-tized" for use in SQL. Consequently, the following function (exactly the same as that shown earlier, except for the addition of the procedure call) will not be executable within SQL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE FUNCTION totcomp
  (sal_in IN NUMBER, comm_in IN NUMBER)
RETURN NUMBER
IS
   myjob INTEGER;
BEGIN
   DBMS_JOB.SUBMIT (myjob, 'calc_totals;');
   RETURN (sal_in + NVL (comm_in, 0));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the error I get when I try to execute my new and "improved" function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT totcomp (salary, NULL) FROM employee;
SELECT totcomp (salary, NULL) FROM employee
       *
ERROR at line 1:
ORA-06571: Function TOTCOMP does not guarantee not to update database</PRE
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.7.1"
>1.3.7.1 Calling a packaged function in SQL</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10432-0"
></A
>If you want to use a packaged function in a SQL statement, it must have a RESTRICT_REFERENCES pragma. If that is the case, you are all set! Just call the function as you would call a built-in function such as SUBSTR or TO_CHAR. </P
><P
CLASS="para"
>Suppose that I am working on the large objects stored in files. The DBMS_LOB package includes several RESTRICT_REFERENCES pragmas. Here is the pragma for the GETLENGTH function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT_REFERENCES (getlength, WNDS, RNDS, WNPS, RNPS);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are the meanings for each of those <EM
CLASS="emphasis"
>purity levels</EM
><A
CLASS="indexterm"
NAME="ch01-idx-10444-0"
></A
>:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>WNDS</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Writes No Database State. In other words, does not make any changes to database structures by calling an INSERT, UPDATE, or DELETE.</P
></DD
><DT
CLASS="term"
>WNPS</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Writes No Package State. In other words, does not change the values of any package data structures.</P
></DD
><DT
CLASS="term"
>RNDS</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Read No Database State. In other words, does not SELECT from any database tables or other database objects.</P
></DD
><DT
CLASS="term"
>RNPS</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Reads No Package State. In other words, does not reference any package data structures.</P
></DD
></DL
><P
CLASS="para"
>The absolute minimum purity level required to allow a program to be used (directly or indirectly) inside SQL is WNDS. You can <EM
CLASS="emphasis"
>never</EM
> update the database. In some situations, such as when you want to call a function from within a WHERE clause, the program will also need to have asserted the WNPS purity level.</P
><P
CLASS="para"
>Since DBMS_LOB.GETLENGTH asserts all four purity levels, I can use it in SQL, both in the SELECT list of a query and even in the WHERE clause. Here is an example; in it, I display the length of each photograph stored in the archives for my family:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT DBMS_LOB.GETLENGTH (portrait_lob_loc)
  FROM photo_archive
 WHERE family = 'FEUERSTEIN' AND DBMS_LOB.GETLENGTH (portrait_lob_loc) &lt; 1000;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Table 1-4 <A
CLASS="indexterm"
NAME="ch01-idx-10446-0"
></A
>provides a complete list of all packaged programs that can be called (directly or indirectly) from within a SQL statement, the purity levels for each, and the Oracle versions in which these purity levels become available (thus enabling you to call the programs from within SQL). The rest of this section explains how to use packaged functions and procedures, and the meaning of the various purity levels.   </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch01-TABLE-1"
>Table 1.4: Purity Levels for Oracle Built-in Package Programs</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Package</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Program</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>WNDS</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>WNPS</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>RNDS</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>RNPS</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_LOB</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COMPARE<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>FILEEXISTS<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>FILEISOPEN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GETLENGTH</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INSTR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SUBSTR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_OUTPUT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DISABLE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ENABLE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET_LINE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET_LINES<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NEW_LINE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PUT<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PUT_LINE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_PIPE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE_PIPE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NEXT_ITEM_TYPE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PACK_MESSAGE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PACK_MESSAGE_RAW<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PACK_MESSAGE_ROWID<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PURGE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>RECEIVE_MESSAGE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>REMOVE_PIPE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>RESET_BUFFER<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SEND_MESSAGE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UNIQUE_SESSION_NAME<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UNPACK_MESSAGE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UNPACK_MESSAGE_RAW<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UNPACK_MESSAGE_ROWID<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_ROWID</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_BLOCK_NUMBER<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_CREATE<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_INFO<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_OBJECT<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_RELATIVE_FNO<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_ROW_NUMBER<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_TO_ABSOLUTE<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_TO_EXTENDED<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_TO_RESTRICTEDa</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_TYPE<SUP
CLASS="superscript"
>a</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID_VERIFYa</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_SESSION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UNIQUE_SESSION_ID<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_STANDARD</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DELETING<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INSERTING<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>RAISE_APPLICATION_ERROR<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UPDATING<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DBMS_UTILITY</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DATA_BLOCK_ADDRESS_BLOCK<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DATA_BLOCK_ADDRESS_FILE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GET_HASH_VALUE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>MAKE_DATA_BLOCK_ADDRESS<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PORT_STRING<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UTL_RAW</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BIT_AND<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>x</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>x</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>x</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>x</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BIT_COMPLEMENT<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BIT_OR<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BIT_XOR<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CAST_TO_RAW<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COMPARE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CONCAT<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CONVERT<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COPIES<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LENGTH<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>OVERLAY<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>REVERSE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SUBSTR<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRANSLATE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRANSLITERATE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>XRANGE<SUP
CLASS="superscript"
>b</SUP
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-13205-0"
></A
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-13208-0"
></A
>X</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-13211-0"
></A
>X</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><SUP
CLASS="superscript"
>a</SUP
> Indicates availability in Oracle8 and above only.</P
><P
CLASS="para"
><SUP
CLASS="superscript"
>b</SUP
> Indicates availability in Oracle7.3 and above only.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch01-SECT-3.7.2"
>1.3.7.2 Using a packaged procedure from within SQL</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10433-0"
></A
>You cannot call a PL /SQL procedure directly inside an SQL statement. Instead, you would call that procedure from within a function that is called in SQL (or within another program that is, in turn, called by that function, and so on). That function will not work within SQL unless the procedure it calls has a RESTRICT_REFERENCES pragma.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-10453-0"
></A
>You will most likely run into this situation when you want to add some trace capabilities to your SQL statement. Suppose that I want to write a general trace function that I can add to any SELECT statement to obtain information about the rows' queries. Here is one possible implementation:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE FUNCTION sql_trace (str IN VARCHAR2) RETURN NUMBER
IS
BEGIN
   DBMS_OUTPUT.PUT_LINE ('Display from SQL: ' || str);
   RETURN 0;
EXCEPTION
   WHEN OTHERS THEN RETURN SQLCODE;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now I will use this function inside SQL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; SELECT last_name, sql_trace (first_name) trc
  2    FROM employee
  3   WHERE department_id = 20;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And here are the results:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>LAST_NAME              TRC
--------------- ----------
SMITH                    0
JONES                    0
SCOTT                    0
ADAMS                    0
FORD                     0</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Wait a minute! Where's the trace output from the function? It turns out that you must call DBMS_OUTPUT.ENABLE to flush out the current contents of the buffer (a "standalone" call to DBMS_OUTPUT.PUT_LINE will also do the trick). <A
CLASS="indexterm"
NAME="ch01-idx-10451-0"
></A
>Here <A
CLASS="indexterm"
NAME="ch01-idx-10430-0"
></A
>we <A
CLASS="indexterm"
NAME="ch01-idx-10426-0"
></A
>go:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec dbms_output.enable
Display from SQL: JOHN
Display from SQL: TERRY
Display from SQL: DONALD
Display from SQL: DIANE
Display from SQL: JENNIFER</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.2 Built-in Packages Covered in This Book"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.2 Built-in Packages Covered in This Book"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_04.htm"
TITLE="1.4 Examining Built-in Package Source Code"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.4 Examining Built-in Package Source Code"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.2 Built-in Packages Covered in This Book</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.4 Examining Built-in Package Source Code</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
