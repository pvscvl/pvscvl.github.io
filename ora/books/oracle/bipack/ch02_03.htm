<HTML
><HEAD
><TITLE
>[Chapter 2] 2.3 The DBMS_SQL Interface</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Charles Dye &amp; John Beresniewicz"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:44:46Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-375-8E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-375-8E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Packages"><META
NAME="DC.Title"
CONTENT="Oracle Built-in Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch02_01.htm"
TITLE="2. Executing Dynamic SQL and PL/SQL"><LINK
REL="prev"
HREF="ch02_02.htm#ch02-SECT-2.3"
TITLE="2.2 Getting Started with DBMS_SQL"><LINK
REL="next"
HREF="ch02_04.htm#ch02-SECT-4.5"
TITLE="2.4 Tips on Using Dynamic SQL"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Built-in Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Built-in Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch02_02.htm#ch02-SECT-2.3"
TITLE="2.2 Getting Started with DBMS_SQL"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.2 Getting Started with DBMS_SQL"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch02_01.htm"
TITLE="2. Executing Dynamic SQL and PL/SQL"
>Chapter 2<BR>Executing Dynamic SQL and PL/SQL</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch02_04.htm#ch02-SECT-4.5"
TITLE="2.4 Tips on Using Dynamic SQL"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.4 Tips on Using Dynamic SQL"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch02-34277"
>2.3 The DBMS_SQL Interface</A
></H2
><P
CLASS="para"
>DBMS_SQL is an extremely powerful package, but it is also one of the most complicated built-in packages to use. Sure, you can construct and execute any SQL statement you desire. The trade-off for that flexibility is that you have to do lots more work to get your SQL-related job done. You must specify all aspects of the SQL statement, usually with a wide variety of procedure calls, from the SQL statement itself down to the values of bind variables and the datatypes of columns in SELECT statements. Before I explore each of the programs that implement these steps, let's review the general flow of events that must occur in order to use DBMS_SQL successfully.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.1"
>2.3.1 Processing Flow of Dynamic SQL</A
></H3
><P
CLASS="para"
>In order to execute <A
CLASS="indexterm"
NAME="ch02-idx-19797-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19797-1"
></A
>dynamic SQL with DBMS_SQL you must follow these steps; see <A
CLASS="xref"
HREF="ch02_03.htm#ch02-SECT-3.4.1"
>Figure 2.1</A
> for a graphical summary:</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch02-24104"
>Figure 2.1: DBMS_SQL execution flow</A
></H4
><IMG
CLASS="graphic"
SRC="figs/obip.0201.gif"
ALT="Figure 2.1"><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Open a cursor</EM
>. When you <EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch02-idx-19810-0"
></A
>open a cursor, you ask the RDBMS to set aside and maintain a valid cursor structure for your use with future DBMS_SQL calls. The RDBMS returns an INTEGER handle to this cursor. You will use this handle in all future calls to DBMS_SQL programs for this dynamic SQL statement. Note that this cursor is completely distinct from normal, native PL/SQL cursors.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Parse the SQL statement</EM
>. Before you can specify bind variable values and column structures for the SQL statement, it must be <EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch02-idx-19815-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19815-1"
></A
>parsed by the RDBMS. This parse phase verifies that the SQL statement is properly constructed. It then associates the SQL statement with your cursor handle. Note that when you parse a DDL statement, it is also executed immediately. Upon successful completion of the DDL parse, the RDBMS also issues an implicit commit. This behavior is consistent with that of SQL*Plus.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Bind all host variables</EM
><A
CLASS="indexterm"
NAME="ch02-idx-19817-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19817-1"
></A
>. If the SQL statement contains references to host       PL/SQL variables, you will include placeholders to those variables in the SQL statement by prefacing their names with a colon, as in :salary. You must then bind the actual value for that variable into the SQL statement.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Define the columns in SELECT statements</EM
><A
CLASS="indexterm"
NAME="ch02-idx-19818-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19818-1"
></A
>. Each column in the list of the SELECT must be defined. This define phase sets up a correspondence between the expressions in the list of the SQL statement and the local PL/SQL variables receiving the values when a row is fetched (see COLUMN_VALUE). This step is only necessary for SELECT statements and is roughly equivalent to the INTO clause of an implicit SELECT statement in PL/SQL.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Execute the SQL statement</EM
>. <A
CLASS="indexterm"
NAME="ch02-idx-19819-0"
></A
>Execute the specified cursor&nbsp;-- that is, its associated SQL statement. If the SQL statement is an INSERT, UPDATE, or DELETE, the EXECUTE command returns the numbers of rows processed. Otherwise, you should ignore that return value. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Fetch rows from the dynamic SQL query</EM
><A
CLASS="indexterm"
NAME="ch02-idx-19820-0"
></A
>. If you execute a SQL statement, you must then fetch the rows from the cursor, as you would with a normal        PL/SQL cursor. When you fetch, however, you do not fetch directly into local PL/SQL <A
CLASS="indexterm"
NAME="ch02-idx-23798-0"
></A
>variables. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Retrieve values from the execution of the dynamic SQL</EM
><A
CLASS="indexterm"
NAME="ch02-idx-19821-0"
></A
>. If the SQL statement is a query, retrieve values from the SELECT expression list using COLUMN_VALUE. If you have passed a PL/SQL block containing calls to stored procedures, use VARIABLE_VALUE to retrieve the values returned by those procedures.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Close the cursor</EM
><A
CLASS="indexterm"
NAME="ch02-idx-19822-0"
></A
>. As with normal PL/SQL cursors, always clean up by closing the cursor when you are done. This releases the memory associated with <A
CLASS="indexterm"
NAME="ch02-idx-19870-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19870-1"
></A
>the cursor.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.2"
>2.3.2 Opening the Cursor</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-19823-0"
></A
>Before you perform any kind of dynamic SQL, you must obtain a pointer to memory in which the dynamic SQL will be managed. You do this by "opening the cursor," at which point Oracle sets aside memory for a cursor data area and then returns a pointer to that area. </P
><P
CLASS="para"
>These pointers are different from the cursors defined by other elements of Oracle, such as the Oracle Call Interface (OCI) and precompiler interfaces and even      PL/SQL's static cursors.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.2.1"
>2.3.2.1 The DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-19824-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19824-1"
></A
>OPEN_CURSOR function</A
></H4
><P
CLASS="para"
>Use this function to open a cursor. Here's the specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.OPEN_CURSOR RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that you do not provide a name for the cursor. You are simply requesting space in shared memory for the SQL statement and the data affected by that statement.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-19825-0"
></A
>You can use a cursor to execute the same or different SQL statements more than once. When you reuse a cursor, the contents of the cursor data area are reset if a new SQL statement is parsed. You do not have to close and reopen a cursor before you reuse it. You absolutely do <EM
CLASS="emphasis"
>not</EM
> have to open a new cursor for each new dynamic SQL statement you want to process. When you are done with the cursor, you should remove it from memory with a call to the CLOSE_CURSOR procedure.</P
><P
CLASS="para"
>The following example demonstrates the use of a single cursor for two different SQL statements. I declare a cursor, use it to create an index, and then use it to update rows in the emp table.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE do_two_unrelated_actions 
   (tab_in IN VARCHAR2, col_in IN VARCHAR2, val_in IN NUMBER)
IS
   cur BINARY_INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk BINARY_INTEGER;   
BEGIN
   /* Piece together a CREATE INDEX statement. */
   DBMS_SQL.PARSE (cur, 
      'CREATE INDEX ind_' || tab_in || '$' || col_in || ' ON ' ||
      tab_in || '(' || col_in || ')',
      DBMS_SQL.NATIVE);
   fdbk := DBMS_SQL.EXECUTE (cur);

   /* Use the same cursor to do the update. */
   DBMS_SQL.PARSE (cur,
      'UPDATE ' || tab_in || ' SET ' || col_in || ' = :newval',
      DBMS_SQL.NATIVE);
   DBMS_SQL.BIND_VARIABLE (cur, 'newval', val_in);
   fdbk := DBMS_SQL.EXECUTE (cur);
   
   /* Free up the memory from the cursor. */
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.2.2"
>2.3.2.2 The DBMS_SQL.IS_OPEN function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-20204-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20204-1"
></A
>IS_OPEN function returns TRUE if the specified cursor is already open, and FALSE if the cursor has been closed or if the value does not point to a dynamic cursor,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.IS_OPEN (c IN INTEGER) RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <CODE
CLASS="literal"
>c</CODE
> is the pointer to the cursor. This function corresponds to the %ISOPEN attribute for regular PL/SQL cursors. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.3"
>2.3.3 Parsing the SQL Statement</A
></H3
><P
CLASS="para"
><EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch02-idx-19833-0"
></A
>Once you have allocated a pointer to a cursor, you can then associate that pointer with a SQL statement. You do this by <EM
CLASS="emphasis"
>parsing</EM
> the SQL statement with a call to the PARSE procedure. The parse phase checks the statement's syntax, so if there is a syntax error, the call to PARSE will fail and an exception will be raised.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.3.1"
>2.3.3.1 The DBMS_SQL.PARSE procedure</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-19883-0"
></A
>The PARSE procedure immediately parses the statement specified. It comes in two formats. The first, as follows, will be used in almost every case. For very large SQL statments, use the PL/SQL table-based version described in the next section.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.PARSE 
   (c IN INTEGER,
    statement IN VARCHAR2,
    language_flag IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this procedure are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The pointer to the cursor or memory area for this SQL statement.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>statement</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The SQL statement to be parsed and associated with the cursor. This statement should not be terminated with a semicolon unless it is a      PL/SQL block.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>language_flag</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A flag determing how Oracle will handle the statement. Valid options are DBMS_SQL.V6, DBMS_SQL.V7, and DBMS_SQL.NATIVE. Use DBMS_SQL.NATIVE unless otherwise instructed by your DBA.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Note that you cannot <A
CLASS="indexterm"
NAME="ch02-idx-19844-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19844-1"
></A
>defer the parsing of this statement, as is possible with OCI. Statements in DBMS_SQL are parsed immediately. Oracle documentation does mention that this "may change in future versions; you should not rely on this behavior." This means that at some point in the future, Oracle Corporation may allow parsing to be deferred to the execute phase, thereby reducing network traffic. If this change occurs, let's hope that a flag is offered to preserve earlier functionality.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> <A
CLASS="indexterm"
NAME="ch02-idx-19857-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19857-1"
></A
>The common understanding among long-time Oracle programmers is that when you parse DDL, it always executes, so a call to the EXECUTE procedure is not necessary when calling DBMS_SQL.PARSE for a DDL statement. <EM
CLASS="emphasis"
>You should not take this shortcut!</EM
> Oracle will not guarantee that this behavior will continue in future releases. If you want to make sure that your DDL has executed, call the DBMS_SQL.EXECUTE procedure.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.3.2"
>2.3.3.2 Parsing very l<A
CLASS="indexterm"
NAME="ch02-idx-19861-0"
></A
>ong SQL statements</A
></H4
><P
CLASS="para"
>PL/SQL8 offers a second, overloaded version of PARSE, which comes in handy when you have very large SQL statements. If your SQL statement exceeds the largest possible contiguous allocation on your system (and it is machine-dependent) or 32Kbytes (the maximum size for VARCHAR2), then use this version of the PARSE procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.PARSE
   (c IN INTEGER,
    statement IN DBMS_SQL.VARCHAR2S,
    lb IN INTEGER,
    ub IN INTEGER,
    lfflg IN BOOLEAN,
    language_flag IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this procedure are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The pointer to the cursor or memory area for this SQL statement.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>statement</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The SQL statement to be parsed and associated with the cursor. In this case, you will be passing a PL/SQL table of the DBMS_SQL.VARCHAR2S type.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lb</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The lower bound or first row in the statement table to be parsed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ub</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The upper bound or last row in the statement table to be parsed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lfflg</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If TRUE, then a line-feed should be concatenated after each row in the table.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>language_flag</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A flag determining how Oracle will handle the statement. Valid options are DBMS_SQL.V6, DBMS_SQL.V7, and DBMS_SQL.NATIVE. Use DBMS_SQL.NATIVE unless otherwise instructed by your DBA.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>My own <A
CLASS="indexterm"
NAME="ch02-idx-19865-0"
></A
>parse_long_one procedure offers an example of using the array-based version of the PARSE procedure: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch02-idx-20743-0"
></A
>parslong.sp */
CREATE OR REPLACE PROCEDURE parse_long_one 
   (select_list IN VARCHAR2,
    from_list IN VARCHAR2,
    where_clause IN VARCHAR2,
    maxlen IN BINARY_INTEGER := 256, /* Can change the max. */
    dbg IN BOOLEAN := FALSE /* Built-in debugging toggle */
   )
IS
   /* Open the cursor as I declare the variable */
   cur BINARY_INTEGER := DBMS_SQL.OPEN_CURSOR;
   
   /* Declare the index-by table based on the DBMS_SQL TYPE. */
   sql_table DBMS_SQL.VARCHAR2S;
   
   /* Local module to extract up to the next maxlen chars. */
   FUNCTION next_row 
      (string_in IN VARCHAR2, 
       start_inout IN OUT BINARY_INTEGER,
       len_in IN BINARY_INTEGER)
   RETURN VARCHAR2
   IS
      v_start BINARY_INTEGER := start_inout;
   BEGIN
      start_inout := LEAST (len_in + 1, start_inout + maxlen);
      RETURN SUBSTR (string_in, v_start, maxlen);
   END;
   
   /* Local module to transfer string to index-by table. */
   PROCEDURE fill_sql_table (string_in IN VARCHAR2)
   IS
      v_length BINARY_INTEGER;
      v_start BINARY_INTEGER := 1;
   BEGIN
      IF string_in IS NOT NULL
      THEN
         v_length := LENGTH (string_in);
         LOOP
            sql_table (NVL (sql_table.LAST, 0)+1) := 
               next_row (string_in, v_start, v_length);
            EXIT WHEN v_start &gt; v_length;
         END LOOP;
      END IF;
   END;
    
BEGIN
   /* Move each portion of the SELECT string to the table. */
   fill_sql_table (select_list);
   fill_sql_table (from_list);
   fill_sql_table (where_clause);
   
   /* Parse everything from first to last row of table. */
   DBMS_SQL.PARSE (cur, 
      sql_table, sql_table.FIRST, sql_table.LAST,
      FALSE, DBMS_SQL.NATIVE);
     
   /* Execute and fetch rows if doing something for real... */ 
   /* If debugging, then display contents of the table. */   
   IF dbg
   THEN
      DBMS_OUTPUT.PUT_LINE 
         ('Parsed into lines of length ' || TO_CHAR (maxlen));
      FOR rowind IN sql_table.FIRST .. sql_table.LAST
      LOOP
         DBMS_OUTPUT.PUT_LINE (sql_table(rowind));
      END LOOP;
   END IF;
   
   /* Close the cursor when done. */
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is a little test script (and the results of execution) for this procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; BEGIN
parse_long_one ('select empno, ename, sal, hiredate, mgr, comm ',
   'from emp ', 'where empno = empno and sal = sal', 10, TRUE);
END;
/

Parsed into lines of length 10
select emp
no, ename,
sal, hire
date, mgr,
comm
from emp
where empn
o = empno
and sal =
sal
/ </PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that the SELECT statement is broken without any concern for keeping identifiers intact. The lfflg value passed in to the PARSE procedure is set to FALSE so linefeeds are not concatenated. As a result, the broken identifiers are concatenated back together and the SQL statement parses <A
CLASS="indexterm"
NAME="ch02-idx-22738-0"
></A
>without <A
CLASS="indexterm"
NAME="ch02-idx-22743-0"
></A
>any <A
CLASS="indexterm"
NAME="ch02-idx-22748-0"
></A
>difficulty.<EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch02-idx-19836-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.4"
>2.3.4 Binding Values into Dynamic SQL</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-21356-0"
></A
>SQL (or PL/SQL) statement you execute is constructed as a string at runtime. In most scenarios, you are using dynamic SQL because all the information about the SQL statement is not known at compile time. You therefore have values that you want to pass <EM
CLASS="emphasis"
>into</EM
> the SQL statement at runtime. You have two ways of doing this: <A
CLASS="indexterm"
NAME="ch02-idx-21358-0"
></A
>concatenation and <A
CLASS="indexterm"
NAME="ch02-idx-21359-0"
></A
>binding. With concatenation, you convert all elements of the SQL statement into strings and concatenate them together. With binding, you insert <EM
CLASS="emphasis"
>placeholders</EM
> in your string (identifiers prefaced with a colon) and then explicitly bind or associate a value with that placeholder before executing the SQL statement.</P
><P
CLASS="para"
>If you concatenate the value into the string, then you are not really binding values and you do not have to make calls to the BIND_VARIABLE or BIND_ARRAY procedures. Here is an example of the parsing of a dynamically constructed string relying on concatenation:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.PARSE 
   (cur, 'SELECT * FROM emp WHERE ename LIKE ' || v_ename);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>At runtime the string is cobbled together and passed to the SQL engine for parsing. With binding, you would write code like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.PARSE 
   (cur, 'SELECT * FROM emp WHERE ename LIKE :varname');
DBMS_SQL.BIND_VARIABLE (cur, 'varname', var_name_in);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Binding involves writing more code, but offers much more flexibility and power. The following comparison between concatenation and binding techniques will help you decide which to use:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-19906-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19906-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19906-2"
></A
>When you concatenate, you convert to a string format. This can become awkward and error-prone. With binding, you do not perform any conversions. Instead, the native datatypes are employed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When you execute <A
CLASS="indexterm"
NAME="ch02-idx-19907-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19907-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19907-2"
></A
>DDL statements dynamically, you <EM
CLASS="emphasis"
>cannot</EM
> use bind variables. Your only choice is to concatenate together the strings and then pass that to the engine. This makes sense, since, at least in the current version of DBMS_SQL, there is no such thing as <A
CLASS="indexterm"
NAME="ch02-idx-19908-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19908-1"
></A
>deferred parsing. When you parse, you also execute DDL.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can execute the same dynamic <A
CLASS="indexterm"
NAME="ch02-idx-19909-0"
></A
>cursor more than once, and each time you bind in different values to the SQL statement. This is not possible if you concatenate the values into the string at the time of parsing.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>With bind variables, you can take advantage of the new <A
CLASS="indexterm"
NAME="ch02-idx-19910-0"
></A
>array-processing features of PL/SQL8's DBMS_SQL package. You can bind an entire array of scalar values into the SQL string and then apply each of those values in a single SQL execution.</P
></LI
></UL
><P
CLASS="para"
>So if you decide that you really do want to bind variables into your dynamic SQL, use one of the programs described in the following sections.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.4.1"
>2.3.4.1 The DBMS_SQL.BIND_VARIABLE procedure </A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-2762-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-2762-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-2762-2"
></A
>BIND_VARIABLE procedure binds a scalar value to a placeholder in your SQL statement. A <A
CLASS="indexterm"
NAME="ch02-idx-19911-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19911-1"
></A
>placeholder is an identifier prefaced by a colon, as in :myval. Call BIND_VARIABLE after DBMS_SQL.PARSE, but before calls to EXECUTE and EXECUTE_AND_FETCH. This procedure is overloaded to allow you to bind a number of different types of data. This is the header:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.BIND_VARIABLE
   (c IN INTEGER,
    name IN VARCHAR2,
    value IN &lt;datatype&gt;);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this procedure are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The handle or pointer to the cursor originally returned by a call to OPEN_CURSOR.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the placeholder included in the SQL statement passed to PARSE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>value</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The value to be bound to the placeholder variable.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><KBD
CLASS="command"
>&lt;datatype&gt; </KBD
>may be any of the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
MLSLABEL /*Trusted Oracle only*/
NUMBER
VARCHAR2 CHARACTER SET ANY_CS_ARRAY</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is an example of binding the current date/time into a placeholder called "now:"</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.BIND_VARIABLE (cur, 'now', SYSDATE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is an example of binding the literal value "Liberation Theology" into a placeholder called "progress:"</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.BIND_VARIABLE (cur, ':progress', 'Liberation Theology');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that you can include or leave out the colon when you specify the placeholder name.</P
><P
CLASS="para"
>The DBMS_SQL package also offers more specific variants of BIND_VARIABLE for less-common datatypes,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.BIND_VARIABLE
   (c IN INTEGER, 
    name IN VARCHAR2, 
    value IN VARCHAR2 CHARACTER SET ANY_CS,
    [,out_value_size IN INTEGER]);

PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-19912-0"
></A
>BIND_VARIABLE_CHAR
   (c IN INTEGER, 
    name IN VARCHAR2, 
    value IN CHAR CHARACTER SET ANY_CS,
    [,out_value_size IN INTEGER]);

PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-19913-0"
></A
>BIND_VARIABLE_RAW
   (c IN INTEGER, 
    name IN VARCHAR2, 
    value IN RAW
    [,out_value_size IN INTEGER]);

PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-19914-0"
></A
>BIND_VARIABLE_ROWID
   (c IN INTEGER, 
    name IN VARCHAR2, 
    value IN ROWID);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where out_value_size is the maximum size expected for the value that might be passed to this variable. <A
CLASS="indexterm"
NAME="ch02-idx-19915-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19915-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19915-2"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19915-3"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19915-4"
></A
>Square brackets indicate optional parameters. If you do not provide a value for out_value_size, the size is the length of the current value provided. </P
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch02-SECT-3.4.1.5"
>2.3.4.1.1 Examples</A
></H4
><P
CLASS="para"
>For every placeholder you put in your SQL string, you must make a call to BIND_VARIABLE (or BIND_ARRAY). For example, the SELECT statement in the call to PARSE below contains two bind variables, :call_date and :call_type:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.PARSE 
   (the_cursor, 
    'SELECT COUNT(*) freq FROM call WHERE call_date = :call_date ' ||
      'AND call_type_cd = :call_type',
    DBMS_SQL.V7);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I will therefore need to issue the following two calls to BIND_VARIABLE before I can execute the query,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.BIND_VARIABLE (the_cursor, 'call_date', :call.last_date_called);
DBMS_SQL.BIND_VARIABLE (the_cursor, 'call_type', :call.call_status);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where the two bind values are items in an Oracle Forms screen. Since BIND_VARIABLE is overloaded, I can call it with either a date value or a string, and PL/SQL will execute the appropriate code. Notice that the name of the bind variable does <EM
CLASS="emphasis"
>not</EM
> have to match any particular column name in the SELECT statement, and it does not have to match the name of the PL/SQL variable that may hold the value. The name is really just a placeholder into which a value is substituted.</P
><P
CLASS="para"
>You can also include the colon in the placeholder name when you bind the value to the variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.BIND_VARIABLE (the_cursor, ':call_date', :call.last_date_called);</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-19919-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19919-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19919-2"
></A
>If you want to avoid having to make these separate calls to BIND_VARIABLE, you can substitute these values into the SQL statement yourself at the time the statement is parsed. The code shows the same SELECT statement, but without any bind variables.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.PARSE 
   (the_cursor, 
    'SELECT COUNT(*) freq FROM call WHERE call_date = ''' || 
    TO_CHAR (:call.last_date_called) ||
    ''' AND call_type_cd = ''' || :call.call_status || '''',
    DBMS_SQL.V7);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Kind of ugly, isn't it? All of those single quotes glommed together (three consecutive single quotes at the end of a string result in one single quote around the literal values stuffed into the SQL statement), the concatenation, datatype conversions, etc. This is the tradeoff for not using the programmatic interface provided by DBMS_SQL.</P
><P
CLASS="para"
>You will also call BIND_VARIABLE for every placeholder in a <A
CLASS="indexterm"
NAME="ch02-idx-19921-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19921-1"
></A
>dynamic PL/SQL block, even if the placeholder is an OUT argument or is otherwise simply receiving a value. Consider the following PL/SQL procedure, which performs an assignment dynamically when it could simply do it explicitly:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE assign_value (newval_in IN NUMBER)
IS 
   cur PLS_INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk PLS_INTEGER;
   local_var NUMBER; /* Receives the new value */
BEGIN
   DBMS_SQL.PARSE 
      (cur, 'BEGIN :container := :newval; END;', DBMS_SQL.NATIVE);
   DBMS_SQL.BIND_VARIABLE (cur, 'newval', newval_in);
   DBMS_SQL.BIND_VARIABLE (cur, 'container', 1);
   fdbk := DBMS_SQL.EXECUTE (cur);
   DBMS_SQL.VARIABLE_VALUE (cur, 'container', local_var);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that even though the container placeholder's value <EM
CLASS="emphasis"
>before execution</EM
> is irrelevant, I still needed to bind that placeholder to a value for the PL/SQL block to execute <A
CLASS="indexterm"
NAME="ch02-idx-23736-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-23736-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-23736-2"
></A
>successfully.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch02-SECT-3.4.2"
>2.3.4.1.2 The DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-19922-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19922-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19922-2"
></A
>BIND_ARRAY procedure</A
></H4
><P
CLASS="para"
>With PL/SQL8, you can use the new BIND_ARRAY procedure to perform bulk selects, inserts, updates, and deletes to improve the performance of your application. This same procedure will allow you to use and manipulate <A
CLASS="indexterm"
NAME="ch02-idx-19929-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19929-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19929-2"
></A
>index-by tables (previously known as PL/SQL tables) within dynamically constructed PL/SQL blocks of code. To perform bulk or array processing, you will associate one or more index-by tables with columns or placeholders in your cursor.</P
><P
CLASS="para"
>The BIND_ARRAY procedure establishes this association for you. Call this procedure after PARSE, but before calls to EXECUTE and EXECUTE_AND_FETCH:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.BIND_ARRAY
   (c IN INTEGER,
   name IN VARCHAR2,
   &lt;table_variable&gt; IN &lt;datatype&gt;,
   [,index1 IN INTEGER,
   ,index2 IN INTEGER)]);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this procedure are summarized in the following table. </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The handle or pointer to the cursor originally returned by a call to OPEN_CURSOR.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the host variable included in the SQL statement passed to PARSE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>index1</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The lower bound or row in the index-by table &lt;table_variable&gt; for the first table element.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>variable</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>See the following description.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>index2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The upper bound or row in the index-by table &lt;table_variable&gt; for the last table element.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The &lt;table_variable&gt; IN &lt;datatype&gt; clause may be any of the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>n_tab IN DBMS_SQL.NUMBER_TABLE
c_tab IN DBMS_SQL.VARCHAR2_TABLE
d_tab IN DBMS_SQL.DATE_TABLE
bl_tab IN DBMS_SQL.BLOB_TABLE
cl_tab IN DBMS_SQL.CLOB_TABLE
bl_tab IN DBMS_SQL.BFILE_TABLE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following example shows how I can use BIND_ARRAY to update multiple numeric rows of any table that has a numeric primary key:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch02-idx-20745-0"
></A
>updarray.sp */
CREATE OR REPLACE PROCEDURE updarray 
   (tab IN VARCHAR2,
    keycol IN VARCHAR2, 
    valcol IN VARCHAR2, 
    keylist IN DBMS_SQL.NUMBER_TABLE,
    vallist IN DBMS_SQL.NUMBER_TABLE)
IS
   cur INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk INTEGER;
   mytab DBMS_SQL.NUMBER_TABLE;
BEGIN
   DBMS_SQL.PARSE
     (cur, 
      'UPDATE ' || tab ||
        ' SET ' || valcol || ' = :vals ' ||
      ' WHERE ' || keycol || ' = :keys',
      DBMS_SQL.NATIVE);

   DBMS_SQL.BIND_ARRAY (cur, 'keys', keylist);
   DBMS_SQL.BIND_ARRAY (cur, 'vals', vallist);

   fdbk := DBMS_SQL.EXECUTE (cur);
   
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now I can execute this "update by array" procedure for the sal column of the emp table.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   emps DBMS_SQL.NUMBER_TABLE;
   sals DBMS_SQL.NUMBER_TABLE;
BEGIN
   emps (1) := 7499;
   sals (1) := 2000;
   emps (2) := 7521;
   sals (2) := 3000;
   
   updarray ('emp', 'empno', 'sal', emps, sals);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The section on the DEFINE_ARRAY procedure and the section called "Array Processing with DBMS_SQL" provide additional examples of using BIND_ARRAY.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="ch02-SECT-3.4.3"
>2.3.4.1.3 Rules for array binding</A
></H4
><P
CLASS="para"
>There are a number of factors to keep in mind when you are binding with index-by tables.</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>At the time of binding, the contents of the nested table are copied from your private global area to the DBMS_SQL buffers. Consequently, if you make changes to the nested table after your call to DBMS_SQL.BIND_ARRAY, those changes will not affect the cursor when executed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you specify values for index1 and/or index2, then those rows must be defined in the nested table. The value of index1 must be less than or equal to index2. All elements between and included in those rows will be used in the bind, but the table does not have to be densely filled. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you do not specify values for index1 and index2, the first and last rows defined in the nested table will be used to set the boundaries for the bind.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Suppose that you have more than one bind array in your statement and the bind ranges (or the defined rows, if you did not specify) for the arrays are different. DBMS_SQL will then use the smallest common range&nbsp;-- that is, the greatest of the lower bounds and the least of the upper bounds.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can mix array and scalar binds in your dynamic SQL execution. If you have a scalar bind, the same value will be used for each element of the arrays. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When fetching data using dynamic SQL, you cannot use arrays in both the bind and define phases. You may not, in other words, specify multiple bind values and at the same time fetch multiple rows into <A
CLASS="indexterm"
NAME="ch02-idx-20240-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20240-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20240-2"
></A
>an array. <A
CLASS="indexterm"
NAME="ch02-idx-19902-0"
></A
></P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.5"
>2.3.5 Defining Cursor Columns</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-19932-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19932-1"
></A
>The <A
CLASS="indexterm"
NAME="ch02-idx-19931-0"
></A
>OPEN_CURSOR procedure allocates memory for a cursor and its result set and returns a pointer to that area in memory. It does not, however, give any structure to that cursor. And even after you parse a SQL statement for that pointer, the cursor itself still does not have any internal structure. If you are going to execute a SELECT statement dynamically and extract values of columns in retrieved rows, you will need to take the additional step of defining the datatype of the individual columns in the cursor.</P
><P
CLASS="para"
>Each cursor column is, essentially, a <EM
CLASS="emphasis"
>container</EM
> which will hold fetched data. You can use the DEFINE_COLUMN procedure to define a "scalar" column&nbsp;-- one that will hold a single value. You can also (with PL/SQL8) call DEFINE_ARRAY to create a column that will hold multiple values, allowing you to fetch rows in bulk from the database.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.5.1"
>2.3.5.1 The DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-21022-0"
></A
>DEFINE_COLUMN procedure</A
></H4
><P
CLASS="para"
>When you call the PARSE procedure to process a SELECT statement, you need to pass values from the database into local variables. To do this, you must tell DBMS_SQL the datatypes of the different columns or expressions in the SELECT list by making a call to the DEFINE_COLUMN procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.DEFINE_COLUMN
    (c IN INTEGER, 
    position IN INTEGER, 
    column IN &lt;datatype&gt;);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for this procedure are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Pointer to the cursor.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>position</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The relative position of the column in the SELECT list.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>column</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>A PL/SQL variable or expression whose datatype determines the datatype of the column being defined. The particular value being passed in is irrelevant.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><CODE
CLASS="literal"
>&lt;datatype&gt;</CODE
> may be one of the following data types: <CODE
CLASS="literal"
>NUMBER</CODE
>, <CODE
CLASS="literal"
>DATE</CODE
>, <CODE
CLASS="literal"
>MLSLABEL</CODE
>, <CODE
CLASS="literal"
>BLOB</CODE
>, <CODE
CLASS="literal"
>CLOB CHARACTER SET ANY_CS</CODE
>, <CODE
CLASS="literal"
>BFILE</CODE
></P
><P
CLASS="para"
>The DBMS_SQL package also offers more specific variants of DEFINE_COLUMN for less-common datatypes.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.DEFINE_COLUMN 
    (c IN INTEGER
    ,position IN INTEGER
    ,column IN VARCHAR2 CHARACTER SET ANY_CS
    ,column_size IN INTEGER);

PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-19955-0"
></A
>DEFINE_COLUMN_CHAR 
    (c IN INTEGER
    ,position IN INTEGER
    ,column IN CHAR CHARACTER SET ANY_CS
    ,column_size IN INTEGER);

PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-19956-0"
></A
>DEFINE_COLUMN_RAW
    (c IN INTEGER
    ,position IN INTEGER
    ,column IN RAW
    ,column_size IN INTEGER);

PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-19957-0"
></A
>DEFINE_COLUMN_ROWID
    (c IN INTEGER
    ,position IN INTEGER
    ,column IN ROWID);

PROCEDURE DBMS_SQL.DEFINE_COLUMN_LONG
    (c IN INTEGER
    ,position IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You call DEFINE_COLUMN after the call to the PARSE procedure, but before the call to EXECUTE or EXECUTE_AND_FETCH. Once you have executed the SELECT statement, you will then use the COLUMN_VALUE procedure to grab a column value from the select list and pass it into the appropriate local variable.</P
><P
CLASS="para"
>The following code shows the different steps required to set up a SELECT statement for execution with DBMS_SQL:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   /* Declare cursor handle and assign it a pointer */
   c INTEGER := DBMS_SQL.OPEN_CURSOR;

   /* Use a record to declare local structures. */
   rec employee%ROWTYPE;

   /* return value from EXECUTE; ignore in case of query */
   execute_feedback INTEGER;
BEGIN
   /* Parse the query with two columns in SELECT list */
   DBMS_SQL.PARSE 
      (c, 
       'SELECT employee_id, last_name FROM employee',
       DBMS_SQL.V7);

   /* Define the columns in the cursor for this query */
   DBMS_SQL.DEFINE_COLUMN (c, 1, rec.empno);
   DBMS_SQL.DEFINE_COLUMN (c, 2, rec.ename, 30);

   /* Now I can execute the query */
   execute_feedback := DBMS_SQL.EXECUTE (c);
   ...
   DBMS_SQL.CLOSE_CURSOR (c)
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that with the DEFINE_COLUMN procedure, you define columns (their datatypes) using a sequential position. With BIND_VARIABLE, on the other hand, you associate values to placeholders by <A
CLASS="indexterm"
NAME="ch02-idx-19961-0"
></A
>name. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.5.2"
>2.3.5.2 The <A
CLASS="indexterm"
NAME="ch02-idx-19965-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19965-1"
></A
>DBMS_SQL.DEFINE_ARRAY procedure</A
></H4
><P
CLASS="para"
>If you are working with PL/SQL8, you have the option of defining a column in the cursor which is capable of holding the values of multiple fetched rows. You accomplish this with a call to the DEFINE_ARRAY procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.DEFINE_ARRAY
    (c IN INTEGER
    ,position IN INTEGER
    ,&lt;table_parameter&gt; IN &lt;table_type&gt;
    ,cnt IN INTEGER
    ,lower_bound IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The DEFINE_ARRAY parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Pointer to cursor.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>position</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The relative position of the column in the select list.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>&lt;table_parameter&gt;</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The nested table which is used to tell DBMS_SQL the datatype of the column.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>cnt</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The maximum number of rows to be fetched in the call to the FETCH_ROWS or EXECUTE_AND_FETCH functions.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>lower_bound</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The starting row (lower bound) in which column values will be placed in the nested table you provide in the corresponding call to the COLUMN_VALUE or VARIABLE_VALUE procedures.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>&lt;table_parameter&gt; IN &lt;table_type&gt; is one of the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>n_tab IN DBMS_SQL.NUMBER_TABLE
c_tab IN DBMS_SQL.VARCHAR2_TABLE
d_tab IN DBMS_SQL.DATE_TABLE
bl_tab IN DBMS_SQL.BLOB_TABLE
cl_tab IN DBMS_SQL._TABLE
bf_tab IN DBMS_SQL.BFILE_TABLE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you call the COLUMN_VALUE or VARIABLE_VALUE procedures against an array-defined column, the Nth fetched column value will be placed in the lower_bound+N-1th row in the nested table. In other words, if you have fetched three rows and your call to DEFINE_ARRAY looked like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   datetab DBMS_SQL.DATE_TABLE;
BEGIN
   DBMS_SQL.DEFINE_ARRAY (cur, 2, datetab, 10, 15);

   <I
CLASS="lineannotation"
>...execute and fetch rows...</I
>

   DBMS_SQL.COLUMN_VALUE (cur, 2, datetab);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>then the data will be placed in datetab(15), datetab(16), and <A
CLASS="indexterm"
NAME="ch02-idx-21026-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-21026-1"
></A
>datetab(17).<A
CLASS="indexterm"
NAME="ch02-idx-19972-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19972-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.6"
>2.3.6 Executing the Cursor</A
></H3
><P
CLASS="para"
>So you've opened and parsed the cursor. You've bound your variables and defined your columns. Now it's time to get some <EM
CLASS="emphasis"
>work</EM
> done. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.6.1"
>2.3.6.1 The DBMS_SQL.EXECUTE function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-19974-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19974-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19974-2"
></A
>EXECUTE function executes the SQL statement associated with the specified cursor,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.EXECUTE (c IN INTEGER) RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where c is the pointer to the cursor. This function returns the number of rows processed by the SQL statement if that statement is an UPDATE, INSERT, or DELETE. For all other SQL (queries and DDL) and PL/SQL statements, the value returned by EXECUTE is undefined and should be ignored.</P
><P
CLASS="para"
>If the SQL statement is a query, you can now call the FETCH_ROWS function to fetch rows that are retrieved by that query. If you are executing a query, you can also use EXECUTE_AND_FETCH to execute the cursor and fetch one or more rows with a single program call.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.7"
>2.3.7 Fetching Rows</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-19975-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19975-1"
></A
>You can fetch one or more rows of data from a dynamically constructed query with either the FETCH_ROWS or EXECUTE_AND_FETCH functions.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Prior to PL/SQL8, both of these functions would return either 0 (no rows fetched) or 1 (one row fetched). With PL/SQL8 and array processing, these functions will return 0 (no rows fetched) or the actual number of rows fetched.</P
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.7.1"
>2.3.7.1 The DBMS_SQL.FETCH_ROWS function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-19983-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19983-1"
></A
>FETCH_ROWS function corresponds to the FETCH statement for regular PL/SQL cursors. It fetches the next N rows from the cursor (a maximum of one if not using array processing in PL/SQL8). Here's the specification for the function, </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.FETCH_ROWS
   (c IN INTEGER) RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where c is the pointer to the cursor. The function returns 0 when there are no more rows to fetch. You can therefore use FETCH_ROWS much as you would FETCH and the %FOUND (or %NOTFOUND) attributes. The following two sets of statements are equivalent:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Use a normal, static cursor:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   FETCH emp_cur INTO emp_rec;
   IF emp_cur%FOUND
   THEN
       ... process data ...
   END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use DBMS_SQL to fetch rows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   IF DBMS_SQL.FETCH_ROWS (c) &gt; 0
   THEN
      ... process data ...
   END IF;</PRE
></BLOCKQUOTE
></LI
></UL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-19995-0"
></A
>So that happens when you fetch past the end of the cursor's result set? With static cursors, you can fetch all you want and never raise an error. In the following block, for example, I fetch 1000 times from a table with 14 rows. (C'mon, you knew that, right? The emp table has 14 rows.) </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR empcur IS SELECT * FROM emp;
   emprec empcur%ROWTYPE;
BEGIN
   OPEN empcur;
   FOR rowind IN 1 .. 1000
   LOOP
      FETCH empcur INTO emprec;
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>No problem&nbsp;-- and no exceptions! After the fourteenth fetch, the FETCH statement simply does nothing (and the record continues to hold the fourteenth row's information). </P
><P
CLASS="para"
>However, the "fetch past last record" behavior with dynamic SQL is different. The FETCH_ROWS function will raise the ORA-01002 exception: fetch out of sequence, if you fetch again <EM
CLASS="emphasis"
>after</EM
> a call to FETCH_ROWS has returned 0. The following anonymous block raises the ORA-01002 error, because there are only three employees in department 10:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   cur PLS_INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk PLS_INTEGER;
BEGIN
   DBMS_SQL.PARSE 
      (cur, 'SELECT * FROM emp WHERE deptno = 10', DBMS_SQL.NATIVE);

   fdbk := DBMS_SQL.EXECUTE_CURSOR (cur);
   FOR Nfetch IN 1 .. 5
   LOOP
      /* On fetch #5 this will raise ORA-01002 */
      fdbk := DBMS_SQL.FETCH_ROWS (cur);
   END LOOP;
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following procedure shows how you can employ the FETCH_ROWS logic inside of a loop to fetch each of the rows from a cursor and place column values in an Oracle Forms block:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch02-idx-20747-0"
></A
>fillblck.fp */
PROCEDURE fill_block (where_clause_in IN VARCHAR2)
/*
|| Query data from table using a dynamic where clause and then
|| pass those values to an Oracle Forms block.
*/
IS
   /* 
   || Declare cursor handle and parse the query, all in a single
   || statement using open_and_parse (see PARSE description).
   */
   c INTEGER := DBMS_SQL.OPEN_CURSOR;

   emprec employee%ROWTYPE;

   /* return value from EXECUTE; ignore in case of query */
   fdbk INTEGER;
BEGIN
   /* Parse the query  with a dynamic WHERE clause */
   DBMS_SQL.PARSE (c, 
      'SELECT employee_id, last_name ' ||
      '  FROM employee WHERE ' || where_clause_in,
      DBMS_SQL.NATIVE);

   /* Define the columns in the cursor for this query */
   DBMS_SQL.DEFINE_COLUMN (c, 1, emprec.empno);
   DBMS_SQL.DEFINE_COLUMN (c, 2, emprec.ename, 30);

   /* Now I can execute the query */
   fdbk:= DBMS_SQL.EXECUTE (c);
   LOOP
      /* Try to fetch next row. If done, then exit the loop. */
      EXIT WHEN DBMS_SQL.FETCH_ROWS (c) = 0;
      /*
      || Retrieve data via calls to COLUMN_VALUE and place those
      || values in a new record in the block.
      */
      DBMS_SQL.COLUMN_VALUE (c, 1, emprec.empno);
      DBMS_SQL.COLUMN_VALUE (c, 2, emprec.ename);
      CREATE_RECORD;
      :employee.employee_id := emprec.empno;
      :employee.employee_nm := emprec.ename;
   END LOOP;

   /* Clean up the cursor */
   DBMS_SQL.CLOSE_CURSOR (c);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this example, you can fetch only one row at a time, because you defined each of your columns in the cursor to hold a single value. If, on the other hand, you defined a column as an array, then the fetch could receive multiple rows in a single call. This approach is explored in more detail in the section <A
CLASS="xref"
HREF="ch02_05.htm#ch02-SECT-5.1"
>Section 2.5.6, "Array Processing with DBMS_SQL"</A
>."<A
CLASS="indexterm"
NAME="ch02-idx-19993-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19993-1"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.7.2"
>2.3.7.2 The DBMS_SQL.EXECUTE_AND_FETCH function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-19996-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19996-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19996-2"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-19996-3"
></A
>EXECUTE_AND_FETCH function executes the SELECT statement associated with the specified cursor and immediately fetches the rows associated with the query. Here's the specification for the function. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.EXECUTE_AND_FETCH
    (c IN INTEGER
    ,exact IN BOOLEAN DEFAULT FALSE)
RETURN INTEGER;
</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The handle or pointer to the cursor originally returned by a call to OPEN_CURSOR.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>exact</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Set to TRUE if you want the function to raise an exception when it fetches more than one row.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-20002-0"
></A
>Even if EXECUTE_AND_FETCH does raise an exception (TOO_MANY_ROWS), the rows will still be fetched and available. The value returned by the function will, however, be NULL.</P
><P
CLASS="para"
>This function is designed to make it easy to execute and fetch a single row from a query. It is very similar to the implicit SELECT cursor in native PL/SQL, which either returns a single row, multiple rows (for PL/SQL8 array access only), or raises the TOO_MANY_ROWS exception (ORA-01422). </P
><P
CLASS="para"
>See the sidebar entitled <A
CLASS="xref"
HREF="ch02_03.htm#ch02-SECT-3.4.1"
>the sidebar "Oracle: The Show Me Technology"</A
>," for a script you can use to examine the behavior of this built-in function.<A
CLASS="indexterm"
NAME="ch02-idx-19977-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.8"
>2.3.8 Retrieving Values </A
></H3
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="ch02-36946"
>Oracle: The Show Me Technology</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-20062-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20062-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20062-2"
></A
>If there is one thing I have learned over the years, it is that if I am not absolutely sure about the way a particular feature works, I have to try it out and see what happens. I have two primary references for writing about PL/SQL technology: the Oracle documentation and the Oracle software. The former is helpful for guiding my "first draft." The latter is helpful for making sure that my "final draft" is accurate and honest. See, unfortunately, just because the documentation says that something works a certain way, that doesn't necessarily mean it really does operate as advertised.</P
><P
CLASS="para"
>I built the following script (designed for use in SQL*Plus) to make it easier for Oracle to "show me" exactly the kind of variations in behavior of DBMS_SQL.EXECUTE_AND_FETCH I might encounter. You use the first argument to indicate whether or not you want rows to be found. The second argument dictates the error-handling behavior. I thought I would share it with you to give you a sense of how these kinds of scripts can make it very easy to test functionality and behavior.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: execftch.sql */
DECLARE
   cur INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk INTEGER;
BEGIN
   DBMS_SQL.PARSE
     (cur, 'SELECT empno FROM emp where 1=&amp;1', DBMS_SQL.NATIVE);

   DBMS_SQL.DEFINE_COLUMN (cur, 1, 1);

   fdbk := DBMS_SQL.EXECUTE_AND_FETCH (cur, &amp;2);
   DBMS_OUTPUT.PUT_LINE (fdbk);
   DBMS_SQL.CLOSE_CURSOR (cur);
EXCEPTION
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.PUT_LINE ('error code ' || SQLCODE);
      DBMS_OUTPUT.PUT_LINE
        ('returned by e_and_f ' || NVL (TO_CHAR (fdbk), '[NULL]'));
END;
/
</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are the results of executing this script in SQL*Plus:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @execftch 1 false
1
SQL&gt; @execftch 2 false
0
SQL&gt; @execftch 1 true
error code -1422
returned by e_and_f [NULL]
SQL&gt; @execftch 2 true
error code 100
returned by e_and_f [NULL]ORA-01403: no data found
</PRE
></BLOCKQUOTE
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-20009-0"
></A
>If you construct a dynamic SELECT or PL/SQL block, you can retrieve values from the cursor after execution. Use the COLUMN_VALUE procedure to obtain the values of individual columns in the fetched row of a SELECT. Use the COLUMN_VALUE_LONG procedure to obtain the values of a LONG column in the fetched row of a SELECT. Use the VARIABLE_VALUE procedure to extract the values of variables in a dynamic PL/SQL block.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.8.1"
>2.3.8.1 The DBMS_SQL.COLUMN_VALUE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-20010-0"
></A
>COLUMN_VALUE procedure retrieves a value from the cursor into a local variable. Use this procedure when the SQL statement is a <A
CLASS="indexterm"
NAME="ch02-idx-20059-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20059-1"
></A
>query and you are fetching rows with EXECUTE_AND_FETCH or FETCH_ROWS. You can retrieve the value for a single column in a single row or, with PL/SQL8, you can retrieve the values for a single column across multiple rows fetched. The header for the single-row version of the procedure is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13; PROCEDURE DBMS_SQL.COLUMN_VALUE
 (c IN INTEGER,
     position IN INTEGER, 
    value OUT &lt;datatype&gt;,
    [, column_error OUT NUMBER] 
    [, actual_length OUT INTEGER ]);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The COLUMN_VALUE parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Pointer to the cursor.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>position</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Relative position of the column in the select list.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>value</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The PL/SQL structure that receives the column value. If the &lt;datatype&gt; of this argument does not match that of the cursor's column, DBMS_SQL will raise the DBMS_SQL.INCONSISTENT_DATATYPE exception.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>&lt;table_parameter&gt;</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The PL/SQL table (of type &lt;table_type&gt;) holding one or more colum values, depending on how many rows were previously fetched. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>column_error</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns an error code for the specified value (the value might be too large for the variable, for instance).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>actual_length</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the actual length of the returned value before any truncation takes place (due to a difference in size between the retrieved value in the cursor and the variable).</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>&lt;datatype&gt; can be one of the following types:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NUMBER
DATE
MLSLABEL
VARCHAR2 CHARACTER SET ANY_CS
BLOB
CLOB CHARACTER SET ANY_CS
BFILE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The header for the multiple-row version of COLUMN_VALUE is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.COLUMN_VALUE
   (c IN INTEGER, 
    position IN INTEGER, 
    &lt;table_parameter&gt; OUT &lt;table_type&gt;);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>&lt;table_parameter&gt; OUT &lt;table_type&gt; can be one of the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>n_tab OUT DBMS_SQL.NUMBER_TABLE
c_tab OUT DBMS_SQL.VARCHAR2_TABLE
d_tab OUT DBMS_SQL.DATE_TABLE
bl_tab OUT DBMS_SQL.BLOB_TABLE
cl_tab OUT DBMS_SQL.CLOB_TABLE
bf_tab OUT DBMS_SQL.BFILE_TABLE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The DBMS_SQL package also offers more specific variants of COLUMN_VALUE for less common datatype:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-20063-0"
></A
>COLUMN_VALUE_CHAR
   (c IN INTEGER, 
    position IN INTEGER, 
    value OUT CHAR,
    [, column_error OUT NUMBER] 
    [, actual_length OUT INTEGER ]);

PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-20064-0"
></A
>COLUMN_VALUE_RAW
   (c IN INTEGER, 
    position IN INTEGER, 
    value OUT RAW,
    [, column_error OUT NUMBER] 
    [, actual_length OUT INTEGER ]);

PROCEDURE DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-20082-0"
></A
>COLUMN_VALUE_ROWID
   (c IN INTEGER, 
    position IN INTEGER, 
    value OUT ROWID,
    [, column_error OUT NUMBER] 
    [, actual_length OUT INTEGER ]);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You call COLUMN_VALUE after a row has been fetched to transfer the value from the SELECT list of the cursor into a local variable. For each call to the single-row COLUMN_VALUE, you should have made a call to <A
CLASS="indexterm"
NAME="ch02-idx-20083-0"
></A
>DEFINE_COLUMN in order to define that column in the cursor. If you want to use the multiple-row version of COLUMN_VALUE, use the <A
CLASS="indexterm"
NAME="ch02-idx-20084-0"
></A
>DEFINE_ARRAY procedure to define that column as capable of holding an array of values.</P
><P
CLASS="para"
>The following procedure displays employees by defining a cursor with two columns and, after fetching a row, calls COLUMN_VALUE to retrieve both column values:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch02-idx-20749-0"
></A
>showemps.sp */
CREATE OR REPLACE PROCEDURE showemps (where_in IN VARCHAR2 := NULL)
IS
   cur INTEGER := DBMS_SQL.OPEN_CURSOR;
   rec emp%ROWTYPE;
   fdbk INTEGER;
BEGIN
   DBMS_SQL.PARSE
     (cur, 'SELECT empno, ename FROM emp ' || 
           ' WHERE ' || NVL (where_in, '1=1'),
      DBMS_SQL.NATIVE);

   DBMS_SQL.DEFINE_COLUMN (cur, 1, rec.empno);
   DBMS_SQL.DEFINE_COLUMN (cur, 2, rec.ename, 30);

   fdbk := DBMS_SQL.EXECUTE (cur);
   LOOP
      /* Fetch next row. Exit when done. */
      EXIT WHEN DBMS_SQL.FETCH_ROWS (cur) = 0;
      DBMS_SQL.COLUMN_VALUE (cur, 1, rec.empno);
      DBMS_SQL.COLUMN_VALUE (cur, 2, rec.ename);
      DBMS_OUTPUT.PUT_LINE (TO_CHAR (rec.empno) || '=' || rec.ename);
   END LOOP;

   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This next PL/SQL8 block fetches the hiredate and employee ID for all rows in the emp table and deposits values into two separate PL/SQL tables. Notice that since I know there are just 14 rows in the emp table, I need only one call to the EXECUTE_AND_FETCH function to fetch all rows. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch02-idx-20751-0"
></A
>arrayemp.sp */
CREATE OR REPLACE PROCEDURE showall
IS
   cur INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk INTEGER;

   empno_tab DBMS_SQL.NUMBER_TABLE;
   hiredate_tab DBMS_SQL.DATE_TABLE;
BEGIN
   DBMS_SQL.PARSE
     (cur, 'SELECT empno, hiredate FROM emp', DBMS_SQL.NATIVE);

   /* Allow fetching of up to 100 rows. */
   DBMS_SQL.DEFINE_ARRAY (cur, 1, empno_tab, 100, 1);
   DBMS_SQL.DEFINE_ARRAY (cur, 2, hiredate_tab, 100, 1);

   fdbk := DBMS_SQL.EXECUTE_AND_FETCH (cur);

   /* This will show total numbers of rows fetched. */
   DBMS_OUTPUT.PUT_LINE (fdbk);
   
   /* Get values for all rows in one call. */
   DBMS_SQL.COLUMN_VALUE (cur, 1, empno_tab);
   DBMS_SQL.COLUMN_VALUE (cur, 2, hiredate_tab);
   
   FOR rowind IN empno_tab.FIRST .. empno_tab.LAST
   LOOP
      DBMS_OUTPUT.PUT_LINE (empno_tab(rowind));
      DBMS_OUTPUT.PUT_LINE (hiredate_tab(rowind));
   END LOOP;
   
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <A
CLASS="xref"
HREF="ch02_05.htm#ch02-SECT-5.1"
>Section 2.5, "DBMS_SQL Examples"</A
>" section provides other examples of array processing in DBMS_SQL. <A
CLASS="indexterm"
NAME="ch02-idx-20012-0"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.8.2"
>2.3.8.2 The DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-20085-0"
></A
>COLUMN_VALUE_LONG procedure</A
></H4
><P
CLASS="para"
>DBMS_SQL provides a separate procedure, COLUMN_VALUE_LONG, to allow you to retrieve <A
CLASS="indexterm"
NAME="ch02-idx-20093-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20093-1"
></A
>LONG values from a dynamic query. The header for this program is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.COLUMN_VALUE_LONG
    (c IN INTEGER
    ,position IN INTEGER
    ,length IN INTEGER
    ,offset IN INTEGER
    ,value OUT VARCHAR2
    ,value_length OUT INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The COLUMN_VALUE_LONG parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Pointer to the cursor.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>position</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Relative position of the column in the select list.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>length</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The length in bytes of the portion of the LONG value to be retrieved.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>offset</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The byte position in the LONG column at which the retrieval is to start.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>value</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The variable that will receive part or all of the LONG column value.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>value_length</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The actual length of the retrieved value.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The COLUMN_VALUE_LONG procedure offers just about the only way to obtain a <A
CLASS="indexterm"
NAME="ch02-idx-21409-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-21409-1"
></A
>LONG value from the database and move it into PL/SQL data structures in your program. You cannot rely on a static SELECT to do this. Instead, use DBMS_SQL and both the DEFINE_COLUMN_LONG and COLUMN_VALUE_LONG procedures.</P
><P
CLASS="para"
>The following example demonstrates the technique, and, in the process, offers a generic procedure called <A
CLASS="indexterm"
NAME="ch02-idx-21258-0"
></A
>dump_long that you can use to dump the contents of a long column in your table into a local PL/SQL table. The dump_long procedure accepts a table name, column name, and optional WHERE clause. It returns a    PL/SQL table with the LONG value broken up into 256-byte chunks. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch02-idx-24032-0"
></A
>dumplong.sp */
CREATE OR REPLACE PROCEDURE dump_long (
   tab IN VARCHAR2,
   col IN VARCHAR2,
   whr IN VARCHAR2 := NULL,
   pieces IN OUT DBMS_SQL.VARCHAR2S)
/* Requires Oracle 7.3 or above */
IS
   cur PLS_INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk PLS_INTEGER;

   TYPE long_rectype IS RECORD (
      piece_len PLS_INTEGER,
      pos_in_long PLS_INTEGER,
      one_piece VARCHAR2(256),
      one_piece_len PLS_INTEGER
      );
   rec long_rectype;

  BEGIN
       if whr is NULL */
   DBMS_SQL.PARSE (
      cur,
      'SELECT ' || col || 
      '  FROM ' || tab ||
      ' WHERE ' || NVL (whr, '1 = 1'),
      DBMS_SQL.NATIVE);

   /* Define the long column and then execute and fetch... */
   DBMS_SQL.DEFINE_COLUMN_LONG (cur, 1);
   fdbk := DBMS_SQL.EXECUTE (cur);
   fdbk := DBMS_SQL.FETCH_ROWS (cur);

   /* If a row was fetched, loop through the long value until 
   || all pieces are retrieved.
   */
   IF fdbk &gt; 0
   THEN
      rec.piece_len := 256;
      rec.pos_in_long := 0;
      LOOP
         DBMS_SQL.COLUMN_VALUE_LONG (
            cur,
            1,
            rec.piece_len,
            rec.pos_in_long,
            rec.one_piece,
            rec.one_piece_len);
         EXIT WHEN rec.one_piece_len = 0;

         /* Always put the new piece in the next available row */
         pieces (NVL (pieces.LAST, 0) + 1) := rec.one_piece;
         rec.pos_in_long := rec.pos_in_long + rec.one_piece_len;
      END LOOP;
   END IF;
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To test this procedure, I created a table with a LONG column as follows (the table creation, INSERT, and test script may all be found in dumplong.tst): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DROP TABLE nextbook;
CREATE TABLE nextbook 
   (title VARCHAR2(100), text LONG);
INSERT INTO nextbook VALUES  
   ('Oracle PL/SQL Quick Reference',
    RPAD ('INSTR ', 256, 'blah1 ') ||
    RPAD ('SUBSTR ', 256, 'blah2 ') ||
    RPAD ('TO_DATE ', 256, 'blah3 ') ||
    RPAD ('TO_CHAR ', 256, 'blah4 ') ||
    RPAD ('LOOP ', 256, 'blah5 ') ||
    RPAD ('IF ', 256, 'blah6 ') ||
    RPAD ('CURSOR ', 256, 'blah7 ') 
    );</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I then put together this short test script. It extracts the single value from the table. (I pass a NULL WHERE clause, so it simply returns the first&nbsp;-- and only&nbsp;-- row fetched.) It then uses a numeric FOR loop to scan through the returned table to display the results.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>  DECLARE
   mytab DBMS_SQL.VARCHAR2S;
BEGIN
   dump_long ('nextbook', 'text', NULL, mytab);
   FOR longind IN 1 .. mytab.COUNT
   LOOP
      DBMS_OUTPUT.PUT_LINE  (SUBSTR (mytab(longind), 1, 60));
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the output displayed in my SQL*Plus window:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSTR blah1 blah1 blah1 blah1 blah1 blah1 blah1 blah1 blah1
SUBSTR blah2 blah2 blah2 blah2 blah2 blah2 blah2 blah2 blah2
TO_DATE blah3 blah3 blah3 blah3 blah3 blah3 blah3 blah3 blah
TO_CHAR blah4 blah4 blah4 blah4 blah4 blah4 blah4 blah4 blah
LOOP blah5 blah5 blah5 blah5 blah5 blah5 blah5 blah5 blah5 b
IF blah6 blah6 blah6 blah6 blah6 blah6 blah6 blah6 blah6 bla
CURSOR blah7 blah7 blah7 blah7 blah7 blah7 blah7 blah7 <A
CLASS="indexterm"
NAME="ch02-idx-20097-0"
></A
>blah7<A
CLASS="indexterm"
NAME="ch02-idx-20087-0"
></A
></PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.8.3"
>2.3.8.3 The DBMS_SQL.VARIABLE_VALUE procedure</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-20099-0"
></A
>VARIABLE_VALUE procedure retrieves the value of a named variable from the specified PL/SQL block. You can retrieve the value for a single variable, or, with PL/SQL8, you can retrieve the values for an array or PL/SQL table of values. This is the header for the single-row version of the procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.VARIABLE_VALUE
    (c IN INTEGER
    ,name IN VARCHAR2
    ,value OUT &lt;datatype&gt;);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The VARIABLE_VALUE parameters are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The handle or pointer to the cursor originally returned by a call to OPEN_CURSOR.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the host variable included in the PL/SQL statement passed to PARSE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>value</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The PL/SQL data structure (either a scalar variable, &lt;datatype&gt;, or a PL/SQL table, &lt;table_type&gt;) that receives the value from the cursor.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>&lt;datatype&gt; can be one of the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>NUMBER
DATE
MLSLABEL
VARCHAR2 CHARACTER SET ANY_CS
BLOB
CLOB CHARACTER SET ANY_CS
BFILE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The header for the multiple-row version of VARIABLE_VALUE is the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.VARIABLE_VALUE
    (c IN INTEGER
    ,name IN VARCHAR2
    ,value IN &lt;table_type&gt;);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>&lt;table_type&gt; can be one of the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_SQL.NUMBER_TABLE
DBMS_SQL.VARCHAR2_TABLE
DBMS_SQL.DATE_TABLE
DBMS_SQL.BLOB_TABLE
DBMS_SQL.CLOB_TABLE
DBMS_SQL.BFILE_TABLE</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The DBMS_SQL package also offers more specific variants of VARIABLE_VALUE for less common datatypes:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.VARIABLE_VALUE_CHAR
    (c IN INTEGER
    ,name IN VARCHAR2
    ,value OUT CHAR CHARACTER SET ANY_CS);

PROCEDURE DBMS_SQL.VARIABLE_VALUE_RAW
    (c IN INTEGER
    ,name IN VARCHAR2
    ,value OUT RAW);

PROCEDURE DBMS_SQL.VARIABLE_VALUE_ROWID
    (c IN INTEGER
    ,name IN VARCHAR2
    ,value OUT ROWID);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you use the multiple-row version of VARIABLE_VALUE, you must have used the BIND_ARRAY procedure to define the bind variable in the PL/SQL block as an array of values.</P
><P
CLASS="para"
>The following program allows you to provide the name of a stored procedure, a list of IN parameters, and a single OUT variable. It then uses dynamic PL/SQL to construct and execute that stored procedure, and finally retrieves the OUT value and returns it to the calling block.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: <A
CLASS="indexterm"
NAME="ch02-idx-20753-0"
></A
>runprog.sp */
CREATE OR REPLACE PROCEDURE runproc 
   (proc IN VARCHAR2, arglist IN VARCHAR2, outval OUT NUMBER)
IS
   cur INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk INTEGER;
BEGIN
   DBMS_SQL.PARSE
     (cur, 'BEGIN ' || proc || '(' || arglist || ', :outparam); END;', 
      DBMS_SQL.NATIVE);

   DBMS_SQL.BIND_VARIABLE (cur, 'outparam', 1);

   fdbk := DBMS_SQL.EXECUTE (cur);
   
   DBMS_SQL.VARIABLE_VALUE (cur, 'outparam', outval);
   
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now if I have the following procedure defined:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE testdyn 
   (in1 IN NUMBER, in2 IN DATE, out1 OUT NUMBER)
IS
BEGIN
   out1 := in1 + TO_NUMBER (TO_CHAR (in2, 'YYYY'));
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Then I can execute testdyn dynamically as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   n NUMBER;
BEGIN
    runproc ('testdyn', '1, sysdate', n);
    DBMS_OUTPUT.PUT_LINE (n);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you have likely discerned, this is not a very good general-purpose program. It will work only with procedures that have parameter lists in which the last argument is a numeric OUT parameter and that argument must be the only OUT or IN OUT parameter in the list. </P
><P
CLASS="para"
>There can be many complications when attempting to execute dynamic PL/SQL. For suggestions on how best to perform these tasks, see the "Tips on Using Dynamic SQL" <A
CLASS="indexterm"
NAME="ch02-idx-20120-0"
></A
>section.<A
CLASS="indexterm"
NAME="ch02-idx-20121-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.9"
>2.3.9 Closing the Cursor </A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-22591-0"
></A
>When you are done working with a cursor, you should close it and release associated memory.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.9.1"
>2.3.9.1 The DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-22593-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-22593-1"
></A
>CLOSE_CURSOR procedure</A
></H4
><P
CLASS="para"
>The CLOSE_CURSOR procedure closes the specified cursor and sets the cursor handle to NULL. It releases all memory associated with the cursor. The specification for the procedure is,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.CLOSE_CURSOR 
   (c IN OUT INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where c is the handle or pointer to the cursor that was originally returned by a call to OPEN_CURSOR. The parameter is IN OUT because once the cursor is closed, the pointer is set to NULL.</P
><P
CLASS="para"
>If you try to close a cursor that is not open or that is not a valid cursor ID, this program will raise the INVALID_CURSOR exception. You might consider building a "wrapper" for CLOSE_CURSOR to avoid this exception.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE closeif (c IN OUT INTEGER)
IS
BEGIN
   IF DBMS_SQL.IS_OPEN (c)
   THEN
      DBMS_SQL.CLOSE_CURSOR (c); 
   END IF;
END;
/</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-SECT-3.10"
>2.3.10 Checking Cursor Status</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-21032-0"
></A
>Several functions allow you to check the status of a cursor.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.10.1"
>2.3.10.1 The DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-21034-0"
></A
>LAST_ERROR_POSITION function</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-20137-0"
></A
>The LAST_ERROR_POSITION function returns the byte offset in the SQL statement where the error occurred. The first character in the statement is at position 0. This function offers the same kind of feedback SQL*Plus offers you when it displays a syntax or value error while executing a SQL statement: it displays the problematic text with an asterisk (*) under the character that caused the problem. Here's the specification for this function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.LAST_ERROR RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You must call this function immediately after a call to EXECUTE or EXECUTE_AND_FETCH in order to obtain meaningful results. The following script demonstrates when and how this function's return value can come in handy:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: file<A
CLASS="indexterm"
NAME="ch02-idx-24037-0"
></A
> errpos.sql */*
DECLARE   
   cur BINARY_INTEGER := DBMS_SQL.OPEN_CURSOR;
   errpos BINARY_INTEGER;
   fdbk BINARY_INTEGER;
BEGIN
   DBMS_SQL.PARSE (cur, 'SELECT empno, ^a FROM emp', DBMS_SQL.NATIVE);
   DBMS_SQL.DEFINE_COLUMN (cur, 1, 1);
   fdbk := DBMS_SQL.EXECUTE_AND_FETCH (cur, false);
   DBMS_SQL.CLOSE_CURSOR (cur);
EXCEPTION
   WHEN OTHERS 
   THEN
      errpos := DBMS_SQL.LAST_ERROR_POSITION;
      DBMS_OUTPUT.PUT_LINE (SQLERRM || ' at pos ' || errpos);
      DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When I run this script in SQL*Plus, I get the following output:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @errpos
ORA-00936: missing expression at pos 14</PRE
></BLOCKQUOTE
><P
CLASS="para"
>One of the greatest frustrations with dynamic SQL is getting your string strung together improperly. It is very easy to introduce syntax errors. The DBMS_SQL.LAST_ERROR_POSITION function can be a big help in uncovering the source of your problem.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Some readers may be wondering why I declared a local variable called errpos and assigned the value to it before calling DBMS_OUTPUT.PUT_LINE to examine the error. The reason (discovered by Eric Givler, ace technical reviewer for this book) is that if I do not grab the value from this function before calling SQLERRM, the function will return 0 instead of the 14 for which I am looking.</P
></BLOCKQUOTE
><P
CLASS="para"
>If my exception section looks, for example, as follows,</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   WHEN OTHERS 
   THEN
      DBMS_OUTPUT.PUT_LINE 
         (SQLERRM || ' at pos ' || DBMS_SQL.LAST_ERROR_POSITION);
      DBMS_SQL.CLOSE_CURSOR (cur);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>then the output from running the program will become:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @errpos
ORA-00936: missing expression at pos 0</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Why does this happen? The <A
CLASS="indexterm"
NAME="ch02-idx-20321-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20321-1"
></A
>SQLERRM function must be executing an implicit SQL statement (probably a query!). This action resets the values returned by this DBMS_SQL function, since it is tied to the underlying, generic implicit cursor attribute.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.10.2"
>2.3.10.2 The DBMS_SQL.LAST_ROW_COUNT function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-20322-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20322-1"
></A
>LAST_ROW_COUNT function returns the total number of rows fetched at that point. This function corresponds to the %ROWCOUNT attribute of a normal, static cursor in PL/SQL. Here's the specification for this function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.LAST_ROW_COUNT RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You must call this function immediately after a call to EXECUTE_AND_FETCH or FETCH_ROWS in order to obtain meaningful results. You will most likely use this function when fetching from within a loop:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE show_n_emps (lim IN INTEGER)
IS
   cur PLS_INTEGER := DBMS_SQL.OPEN_CURSOR;
   fdbk PLS_INTEGER;
   v_ename emp.ename%TYPE;
BEGIN
   DBMS_SQL.PARSE (cur, 'SELECT ename FROM emp', DBMS_SQL.NATIVE);
   DBMS_SQL.DEFINE_COLUMN (cur, 1, v_ename, 100);
   fdbk := DBMS_SQL.EXECUTE (cur);
   LOOP
      EXIT WHEN DBMS_SQL.FETCH_ROWS (cur) = 0;
      IF DBMS_SQL.LAST_ROW_COUNT &lt;= lim
      THEN
         DBMS_SQL.COLUMN_VALUE (cur, 1, v_ename);
         DBMS_OUTPUT.PUT_LINE (v_ename);
      ELSE
         /* Hit maximum. Display message and exit. */
         DBMS_OUTPUT.PUT_LINE 
            ('Displayed ' || TO_CHAR (lim) || ' employees.');
         EXIT;
      END IF;
   END LOOP;
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.10.3"
>2.3.10.3 The DBMS_SQL.LAST_ROW_ID function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-20323-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20323-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20323-2"
></A
>LAST_ROW_ID function returns the ROWID of the row fetched most recently. The specification for this function is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.LAST_ROW_ID RETURN ROWID;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You must call this function immediately after a call to EXECUTE_AND_FETCH or FETCH_ROWS in order to obtain meaningful results. This function is useful mostly for <A
CLASS="indexterm"
NAME="ch02-idx-20324-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20324-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20324-2"
></A
>debugging purposes and perhaps to log which records have been affected.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.10.4"
>2.3.10.4 The DBMS_SQL.LAST_SQL_FUNCTION_CODE function</A
></H4
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch02-idx-20325-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20325-1"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20325-2"
></A
>LAST_SQL_FUNCTION_CODE function returns the SQL function code for the SQL statement. The specification for this function is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION DBMS_SQL.LAST_SQL_FUNCTION_CODE RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You must call this function immediately after a call to EXECUTE_AND_FETCH or EXECUTE in order to obtain meaningful results. It will tell you which type of SQL statement was executed.<A
CLASS="indexterm"
NAME="ch02-idx-21431-0"
></A
></P
><P
CLASS="para"
>The SQL function codes are listed in <A
CLASS="xref"
HREF="ch02_03.htm#ch02-SECT-3.4.1"
>Table 2.3</A
>.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch02-TABLE-13"
>Table 2.3: <A
CLASS="indexterm"
NAME="ch02-idx-21434-0"
></A
>SQL Function Codes </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Code</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SQL Function</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Code</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SQL Function</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Code</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SQL Function</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>01</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE TABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>35</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LOCK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>69</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>(NOT USED)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>02</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SET ROLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>36</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NOOP</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>70</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER RESOURCE COST</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>03</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INSERT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>37</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>RENAME</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>71</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE SNAPSHOT LOG</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>04</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SELECT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>38</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COMMENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>72</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER SNAPSHOT LOG</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>05</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UPDATE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>39</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>AUDIT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>73</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP SNAPSHOT LOG</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>06</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP ROLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>40</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NO AUDIT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>74</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE SNAPSHOT</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>07</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP VIEW</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>41</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER INDEX</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>75</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER SNAPSHOT</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>08</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP TABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>42</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE EXTERNAL DATABASE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>76</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP SNAPSHOT</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>09</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DELETE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>43</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP EXTERNAL DATABASE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>77</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE TYPE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>10</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE VIEW</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>44</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE DATABASE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>78</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP TYPE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>11</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP USER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>45</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER DATABASE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>79</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER ROLE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>12</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE ROLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>46</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE ROLLBACK SEGMENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>80</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER TYPE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>13</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE SEQUENCE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>47</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER ROLLBACK SEGMENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>81</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE TYPE BODY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>14</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER SEQUENCE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>48</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP ROLLBACK SEGMENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>82</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER TYPE BODY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>15</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>(NOT USED)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>49</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE TABLESPACE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>83</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP TYPE BODY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>16</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP SEQUENCE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>50</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER TABLESPACE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>84</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP LIBRARY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>17</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE SCHEMA</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>51</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP TABLESPACE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>85</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRUNCATE TABLE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>18</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE CLUSTER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>52</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER SESSION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>86</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRUNCATE CLUSTER</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>19</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE USER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>53</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER USER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>87</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE BITMAPFILE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>20</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE INDEX</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>54</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COMMIT (WORK)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>88</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER VIEW</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>21</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP INDEX</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>55</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROLLBACK</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>89</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP BITMAPFILE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>22</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP CLUSTER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>56</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SAVEPOINT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>90</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SET CONSTRAINTS</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>23</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VALIDATE INDEX</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>57</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE CONTROL FILE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>91</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE FUNCTION</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>24</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE PROCEDURE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>58</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER TRACING</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>92</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER FUNCTION</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>25</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER PROCEDURE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>59</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE TRIGGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>93</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP FUNCTION</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>26</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER TABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>60</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER TRIGGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>94</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE PACKAGE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>27</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>EXPLAIN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>61</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP TRIGGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>95</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER PACKAGE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>28</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>GRANT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>62</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ANALYZE TABLE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>96</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP PACKAGE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>29</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>REVOKE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>63</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ANALYZE INDEX</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>97</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE PACKAGE BODY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>30</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE SYNONYM</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>64</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ANALYZE CLUSTER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>98</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER PACKAGE BODY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>31</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP SYNONYM</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>65</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE PROFILE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>99</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP PACKAGE BODY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>32</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER SYSTEM SWITCH LOG</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>66</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP PROFILE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>157</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE DIRECTORY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>33</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SET TRANSACTION</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>67</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ALTER PROFILE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>158</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP DIRECTORY</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>34</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PL/SQL EXECUTE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>68</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DROP PROCEDURE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>159</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CREATE LIBRARY</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch02-21178"
>2.3.11 Describing Cursor Columns </A
></H3
><P
CLASS="para"
>With PL/SQL8, you can now obtain information about the structure of the columns of your dynamic cursor.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch02-SECT-3.11.1"
>2.3.11.1 The DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-20327-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20327-1"
></A
>DESCRIBE_COLUMNS procedure</A
></H4
><P
CLASS="para"
>The DESCRIBE_COLUMNS procedure obtains information about your dynamic cursor. Here is the header:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE DBMS_SQL.DESCRIBE_COLUMNS
    (c IN INTEGER
    ,col_cnt OUT INTEGER
    ,desc_t OUT DBMS_SQL.DESC_TAB);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parameters for the DESCRIBE_COLUMNS procedure are summarized in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>c</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The pointer to the cursor.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_cnt</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The number of columns in the cursor, which equals the number of rows defined in the PL/SQL table.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>desc_t</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The PL/SQL table, which contains all of the column information. This is a table of records of type DBMS_SQL.DESC_REC (&lt;table_type), which is described later.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The following table lists the DBMS_SQL.DESC_REC record type fields.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>&lt;table_type&gt;</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Datatype</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_type</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Type of column described</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_max_len</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Maximum length of column value</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VARCHAR2(32)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of the column</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_name_len</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Length of the column name</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_schema_name</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VARCHAR2(32)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name of column type schema if an object type</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_schema_name_len</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Length of schema name</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_precision</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Precision of column if a number</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_scale</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Scale of column if a number</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_charsetid</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ID of character set</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_charsetform</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Character set form</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>col_null_ok</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BOOLEAN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRUE if column can be NULL</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The values for column types are as follows:<A
CLASS="indexterm"
NAME="ch02-idx-20578-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20578-1"
></A
></P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Datatype</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Number</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VARCHAR2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NVARCHAR2</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NUMBER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>2</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INTEGER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>2</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LONG</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>8</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROWID</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>11</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DATE</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>12</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>RAW</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>23</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LONG RAW</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>24</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CHAR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>96</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NCHAR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>96</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>MLSLABEL</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>106</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>CLOB (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>112</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NCLOB (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>112</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BLOB (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>113</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BFILE (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>114</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Object type (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>121</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Nested table Type (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>122</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Variable array (Oracle8)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>123</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>When you call this program, you need to have declared a PL/SQL table based on the DBMS_SQL.<A
CLASS="indexterm"
NAME="ch02-idx-20331-0"
></A
>DESC_T. You can then use PL/SQL table methods to traverse the table and extract the needed information about the cursor. The following anonymous block shows the basic steps you will perform when working with this built-in:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   cur PLS_INTEGER := DBMS_SQL.OPEN_CURSOR;
   cols DBMS_SQL.DESC_T;
   ncols PLS_INTEGER;
BEGIN
   DBMS_SQL.PARSE 
      (cur, 'SELECT hiredate, sal FROM emp', DBMS_SQL.NATIVE);
   DBMS_SQL.DEFINE_COLUMN (cur, 1, SYSDATE);
   DBMS_SQL.DEFINE_COLUMN (cur, 2, 1);
   DBMS_SQL.DESCRIBE_COLUMNS (cur, ncols, cols);
   FOR colind IN 1 .. ncols
   LOOP
      DBMS_OUTPUT.PUT_LINE (cols.col_name);
   END LOOP;
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you are going to use this procedure to extract information about a dynamic cursor, you will likely want to build a "wrapper" around it to make it easier for you to get at this data. The <A
CLASS="xref"
HREF="ch02_05.htm#ch02-SECT-5.1"
>Section 2.5</A
>" section at the end of this chapter offers an example of this wrapper.<A
CLASS="indexterm"
NAME="ch02-idx-20329-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-20329-1"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&#13;</PRE
></BLOCKQUOTE
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="ch02-TABLE-17"
>How'd He Get Those Numbers?</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch02-idx-23608-0"
></A
><A
CLASS="indexterm"
NAME="ch02-idx-23608-1"
></A
>The Oracle documentation for DBMS_SQL tells us only that the col_type field of the DBMS_REC record contains the "type of the column being described" and that the type is an INTEGER. Well, what exactly are those integer values? I could have sent email to someone at Oracle Corporation and waited for a response. But even then, how would I be sure that those values are correct? And why depend on another person, when I can depend on the software itself?</P
><P
CLASS="para"
>To figure out the different column type values, I first constructed a table as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE coltypes
   (vc VARCHAR2(10),
    nvc NVARCHAR2(10),
    ch CHAR(10),
    nch NCHAR(10),
    d DATE,
    n NUMBER,
    i INTEGER,
    l LONG,
    r RAW(100),
    rid ROWID,
    cl CLOB,
    ncl NCLOB,
    bl BLOB,
    bf BFILE,
    msl MLSLABEL
    )
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>These columns pretty much cover all of the datatypes through Oracle8. I then built a script which relies on the desccols package to call the DESCRIBE_COLUMNS procedure (see the <A
CLASS="xref"
HREF="ch02_05.htm#ch02-SECT-5.1"
>Section 2.5</A
>" section) and display the column information, including the column types.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: desccols.xmn */
DECLARE
   cur integer := dbms_sql.open_cursor;
   cl CLOB;
   bl BLOB;
   ncl NCLOB;
   bf BFILE;
   msl MLSLABEL;
   r RAW(100);
   rid ROWID;
BEGIN
   dbms_sql.PARSE (cur, 'SELECT vc, nvc, ch, nch, d, n, i, l, r, rid, cl, ncl, bl, bf, msl FROM coltypes', DBMS_SQL.NATIVE);
   DBMS_SQL.DEFINE_COLUMN (cur, 1, 'a', 10);
   DBMS_SQL.DEFINE_COLUMN (cur, 2, 'a', 10);
   DBMS_SQL.DEFINE_COLUMN_CHAR (cur, 3, 'a', 10);
   DBMS_SQL.DEFINE_COLUMN_CHAR (cur, 4, 'a', 10);
   DBMS_SQL.DEFINE_COLUMN (cur, 5, SYSDATE);  
   DBMS_SQL.DEFINE_COLUMN (cur, 6, 1);
   DBMS_SQL.DEFINE_COLUMN (cur, 7, 1);
   DBMS_SQL.DEFINE_COLUMN_LONG (cur, 8);
   DBMS_SQL.DEFINE_COLUMN_RAW (cur, 9, r, 10);
   DBMS_SQL.DEFINE_COLUMN_ROWID (cur, 10, rid);
   DBMS_SQL.DEFINE_COLUMN (cur, 11, cl);
   DBMS_SQL.DEFINE_COLUMN (cur, 12, ncl);
   DBMS_SQL.DEFINE_COLUMN (cur, 13, bl);
   DBMS_SQL.DEFINE_COLUMN (cur, 14, bf);
   DBMS_SQL.DEFINE_COLUMN (cur, 15, msl);
   dyncur.desccols (cur);
   dyncur.show;
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/
</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and I got this output:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Column 1
VC
1
Column 2
NVC
1
Column 3
CH
96
Column 4
NCH
96
Column 5
D
12
Column 6
N
2
Column 7
I
2
Column 8
L
8
Column 9
R
23
Column 10
RID
11
Column 11
CL
112
Column 12
NCL
112
Column 13
BL
113
Column 14
BF
114
Column 15
MSL
106
</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I could then document those values with confidence in this book. I wanted to show you this so that you understand that even when a person knows an <EM
CLASS="emphasis"
>awful</EM
> lot about PL/SQL, he doesn't necessarily know everything. In fact, knowing everything is completely impossible and anyone claiming to &quot;know it all&quot; should not be trusted. Recognize your areas of ignorance and then search out the answers, preferably by going to the source&nbsp;-- the source code, that is.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch02_02.htm#ch02-SECT-2.3"
TITLE="2.2 Getting Started with DBMS_SQL"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.2 Getting Started with DBMS_SQL"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Built-in Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Built-in Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch02_04.htm#ch02-SECT-4.5"
TITLE="2.4 Tips on Using Dynamic SQL"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.4 Tips on Using Dynamic SQL"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>2.2 Getting Started with DBMS_SQL</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>2.4 Tips on Using Dynamic SQL</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
