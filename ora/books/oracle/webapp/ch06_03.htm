<HTML
><HEAD
><TITLE
>[Chapter 6] 6.3 Packages</TITLE
><META
NAME="DC.Creator"
CONTENT="Andrew Odewahn"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:36:23Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CDROM-1-56592-687-0E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-687-0E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Web 8i"><META
NAME="DC.Title"
CONTENT="Oracle Web Applications: PL/SQL Developer's Introduction"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. PL/SQL"><LINK
REL="prev"
HREF="ch06_02.htm#BOOK-CH-6-SECT-2.3"
TITLE="6.2 Programming Constructs"><LINK
REL="next"
HREF="ch06_04.htm"
TITLE="6.4 PL/SQL Tools"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_02.htm#BOOK-CH-6-SECT-2.3"
TITLE="6.2 Programming Constructs"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.2 Programming Constructs"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch06_01.htm"
TITLE="6. PL/SQL"
>Chapter 6<BR>PL/SQL</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_04.htm"
TITLE="6.4 PL/SQL Tools"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.4 PL/SQL Tools"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="BOOK-CH-6-SECT-3"
>6.3 Packages</A
></H2
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="ch-06-packages"
></A
> <A
CLASS="indexterm"
NAME="ch-06-plsql_packages"
></A
>  Now that we've looked at PL/SQL's structure and its most common programming constructs, we're ready to group these elements into tidy little structures called packages. A <EM
CLASS="emphasis"
>package</EM
> is a container (hence the name) for other PL/SQL elements, such as variables and constants, procedures and functions, and datatype definitions. </P
><P
CLASS="para"
>A package has two parts: a specification and a body. The specification is a sort of table of contents that lists the items in the package. The body contains the implementations for each item. For example, the specification tells us "This package contains a procedure named `foo', which has the following parameters." The body of the package contains the actual implementation of foo. </P
><P
CLASS="para"
>Packages are the most powerful and useful PL/SQL constructs because they help us build standard code libraries with well-defined application programming interfaces  <A
CLASS="indexterm"
NAME="AUTOID-4248"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4250"
></A
> (APIs). In a web environment, for example, you can create standard libraries to handle security, page formatting, or list of values (LOV) generation. Each time you build a new application, you can just plunk in calls to these standard libraries, rather than reinventing them for each new system. Packages are also excellent for building  <A
CLASS="indexterm"
NAME="AUTOID-4252"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4254"
></A
> abstract data types (ADTs), a fancy terminology for structures like stacks, lists, and queues. </P
><P
CLASS="para"
>Prebuilt packages with clear APIs encourage software reuse, the Holy Grail of software engineering. In this final section, we'll learn how to use packages effectively. We'll start by looking at the structure of the specification and the body, and then move on to how to use a package within other programs. After that, we'll look at how to hide the implementation details of a package to create a "black box." Finally, we'll look at package persistence. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-6-SECT-3.1"
>6.3.1 The Package Specification</A
></H3
><P
CLASS="para"
>The specification defines the package's API, which governs every aspect of how the package is used. The specification lists the headers of the procedures and functions in the API, as well as any variables, types, cursors, or constants necessary to interface with the package. These last items are global variables, accessible both from inside and outside the package. The headers and declarations in the specification are called <EM
CLASS="emphasis"
>public</EM
> elements because they are the interface between the package and the outside world. </P
><P
CLASS="para"
>You might see the specification as an afterthought, if not a downright nuisance, that stands in the way of your real work. Nothing could be further from the truth. The success or failure of a package almost always depends on a clean, crisp interface that is simple to understand and use. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-6-SECT-3.2"
>6.3.2 The Package Body</A
></H3
><P
CLASS="para"
>The package body contains the actual code for the modules in the specification. It must include a complete implementation of each of these modules. Additionally, it can also include procedures and functions not listed in the specification, as well as declarations for variables, types, cursors, and constants. These elements, invisible to the outside world, are <EM
CLASS="emphasis"
>private</EM
> because they can be referenced only from within the body itself. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-6-SECT-3.3"
>6.3.3 Example</A
></H3
><P
CLASS="para"
>Designing a good package takes practice. A package should be rich enough to support a wide variety of complex activities, yet simple enough to grasp quickly. As with any other art, the best place to learn package design is from the classics, so in this section we'll create a stack package based on an index-by table. Here's the specification: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Formatted by PL/Formatter v.1.1.13 */
CREATE OR REPLACE PACKAGE stack
IS
   
   /*------------------------------------------------------
   || Global type declaration
   */------------------------------------------------------
   TYPE stack_array IS TABLE OF VARCHAR2(2000)
      INDEX BY BINARY_INTEGER;
   
   /*-------------------------------------------------------
   || Global API declaration
   */-------------------------------------------------------
   -- Initialize the stack
   PROCEDURE init;
   
   -- Push an item onto the stack
   PROCEDURE push (item IN VARCHAR2);
   
   -- Return the first element on the stack
   FUNCTION pop
      RETURN VARCHAR2;
   
   -- Return a boolean if the stack is empty
   FUNCTION is_empty
      RETURN BOOLEAN;
   
   -- Copy the stack into an array
   PROCEDURE copy_to_array (
      s OUT stack_array,
      num_elements OUT NUMBER
      );

END stack;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Our next step is to actually implement each of the procedures and functions listed in the specification. Here's the body of the stack package: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Formatted by PL/Formatter v.1.1.13 */
CREATE OR REPLACE PACKAGE BODY stack
IS
   
   /*------------------------------------------------------
   || Local declarations
   */------------------------------------------------------
   -- Declare stack data structure
   local_stack stack_array;   
   -- Declare index to top of stack
   top NUMBER DEFAULT 0;

   /*-------------------------------------------------------
   || Implementation
   */-------------------------------------------------------

   /*
   || Initialize the stack
   */
   PROCEDURE init
   IS
   BEGIN
      top := 0;
   END init;
   
   /*
   || Push an item onto the stack.
   || Since PL/SQL arrays are unconstrained, we never have    
   || to worry about pushing too many elements!
   */
   PROCEDURE push (item IN VARCHAR2)
   IS
   BEGIN
      top := top + 1;
      local_stack  (top) := item;
   END push;
   
   /*
   || Return a boolean if the stack is empty
   */
   FUNCTION is_empty
      RETURN BOOLEAN
   IS
   BEGIN
      IF top = 0
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END is_empty;
   
   /*
   || Return the first element on the stack. 
   || Return NULL if the stack is empty.
   */
   FUNCTION pop
      RETURN VARCHAR2
   IS
      item_to_return VARCHAR2(2000);
   BEGIN
      IF is_empty
      THEN
         item_to_return := NULL;
      ELSE
         item_to_return := local_stack (top);
         top := top - 1;
      END IF;
      RETURN item_to_return;
   END pop;
   
   /*
   || Copy the stack into an array
   */
   PROCEDURE copy_to_array (
      s OUT stack_array,
      num_elements OUT NUMBER
      )
   IS
   BEGIN
      -- Set the number of elements
      num_elements := top;
      -- Load each element into the array
      FOR i IN 1 .. top
      LOOP
         s  (i) := local_stack (i);
      END LOOP;
   END copy_to_array;

END stack;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-6-SECT-3.4"
>6.3.4 Using a Package</A
></H3
><P
CLASS="para"
>After we've created the package specification and body, we can start using it in other procedures and functions. You use the following syntax to refer to a public element (variable, procedure, function, etc.) in a package: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
><I
CLASS="replaceable"
>package_name.public_element_name</I
></PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following sample illustrates how to use the stack package developed in the last section: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Formatted by PL/Formatter v.1.1.13 */
CREATE OR REPLACE PROCEDURE test_stack
IS
   stack_copy stack.stack_array;
   stack_size NUMBER;
BEGIN
   --Push some test data onto the stack
   FOR i IN 1 .. 10
   LOOP
      stack.push (i);
   END LOOP;
   
   -- Make a copy of the stack
   
   stack.copy_to_array (stack_copy, stack_size);
   
   -- Pop all elements off the stack
   WHILE NOT stack.is_empty
   LOOP
      DBMS_OUTPUT.put_line (stack.pop);
   END LOOP;
   
   -- Print the copied elements
   FOR i IN 1 .. stack_size
   LOOP
      DBMS_OUTPUT.put_line (stack_copy (i));
   END LOOP;

END test_stack;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-6-SECT-3.5"
>6.3.5 Information Hiding</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4282"
></A
> You might have noticed in the stack example that we declared the local_stack and the top variable inside the body, rather than in the specification. This is an example of <EM
CLASS="emphasis"
>information hiding</EM
>, a technique that's used to hide a package's implementation details from its users. </P
><P
CLASS="para"
>A package should be a black box; input comes in one side and predictable output goes out the other. The details between these steps should be invisible to everyone except the package's developer. It's amazing how often knowing how something works can get us into trouble. How many times have you written one program to take advantage of a bug in another? These shortcuts turn bugs into permanent fixtures. Information hiding eliminates the possibility of this problem by forcing everyone to use the package the way it was intended to be used. </P
><P
CLASS="para"
>Access to the internal workings of a package can cause problems even when the workaround seems perfectly innocent. To return to our original example, if the local_stack and top variables in the stack example were declared in the package specification, and not hidden away in the body, a developer in a rush might be tempted to write a program to bypass the stack directly, as you can see here: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/*
|| Quick procedure to print stack
*/
CREATE OR REPLACE PROCEDURE show_stack
   i NUMBER DEFAULT 0;
IS
BEGIN
   FOR i IN REVERSE 1 .. STACK.top
   LOOP
      DBMS_OUTPUT.put_line (STACK.local_stack (i));
   END LOOP;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This shortcut depends on the stack being implemented as an index-by table. If we decided to redesign the package to represent the stack in another way (for example, using an object type we can store directly in the database), it would break this program and every other program that made a similar use of the package's public data structures. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-6-SECT-3.6"
>6.3.6 Variable Persistence Throughout a Session</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4292"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4294"
></A
> Package variables, whether they are declared in the specification or the body, maintain their values throughout a session. All values are initialized when a session begins and are lost when it ends. This is called <EM
CLASS="emphasis"
>persistence</EM
> because the values remain, or persist, even when the package is not being directly used. Only package variables declared as part of the specification or body persist. Variables declared inside a procedure or function do not. </P
><P
CLASS="para"
>For example, suppose you log into SQL*Plus and push a few elements onto the stack. After that, you execute a few SELECT statements, issue some updates, and describe a table or two. Finally, before you're ready to log out, you call the test_stack procedure. When it executes, not only does it print "1" through "10," it also prints the elements you manually added at the beginning of the session. PL/SQL remembered the previous elements, even though you've been doing other things. However, if you logged out and reconnected before running the test_stack procedure, the previous elements disappear, because variables persist only throughout a single session. </P
><P
CLASS="para"
>In <A
CLASS="xref"
HREF="ch07_01.htm"
>Chapter 7, <CITE
CLASS="chapter"
>The PL/SQL Toolkit</CITE
></A
>, we'll look at some strategies to mimic persistence in the web environment. </P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_02.htm#BOOK-CH-6-SECT-2.3"
TITLE="6.2 Programming Constructs"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.2 Programming Constructs"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Web Applications: PL/SQL Developer's Introduction"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_04.htm"
TITLE="6.4 PL/SQL Tools"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.4 PL/SQL Tools"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.2 Programming Constructs</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.4 PL/SQL Tools</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
