<HTML
><HEAD
><TITLE
>[Chapter 7] 7.3 Maintaining State</TITLE
><META
NAME="DC.Creator"
CONTENT="Andrew Odewahn"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:36:49Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CDROM-1-56592-687-0E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-687-0E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Web 8i"><META
NAME="DC.Title"
CONTENT="Oracle Web Applications: PL/SQL Developer's Introduction"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch07_01.htm"
TITLE="7. The PL/SQL Toolkit"><LINK
REL="prev"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
TITLE="7.2 Text Processing"><LINK
REL="next"
HREF="ch07_04.htm#BOOK-CH-7-SECT-4.1.5"
TITLE="7.4 Improving Productivity"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
TITLE="7.2 Text Processing"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.2 Text Processing"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch07_01.htm"
TITLE="7. The PL/SQL Toolkit"
>Chapter 7<BR>The PL/SQL Toolkit</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_04.htm#BOOK-CH-7-SECT-4.1.5"
TITLE="7.4 Improving Productivity"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.4 Improving Productivity"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3"
>7.3 Maintaining State</A
></H2
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="ch-07-main_state"
></A
> The inability to save information, or state, throughout a session is one of HTML's major limitations. HTML has no client/server type variables that remember things as the user moves from page to page. For example, if we want to use a piece of information entered by a user on the first page of a web system, we must save it somehow and be able to recall it later. There are four basic ways to do this: saving the information as part of a query string in a URL, saving it in a hidden field, saving it in a database table, or saving it in a cookie file by using the OWA_COOKIE package, described later in this section. In this section, we'll look at each method and discuss possible problems you may run into. </P
><P
CLASS="para"
>The first way to maintain state, using a query string of a URL, is the most straightforward: you simply build the string as you go, placing the information you want to pass from screen to screen in name/value pairs. These values are then passed to the procedure specified in the URL's <CODE
CLASS="literal"
>href</CODE
> attribute when the user clicks on the hyperlink. The disadvantages to this approach include the following: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Depending on the system, the maximum length of the URL is limited to 256 characters. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Each value must be encoded to the CGI specification. It can be easy to forget to do this if you're in a rush. </P
></LI
></UL
><P
CLASS="para"
>The second way to save state information is to store it in hidden fields. A hidden field is simply an invisible input element that is part of an HTML form. Although the user cannot see the value on the screen, the hidden field is stored as part of the underlying HTML code. To maintain a value across multiple sessions, all we have to do is include the value as a hidden field on the form. You create a hidden field by setting the <CODE
CLASS="literal"
>type</CODE
> attribute of an <CODE
CLASS="literal"
>&lt;input&gt;</CODE
> element to "hidden," as in the following example: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;input type=hidden name=user_id value=&quot;10235&quot;&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The disadvantages of this approach include the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Every procedure must include a corresponding parameter for the hidden value. While this might be okay for a small number of fields, it quickly becomes unworkable for larger numbers (this also applies when embedding the information in a URL). </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Each procedure must include the code to reproduce the hidden fields as part of its output. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Hidden fields are insecure since almost all browsers have a "View Source" option that allows users to look at the underlying HTML code, making hidden fields of limited value when security is an issue. </P
></LI
></UL
><P
CLASS="para"
>The third method for maintaining state simply saves the information in a table and uses a SELECT statement to retrieve it later. However, there are two problems with this approach: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>It requires a hit against a table to both save and recall a piece of information. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>We need something to use as a primary key, carried across each page, to associate the state information with a particular session. The simplest way to do this is to store the client's IP address as part of a primary key. We can use this address, which is simple to obtain, when we want to recall the information later. </P
></LI
></UL
><P
CLASS="para"
>The fourth method is to save state information using <EM
CLASS="emphasis"
>cookies</EM
>. Each cookie has a name and one or more associated values, and is saved either as a record on the user's machine or as an environment variable on the web server. In either case, it is accessible throughout (and sometimes even after) a user's session. You create a cookie on a user's browser by embedding HTML-like commands into the MIME header of a page. For example, the following set of instructions creates two cookies (notice that the second has multiple values): </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Set-Cookie: username=odewahn
Set-Cookie: city=BOSTON; city=CHICAGO; city=NEW YORK</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Some disadvantages of this approach are:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Cookies were originally introduced by Netscape and are not part of the HTML standard. However, they have become a popular way to overcome statelessness and are now supported by most browsers. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Cookies that are saved on a user's machine (and don't expire) tie the user to that specific machine. For example, many Internet storefronts use cookies to save your user information. When you visit the site, the server reads the cookies and thinks it's you. When someone else borrows or uses your computer, though, this information is still stored on the machine, which can lead to problems. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Cookies can be turned off. Most browsers allow users to reject cookies, usually out of privacy concerns. Consequently, you can't save any state information to those users' machines. </P
></LI
></UL
><P
CLASS="para"
>In the next section, we'll look at the toolkit package for manipulating cookies. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.1"
>7.3.1 OWA_COOKIE: Storing Cookies</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5447"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5450"
></A
> The OWA_COOKIE package contains procedures that allow us to create, access, and even update cookies within PL/SQL. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.1.1"
>7.3.1.1 Data structures</A
></H4
><P
CLASS="para"
>A cookie can have multiple values that can be as large as 4K. These are stored in an array named vc_arr: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE vc_arr IS TABLE OF VARCHAR2(4096)
   INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> The vc_arr used in OWA_COOKIE is not the same as the one used in OWA_TEXT.</P
></BLOCKQUOTE
><P
CLASS="para"
>The cookie itself is represented with a record that holds its name, its values, and the number of these values: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE cookie IS RECORD (
   name VARCHAR2(4096),
   vals vc_arr,
   num_vals INTEGER
);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.1.2"
>7.3.1.2 Procedures and functions</A
></H4
><P
CLASS="para"
>The procedures and functions of OWA_COOKIE read, create, and remove cookies. The instructions to read cookies retrieve those cookies from the browser and store their values in a cookie variable. Creating or removing the cookies is slightly trickier. <A
CLASS="xref"
HREF="ch07_03.htm#BOOK-CH-7-SECT-3.2.2"
>Table 7.13</A
> shows the procedures and functions for OWA_COOKIE, along with their parameters. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-26"
>Table 7.13: Various OWA_COOKIE Procedures and Functions </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Procedure/Function</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Parameters</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5482"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5484"
></A
> GET</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>name IN VARCHAR2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Generates instructions to retrieve a specified cookie from the browser and store its value in a cookie variable </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5494"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5496"
></A
> GET_ALL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>names OUT owa_cookie.vc_arr</P
>  <P
CLASS="para"
>vals OUT owa_cookie.vc_arr</P
>  <P
CLASS="para"
>num_vals OUT INTEGER</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Generates instructions to retrieve the names and values of all unexpired cookies </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5508"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5510"
></A
> SEND</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>name IN VARCHAR2</P
>  <P
CLASS="para"
>value IN VARCHAR2</P
>  <P
CLASS="para"
>expires IN DATE DEFAULT NULL</P
>  <P
CLASS="para"
>path IN VARCHAR2 DEFAULT NULL</P
>  <P
CLASS="para"
>domain IN VARCHAR2 DEFAULT NULL</P
>  <P
CLASS="para"
>SECURE IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Generates instructions to create a cookie</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5525"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5527"
></A
> REMOVE</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>name IN VARCHAR2</P
>  <P
CLASS="para"
>value IN VARCHAR2</P
>  <P
CLASS="para"
>path IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Generates instructions to delete a cookie</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Like the procedures of the HTP package, the OWA_COOKIE procedures and functions generate instructions that are sent to the browser for processing. Unlike normal HTML tags, however, these instructions must appear outside the normal document in a section called the HTTP header. To place instructions in the header, we must use the MIME_HEADER and HTTP_HEADER_CLOSE procedures from the OWA_UTIL package. Please see <A
CLASS="xref"
HREF="ch07_04.htm#BOOK-CH-7-SECT-4.1.5"
>Section 7.4.1.4, "HTML and HTTP utilities"</A
>, later in this chapter, for a detailed discussion of these procedures. </P
><P
CLASS="para"
>The following snippet shows how the OWA_UTIL procedures are used to create cookies: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/*
|| FALSE value in mime_header keeps the header open 
|| so we can insert the cookie into the header section
*/
OWA_UTIL.mime_header ('text/html', FALSE);
OWA_COOKIE.send ('city', 'BOSTON');
OWA_COOKIE.send ('city', 'CHICAGO');
OWA_COOKIE.send ('city', 'NEW YORK');
OWA_UTIL.http_header_close;  -- Now close the header
HTP.print ('&lt;html&gt;');
...</PRE
></BLOCKQUOTE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.1.2.1"
>7.3.1.2.1 The SEND procedure.</A
></H4
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5543"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5545"
></A
>  This procedure generates the instruction to create a cookie. As noted, this instruction must appear inside the HTTP header. The parameters for the procedure are as follows: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>name IN VARCHAR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Name of the cookie.</P
></DD
><DT
CLASS="term"
>value IN VARCHAR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Value of the cookie.</P
></DD
><DT
CLASS="term"
>expires IN DATE DEFAULT NULL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Expiration date; the cookie is deleted after the specified date. If omitted, it never expires. Also note that the time zone must match the settings in OWA_INIT. </P
></DD
><DT
CLASS="term"
>path IN VARCHAR2 DEFAULT NULL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If a path is specified, the server sends the cookie only when the URL of the request matches the path; this make the cookie available only to those requests that match the specified path. </P
></DD
><DT
CLASS="term"
>domain IN VARCHAR2 DEFAULT NULL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Like the path, the server sends the cookie only if the domain (i.e., www.oreilly.com) matches the URL of the request, allowing you to prevent a cookie from being sent if the domain (the server section of the URL) matches the specified path. </P
></DD
><DT
CLASS="term"
>SECURE IN VARCHAR2 DEFAULT NULL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If non-NULL, the keyword SECURE is added to the cookie; if added, the cookie is sent only if the client and server are connected through a secure protocol like HTTPS. </P
></DD
></DL
><P
CLASS="para"
>SEND produces a string based on the following template:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Set-Cookie: name=<I
CLASS="replaceable"
>value</I
> expires=<I
CLASS="replaceable"
>expires</I
> path=<I
CLASS="replaceable"
>path</I
> domain=<I
CLASS="replaceable"
>domain</I
> secure</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following procedure illustrates the use of the SEND procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE send_cookie (
   cookie_name IN VARCHAR2 DEFAULT NULL,
   cookie_val IN VARCHAR2 DEFAULT NULL
   )
IS

BEGIN
   -- Cookies must be set within the header
   OWA_UTIL.mime_header ('text/html', FALSE);
   -- Send a cookie if a name was entered
   IF cookie_name IS NOT NULL
   THEN
      OWA_COOKIE.send (cookie_name, cookie_val);
   END IF;
   OWA_UTIL.http_header_close;
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.1.2.2"
>7.3.1.2.2 The REMOVE procedure.</A
></H4
><P
CLASS="para"
>This procedure causes a cookie to immediately expire and, like SEND, must be used inside the HTTP header. The parameters are: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>name IN VARCHAR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The name of the cookie to remove.</P
></DD
><DT
CLASS="term"
>value IN VARCHAR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The value of the cookie to remove.</P
></DD
><DT
CLASS="term"
>path IN VARCHAR2 DEFAULT NULL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The path of the cookie to remove.</P
></DD
></DL
><P
CLASS="para"
>REMOVE produces the following template:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Set-Cookie: name=<I
CLASS="replaceable"
>value</I
> expires=01-JAN-1990 path=<I
CLASS="replaceable"
>path</I
></PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.1.2.3"
>7.3.1.2.3 The GET function.</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5604"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5606"
></A
> This function retrieves the value for the specified cookie and returns it as a cookie datatype. Unlike SEND or REMOVE, GET is not limited to the header and may appear anywhere within a procedure. It has one parameter: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>name IN VARCHAR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Name of the cookie to retrieve.</P
></DD
></DL
><P
CLASS="para"
>The following example illustrates the GET procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE get_cookie (
   cookie_name IN VARCHAR2 DEFAULT NULL
   )
IS
   
   target_cookie OWA_COOKIE.cookie;

BEGIN
   target_cookie := OWA_COOKIE.get (cookie_name);
   -- Print message if the cookie was not found
   IF target_cookie.num_vals = 0
   THEN
      HTP.print ('&lt;h1&gt;Cookie not found!&lt;/h1&gt;');
   ELSE
      HTP.print ('&lt;h1&gt;Values for cookie ' ||
                 cookie_name ||
                 '&lt;/h1&gt;&lt;hr&gt;');
      FOR i IN 1 .. target_cookie.num_vals
      LOOP
         HTP.print (target_cookie.vals (i) || '&lt;p&gt;');
      END LOOP;
   END IF;
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.1.2.4"
>7.3.1.2.4 The GET_ALL procedure.</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5619"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5621"
></A
> This procedure retrieves the names and values for all nonexpired cookies. Its parameters are: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>names OUT owa_cookie.vc_arr</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Array of cookie names.</P
></DD
><DT
CLASS="term"
>vals OUT owa_cookie.vc_arr</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Array of cookie values.</P
></DD
><DT
CLASS="term"
>num_vals OUT INTEGER</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Total number of cookies retrieved.</P
></DD
></DL
><P
CLASS="para"
>The following procedure illustrates the GET_ALL procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE print_cookies
IS
   
   -- Note that vc_arr is in owa_cookie, not owa_text!
   
   current_cookie_names          OWA_COOKIE.vc_arr;
   current_cookie_vals           OWA_COOKIE.vc_arr;
   n                             INTEGER DEFAULT 0;

BEGIN
   -- Fetch and print the current cookies
   OWA_COOKIE.get_all (
      current_cookie_names,
      current_cookie_vals,
      n
   );
   FOR i IN 1 .. n
   LOOP
      HTP.print ('&lt;b&gt;' || current_cookie_names (i) || ':&lt;/b&gt;');
      HTP.print ('&lt;b&gt;' || current_cookie_vals (i) || '&lt;p&gt;');
   END LOOP;
END;</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.2"
>7.3.2 OWA_OPT_LOCK: Record Locking</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="ch-07-opt_lock"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5644"
></A
> Developing data entry forms with HTML is closely related to the problem of maintaining state. As discussed in <A
CLASS="xref"
HREF="ch02_01.htm"
>Chapter 2, <CITE
CLASS="chapter"
>Foundations</CITE
></A
>, forms are processed in two steps. In the first, the form is displayed and the user is allowed to make changes. In the second, once the user has made all desired edits, the form is submitted to another program for processing. This program adds, deletes, or updates the original record. As any client/server developer knows, forms must be able to handle situations in which multiple users attempt to update the same record simultaneously. </P
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5648"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5650"
></A
> There are two different approaches to handling the simultaneous update problem: pessimistic locking and optimistic locking. With <EM
CLASS="emphasis"
>pessimistic locking</EM
>, the record is locked as soon as the user attempts to edit it. If the lock succeeds, other users are unable to make changes until the original user releases the lock. </P
><P
CLASS="para"
>With <EM
CLASS="emphasis"
>optimistic locking</EM
>, no locks are issued, in the hope (hence the term "optimistic") that someone else won't come along in the interim and make changes to the record. A user makes edits on the screen, and only when the user has finished editing does the system attempt to lock the record and apply the changes. Unfortunately, because the record was not initially locked, other users are free to make changes while the first user is still staring at his screen. If this occurs, the first user must be given a choice about how to proceed; he can choose to overwrite the other user's updates with his own, or choose to discard his changes in favor of the other user's. </P
><P
CLASS="para"
>HTML's inability to maintain state makes it extremely difficult, if not impossible, to implement pessimistic locking. However, it is relatively straightforward, although a little clumsy, to implement optimistic locking. With this approach, a snapshot is taken of a record before the user makes any changes. When the user submits the form, the original record is requeried and compared to the snapshot. If they are identical (i.e., no one has made intervening changes) the user's edits are saved. Otherwise, the user is asked how to proceed. </P
><P
CLASS="para"
>The OWA_OPT_LOCK package provides two ways to simplify optimistic locking in HTML forms. With the first method, the record's columns are saved in hidden fields within the form. When the form is submitted, these hidden fields are passed to the new procedure in an array, where they are then compared with the original record. The second method computes a checksum of the original record. This value is compared to a recomputed checksum to determine if the record has been updated.[<A
CLASS="footnote"
HREF="#BOOK-CH-7-FOOTNOTE-2"
>3</A
>] </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="BOOK-CH-7-FOOTNOTE-2"
>[3]</A
> A checksum is a mathematical function that computes a single, unique value for any input. For example, the sum of a record's bytes is probably unique to that particular record. Real checksum functions, however, are complex enough that even tiny changes to the record result in a different value.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.2.1"
>7.3.2.1 Data structures</A
></H4
><P
CLASS="para"
>The vcArray array holds the hidden fields that are passed from the data entry form: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE vcarray IS TABLE OF VARCHAR2(2000)
   INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.2.2"
>7.3.2.2 Procedures and functions</A
></H4
><P
CLASS="para"
>The procedures and functions in OWA_OPT_LOCK implement the two strategies for optimistic locking. <A
CLASS="xref"
HREF="ch07_03.htm#BOOK-CH-7-SECT-3.2.2"
>Table 7.14</A
> shows the procedures and functions, along with their parameters. Note that the hidden fields and checksum approaches are two different methods, each with its own distinct set of operations. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-28"
>Table 7.14: Various OWA_OPT_LOCK Procedures and Functions </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Procedure/</P
>  <P
CLASS="para"
>Function</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Parameters</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5686"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5688"
></A
> CHECKSUM</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>p_owner IN VARCHAR2</P
>  <P
CLASS="para"
>p_tname IN VARCHAR2</P
>  <P
CLASS="para"
>p_rowid IN VARCHAR2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Generates a checksum (rather than a hidden field) for each sensitive column of the row being updated </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5700"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5702"
></A
> GET_ROWID</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>p_values IN owa_opt_</P
>  <P
CLASS="para"
>  lock.vcArray</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the ROWID from fields generated by store_values</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5713"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5715"
></A
> STORE_VALUES</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>p_owner IN VARCHAR2</P
>  <P
CLASS="para"
>p_tname IN VARCHAR2</P
>  <P
CLASS="para"
>p_rowid IN VARCHAR2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Generates a hidden field for each column of the row being updated</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5727"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5729"
></A
> VERIFY_VALUES</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>p_old_values IN owa_opt_  </P
>  <P
CLASS="para"
>  lock.vcArray</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Compares old and new values</P
> </TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.2.2.1"
>7.3.2.2.1 The STORE_VALUES procedure.</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5740"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5742"
></A
> This procedure generates a hidden field for each column of the row that is to be updated. Its parameters are: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>p_owner IN VARCHAR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The schema that owns the table that is to be updated; you can use the reserved word USER to default to the current schema. </P
></DD
><DT
CLASS="term"
>p_tname IN VARCHAR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The table to be updated.</P
></DD
><DT
CLASS="term"
>p_rowid IN VARCHAR2</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>ROWID of the record in the table that is to be updated; the procedure always uses the ROWID of the row that is to be updated, regardless of the primary key of the table. </P
></DD
></DL
><P
CLASS="para"
>Like the HTP procedures, STORE_VALUES generates HTML tags that are returned to the browser. These tags must appear as part of the data entry form that is being used to update a record. The hidden fields generated by STORE_VALUES have the same name: "old_" followed by the name of the table passed in the p_tname parameter. This passes the old values in a single array parameter to the procedure that processes the form. </P
><P
CLASS="para"
>Here is a sample program that creates a simple data entry form based on the EMP table. The <CODE
CLASS="literal"
>&lt;form&gt;</CODE
> tag's <CODE
CLASS="literal"
>action</CODE
> attribute points us to the procedure that performs the update: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE opt_lock_fentry (
   iempno IN VARCHAR2 DEFAULT NULL
   )
IS
   
   emp_rec scott.emp%ROWTYPE;
   rec_row_id ROWID;

BEGIN
   -- Fetch the record and rowid the employee with the given id
   SELECT *
     INTO emp_rec
     FROM scott.emp
    WHERE emp.empno = iempno;
   SELECT ROWID
     INTO rec_row_id
     FROM scott.emp
    WHERE emp.empno = iempno;
   -- Create a simple data entry form
   HTP.print ('&lt;form action=opt_lock_fupdate&gt;');
   HTP.formhidden (cname =&gt; 'iempno', cvalue =&gt; iempno);
   HTP.print ('Employee Name:');
   HTP.formtext (cname =&gt; 'iename', cvalue =&gt; emp_rec.ename);
   HTP.print ('Job:');
   HTP.formtext (cname =&gt; 'ijob', cvalue =&gt; emp_rec.job);
   /*
   || Store the current values for the row that is to be updated
   */
   OWA_OPT_LOCK.store_values ('SCOTT', 'emp', rec_row_id);
   HTP.print ('&lt;input type=submit&gt;');
   HTP.print ('&lt;/form&gt;');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following listing shows what happens when the procedure is executed. The first three fields simply reproduce the original parameters: the schema name, the table name, and the ROWID of the record that is being updated. After these fields, all the columns in the target row are listed: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;FORM action=opt_lock_fupdate&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;iempno&quot; VALUE=&quot;7934&quot;&gt;
Employee Name:
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;iename&quot; VALUE=&quot;MILLER&quot;&gt;
Job:
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;ijob&quot; VALUE=&quot;CLERK&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;SCOTT&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;emp&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;AAAAeFAACAAAAEbAAN&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;7934&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;MILLER&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;CLERK&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;7566&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;23-JAN-82&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;1300&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;old_emp&quot; VALUE=&quot;10&quot;&gt;
&lt;input type=submit&gt;
&lt;/form&gt;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.2.2.2"
>7.3.2.2.2 The VERIFY_VALUES function.</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5768"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5770"
></A
> This function, used when a form is submitted, compares the old values from the row to the current values. If they match, the function returns TRUE; otherwise, it returns FALSE. Its one parameter is: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>p_old_values IN owa_opt_lock.vcArray</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The array of field values created by the STORE_VALUES procedure.</P
></DD
></DL
><P
CLASS="para"
>The VERIFY_VALUES procedure is meant to work in tandem with the STORE_VALUES procedure. The following example performs the record update started in the earlier example. In addition to a parameter for each input element on the form, we must also include a parameter that receives the values from the STORE_VALUES procedure. The parameter, declared as a vcArray, must have the same name as the hidden fields created by STORE_VALUES: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE opt_lock_fupdate (
   iempno IN VARCHAR2 DEFAULT NULL,
   iename IN VARCHAR2 DEFAULT NULL,
   ijob IN VARCHAR2 DEFAULT NULL,
   old_emp IN OWA_OPT_LOCK.vcarray
   )
IS
BEGIN
   IF OWA_OPT_LOCK.verify_values (old_emp)
   THEN
      -- Perform the update
      UPDATE scott.emp
         SET emp.ename = iename,
             emp.job = ijob
       WHERE emp.empno = iempno;
      COMMIT;
      HTP.print ('&lt;h1&gt;Change Successful&lt;/h1&gt;');
   ELSE
      HTP.print ('&lt;h1&gt;The record has been changed!&lt;/h1&gt;');
   END IF;
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.2.2.3"
>7.3.2.2.3 The GET_ROWID function.</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5783"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5785"
></A
> This function accepts a vcArray, and returns the ROWID (always in the third element in the array) from the fields generated by the STORE_VALUES procedure. Like VERIFY_VALUES, GET_ROWID is used in the procedure that handles form submission. The function is included as a convenience to save us from having to pass the original primary key of the record we are attempting to update. For example, in the previous procedure, we had to include the empno field both in the data entry form and as a parameter to the submission form (again, due to statelessness) to retain the original primary key. We could have saved a step by omitting empno and using GET_ROWID to retrieve the ROWID of the target record, as illustrated in the following code snippet: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>-- old_rowid is a local variable declared as a rowid
   
old_rowid := OWA_OPT_LOCK.get_rowid (old_emp);
UPDATE scott.emp
   SET emp.ename = iename,
       emp.job = ijob
 WHERE ROWID = old_rowid;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-3.2.2.4"
>7.3.2.2.4 The CHECKSUM function.</A
></H4
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5792"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5794"
></A
> <A
CLASS="indexterm"
NAME="ch-07-checksum"
></A
> This function provides an alternative to the hidden field method that is useful when the underlying table contains sensitive information that might be compromised with the "View Source" browser option. Additionally, for tables with a very large number of columns, a checksum results in a more compact HTML form. This can be an important factor in improving download times, particularly when users are connecting with a modem or a WAN. </P
><P
CLASS="para"
>The CHECKSUM function has the same parameters as the STORE_VALUE procedure discussed earlier. The function returns a unique value for the values in the target row, and this value is stored as a hidden field within the data entry form. When the form is submitted, the checksum for the target row is recomputed and compared to the old value. If they are the same, then the procedure can apply the user's updates. </P
><P
CLASS="para"
>The following procedure illustrates how to use the CHECKSUM function when creating a data entry form. Unlike STORE_VALUES, which automatically passes the ROWID or the target record, we must manually include it as a hidden field when using the CHECKSUM approach: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE opt_lock_centry (
   iempno IN VARCHAR2 DEFAULT NULL
   )
IS
   
   emp_rec scott.emp%ROWTYPE;
   rec_row_id ROWID;
   csum NUMBER;

BEGIN
   SELECT *
     INTO emp_rec
     FROM scott.emp
    WHERE emp.empno = iempno;
   SELECT ROWID
     INTO rec_row_id
     FROM scott.emp
    WHERE emp.empno = iempno;
   -- Create a simple data entry form
   HTP.print ('&lt;form action=opt_lock_cupdate&gt;');
   HTP.formhidden (cname =&gt; 'iempno', cvalue =&gt; iempno);
   HTP.formhidden (cname =&gt; 'irowid', cvalue =&gt; rec_row_id);
   HTP.print ('Employee Name:');
   HTP.formtext (cname =&gt; 'iename', cvalue =&gt; emp_rec.ename);
   HTP.print ('Job:');
   HTP.formtext (cname =&gt; 'ijob', cvalue =&gt; emp_rec.job);
   /*
   || Save the row's checksum in a hidden field
   */
   csum := OWA_OPT_LOCK.checksum ('SCOTT', 'emp', rec_row_id);
   HTP.formhidden (cname =&gt; 'iold_checksum', cvalue =&gt; csum);
   HTP.print ('&lt;input type=submit&gt;');
   HTP.print ('&lt;/form&gt;');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the output of the procedure, showing the hidden field for the checksum of the target row: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;form action=opt_lock_cupdate&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;iempno&quot; VALUE=&quot;7934&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;irowid&quot; VALUE=&quot;AAAAeFAACAAAAEbAAN&quot;&gt;
Employee Name:
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;iename&quot; VALUE=&quot;MILLER&quot;&gt;
Job:
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;ijob&quot; VALUE=&quot;CLERK&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;iold_checksum&quot; VALUE=&quot;7925&quot;&gt;
&lt;input type=submit&gt;
&lt;/form&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next procedure illustrates how the function is used to process the form data; notice that the parameter name for the checksum must match the name used for the hidden field: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE opt_lock_cupdate (
   iempno IN VARCHAR2 DEFAULT NULL,
   iename IN VARCHAR2 DEFAULT NULL,
   ijob IN VARCHAR2 DEFAULT NULL,
   iold_checksum IN VARCHAR2 DEFAULT NULL,
   irowid IN VARCHAR2 DEFAULT NULL
   )
IS
   
   new_checksum NUMBER;

BEGIN
   
   new_checksum :=
      OWA_OPT_LOCK.checksum ('SCOTT', 'emp', irowid);
   IF  (iold_checksum = new_checksum)
   THEN
      -- Perform the update
      UPDATE scott.emp
         SET emp.ename = iename,
             emp.job = ijob
       WHERE emp.empno = iempno;
      COMMIT;
      HTP.print ('&lt;h1&gt;Change Successful&lt;/h1&gt;');
   ELSE
      HTP.print ('&lt;h1&gt;The record has been changed by another user.&lt;/h1&gt;');
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There is a second version of the CHECKSUM function that computes a value for an arbitrary VARCHAR2 string. The following example shows its return value on two strings that differ by just one character: <A
CLASS="indexterm"
NAME="AUTOID-5807"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5808"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-5809"
></A
> </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OWA_OPT_LOCK.checksum ('Hello, World');   -- (csum = 21074)
OWA_OPT_LOCK.checksum ('Hello, Wordl');   -- (csum = 23114)</PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
TITLE="7.2 Text Processing"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.2 Text Processing"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Web Applications: PL/SQL Developer's Introduction"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_04.htm#BOOK-CH-7-SECT-4.1.5"
TITLE="7.4 Improving Productivity"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.4 Improving Productivity"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>7.2 Text Processing</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>7.4 Improving Productivity</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
