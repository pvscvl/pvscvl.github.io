<HTML
><HEAD
><TITLE
>[Chapter 7] 7.2 Text Processing</TITLE
><META
NAME="DC.Creator"
CONTENT="Andrew Odewahn"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:36:34Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CDROM-1-56592-687-0E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-687-0E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle Web 8i"><META
NAME="DC.Title"
CONTENT="Oracle Web Applications: PL/SQL Developer's Introduction"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch07_01.htm"
TITLE="7. The PL/SQL Toolkit"><LINK
REL="prev"
HREF="ch07_01.htm"
TITLE="7.1 Communicating with the Outside World"><LINK
REL="next"
HREF="ch07_03.htm#BOOK-CH-7-SECT-3.2.2"
TITLE="7.3 Maintaining State"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_01.htm"
TITLE="7.1 Communicating with the Outside World"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.1 Communicating with the Outside World"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch07_01.htm"
TITLE="7. The PL/SQL Toolkit"
>Chapter 7<BR>The PL/SQL Toolkit</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_03.htm#BOOK-CH-7-SECT-3.2.2"
TITLE="7.3 Maintaining State"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.3 Maintaining State"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2"
>7.2 Text Processing</A
></H2
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4659"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4662"
></A
> The enormous popularity of Perl is due in large part to its sophisticated text processing capabilities. A single Perl command can replace dozens of PL/SQL INSTR and SUBSTR operations. Additionally, Perl's pattern matching capabilities are well suited for processing and validating the text entered into HTML forms. </P
><P
CLASS="para"
>The PL/SQL toolkit has two packages that bring a subset of these capabilities to PL/SQL. The first, OWA_TEXT, manipulates large chunks of text. The second, OWA_PATTERN, allows developers to use sophisticated search patterns to perform many of the text operations found in Perl. </P
><P
CLASS="para"
>Beyond their mere utility, these two packages are interesting examples of good package design. OWA_TEXT is similar to the abstract datatypes described in <A
CLASS="xref"
HREF="ch06_01.htm"
>Chapter 6, <CITE
CLASS="chapter"
>PL/SQL</CITE
></A
>. OWA_PATTERN builds on OWA_TEXT to create dozens of variations of the search and replace procedure, each useful in particular circumstances. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.1"
>7.2.1 OWA_TEXT: Representing Text</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4670"
></A
> The largest PL/SQL string can contain 32,767 characters. Unfortunately, there are many cases where we might like to process larger chunks of text. A document indexing system, for example, must almost certainly process files much larger than 32K.[<A
CLASS="footnote"
HREF="#pgfId-155525"
>1</A
>] The OWA_TEXT package overcomes the 32K limitation by breaking text streams into smaller pieces that are stored as elements in a PL/SQL array. </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="pgfId-155525"
>[1]</A
> The human resources dress code guidelines at some companies probably exceed a megabyte.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Additionally, it is often useful to treat the components of a string as a single entity (e.g., a sentence as an array of words). OWA_TEXT is ideal for this type of application. In practice, though, you'll probably not use OWA_TEXT directly; instead, it's used to provide more flexibility to the OWA_PATTERN package discussed later in this chapter. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.1.1"
>7.2.1.1 Data structures</A
></H4
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4678"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4680"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4682"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4684"
></A
> OWA_TEXT's specification declares four data structures. The first two, vc_arr and int_arr, are PL/SQL arrays that are the building blocks of the more complex types. vc_arr is a 32K string array; int_arr holds indexes to the interesting rows of vc_arr. The declarations for these two datatypes are: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE vc_arr IS TABLE OF VARCHAR2(32767)
   INDEX BY BINARY_INTEGER;

TYPE int_arr IS TABLE OF INTEGER
   INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The third data structure, called multi_line, is used to store information about an entire text stream. multi_line contains three fields: a vc_arr array to hold the individual rows of the stream, an integer to hold the number of rows in the vc_arr array, and a Boolean flag to indicate the presence of a partial row. Its declaration is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE multi_line IS RECORD (
   rows vc_arr,
   num_rows INTEGER,
   partial_row BOOLEAN
);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The fourth data structure, row_list, is used to represent pointers into the rows in a multi_line structure. This structure is generally used by other toolkit packages, such as OWA_PATTERN, discussed later in this chapter. The declaration for the row_list structure is: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE row_list IS RECORD (
   rows int_arr,
   num_rows INTEGER
);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.1.2"
>7.2.1.2 Procedures</A
></H4
><P
CLASS="para"
>The procedures in OWA_TEXT define a limited set of operations similar to those of a classic linked list. There are procedures to create a new multi_line structure, to add a new row onto the end of an existing structure, and even to print its contents. <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.4</A
> summarizes these procedures: </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-8"
>Table 7.4: Various OWA_TEXT Procedures</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4705"
></A
> Procedure</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Parameters</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <A
CLASS="indexterm"
NAME="AUTOID-4714"
></A
> <P
CLASS="para"
>ADD2MULTI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>stream IN VARCHAR2</P
>  <P
CLASS="para"
>mline OUT multi_line</P
>  <P
CLASS="para"
>continue IN BOOLEAN</P
>  <P
CLASS="para"
> DEFAULT TRUE</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Appends the passed stream to the multi_line structure. If the continue flag is TRUE, the stream is appended to the last line of the multi_line array. If FALSE, the stream is appended as the last row. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4727"
></A
> NEW_MULTI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>mline OUT multi_line</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Creates a new, blank multi_line. There is also a functionalized version that returns an empty structure. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4736"
></A
> NEW_ROW_LIST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>rlist IN row_list</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Creates a new row_list structure. The command can be used as either a procedure or a function. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4745"
></A
> PRINT_MULTI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>mline IN multi_line</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Prints the content of the multi_line data structure using HTP.PRINT.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4754"
></A
> PRINT_ROW_LIST</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>rlist IN row_list</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Prints the row_list using HTP.PRINT.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4763"
></A
> STREAM2MULTI</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>stream IN VARCHAR2</P
>  <P
CLASS="para"
>mline OUT multi_line</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Converts a VARCHAR2 into a multi_line.</P
> </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.1.3"
>7.2.1.3 Example</A
></H4
><P
CLASS="para"
>Let's look at a quick example that illustrates OWA_TEXT in action. The following procedure, TOKENIZE, uses OWA_TEXT to break apart and print the individual words in a sentence: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE tokenize (
   sentence IN VARCHAR2 DEFAULT NULL
   )
IS
   mline OWA_TEXT.multi_line;
   i NUMBER;
   n NUMBER := LENGTH (sentence);
   c VARCHAR2(1);
BEGIN
   OWA_TEXT.new_multi (mline);   -- Initialize the structure
   FOR i IN 1 .. n
   LOOP
      c := SUBSTR (sentence, i, 1);   -- Fetch current character
      IF c = ' '
      THEN
         -- Add a new row if the character is a space
         OWA_TEXT.add2multi (c, mline, FALSE);
      ELSE
         -- Otherwise, append the character to the string
         OWA_TEXT.add2multi (c, mline);
      END IF;
   END LOOP;
   /*
   || Print individual words in sentence
   */
   FOR i IN 1 .. mline.num_rows
   LOOP
      HTP.print ('Word ' || i || ' is ');
      HTP.print (mline.rows (i) || '&lt;br&gt;');
   END LOOP;
END;   </PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following HTML form is used to test the procedure; note how the <CODE
CLASS="literal"
>&lt;textarea&gt;</CODE
> tag is used to supply the value for the sentence parameter. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;html&gt;
&lt;title&gt;Test tokenizer procedure&lt;/title&gt;
&lt;body&gt;
   Enter the text to tokenize:
   &lt;form action=&quot;http://gandalf/agent_webtest/plsql/tokenize&quot;&gt;
      &lt;textarea name=sentence&gt;Enter sentence here&lt;/textarea&gt;
      &lt;p&gt;
      &lt;input type=submit&gt;
   &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Figure 7.2</A
> shows the results of the TOKENIZE procedure. The image on the left shows the form used to submit the sentence; the image on the right shows the corresponding output generated by TOKENIZE. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="BOOK-CH-7-FIG-2"
>Figure 7.2: Results of the TOKENIZE procedure</A
></H4
><IMG
CLASS="graphic"
SRC="figs/owa.0702.gif"
ALT="Figure 7.2"></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.1.4"
>7.2.1.4 Design note</A
></H4
><P
CLASS="para"
>In a classic ADT, such as the stack presented in <A
CLASS="xref"
HREF="ch06_01.htm"
>Chapter 6</A
>, the datatypes would be hidden within the package body and would be accessible only through a programmatic interface. While this information hiding approach gives the developer strict control over how the package is used, it also makes it difficult to extend the package. </P
><P
CLASS="para"
>Although it seems like an obscure issue, the placement of the declaration has a profound impact on the life of the package. Declaring everything in the specification can make the package unwieldy and hard to maintain. The other extreme, declaring everything in the body and making nothing accessible, results in a package that is rigid and difficult to use in new circumstances. </P
><P
CLASS="para"
>OWA_TEXT resolves this tension admirably. By placing the declarations in the specification, the developers are consciously creating a general-purpose object that other packages can use. However, the package also contains a well-defined, private set of procedures that limit the operations that can be performed against its structures. In the next section, we'll see how the package is used to extend the toolkit's pattern searching capabilities. </P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.2"
>7.2.2 OWA_PATTERN: Searching and Replacing Text</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4791"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4793"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4795"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4797"
></A
> The OWA_PATTERN package is the second component of our text processing unit. As its name implies, OWA_PATTERN performs more complex text manipulation than is possible with PL/SQL's INSTR and SUBSTR functions. Regular expressions make this sophistication possible. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.2.1"
>7.2.2.1 Regular expressions</A
></H4
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4803"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4805"
></A
> A <EM
CLASS="emphasis"
>regular expression</EM
>, or RegExp, is a compact description for a pattern of characters used to find matches within another string. Chances are you have used a simple RegExp to perform wildcard file searches using commands such as <CODE
CLASS="literal"
>dir</CODE
> <CODE
CLASS="literal"
>*.sql</CODE
> or <CODE
CLASS="literal"
>ls</CODE
> <CODE
CLASS="literal"
>*.sql</CODE
>. In these searches, instead of looking for a specific file, you are looking for any file that matches the <I
CLASS="filename"
>.sql</I
> extension. In this case, the RegExp translates to the sentence "Any string of characters that ends in <I
CLASS="filename"
>.sql</I
>." </P
><P
CLASS="para"
>You can use regular expressions to create more sophisticated patterns. For example, suppose you want to take some action if any date appears within a string; you are only interested in its presence and do not know its value ahead of time. Clearly, the following INSTR test is not very effective: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF    INSTR (some_string, '07/13/71')
   OR INSTR (some_string, '07/14/71')
   OR INSTR (some_string, '07/15/71')
   OR INSTR (some_string, '07/16/71') ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>What you are really after is a pattern consisting of three sets of two digits separated by slashes (for clarity, assume the date is always DD-MM-YY). A regular expression is a mini-language that uses a compact vocabulary to describe these patterns. </P
><P
CLASS="para"
>The first part of the RegExp vocabulary defines the different types of characters that can be matched, such as digits, letters, or tabs. These characters are sometimes called <EM
CLASS="emphasis"
>atoms</EM
> because they form the basic building blocks on which the expressions are based.  <A
CLASS="indexterm"
NAME="AUTOID-4819"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4821"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4823"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4825"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4827"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4829"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4831"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4833"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4835"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4837"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4839"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4841"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4843"
></A
> The atoms that can be used in OWA_PATTERN are shown in <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.5</A
>. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-10"
>Table 7.5: Atoms Available in OWA_PATTERN </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Atom</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>.</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Any character except newline (\n)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\n</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Newline</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\t</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Tab</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\d</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Any digit (0 . . . 9)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\D</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Any non-digit</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\w</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Any alphanumeric character (0 . . . 9, a . . . z, A . . . Z)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\W</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Any nonalphanumeric character</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\s</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Any whitespace character (space, tab, or newline)</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\S</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Non-whitespace character</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\b</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Word boundary</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\x<EM
CLASS="emphasis"
>nn</EM
></P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Character having the hexadecimal value <EM
CLASS="emphasis"
>nn</EM
> (i.e., \x20 is a space) </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\<EM
CLASS="emphasis"
>nnn</EM
></P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Character having the octal value <EM
CLASS="emphasis"
>nnn</EM
> (i.e., \040 is a space) </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>\<EM
CLASS="emphasis"
>c</EM
></P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Any character matching <EM
CLASS="emphasis"
>c</EM
></P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The next part of the vocabulary defines how many characters must appear to constitute a match. For example, we may want to return a match only if there are exactly two consecutive digits. The characters in this set are called the <I
CLASS="firstterm"
>quantifiers</I
>; the possibilities for them are shown in <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.6</A
>. <A
CLASS="indexterm"
NAME="AUTOID-4932"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4934"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4936"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4938"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4940"
></A
> </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-12"
>Table 7.6: Quantifiers Available in OWA_PATTERN </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Quantifier</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>?</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Exactly zero or one occurrence of an atom</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>*</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Zero or more occurrences of an atom</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>+</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>One or more occurrences of an atom</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>{<EM
CLASS="emphasis"
>n</EM
>}</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Exactly <EM
CLASS="emphasis"
>n</EM
> occurrences of an atom</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>{<EM
CLASS="emphasis"
>n</EM
>,}</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>At least <EM
CLASS="emphasis"
>n</EM
> occurrences of an atom</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>{<EM
CLASS="emphasis"
>n,m</EM
>}</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>At least <EM
CLASS="emphasis"
>n</EM
>, but not more than <EM
CLASS="emphasis"
>m</EM
>, occurrences of an atom </P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-4992"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4994"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4996"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-4998"
></A
>  There are two possible <I
CLASS="firstterm"
>assertions</I
>, or sets of characters used to fix the position of a match, as shown in <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.7</A
>. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-14"
>Table 7.7: Assertions Available in OWA_PATTERN </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5011"
></A
> Assertion</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>^</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Match must come at the start of the string.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>$</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Match must come at the end of the string.</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Finally, the vocabulary of the regular expression contains a set of <I
CLASS="firstterm"
>flags</I
> that are used to control the behavior of the search. Unlike the atoms, quantifiers, and assertions, these flags are not included as part of the RegExp itself. Instead, they are passed as a separate parameter to control how the various OWA_TEXT procedures behave. The two available flags are shown in <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.8</A
>. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-16"
>Table 7.8: Flags Available in OWA_PATTERN </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5038"
></A
> Flag</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>I</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>The search is not case sensitive.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>g</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Used in the change procedure to specify a global search and replace.</P
> </TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-5054"
></A
> There are additional special characters that remember the portions of the original string that was matched. The first special character, the ampersand (&amp;), can be used during the replace phase of a search and replace operation. The &amp; represents the original pattern found in a match; including it in a replace string recreates the original string of characters that matched the pattern. The second special character is a pair of parentheses. When a portion of a match sequence is enclosed in parentheses, the subsequent replace operation can remember each parenthesized match. These remembered strings are called <I
CLASS="firstterm"
>back references</I
> (backrefs) and are stored in an array. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.2.2"
>7.2.2.2 Data structures</A
></H4
><P
CLASS="para"
>You must supply a regular expression to each function in OWA_PATTERN. Initially, the pattern is stored as a simple VARCHAR2 string. In order to use the expression, however, OWA_PATTERN transforms it into a more useful format. This relatively time-consuming process converts the regular expression from a VARCHAR2 into a PL/SQL array, using the following declaration: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE pattern IS TABLE OF VARCHAR2(4)
   INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Like many of the other data structures we've seen, pattern datatypes are initialized by calling a procedure. In this case, the procedure is called GET_PAT. There are two parameters to this procedure. The first is a VARCHAR2 string called arg that holds the regular expression to be parsed. The second is a pattern datatype (declared as an IN OUT mode parameter) to hold the resultant parsed pattern. </P
><P
CLASS="para"
>In the next section, we'll see once again how the toolkit's developers intentionally placed the declaration in the specification and not the body, even though it's a purely internal representation. This time, however, the intent is to improve the package's performance as well as its usability. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.2.3"
>7.2.2.3 Procedures and functions</A
></H4
><P
CLASS="para"
>In addition to GET_PAT, the OWA_PATTERN package contains three other basic functions: MATCH, AMATCH, and CHANGE. In an attempt to match the enormous flexibility of Perl, each function has several overloaded versions that derive from the data structures found in OWA_TEXT. For example, the MATCH function can search either a simple VARCHAR2 string or the more complex multi_line data structure. This is a great example of the power and flexibility a good package can provide. </P
><P
CLASS="para"
>However, with 14 variations of just three functions, OWA_PATTERN reveals an API that just might be <EM
CLASS="emphasis"
>too</EM
> complex. The next three sections describe the functions for this package, shown in <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.9</A
>. Keep in mind that some of these functions are like the finches on the Galapagos Islands: very specialized. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-18"
>Table 7.9: Various OWA_PATTERN Procedures and Functions </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Procedure/Function</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Parameters</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>AMATCH</P
> <A
CLASS="indexterm"
NAME="AUTOID-5087"
></A
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.11</A
> for details on overloaded versions.</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns the position of the end of the first RegExp found within text</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>CHANGE</P
> <A
CLASS="indexterm"
NAME="AUTOID-5097"
></A
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.12</A
> for details on overloaded versions.</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Replaces matched pattern with a new string</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>GET_PAT</P
> <A
CLASS="indexterm"
NAME="AUTOID-5107"
></A
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>arg IN VARCHAR2</P
>  <P
CLASS="para"
>pat IN OUT pattern</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Initializes a datatype</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>MATCH</P
> <A
CLASS="indexterm"
NAME="AUTOID-5117"
></A
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.10</A
> for details on overloaded versions.</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Returns a Boolean value indicating whether a RegExp was found inside text </P
> </TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.2.3.1"
>7.2.2.3.1 The MATCH function.</A
></H4
><P
CLASS="para"
>This function returns a Boolean value indicating whether a regular expression was found inside a chunk of text. There are six overloaded versions. The parameters for this function are: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>line/mline</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The text that is being searched, either a VARCHAR2 or an OWA_TEXT.MULTI_LINE (in the latter case, the parameter is renamed mline). </P
></DD
><DT
CLASS="term"
>pat</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The regular expression, either a VARCHAR2 or a pattern. If used as a pattern, the structure must be initialized with the GET_PAT procedure before it is passed as a parameter. </P
></DD
><DT
CLASS="term"
>flags</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Controls the behavior of the search as described in <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.8</A
>; a VARCHAR2. </P
></DD
><DT
CLASS="term"
>backrefs</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Optional parameter to hold back references when parentheses are used as part of the regular expression; an OWA_TEXT.VC_ARR. </P
></DD
><DT
CLASS="term"
>rlist</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Identifies the rows in which a match was found; an OWA_TEXT.ROW_LIST (mandatory when the line parameter is an OWA_TEXT.MULTI_LINE). </P
></DD
></DL
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.10</A
> lists the formal parameters for each of the different versions of MATCH. </P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-20"
>Table 7.10: Overloaded Versions of MATCH </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Version</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Parameters</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>1</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN VARCHAR2</P
>  <P
CLASS="para"
>pat IN VARCHAR2</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>The simplest of the versions; all parameters are VARCHAR2.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN VARCHAR2</P
>  <P
CLASS="para"
>pat IN OUT pattern</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>multiple searches that use the same RegExp.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>3</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN VARCHAR2</P
>  <P
CLASS="para"
>pat IN VARCHAR2</P
>  <P
CLASS="para"
>backrefs OUT owa_text.vc_arr</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Version 1 with the optional backrefs parameter. When the function completes, the backrefs array contains the portions of the original string that matched the parentheses. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>4</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN VARCHAR2</P
>  <P
CLASS="para"
>pat IN VARCHAR2</P
>  <P
CLASS="para"
>backrefs OUT owa_text.vc_arr</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Version 2 with the optional backrefs parameter.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>5</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>mline IN owa_text.multi_line</P
>  <P
CLASS="para"
>pat IN VARCHAR2</P
>  <P
CLASS="para"
>rlist OUT owa_text.row_list</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>In this version, the text string is a multi_line datatype rather than a VARCHAR2. The mline parameter must be initialized using the procedures described in the OWA_TEXT section. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>6</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>mline IN owa_text.multi_line</P
>  <P
CLASS="para"
>pat IN OUT pattern</P
>  <P
CLASS="para"
>rlist OUT owa_text.row_list</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Same as version 5, but the pat parameter is declared as a pattern structure. </P
> </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.2.3.2"
>7.2.2.3.2 The AMATCH function.</A
></H4
><P
CLASS="para"
>This function is similar to MATCH, except that it returns the position of the end of the first match found within the string.[<A
CLASS="footnote"
HREF="#BOOK-CH-7-FOOTNOTE-1"
>2</A
>] The function returns if no match is found. There are four overloaded versions; the parameters for each version are: </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="BOOK-CH-7-FOOTNOTE-1"
>[2]</A
> INSTR, a similar function that's built into PL/SQL, returns the position of the first character of a match.</P
></DIV
></BLOCKQUOTE
><DL
CLASS="variablelist"
><DT
CLASS="term"
>line</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The text that is being searched; unlike the MATCH function, it is always a VARCHAR2. </P
></DD
><DT
CLASS="term"
>from_loc</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Starting position within the string for the search.</P
></DD
><DT
CLASS="term"
>pat</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The regular expression, either a VARCHAR2 or a pattern. If used as a pattern, the structure must be initialized with the GET_PAT procedure before it is passed as a parameter. </P
></DD
><DT
CLASS="term"
>flags</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Controls the behavior of the search as described in <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.8</A
>; a VARCHAR2. </P
></DD
><DT
CLASS="term"
>backrefs</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Optional parameter to hold back references when parentheses are used as part of the regular expression; an OWA_TEXT.VC_ARR. </P
></DD
></DL
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.11</A
> lists the four versions of AMATCH.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-22"
>Table 7.11: Overloaded Versions of AMATCH </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Version</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Parameters</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>1</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN VARCHAR2</P
>  <P
CLASS="para"
>from_loc IN INTEGER</P
>  <P
CLASS="para"
>pat IN VARCHAR2</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>The simplest of the versions; all parameters are VARCHAR2.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN VARCHAR2</P
>  <P
CLASS="para"
>from_loc IN INTEGER</P
>  <P
CLASS="para"
>pat IN OUT pattern</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>In this version, the pat parameter is declared using the PATTERN datatype. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>3</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN VARCHAR2</P
>  <P
CLASS="para"
>from_loc IN INTEGER</P
>  <P
CLASS="para"
>pat IN VARCHAR2</P
>  <P
CLASS="para"
>backrefs OUT owa_text.vc_arr</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Version 1 with the optional backrefs parameter.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>4</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN VARCHAR2</P
>  <P
CLASS="para"
>from_loc IN INTEGER</P
>  <P
CLASS="para"
>pat IN pattern</P
>  <P
CLASS="para"
>backrefs OUT owa_text.vc_arr</P
>  <P
CLASS="para"
>flags IN VARCHAR2 DEFAULT NULL</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Version 2 with the optional backrefs parameter.</P
> </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.2.3.3"
>7.2.2.3.3 CHANGE.</A
></H4
><P
CLASS="para"
>The CHANGE function or procedure searches a chunk of text for a pattern. When it finds a match, it replaces the matched substring with a new string. When used as a procedure, CHANGE simply updates the text with the appropriate matches. When used as a function, it makes the changes and returns the number of substitutions. </P
><P
CLASS="para"
>This second usage is questionable. When a function changes the value of a parameter, it violates the most important rule about functions: that a function should return exactly one value. By updating the parameters, CHANGE is essentially returning two values: one for the number of updates and another for the actual results of that update. Including an OUT mode parameter to the procedural version would probably have been a better design. </P
><P
CLASS="para"
>The parameters used in each version are:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>line/mline</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The text that is being searched and replaced; either a VARCHAR2 or an OWA_TEXT.MULTI_LINE (in the latter case, the parameter is renamed mline). </P
></DD
><DT
CLASS="term"
>from_str</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>String to be replaced; always a VARCHAR2. Note that although the string represents a regular expression like the pat parameter in the MATCH and AMATCH functions, it cannot be used as a PATTERN datatype. </P
></DD
><DT
CLASS="term"
>to_str</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The string that replaces from_str; always a VARCHAR2. An &amp; character, when used anywhere in the string, is replaced by the original portion of the text line that matches the from_str pattern. </P
></DD
><DT
CLASS="term"
>flags</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Controls the behavior of the search as described in <A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.8</A
>; a VARCHAR2. If no value is specified (the default), only the first match is replaced. If the value "g" is used, it replaces all the matches. </P
></DD
></DL
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Table 7.12</A
> lists the four versions of CHANGE.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="BOOK-CH-7-TABLE-24"
>Table 7.12: Overloaded Versions of CHANGE </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Version</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Parameters</P
> </TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Description</P
> </TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>1</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN OUT VARCHAR2</P
>  <P
CLASS="para"
>from_str IN VARCHAR2</P
>  <P
CLASS="para"
>to_str IN VARCHAR2</P
>  <P
CLASS="para"
>flags IN VARCHAR2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Function that returns the number of substitutions made. After the function exits, the line parameter is updated with the results of the search and replace. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>line IN OUT VARCHAR2</P
>  <P
CLASS="para"
>from_str IN VARCHAR2</P
>  <P
CLASS="para"
>to_str IN VARCHAR2</P
>  <P
CLASS="para"
>flags IN VARCHAR2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Procedural version of version 1.</P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>3</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>mline IN OUT owa_text.multi_line</P
>  <P
CLASS="para"
>from_str IN VARCHAR2</P
>  <P
CLASS="para"
>to_str IN VARCHAR2</P
>  <P
CLASS="para"
>flags IN VARCHAR2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Function that returns the number of substitutions made; the target text is declared as a multi_line structure. </P
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>4</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>mline IN OUT owa_text.multi_line</P
>  <P
CLASS="para"
>from_str IN VARCHAR2</P
>  <P
CLASS="para"
>to_str IN VARCHAR2</P
>  <P
CLASS="para"
>flags IN VARCHAR2</P
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>Procedural version of version 4.</P
> </TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="BOOK-CH-7-SECT-2.2.4"
>7.2.2.4 Example</A
></H4
><P
CLASS="para"
>As you can imagine, there are a lot of possible examples for the OWA_PATTERN package. However, it's not necessary to detail every one. Instead, let's focus on a single example, based on the CHANGE procedure, that allows you to test the effect of various regular expressions in search and replace operations. </P
><P
CLASS="para"
>The example procedure, regexp_test, accepts the parameters of version 1 of CHANGE and builds an HTML table that breaks the final page into two columns. The first column contains a data entry form with the fields necessary to test the CHANGE procedure. The second column displays the results of the CHANGE procedure when it is executed with the regexp_test procedure's parameters. </P
><P
CLASS="para"
>The interesting thing about this procedure is that it preserves the values entered when the user submits the form. This is accomplished by setting the form <CODE
CLASS="literal"
>action</CODE
> attribute back to the regexp_test procedure. When the form is submitted, the procedure reconstructs the form using the input from the previous screen: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE regexp_test (
   line IN OUT VARCHAR2 DEFAULT NULL,
   from_str IN VARCHAR2 DEFAULT NULL,
   to_str IN VARCHAR2 DEFAULT '&lt;b&gt;&amp;&lt;/b&gt;',
   flags IN VARCHAR2 DEFAULT NULL
   )
IS

BEGIN
   HTP.print ('&lt;html&gt;&lt;title&gt;Pattern Test&lt;/title&gt;&lt;body&gt;');
   HTP.print ('&lt;table border=1&gt;&lt;tr&gt;&lt;td&gt;');   -- Used to format results
   HTP.print ('&lt;form action=regexp_test&gt;');
   HTP.print ('Line:&lt;textarea name=line&gt;' ||
              line ||
              '&lt;/textarea&gt;&lt;br&gt;');
   HTP.print ('From:&lt;input name=from_str value=&quot;' ||
              from_str ||
              '&quot;&gt;&lt;br&gt;');
   HTP.print ('To:&lt;input name=to_str value=&quot;' ||
              to_str ||
              '&quot;&gt;&lt;br&gt;');
   HTP.print ('Flags:&lt;input name=flags value=&quot;' ||
              flags ||
              '&quot;&gt;&lt;br&gt;');
   HTP.print ('&lt;input type=submit&gt;');
   HTP.print ('&lt;/form&gt;&lt;/td&gt;&lt;td&gt;');   -- Results print in second column
   -- Call the change procedure
   OWA_PATTERN.change (line, from_str, to_str, flags);
   HTP.print (line_copy);
   HTP.print ('&lt;/td&gt;&lt;/tr&gt;&lt;/html&gt;');
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch07_02.htm#BOOK-CH-7-SECT-2.2.1"
>Figure 7.3</A
> shows the output of the regexp_test procedure. </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="BOOK-CH-7-FIG-3"
>Figure 7.3: The results of the regexp_test procedure</A
></H4
><IMG
CLASS="graphic"
SRC="figs/owa.0703.gif"
ALT="Figure 7.3"></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_01.htm"
TITLE="7.1 Communicating with the Outside World"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.1 Communicating with the Outside World"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle Web Applications: PL/SQL Developer's Introduction"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle Web Applications: PL/SQL Developer's Introduction"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch07_03.htm#BOOK-CH-7-SECT-3.2.2"
TITLE="7.3 Maintaining State"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.3 Maintaining State"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>7.1 Communicating with the Outside World</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>7.3 Maintaining State</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
