<HTML
><HEAD
><TITLE
>[Chapter 6] 6.2 Database-Level Event Triggers</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:26:01Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CDROM-1-56592-675-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-675-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle 8i Features"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. New Trigger Features in Oracle8i"><LINK
REL="prev"
HREF="ch06_01.htm"
TITLE="6.1 Triggers on Nested Table View Columns"><LINK
REL="next"
HREF="ch06_03.htm"
TITLE="6.3 Schema-Level Event Triggers"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_01.htm"
TITLE="6.1 Triggers on Nested Table View Columns"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.1 Triggers on Nested Table View Columns"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch06_01.htm"
TITLE="6. New Trigger Features in Oracle8i"
>Chapter 6<BR>New Trigger Features in Oracle8i</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_03.htm"
TITLE="6.3 Schema-Level Event Triggers"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.3 Schema-Level Event Triggers"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch06-92866"
>6.2 Database-Level Event Triggers</A
></H2
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-2958"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-2961"
></A
> <A
CLASS="indexterm"
NAME="ch-06-dlet"
></A
>Oracle8<EM
CLASS="emphasis"
>i</EM
> allows you to define triggers to respond to database-level events (also known as system-level events), including the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Logon to and logoff from a schema</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Startup and shutdown of the database</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Response to a server error</P
></LI
></UL
><P
CLASS="para"
>Here is the syntax for these triggers:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE [ OR REPLACE ] TRIGGER <I
CLASS="replaceable"
>trigger_name</I
>
   { BEFORE | AFTER }
   { SERVERERROR |
     LOGON | LOGOFF | 
     STARTUP | SHUTDOWN }
   ON DATABASE
BEGIN
   <I
CLASS="replaceable"
>pl/sql_statements</I
>
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2978"
></A
>To create a trigger at the database level, you must have the ADMINISTER DATABASE TRIGGER system privilege. You will also need privileges to access any of the external references in the trigger's PL/SQL code.</P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch06_02.htm"
>Table 6.1</A
> lists the different database-level events on which you may define a trigger.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch06-86706"
>Table 6.1: Database-Level Events for Trigger Definitions </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Event</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-2995"
></A
> SERVERERROR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Oracle fires the trigger whenever a server error message is logged. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3002"
></A
>LOGON</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Oracle fires the trigger after a client application logs on to the database successfully.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3009"
></A
>LOGOFF</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Oracle fires the trigger before a client application logs off the database. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3016"
></A
> STARTUP</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Oracle fires the trigger immediately after the database is opened. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3023"
></A
> SHUTDOWN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Oracle fires the trigger just before the server starts a shutdown of an instance of the database. Note that a SHUTDOWN trigger will only fire if the database is shut down cleanly using SHUTDOWN or SHUTDOWN IMMEDIATE. If an instance shuts down abnormally (SHUTDOWN ABORT), this event will not be fired.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Each database-level event has an associated with it a set of attributes. These attributes are actually functions owned by SYS that return the values of characteristics relevant to the event. <A
CLASS="xref"
HREF="ch06_02.htm"
>Table 6.2</A
> lists the current set of attributes.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch06-47269"
>Table 6.2: Attributes for Database-Level Events </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Datatype</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3044"
></A
> SYSEVENT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VARCHAR2(30)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The database-level event firing the trigger; this value matches the name used in the syntax of the trigger. </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3053"
></A
>LOGIN_USER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VARCHAR2(30)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The login username.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3062"
></A
>INSTANCE_NUM</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NUMBER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The instance number.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3071"
></A
>DATABASE_NAME</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VARCHAR2(50)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The name of the database.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SERVER_ERROR</P
></TD
><A
CLASS="indexterm"
NAME="AUTOID-3080"
></A
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NUMBER</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>This function returns the error at the <EM
CLASS="emphasis"
>n </EM
>th position in the stack. You must specify a position (1 equals "top") when you call this function. For example:</P
><P
CLASS="para"
>  SERVER_ERROR(1)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3091"
></A
>IS_SERVERERROR</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BOOLEAN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns TRUE if the specified error is on the current error stack; FALSE otherwise.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch06_02.htm"
>Table 6.3</A
> lists the restrictions and attributes for each database-level event.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch06-45221"
>Table 6.3: Restrictions and Attributes for Database-Level Events </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Event</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Conditions/Restrictions</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Attributes</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SERVERERROR</P
></TD
><A
CLASS="indexterm"
NAME="AUTOID-3114"
></A
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You can specify a condition that will restrict the trigger to firing only when the specified exception is raised. Otherwise, it will fire for all errors.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SYSEVENT</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3121"
></A
>LOGIN_USER</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3124"
></A
>INSTANCE_NUM </P
><P
CLASS="para"
>DATABASE_NAME</P
><P
CLASS="para"
>SERVER_ERROR</P
><P
CLASS="para"
>IS_SERVERERROR</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LOGON</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You can specify a condition using either   USERID(  ) or USERNAME(  ).</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SYSEVENT</P
><P
CLASS="para"
>LOGIN_USER</P
><P
CLASS="para"
>INSTANCE_NUM </P
><P
CLASS="para"
>DATABASE_NAME</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LOGOFF</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>You can specify a condition using either   USERID(  ) or USERNAME(  ).</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SYSEVENT</P
><P
CLASS="para"
>LOGIN_USER</P
><P
CLASS="para"
>INSTANCE_NUM </P
><P
CLASS="para"
>DATABASE_NAME</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>STARTUP</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No database operations (DML and queries) are allowed. Instead, you might start up listener programs, pin code in memory, etc.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SYSEVENT</P
><P
CLASS="para"
>LOGIN_USER</P
><P
CLASS="para"
>INSTANCE_NUM </P
><P
CLASS="para"
>DATABASE_NAME</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SHUTDOWN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No database operations (DML and queries) are allowed. Instead, you might shut down listener programs, run performance collection utilities that write logs to files, etc.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SYSEVENT</P
><P
CLASS="para"
>LOGIN_USER</P
><P
CLASS="para"
>INSTANCE_NUM </P
><P
CLASS="para"
>DATABASE_NAME</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Keep in mind the following rules when working with these triggers:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3173"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3175"
></A
>Whenever a database-level event trigger fires, Oracle opens an autonomous transaction, fires the trigger, and commits any DML in the trigger logic independently of the existing user transaction. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3180"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3182"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3184"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3186"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3188"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3190"
></A
> When defining LOGON, STARTUP, and SERVERERROR triggers, you can only specify the AFTER context. If you specify BEFORE, you will get this error:</P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-30500: database open triggers and server error 
           triggers cannot have BEFORE type</PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3196"
></A
>When defining LOGOFF and SHUTDOWN triggers, you can only specify the BEFORE context. If you specify AFTER, you will get this error:</P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-30509: client logoff triggers cannot have AFTER type</PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot define AFTER STARTUP and BEFORE SHUTDOWN triggers for a schema; these apply only to DATABASE. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3204"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3206"
></A
>Calls to DBMS_OUTPUT.PUT_LINE do not generate any visible output in the current session. If you want to obtain a record of actions that occurred, you will need to write information to a database table, database pipe, or operating system file. You could also use DBMS_AQ.ENQUEUE to place a message in a queue.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A SERVERERROR trigger will not fire for any of the following errors:<A
CLASS="indexterm"
NAME="AUTOID-3210"
></A
></P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-01403: no data found
ORA-01422: exact fetch returns more than requested number of rows
ORA-04030: out of process memory when trying to allocate <I
CLASS="replaceable"
>nnn</I
> bytes 
ORA-01034: ORACLE not available
ORA-01007: variable not in select list</PRE
></BLOCKQUOTE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-2.1"
>6.2.1 Examples of Database-Level Event Triggers</A
></H3
><P
CLASS="para"
> There are many different ways you can use database-level event triggers to manage your database. The following examples offer some simple models from which you can build your own, more complex variations.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.1"
>6.2.1.1 Pinning packages on database startup</A
></H4
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3219"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3222"
></A
>A common requirement for a high-performance database is to pin one or more packages into shared memory. By pinning your code, it is exempted from the least recently used algorithm and will <EM
CLASS="emphasis"
>never</EM
> be aged out of the shared pool area. </P
><P
CLASS="para"
>Before the existence of STARTUP triggers, the DBA would have to set up a script to run after the database was started. Now, I can create a STARTUP trigger like the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: startup.trg */
CREATE OR REPLACE TRIGGER pin_code_on_startup 
  AFTER STARTUP ON DATABASE 
BEGIN
   /* Pin the default packages of PL/SQL to 
      improve runtime performance. */
   DBMS_SHARED_POOL.KEEP (
      'SYS.STANDARD', 'P');
   DBMS_SHARED_POOL.KEEP (
      'SYS.DBMS_STANDARD', 'P');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With this trigger in place, I guarantee that all of my large code elements (including cursors, types, and triggers) and even my sequences are cached in the shared pool until the instance goes down.</P
><P
CLASS="para"
>If you are going to be pinning objects, you should consider building an infrastructure table to store the names of elements you want pinned. Then instead of hard-coding your pin commands in a trigger (as just shown), you could run a procedure that reads through the table and pins each element found. This approach is explained in detail in <CITE
CLASS="citetitle"
>Chapter 12</CITE
> of <CITE
CLASS="citetitle"
>Oracle Built-in Packages</CITE
>. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.2"
>6.2.1.2 Tracking logins to the database</A
></H4
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3234"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3237"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3239"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3241"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3243"
></A
>Suppose that I want to keep track of logins to my database instance. To make this information available in a structured fashion, I am going to send my login information to a queue using the Oracle Advanced Queuing (AQ) facility.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3246"
></A
>These steps are illustrated in <A
CLASS="xref"
HREF="ch06_02.htm"
>Figure 6.2</A
>. You will find all of the AQ-related steps in the <I
CLASS="filename"
>aq.sql</I
> script on the companion disk; I'll concentrate on the trigger-related components here.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch06-12116"
>Figure 6.2: Logical flow of LOGON trigger</A
></H4
><IMG
CLASS="graphic"
SRC="figs/o8if.0602.gif"
ALT="Figure 6.2"><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3254"
></A
>Let's start in reverse. Here is the LOGON trigger:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: aq.sql */
CREATE OR REPLACE TRIGGER publish_logon
AFTER LOGON ON DATABASE
BEGIN
   oraevent.put ('This is a logon');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, there isn't much to it: every time someone logs in to the database, we'll put a message in the queue with a call to oraevent.put. So let's take a look at that procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE oraevent.put (details_in IN VARCHAR2) 
IS
   q_opts DBMS_AQ.ENQUEUE_OPTIONS_T;
   msg_props DBMS_AQ.MESSAGE_PROPERTIES_T;
   msg_handle RAW(16);
   event_l Event_t;
BEGIN
   /* Setting visibility to IMMEDIATE will
   || force the queue to &quot;commit&quot; before the
   || client transaction commits.
   */
   q_opts.visibility := DBMS_AQ.IMMEDIATE;
   event_l := Event_t.make(details_in);

   DBMS_AQ.ENQUEUE(queue_name =&gt; 'aqadmin.loginQ',
      enqueue_options =&gt; q_opts,
      message_properties =&gt; msg_props,
      payload =&gt; event_l,
      msgid =&gt; msg_handle);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3260"
></A
>This procedure calls DMBS_AQ.ENQUEUE to place a message, or <I
CLASS="firstterm"
>payload</I
>, in the loginQ queue. Each message is an object of type Event_t, defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE Event_t AS OBJECT (
   eventname VARCHAR2(64),
   details VARCHAR2(512),
   username VARCHAR2(30),
   timestamp DATE,
   STATIC FUNCTION make (
      details_in IN VARCHAR2) RETURN Event_t
);
/
CREATE OR REPLACE TYPE BODY Event_t 
AS
   STATIC FUNCTION make (
      details_in IN VARCHAR2) RETURN Event_t
   IS
   BEGIN
      RETURN Event_t(
         SYSEVENT, 
         details_in,
         LOGIN_USER, 
         SYSDATE);
   END;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The RETURN statement relies on two of the event-related functions, SYSEVENT and LOGIN_USER, to record characteristics at the time of login. </P
><P
CLASS="para"
>Run the <I
CLASS="filename"
>aq.sql</I
> script to create all elements and then test the code by spawning a second SQL*Plus session to watch or dequeue the login messages.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.3"
>6.2.1.3 Trapping system errors</A
></H4
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3270"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3273"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3275"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-3277"
></A
> The SERVERERROR event will prove to be a very handy mechanism. You can define it at the database level, which means that any error raised in any schema will be interceptable through the trigger. You can also define a trigger for this event at the schema level, limiting the scope of firing of the trigger. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-06-dbpipe"
></A
>Suppose that you simply want to keep track of errors raised in a particular application running on your instance. When an error occurs, you write a message to a database pipe. Another session (running asynchronously to the application users) can then wake up and dump the contents of the pipe and examine the errors.</P
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3283"
></A
> <A
CLASS="indexterm"
NAME="ch-06-dpp"
></A
>To facilitate that process, I have created and included on the disk a package called watch. Stored in <I
CLASS="filename"
>watch.pkg</I
> on the companion disk, this package allows you to watch actions and then direct a message constructed for that action to either the screen via DBMS_OUTPUT or to a pipe via DBMS_PIPE.</P
><BLOCKQUOTE
CLASS="tip"
><P
CLASS="para"
><STRONG
>TIP:</STRONG
> If you are comfortable with Oracle Advanced Queuing, you'll find that the AQ facility certainly offers a more robust architecture than the basic database pipes of DBMS_PIPE for intersession communication and logging. DBMS_PIPE, on the other hand, is easier to use and also very handy to know for a variety of development scenarios.</P
></BLOCKQUOTE
><P
CLASS="para"
>Using the watch package, I first create a utility procedure that I will call in my SERVERERROR triggers:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: serverr.trg */
CREATE OR REPLACE PROCEDURE pipe_error (
   context IN VARCHAR2, msg IN VARCHAR2)
IS
BEGIN
   /* Send the information to a pipe. */
   watch.topipe;
   
   /* Retrieve all system event attributes. */
   watch.action (context || ' trap_error', msg);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I can then define a trigger at the database level that displays all of the attributes available from within this trigger:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE TRIGGER trap_error 
  AFTER SERVERERROR ON DATABASE 
BEGIN
   pipe_error ('DATABASE', 
      sysevent || '-' ||
      instance_num || '-' ||
      database_name || '-' ||
      SQLCODE || '-' ||
      server_error (1) || '-' || 
      login_user
      );
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I will also define a SERVERERROR trigger for the SCOTT schema, so we can explore the way multiple triggers of the same type fire:<A
CLASS="indexterm"
NAME="AUTOID-3295"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE TRIGGER scott_trap_error 
  AFTER SERVERERROR ON SCOTT.SCHEMA 
BEGIN
   pipe_error (login_user, 
      sysevent || '-' ||
      instance_num || '-' ||
      database_name || '-' ||
      SQLCODE || '-' ||
      server_error (1) || '-' || 
      login_user
      );
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3298"
></A
> To test these triggers, I created the following script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: serverr.tst */
DECLARE
   exc EXCEPTION;
   PRAGMA EXCEPTION_INIT (exc, -&amp;1);
BEGIN
   RAISE exc;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now I will connect as SCOTT and run the script emulating a date-related error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @serverr.tst 1855
*
ERROR at line 1:
ORA-01855: AM/A.M. or PM/P.M. required</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the triggers fired, the watch pipe should contain some information. I can dump the contents of the pipe with a call to watch.show:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec watch.show
Contents of WATCH Trace:
***WATCHing at: June 1, 1999 12:54:14
   Context: SCOTT trap_error
   Message: SERVERERROR-1-ORACLE-0-1855-SCOTT
***WATCHing at: June 1, 1999 12:54:14
   Context: DATABASE trap_error
   Message: SERVERERROR-1-ORACLE-0-1855-SCOTT </PRE
></BLOCKQUOTE
><P
CLASS="para"
>We learn a few things from this execution:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3310"
></A
> The schema-level trigger fires before the database-level trigger. </P
></LI
></UL
><BLOCKQUOTE
CLASS="tip"
><P
CLASS="para"
><STRONG
>TIP:</STRONG
> Current behavior in the Oracle database is that a schema-level trigger will fire before a database-level trigger. This sequence is not, however, a documented feature and is subject to change in future versions of Oracle. You should design your triggers so that the trigger logic does <EM
CLASS="emphasis"
>not</EM
> depend on the firing sequence.</P
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3318"
></A
> By the time the SERVERERROR trigger fires, the SQLCODE function does not return the error that was raised. Instead, it returns 0. You must rely on the SERVER_ERROR function to retrieve the error at the top of the error stack.</P
></LI
></UL
><P
CLASS="para"
>Now I will connect to the DEMO account in my Oracle 8.1.5 instance and run this script for a different error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; connect demo/demo.
SQL&gt; @serverr.tst 1652
*
ERROR at line 1:
ORA-01652: unable to extend temp segment by <I
CLASS="replaceable"
>nnn</I
> in tablespace</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When I take a look at my pipe contents, I have only one entry:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec watch.show
Contents of WATCH Trace:
***WATCHing at: June 1, 1999 13:01:38
   Context: DATABASE trap_error
   Message: SERVERERROR-1-ORACLE-0-1652-DEMO</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And that is because I did not create a SERVERERROR trigger in the DEMO schema; only the database-level trigger is fired. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch06-SECT-2.1.4"
>6.2.1.4 Checking for specific errors</A
></H4
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3329"
></A
> <A
CLASS="indexterm"
NAME="ch-06-cset"
></A
>One other useful technique in this type of trigger is to check for a specific error and then take special action in that instance. There are two ways to do this:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-3337"
></A
> Use the trigger WHEN clause to restrict the execution of the trigger logic for a specific error.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use the IS_SERVERERROR function to determine if a specific error has been raised anywhere within the error call stack and then take action.</P
></LI
></UL
><P
CLASS="para"
>Let's see how each approach would work. First, suppose that I want to qualify my SERVERERROR trigger at the database level to fire only when the ORA-02292 error occurs ("integrity constraint (<EM
CLASS="emphasis"
>constant name</EM
>) violated - child record found").</P
><P
CLASS="para"
>I can create my trigger as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: serverr2.trg */
CREATE OR REPLACE TRIGGER scott_trap_parent_key 
  AFTER SERVERERROR ON DATABASE 
WHEN (SYS.SERVER_ERROR(1) = 2292)
BEGIN
   pipe_error (
      'DATABASE trap parent key', 
      'Invalid attempt to delete primary key by ' ||
      LOGIN_USER);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>My call to SYS.SERVER_ERROR(1) retrieves the error at the top of the error stack. There are two things to note in this procedure:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If I do not qualify the call to SERVER_ERROR with its owner, SYS, I get the following error:<A
CLASS="indexterm"
NAME="AUTOID-3349"
></A
></P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>AFTER SERVERERROR ON DATABASE
                       *
ERROR at line 2:
ORA-00942: table or view does not exist</PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>I must specify the error number as a positive, not negative, integer value. Otherwise, no match will be detected. </P
></LI
></UL
><P
CLASS="para"
>Once the trigger is defined, I test it by trying to delete a row from the dept table whose parent key is referenced by an employee:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; DELETE FROM dept WHERE deptno=10;
*
ERROR at line 1:
ORA-02292: integrity constraint (SCOTT.FK_DEPTNO) violated - 
           child record found</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I can now see what information was sent to my pipe within the trigger as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec watch.show
Contents of WATCH Trace:
***WATCHing at: June 2, 1999 16:27:09
   Context: DATABASE trap parent key trap_error
   Message: Invalid attempt to delete primary key by SCOTT</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-06-isadle"
></A
>Here I will demonstrate the IS_SERVERERROR approach with a modified version of the database-level trigger:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: serverr.trg */
CREATE OR REPLACE TRIGGER trap_error 
  AFTER SERVERERROR ON DATABASE 
BEGIN
   /* Same tracking as before. */
   pipe_error ('DATABASE', ...);
      
   IF IS_SERVERERROR (1652) -- POSITIVE NUMBER REQUIRED!
   THEN
      /* Add a file to the tablespace... just a dummy
         entry for the book. */
      pipe_error ('DATABASE', 'Add to tablespace');
   END IF;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3363"
></A
>And now if the ORA-01652 error is raised <EM
CLASS="emphasis"
>anywhere</EM
> in the error stack from the SCOTT schema, I see three entries in the error pipe:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; DECLARE
  2     exc EXCEPTION;
  3     PRAGMA EXCEPTION_INIT (exc, -1652);
  4  BEGIN
  5     RAISE exc;
  6  EXCEPTION 
  7     WHEN OTHERS THEN
  8        RAISE VALUE_ERROR;
  9  END;
 10  /
*
ERROR at line 1:
ORA-06502: PL/SQL: numeric or value error
ORA-01652: unable to extend temp segment by <I
CLASS="replaceable"
>nnn</I
> in tablespace

SQL&gt; exec watch.show
Contents of WATCH Trace:
***WATCHing at: June 3, 1999 09:47:05
   Context: SCOTT trap_error
   Message: SERVERERROR-1-ORACLE-0-6502-SCOTT
***WATCHing at: June 3, 1999 09:47:05
   Context: DATABASE trap_error
   Message: SERVERERROR-1-ORACLE-0-6502-SCOTT
***WATCHing at: June 3, 1999 09:47:05
   Context: DATABASE trap_error
   Message: Add to tablespace</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="warning"
><P
CLASS="para"
><STRONG
>WARNING:</STRONG
> When you use IS_SERVERERROR, you must pass a <EM
CLASS="emphasis"
>positive</EM
> number for it to find a match on the error. So we must wonder once again: are Oracle error numbers negative or positive? It looks like the folks at Oracle have trouble giving a consistent answer to this question.<A
CLASS="indexterm"
NAME="AUTOID-3371"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3372"
></A
></P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_01.htm"
TITLE="6.1 Triggers on Nested Table View Columns"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.1 Triggers on Nested Table View Columns"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming Guide to Oracle 8i Features"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_03.htm"
TITLE="6.3 Schema-Level Event Triggers"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.3 Schema-Level Event Triggers"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.1 Triggers on Nested Table View Columns</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.3 Schema-Level Event Triggers</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
