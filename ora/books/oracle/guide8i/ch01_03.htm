<HTML
><HEAD
><TITLE
>[Chapter 1] 1.3 New PL/SQL Features Roundup</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:24:35Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CDROM-1-56592-675-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-675-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle 8i Features"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Oracle8i: A Bounty for PL/SQL Developers"><LINK
REL="prev"
HREF="ch01_02.htm"
TITLE="1.2 And Then There's Java"><LINK
REL="next"
HREF="ch02_01.htm"
TITLE="2. Choose Your Transaction!"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.2 And Then There's Java"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.2 And Then There's Java"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Oracle8i: A Bounty for PL/SQL Developers"
>Chapter 1<BR>Oracle8i: A Bounty for PL/SQL Developers</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch02_01.htm"
TITLE="2. Choose Your Transaction!"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2. Choose Your Transaction!"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch01-64971"
>1.3 New PL/SQL Features Roundup</A
></H2
><P
CLASS="para"
>Even if I stick to the narrow course of exploring only those PL/SQL-related new features of Oracle8<EM
CLASS="emphasis"
>i</EM
>, I can still find <EM
CLASS="emphasis"
>lots</EM
> to talk about. This section previews the chapters of the book and introduces you to the main PL/SQL enhancements in this release of Oracle.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.1"
>1.3.1 Autonomous Transactions (<A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="Choose Your Transaction!"
>Chapter 2, Choose Your Transaction!</A
>)</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="ch-01-auton"
></A
> <A
CLASS="indexterm"
NAME="ch-01-datamanlang"
></A
> <A
CLASS="indexterm"
NAME="ch-01-dml2"
></A
> <A
CLASS="indexterm"
NAME="ch-01-autr"
></A
>  One long-standing request from PL/SQL developers has been to have the ability to execute and then save or cancel certain Data Manipulation Language (DML) statements (INSERT, UPDATE, DELETE) without affecting the overall session's transaction. You can now do this with <I
CLASS="filename"
>autonomous transactions</I
>. </P
><P
CLASS="para"
>Where would you find autonomous transactions useful in your applications? Here are some ideas:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Logging mechanism</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-393"
></A
>This is the classic example of the need for an autonomous transaction. You need to log error information in a database table, but don't want that log entry to be a part of the logical transaction.</P
></DD
><DT
CLASS="term"
>Commits or rollbacks in your database triggers</DT
><DD
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-399"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-402"
></A
><A
CLASS="indexterm"
NAME="AUTOID-404"
></A
><A
CLASS="indexterm"
NAME="AUTOID-406"
></A
>Finally! If you define a trigger as an autonomous transaction, then you can commit and/or roll back in that code.</P
></DD
><DT
CLASS="term"
>Retry counter</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-412"
></A
>Autonomous transactions can help you keep track of how many times a user tries to connect to a database or get access to a resource (you'll reject access after a certain number of attempts).</P
></DD
><DT
CLASS="term"
>Software usage meter</DT
><DD
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-418"
></A
> A similar type of situation is when you want to track how often a program is called during an application session. In fact, autonomous transactions are helpful in meeting any application requirement that calls for persistently storing a state (how many times did Joe try to update the salary column?).</P
></DD
><DT
CLASS="term"
>Reusable application components</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-424"
></A
>You are building an Internet application. You want to combine components from many different vendors and layers. They need to interact in certain well-defined ways. If when one component commits, it affects all other aspects of your application, it will not function well in this environment.</P
></DD
></DL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-427"
></A
><A
CLASS="indexterm"
NAME="AUTOID-429"
></A
>When you define a PL/SQL block (anonymous block, procedure, function, packaged procedure, packaged function, database trigger) as an autonomous transaction, you isolate the DML in that block from the rest of your session. That block becomes an independent transaction that is started by another transaction, referred to as the <EM
CLASS="emphasis"
>main transaction</EM
>. Within the autonomous transaction block, the main transaction is suspended. You perform your SQL operations, commit or roll back those operations, and then resume the main transaction.</P
><P
CLASS="para"
>There isn't much involved in defining a PL/SQL block as an autonomous transaction. You simply include the following statement in your declaration section:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA AUTONOMOUS_TRANSACTION;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is a very simple logging mechanism relying on the autonomous transaction feature to save changes to the log without affecting the rest of the session's transaction:<A
CLASS="indexterm"
NAME="AUTOID-435"
></A
><A
CLASS="indexterm"
NAME="AUTOID-436"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE write_log (
   code IN INTEGER, text IN VARCHAR2)
IS
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   INSERT INTO log VALUES (
      code, text, 
      USER, SYSDATE
      );
   COMMIT:
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Of course, there are all sorts of rules and some restrictions to be aware of; see <A
CLASS="xref"
HREF="ch02_01.htm"
>Chapter 2</A
>, for all the details.<A
CLASS="indexterm"
NAME="AUTOID-440"
></A
><A
CLASS="indexterm"
NAME="AUTOID-441"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.2"
>1.3.2 Invoker Rights (<A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Invoker Rights: Your Schema or Mine? "
>Chapter 3, Invoker Rights: Your Schema or Mine? </A
>)</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-446"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-448"
></A
><A
CLASS="indexterm"
NAME="AUTOID-450"
></A
><A
CLASS="indexterm"
NAME="AUTOID-454"
></A
>Back in the "old days" of Oracle7 and Oracle 8.0, whenever you executed a stored program, it executed under the authority of the owner of that program. This was not a big deal if your entire application&nbsp;-- code, data, and users&nbsp;-- worked out of the same Oracle account. That scenario probably fit about 0.5% of all Oracle shops. It proved to be a real pain in the neck for the other 99.5%, though, because usually code was stored in one schema and then shared through GRANT EXECUTE statements with other users (directly or through roles).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-01-dsp"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-459"
></A
> For one thing, that centralized, stored code would not automatically apply the privileges of a user (also known as an <EM
CLASS="emphasis"
>invoker</EM
>) to the code's objects. The user might not have had DELETE privileges on a table, but the stored code did, so delete away! Now, in some circumstances, that is just how you wanted it to work. In others, particularly when you were executing programs relying on the DBMS_SQL (dynamic SQL) package, awesome complications could ensue.</P
><P
CLASS="para"
>In Oracle 8.1, PL/SQL has now been enhanced so that at the time of compilation, you can decide whether a program (or all programs in a package) should run under the authority of the definer (the only choice in Oracle 8.0 and below) or of the invoker of that program.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-464"
></A
><A
CLASS="indexterm"
NAME="AUTOID-466"
></A
>The syntax to support this feature is simple enough. Here is a generic "run DDL" engine that relies on the new native dynamic SQL statement EXECUTE IMMEDIATE: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE runddl (ddl_in in VARCHAR2)
   AUTHID CURRENT_USER 
IS
BEGIN
   EXECUTE IMMEDIATE ddl_in;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-470"
></A
><A
CLASS="indexterm"
NAME="AUTOID-472"
></A
>The AUTHID CURRENT_USER clause before the IS keyword indicates that when runddl executes, it should run under the authority of the invoker, or "current user," not the authority of the definer. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.3"
>1.3.3 Native Dynamic SQL (<A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="Native Dynamic SQL in Oracle8i"
>Chapter 4, Native Dynamic SQL in Oracle8i</A
>)</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-478"
></A
><A
CLASS="indexterm"
NAME="AUTOID-480"
></A
><A
CLASS="indexterm"
NAME="ch-01-natdyn"
></A
><A
CLASS="indexterm"
NAME="ch-01-or8nat"
></A
>Ever since Oracle 7.1, we PL/SQL developers have been able to use the built-in DBMS_SQL package to execute dynamic SQL and PL/SQL. This means that at runtime you can construct the query, a DELETE or CREATE TABLE, or even a PL/SQL block, as a string&nbsp;-- and then execute it. Dynamic SQL comes in extremely handy when you are building ad hoc query systems, when you need to execute Data Definition Language (DDL) inside PL/SQL, and just generally when you don't know in advance exactly what you need to do or what the user will want to do. Dynamic SQL is a frequent requirement in Web-based applications.</P
><P
CLASS="para"
>But there are some problems with DBMS_SQL: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>It is a very complicated package. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>It has a number of restrictions (such as not recognizing and being able to work with new Oracle8 datatypes).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>It is relatively slow.</P
></LI
></UL
><P
CLASS="para"
>So our dear friends at PL/SQL Central in Redwood Shores took pity on us all and reimplemented dynamic SQL directly in the PL/SQL language itself. This is called <EM
CLASS="emphasis"
>native dynamic SQL</EM
> (NDS). </P
><P
CLASS="para"
>In my latest book on PL/SQL, <CITE
CLASS="citetitle"
>Oracle Built-in Packages</CITE
> (O'Reilly &amp; Associates, coauthored with John Beresniewicz and Charles Dye), I spent about 100 pages explaining dynamic SQL and the DBMS_SQL package. While NDS makes it much easier to get your dynamic job done, there is still a whole lot to say on this subject. Let's just compare a DBMS_SQL and NDS implementation of a program that displays all the employees for the specified and dynamic WHERE clause.</P
><P
CLASS="para"
>The DBMS_SQL implementation:<A
CLASS="indexterm"
NAME="AUTOID-501"
></A
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE showemps (
   where_in IN VARCHAR2 := NULL)
IS
   cur INTEGER := DBMS_SQL.OPEN_CURSOR;
   rec employee%ROWTYPE;
   fdbk INTEGER;
BEGIN
   DBMS_SQL.PARSE
     (cur, 
      'SELECT employee_id, last_name 
         FROM employee 
        WHERE ' || NVL (where_in, '1=1'),
      DBMS_SQL.NATIVE);
   DBMS_SQL.DEFINE_COLUMN (cur, 1, 1);
   DBMS_SQL.DEFINE_COLUMN (cur, 2, user, 30);
   fdbk := DBMS_SQL.EXECUTE (cur);
   LOOP
      /* Fetch next row. Exit when done. */
      EXIT WHEN DBMS_SQL.FETCH_ROWS (cur) = 0;
      DBMS_SQL.COLUMN_VALUE (cur, 1, rec.employee_id);
      DBMS_SQL.COLUMN_VALUE (cur, 2, rec.last_name);
      DBMS_OUTPUT.PUT_LINE (
         TO_CHAR (rec.employee_id) || '=' || 
         rec.last_name);
   END LOOP;
   DBMS_SQL.CLOSE_CURSOR (cur);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And now the NDS implementation:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE showemps (
   where_in IN VARCHAR2 := NULL)
IS
   TYPE cv_typ IS REF CURSOR;
   cv cv_typ;
   v_id employee.employee_id%TYPE;
   v_nm employee.last_name%TYPE;
BEGIN
   OPEN cv FOR 
      'SELECT employee_id, last_name 
         FROM employee 
        WHERE ' || NVL (where_in, '1=1');
   LOOP
      FETCH cv INTO v_id, v_nm;
      EXIT WHEN cv%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE (TO_CHAR (v_id) || '=' || v_nm);
   END LOOP;
   CLOSE cv;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I know which one I would prefer. I'll be looking at native dynamic SQL in much more detail in <A
CLASS="xref"
HREF="ch04_01.htm"
>Chapter 4</A
>. And if you are an expert at DBMS_SQL and feel tears coming to your eyes about all that wasted intellectual property, take heart in these factoids:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>No one has invested more time and typed words in DBMS_SQL than yours truly.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>DBMS_SQL is not completely obsolete. There are still times when you will want to use it instead of NDS, and there are things you can do with DBMS_SQL that are not yet possible with NDS.<A
CLASS="indexterm"
NAME="AUTOID-512"
></A
><A
CLASS="indexterm"
NAME="AUTOID-513"
></A
></P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.4"
>1.3.4 Bulk Binds and Collects (<A
CLASS="xref"
HREF="ch05_01.htm"
TITLE="Bulking Up with PL/SQL 8.1"
>Chapter 5, Bulking Up with PL/SQL 8.1</A
>)</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-01-bbinds"
></A
><A
CLASS="indexterm"
NAME="ch-01-bbcollect"
></A
>One of the major priorities of the PL/SQL development team is to speed up the performance of their language. This effort cannot come a moment too soon. We developers have been complaining about runtime performance for years, and finally the developers are responding (though, to be brutally honest, it seems to me that the intensive tuning steps taken in Oracle 8.0 were motivated at least partly by the need to make PL/SQL fast enough to support object types).</P
><P
CLASS="para"
>One area of improvement concerns the execution of "bulk" DML inside PL/SQL. Consider, for example, the following code that deletes each employee identified by the employee number found in the nested table list:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TYPE empnos_list_t IS VARRARY(100) OF NUMBER;
CREATE OR REPLACE del_emps (list_in IN empnos_list_t)
IS
BEGIN
   FOR listnum IN list_in.FIRST.. list_in.LAST 
   LOOP
      DELETE FROM emp WHERE empno = list_in (listnum);
   END LOOP;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-527"
></A
>Easy to write, easy to read. But what about performance? Whenever this program issues its DELETE, a <EM
CLASS="emphasis"
>context switch</EM
> takes place from PL/SQL to SQL to execute that command. If there are 100 elements in the list, there are 100 switches, with corresponding performance degradation.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-531"
></A
><A
CLASS="indexterm"
NAME="AUTOID-533"
></A
>Recognizing this common requirement and its overhead, Oracle now offers a <EM
CLASS="emphasis"
>bulk bind</EM
> variation on the FOR loop&nbsp;-- the FORALL statement. With this statement, you can recode the del_emps procedure as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE del_emps (list_in IN empnos_list_t)
IS
BEGIN
   FORALL listnum IN list_in.FIRST.. list_in.LAST 
   LOOP
      DELETE FROM emp WHERE empno = list_in (listnum);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now there will be just <EM
CLASS="emphasis"
>one</EM
> context switch: all of the DELETE operations will be bundled into a single bulk operation and passed to the SQL layer together. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-540"
></A
><A
CLASS="indexterm"
NAME="AUTOID-542"
></A
>In addition to the FORALL bulk DML operator, Oracle 8.1 also offers the BULK COLLECT variation on the INTO clause of an implicit query. This operation allows you to retrieve multiple rows in a single context switch.<A
CLASS="indexterm"
NAME="AUTOID-544"
></A
><A
CLASS="indexterm"
NAME="AUTOID-545"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.5"
>1.3.5 New Trigger Capabilities (<A
CLASS="xref"
HREF="ch06_01.htm"
TITLE="New Trigger Features in Oracle8i"
>Chapter 6, New Trigger Features in Oracle8i</A
>)</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-550"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-552"
></A
><A
CLASS="indexterm"
NAME="ch-01-trigor"
></A
>Oracle8<EM
CLASS="emphasis"
>i</EM
> expands significantly the use of triggers to administer a database and "publish" information about events taking place within the database. By employing database triggers on the newly defined system events and using Oracle Advanced Queuing within those triggers, you can take advantage of the publish/subscribe capabilities of Oracle8<EM
CLASS="emphasis"
>i</EM
>.</P
><P
CLASS="para"
>The database event publication feature allows applications to subscribe to database events just as they subscribe to messages from other applications. The trigger syntax is extended to support system and other data events on database or schema. Trigger syntax also supports a CALL to a procedure as the trigger body. </P
><P
CLASS="para"
>You can now enable the publication of (i.e., define a programmatic trigger on) the following actions:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-565"
></A
><A
CLASS="indexterm"
NAME="AUTOID-567"
></A
><A
CLASS="indexterm"
NAME="AUTOID-569"
></A
><A
CLASS="indexterm"
NAME="AUTOID-571"
></A
>DML statements (DELETE, INSERT, and UPDATE) </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-575"
></A
><A
CLASS="indexterm"
NAME="AUTOID-577"
></A
><A
CLASS="indexterm"
NAME="AUTOID-579"
></A
>DDL events (e.g., CREATE, DROP, and ALTER)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-583"
></A
><A
CLASS="indexterm"
NAME="AUTOID-585"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-587"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-589"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-591"
></A
> Database events (SERVERERROR, LOGON, LOGOFF, STARTUP, and SHUTDOWN)</P
></LI
></UL
><P
CLASS="para"
>These are the new trigger features available in Oracle8<EM
CLASS="emphasis"
>i</EM
>:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Triggers on nested table columns</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-600"
></A
><A
CLASS="indexterm"
NAME="AUTOID-602"
></A
>The CAST. . .MULTISET operation allows you to trigger activity when only an attribute in a nested table column is modified.</P
></DD
><DT
CLASS="term"
>Database-level event triggers</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-609"
></A
>You can now define triggers to respond to such system events as LOGON, DATABASE SHUTDOWN, and even SERVERERROR.</P
></DD
><DT
CLASS="term"
>Schema-level event triggers</DT
><DD
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-615"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-617"
></A
><A
CLASS="indexterm"
NAME="AUTOID-619"
></A
>You can now define triggers to respond to such user- or schema-level events as CREATE, DROP, and ALTER.<A
CLASS="indexterm"
NAME="AUTOID-621"
></A
></P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.6"
>1.3.6 New and Enhanced Built-in Packages (<A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="New and Enhanced Built-in Packages in Oracle8i"
>Chapter 7, New and Enhanced Built-in Packages in Oracle8i</A
>)</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-626"
></A
><A
CLASS="indexterm"
NAME="ch-01-bipacks"
></A
>Oracle has added a number of new built-in packages in Oracle8<EM
CLASS="emphasis"
>i</EM
>. Many of them are for fairly specialized purposes, such as the replication facility or online analytical processing (OLAP)/data warehouse optimization, but a number of the packages, including those listed here, will come in very handy for database administrators (DBAs) and PL/SQL developers:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>DBMS_JAVA</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-638"
></A
>Gives you the ability to modify the behavior of the Aurora Java Virtual Machine (JVM) in Oracle. You can enable output (meaning that System.out.println will act like DBMS_OUTPUT.PUT_LINE), set compiler and debugger options, and more.</P
></DD
><DT
CLASS="term"
>DBMS_PROFILER</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-644"
></A
>Accesses performance and code coverage analysis of your PL/SQL application.</P
></DD
><DT
CLASS="term"
>DBMS_RLS</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-650"
></A
>Offers an interface to the fine-grained access control administrative features of Oracle8<EM
CLASS="emphasis"
>i</EM
>; it is only available with the Enterprise Edition.</P
></DD
><DT
CLASS="term"
>DBMS_TRACE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-657"
></A
>Allows PL/SQL developers to trace the execution of stored PL/SQL functions, procedures, and exceptions. </P
></DD
><DT
CLASS="term"
>UTL_COLL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Allows PL/SQL programs to use collection locators in order to perform queries and updates.</P
></DD
></DL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-664"
></A
><A
CLASS="indexterm"
NAME="AUTOID-666"
></A
><A
CLASS="indexterm"
NAME="AUTOID-668"
></A
>Oracle has also enhanced a number of packages, including DBMS_UTILITY, DBMS_AQ, and DBMS_LOB. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch07_01.htm"
>Chapter 7</A
>, introduces you to a subset of the capabilities of these packages. Comprehensive, reference-oriented coverage of these packages will be included in the second edition of <CITE
CLASS="citetitle"
>Oracle Built-in Packages</CITE
> (O'Reilly &amp; Associates, expected in 2000).<A
CLASS="indexterm"
NAME="AUTOID-673"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.7"
>1.3.7 Fine-Grained Access Control (<A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="Deploying Fine-Grained Access Control"
>Chapter 8, Deploying Fine-Grained Access Control</A
>)</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-678"
></A
> <A
CLASS="indexterm"
NAME="ch-01-fine"
></A
><A
CLASS="indexterm"
NAME="ch-01-grainacc"
></A
><A
CLASS="indexterm"
NAME="AUTOID-686"
></A
>Fine-grained access control (FGAC) is a new feature in Oracle8<EM
CLASS="emphasis"
>i</EM
> that allows you to implement security policies with functions and then use those security policies to implement row-level security on tables or views. The database server automatically enforces security policies, no matter how the data is accessed&nbsp;-- through SQL*Plus or the Internet, as an ad hoc query, or as an update processed through an Oracle Forms application. </P
><P
CLASS="para"
>What, you might ask, is a security policy? Consider the following very simple scenario (I'll expand upon this scenario in <A
CLASS="xref"
HREF="ch08_01.htm"
>Chapter 8</A
>  ). Suppose that I have tables of hospital patients and their doctors defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE patient ( 
   patient_id NUMBER,  
   name VARCHAR2(100), 
   dob DATE,           
   doctor_id INTEGER
   ); 

CREATE TABLE doctor (
   doctor_id NUMBER,
   name VARCHAR2(100)
 );</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now suppose that I want to let a doctor see only her patients when she issues a query against the table. More than that, I don't want to let doctors modify patient records unless they are that doctor's patients. You could achieve much of what is needed through the creation of a set of views, but wouldn't it be grand if you could just let any doctor connect to her schema in Oracle and say:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT * FROM patient;  </PRE
></BLOCKQUOTE
><P
CLASS="para"
>and see only her patients? In other words, hide all the rules needed to enforce the appropriate privacy and security rules (the <EM
CLASS="emphasis"
>policy</EM
>) so that the policy is transparent to users of the data structures. That's what the fine-grained access control feature does for you!</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-697"
></A
>With Oracle8<EM
CLASS="emphasis"
>i</EM
> 's fine-grained access control, also known as <EM
CLASS="emphasis"
>row-level security</EM
>, you can apply different policies to SELECT, INSERT, UPDATE, and DELETE, and use security policies only where you need them (for example, on salary information). You can also design and enforce more than one policy for a table, and can even construct layers of policies (one policy building on top of an existing policy) to handle complex situations.<A
CLASS="indexterm"
NAME="AUTOID-701"
></A
><A
CLASS="indexterm"
NAME="AUTOID-702"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.8"
>1.3.8 Calling Java from PL/SQL (<A
CLASS="xref"
HREF="ch09_01.htm"
TITLE="Calling Java from PL/SQL"
>Chapter 9, Calling Java from PL/SQL</A
>)</A
></H3
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-707"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-709"
></A
><A
CLASS="indexterm"
NAME="AUTOID-712"
></A
> <A
CLASS="indexterm"
NAME="AUTOID-715"
></A
>Java is a very powerful language, much more robust in many ways than PL/SQL. Java also offers hundreds of classes that provide clean, easy-to-use application programming interfaces (APIs) to a wide range of functionality.</P
><P
CLASS="para"
>In Oracle8<EM
CLASS="emphasis"
>i</EM
>, Oracle includes a new product called JServer. JServer consists of the following elements:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-723"
></A
><A
CLASS="indexterm"
NAME="AUTOID-726"
></A
>Oracle's Java Virtual Machine, called Aurora, the supporting runtime environment, and Java class libraries </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-730"
></A
><A
CLASS="indexterm"
NAME="AUTOID-732"
></A
>Tight integration with PL/SQL and Oracle relational database management system (RDBMS) functionality </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-737"
></A
><A
CLASS="indexterm"
NAME="AUTOID-739"
></A
><A
CLASS="indexterm"
NAME="AUTOID-741"
></A
><A
CLASS="indexterm"
NAME="AUTOID-743"
></A
>An Object Request Broker (the Aurora/ORB) and Enterprise JavaBeans(TM) (EJB) </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-747"
></A
>The JServer Accelerator (native compiler); available in the 8.1.6 Enterprise Edition only</P
></LI
></UL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-750"
></A
><A
CLASS="indexterm"
NAME="AUTOID-752"
></A
>The Aurora JVM executes Java methods (also known as Java stored procedures, or JSPs) and classes if they are stored in the database itself. This means that even if you are a full-time Oracle PL/SQL developer, you can take advantage of the wonderful world of Java to build your applications.</P
><P
CLASS="para"
>Java in the Oracle database is a big topic; Java programming all by itself is an even bigger topic. Complete treatment of either is outside the scope of this book. <A
CLASS="xref"
HREF="ch09_01.htm"
>Chapter 9</A
>, focuses on the exciting new feature of Oracle8<EM
CLASS="emphasis"
>i</EM
> that allows a developer to call Java stored procedures from within PL/SQL. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-SECT-3.9"
>1.3.9 Miscellaneous New Features and Performance Improvements (<A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="More Goodies for Oracle8i PL/SQL Developers"
>Chapter 10, More Goodies for Oracle8i PL/SQL Developers</A
>)</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-01-improv"
></A
>By the time you get to <A
CLASS="xref"
HREF="ch10_01.htm"
>Chapter 10</A
>, you will have learned about a wide range of significant new capabilities in PL/SQL. Yet there is still more! This chapter covers some other features that improve either the performance or usability of PL/SQL in Oracle8<EM
CLASS="emphasis"
>i</EM
>. I'll also review transparent improvements, that is, changes to the language that improve the performance or behavior of your PL/SQL-based applications without necessitating any modifications to your code.</P
><P
CLASS="para"
>Major topics include the following:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>The NOCOPY compiler hint</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-773"
></A
>You can avoid the overhead of copying IN OUT parameter values with this enhancement. When you are working with large collections and records, NOCOPY can have a noticeable impact on program performance.</P
></DD
><DT
CLASS="term"
>Calling PL/SQL functions from SQL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-779"
></A
><A
CLASS="indexterm"
NAME="AUTOID-781"
></A
>Oracle8<EM
CLASS="emphasis"
>i </EM
>offers some big relief for PL/SQL developers when it comes to calling their own functions: you no longer have to use the RESTRICT_REFERENCES pragma! Oracle8<EM
CLASS="emphasis"
>i</EM
> also offers two new keywords, DETERMINISTIC and PARALLEL_ENABLE, to help you integrate your PL/SQL, C, and Java code into all aspects of your database.</P
></DD
><DT
CLASS="term"
>SQL99 compliance</DT
><DD
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-789"
></A
> Oracle8<EM
CLASS="emphasis"
>i</EM
> adds or expands the TRIM and CAST operators to better support the SQL99 standard.</P
></DD
><DT
CLASS="term"
>SQL operations on collections</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Oracle8<EM
CLASS="emphasis"
>i</EM
> makes it even easier to integrate PL/SQL (transient) collections into SQL statements. <A
CLASS="indexterm"
NAME="AUTOID-797"
></A
></P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_02.htm"
TITLE="1.2 And Then There's Java"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.2 And Then There's Java"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming Guide to Oracle 8i Features"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="chapter"
HREF="ch02_01.htm"
TITLE="2. Choose Your Transaction!"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2. Choose Your Transaction!"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.2 And Then There's Java</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>2. Choose Your Transaction!</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
