<HTML
><HEAD
><TITLE
>[Chapter 5] 5.4 Using Cursor Attributes</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:25:55Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CDROM-1-56592-675-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-675-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle 8i Features"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch05_01.htm"
TITLE="5. Bulking Up with PL/SQL 8.1"><LINK
REL="prev"
HREF="ch05_03.htm"
TITLE="5.3 Bulk Querying with the BULK COLLECT Clause"><LINK
REL="next"
HREF="ch05_05.htm"
TITLE="5.5 Analyzing the Impact of Bulk Operations"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_03.htm"
TITLE="5.3 Bulk Querying with the BULK COLLECT Clause"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.3 Bulk Querying with the BULK COLLECT Clause"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch05_01.htm"
TITLE="5. Bulking Up with PL/SQL 8.1"
>Chapter 5<BR>Bulking Up with PL/SQL 8.1</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_05.htm"
TITLE="5.5 Analyzing the Impact of Bulk Operations"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.5 Analyzing the Impact of Bulk Operations"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch05-74397"
>5.4 Using Cursor Attributes</A
></H2
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-2679"
></A
> <A
CLASS="indexterm"
NAME="ch-05-curat"
></A
><A
CLASS="indexterm"
NAME="ch-05-plcursats"
></A
>Whenever you work with explicit and implicit cursors (including cursor variables), PL/SQL provides a set of cursor attributes that return information about the cursor. PL/SQL 8.1 adds another, composite attribute, SQL%BULK_ROWCOUNT, for use with or after the FORALL statement. All of the current attributes are summarized in <A
CLASS="xref"
HREF="ch05_04.htm"
>Table 5.1</A
>.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch05-75759"
>Table 5.1: Cursor Attributes </A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Cursor Attribute</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Effect</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2700"
></A
><I
CLASS="filename"
>cur</I
> %FOUND</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns TRUE if the last FETCH found a row</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2708"
></A
><I
CLASS="filename"
>cur</I
> %NOTFOUND</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns FALSE if the last FETCH found a row</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2716"
></A
><I
CLASS="filename"
>cur</I
> %ISOPEN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns TRUE if the specified cursor is open</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2724"
></A
><I
CLASS="filename"
>cur</I
> %ROWCOUNT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the number of rows modified by the DML statement</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SQL%BULK_ROWCOUNT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the number of rows processed for each execution of the bulk DML operation</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>In these attributes, <I
CLASS="filename"
>cur</I
> is the name of an explicit cursor, a cursor variable, or the string "SQL" for implicit cursors (UPDATE, DELETE, and INSERT statements, since none of the attributes can be applied to an implicit query). The %BULK_ROWCOUNT structure has the same semantics as an index-by table. The <EM
CLASS="emphasis"
>n </EM
>th row in this pseudo index-by table stores the number of rows processed by the <EM
CLASS="emphasis"
>n </EM
>th execution of the DML operation in the FORALL statement. </P
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-2739"
></A
> Let's examine the behavior of these cursor attributes in FORALL and BULK COLLECT statements by running the script found in the <I
CLASS="filename"
>showattr.sql</I
> file on the disk. I start out by creating a utility function and general show_attributes procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: showattr.sql */
CREATE OR REPLACE FUNCTION boolstg (bool IN BOOLEAN)
   RETURN VARCHAR2
IS
BEGIN
   IF bool THEN RETURN 'TRUE ';
   ELSIF NOT bool THEN RETURN 'FALSE';
   ELSE RETURN 'NULL ';
   END IF;
END;
/

CREATE OR REPLACE PROCEDURE show_attributes (
   depts IN number_varray)
IS
BEGIN
   FORALL indx IN depts.FIRST .. depts.LAST
      UPDATE emp
         SET sal = sal + depts(indx)
       WHERE deptno = depts(indx);

   DBMS_OUTPUT.PUT_LINE (
      'FOUND-' || boolstg(SQL%FOUND) || ' ' ||
      'NOTFOUND-' || boolstg(SQL%NOTFOUND) || ' ' ||
      'ISOPEN-' || boolstg(SQL%ISOPEN) || ' ' ||
      'ROWCOUNT-' || NVL (TO_CHAR (SQL%ROWCOUNT), 'NULL'));

   FOR indx IN depts.FIRST .. depts.LAST
   LOOP
      DBMS_OUTPUT.PUT_LINE (
         depts(indx) || '-' || SQL%BULK_ROWCOUNT(indx));
   END LOOP;

   ROLLBACK;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Then I run a query to show some data and show the attributes for two different lists of department numbers, followed by a use of BULK COLLECT:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT deptno, COUNT(*) FROM emp GROUP BY deptno;

DECLARE
   /* No employees in departments 98 and 99 */
   depts1 number_varray := number_varray (10, 20, 98);
   depts2 number_varray := number_varray (99, 98);
BEGIN
   show_attributes (depts1);
   show_attributes (depts2);
END;
/ 
DECLARE
   CURSOR allsals IS
      SELECT sal FROM emp;
   salaries number_varray;
BEGIN
   OPEN allsals; 
   FETCH allsals BULK COLLECT INTO salaries;
 
   DBMS_OUTPUT.PUT_LINE (
      'FOUND-' || boolstg(SQL%FOUND) || ' ' ||
      'NOTFOUND-' || boolstg(SQL%NOTFOUND) || ' ' ||
      'ISOPEN-' || boolstg(SQL%ISOPEN) || ' ' ||
      'ROWCOUNT-' || NVL (TO_CHAR (SQL%ROWCOUNT), 'NULL'));
END;
/ </PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the output from this script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DEPTNO COUNT(*)
------ ---------
    10         3
    20         5
    30         6

FOUND-TRUE  NOTFOUND-FALSE ISOPEN-FALSE ROWCOUNT-8
10-3
98-0
20-5
FOUND-FALSE NOTFOUND-TRUE  ISOPEN-FALSE ROWCOUNT-0
99-0
98-0
FOUND-NULL  NOTFOUND-NULL  ISOPEN-FALSE ROWCOUNT-NULL</PRE
></BLOCKQUOTE
><P
CLASS="para"
>From this output, we can conclude the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-05-foundcurat"
></A
><A
CLASS="indexterm"
NAME="ch-05-notfndca"
></A
>For FORALL, %FOUND and %NOTFOUND reflect the overall results, not the results of any individual statement, including the last (this contradicts Oracle documentation). In other words, if any one of the statements executed in the FORALL modified at least one row, %FOUND returns TRUE and %NOTFOUND returns FALSE.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-05-isopen"
></A
>For FORALL, %ISOPEN always returns FALSE because the cursor is closed when the FORALL statement terminates.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2761"
></A
>For FORALL, %ROWCOUNT returns the total number of rows affected by all the FORALL statements executed, not simply the last statement.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>For BULK COLLECT, %FOUND and %NOTFOUND always return NULL and %ISOPEN returns FALSE because the BULK COLLECT has completed the fetching and closed the cursor. %ROWCOUNT always returns NULL, since this attribute is only relevant for DML statements.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2767"
></A
>The <EM
CLASS="emphasis"
>n</EM
>th row in this pseudo index-by table stores the number of rows processed by the <EM
CLASS="emphasis"
>n </EM
>th execution of the DML operation in the FORALL statement. If no rows are processed, then the value in %BULK_ROWCOUNT is set to 0.</P
></LI
></UL
><P
CLASS="para"
>The %BULK_ROWCOUNT attribute is a handy device, but it is also quite limited. Keep the following in mind:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Even though it looks like an index-by table, you cannot apply any methods to it. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-2777"
></A
> %BULK_ROWCOUNT cannot be assigned to other collections. Also, it cannot be passed as a parameter to subprograms.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The only rows defined for this pseudo index-by table are the same rows defined in the collection referenced in the FORALL statement.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2783"
></A
>If you reference a row in %BULK_ROWCOUNT that is outside the defined subscripts, you will <EM
CLASS="emphasis"
>not</EM
> raise a NO_DATA_FOUND error or subscript error. It will simply return a NULL value.</P
></LI
></UL
><P
CLASS="para"
>If I try to execute code like either of these statements:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DBMS_OUTPUT.PUT_LINE (SQL%BULK_ROWCOUNT.COUNT);

IF SQL%BULK_ROWCOUNT.FIRST IS NOT NULL</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I get this error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLS-00332: &quot;%BULK_ROWCOUNT&quot; is not a valid prefix for a qualified name</PRE
></BLOCKQUOTE
><P
CLASS="para"
>All you can really do with %BULK_ROWCOUNT is reference individual rows in this special structure.<A
CLASS="indexterm"
NAME="AUTOID-2791"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2792"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2793"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2794"
></A
></P
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_03.htm"
TITLE="5.3 Bulk Querying with the BULK COLLECT Clause"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.3 Bulk Querying with the BULK COLLECT Clause"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming Guide to Oracle 8i Features"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch05_05.htm"
TITLE="5.5 Analyzing the Impact of Bulk Operations"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.5 Analyzing the Impact of Bulk Operations"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.3 Bulk Querying with the BULK COLLECT Clause</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>5.5 Analyzing the Impact of Bulk Operations</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
