<HTML
><HEAD
><TITLE
>[Chapter 4] 4.2 NDS Statement Summary</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:25:16Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CDROM-1-56592-675-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-675-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle 8i Features"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. Native Dynamic SQL in Oracle8i"><LINK
REL="prev"
HREF="ch04_01.htm"
TITLE="4.1 DBMS_SQL Versus NDS"><LINK
REL="next"
HREF="ch04_03.htm"
TITLE="4.3 Multirow Queries with Cursor Variables"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_01.htm"
TITLE="4.1 DBMS_SQL Versus NDS"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.1 DBMS_SQL Versus NDS"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. Native Dynamic SQL in Oracle8i"
>Chapter 4<BR>Native Dynamic SQL in Oracle8i</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_03.htm"
TITLE="4.3 Multirow Queries with Cursor Variables"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.3 Multirow Queries with Cursor Variables"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch04-24870"
>4.2 NDS Statement Summary</A
></H2
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="ch-04-executeistat"
></A
>One of the nicest things about NDS is its simplicity. Unlike DBMS_SQL, which has dozens of programs and lots of rules to follow, NDS has been integrated into the PL/SQL language by adding one new statement, EXECUTE IMMEDIATE, and by enhancing the existing OPEN FOR statement:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>EXECUTE IMMEDIATE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Executes a specified SQL statement immediately</P
></DD
><DT
CLASS="term"
>OPEN FOR</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Allows you to perform multiple-row dynamic queries</P
></DD
></DL
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-SECT-2.1"
>4.2.1 The EXECUTE IMMEDIATE Statement</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-04-eis"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1549"
></A
>Use EXECUTE IMMEDIATE to execute (immediately!) the specified SQL statement. Here is the syntax of this statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXECUTE IMMEDIATE <I
CLASS="replaceable"
>SQL_string</I
>
   [INTO {<I
CLASS="replaceable"
>define_variable</I
>[, <I
CLASS="replaceable"
>define_variable</I
>]... | <I
CLASS="replaceable"
>record</I
>}]
   [USING [IN | OUT | IN OUT] <I
CLASS="replaceable"
>bind_argument</I
>
       [, [IN | OUT | IN OUT] <I
CLASS="replaceable"
>bind_argument</I
>]...];
</PRE
></BLOCKQUOTE
><DL
CLASS="variablelist"
><DT
CLASS="term"
>SQL_string </DT
><DD
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-1564"
></A
> A string expression containing the SQL statement or PL/SQL block</P
></DD
><DT
CLASS="term"
>define_variable</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1570"
></A
>A variable that receives a column value returned by a query</P
></DD
><DT
CLASS="term"
>record </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1576"
></A
>A record based on a user-defined TYPE or %ROWTYPE that receives an entire row returned by a query</P
></DD
><DT
CLASS="term"
>bind_argument </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1582"
></A
>An expression whose value is passed to the SQL statement or PL/SQL block </P
></DD
><DT
CLASS="term"
>INTO clause</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Use for single-row queries; for each column value returned by the query, you must supply an individual variable or field in a record of compatible type. </P
></DD
><DT
CLASS="term"
>USING clause</DT
><DD
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-1592"
></A
> Allows you to supply bind arguments for the SQL string. This clause is used for both dynamic SQL and PL/SQL, which is why you can specify a parameter mode. This usage is only relevant for PL/SQL, however; the default is IN, which is the only kind of bind argument you would have for SQL statements.</P
></DD
></DL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1595"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1597"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1599"
></A
>You can use EXECUTE IMMEDIATE for any SQL statement or PL/SQL block, except for multiple-row queries. If <EM
CLASS="emphasis"
>SQL_string</EM
> ends with a semicolon, it will be treated as a PL/SQL block; otherwise, it will be treated as either DML (Data Manipulation Language&nbsp;-- SELECT, INSERT, UPDATE, or DELETE) or DDL (Data Definition Language, such as CREATE TABLE). The string may contain placeholders for bind arguments, but you cannot use bind values to pass in the names of schema objects, such as table names or column names. </P
><P
CLASS="para"
>When the statement is executed, the runtime engine replaces each placeholder (an identifier with a colon in front of it, such as :salary_value) in the SQL string with its corresponding bind argument (by position). You can pass numeric, date, and string expressions. You cannot, however, pass a Boolean, because it is a PL/SQL datatype. Nor can you pass a NULL literal value. Instead, you must pass a variable of the correct type that has a value of NULL.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1604"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1606"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1608"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1610"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1612"
></A
>NDS supports all SQL datatypes available in Oracle8<EM
CLASS="emphasis"
>i</EM
>. So, for example, define variables and bind arguments can be collections, large objects (LOBs), instances of an object type, and REFs. On the other hand, NDS does not support datatypes that are specific to PL/SQL, such as Booleans, index-by tables, and user-defined record types. The INTO clause may, however, contain a PL/SQL record. </P
><P
CLASS="para"
>Let's take a look at a few examples: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Create an index:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXECUTE IMMEDIATE 'CREATE INDEX emp_u_1 ON employee (last_name)';</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It can't get much easier than that, can it?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Create a stored procedure that will execute any DDL statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE execDDL (ddl_string IN VARCHAR2)
IS
BEGIN
   EXECUTE IMMEDIATE ddl_string;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With execDDL in place, I can create that same index as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>execDDL ('CREATE INDEX emp_u_1 ON employee (last_name)');</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Obtain the count of rows in any table, in any schema, for the specified WHERE clause:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: tabcount.sf */
CREATE OR REPLACE FUNCTION tabCount (
   tab IN VARCHAR2,
   whr IN VARCHAR2 := NULL,
   sch IN VARCHAR2 := NULL)
   RETURN INTEGER
IS
   retval INTEGER;
BEGIN
   EXECUTE IMMEDIATE
      'SELECT COUNT(*) 
         FROM ' || NVL (sch, USER) || '.' || tab ||
      ' WHERE ' || NVL (whr, '1=1')
      INTO retval;
   RETURN retval;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So now I never again have to write SELECT COUNT(*), whether in SQL*Plus or within a PL/SQL program, as in the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   IF tabCount ('emp', 'deptno = ' || v_dept) &gt; 100
   THEN
      DBMS_OUTPUT.PUT_LINE ('Growing fast!');
   END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Here's a function that lets you update the value of any numeric column in any table. It's a function because it returns the number of rows that have been updated.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: updnval.sf */
CREATE OR REPLACE FUNCTION updNVal (
   tab IN VARCHAR2,
   col IN VARCHAR2,
   val IN NUMBER,
   whr IN VARCHAR2 := NULL,
   sch IN VARCHAR2 := NULL)
   RETURN INTEGER
IS
BEGIN
   EXECUTE IMMEDIATE
      'UPDATE ' || NVL (sch, USER) || '.' || tab ||
      '   SET ' || col || ' = :the_value 
        WHERE ' || NVL (whr, '1=1')
     USING val;
   RETURN SQL%ROWCOUNT;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Where I come from, that is a very small amount of code to achieve all of that flexibility! This example introduces the bind argument: after the UPDATE statement is parsed, the PL/SQL engine replaces the :the_value placeholder with the value in the val variable. Notice also that I am able to rely on the SQL%ROWCOUNT cursor attribute that I have already been using for static DML statements. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Suppose that I need to run a different stored procedure at 9 a.m. each day of the week. Each program's name has this structure: DAYNAME_set_schedule. Each procedure has the same four arguments: you pass in employee_id and hour for the first meeting of the day; it returns the name of the employee and the number of appointments for the day. I can use dynamic PL/SQL to handle this situation:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: run9am.sp */
CREATE OR REPLACE PROCEDURE run_9am_procedure (
   id_in IN employee.employee_id%TYPE,
   hour_in IN INTEGER)
IS
   v_apptCount INTEGER;
   v_name VARCHAR2(100);
BEGIN
   EXECUTE IMMEDIATE
      'BEGIN ' || TO_CHAR (SYSDATE, 'DAY') || 
         '_set_schedule (:id, :hour, :name, :appts); END;'
     USING IN 
        id_in, IN hour_in, OUT v_name, OUT v_apptCount;

   DBMS_OUTPUT.PUT_LINE (
      'Employee ' || v_name || ' has ' || v_apptCount ||
      ' appointments on ' || TO_CHAR (SYSDATE));
END;
/</PRE
></BLOCKQUOTE
></LI
></OL
><P
CLASS="para"
>This is a very easy and accessible syntax!<A
CLASS="indexterm"
NAME="AUTOID-1640"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1641"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch04-18443"
>4.2.2 The OPEN FOR Statement</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-04-openforst"
></A
><A
CLASS="indexterm"
NAME="ch-04-openfstwo"
></A
>The OPEN FOR statement is not brand-new to PL/SQL in Oracle8<EM
CLASS="emphasis"
>i</EM
>; it was first offered in Oracle7 to support cursor variables. Now it is deployed in an especially elegant fashion to implement multiple-row dynamic queries. With DBMS_SQL, you go through a particularly painful series of steps to implement multirow queries: parse, bind, define each column individually, execute, fetch, extract each column value individually. My gosh, what a lot of code to write!</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1652"
></A
>For native dynamic SQL, Oracle took an existing feature and syntax&nbsp;-- that of cursor variables&nbsp;-- and extended it in a very natural way to support dynamic SQL. The next section explores multirow queries in detail; let's take a look now specifically at the syntax of the OPEN FOR statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OPEN {<I
CLASS="replaceable"
>cursor_variable</I
> | :<I
CLASS="replaceable"
>host_cursor_variable</I
>} FOR <I
CLASS="replaceable"
>SQL_string</I
>
   [USING <I
CLASS="replaceable"
>bind_argument</I
>[, <I
CLASS="replaceable"
>bind_argument</I
>]...];
</PRE
></BLOCKQUOTE
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>cursor_variable</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A weakly typed cursor variable</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>:host_cursor_variable</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1671"
></A
>A cursor variable declared in a PL/SQL host environment such as an Oracle Call Interface (OCI) program </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>SQL_string</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-1678"
></A
> Contains the SELECT statement to be executed dynamically</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>USING clause</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-1685"
></A
> Follows the same rules as it does in the EXECUTE IMMEDIATE statement</P
></DD
></DL
><P
CLASS="para"
>Many PL/SQL developers are not very familiar with cursor variables, so a quick review is in order (for lots more details, check out <CITE
CLASS="citetitle"
>Chapter 6</CITE
> of <CITE
CLASS="citetitle"
>Oracle PL/SQL Programming, 2nd Edition</CITE
>.</P
><P
CLASS="para"
>A <EM
CLASS="emphasis"
>cursor variable</EM
> is a variable of type REF CURSOR, or referenced cursor. Here is an example of a declaration of a cursor variable based on a "weak" REF CURSOR (the sort you will use for NDS):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   TYPE cv_type IS REF CURSOR;
   cv cv_type;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A cursor variable <EM
CLASS="emphasis"
>points to</EM
> a cursor object; it is, however, a variable. You can have more than one variable pointing to the same cursor object, you can assign one cursor variable to another, and so on. Once you have declared a cursor variable, you can assign a value to it by referencing it in an OPEN FOR statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   TYPE cv_type IS REF CURSOR;
   cv cv_type;
BEGIN
   OPEN cv FOR SELECT COUNT(guns) FROM charlton_heston_home;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this example, the query is static&nbsp;-- it is not contained in single quotes, and it is frozen at compilation time. That is the only way we have been able to work with cursor variables until Oracle8<EM
CLASS="emphasis"
>i</EM
>. Now we can use the same syntax as before, but the query can be a literal or an expression, as in the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OPEN dyncur FOR SQL_string;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or, to show the use of a bind argument:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OPEN dyncur FOR 
   'SELECT none_of_the_above FROM senate_candidates
     WHERE state = :your_state_here'
   USING state_in;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Once you have opened the query with the OPEN FOR statement, the syntax used to fetch rows, close the cursor variable and check the attributes of the cursor are all the same as for static cursor variables&nbsp;-- and hardcoded explicit cursors, for that matter. The next section demonstrates all of this syntax through examples.</P
><P
CLASS="para"
>To summarize, there are two differences between the OPEN FOR statement for static and dynamic SQL:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The static version does not support the USING clause of NDS.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The static version requires a static SQL statement after the FOR keyword, whereas with NDS, the SQL string is always either a literal string or an expression that evaluates to a string.<A
CLASS="indexterm"
NAME="AUTOID-1708"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1709"
></A
></P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_01.htm"
TITLE="4.1 DBMS_SQL Versus NDS"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.1 DBMS_SQL Versus NDS"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming Guide to Oracle 8i Features"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch04_03.htm"
TITLE="4.3 Multirow Queries with Cursor Variables"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.3 Multirow Queries with Cursor Variables"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.1 DBMS_SQL Versus NDS</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.3 Multirow Queries with Cursor Variables</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
