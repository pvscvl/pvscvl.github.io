<HTML
><HEAD
><TITLE
>[Chapter 10] More Goodies for Oracle8i PL/SQL Developers</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T19:27:42Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CDROM-1-56592-675-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-675-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle 8i Features"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming Guide to Oracle 8i Features"><LINK
REL="prev"
HREF="ch09_09.htm#ch09-SECT-9.1.1"
TITLE="9.9 Examples"><LINK
REL="next"
HREF="ch10_02.htm#ch10-SECT-2.2.1"
TITLE="10.2 Calling Packaged Functions in SQL"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_09.htm#ch09-SECT-9.1.1"
TITLE="9.9 Examples"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.9 Examples"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 10</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.2.1"
TITLE="10.2 Calling Packaged Functions in SQL"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.2 Calling Packaged Functions in SQL"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch10-75374"
>10. More Goodies for Oracle8i PL/SQL Developers</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch10-28218"
TITLE="10.1 The NOCOPY Parameter Mode Hint"
>The NOCOPY Parameter Mode Hint</A
><BR><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.2.1"
TITLE="10.2 Calling Packaged Functions in SQL"
>Calling Packaged Functions in SQL</A
><BR><A
CLASS="sect1"
HREF="ch10_03.htm#ch10-SECT-3.2"
TITLE="10.3 SQL99 Compliance"
>SQL99 Compliance</A
><BR><A
CLASS="sect1"
HREF="ch10_04.htm"
TITLE="10.4 SQL Operations on Collections"
>SQL Operations on Collections</A
><BR><A
CLASS="sect1"
HREF="ch10_05.htm#ch10-SECT-5.2"
TITLE="10.5 Miscellaneous and Minor Improvements"
>Miscellaneous and Minor Improvements</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-10-ovten"
></A
>I've already covered a veritable cornucopia of new features available for PL/SQL developers in Oracle8<EM
CLASS="emphasis"
>i</EM
>. Even if that were all that Oracle8<EM
CLASS="emphasis"
>i</EM
> offered to developers, we would all be very happy&nbsp;-- and very busy learning how to use all the new stuff. Yet there is still more! This chapter covers other features that improve either the performance or the usability of PL/SQL in Oracle8<EM
CLASS="emphasis"
>i</EM
>:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>The NOCOPY compiler hint</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>You can avoid the overhead of copying IN OUT parameter values with this enhancement. When you are working with large collections and records, NOCOPY can have a noticeable impact on program performance.</P
></DD
><DT
CLASS="term"
>Calling PL/SQL functions from SQL</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Oracle8<EM
CLASS="emphasis"
>i </EM
>offers some big relief for PL/SQL developers when it comes to calling their own functions: you no longer have to use the RESTRICT_REFERENCES pragma! Oracle8<EM
CLASS="emphasis"
>i</EM
> also offers two new keywords, DETERMINISTIC and PARALLEL ENABLE, to help you integrate your PL/SQL, C, and Java code into all aspects of your database.</P
></DD
><DT
CLASS="term"
>SQL99 compliance</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Oracle8<EM
CLASS="emphasis"
>i</EM
> adds or expands the TRIM and CAST operators to better support the SQL99 standard.</P
></DD
><DT
CLASS="term"
>SQL operations on collections</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Oracle8<EM
CLASS="emphasis"
>i</EM
> makes it even easier to integrate PL/SQL (transient) collections into SQL statements.</P
></DD
></DL
><P
CLASS="para"
>I also review transparent improvements, that is, changes to the language that improve the performance or behavior of your PL/SQL-based applications without necessitating any modifications to your code.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch10-28218"
>10.1 The NOCOPY Parameter Mode Hint</A
></H2
><P
CLASS="para"
>PL/SQL 8.1 offers a new option for definitions of parameters: the NOCOPY clause. NOCOPY is a <EM
CLASS="emphasis"
>hint</EM
> to the compiler about how you would like the PL/SQL engine to work with the data structure being passed in as an OUT or IN OUT parameter. To understand NOCOPY and its potential impact, it will help to review how PL/SQL handles parameters. Let's start with some definitions: </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Formal parameter </EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The parameter defined in the parameter list and used in the program. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Actual parameter</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The actual expression or variable passed to the program when it is called. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>By reference</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>When an actual parameter is passed <EM
CLASS="emphasis"
>by reference</EM
>, it means that a pointer to the actual parameter is passed to the corresponding formal parameter. Both the actual and formal parameters then reference, or point to, the same location in memory that holds the value of the parameter.</P
></DD
><DT
CLASS="term"
><I
CLASS="filename"
>By value</I
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>When an actual parameter is passed <EM
CLASS="emphasis"
>by value</EM
>, the value of the actual parameter is copied into the corresponding formal parameter. If the program then terminates without an exception, the formal parameter value is copied back to the actual parameter. If an error occurs, the changed values are <EM
CLASS="emphasis"
>not</EM
> copied back to the actual parameter.</P
></DD
></DL
><P
CLASS="para"
>Parameter passing in PL/SQL (without the use of NOCOPY) follows the rules shown in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><B
CLASS="emphasis.bold"
>Parameter Mode</B
></P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Passed by Value or Reference? (Default Behavior)</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>IN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>By reference</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>OUT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>By value</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>IN OUT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>By value</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>We can infer from all of these definitions and rules that when you pass a large data structure (such as a collection, record, or instance of an object type) as an OUT or IN OUT parameter, your application could experience performance and memory degradation due to all of this copying.</P
><P
CLASS="para"
>PL/SQL 8.1 offers the NOCOPY hint as a way for you to attempt to avoid this copying. The syntax of this feature is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
><I
CLASS="replaceable"
>parameter_name</I
> [ IN | IN OUT | OUT | IN OUT NOCOPY | OUT NOCOPY ] <I
CLASS="replaceable"
>parameter_datatype</I
></PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can specify NOCOPY only in conjunction with the OUT or IN OUT mode. Here, for example, is a parameter list that uses the NOCOPY hint for both of its IN OUT arguments:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE analyze_results (
   date_in IN DATE,
   values IN OUT NOCOPY numbers_varray,
   validity_flags IN OUT <CODE
CLASS="userinput"
><B
>NOCOPY</B
></CODE
> validity_rectype
   );</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Remember that NOCOPY is a hint, not a command. This means that the compiler might silently decide that it cannot fulfill your request for a NOCOPY parameter treatment. The next section lists the restrictions on NOCOPY that might cause this to happen.<A
CLASS="indexterm"
NAME="AUTOID-7013"
></A
></P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.1"
>10.1.1 Restrictions on NOCOPY</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7017"
></A
>A number of situations will cause the PL/SQL compiler to ignore the NOCOPY hint and instead use the default by-value method to pass the OUT or IN OUT parameter. These situations are the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The actual parameter is an element of an index-by table (which could be an entire record structure). You can request NOCOPY for an entire index-by table, but not for an individual element in the table. A suggested workaround is to copy the structure to a standalone variable, either scalar or record, and then pass <EM
CLASS="emphasis"
>that</EM
> as the NOCOPY parameter. That way, at least you aren't copying the entire structure.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Certain constraints applied to actual parameters will result in the NOCOPY hint being ignored. These constraints include a scale specification for a numeric variable and the NOT NULL constraint. You can, however, pass a string variable that has been constrained by size. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Both the actual and formal parameters are record structures. One or both records were declared using %ROWTYPE or %TYPE, and the constraints on corresponding fields in these two records are different. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The actual and formal parameters are record structures. The actual parameter was declared by the PL/SQL engine as the index of a cursor FOR loop, and the constraints on corresponding fields in the records are different. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>In passing the actual parameter, the PL/SQL engine must perform an implicit datatype conversion. A suggested workaround is this: you are always better off performing explicit conversions, so do that and then pass the converted value as the NOCOPY parameter.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The subprogram requesting the NOCOPY hint is used in an external or remote procedure call. In these cases, PL/SQL will always pass the actual parameter by value. </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.2"
>10.1.2 Impact of NOCOPY Use</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-10-impact"
></A
>Depending on your application, NOCOPY can improve the performance of programs with IN OUT or OUT parameters. As you might expect, these potential gains are only available with a trade-off: if a program terminates with an unhandled exception, you cannot trust the values in a NOCOPY actual parameter. </P
><P
CLASS="para"
>What do I mean by trust? Let's review how PL/SQL behaves concerning its parameters when an unhandled exception terminates a program. Suppose that I pass an IN OUT record to my calculate_totals procedure. The PL/SQL runtime engine first makes a copy of that record and then, during program execution, makes any changes to that <EM
CLASS="emphasis"
>copy</EM
>. The actual parameter itself is not modified until calculate_totals ends successfully (without propagating back an exception). At that point, the local copy is copied back to the actual parameter, and the program that called calculate_totals can access that changed data. If calculate_totals terminates with an unhandled exception, however, the calling program can be certain that the actual parameter's value has not been changed.</P
><P
CLASS="para"
>That certainty disappears with the NOCOPY hint. When a parameter is passed by reference (the effect of NOCOPY), any changes made to the formal parameter are also made immediately to the actual parameter. Suppose that my calculate_totals program reads through a 10,000-row collection and makes changes to each row. If an error is raised at row 5000, and that error is propagated out of calculate_totals unhandled, my actual parameter collection will be only half-changed. How will I know what is good data and what is bad? </P
><P
CLASS="para"
>The following test script (available in <I
CLASS="filename"
>nocopy.tst</I
> on the companion disk) demonstrates this problem. I create two versions of the same program, each of which moves through a five-row collection, doubling the value of each row. When they hit row 3, however, I raise a VALUE_ERROR exception. I then examine the contents of the collection before and after each program call. </P
><P
CLASS="para"
>Here are the programs:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: nocopy.tst */
CREATE OR REPLACE PACKAGE BODY nocopy_test
IS
   PROCEDURE pass_by_value (nums IN OUT number_varray)
   IS
   BEGIN
      FOR indx IN nums.FIRST .. nums.LAST
      LOOP
         nums(indx) := nums(indx) * 2;
         IF indx &gt; 2 THEN RAISE VALUE_ERROR; END IF;
      END LOOP;
   END;
      
   PROCEDURE pass_by_ref (nums IN OUT NOCOPY number_varray)
   IS
   BEGIN
      FOR indx IN nums.FIRST .. nums.LAST
      LOOP
         nums(indx) := nums(indx) * 2;
         IF indx &gt; 2 THEN RAISE VALUE_ERROR; END IF;
      END LOOP;
   END;
   
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here is the block that exercises these two programs:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   nums1 number_varray := number_varray (1, 2, 3, 4, 5);
   nums2 number_varray := number_varray (1, 2, 3, 4, 5);
   
   PROCEDURE shownums (
      str IN VARCHAR2, nums IN number_varray) IS
   BEGIN
      DBMS_OUTPUT.PUT_LINE (str);
      FOR indx IN nums.FIRST .. nums.LAST
      LOOP
         DBMS_OUTPUT.PUT (nums(indx) || '-');
      END LOOP;
      DBMS_OUTPUT.NEW_LINE;
   END;
BEGIN
   
   shownums ('Before By Value', nums1);
   BEGIN
      nocopy_test.pass_by_value (nums1);
   EXCEPTION
      WHEN OTHERS THEN shownums ('After By Value', nums1);
   END;

   shownums ('Before NOCOPY', nums2);
   BEGIN
      nocopy_test.pass_by_ref (nums2);
   EXCEPTION
      WHEN OTHERS THEN shownums ('After NOCOPY', nums2);
   END;

END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>And here are the results:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Before By Value
1-2-3-4-5-
After By Value
1-2-3-4-5-
Before NOCOPY
1-2-3-4-5-
After NOCOPY
2-4-6-4-5-</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see from the last set of output numbers, the first three rows of the nums2 variable array have been modified, even though the pass_by_ref procedure did not finish its job. </P
><P
CLASS="para"
>One concern about this trade-off is that the behavior of your application can change even when you don't actually change any of your code. Suppose that you are running in a distributed database environment, and you rely on remote procedure calls (RPCs). In the current implementation of PL/SQL, the NOCOPY hint is always ignored for RPCs. For the last six months, your application has been calling a program that happened to reside on the same database instance as your application. Then a DBA reconfigured databases and the distribution of code, and now your application is calling a remote procedure&nbsp;-- which may cause your application to behave differently, at least when an exception occurs. </P
><P
CLASS="para"
>On the other hand, you are not likely to encounter this scenario or others that might cause a change in behavior: for example, parameter aliasing (discussed in the next section) or reliance on the values of parameters after a program call fails with an unhandled exception. Standard, reasonable coding practices should keep you away from such problems.<A
CLASS="indexterm"
NAME="AUTOID-7054"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.3"
>10.1.3 Parameter Aliasing</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-10-paralias"
></A
>Potential corruption of your data structures is not the only complication with NOCOPY. This hint also increases the possibility that you will encounter programs with a situation known as <I
CLASS="firstterm"
>parameter aliasing</I
>, where two different identifiers in your program refer to the same memory location (two <I
CLASS="firstterm"
>aliases</I
> for the same data), and the behavior of your code does not match your expectations. </P
><BLOCKQUOTE
CLASS="tip"
><P
CLASS="para"
><STRONG
>TIP:</STRONG
> Parameter aliasing as a potential issue predates the introduction of the NOCOPY feature. Programs should not rely on aliasing behavior, and you should examine your code carefully to ferret out such dependencies.</P
></BLOCKQUOTE
><P
CLASS="para"
>Here is an example of parameter aliasing and the trouble it can cause (see <I
CLASS="filename"
>parmalias.sql</I
> for the contiguous code). First, I declare a record type containing information about a prisoner (name and number of years incarcerated). Then I declare a variable type array of those records:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: parmalias.sql */
DECLARE
   TYPE prisoner IS RECORD (
      name VARCHAR2(100),
      years_incarcerated NUMBER);
      
   TYPE prisoner_list IS VARRAY(2000) OF prisoner;
   innocents_on_deathrow prisoner_list := prisoner_list();</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since the death penalty was reinstated in the state of Illinois in 1977, 10 men have been executed (as of May 1999). Eleven men have been found to be innocent of the crimes for which they were to be killed and have been released, but often after spending many years on Death Row (Anthony Porter was there for 18 years!). Now that is what I call a travesty of justice. So here's a procedure&nbsp;-- defined within the same PL/SQL block or scope&nbsp;-- to add a travesty to the list:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE add_travesty (
   illinois_inhumanity IN OUT NOCOPY prisoner_list) 
IS
BEGIN
   illinois_inhumanity(1).name := 'Rolando Cruz';
   illinois_inhumanity(1).years_incarcerated := 10;
     
   innocents_on_deathrow(1).name := 'Anthony Porter';
   innocents_on_deathrow(1).years_incarcerated := 17.75;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This program populates the first rows of what seem to be two different variable arrays: illinois_inhumanity and innocents_on_deathrow. Nothing wrong with that, right? Well, let's see how we are going to use this program: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   innocents_on_deathrow.EXTEND;
   add_travesty (innocents_on_deathrow);
   DBMS_OUTPUT.PUT_LINE (innocents_on_deathrow(1).name);  
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I extend the global innocents_on_deathrow array and then call add_travesty, passing in that variable array. Then I display the name of the person in the first row.</P
><P
CLASS="para"
>You will see in <I
CLASS="filename"
>parmalias.sql</I
> that I have two different versions of this block: one that uses NOCOPY for the parameter in add_travesty, and another that relies on the default parameter passing mechanism (by value). When I run these two blocks, I see this result on my screen:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>With NOCOPY: Anthony Porter
Without NOCOPY: Rolando Cruz</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Why do I get these different results? We'll first analyze the action with the NOCOPY option (see <A
CLASS="xref"
HREF="ch10_01.htm"
>Figure 10.1</A
>):</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>When I call add_travesty, I pass innocents_on_deathrow as the IN OUT prisoner list. Since it is passed using NOCOPY, any changes made to the array take place immediately. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I set the first row of illinois_inhumanity with information about Rolando Cruz.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Then I set the first row of innocents_on_deathrow with the information about Anthony Porter. Since I have used NOCOPY, the two arrays are the same, and so illinois_inhumanity is modified as well.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When the program ends, no copying takes place and so I see "Anthony Porter" when I display the contents of the innocents_on_deathrow array.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch10-50307"
>Figure 10.1: Parameter aliasing with NOCOPY</A
></H4
><IMG
CLASS="graphic"
SRC="figs/o8if.1001.gif"
ALT="Figure 10.1"></LI
></OL
><P
CLASS="para"
>Now let's step through the default processing (no use of NOCOPY):</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>When I call add_travesty, I pass innocents_on_deathrow by value. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I set the first row of my formal parameter (a local copy of innocents_on_deathrow) with information about Rolando Cruz.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Then I set the first row of my global collection (innocents_on_deathrow itself) with the information about Anthony Porter. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When the program ends, any changes made to the formal parameter are copied to the actual parameter, innocents_on_deathrow. This action <EM
CLASS="emphasis"
>overwrites</EM
> the Anthony Porter information. Consequently, after the program is run, I see "Rolando Cruz" when I display the contents of the innocents_on_deathrow array.</P
></LI
></OL
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch10_01.htm"
>Figure 10.2</A
> illustrates the sequence of events without the use of NOCOPY.  </P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch10-46988"
>Figure 10.2: Parameter aliasing without NOCOPY</A
></H4
><IMG
CLASS="graphic"
SRC="figs/o8if.1002.gif"
ALT="Figure 10.2"><P
CLASS="para"
>You can see that the results of my program depend on the method of parameter passing chosen by the compiler. The compiler might change its mind, when and if circumstances change and a recompile is required. This introduces a level of uncertainty in your application. How can you avoid this problem? </P
><P
CLASS="para"
>You should be very careful in your use of both the NOCOPY hint and global variables. You are almost always better off passing global data structures through a parameter list rather than referencing them directly within a program unit. When this is not practical, set clear rules about how and when your globals can be used.<A
CLASS="indexterm"
NAME="AUTOID-7108"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.4"
>10.1.4 Performance Gains with NOCOPY</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch-10-pgain"
></A
>How much faster might your application run if you use the NOCOPY hint? It will certainly depend very much on your data structures: the number of rows in your collections, the size of your records, and so on. </P
><P
CLASS="para"
>I put together a test comparing the management of an index-by table of records with NOCOPY and the default by-value passing method. Here is the procedure, combining both versions within the [ ] brackets to save some space (see <I
CLASS="filename"
>nocopy3.tst</I
> for the full script):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Filename on companion disk: nocopy3.tst */
PROCEDURE pass_by_[value | ref ] (
   emps IN OUT [NOCOPY] emp_tabtype,
   raise_err IN BOOLEAN := FALSE)
IS
BEGIN
   FOR indx IN emps.FIRST .. emps.LAST
   LOOP
      emps(indx).last_name := RTRIM (emps(indx).last_name || ' ');
      emps(indx).salary := emps(indx).salary + 1;
   END LOOP;
   IF raise_err THEN RAISE VALUE_ERROR; END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that I have set the procedure up to run so that I can allow it to end successfully or terminate with an unhandled exception. I ran these programs in a variety of ways, one of which is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVtmr.capture;
BEGIN
   FOR indx IN 1 .. num
   LOOP
      pass_by_[value | ref ] (emptab, TRUE);
   END LOOP;
EXCEPTION
   WHEN OTHERS THEN 
      PLVtmr.show_elapsed ('By value raising error ' || num);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are the results of executing the script 10 and then 100 times (with correspondingly larger volumes of data in the index-by table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>By value no error 10 Elapsed: .65 seconds.
NOCOPY no error 10 Elapsed: .06 seconds.

By value raising error 10 Elapsed: .03 seconds.
NOCOPY raising error 10 Elapsed: .01 seconds.

By value no error 100 Elapsed: 317.78 seconds.
NOCOPY no error 100 Elapsed: 6.67 seconds.

By value raising error 100 Elapsed: 1.57 seconds.
NOCOPY raising error 100 Elapsed: .07 seconds.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, there is a significant improvement in performance with NOCOPY, especially for the largest-scale test. I have run other tests, with less dramatic gains (see <I
CLASS="filename"
>nocopy2.tst</I
>); you can easily modify my test scripts to test your own code to verify the impact of NOCOPY in your application.<A
CLASS="indexterm"
NAME="AUTOID-7124"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_09.htm#ch09-SECT-9.1.1"
TITLE="9.9 Examples"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.9 Examples"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Programming Guide to Oracle 8i Features"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Programming Guide to Oracle 8i Features"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.2.1"
TITLE="10.2 Calling Packaged Functions in SQL"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.2 Calling Packaged Functions in SQL"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>9.9 Examples</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10.2 Calling Packaged Functions in SQL</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
