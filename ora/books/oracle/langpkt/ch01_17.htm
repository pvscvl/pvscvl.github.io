<HTML
><HEAD
><TITLE
>[Chapter 1] 1.17 Collections </TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Bill Pribyl &amp; Chip Dawes"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:32:50Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-457-6E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-457-6E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL Reference"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Language Pocket Reference"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Oracle PL/SQL Language Pocket Reference"><LINK
REL="prev"
HREF="ch01_16.htm"
TITLE="1.16 Oracle8 Objects"><LINK
REL="next"
HREF="ch01_18.htm"
TITLE="1.18 External Procedures "></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Language Pocket Reference"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Language Pocket Reference"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_16.htm"
TITLE="1.16 Oracle8 Objects"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.16 Oracle8 Objects"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Oracle PL/SQL Language Pocket Reference"
>Chapter 1<BR>Oracle PL/SQL Language Pocket Reference</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_18.htm"
TITLE="1.18 External Procedures "
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.18 External Procedures "
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="plsql-toc443895418"
>1.17 Collections </A
></H2
><P
CLASS="para"
>There are three types of collections: index-by tables (formerly known as PL/SQL tables), nested tables, and VARRAYs. </P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Index-by table </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Single-dimension, unbounded collections of homogeneous elements available only in PL/SQL, not in the database. Index-by tables are initially sparse; they have nonconsecutive subscripts.</P
></DD
><DT
CLASS="term"
>Nested table </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Single-dimension, unbounded collections of homogeneous elements available in both PL/SQL and the database as columns or tables. Nested tables are initially dense (they have consecutive subscripts), but can become sparse through deletions.</P
></DD
><DT
CLASS="term"
>VARRAYs </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Variable-size arrays are single-dimension, bounded collections of homogeneous elements available in both PL/SQL and the database. VARRAYs are never sparse. Unlike nested tables, their element order is preserved when you store and retrieve them from the database.</P
></DD
></DL
><P
CLASS="para"
>The following table compares these similar collection types.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Collection Type</P
></TH
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Characteristic</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Index-by Table</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Nested Table</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>VARRAY</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Dimensionality</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Single</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Single</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Single</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Usable in SQL?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Usable as a column datatype in a table?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes; data stored "out of line" (in a separate table)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes; data typically stored "in line" (in the same table)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Uninitialized state</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Empty (cannot be NULL); elements are undefined</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Atomically null; illegal to reference elements</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Atomically null; illegal to reference elements</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Initialization</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Automatic, when declared</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Via constructor, fetch, assignment</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Via constructor, fetch, assignment</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>In PL/SQL, elements referenced by</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>BINARY_INTEGER (-2,147,483,647</P
><P
CLASS="para"
>.. 2,147,483,647)</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Positive integer between 1 and 2,147483,647</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Positive integer between 1 and 2,147483,647</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Sparse?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Initially no; after deletions, yes</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Bounded?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Can be extended</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Can assign a value to any element at any time?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No; may need to EXTEND first</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No; may need to EXTEND first, and cannot EXTEND past the upper bound</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Means of extending</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Assign value to element with a new subscript</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Use built-in EXTEND procedure or TRIM to condense, with no predefined maximum</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>EXTEND or TRIM, but only up to declared maximum size.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Can be compared for equality?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Elements retain ordinal position and subscript when stored and retrieved from the database</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>N/A&nbsp;-- can't be stored in database</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>No</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Yes</P
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-SECT-17.1"
>1.17.1 Syntax for Declaring Collection Datatypes </A
></H3
><P
CLASS="para"
>Collections are implemented as TYPEs. Like any programmer-defined type, you must first define the type; then you can declare instances of that type. The TYPE definition can be stored in the database or declared in the PL/SQL program. Each instance of the TYPE is a collection. </P
><P
CLASS="para"
>The syntax for declaring an index-by table is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>TYPE type_name IS TABLE OF element_type [NOT NULL] INDEX BY BINARY_INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The syntax for a nested table is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>[CREATE [OR REPLACE]] TYPE type_name IS TABLE OF 
   element_type [NOT NULL];</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The syntax for a VARRAY is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>[CREATE [OR REPLACE]] TYPE type_name IS VARRAY | 
   VARYING ARRAY (max_elements) OF element_type 
   [NOT NULL];</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The CREATE keyword defines the statement to be DDL and indicates that this type will exist in the database. The optional OR REPLACE keywords are used to rebuild an existing type, preserving the privileges. <EM
CLASS="emphasis"
>type_name</EM
> is any valid identifier that will be used later to declare the collection. <EM
CLASS="emphasis"
>max_elements</EM
> is the maximum size of the VARRAY. <EM
CLASS="emphasis"
>element_type</EM
> is the type of the collection's elements. All elements are of a single type, which can be most scalar datatypes, an object type, or a REF object type. If the elements are objects, the object type itself cannot have an attribute that is a collection. Explicitly disallowed collection datatypes are BOOLEAN, NCHAR, NCLOB, NVARCHAR2, REF CURSOR, TABLE, and VARRAY.</P
><P
CLASS="para"
>NOT NULL indicates that a collection of this type cannot have any null elements. However, the collection can be atomically null (uninitialized). </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-toc443895421"
>1.17.2 Initializing Collections </A
></H3
><P
CLASS="para"
>Initializing an index-by table is trivial&nbsp;-- simply declaring it also initializes it. Initializing a nested table or VARRAY can be done explicitly, with a constructor, or implicitly with a fetch from the database or a direct assignment of another collection variable. </P
><P
CLASS="para"
>The constructor is a built-in function with the same name as the collection. It constructs the collection from the elements passed to it. We can create a nested table of colors and initialize it to three elements with a constructor:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   TYPE colors_tab_t IS TABLE OF VARCHAR2(30);

   colors_tab_t('RED','GREEN','BLUE');
BEGIN</PRE
></BLOCKQUOTE
><P
CLASS="para"
>We can create our nested table of colors and initialize it with a fetch from the database:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>-- Create the nested table to exist in the database.
CREATE TYPE colors_tab_t IS TABLE OF VARCHAR2(32);

-- Create table with nested table type as column.
CREATE TABLE color_models 
(model_type   VARCHAR2(12)
,colors       color_tab_t)
NESTED TABLE colors STORE AS 
   color_model_colors_tab;

-- Add some data to the table.
INSERT INTO color_models 
   VALUES('RGB',color_tab_t('RED','GREEN','BLUE'));
INSERT INTO color_models 
   VALUES('CYMK',color_tab_t('CYAN','YELLOW',
      'MAGENTA' 'BLACK'));

-- Initialize a collection of colors from the table.
DECLARE
   basic_colors colors_tab_t;
BEGIN
   SELECT colors INTO basic_colors
     FROM color_models
    WHERE model_type = 'RGB';
...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The third initialization technique is by assignment from an existing collection:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   basic_colors Color_tab_t := 
      Color_tab_t ('RED','GREEN','BLUE');

   my_colors Color_tab_t;
BEGIN
   my_colors := basic_colors;
   my_colors(2) := 'MUSTARD';</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-toc443895422"
>1.17.3 Adding and Removing Elements</A
></H3
><P
CLASS="para"
>Elements in an index-by table can be added simply by referencing new subscripts. To add elements to nested tables or VARRAYs, you must first enlarge the collection with the EXTEND function, and then you can assign a value to a new element using one of the methods described in the previous section. </P
><P
CLASS="para"
>Use the DELETE function to remove an element in a nested table regardless of its position. The TRIM function can also be used to remove elements, but only from the end of a collection. To avoid unexpected results, do not use both DELETE and TRIM on the same collection.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-toc443895423"
>1.17.4 Collection Pseudo-Functions </A
></H3
><P
CLASS="para"
>There are several psuedo-functions defined for collections. They include THE, CAST, MULTISET, and TABLE.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>THE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Maps a single column's value in a single row into a virtual database table. Syntactically, this is similar to an inline view, where a subquery is used in the FROM clause.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT VALUE(c)
   FROM THE(SELECT colors
              FROM color_models
             WHERE model_type = 'RGB') c;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The pseudo-function THE will work in Oracle8<EM
CLASS="emphasis"
>i</EM
> but its use is discouraged. Use the 8<EM
CLASS="emphasis"
>i</EM
>  TABLE( ) function instead.</P
></DD
><DT
CLASS="term"
>CAST</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Maps a collection of one type to a collection of another type.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT column_value
FROM THE(SELECT CAST(colors AS color_tab_t)
           FROM color_models_a
          WHERE model_type ='RGB');</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>MULTISET</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Maps a database table to a collection. With MULTISET and CAST, you can retrieve rows from a database table as a collection-typed column.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT b.genus ,b.species,
      CAST(MULTISET(SELECT bh.country
                      FROM bird_habitats bh
                     WHERE bh.genus = b.genus
                       AND bh.species = b.species)
          AS country_tab_t)
FROM birds b;</PRE
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>TABLE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Maps a collection to a database table; the inverse of MULTISET.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT *
  FROM color_models c
 WHERE 'RED' IN (SELECT * FROM TABLE(c.colors));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In Oracle8<EM
CLASS="emphasis"
>i</EM
> PL/SQL, you can use TABLE( ) to unnest a transient collection:</P
></DD
></DL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   birthdays Birthdate_t :=
      Birthdate_t('24-SEP-1984', '19-JUN-1993');
BEGIN
   FOR the_rec IN
      (SELECT COLUMN_VALUE
         FROM TABLE(CAST(birthdays AS Birthdate_t)))</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-toc443895428"
>1.17.5 Collection Methods </A
></H3
><P
CLASS="para"
>There are a number of built-in functions (methods) defined for all collections. These methods are called with dot notation:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>collection_name.method_name[(parameters)]</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The methods are described in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Collection Method </P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>COUNT function</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the current number of elements in the collection.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>DELETE [( i [,j ] )] procedure</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Removes element <EM
CLASS="emphasis"
>i</EM
> or elements <EM
CLASS="emphasis"
>i</EM
> through <EM
CLASS="emphasis"
>j</EM
> from a nested table or index-by table. When called with no parameters, removes all elements in the collection. Reduces the COUNT if the element is not already DELETEd. Does not apply to VARRAYs.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>EXISTS ( i ) function</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns TRUE or FALSE to indicate whether element <EM
CLASS="emphasis"
>i</EM
> exists. If the collection is an uninitialized nested table or VARRAY, returns FALSE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>EXTEND [( n [,i ] )] procedure</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Appends <EM
CLASS="emphasis"
>n</EM
> elements to a collection, initializing them to the value of element <EM
CLASS="emphasis"
>i</EM
>. <EM
CLASS="emphasis"
>n</EM
> is optional and defaults to 1.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>FIRST function</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the smallest index in use. Returns NULL when applied to empty initialized collections.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LAST function</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the largest index in use. Returns NULL when applied to empty initialized collections.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LIMIT function</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns the maximum number of allowed elements in a VARRAY. Returns NULL for index-by tables and nested tables.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>PRIOR ( i ) function</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return the index immediately before element <EM
CLASS="emphasis"
>i</EM
>. Returns NULL if <EM
CLASS="emphasis"
>i</EM
> is less than or equal to FIRST.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NEXT ( i ) function</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return the index immediately after element <EM
CLASS="emphasis"
>i</EM
>. Returns NULL if <EM
CLASS="emphasis"
>i</EM
> is greater than or equal to COUNT.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRIM [( n )] procedure</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Removes <EM
CLASS="emphasis"
>n</EM
> elements at the end of the collection with the largest index. <EM
CLASS="emphasis"
>n</EM
> is optional and defaults to 1. If <EM
CLASS="emphasis"
>n</EM
> is NULL, TRIM does nothing. Index-by tables cannot be TRIMmed.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The EXISTS function returns a BOOLEAN and all other functions return BINARY_INTEGER. All parameters are of the BINARY_INTEGER type. </P
><P
CLASS="para"
>Only EXISTS can be used on uninitialized nested tables or VARRAYs. Other methods applied to these atomically null collections will raise the COLLECTION_IS_NULL exception.</P
><P
CLASS="para"
>DELETE and TRIM both remove elements from a nested table, but TRIM also removes the placeholder, while DELETE does not. This behavior may be confusing, since TRIM can remove previously DELETED elements.</P
><P
CLASS="para"
>Here is an example of some collection methods in use:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   TYPE colors_tab_t IS TABLE OF VARCHAR2(30);
   my_list colors_tab_t := 
      colors_tab_t('RED','GREEN','BLUE');
   element BINARY_INTEGER;
BEGIN
   DBMS_OUTPUT.PUT_LINE('my_list has '
      ||my_list.COUNT||' elements');
   my_list.DELETE(2); -- delete element two
   DBMS_OUTPUT.PUT_LINE('my_list has '
      ||my_list.COUNT||' elements');

   FOR element IN my_list.FIRST..my_list.LAST
   LOOP
      IF my_list.EXISTS(element) 
      THEN
         DBMS_OUTPUT.PUT_LINE(my_list(element) 
            || ' Prior= '||my_list.PRIOR(element)
            || ' Next= ' ||my_list.NEXT(element));
      ELSE
         DBMS_OUTPUT.PUT_LINE('Element '|| element 
            ||' deleted. Prior= '||my_
               list.PRIOR(element)
            || ' Next= '||my_list.NEXT(element));
      END IF;
   END LOOP;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This example gives the output:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>my_list has 3 elements
my_list has 2 elements
RED Prior=  Next= 3
Element 2 deleted. Prior= 1 Next= 3
BLUE Prior= 1 Next=</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-toc443895429"
>1.17.6 Privileges</A
></H3
><P
CLASS="para"
>As with other TYPEs in the database, you need the EXECUTE privilege on that TYPE in order to use a collection type created by another schema (user account) in the database. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-toc443895430"
>1.17.7 Bulk Binds (Oracle8i)</A
></H3
><P
CLASS="para"
>Starting with Oracle8<EM
CLASS="emphasis"
>i</EM
>, you can use collections to improve the performance of SQL operations executed iteratively by using bulk binds. <EM
CLASS="emphasis"
>Bulk binds</EM
> reduce the number of round-trips that must be made between a client application and the database. Two PL/SQL language constructs implement bulk binds: FORALL and BULK COLLECT INTO. </P
><P
CLASS="para"
>The syntax for the FORALL statement is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FORALL bulk_index IN lower_bound..upper_bound 
   sql_statement; </PRE
></BLOCKQUOTE
><P
CLASS="para"
><EM
CLASS="emphasis"
>bulk_index</EM
> can be used only in the <EM
CLASS="emphasis"
>sql_statement</EM
> and only as a collection index (subscript). When PL/SQL processes this statement, the whole collection, instead of each individual collection element, is sent to the database server for processing. To delete all the accounts in the collection inactives from the table ledger, do this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FORALL i IN inactives.FIRST..inactives.LAST
   DELETE FROM ledger WHERE acct_no = inactives(i);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The syntax for the BULK COLLECT INTO clause is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BULK COLLECT INTO collection_name_list;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <EM
CLASS="emphasis"
>collection_name_list</EM
> is a comma-delimited list of collections, one for each column in the SELECT. As of Oracle8<EM
CLASS="emphasis"
>i</EM
>, collections of records cannot be a target of a BULK COLLECT INTO clause. However, 8<EM
CLASS="emphasis"
>i</EM
> does support retrieving a set of typed objects and "bulk collecting" them into a collection of objects. </P
><P
CLASS="para"
>The BULK COLLECT INTO clause can be used in SELECT INTO, FETCH INTO, or RETURNING INTO statements. For example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   TYPE vendor_name_tab IS TABLE OF 	
      vendors.name%TYPE;
   TYPE vendor_term_tab IS TABLE OF 
      vendors.terms%TYPE;
   v_names vendor_name_tab;
   v_terms vendor_term_tab;
BEGIN
   SELECT name, terms
     BULK COLLECT INTO v_names, v_terms
     FROM vendors
    WHERE terms &lt; 30;
   ...
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next function deletes employees in an input list of departments, and the (Oracle8) SQL RETURNING clause returns a list of deleted employees:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION whack_emps_by_dept (deptlist dlist_t)
RETURN enolist_t
IS
   enolist enolist_t;
BEGIN
   FORALL adept IN deptlist.FIRST..deptlist.LAST
      DELETE FROM emp WHERE deptno IN               
         deptlist(adept)
      RETURNING empno BULK COLLECT INTO enolist;
   RETURN Enolist;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can use the SQL%BULK_ROWCOUNT cursor attribute for bulk bind operations. It is like an index-by table containing the number of rows affected by the executions of the bulk bound statements. The <EM
CLASS="emphasis"
>n</EM
>th element of SQL%BULK_ROWCOUNT contains the number of rows affected by <EM
CLASS="emphasis"
>n</EM
>th execution of the SQL statement. For example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FORALL i IN inactives.FIRST..inactives.LAST
   DELETE FROM ledger WHERE acct_no = inactives(i);
FOR counter IN inactives.FIRST..inactives.LAST 
LOOP
   IF SQL%BULK_ROWCOUNT(counter) = 0
   THEN
      DBMS_OUTPUT.PUT_LINE('No rows deleted for '||
         counter);
   END IF;
END LOOP;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You cannot pass SQL%BULK_ROWCOUNT as a parameter to another program, or use an aggregate assignment to another collection. %ROWCOUNT contains a summation of all %BULK_ROWCOUNT elements. %FOUND and %NOTFOUND reflect only the last execution of the SQL statement.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_16.htm"
TITLE="1.16 Oracle8 Objects"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.16 Oracle8 Objects"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Language Pocket Reference"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Language Pocket Reference"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_18.htm"
TITLE="1.18 External Procedures "
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.18 External Procedures "
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.16 Oracle8 Objects</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
>&nbsp;</TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.18 External Procedures </TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
