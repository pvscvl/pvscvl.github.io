<HTML
><HEAD
><TITLE
>[Chapter 1] 1.12 Named Program Units</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein, Bill Pribyl &amp; Chip Dawes"><META
NAME="DC.Date"
CONTENT="2000-04-29T17:32:12Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates CD-ROM-1-56592-457-6E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-457-6E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="Oracle PL/SQL Reference"><META
NAME="DC.Title"
CONTENT="Oracle PL/SQL Language Pocket Reference"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Oracle PL/SQL Language Pocket Reference"><LINK
REL="prev"
HREF="ch01_11.htm"
TITLE="1.11 Records in PL/SQL"><LINK
REL="next"
HREF="ch01_13.htm"
TITLE="1.13 Triggers"></HEAD
><BODY
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Oracle PL/SQL Language Pocket Reference"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Oracle PL/SQL Language Pocket Reference"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_11.htm"
TITLE="1.11 Records in PL/SQL"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.11 Records in PL/SQL"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Oracle PL/SQL Language Pocket Reference"
>Chapter 1<BR>Oracle PL/SQL Language Pocket Reference</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_13.htm"
TITLE="1.13 Triggers"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.13 Triggers"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="plsql-toc443895377"
>1.12 Named Program Units</A
></H2
><P
CLASS="para"
>The PL/SQL programming language allows you to create a variety of named program units (containers for code). They include:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Procedure</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A program that executes one or more statements</P
></DD
><DT
CLASS="term"
>Function</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A program that returns a value</P
></DD
><DT
CLASS="term"
>Package</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A container for procedures, functions, and data structures</P
></DD
><DT
CLASS="term"
>Triggers</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Programs that execute in response to database changes</P
></DD
><DT
CLASS="term"
>Object type</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Oracle8's version of a SQL3 named row type; object types can contain member procedures and functions</P
></DD
></DL
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-SECT-12.1"
>1.12.1 Procedures</A
></H3
><P
CLASS="para"
>Procedures are program units that execute one or more statements and can receive or return zero or more values through their parameter lists. The syntax of a procedure is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE [OR REPLACE] PROCEDURE name 
   [ (parameter [,parameter]) ]
   [AUTHID  CURRENT_USER | DEFINER ] -- Oracle8i
   [DETERMINISTIC]                   -- Oracle8i
IS | AS
   declaration_section
BEGIN
   executable_section
[EXCEPTION
   exception_section]
END [name];</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A procedure is called as a standalone executable PL/SQL statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>apply_discount(new_company_id, 0.15) --15% discount</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-toc443895379"
>1.12.2 Functions</A
></H3
><P
CLASS="para"
>Functions are program units that execute one or more statements and return a value through the RETURN clause. Functions can also receive or return zero or more values through their parameter lists. The syntax of a function is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE [OR REPLACE] FUNCTION name 
   [ (parameter [,parameter]) ] 
   RETURN return_datatype
   [AUTHID  CURRENT_USER | DEFINER ] -- Oracle8i
   [DETERMINISTIC]                   -- Oracle8i
   [PARALLEL_ENABLE]                 -- Oracle8i
IS | AS
   [declaration_section]
BEGIN
   executable_section
[EXCEPTION
   exception_section]
END [name];</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A function must have at least one RETURN statement in the execution section. The RETURN clause in the function header specifies the datatype of the returned value.</P
><P
CLASS="para"
>See the <A
CLASS="xref"
HREF="ch01_12.htm"
>Section 1.12.3.8, "Compiling stored PL/SQL programs</A
><EM
CLASS="emphasis"
>"</EM
> section for information on the key words OR REPLACE, AUTHID, DETERMINISTIC, and PARALLEL_ENABLE. </P
><P
CLASS="para"
>See the <A
CLASS="xref"
HREF="ch01_12.htm"
>Section 1.12.3.9, "Privileges and stored PL/SQL</A
><EM
CLASS="emphasis"
>"</EM
> section for additional information on the key word AUTHID. </P
><P
CLASS="para"
>A function can be called anywhere an expression of the same type can be used. You can call a function:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In an assignment statement:</P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>sales95 := tot_sales(1995,'C');</PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>To set a default value:</P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
	sales95 NUMBER DEFAULT tot_sales(1995,'C');
BEGIN</PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In a Boolean expression:</P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF tot_sales(1995,'C') &gt; 10000
THEN
...</PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In a SQL statement:</P
></LI
></UL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SELECT first_name ,surname
   FROM sellers
WHERE tot_sales(1995,'C') &gt; 1000;</PRE
></BLOCKQUOTE
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>As an argument in another program unit's parameter list. </P
></LI
></UL
><P
CLASS="para"
>Here, for example, <EM
CLASS="emphasis"
>max_discount</EM
> is a programmer-defined function and SYSDATE is a built-in function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>apply_discount(company_id, max_discount(SYSDATE));</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="plsql-toc443895380"
>1.12.3 Parameters</A
></H3
><P
CLASS="para"
>Procedures, functions, and cursors may have a parameter list. This list contains one or more parameters that allow you to pass information back and forth between the subprogram and the calling program. Each parameter is defined by its name, datatype, mode, and optional default value. The syntax for a parameter is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>parameter_name [mode] [NOCOPY] datatype
   [(:= | DEFAULT) value]</PRE
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895381"
>1.12.3.1 Datatype</A
></H4
><P
CLASS="para"
>The datatype can be any PL/SQL or programmer-defined datatype, but cannot be constrained by a size (NUMBER is valid, NUMBER(10) is not valid). The actual size of the parameter is determined from the calling program or via a %TYPE constraint.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE empid_to_name
(in_id           emp.emp_id%TYPE -- Compiles OK.
,out_last_name   VARCHAR2        -- Compiles OK.
,out_first_name  VARCHAR2(10)    -- Won't compile.
) IS
...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The lengths of <EM
CLASS="emphasis"
>out_last_name</EM
> and <EM
CLASS="emphasis"
>out_first_name</EM
> are determined by the calling program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   surname     VARCHAR2(10);
   first_name  VARCHAR2(10);
BEGIN
   empid_to_name(10, surname, first_name);
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895382"
>1.12.3.2 Mode</A
></H4
><P
CLASS="para"
>The mode of a parameter specifies whether the parameter can be read from or written to, as shown in the following table.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Mode</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parameter Usage</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>IN</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Read-only</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The value of the actual parameter can be referenced inside the program, but the parameter cannot be changed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>OUT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Write-only</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The program can assign a value to the parameter, but the parameter's value cannot be referenced.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>IN OUT</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Read/write</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The program can both reference (read) and modify (write) the parameter.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>If the mode is not explicitly defined, it defaults to IN. </P
><P
CLASS="para"
>OUT parameters can be written to. In Oracle7, OUT parameters can appear only on the left side of an assignment operation. In Oracle8 and above, OUT parameters are read/write and hence can appear on either side of an assignment. If an exception is raised during execution of a procedure or function, assignments made to OUT or IN OUT parameters get rolled back.</P
><P
CLASS="para"
>The NOCOPY (Oracle8<EM
CLASS="emphasis"
>i</EM
>) compiler hint for parameters makes the parameter a call by reference instead of a call by value. Normally, PL/SQL passes IN/OUT parameters by value&nbsp;-- a copy of the parameter is created for the subprogram. When parameter items get large, like collections or objects, the copy can eat memory and slow the processing. NOCOPY directs PL/SQL to pass the parameter by reference, using a pointer to the single copy of the parameter. The disadvantage of NOCOPY is that when an exception is raised during execution of a program that has modified an OUT or IN OUT parameter, the changes to the actual parameters are not rolled back because the parameters were passed by reference instead of being copied. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895383"
>1.12.3.3 Default values</A
></H4
><P
CLASS="para"
>IN parameters can be given default values. If an IN parameter has a default value, then you do not need to supply an argument for that parameter when you call the program unit. It automatically uses the default value. For example:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PROCEDURE hire_employee
(emp_id       IN VARCHAR2
,hire_date    IN DATE := SYSDATE
,company_id   IN NUMBER := 1
) IS
...

-- Example calls to the procedure.
-- Use two default values.
hire_employee(new_empno);
-- Use one default value.
hire_employee(new_empno,'12-Jan-1999');
-- Use non-trailing default value, named notation.
hire_employee(emp_id=&gt;new_empno, comp_id=&gt;12);</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895384"
>1.12.3.4 Parameter-passing notations</A
></H4
><P
CLASS="para"
><EM
CLASS="emphasis"
>Formal parameters</EM
> are the names that are declared in the header of a procedure or function. <EM
CLASS="emphasis"
>Actual parameters</EM
> are the values or expressions placed in the parameter list when a procedure or function is called. In the <EM
CLASS="emphasis"
>empid_to_name</EM
> example shown earlier in the <A
CLASS="xref"
HREF="ch01_12.htm"
>Section 1.12.3.1, "Datatype</A
>" section, the actual parameters to the procedure are <EM
CLASS="emphasis"
>in_id</EM
>, <EM
CLASS="emphasis"
>out_last_name</EM
>, and <EM
CLASS="emphasis"
>out_first_name</EM
>. The formal parameters used in the call to this procedure are 10, <EM
CLASS="emphasis"
>surname</EM
>, and <EM
CLASS="emphasis"
>first_name</EM
>. </P
><P
CLASS="para"
>PL/SQL lets you use either of two styles for passing arguments in parameter lists: positional or named notation.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Positional notation</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This is the default. Each value in the list of arguments supplied in the program call is associated with the parameter in the corresponding position. </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>Named notation</EM
> </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This explicitly associates the argument value with its parameter by name (not position). When you use named notation, you can supply the arguments in any order and you can skip over IN arguments that have default values.</P
></DD
></DL
><P
CLASS="para"
>The call to the <EM
CLASS="emphasis"
>empid_to_name</EM
> procedure is shown here with both notations:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   -- Implicit positional notation. 
   empid_to_name(10, surname, first_name);
 
   -- Explicit named notation. 
   empid_to_name(in_id=&gt;10 
      ,out_last_name=&gt;surname 
      ,out_first_name=&gt;first_name);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When calling stored functions from SQL, named notation is not supported.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895386"
>1.12.3.5 Local program </A
></H4
><P
CLASS="para"
>A local program is a procedure or function that is defined in the declaration section of a PL/SQL block. The declaration of a local program must appear at the end of the declaration section, after the declarations of any types, records, cursors, variables, and exceptions. A program defined in a declaration section may only be referenced within that block's executable and exception sections. It is not defined outside that block. </P
><P
CLASS="para"
>The following program defines a local procedure and function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE track_revenue
IS
   PROCEDURE calc_total (year_in IN INTEGER) IS
   BEGIN
      calculations here ...
   END;

   FUNCTION below_minimum (comp_id IN INTEGER)  
      RETURN BOOLEAN
   IS
   BEGIN
      ...
   END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Local programs may be overloaded with the same restrictions as overloaded packaged programs.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895387"
>1.12.3.6 Program overloading </A
></H4
><P
CLASS="para"
>PL/SQL allows you to define two or more programs with the same name within any declaration section, including a package specification or body. This is called <EM
CLASS="emphasis"
>overloading</EM
>. If two or more programs have the same name, they must be different in some other way so that the compiler can determine which program should be used. </P
><P
CLASS="para"
>Here is an example of overloaded programs in a built-in package specification:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE DBMS_OUTPUT 
IS
   PROCEDURE PUT_LINE (a VARCHAR2);
   PROCEDURE PUT_LINE (a NUMBER);
   PROCEDURE PUT_LINE (a DATE);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Each PUT_LINE procedure is identical, except for the datatype of the parameter. That is enough difference for the compiler. </P
><P
CLASS="para"
>To overload programs successfully, one or more of the following conditions must be true:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Parameters must differ by datatype family (number, character, datetime, or Boolean).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The program type must be different (you can overload a function and a procedure of the same name and identical parameter list).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The numbers of parameters must be different.</P
></LI
></UL
><P
CLASS="para"
>You <EM
CLASS="emphasis"
>cannot</EM
> overload programs if:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Only the datatypes of the functions' RETURN clauses are different.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Parameter datatypes are within the same family (CHAR and VARCHAR2, NUMBER and INTEGER, etc.).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Only the modes of the parameters are different.</P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895388"
>1.12.3.7 Forward declarations </A
></H4
><P
CLASS="para"
>Programs must be declared before they can be used. PL/SQL supports <EM
CLASS="emphasis"
>mutual recursion</EM
>, in which program A calls program B, whereupon program B calls program A. To implement this mutual recursion, you must use a <EM
CLASS="emphasis"
>forward declaration</EM
> of the programs. This technique declares a program in advance of the program definition, thus making it available for other programs to use. The forward declaration is the program header up to the IS/AS keyword:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE perform_calc(year_in IN NUMBER)
IS
   /* Forward declaration for total_cost 
      function. */
   FUNCTION total_cost (...) RETURN NUMBER;

   /* The net_profit function can now use 
      total_cost. */
   FUNCTION net_profit(...) RETURN NUMBER
   IS
   BEGIN
      RETURN total_sales(...) - total_cost(...);
   END;

   /* The Total_cost function calls net_profit. */
   FUNCTION total_cost (...) RETURN NUMBER
   IS
   BEGIN
      IF net_profit(...) &lt; 0
      THEN
         RETURN 0;
         ELSE
         RETURN...;
      END IF;
   END;
BEGIN /* procedure perform_calc */
   ...
END perform_calc;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895389"
>1.12.3.8 Compiling stored PL/SQL programs</A
></H4
><P
CLASS="para"
>The following keywords are new with Oracle8<EM
CLASS="emphasis"
>i</EM
>:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>OR REPLACE </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Used to rebuild an existing program unit, preserving its privileges. </P
></DD
><DT
CLASS="term"
>AUTHID </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Defines whether the program will execute with the privileges of, and resolve names like, the object owner (DEFINER), or as the user executing the function (CURRENT_USER). Prior to Oracle8<EM
CLASS="emphasis"
>i,</EM
> only the built-in packages DBMS_SQL and DBMS_UTILITY executed as CURRENT_USER. The default AUTHID is DEFINER. </P
></DD
><DT
CLASS="term"
>REPEATABLE </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Required for functions and any dependent programs used in domain (application-defined) indexes.</P
></DD
><DT
CLASS="term"
>DETERMINISTIC </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Required for function-based indexes. A function is DETERMINISTIC if it does not meaningfully reference package variables or the database.</P
></DD
><DT
CLASS="term"
>PARALLEL_ENABLED</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Tells the optimizer that a function is safe for parallel execution. It replaces the statement:</P
></DD
></DL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PRAGMA RESTRICT REFERENCES (function_name, wnps, 
	rnps, wnds, rnds); </PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="plsql-toc443895390"
>1.12.3.9 Privileges and stored PL/SQL</A
></H4
><P
CLASS="para"
>Unless you're using an invoker's rights program in Oracle8<EM
CLASS="emphasis"
>i</EM
>,  roles cannot provide object or system privileges that can be used inside stored PL/SQL. You must have privileges granted directly to you for objects that, rather than owning, you reference in stored SQL or PL/SQL (procedures, functions, packages, triggers, and views). This restriction arises from the manner in which the database obtains privileges and checks for objects referenced from SQL.</P
><P
CLASS="para"
>Direct GRANT and REVOKE privileges cannot be different for two concurrent sessions of the same user, while roles can be disabled in only one session. Privileges are checked when stored PL/SQL is compiled, and since only GRANT and REVOKE privileges can be relied upon to remain enabled, they are the only privileges checked. </P
><P
CLASS="para"
>This direct GRANT restriction does not apply for anonymous PL/SQL blocks because such blocks are compiled at runtime when all privileges are known. It also does not apply for procedures and functions with the AUTHID of CURRENT_USER (Oracle8<EM
CLASS="emphasis"
>i</EM
>).</P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_11.htm"
TITLE="1.11 Records in PL/SQL"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.11 Records in PL/SQL"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Oracle PL/SQL Language Pocket Reference"
><IMG
SRC="../gifs/txthome.gif"
ALT="Oracle PL/SQL Language Pocket Reference"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_13.htm"
TITLE="1.13 Triggers"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.13 Triggers"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.11 Records in PL/SQL</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
>&nbsp;</TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.13 Triggers</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly &amp; Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="../advprog/index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>

</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
