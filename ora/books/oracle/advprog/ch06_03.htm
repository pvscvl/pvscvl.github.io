<HTML
><HEAD
><TITLE
>[Chapter 6] 6.3 Assertion Routines</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:26:33Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. PLV: Top-Level Constants and Functions "><LINK
REL="prev"
HREF="ch06_02.htm"
TITLE="6.2 Setting the PL/Vision Date Mask"><LINK
REL="next"
HREF="ch06_04.htm#ch06-SECT-4.1"
TITLE="6.4 PLV Utilities"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_02.htm"
TITLE="6.2 Setting the PL/Vision Date Mask"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.2 Setting the PL/Vision Date Mask"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch06_01.htm"
TITLE="6. PLV: Top-Level Constants and Functions "
>Chapter 6<BR>PLV: Top-Level Constants and Functions </A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_04.htm#ch06-SECT-4.1"
TITLE="6.4 PLV Utilities"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.4 PLV Utilities"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch06-21041"
>6.3 Assertion Routines</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-998027-0"
></A
>PL/Vision provides a set of generic routines you can use in your own programs to assert the validity of your program's assumptions. Just about every piece of software you write makes assumptions about the data it manipulates. For example, parameters may have only certain values or be within a certain range; a string value should have a certain format; an underlying data structure is assumed to have been created. It's fine to have such rules and assumptions, but it is also very important to verify or "assert" that none of the rules is being violated.</P
><P
CLASS="para"
>The cleanest way to perform this task is to call a prebuilt assertion routine (see <CITE
CLASS="citetitle"
>Chapter 20</CITE
> in <CITE
CLASS="citetitle"
>Oracle PL/SQL Programming</CITE
>). The PLV package offers a variety of procedures to allow you to validate assumptions in the most natural possible manner. In all cases, if the assumption is violated the assertion program will take up to two actions:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Display a message if provided.</EM
> This string is optional and the default for the string is NULL.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Raise the</EM
> <KBD
CLASS="command"
>assertion_failure</KBD
> <EM
CLASS="emphasis"
>exception.</EM
><A
CLASS="indexterm"
NAME="ch06-idx-997907-0"
></A
> You can then handle this exception in the program that called the assertion routine, or you can let the exception terminate that program and propagate to the enclosing block.</P
></LI
></OL
><P
CLASS="para"
>The PLV assertion routines come in the following flavors:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Procedure Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>assert</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Generic assertion routine. You pass it a Boolean expression or value and assert tests to see if that expression is TRUE.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>assert_inrange</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Generic assertion routine to check date and numeric ranges. You provide the value to be checked along with start and end values. If the value (either date or number) does not fall within the specified range, <KBD
CLASS="command"
>assert_inrange</KBD
> </P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>assert_notnull</KBD
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Generic assertion routine to check that the specified value is NOT NULL.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The <KBD
CLASS="command"
>assert</KBD
> procedure <A
CLASS="indexterm"
NAME="ch06-idx-997908-0"
></A
>is the most generic of the assertion routines. It is called, in fact, by the other assertion routines. The header for <KBD
CLASS="command"
>assert</KBD
> is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE assert
   (bool_in IN BOOLEAN, stg_in IN VARCHAR2 := NULL);</PRE
></BLOCKQUOTE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-3.1"
>6.3.1 Using the assert Procedure</A
></H3
><P
CLASS="para"
>Let's take a look at how to incorporate assertion routines in your code, and then examine the impact. The following procedure translates a code into a description string. There are only three valid codes, an assumption that is validated by the call to <KBD
CLASS="command"
>PLV.assert</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE FUNCTION calltype (code_in IN VARCHAR2) 
   RETURN VARCHAR2
IS
   retval VARCHAR2(100) := NULL;
BEGIN
   PLV.assert 
      (code_in IN ('E', 'C', 'I'), 'Enter E C or I...');
   IF code_in = 'E'
   THEN retval := 'EMERGENCY';
   ELSIF code_in = 'C'
   THEN retval := 'COMPLAINT';
   ELSIF code_in = 'I'
   THEN retval := 'INFORMATION';
   END IF;
   RETURN retval;
END calltype;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that I pass a complex Boolean expression as an argument to the assert routine. This may seem odd at first glance, but you will get used to it quickly. A program's Boolean argument can be a literal, a variable, or an expression.</P
><P
CLASS="para"
>Now we will try using the <KBD
CLASS="command"
>calltype</KBD
> function<A
CLASS="indexterm"
NAME="ch06-idx-997909-0"
></A
> by embedding it in calls to the <KBD
CLASS="command"
>p.l</KBD
> procedure so that we can see the results.</P
><P
CLASS="para"
>In the first call to <KBD
CLASS="command"
>calltype</KBD
> below, I pass a valid code and <KBD
CLASS="command"
>p.l</KBD
> displays the correct returned description. In the second call to <KBD
CLASS="command"
>calltype</KBD
>, I pass an invalid code, J. As a result, the assertion routine displays the message as specified in the function and then raises the exception, which goes unhandled.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec p.l(calltype('E'));
EMERGENCY
SQL&gt; exec p.l(calltype('J'));
Enter E C or I...
ERROR at line 1:
ORA-06510: PL/SQL: unhandled user-defined exception</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The error is displayed as a "user-defined exception" because <KBD
CLASS="command"
>PLV.assert</KBD
> raised the <KBD
CLASS="command"
>assertion_failure</KBD
> exception, which is not a system exception. You can trap for that exception as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   p.l (calltype ('J'));
EXCEPTION
   WHEN PLV.assertion_failure
   THEN
      p.l ('Invalid call type code');
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-3.2"
>6.3.2 Asserting NOT NULL<A
CLASS="indexterm"
NAME="ch06-idx-997911-0"
></A
></A
></H3
><P
CLASS="para"
>The other assertion routines are designed to handle specific kinds of assertions that programmers must commonly handle. The <KBD
CLASS="command"
>assert_notnull</KBD
><A
CLASS="indexterm"
NAME="ch06-idx-997910-0"
></A
> routine, for example, allows you to easily make sure that an argument to a program is NOT NULL.</P
><P
CLASS="para"
>Without an assertion routine, you will write variations of code like this over and over again in your programs:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF code_in IS NULL
THEN
   p.l ('The code cannot be null!');
   RAISE VALUE_ERROR;
ELSE
   act_on_code (code_in);
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With <KBD
CLASS="command"
>PLV.assert_notnull</KBD
>, you simply attempt to assert the rule. If the code "passes," you move on to your action:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLV.assert_notnull (code_in);
act_on_code (code_in);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You save on the typing and your indentation flattens out, thereby improving the readability of your program.</P
><P
CLASS="para"
>PLV offers four overloadings of <KBD
CLASS="command"
>assert_notnull</KBD
>, so you can pass it Booleans, strings, dates, and numbers. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-SECT-3.3"
>6.3.3 Asserting "In Range"</A
></H3
><P
CLASS="para"
>The range assertion routines<A
CLASS="indexterm"
NAME="ch06-idx-997912-0"
></A
> will probably save you the most code and provide a higher level of coverage of problem data. PLV offers two overloaded <KBD
CLASS="command"
>assert_inrange</KBD
><A
CLASS="indexterm"
NAME="ch06-idx-997913-0"
></A
> programs: one for dates and one for numbers. </P
><P
CLASS="para"
>The date range assertion routine header is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE assert_inrange
   (val_in IN DATE,
    start_in IN DATE := SYSDATE,
    end_in IN DATE := SYSDATE+1,
    stg_in IN VARCHAR2 := NULL,
    truncate_in IN BOOLEAN := TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first three arguments should be clear: You provide the value you want to check, as well as the start and end dates. Notice that the default start date is SYSDATE or "now" (at midnight) and the default end date is SYSDATE+1 or "tomorrow" (at midnight). The fourth argument, <KBD
CLASS="command"
>stg_in</KBD
>, is the optional string for display. </P
><P
CLASS="para"
>The fifth parameter, <KBD
CLASS="command"
>truncate_in</KBD
>, allows you to specify whether or not you want the end-point dates to be truncated. When a date is truncated (with the default mask, which is your only option in <KBD
CLASS="command"
>assert_inrange</KBD
>), the time portion is removed. The default setting for this argument is to perform truncation. I offer this option because in many cases when developers want to perform date range checks, they do not want to have to deal with the time component. That aspect of a date variable can, in fact, cause "obviously correct" dates to fail.</P
><P
CLASS="para"
>The default values of <KBD
CLASS="command"
>assert_inrange</KBD
> for dates is designed to allow you to assert with a minimum of typing that a date falls on the current day. Consider this call to the assertion program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF PLV.assert_inrange (v_hiredate)
THEN
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If no other arguments are specified, then <KBD
CLASS="command"
>PLV</KBD
> checks to see if</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>v_hiredate BETWEEN TRUNC (SYSDATE) AND TRUNC (SYSDATE+1)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>which, given the way TRUNC works, asks: "Is <KBD
CLASS="command"
>hiredate</KBD
> between midnight of last night and midnight of the coming night?" In other words, does <KBD
CLASS="command"
>v_hiredate</KBD
> fall anywhere during the current day?</P
><P
CLASS="para"
>The numeric <KBD
CLASS="command"
>assert_inrange</KBD
> is more straightforward. As you can see from the header below, there is no truncate argument. It simply checks to see if the specified number falls within the specified range.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE assert_inrange
   (val_in IN NUMBER,
    start_in IN NUMBER,
    end_in IN NUMBER,
    stg_in IN VARCHAR2 := NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following procedure updates the salary of an employee, but only if the new salary does not exceed the maximum salary allowed in the system (returned by the personnel package <KBD
CLASS="command"
>max_salary</KBD
> function):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE update_salary 
   (emp_in IN emp.empno%TYPE, newsal_in IN NUMBER)
BEGIN
   PLV.assert_inrange (newsal_in, 0, personnel.max_salary);
   UPDATE emp
      SET sal = newsal_in
    WHERE empid = emp_in;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you are careful and consistent in your use of assertion programs like those in the PLV package, your programs will be more robust and less likely to fail in unpredictable ways.<A
CLASS="indexterm"
NAME="ch06-idx-997914-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_02.htm"
TITLE="6.2 Setting the PL/Vision Date Mask"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.2 Setting the PL/Vision Date Mask"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch06_04.htm#ch06-SECT-4.1"
TITLE="6.4 PLV Utilities"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.4 PLV Utilities"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.2 Setting the PL/Vision Date Mask</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.4 PLV Utilities</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
