<HTML
><HEAD
><TITLE
>[Chapter 21] PLVlog and PLVtrc: Logging and Tracing</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:31:24Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part05.htm"
TITLE="V. Plug-and-Play Packages"><LINK
REL="prev"
HREF="ch20_02.htm#ch20-SECT-2.1"
TITLE="20.2 PLVrb: Performing Rollbacks"><LINK
REL="next"
HREF="ch21_02.htm#ch21-SECT-2.1"
TITLE="21.2 PLVtrc: Tracing Execution of PL/SQL Programs"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_02.htm#ch20-SECT-2.1"
TITLE="20.2 PLVrb: Performing Rollbacks"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 20.2 PLVrb: Performing Rollbacks"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 21</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch21_02.htm#ch21-SECT-2.1"
TITLE="21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="plsql-adv-ch-21"
>21. PLVlog and PLVtrc: Logging and Tracing</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch21-11229"
TITLE="21.1 PLVlog: Logging Activity in PL/SQL Programs"
>PLVlog: Logging Activity in PL/SQL Programs</A
><BR><A
CLASS="sect1"
HREF="ch21_02.htm#ch21-SECT-2.1"
TITLE="21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
>PLVtrc: Tracing Execution of PL/SQL Programs</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch21-idx-998520-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998520-1"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998520-2"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998520-3"
></A
>PL/Vision provides two packages to provide execution tracing and logging from within <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs. </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Use the PLVlog package to write information to a log. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use the PLVtrc package to trace the execution of your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs. </P
></LI
></UL
><P
CLASS="para"
>Both of these packages are used by other PL/Vision packages, PLVlog in particular. For example, when you handle an exception with a PLVexc handler like <KBD
CLASS="command"
>rec_continue</KBD
>, it, in turn, calls PLVlog to log the error.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch21-11229"
>21.1 PLVlog: Logging Activity in PL/SQL Programs</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch21-idx-998521-0"
></A
>The PLVlog (PL/Vision LOGging) package offers a powerful, generic logging mechanism for <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>-based applications. The need to log activity arises in a number of different settings, including logging errors, tracing execution, and auditing activity. Rather than build this functionality over and over again, you can use PLVlog to handle many different circumstances.</P
><P
CLASS="para"
>The central features of PLVlog include:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Writing of log information to one of several different repositories, including a database table, a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, or an operating system file (for <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> Release 2.3 and above).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Simultaneous, optional display of logged information. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Toggle processing of log activity. You can decide to turn off logging at any time without having to change your own application code.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>High-level programs to manage the log. You can display contents of the log with a single program call, and transfer the log contents from a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table to a database table.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Automated rollback and savepoint activity. The package provides the ability to preserve database-logged information even if the surrounding transaction is rolled back.</P
></LI
></UL
><P
CLASS="para"
>The following sections show how to use each of the different elements of PLVlog.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch21-SECT-1.1"
>21.1.1 Controlling the Log Action</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch21-idx-998522-0"
></A
>PLVlog writes information to the log only when it is turned on. The package provides a standard PL/Vision toggle to control the action of the logging mechanism. The programs comprising this toggle are:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE turn_on;
PROCEDURE turn_off;
FUNCTION logging RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>One procedure to turn on logging, another to turn it off, and a final function to indicate the current state of affairs (for completeness and politeness). All the two procedures do is set the value of a private Boolean variable, but by correctly applying that Boolean inside an IF statement in PLVlog, the package's user gets to fine-tune the package's behavior. </P
><P
CLASS="para"
>Why would you turn off logging? You might be executing a production program for a one-time batch of millions of records. If you use the normal logging built into your program, you end up with millions of lines in the log. You can't afford the performance or disk overhead, and you don't really care about the log information for this run. So instead of modifying your program (supposed it is called <KBD
CLASS="command"
>analyze_sales</KBD
>), you simply turn off logging as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.turn_off;
SQL&gt; exec analyze_sales;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch21-SECT-1.2"
>21.1.2 Writing to the Log</A
></H3
><P
CLASS="para"
>You use the <KBD
CLASS="command"
>put_line</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998523-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998523-1"
></A
> procedure to write a line to the log. There are two overloaded versions of <KBD
CLASS="command"
>put_line</KBD
>; the headers are shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE put_line
   (context_in IN VARCHAR2,
    code_in IN INTEGER,
    string_in IN VARCHAR2 := NULL,
    create_by_in IN VARCHAR2 := USER,
    rb_to_in IN VARCHAR2 := c_default,
    override_in IN BOOLEAN := FALSE);

PROCEDURE put_line
   (string_in IN VARCHAR2,
    rb_to_in IN VARCHAR2 := c_default,
    override_in IN BOOLEAN := FALSE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The second version of <KBD
CLASS="command"
>put_line</KBD
>&nbsp;-- the one with only three arguments&nbsp;-- simply calls the first version with null values for the other arguments. It is provided for convenience, when you simply want to log a string of text and not bother with all the other values. The full set of arguments to <KBD
CLASS="command"
>put_line</KBD
> is explained in the following:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><KBD
CLASS="command"
>context_in</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The context from which the log was called, which usually means the program unit in which <KBD
CLASS="command"
>put_line</KBD
> was called. You must supply a context.</P
></DD
><DT
CLASS="term"
>code_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A numeric code to be stored with the text message. This would usually be the error number, but it could be anything. You must supply an integer code.</P
></DD
><DT
CLASS="term"
>string_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The text to be stored in the log. It can be up to 2000 bytes in length.</P
></DD
><DT
CLASS="term"
>create_by_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The name of the user or account that created the line in the log. The default is provided by the builtin USER function.</P
></DD
><DT
CLASS="term"
>rb_to_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The name of the savepoint to which you want a rollback to occur. The default value is the currently defined default savepoint in PLVlog. This argument is used when you have called <KBD
CLASS="command"
>do_rollback</KBD
>; see <A
CLASS="xref"
HREF="ch21_01.htm"
>Section 21.1.5, "Rolling Back with PLVlog"</A
> for more information on this argument.</P
></DD
><DT
CLASS="term"
>override_in</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If you pass TRUE for this argument, then the string is written to the log even if logging is otherwise turned off.</P
></DD
></DL
><P
CLASS="para"
>If you have turned off logging with a call to PLV<KBD
CLASS="command"
>log.turn_off</KBD
>, a call to <KBD
CLASS="command"
>put_line</KBD
> will not add any information to the log (unless you override that state of affairs).</P
><P
CLASS="para"
><KBD
CLASS="command"
>PLVlog.put_line</KBD
> is called from several different PL/Vision packages; I'll use those programs as examples so you can see how and why <KBD
CLASS="command"
>put_line</KBD
> has so many arguments.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.2.1"
>21.1.2.1 Using put_line</A
></H4
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In the PLVcmt package, you can ask that commits be recorded to the log by calling the PLVcmt.log procedure. When logging is turned on, the <KBD
CLASS="command"
>put_line</KBD
> program is called at commit time, as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF logging 
THEN 
   PLVlog.put_line
      ('PLVcmt', 0, 
       v_message || ' ' || context_in,
       PLVlog.c_noaction,
       TRUE); 
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I provide the context, a generic <A
CLASS="indexterm"
NAME="ch21-idx-998524-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998524-1"
></A
>PLVcmt, an INTEGER code of 0 to indicate success, and the message constructed from various components. Since I am committing, I do not want any rollback activity to occur, so I request "no action" for the savepoint. Finally, I want to record this information even if the user has turned off logging, so I pass TRUE to override the current setting.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch21-idx-998525-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998525-1"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998525-2"
></A
>PLVexc exception-handling package uses PLVlog to record errors in one's application. In the code shown below, <KBD
CLASS="command"
>PLVlog.put_line</KBD
> is only called when the user has requested that an error be recorded. So I again override the current log setting to make sure that this information is written to the log. I also pass in the context, error code and error message associated with the exception. Finally, I do not provide a value for the savepoint argument; I simply rely on the default handling. If the user wants a special rollback action, she provides direction with calls to the appropriate PLVlog programs directly.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF recording_exception (handle_action_in)
THEN
   PLVlog.put_line 
      (context_in, err_code_in, string_in,
       override_in =&gt; TRUE);
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Sometimes I simply want to take advantage of the PLVlog architecture to allow me to write a string out to a log without having to fuss with all those arguments. In the following code fragment, I request that output be directed to a database table and then execute a series of procedures, documenting their completion with calls to <KBD
CLASS="command"
>PLVlog.put_line</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   PLVlog.to_dbtab;

   calculate_gross_sales (1995, sales$);
   PLVlog.put_line ('gross sales', sales$);

   calculate_office_expenses (1995, offexp$);
   PLVlog.put_line ('office expenses', offexp$);

   calculate_empl_comp(1995, emplcomp$);
   PLVlog.put_line ('employee compensation', emplcomp$);

   PLVcmt.perform_commit;
END;</PRE
></BLOCKQUOTE
></LI
></OL
><P
CLASS="para"
>You can use all the arguments or only the minimum. Either way, the <KBD
CLASS="command"
>put_line</KBD
> logging mechanism should come in very handy. You could even use PLVlog as a lazy way to write information to a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table!</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch21-SECT-1.3"
>21.1.3 Selecting the Log Type</A
></H3
><P
CLASS="para"
>The PLVlog package was designed to offer maximum <A
CLASS="indexterm"
NAME="ch21-idx-998526-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998526-1"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998526-2"
></A
>flexibility for logging. The usual logging mechanism requires that you write a record to a database table. This is certainly supported by PLVlog, but you can also select a different type of log, as appropriate to your needs. The log types supported by PLVlog are: database table, <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, operating system file, and standard output (your monitor). These different types and how to work with them are explained in the following sections. PLVlog does provide a single program, <KBD
CLASS="command"
>sendto</KBD
>, that you can use to set the log type. The header for <KBD
CLASS="command"
>sendto</KBD
> is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch21-idx-998527-0"
></A
>sendto (type_in IN VARCHAR2, file_in IN VARCHAR2 := NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>type_in</KBD
> is the type of log and <KBD
CLASS="command"
>file_in</KBD
> is the name of the operating system file (relevant only if you are setting the log type to <KBD
CLASS="command"
>PLV.file</KBD
>). The <KBD
CLASS="command"
>type_in</KBD
> must be one of the repository constants defined in the PLV package: <KBD
CLASS="command"
>PLV.dbtab</KBD
>, <KBD
CLASS="command"
>PLV.pstab</KBD
>, <KBD
CLASS="command"
>PLV.file</KBD
>, or <KBD
CLASS="command"
>PLV.stdout</KBD
>. </P
><P
CLASS="para"
>In addition to this generic type-setting procedure, PLVlog offers a procedure that specifically sets the log type. So to set the log type to a database table, you can enter either of these commands:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.sendto (PLV.dbtab)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.<A
CLASS="indexterm"
NAME="ch21-idx-998528-0"
></A
>to_dbtab</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To set the log type to a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, you can enter either of these commands:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.sendto (PLV.pstab)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.<A
CLASS="indexterm"
NAME="ch21-idx-998529-0"
></A
>to_pstab</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To set the log type to the <KBD
CLASS="command"
>mylog.txt</KBD
> operating system file, you can enter either of these commands:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.sendto (PLV.file, 'mylog.txt')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.<A
CLASS="indexterm"
NAME="ch21-idx-998530-0"
></A
>to_file ('mylog.txt')</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Finally, to set the log type to standard output, you can enter either of these commands:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.sendto (PLV.stdout)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.<A
CLASS="indexterm"
NAME="ch21-idx-998531-0"
></A
>to_stdout</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you are working with database or <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table logs, there are some other programs in PLVlog that you may find useful, as I describe below.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.3.1"
>21.1.3.1 Defining the database log table</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch21-idx-998532-0"
></A
>If you do decide to write the log to a database table, you can either use the default log table or specify a different table. When PLVlog performs an insert to the log, it uses dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> (PLVdyn), so it can construct the INSERT statement from your inputs. This approach allows you to use PLVlog for different purposes. You can even use PLVlog within the same application and Oracle connection to write to different logs!</P
><P
CLASS="para"
>PL/Vision provides a default log table, whose structure is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE TABLE PLV_log
   (context VARCHAR2(100),
    code INTEGER,
    text VARCHAR2(2000),
    create_ts DATE,
    create_by VARCHAR2(100));</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>context</KBD
> is the context in which the log entry was made. This might be a program name or a section within a program or an action. The <KBD
CLASS="command"
>code</KBD
> column is a numeric code. This could be an error code or a number in use in the application. The <KBD
CLASS="command"
>text</KBD
> column contains a (possibly) long line of text. The <KBD
CLASS="command"
>create_ts</KBD
> and <KBD
CLASS="command"
>create_by</KBD
> columns provide a user and date/time audit for the creation of the log entry.</P
><P
CLASS="para"
>PLVlog provides the <KBD
CLASS="command"
>set_dbtab</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998533-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998533-1"
></A
> procedure to change the name of the table and/or the names of each of the columns in the log table. The header for <KBD
CLASS="command"
>set_dbtab</KBD
> is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE set_dbtab
   (table_in IN VARCHAR2 := 'PLV_log',
    context_col_in IN VARCHAR2 := 'context', 
    code_col_in IN VARCHAR2 := 'code',  
    text_col_in IN VARCHAR2 := 'text',  
    create_ts_col_in IN VARCHAR2 := 'create_ts',
    create_by_col_in IN VARCHAR2 := 'create_by');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, <KBD
CLASS="command"
>set_dbtab</KBD
> provides you with the opportunity to override the default table and column names. Here are two examples of applying <KBD
CLASS="command"
>set_dbtab</KBD
> to different application circumstances:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Change the name of the table used for logging; the names of the columns remain the default.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.set_dbtab ('pnl_log');</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Change the name of the table and its columns used for logging.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.set_dbtab 
  ('pnl_log', 'progname', 'err_code',
   'err_text', 'inserted_on', 'inserted_by');</PRE
></BLOCKQUOTE
></LI
></OL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch21-idx-998534-0"
></A
>You can use <KBD
CLASS="command"
>set_dbtab</KBD
> to change some or all of these names, but remember that the table you select for logging must have at least these five columns with the same datatypes as the default table.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
>  If you use a database table for your log, remember that you must also execute a commit in your session to save the log. In addition, you often need to issue rollbacks so that transactions in error are not saved along with the log. </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.3.2"
>21.1.3.2 Closing the file</A
></H4
><P
CLASS="para"
>If you are writing to an operating system file, you need to close that file before you can see log information written to that repository. To close the PLVlog file, use the <KBD
CLASS="command"
>fclose</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998535-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998535-1"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998535-2"
></A
> procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE fclose;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You do not have to specify the file name; that information has been stored inside the package.<A
CLASS="indexterm"
NAME="ch21-idx-998536-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch21-SECT-1.4"
>21.1.4 Managing a PL/SQL Table Log</A
></H3
><P
CLASS="para"
>PLVlog lets you avoid the hassles of writing to a database log during execution of your application by writing instead to a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table. This data structure is memory-resident and owned by the session, so you don't have to deal with commits and rollbacks. Just run your application and then either display the log or copy the contents of the log to a database table with the <KBD
CLASS="command"
>ps2db</KBD
> procedure (explained below).</P
><P
CLASS="para"
>To set the log repository to the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, execute either:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.to_pstab;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.sendto (PLV.pstab);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Then, whenever a line is written to the log, it is deposited in the next available row in the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table. The log always starts at row 1 and moves sequentially forward. </P
><P
CLASS="para"
>The <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table that stores the log information is a table of 2,000-byte strings, defined as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>pstablog PLVtab.vcmax_table;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When a line is written to the table it is formatted as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>context_in || c_delim || 
TO_CHAR (code_in) || c_delim || 
string_in || c_delim ||
TO_CHAR (SYSDATE, PLV.datemask) || c_delim ||
create_by_in || c_delim</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>c_delim</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998537-0"
></A
> is defined to be CHR(8) (see the explanation of the <KBD
CLASS="command"
>put_line</KBD
> procedure for more information about the individual variables in this string of concatenations). This character shows up in Windows as a black box and is a useful delimiter. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.4.1"
>21.1.4.1 Counting and clearing the PL/SQL table</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch21-idx-998538-0"
></A
>When you are using the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table for logging, PLVlog provides two other programs with which to manage the table: <KBD
CLASS="command"
>clear_pstab</KBD
> and <KBD
CLASS="command"
>pstab_count</KBD
>. If you want to make sure that the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table-based log is empty, call the <KBD
CLASS="command"
>clear_pstab</KBD
> procedure as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.<A
CLASS="indexterm"
NAME="ch21-idx-998539-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998539-1"
></A
>clear_pstab;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you want to find out the number of rows currently in the log, you can call <KBD
CLASS="command"
>pstab_count</KBD
> as shown in the following IF statement (and used in the FOR loop of the <KBD
CLASS="command"
>showlog.sql</KBD
> script above):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF PLVlog.pstab_count &gt; 0
THEN
   PLVlog.display;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You cannot directly access the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table log, since the table itself is defined inside the body of the package and is, therefore, private. On the other hand, you can transfer the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table to a database table (with the <KBD
CLASS="command"
>ps2db</KBD
> procedure). You can also <KBD
CLASS="command"
>get_line</KBD
> to retrieve a specific row from the table, as discussed in the next section.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.4.2"
>21.1.4.2 Retrieving log data from PL/SQL table</A
></H4
><P
CLASS="para"
>You can unpack a log string in the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table into individual variables with the <KBD
CLASS="command"
>get_line</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998540-0"
></A
> procedure, whose header is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE get_line 
   (row_in IN INTEGER,
    context_out OUT VARCHAR2,
    code_out OUT INTEGER,
    string_out OUT VARCHAR2,
    create_by_out OUT VARCHAR2,
    create_ts_out OUT DATE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You supply the row number of the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table in which you are interested, and <KBD
CLASS="command"
>get_line</KBD
> returns the different elements of the logged message. This program is used by the <KBD
CLASS="command"
>ps2db</KBD
> procedure, and you can use it as well to parse the log information from the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table. The following script (stored in the <KBD
CLASS="command"
>showlog.sql</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998541-0"
></A
> file on the companion disk) displays all the rows in the log that were entered today for the context CALC_TOTALS:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   v_context PLV_log.context%TYPE;
   v_code PLV_log.code%TYPE;
   v_text PLV_log.text%TYPE;
   v_create_by PLV_log.create_by%TYPE;
   v_create_ts PLV_log.create_ts%TYPE;

BEGIN
   /* pstab_count is explained below. */
   FOR row_ind IN 1 .. PLVlog.pstab_count
   LOOP
      PLVlog.get_line 
         (row_ind, 
          v_context, v_code, v_text, 
          v_create_by, v_create_ts);

      IF v_create_ts BETWEEN TRUNC (SYSDATE)
                         AND TRUNC (SYSDATE+1) AND
         v_context = 'CALC_TOTALS'
      THEN
         p.l (v_text);
      END IF;
   END LOOP;
END;
/</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
>  If you are on the lookout for handy, concise string manipulation routines, you might want to examine the body of <KBD
CLASS="command"
>get_line</KBD
>. It contains a local procedure called <KBD
CLASS="command"
>get_colval</KBD
>, which allows me to cleanly separate out the different elements of my delimited string. It makes use of the <KBD
CLASS="command"
>betwnstr</KBD
> function of the PLV package, which in and of itself is a useful extra tool.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.4.3"
>21.1.4.3 Transferring a PL/SQL table log to a database table</A
></H4
><P
CLASS="para"
>PLVlog provides the <KBD
CLASS="command"
>ps2db</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998542-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998542-1"
></A
> procedure to transfer the contents of the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table log to the currently defined database log table. The header for this procedure is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE ps2db;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Why would you bother moving the contents of the log from a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table to a database table? You might have relied on the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table log during the execution of your application so that you didn't have to worry about commit and rollback processing. Now the test session is done and you want to move your log information to "persistent" data. The <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table goes away when your session ends. If you move the data to a database table, you can examine the contents at your leisure and with the flexibility offered by the <SPAN
CLASS="acronym"
>SQL</SPAN
> language.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch21-SECT-1.5"
>21.1.5 Rolling Back with PLVlog</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch21-idx-998543-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998543-1"
></A
>One of the problems with writing log information to a database table is that the information is only available once the new rows are committed to the database. This can be a problem because PLVlog is often employed to track errors&nbsp;-- and in many of these situations, the current transaction has failed or otherwise requires a rollback. </P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch21_01.htm"
>Figure 21.1</A
> illustrates the complexity of maintaining <A
CLASS="indexterm"
NAME="ch21-idx-998544-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998544-1"
></A
>transaction integrity while also preserving records written to a database table log. Transaction A raises an exception. A consequence of the exception is a rollback of the entire transaction. PLVlog is then called to put a line in the log. The application then moves on to the next transaction. If transaction B also raises an exception and issues a rollback, the record written to the log is also erased. So it is necessary to issue a savepoint immediately after the write to the database log. The final complication, however, is that when the rollback of transaction B occurs, it must roll back to the post-log savepoint.</P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="ch21-17946"
>Figure 21.1: Preserving log entries while rolling back transactions</A
></H4
><IMG
CLASS="graphic"
SRC="figs/pladv_2101.gif"
ALT="Figure 21.1"><P
CLASS="para"
>This scenario gives rise to a number of interesting challenges for a generic logging package like PLVlog: how can it avoid saving in-error transactions while saving log information? How can the post-log transaction rollback know about the savepoint? If known, how can this dynamic rollback to a variable savepoint be accomplished? And how can Plvlog make this process as transparent as possible to users of the logging mechanism?</P
><P
CLASS="para"
>PLVlog offers an architecture to answer these questions. It is complicated and sometimes hard to follow, but it does seem to get the job done.</P
><P
CLASS="para"
>At a high level, I want to perform steps like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Rollback-Transaction
Insert-Line-in-Log
Set-Savepoint-to-Preserve-Insert</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Yet when you examine "Rollback-Transaction" more closely, a question arises: Do I want to perform an unqualified rollback to reject all uncommitted changes, or do I want to roll back to a particular savepoint?</P
><P
CLASS="para"
>PL/Vision could require that the individual developers who use PLVlog simply handle all of these rollback and savepoint issues. But that approach places a high burden on my users and makes it much less likely that PLVlog will be used to its full potential&nbsp;-- a drawback I take kind of personally. So, instead, PLVlog offers several different toggles, settings, and commands you can use to direct PLVlog to take precisely the right actions in the right order and at the right time.</P
><P
CLASS="para"
>First, let's go over the way PLVlog performs rollbacks and savepoints, then examine how you can control this aspect of the package's behavior. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.5.1"
>21.1.5.1 <A
CLASS="indexterm"
NAME="ch21-idx-998545-0"
></A
>Toggling rollback activity</A
></H4
><P
CLASS="para"
>If your log repository is an operating system file or <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, the concept of a rollback simply doesn't apply. You only have to worry about this complication when you are logging directly to a database table&nbsp;-- which is, after all, a pretty common activity. Suppose, then, that you are using a database table log. PLVlog will still not perform any rollbacks or issue any savepoints unless you explicitly turn on this behavior. </P
><P
CLASS="para"
>PLVlog offers a standard PL/Vision toggle. This triumvirate of programs is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch21-idx-998546-0"
></A
>do_rollback;
PROCEDURE nodo_rollback;
FUNCTION <A
CLASS="indexterm"
NAME="ch21-idx-998547-0"
></A
>rolling_back RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>One procedure to turn on rollback and savepoint activity, another to turn it off (the default), and a final function to indicate the current state of affairs. All the two procedures do is set the value of a private Boolean variable, but by correctly applying that Boolean inside an IF statement in PLVlog, the package's user gets to fine-tune the package's behavior. </P
><P
CLASS="para"
>The discussion in the following sections assumes that at some point in your session before you tried to log activity to the database, you issued this command in SQL*Plus:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVlog.do_rollback</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or directly executed this command inside another <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   PLVlog.do_rollback;
   transfer_data;
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.5.2"
>21.1.5.2 How PLVlog manages the transaction</A
></H4
><P
CLASS="para"
>Assuming that you have directed PLVlog to help you manage your transaction automatically when information is sent to the database log, let's take a look at how PLVlog handles the complexities.</P
><P
CLASS="para"
>The best way to explain this process is to show you the relevant part of the body of the <KBD
CLASS="command"
>put_line</KBD
> program. The section below is executed only when logging is turned on or overridden in that call to <KBD
CLASS="command"
>put_line</KBD
>. As you can see, the discussion of rollbacks and this section of code is relevant only when the log type is a database table.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>1   IF log_type = PLV.dbtab
2   THEN
3      IF rolling_back
4      THEN
5         do_rb (v_message);
6      END IF;
7
8      put_to_db 
9         (context_in, code_in, string_in, create_by_in,
10         SYSDATE);
11
12     IF rolling_back
13     THEN
14        PLVrb.set_savepoint (v_savepoint);
15     END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Lines 8 through 10 contain the call to a private module, <KBD
CLASS="command"
>put_to_db</KBD
>, that performs the actual INSERT into the specified table. This INSERT is sandwiched between two rollback-related activities. Lines 3 and 12 apply the rollback toggle discussed in the previous section; if you have not requested <KBD
CLASS="command"
>PLVlog.do_rollback</KBD
>, then <KBD
CLASS="command"
>rolling_back</KBD
> returns FALSE and the code on lines 5 and 14 are not executed.</P
><P
CLASS="para"
>Suppose, however, that you have executed <KBD
CLASS="command"
>do_rollback</KBD
>. Then before a line of data is inserted into your log table, <KBD
CLASS="command"
>put_line</KBD
> executes the <KBD
CLASS="command"
>do_rb</KBD
> program, which is a local module in <KBD
CLASS="command"
>put_line</KBD
> that figures out exactly which type of rollback to execute. This topic is covered in <A
CLASS="xref"
HREF="ch21_01.htm"
>Section 21.1.5.6, "Performing different kinds of rollbacks"</A
>. After the information is inserted into the log, PLVlog calls the <KBD
CLASS="command"
>PLVrb.set_savepoint</KBD
> to set a savepoint using dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>. The savepoint used (<KBD
CLASS="command"
>v_savepoint</KBD
>) is the current PLVlog savepoint and is discussed in the next section.<A
CLASS="indexterm"
NAME="ch21-idx-998548-0"
></A
></P
><P
CLASS="para"
>By setting a savepoint immediately after the insert, PLVlog gives you a way to roll back all changes except for the last write to the log table. This savepoint is either a savepoint declared by PLVlog or a savepoint you have defined for PLVlog to use, as is explained below.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.5.3"
>21.1.5.3 <A
CLASS="indexterm"
NAME="ch21-idx-998549-0"
></A
>Types of rollback activity</A
></H4
><P
CLASS="para"
>PLVlog provides a set of constants, shown in the following table, that you can use to modify the way rollbacks occur in the <KBD
CLASS="command"
>put_line</KBD
> procedure.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Constant Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Value</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch21-idx-998550-0"
></A
>c_noaction</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>*NO ROLLBACK*</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Do not perform any kind of rollback.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch21-idx-998551-0"
></A
>c_none</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>*FULL*</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Perform a full rollback (not back to a savepoint).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch21-idx-998552-0"
></A
>c_default</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>*DEFAULT*</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Roll back to the default PLVlog savepoint.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch21-idx-998553-0"
></A
>c_last</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>*PLVRB-LAST*</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Roll back to the last savepoint maintained by the PLVrb package.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch21-idx-998554-0"
></A
>c_PLVlogsp</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog_savepoint</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Roll back to the <KBD
CLASS="command"
>PLVlog_savepoint</KBD
>, the initial default savepoint for PLVlog.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>You have probably noticed that the values for the first three "savepoints" are not valid savepoint names. Only the constant <KBD
CLASS="command"
>c_PLVlogsp</KBD
> can actually be used in a SAVEPOINT command. In fact, the other constants are only used by the <KBD
CLASS="command"
>do_rb</KBD
> program in <KBD
CLASS="command"
>put_line</KBD
> to determine which kind of ROLLBACK action to take. The <KBD
CLASS="command"
>do_rb</KBD
> procedure is explored in more detail in <A
CLASS="xref"
HREF="ch21_01.htm"
>Section 21.1.5.6</A
>.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.5.4"
>21.1.5.4 <A
CLASS="indexterm"
NAME="ch21-idx-998555-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998555-1"
></A
>Setting the default "rollback to" behavior</A
></H4
><P
CLASS="para"
>The default "rollback to" savepoint of PLVlog is used when the user has turned on rollback activity and the user has not provided an alternative savepoint in the call to <KBD
CLASS="command"
>put_line</KBD
>. This savepoint is then used to determine the type of rollback to execute before inserting a line into the log.</P
><P
CLASS="para"
>The default savepoint is initialized to the <KBD
CLASS="command"
>c_none</KBD
> constant, which means that a full, unqualified rollback is executed. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch21-idx-998556-0"
></A
>To change the default "rollback to" savepoint, you can call any of the programs whose headers are shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE rb_to (savepoint_in IN VARCHAR2 := c_none);
PROCEDURE <A
CLASS="indexterm"
NAME="ch21-idx-998557-0"
></A
>rb_to_last;
PROCEDURE <A
CLASS="indexterm"
NAME="ch21-idx-998558-0"
></A
>rb_to_default;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The procedures <KBD
CLASS="command"
>rb_to_last</KBD
> and <KBD
CLASS="command"
>rb_to_default</KBD
> are simply special cases of the <KBD
CLASS="command"
>rb_to</KBD
> procedure. Let's look at the impact of using these programs with the different savepoint constants and, of course, your own savepoint names. </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the default savepoint to "no action:"</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to (PLVlog.c_noaction);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you set the "rollback to" savepoint to "no action," no rollback occurs&nbsp;-- even if you have turned on rollbacks with a call to <KBD
CLASS="command"
>do_rollback</KBD
>. You will usually not pass this constant in to <KBD
CLASS="command"
>rb_to</KBD
>. Instead, you might do so in a call to <KBD
CLASS="command"
>put_line</KBD
> so that no rollbacks occur for that single insert.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the default savepoint to none:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to (PLVlog.c_none);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you set the "rollback to" savepoint to none, you are requesting a full ROLLBACK, unqualified by any savepoint. This causes all uncommitted changes to be erased from your session.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the default savepoint to the default:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to (PLVlog.c_default);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to_default;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By setting the "rollback to" savepoint to the default, you actually set the default savepoint to the constant <KBD
CLASS="command"
>c_PLVlogsp</KBD
>. You will usually not pass this constant in to <KBD
CLASS="command"
>rb_to</KBD
>. Instead, you might do so in a call to <KBD
CLASS="command"
>put_line</KBD
> to ensure that the current default savepoint is used for rollback activity (this, in fact, is the default).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the default savepoint to the PLVlog initial value:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to (PLVlog.c_PLVlogsp);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By setting the "rollback to" savepoint to this constant, you return the default savepoint back to its initial value. You might do this at the start of a process in order to reset the PLVlog package back to its original values.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the default savepoint to the last savepoint issued by PLVrb:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to (PLVlog.c_last);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to_last;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By setting the "rollback to" savepoint to this constant, you are coordinating closely with the PLVrb package, which maintains a stack of savepoints. You are indicating that when a rollback occurs, it should only roll back to the last savepoint issued by PLVrb. You should only use this setting if you are rigorous about using the <KBD
CLASS="command"
>PLVrb.set_savepoint</KBD
> procedure whenever you issue a SAVEPOINT.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the default savepoint to a user-defined savepoint indicating the start of a new order transaction:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.rb_to ('new_order');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By setting the savepoint to this string, you set the default behavior of PLVlog to rollback to this savepoint before an insert to the log table. </P
></LI
></OL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.5.5"
>21.1.5.5 <A
CLASS="indexterm"
NAME="ch21-idx-998559-0"
></A
>Specifying rollbacks when calling put_line</A
></H4
><P
CLASS="para"
>You can also use the rollback constants when specifying a value for the <KBD
CLASS="command"
>rb_to_in</KBD
> argument of <KBD
CLASS="command"
>put_line</KBD
>. This acts as an override to the default "rollback to" savepoint. Since we've already looked at how <KBD
CLASS="command"
>put_line</KBD
> works, let's now explore how to use the <KBD
CLASS="command"
>rb_to_in</KBD
> argument with these constants to change the rollback behavior for a specific call to <KBD
CLASS="command"
>put_line</KBD
>.</P
><P
CLASS="para"
>Here, again, is the header for <KBD
CLASS="command"
>put_line</KBD
> (the abbreviated version):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE put_line
   (string_in IN VARCHAR2,
    rb_to_in IN VARCHAR2 := c_default,
    override_in IN BOOLEAN := FALSE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The default value for the "rollback to" argument is <KBD
CLASS="command"
>c_default</KBD
>, which means that PLVlog issues a rollback according to the current default setting (explained in the next section). The following examples show the alternatives to this behavior:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Put a line in the log but do not perform any rollback activity, regardless of the value returned by <KBD
CLASS="command"
>PLVlog.rolling_back</KBD
>.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.put_line (v_err_msg, PLVlog.c_noaction);</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Put a line in the log and request a rollback to the last savepoint issued by PLVrb.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.put_line (v_err_msg, PLVlog.c_last);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This setting ties in PLVlog as tightly as possible with the use of PLVrb to manage and issue savepoints in your application.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Put a line in the log and request a full, unqualified rollback.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.put_line (v_err_msg, PLVlog.c_none);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The constant is called <KBD
CLASS="command"
>c_none</KBD
> because PLVlog does not roll back to any savepoint, instead it just issues a ROLLBACK command.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Put a line in the log, rolling back all changes made since the last SAVEPOINT TO the standard PLVlog savepoint.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVlog.put_line (v_err_msg, PLVlog.c_PLVlogsp);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is not the same as rolling back to the default savepoint, because you may have changed the default with a call to one of the <KBD
CLASS="command"
>rb_to</KBD
> programs documented in the next section.</P
></LI
></OL
><P
CLASS="para"
>In all of the above examples, the rollback activity described applies only to that single call to <KBD
CLASS="command"
>PLVlog.put_line</KBD
>. Whenever you call <KBD
CLASS="command"
>put_line</KBD
> and do not provide a value for the <KBD
CLASS="command"
>rb_to_in</KBD
> argument, PLVlog relies on the default activity you have previously defined (explained below).<A
CLASS="indexterm"
NAME="ch21-idx-998560-0"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.5.6"
>21.1.5.6 Performing different kinds of rollbacks</A
></H4
><P
CLASS="para"
>PLVlog takes a different rollback action depending on the default savepoint value. This logic is encapsulated in the local <KBD
CLASS="command"
>do_rb</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998561-0"
></A
> procedure inside <KBD
CLASS="command"
>put_line</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE do_rb (msg_in IN VARCHAR2)
IS
   v_sp PLV.plsql_identifier%TYPE := v_rb_to;
BEGIN
   IF rb_to_in != c_default
   THEN
      v_sp := rb_to_in;
   END IF;

   IF v_sp = c_noaction
   THEN
      NULL;

   ELSIF v_sp = c_none OR v_sp IS NULL
   THEN
      PLVrb.perform_rollback (msg_in);

   ELSIF v_sp = c_default
   THEN
      PLVrb.rollback_to (v_sp_PLVlog, msg_in);

   ELSIF v_sp = c_last
   THEN
      PLVrb.rb_to_last (msg_in);

   ELSE
      PLVrb.rollback_to (v_sp, msg_in);
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Allow me to translate: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If you have specified (through the default savepoint value stored in <KBD
CLASS="command"
>v_savepoint</KBD
>) "no action," then don't do anything.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you set the default to none or if the current default savepoint itself is NULL, perform a full, unqualified rollback with a call to <KBD
CLASS="command"
>PLVrb.perform_rollback</KBD
>. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the current "rollback to" savepoint is the default, roll back to the initial default value for PLVlog: <KBD
CLASS="command"
>PLVlog_savepoint</KBD
>. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you have requested a rollback to the last savepoint issued by PLVrb, PLVlog calls the corresponding <KBD
CLASS="command"
>PLVrb.rb_to_last</KBD
> procedure to implement precisely that functionality.</P
></LI
></UL
><P
CLASS="para"
>Finally, for any other savepoint values, PLVlog requests that PLVrb roll back uncommitted changes to that savepoint string.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch21-SECT-1.5.7"
>21.1.5.7 Setting the <A
CLASS="indexterm"
NAME="ch21-idx-998562-0"
></A
>post-insert savepoint</A
></H4
><P
CLASS="para"
>After the insert to the database log has taken place, PLVlog issues a savepoint if <KBD
CLASS="command"
>PLVlog.rolling_back</KBD
> returns TRUE. The purpose of this savepoint is to preserve the new log record&nbsp;-- even if a rollback comes surging back from activity after the call to the <KBD
CLASS="command"
>PLVlog.put_line</KBD
> procedure.</P
><P
CLASS="para"
>The post-insert savepoint of PLVlog (referred to for the rest of this section simply as "the savepoint") is initialized to the constant <KBD
CLASS="command"
>c_PLVlogsp</KBD
>, the predefined savepoint of the package.</P
><P
CLASS="para"
>You can change this savepoint with a call to the <KBD
CLASS="command"
>set_sp</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998563-0"
></A
> procedure, whose header is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE set_sp (savepoint_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Savepoint Argument </P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Post-Insert Savepoint Set To</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>c_none</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NULL; no savepoint is issued after the insert.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>c_noaction</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NULL; no savepoint is issued after the insert.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>c_last</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>PLVrb.lastsp</KBD
>; this function returns the last savepoint issued by PLVrb.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>c_default</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>c_PLVlogsp</KBD
>; the initial value and the default value for the PLVlog package.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>others</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The value provided in the argument. This string must be a valid savepoint, that is, a valid <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> identifier&nbsp;-- no more than 30 characters starting with a letter.<A
CLASS="indexterm"
NAME="ch21-idx-998564-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998564-1"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998564-2"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998564-3"
></A
></P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch21-SECT-1.6"
>21.1.6 Displaying the Log</A
></H3
><P
CLASS="para"
>PLVlog provides a single display procedure to display the contents of the log, whether the log is stored in the database or in a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table. If the log is in a database table, PLVlog makes use of the <KBD
CLASS="command"
>PLVdyn.intab</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998565-0"
></A
> procedure. If the log is in a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, PLVlog uses the <KBD
CLASS="command"
>PLVtab.display</KBD
><A
CLASS="indexterm"
NAME="ch21-idx-998566-0"
></A
> procedure. Here is the header for the <KBD
CLASS="command"
>display</KBD
> program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   PROCEDURE display (header_in IN VARCHAR2 := 'PL/Vision Log');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The header, which is optional, is used in the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table display, but not for the display of the database table.</P
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="AUTOID-21805"
>Special Notes on PLVlog</A
></H4
><P
CLASS="para"
>Here are some factors to consider when working with PLVlog:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The maximum size of the text information in the log is 2,000 characters.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>At runtime you can decide on the name of the database log table and its columns, but that table must have columns for the context, code, text line, date, and user.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot write log information to an operating system file unless you are running Oracle7 Server Release 7.3 and the corresponding Release 2.3 of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>One other possibility for log output is a DBMS_PIPE pipe. This has as the same advantages of a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table (no need to commit) and, in addition, allows the log data to be shared across sessions.<A
CLASS="indexterm"
NAME="ch21-idx-998649-0"
></A
><A
CLASS="indexterm"
NAME="ch21-idx-998649-1"
></A
></P
></LI
></UL
></DIV
><P
CLASS="para"
>Here is an example of using the <KBD
CLASS="command"
>display</KBD
> procedure: set the log repository to the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, execute the application, and then display the log.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute PLVlog.to_pstab
SQL&gt; start myapp
SQL&gt; execute PLVlog.display
Contents of PL/Vision Log
proc1 ORA-01476: divisor is equal to zero 12/19/1995 11:41:30
proc2 ORA-06502: PL/SQL: num or val error 12/19/1995 11:41:30</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can also view the contents of the log with <SPAN
CLASS="acronym"
>SQL</SPAN
> if the log is a database table. In the following scenario, I set the log repository to the database table, execute the application, and then display the log.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute PLVlog.to_dbtab
SQL&gt; start myapp
SQL&gt; start inlog
CONTEXT CODE    TEXT                         CREATE_TS
------- ----- ------------------------------ -----------------
proc1   -1476 ORA-01476: divisor is equal to 12/19/95 114301
                         zero
proc2   -6502 ORA-06502: PL/SQL: numeric or  12/19/95 114301
                         value error</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where the <KBD
CLASS="command"
>inlog.sql</KBD
> script is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET ARRAYSIZE 10
column code format 999999
column context format a12
column create_ts format a17
column text format a30
SELECT context, code, text, 
       TO_CHAR (create_ts, 'mm/dd/yy hhmiss') create_ts
  FROM PLV_log
 ORDER BY create_ts;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that this script uses the default logging table, <KBD
CLASS="command"
>PLV_log</KBD
>. You can, as noted above, override this default with your own table and column names.</P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch20_02.htm#ch20-SECT-2.1"
TITLE="20.2 PLVrb: Performing Rollbacks"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 20.2 PLVrb: Performing Rollbacks"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch21_02.htm#ch21-SECT-2.1"
TITLE="21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>20.2 PLVrb: Performing Rollbacks</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>21.2 PLVtrc: Tracing Execution of PL/SQL Programs</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
