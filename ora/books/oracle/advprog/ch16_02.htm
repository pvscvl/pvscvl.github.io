<HTML
><HEAD
><TITLE
>[Chapter 16] 16.2 Code Generated by PLVgen</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:29:00Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch16_01.htm"
TITLE="16. PLVgen: Generating PL/SQL Programs"><LINK
REL="prev"
HREF="ch16_01.htm"
TITLE="16.1 Options for Best Practices"><LINK
REL="next"
HREF="ch16_03.htm#ch16-SECT-3.3"
TITLE="16.3 Modifying PLVgen Behavior"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch16_01.htm"
TITLE="16.1 Options for Best Practices"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 16.1 Options for Best Practices"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch16_01.htm"
TITLE="16. PLVgen: Generating PL/SQL Programs"
>Chapter 16<BR>PLVgen: Generating PL/SQL Programs</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch16_03.htm#ch16-SECT-3.3"
TITLE="16.3 Modifying PLVgen Behavior"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 16.3 Modifying PLVgen Behavior"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch16-17494"
>16.2 Code Generated by PLVgen</A
></H2
><P
CLASS="para"
>With PLVgen, you can generate functions, procedures, packages, and variations on those. You have already seen examples of functions and procedures. The examples in this section demonstrate the other kinds of code generated from this package. You can also modify the contents of generated code by using the many different toggles.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.1"
>16.2.1 Generating a Package</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000238-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000238-1"
></A
>Don't get your hopes up too high. I can't generate a complete package for you. PLVgen can, on the other hand, generate a skeleton of the syntax required to build a package and also load it up with help text stubs and banners to break up the different elements of the package.</P
><P
CLASS="para"
>The header for the package generator is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   PROCEDURE pkg (name_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You provide the name of the package, the procedure produced, and the code for a package (specification and body). Consider the following two commands executed in SQL*Plus: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.usemax
SQL&gt; exec PLVgen.pkg ('PLVfile');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that I call <KBD
CLASS="command"
>PLVgen.usemax</KBD
> before generating my code. <KBD
CLASS="command"
>PLVgen.usemax </KBD
>turns on all available toggles for code content, including the CREATE OR REPLACE syntax, line numbers, program header, and help text stubs. These individual toggles and <KBD
CLASS="command"
>usemax</KBD
> are explained later in the chapter. The code generated by these commands is shown below.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
> 1 CREATE OR REPLACE PACKAGE PLVfile
 2 /*
 3 || Program: PLVfile
 4 ||  Author: Steven Feuerstein
 5 ||    File: PLVfile.SQL
 6 || Created: May 30, 1996 13:34:59
 7 */
 8 /*HELP
 9 Add help text here...
10 HELP*/
11
12 /*EXAMPLES
13 Add help text here...
14 EXAMPLES*/
15
16 IS
17 /* Public Data Structures */
18
19 /* Public Programs */
20
21    PROCEDURE help (context_in IN VARCHAR2 := NULL);
22
23 END PLVfile;
24 /
25
26 CREATE OR REPLACE PACKAGE BODY PLVfile
27 IS
28 /* Private Data Structures */
29
30 /* Private Programs */
31
32 /* Public Programs */
33
34    PROCEDURE help (context_in IN VARCHAR2 := NULL)
35    IS
36    BEGIN
37       PLVhlp.show ('s:PLVfile', context_in);
38    END help;
39 END PLVfile;
40 /</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, this generated package has all the syntax required to create package specifications and bodies (which is not, after all, very much syntax). It also contains a single procedure, <KBD
CLASS="command"
>help</KBD
> (lines 34 through 38), which relies on the PLVhlp package to provide online help about this package. It also creates stubs for the help text (lines 8 through 14), to remind you to add the text and make that information available (see <A
CLASS="xref"
HREF="ch17_01.htm"
>Chapter 17, <CITE
CLASS="chapter"
>PLVhlp: Online Help for PL/SQL Programs</CITE
></A
>, for more information on how PLVhlp works). </P
><P
CLASS="para"
>Finally, <KBD
CLASS="command"
>PLVgen.pkg</KBD
> provides banners in comments to delineate the different kinds of code one normally finds inside a package. These banners (lines 17, 19, 28, 30, and 32) help developers organize their code. This organization will, in turn, make it easier to develop, debug, and enhance the package.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.2"
>16.2.2 Generating a Procedure</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000239-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000239-1"
></A
>Once you have generated a package, you will most likely want to fill it up with procedures and functions. PLVgen provides the <KBD
CLASS="command"
>proc</KBD
> procedure to generate (as you might expect) procedures. Its header is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE proc
   (name_in IN VARCHAR2,
    params_in IN VARCHAR2 := NULL, 
    exec_in IN VARCHAR2 := NULL,
    incl_exc_in IN BOOLEAN := TRUE,
    indent_in IN INTEGER := 0);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The arguments of the <KBD
CLASS="command"
>proc</KBD
> procedure are explained below:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><KBD
CLASS="command"
>name_in</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The name of the procedure. The only required argument.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>params_in</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The list of parameters to be enclosed in parentheses after the procedure name. The default is NULL (no parameters). The syntax of this argument must be a valid parameter list as would appear in the procedure definition (minus the parentheses).</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>exec_in</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>One or more executable statements to place in the body of the procedure. If you want to provide more than one statement, you should concatenate a CHR(10) or <KBD
CLASS="command"
>PLVchr.newline_char</KBD
> between the statements to place them on separate lines. The default is NULL (no executable statements).</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>incl_exc_in</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Pass TRUE (the default) to include an exception section and initial handler, FALSE to skip the exception section. Why give the user a choice? Sometimes an exception handler is just plain unnecessary and little more than clutter.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>indent_in</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The incremental indentation by which the entire procedure's code should be indented. The default is 0.</P
></DD
></DL
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.2.1"
>16.2.2.1 Maximum content of the generated procedure</A
></H4
><P
CLASS="para"
>Let's look at an example of procedure generation to get a feel for the way you can use the different arguments: generate a procedure with all the default argument values and the full set of additional code elements turned on by the call to <KBD
CLASS="command"
>usemax</KBD
> (explained later in this chapter).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.usemax
SQL&gt; exec PLVgen.proc ('calc_totals');
    1    
    2    CREATE OR REPLACE PROCEDURE calc_totals
    3    /*
    4    || Program: calc_totals
    5    ||  Author: null
    6    ||    File: calc_totals.SQL
    7    || Created: May 29, 1996 13:36:20
    8    */
    9    /*HELP
   10    Add help text here...
   11    HELP*/
   12
   13    /*EXAMPLES
   14    Add help text here...
   15    EXAMPLES*/
   16
   17    IS
   18    BEGIN
   19       PLVtrc.startup ('calc_totals');
   20       PLVtrc.terminate;
   21
   22    EXCEPTION
   23       /* Call PLVexc in every handler. */
   24       WHEN OTHERS
   25       THEN
   26          PLVexc.rec_continue;
   27    END calc_totals;
   28    /</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Let's go through this code line by line so that you can understand clearly the different elements of code that are generated for a procedure and function. I won't repeat this explanation (or the volume of code) in the following sections. </P
><P
CLASS="para"
>Line 2 contains the header for the procedure header, including the CREATE OR REPLACE syntax. As you will see in later examples, you can provide a parameter list as part of this header as well.</P
><P
CLASS="para"
>Lines 3 through 8 contain the standard program header provided by PLVgen. Notice that the author is automatically set to "Steven Feuerstein". I make sure of this setting by including the following statement in my <KBD
CLASS="command"
>login.sql</KBD
> script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>exec PLVgen.set_author ('Steven Feuerstein');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Lines 9 through 15 are the stubs for help text on two topics: general help and examples help. These comment blocks are used both for inline documentation of the package and also for online help text for users (through the PLVhlp package).</P
><P
CLASS="para"
>Lines 19 and 20 call PLVtrc <KBD
CLASS="command"
>startup</KBD
> and <KBD
CLASS="command"
>terminate</KBD
> procedures. These programs provide an execution trace that is of particular use in the PLVexc exception- handling package. Again, you do not have to include these programs in your own generated code, but it is an available option.</P
><P
CLASS="para"
>Lines 22 through 26 show the standard PL/Vision exception handler section. A single WHEN OTHERS clause calls the <KBD
CLASS="command"
>PLVexc.rec_continue</KBD
> program, which records the error and continues processing. You can replace this PLVexc handler with another one (such as <KBD
CLASS="command"
>PLVexc.rec_halt</KBD
> or "record and halt"); the point to recognize here is that the generator creates an exception handler as a starting point, which reinforces best practices.</P
><P
CLASS="para"
>Lines 27 and 28 bring the procedure to a close. Notice that PLVgen automatically supplies an END label. It also provides the forward slash, that in conjunction with the CREATE OR REPLACE syntax results in a script that can be used immediately in SQL*Plus to store and compile the procedure.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
>  In most of the examples of generated code in the rest of this chapter, I turn off the many comments and other optional elements of the source code. By doing this, you can focus more easily on how PLVgen constructs the required elements of the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs. <A
CLASS="xref"
HREF="ch16_03.htm#ch16-SECT-3.3"
>Section 16.3, "Modifying PLVgen Behavior"</A
> explains how to use some or all (<KBD
CLASS="command"
>PLVgen.usemax</KBD
>) of the optional elements of the code listed previously.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.2.2"
>16.2.2.2 A procedure with <A
CLASS="indexterm"
NAME="ch16-idx-1000240-0"
></A
>parameter list and executable code</A
></H4
><P
CLASS="para"
>The following SQL*Plus session generates a procedure using a minimum of additional features, but with a parameter list and a single line of code in the body of the procedure.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.usemin
SQL&gt; exec PLVgen.proc ('disptot', 'comp_in in integer', 'get_total;');

PROCEDURE disptot (comp_in IN INTEGER)
IS
BEGIN
   get_total;

EXCEPTION
   WHEN OTHERS
   THEN
      NULL;
END disptot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that the keywords IN and INTEGER are automatically uppercased by PLVgen. This package makes use of the <KBD
CLASS="command"
>PLVcase.string</KBD
> program to convert the case of the parameter list and the executable line of code.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.2.3"
>16.2.2.3 Changing <A
CLASS="indexterm"
NAME="ch16-idx-1000241-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000241-1"
></A
>indentation of generated code</A
></H4
><P
CLASS="para"
>In this final example of the procedure generator, I make use of the indentation parameter to add three spaces to the default three blanks provided by PLVgen. I could then easily cut and paste this text into the body of a package or into the declaration section of a nested, anonymous block.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.usemin
SQL&gt; exec PLVgen.proc ('disptot',indent_in=&gt; 3);
      PROCEDURE disptot
      IS
      BEGIN

      EXCEPTION
         WHEN OTHERS
         THEN
            NULL;
      END disptot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that I use named notation (the =&gt; symbol associating <KBD
CLASS="command"
>indent_in</KBD
> with the value 3) so that I can avoid specifying values for all the other arguments.<A
CLASS="indexterm"
NAME="ch16-idx-1000242-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000242-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.3"
>16.2.3 Generating a Function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000246-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000246-1"
></A
>PLVgen offers seven overloadings of the function generator. Why? Because a function has a RETURN datatype and I want my package to automatically generate functions of the requested type. <KBD
CLASS="command"
>PLVgen.func</KBD
> generates functions with the following datatypes: BOOLEAN, DATE, NUMBER, and VARCHAR2. Four datatypes and seven overloadings...am I leaving something out? Not at all; PLVgen supports four different datatype functions, but provides additional overloadings to handle two kinds of default values for the functions (covered later in this section).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000247-0"
></A
>The format of the function generated by <KBD
CLASS="command"
>PLVgen.func</KBD
> follows my guidelines for a "template" function, the generic structure of which is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION func_name (...) RETURN datatype 
IS
   /* Variable for RETURN */
   return_value datatype;
BEGIN
   &lt;executable statements&gt;
   /* Last line always: */
   RETURN return_value;
EXCEPTION
   WHEN OTHERS
   THEN
      RETURN NULL;
END func_name;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A brief recap of the function template: There is a single RETURN statement in the body of the program and it is the last line of code. There is a local variable (in this case, <KBD
CLASS="command"
>return_value</KBD
>) that is always the same datatype as the function itself and is RETURNed in that single, successful RETURN statement. There is an exception section that returns NULL if something goes wrong.</P
><P
CLASS="para"
>Rather than show the headers for all of the overloadings here and then again in the package specification section, I will show you the header for the string function generator and the headers for the Boolean function generators. All the other nonstring function generators are structured and used like the Boolean version. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.3.1"
>16.2.3.1 Function generator headers</A
></H4
><P
CLASS="para"
>Here is the header for the program that generates a string or VARCHAR2 function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE func
   (name_in IN VARCHAR2,
    datadesc_in VARCHAR2, 
    defval_in IN VARCHAR2 := NULL,
    length_in IN INTEGER := c_def_length,
    incl_exc_in IN BOOLEAN := TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here are the headers for the two programs that generate Boolean functions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE func
   (name_in IN VARCHAR2,
    datadesc_in BOOLEAN, 
    defval_in IN BOOLEAN := NULL,
    incl_exc_in IN BOOLEAN := TRUE);

PROCEDURE func
   (name_in IN VARCHAR2,
    datadesc_in BOOLEAN, 
    defval_in IN VARCHAR2,
    incl_exc_in IN BOOLEAN := TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In all of these programs, the <KBD
CLASS="command"
>name_in</KBD
> is the name of the function, and <KBD
CLASS="command"
>datadesc_in</KBD
> is an expression or value that is the same datatype as the function you want to generate. The <KBD
CLASS="command"
>defval_in</KBD
> argument provides a default value for the RETURN statement of the function. Notice that this is the only parameter that is different for the two overloaded Boolean function generators. In one case, the default value is a Boolean. In the second, the default value is a string. This distinction is explained below.</P
><P
CLASS="para"
>When generating a string function, you can also provide (through the <KBD
CLASS="command"
>length_in</KBD
> argument) the length of the VARCHAR2 variable to be declared. The default is provided by the constant <KBD
CLASS="command"
>c_def_length</KBD
> and is set to 100.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>incl_exc_in</KBD
> argument indicates whether or not an exception section should be included in the function. The default is "Yes! Include an exception section!" (and that is a very important thing to do in functions).</P
><P
CLASS="para"
>Now I will explain how to use these and the other function generators. The only information you have to provide to a function generator is the name and the datatype of the function.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.3.2"
>16.2.3.2 Generated function examples</A
></H4
><P
CLASS="para"
>In this first example, I generate a string function named <KBD
CLASS="command"
>full_name</KBD
> simply by providing a string&nbsp;-- any string&nbsp;-- as the second argument.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.func('full_name','a');
   FUNCTION full_name RETURN VARCHAR2
   IS
      retval VARCHAR2(100) := NULL;
   BEGIN
      RETURN retval;

   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN NULL;
   END full_name;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
>  See <A
CLASS="xref"
HREF="ch16_02.htm#ch16-SECT-2.3.2"
>Section 16.2.2, "Generating a Procedure"</A
> for a more complete description of the elements of code that can be included in a generated function.</P
></BLOCKQUOTE
><P
CLASS="para"
>Notice that this function conforms to the template structure described earlier. Based on the datatype of the second argument, PLVgen has automatically determined that the RETURN datatype should be VARCHAR2. It has also declared a local variable with matching datatype and appropriate default value.</P
><P
CLASS="para"
>In the next call to <KBD
CLASS="command"
>PLVgen.func</KBD
>, I generate a Boolean function, this time setting the default value to FALSE and rejecting the use of an exception section.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.func ('valid_account', true, false, FALSE);
   FUNCTION valid_account RETURN BOOLEAN
   IS
      retval BOOLEAN := FALSE;
   BEGIN
      RETURN retval;
   END valid_account;</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000248-0"
></A
>Now I will generate this same function, but instead of providing a literal default value, I pass in a string that contains an expression (and include an exception section):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.func
             ('valid_account', true, 'sysdate &lt; account.start_date');
   FUNCTION valid_account RETURN BOOLEAN
   IS
      retval BOOLEAN := sysdate &lt; account.start_date;
   BEGIN
      RETURN retval;

   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN NULL;
   END valid_account;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since the second argument to <KBD
CLASS="command"
>PLVgen.func</KBD
> was a Boolean and the third a string, the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> runtime engine executed the version of <KBD
CLASS="command"
>func</KBD
> that interprets the default value not as a literal, but as an expression.</P
><P
CLASS="para"
>And that is the reason for the overloading of the two different Boolean function generators. When the default value is a Boolean, that value is applied directly (as a TRUE, FALSE, or NULL) to the local variable declaration. If the default is a string, that string becomes the <EM
CLASS="emphasis"
>unevaluated</EM
> expression used as the default value for the local variable.</P
><P
CLASS="para"
>The function generators for dates and numbers are overloaded and work in the same way as the Boolean procedures do. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.3.3"
>16.2.3.3 Default values for string functions </A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000249-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000249-1"
></A
>PLVgen provides two distinct overloadings for Boolean, date, and number function generators to handle literals and expressions for default values. This same approach is not possible for the procedure that generates string functions. The way <KBD
CLASS="command"
>PLVgen.func</KBD
> supports expressions for default values is that they are passed as strings. But since the default value for a string function is already a string, another overloaded version with a default value of datatype VARCHAR2 to handle string expressions would simply not work.</P
><P
CLASS="para"
>A different approach is required for the string function generator. There is just one version of <KBD
CLASS="command"
>func</KBD
> to generate string functions, but the following special rule applies to the default value argument, namely: if the first character of the default value string is an <A
CLASS="indexterm"
NAME="ch16-idx-1000250-0"
></A
>equal sign (<KBD
CLASS="command"
>=</KBD
>), then the string is to be interpreted as an expression. In this case, the value in the string is not evaluated, but simply placed in the default value area for the local variable of the function.</P
><P
CLASS="para"
>Let's look at a couple of examples. In this first call to <KBD
CLASS="command"
>PLVgen.func</KBD
>, I generate a VARCHAR2 function with a default return value of ABC. Notice that since this is a string function, I also specify the maximize length of the return value and request that the function not have an exception section.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.func ('full_name', 'a', 'ABC', 50, FALSE);
   FUNCTION full_name RETURN VARCHAR2
   IS
      retval VARCHAR2(50) := 'ABC';
   BEGIN

      RETURN retval;
   END full_name;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this next call to <KBD
CLASS="command"
>PLVgen.func</KBD
>, I change the default value to prefix the "ABC" with the equal sign. In the resulting declaration of a local variable, the default value is set to the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> identifier named abc, and not to a literal with that value.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.func ('full_name', 'a', '=ABC', 50, FALSE);
   FUNCTION full_name RETURN VARCHAR2
   IS
      retval VARCHAR2(50) := abc;
   BEGIN

      RETURN retval;
   END full_name;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Let's look at an example that involves a more real world use of this expression default value. In the following call to <KBD
CLASS="command"
>PLVgen.func</KBD
>, I create a string function that sets the default value to a package-based constant.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt;  exec PLVgen.func ('full_name', 'a', '=Names.formal_address');
   FUNCTION full_name RETURN VARCHAR2
   IS
      retval VARCHAR2(100) := names.formal_address;
   BEGIN
      RETURN retval;

   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN NULL;
   END full_name;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you ever want to generate a string function with a nonliteral default value, don't forget to prefix the default value string with an equal sign.<A
CLASS="indexterm"
NAME="ch16-idx-1000251-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000251-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.4"
>16.2.4 Generating Get-and-Set Routines</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000252-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000252-1"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000252-2"
></A
>One of the most important of my best practices for package construction is to always hide package data behind a programmatic interface, otherwise known as get-and-set routines. Instead of declaring a variable directly in the specification, you would move that declaration to the body of the package and then build (a minimum of) two programs: a function to retrieve the current value of this variable and a procedure to change the value of the variable.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>gas</KBD
> (get-and-set) procedure of PLVgen generates the get-and-set code needed to hide variables of datatypes VARCHAR2, DATE, NUMBER, and Boolean. The overloading for the <KBD
CLASS="command"
>gas</KBD
> procedure is similar to that of the <KBD
CLASS="command"
>func</KBD
> procedure, which makes sense since <KBD
CLASS="command"
>PLVgen.gas</KBD
> does generate a function, as well as a variable declaration of the correct datatype. There are two versions of <KBD
CLASS="command"
>gas</KBD
> for every datatype <EM
CLASS="emphasis"
>except</EM
> VARCHAR2. For this string datatype, there is only one overloading. The header for the string version of <KBD
CLASS="command"
>gas</KBD
> is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE gas
   (name_in IN VARCHAR2,
    valtype_in VARCHAR2, 
    defval_in IN VARCHAR2 := NULL,
    length_in IN INTEGER := c_def_length);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The header for the NUMBER version of <KBD
CLASS="command"
>gas</KBD
> is shown below. The headers for the other datatypes are exactly the same as for the NUMBER version, except for the datatype of the <KBD
CLASS="command"
>valtype_in</KBD
> and <KBD
CLASS="command"
>defval_in</KBD
> arguments.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE gas
   (name_in IN VARCHAR2,
    valtype_in NUMBER, 
    defval_in IN NUMBER := NULL);

PROCEDURE gas
   (name_in IN VARCHAR2,
    valtype_in NUMBER, 
    defval_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Generally, the first argument provides the name of the variable. The second argument determines the type of the function and the variable being hidden inside the package body. The third argument provides a default value for the variable. When generating a string get-and-set, you can also provide the length of the VARCHAR2 variable to be declared. The default is provided by the constant <KBD
CLASS="command"
>c_def_length</KBD
> and is set to 100.</P
><P
CLASS="para"
>The listing below gives you an idea of the kind of code that is generated by a call to the <KBD
CLASS="command"
>PLVgen.gas</KBD
> procedure. I call the <KBD
CLASS="command"
>PLVgen.useln</KBD
> to turn on line numbers to use as a reference (after turning off all other toggles).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.usemin
SQL&gt; exec PLVgen.useln
SQL&gt; exec PLVgen.gas ('pagesize', 1, 25);
    1
    2    PROCEDURE set_pagesize (pagesize_in IN NUMBER);
    3    FUNCTION pagesize RETURN NUMBER;
    4
    5    v_pagesize NUMBER := 25;
    6
    7    PROCEDURE set_pagesize (pagesize_in IN NUMBER)
    8    IS
    9    BEGIN
   10       v_pagesize := pagesize_in;
   11    END set_pagesize;
   12
   13    FUNCTION pagesize RETURN NUMBER
   14    IS
   15       retval NUMBER := v_pagesize;
   16    BEGIN
   17       RETURN retval;
   18    END pagesize;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Lines 2 and 3 contain the headers for the set and get programs. These should be cut and pasted into the package specification. Line 5 contains the declaration of the variable that is to be protected by the get-and-set programs. This declaration is placed in the body of the package, before any of the program definitions are listed. Lines 7 through 11 contain the definition of the set program. Lines 13 through 18 contain the definition of the get program. Both of these should be cut and pasted into the package body. Notice that even in the simple get function, the template approach is still followed.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.4.1"
>16.2.4.1 Generating a <A
CLASS="indexterm"
NAME="ch16-idx-1000253-0"
></A
>Boolean get-and-set</A
></H4
><P
CLASS="para"
>The naming scheme and structure for programs generated for a Boolean get-and-set is a bit different from that for strings, dates, and numbers. When building a get-and-set around a Boolean variable, you can and should take into account the fact that a user can only set the variable to one of three values (TRUE, FALSE, and NULL). In fact, in many cases, a NULL value is not allowed. If <KBD
CLASS="command"
>PLVgen.gas</KBD
> used the same syntax for Booleans as it does for numbers (see above listing), then the set program would look like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE set_show_changes (show_changes_in IN BOOLEAN);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and this program would be used as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PKG_NAME.set_show_changes (TRUE);
PKG_NAME.set_show_changes (FALSE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>While there is certainly nothing wrong with this style, it strikes me as a cumbersome interface. A much cleaner, more natural style would allow me to call programs like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PKG_NAME.show_changes; -- Set variable to TRUE.
PKG_NAME.noshow_changes; -- Set variable to FALSE.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the very approach taken with the Boolean <KBD
CLASS="command"
>gas</KBD
> procedure. The full set of generated code (specification, variable declaration, and body code) is shown below for a <KBD
CLASS="command"
>show_changes</KBD
> variable:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.gas ('show_changes', true, true);
   PROCEDURE show_changes;
   PROCEDURE noshow_changes;
   FUNCTION show_changesing RETURN BOOLEAN;

   v_show_changes BOOLEAN := TRUE;

   PROCEDURE show_changes
   IS
   BEGIN
      v_show_changes := TRUE;
   END show_changes;

   PROCEDURE noshow_changes
   IS
   BEGIN
      v_show_changes := FALSE;
   END no_show_changes;

   FUNCTION show_changesing RETURN BOOLEAN
   IS
      retval BOOLEAN := v_show_changes;
   BEGIN
      RETURN retval;
   END show_changesing;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice the third program, a function, in the get-and-set routines for a Boolean. This function is the get program and it returns the current value of the Boolean variable. I use the "ing" structure for the name of this function, as in: "Am I currently showing the changes?" PLVgen automatically appends an "ing" to the name of the variable passed in the call to the <KBD
CLASS="command"
>gas</KBD
> procedure. It is smart enough to convert some formats to a readable name. For example, if you request a get-and-set for the <KBD
CLASS="command"
>use_lines</KBD
> variable, <KBD
CLASS="command"
>PLVgen.gas</KBD
> generates a function with this header:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION using_lines RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and if you use <KBD
CLASS="command"
>PLVgen.gas</KBD
> with a variable name <KBD
CLASS="command"
>propose</KBD
>, it generates a function whose header is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION proposing RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>but PLVgen does not pretend to handle all nuances of the infinitely nuanced English language. As a result, variable names like <KBD
CLASS="command"
>show_changes</KBD
> result in a function named <KBD
CLASS="command"
>show_changesing</KBD
> and you will just have to rename it yourself!</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.4.2"
>16.2.4.2 Generating a toggle</A
></H4
><P
CLASS="para"
>A toggle is an on-off switch; it is actually a special case of the Boolean get-and-set routines. The <A
CLASS="indexterm"
NAME="ch16-idx-1000254-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000254-1"
></A
>toggle procedure generates the code required to implement this switch in <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>. </P
><P
CLASS="para"
>The header for toggle is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE toggle (name_in IN VARCHAR2 := NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>name_in</KBD
> is the name of the toggle. If you do not specify a toggle name, the following code is generated:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.usemin
SQL&gt; exec PLVgen.useln
SQL&gt; exec PLVgen.toggle
   PROCEDURE turn_on;
   PROCEDURE turn_off;
   FUNCTION turned_on RETURN BOOLEAN;

   v_onoff BOOLEAN := TRUE;

   PROCEDURE turn_on
   IS
   BEGIN
      v_onoff := TRUE;
   END turn_on;

   PROCEDURE turn_off
   IS
   BEGIN
      v_onoff := FALSE;
   END turn_off;

   FUNCTION turned_on RETURN BOOLEAN
   IS
      retval BOOLEAN := v_onoff;
   BEGIN
      RETURN retval;
   END turned_on;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You have generated, in other words, a generic toggle to turn something off or turn it on. You can also generate more specific toggles by providing a toggle name. If you pass a non-NULL toggle name, the get-and-set code matches those lines of source code generated by a call to <KBD
CLASS="command"
>PLVgen.gas</KBD
> for a Boolean variable.<A
CLASS="indexterm"
NAME="ch16-idx-1000255-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000255-1"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000255-2"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.5"
>16.2.5 Generating Help Stubs</A
></H3
><P
CLASS="para"
>PL/Vision provides a mechanism for delivering online help for your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs (see <A
CLASS="xref"
HREF="ch17_01.htm"
>Chapter 17</A
>). To take advantage of this mechanism you need to (a) put comments with an appropriate format in your source code, and (b) provide an easy way for developers to ask for that help. PLVgen allows you to generate the code and comments to handle both these tasks.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.5.1"
>16.2.5.1 <A
CLASS="indexterm"
NAME="ch16-idx-1000256-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000256-1"
></A
>Generating help text stubs</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>helptext</KBD
><A
CLASS="indexterm"
NAME="ch16-idx-1000257-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000257-1"
></A
> procedure generates a comment stub of the correct format so that the PLVhlp package can find and display the information. The header for <KBD
CLASS="command"
>helptext</KBD
> is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE helptext 
   (context_in IN VARCHAR2 := PLVhlp.c_main);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>context_in</KBD
> is the context or keyword that indicates the topic of the help text. The default value for this context is the main help topic constant from PLVhlp: HELP. </P
><P
CLASS="para"
>You can call <KBD
CLASS="command"
>helptext</KBD
> directly; it is also called by the various program unit generators to include stubs for help text in generated code.</P
><P
CLASS="para"
>To create a stub of help text for the main topic, you would do the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.helptext;
   /*HELP
   Add help text here...
   HELP*/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To create a stub of help text for a different topic, such as KNOWN PROBLEMS, you would execute the following command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.helptext ('known problems');
   /*KNOWN PROBLEMS
   Add help text here...
   KNOWN PROBLEMS*/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can then cut and paste these stubs anywhere in your program definition, add some meaningful help text, and CREATE OR REPLACE the program. Users of the program can then access this text through the <KBD
CLASS="command"
>PLVhlp.show</KBD
> procedure. To make it easier to get at this information, however, you will most likely generate and include a special help procedure in your program unit (if it is a package, anyway). You do this with the <KBD
CLASS="command"
>PLVgen.helpproc</KBD
> program.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.5.2"
>16.2.5.2 Generating a help procedure</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>helpproc</KBD
><A
CLASS="indexterm"
NAME="ch16-idx-1000258-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000258-1"
></A
> procedure generates a program that provides help for a given program unit. The header for <KBD
CLASS="command"
>helpproc</KBD
> is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE helpproc
   (prog_in IN VARCHAR2 := NULL, indent_in IN INTEGER := 0);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>prog_in</KBD
> is the name of the program and <KBD
CLASS="command"
>indent_in</KBD
> is an optional additional indentation. By default the generated code already has an indentation of three spaces. The following SQL*Plus session generates a program to show help text from the specification of the PLVio package.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.helpproc ('s:PLVio');
   PROCEDURE help (context_in IN VARCHAR2 := NULL)
   IS
   BEGIN
      PLVhlp.show ('s:PLVio', context_in);
   END help;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Let's see how you would use <KBD
CLASS="command"
>helpproc</KBD
> to provide help to your users. Suppose you have built a package named <KBD
CLASS="command"
>emp_maint</KBD
>. You want to allow developers to ask for general help on the employee maintenance tasks available. So you first execute <KBD
CLASS="command"
>PLVgen.helptext</KBD
> to create a stub help block:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.helptext;
   /*HELP
   Add help text here...
   HELP*/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You cut and paste this text into the specification of <KBD
CLASS="command"
>emp_maint</KBD
> and add some real text. Then you generate a help program as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.helpproc ('s:emp_maint');
   PROCEDURE help (context_in IN VARCHAR2 := NULL)
   IS
   BEGIN
      PLVhlp.show ('s:emp_maint', context_in);
   END help;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You then cut and paste this program into the body of the package. You must also cut only the header (first line) of the procedure and paste that into the specification of the package. Once the code is recompiled, a user of <KBD
CLASS="command"
>emp_maint</KBD
> can enter the following command to see the associated help text:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec emp_maint.help</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If, by the way, you used <KBD
CLASS="command"
>PLVgen.pkg</KBD
> to generate the first version of the <KBD
CLASS="command"
>emp_maint</KBD
> package, it would come with the help program and help text stubs already in place.<A
CLASS="indexterm"
NAME="ch16-idx-1000259-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000259-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.6"
>16.2.6 Generating a Cursor Declaration</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000260-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000260-1"
></A
>Many of us have gotten pretty good about using consistent indentation and white space for our <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> code. Yet when we come to writing a SQL statement, we abandon any pretense of formatting and disgorge an absolutely <EM
CLASS="emphasis"
>awful</EM
> mish-mash of <SPAN
CLASS="acronym"
>SQL</SPAN
> text into our otherwise orderly procedural logic. I believe that a consistent, readable format for the <SPAN
CLASS="acronym"
>SQL</SPAN
> in our <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs is even more important than a good format for the procedural part of the programs. To help you satisfy my whim, PLVgen provides the <KBD
CLASS="command"
>curdecl</KBD
><A
CLASS="indexterm"
NAME="ch16-idx-1000261-0"
></A
> procedure, which generates the declaration statement for a cursor.</P
><P
CLASS="para"
>The header for <KBD
CLASS="command"
>curdecl</KBD
> is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE curdecl 
   (cur_in IN VARCHAR2,
    ind_in IN INTEGER := 0,
    table_in IN VARCHAR2 := NULL,
    collist_in IN VARCHAR2 := NULL,
    gen_rec_in IN BOOLEAN := TRUE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>cur_in</KBD
> is the name of the cursor, <KBD
CLASS="command"
>ind_in</KBD
> is an additional amount of indentation, <KBD
CLASS="command"
>table_in</KBD
> is the name of the table (or list of tables), and <KBD
CLASS="command"
>collist_in</KBD
> is the list of columns in the SELECT list of the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement. The <KBD
CLASS="command"
>gen_rec_in</KBD
> argument specifies whether or not you want a record declaration to be generated with the cursor.</P
><P
CLASS="para"
>This procedure implements several best practices and naming conventions for cursors: it automatically appends "<KBD
CLASS="command"
>_cur</KBD
>" to the end of the cursor name and        "<KBD
CLASS="command"
>_rec</KBD
>" to the end of the record name. It formats the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement to make it easier to read. It provides a record to go with the cursor as a discouragement against declaring individual variables into which data is then fetched.</P
><P
CLASS="para"
>The more you take advantage of these different arguments, the more likely it is that you will generate a cursor declaration that is very close to being ready for execution. Let's look at some examples.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch16-SECT-2.6.1"
>16.2.6.1 Cursor declaration examples</A
></H4
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Generate a cursor declaration relying on all default parameter values. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.curdecl('emp');
   CURSOR emp_cur
   IS
      SELECT
        FROM
       WHERE
         AND
       ORDER BY ;
   emp_rec emp_cur%ROWTYPE;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Generate a cursor against the order table to select the <KBD
CLASS="command"
>order_id</KBD
> and <KBD
CLASS="command"
>ship_date</KBD
>. Do not generate a record declaration since I am going to use this cursor in a FOR loop.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.curdecl ('orders', 0, 'order', 'order_id, ship_date', FALSE);
   CURSOR orders_cur
   IS
      SELECT order_id, ship_date
        FROM order
       WHERE
         AND
       ORDER BY ;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The backbone of an <SPAN
CLASS="acronym"
>SQL</SPAN
> SELECT statement generated by <KBD
CLASS="command"
>curdecl</KBD
> supplies all the main clauses. You could greatly expand upon the PLVgen package to produce all manner of <SPAN
CLASS="acronym"
>SQL</SPAN
> statements.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.7"
>16.2.7 Generating a "Record Found?" Function</A
></H3
><P
CLASS="para"
>The <KBD
CLASS="command"
>curdecl</KBD
> procedure generates a cursor declaration, which is certainly useful. Yet there are also many common kinds of code fragments and programs that use cursors in specific ways. One example is the "record found?" function. How many times have you written a function to return TRUE if the desired record exists, and FALSE otherwise? </P
><P
CLASS="para"
>PLVgen offers the <KBD
CLASS="command"
>recfnd</KBD
><A
CLASS="indexterm"
NAME="ch16-idx-1000262-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000262-1"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000262-2"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000262-3"
></A
> procedure to generate a version of this "record found?" function that will save you many keystrokes if and when you need this functionality. The header for <KBD
CLASS="command"
>recfnd</KBD
> is, quite simply:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE recfnd (table_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, you provide the name of the table whose contents you wish to check, and <KBD
CLASS="command"
>recfnd</KBD
> does the rest of the work from there.</P
><P
CLASS="para"
>The following session generates a function that returns TRUE if the employee is found, and FALSE otherwise. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.recfnd ('emp');
    1    FUNCTION empexists (empkey_in IN NUMBER) RETURN BOOLEAN
    2    IS
    3       CURSOR emp_cur
    4       IS
    5          SELECT 1
    6            FROM emp
    7           WHERE
    8             AND
    9           ORDER BY ;
   10       emp_rec emp_cur%ROWTYPE;
   11       retval BOOLEAN := FALSE;
   12    BEGIN
   13       OPEN emp_cur;
   14       FETCH emp_cur INTO emp_rec;
   15       retval := emp_cur%FOUND;
   16       CLOSE emp_cur;
   17       RETURN retval;
   18
   19    EXCEPTION
   20       WHEN OTHERS
   21       THEN
   22          RETURN NULL;
   23    END empexists;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that the procedure creates appropriate names for the function, cursor, and record from the table name&nbsp;-- and places that table name into the cursor's query. It follows the template approach for functions, so that you have an exception handler to return a NULL in case of problems and a single RETURN in the body of the function. Sure, you have to change the SELECT statement and the key might not be a NUMBER. Regardless, with a simple cut and paste operation, you have more than twenty lines of consistent, readable code.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.8"
>16.2.8 Generating a Cursor FOR Loop</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000263-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000263-1"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000263-2"
></A
>Another common programming construct for <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> developers is the cursor FOR loop, so it will come as no surprise that PLVgen offers a procedure to generate this loop. The header for the <KBD
CLASS="command"
>cfloop</KBD
> procedure is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE cfloop (table_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You provide the name of the cursor and <KBD
CLASS="command"
>cfloop</KBD
> does the rest. The following SQL*Plus session demonstrates the kind of code generated, in this case for a cursor FOR loop based on the <KBD
CLASS="command"
>dept</KBD
> table.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.cfloop('dept');
   CURSOR dept_cur
   IS
      SELECT *
        FROM dept
       WHERE
         AND
       ORDER BY ;

   &lt;&lt; dept_cur &gt;&gt;
   FOR dept_rec IN dept_cur
   LOOP

   END LOOP dept_cur;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>cfloop</KBD
> procedure does several convenient things for us: it defaults the SELECT list to <KBD
CLASS="command"
>*</KBD
> or all columns. It creates a loop label, which is also applied to the END LOOP statement to improve readability. It <EM
CLASS="emphasis"
>avoids</EM
> declaring the record used by the FOR loop&nbsp;-- an unnecessary and potentially hazardous step often taken by poorly informed <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programmers. </P
><P
CLASS="para"
>You cut and paste the cursor declaration into the declaration section; move the FOR loop itself into the body of the program; put some executable code in the body of the loop; and off you go.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch16-SECT-2.9"
>16.2.9 Generating a Timer Script</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch16-idx-1000264-0"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000264-1"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000264-2"
></A
><A
CLASS="indexterm"
NAME="ch16-idx-1000264-3"
></A
>The PLVtmr package offers an easy-to-use mechanism for timing <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> code execution down to a hundredth of a second. I found that I often used this package to time the performance of the same line or lines of code executed more than once&nbsp;-- in other words, inside a loop. Rather than write these loops again and again, I added a procedure to PLVgen to generate this code for me.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>timer</KBD
> procedure's header is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE timer (plsql_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You provide the line of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> code you want to execute and PLVgen provides a SQL*Plus script as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVgen.timer ('calc_totals;');
   BEGIN
      PLVtmr.set_factor (&amp;1);
      PLVtmr.capture;
      FOR rep IN 1 .. &amp;1
      LOOP
         calc_totals;
      END LOOP;
      PLVtmr.show_elapsed ('MSG');
   END;
   /</PRE
></BLOCKQUOTE
><P
CLASS="para"
>These lines of code should be placed in a file with the <I
CLASS="filename"
>.sql</I
> extension. Change the text in the call to <KBD
CLASS="command"
>show_elapsed</KBD
>, add other lines of code to the body of the loop if desired. Upon execution, you provide the number of iterations (or, in PLVtmr terms, the factor), and the script executes (in this case) the <KBD
CLASS="command"
>calc_totals</KBD
> procedure that number of times. <KBD
CLASS="command"
>PLVtmr.show_elapsed</KBD
> then displays the total elapsed time and the per-execution time as well.<A
CLASS="indexterm"
NAME="ch16-idx-1000265-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch16_01.htm"
TITLE="16.1 Options for Best Practices"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 16.1 Options for Best Practices"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch16_03.htm#ch16-SECT-3.3"
TITLE="16.3 Modifying PLVgen Behavior"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 16.3 Modifying PLVgen Behavior"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>16.1 Options for Best Practices</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>16.3 Modifying PLVgen Behavior</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
