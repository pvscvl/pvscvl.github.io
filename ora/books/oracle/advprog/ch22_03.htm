<HTML
><HEAD
><TITLE
>[Chapter 22] 22.3 Implementing PLVexc</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:32:24Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch22_01.htm"
TITLE="22. Exception Handling"><LINK
REL="prev"
HREF="ch22_02.htm#ch22-SECT-2.1.1"
TITLE="22.2 Application-Specific Exception Packages"><LINK
REL="next"
HREF="part06.htm"
TITLE="VI. Testing Your Knowledge"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch22_02.htm#ch22-SECT-2.1.1"
TITLE="22.2 Application-Specific Exception Packages"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 22.2 Application-Specific Exception Packages"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch22_01.htm"
TITLE="22. Exception Handling"
>Chapter 22<BR>Exception Handling</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part06.htm"
TITLE="VI. Testing Your Knowledge"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: VI. Testing Your Knowledge"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch22-26560"
>22.3 Implementing PLVexc</A
></H2
><P
CLASS="para"
>Now that you have seen how to use the PLVexc plug-and-play component, let's go through the steps I followed to build this package. I will even show you two different stages of development of the package. It is very important for you to understand that while it is important to do it right the first time, it is also very unlikely that you will really and truly get it all correct in that first implementation. I present in this book software that I have massaged and fine-tuned repeatedly over the course of a year. You don't see all the pain, indecision, and transitional bugs of PL/Vision, but&nbsp;-- believe me&nbsp;-- they were there.</P
><P
CLASS="para"
>I learned in the course of building PLVexc that I need to progress through several phases in order to properly design and implement a package component. These phases are:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>Phase 1. Understand the challenge and obstacle.</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The first step I took to construct PLVexc was to understand fully the challenges faced by developers when building exception handlers in their <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs. I have found that the more thoroughly I grasp the problem, the more accurate I will be in providing a solution.</P
></DD
><DT
CLASS="term"
>Phase 2. Research the technical issues.</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>What are all the nuances of exception handling in <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>? What are the gotchas, the no-can-dos? What things are possible, but never before attempted?</P
></DD
><DT
CLASS="term"
>Phase 3. Implement the first version of the package.</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Admit to yourself right up front: this is Version 1.0. It will change radically before you are done. But put something together so you can move on to the next phase.</P
></DD
><DT
CLASS="term"
>Phase 4. Try out the package.</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The only way you can really tell if your approach is sound is to try it out. You will encounter requirements, interface issues, and restrictions you would never have discovered from an abstract or theoretical analysis.</P
></DD
><DT
CLASS="term"
>Phase 5. Experience phase 3 and phase 4 again and again, each time improving your code and your awareness of best practices.</DT
><DD
CLASS="listitem"
><P
CLASS="para"
></P
></DD
></DL
><P
CLASS="para"
>Be prepared to go back and recode your package. You might even throw away the entire implementation and start again. It is far too easy to believe that just because you spent a lot of time writing and debugging your code and it sure looks pretty that it must be <EM
CLASS="emphasis"
>good</EM
>. I try to never think about the hours of coding I have "thrown away." Too painful. Just accept it as part of the process. Be committed to constantly improving and you will eventually end up with something that you like&nbsp;-- and maybe a few others will find useful as well.</P
><P
CLASS="para"
>Let's look at how I applied these phases as I constructed the PLVexc package.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-3.1"
>22.3.1 <A
CLASS="indexterm"
NAME="ch22-idx-999353-0"
></A
>Analyzing the Need</A
></H3
><P
CLASS="para"
>A developer must ask and answer many questions in order to properly bullet-proof an application from the perspective of handling errors. These questions include the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Which exceptions should I trap and handle? How do I handle the different kinds of exceptions that occur in my program?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When should I include a <SPAN
CLASS="acronym"
>WHEN</SPAN
> <SPAN
CLASS="acronym"
>OTHERS</SPAN
> handler? Do I have one at every level or just at the very top or outer block of my program?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When do I need to use the <SPAN
CLASS="acronym"
>EXCEPTION_INIT</SPAN
> pragma to associate error numbers with messages? How can I avoid using the same error number (in the -20NNN range) in different programs across my application? How can I guarantee a consistent set of messages for these errors?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When should I call RAISE_APPLICATION_ERROR rather than simply the <SPAN
CLASS="acronym"
>RAISE</SPAN
> statement to raise an exception?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When I handle an exception, what kind of action should I take? Do I ignore the error and continue, record that the error occurred and then continue, notify the error of the problem, stop execution of the program, reraise the same exception? Will the answer to this question change over time or from program to program?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If I record my errors, do I write the information to a database table or some memory-based structure, such as a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table? What information should I include in the error text? Is all the data I want available from within <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> (consider, for example, how you might determine the name of the program in which an error occurred)? What information will I need in order to do restores and fixes of the data?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If I write error log records to a database table, how do I make sure that the log is saved, but that the transaction I was working on in my application is rolled back (as necessitated by the error)? Remember that if an exception is passed unhandled out of a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block, then all changes to <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> data structures <EM
CLASS="emphasis"
>and</EM
> database tables are rolled back implicitly and automatically.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Will I use the same log table for all of my applications, or should I provide a different log table for each application? Will I then have to create a different program to handle each log table? What should be the structure of the log table?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>How do I write my exception handlers so that when I am in test and debug mode the information is available in one form (such as displayed on the screen), but when the code goes into production that information is redirected? And how, most importantly, can I do this without having to change my code right before it goes into production (which, at least theoretically, would require another round of tests)?</P
></LI
></UL
><P
CLASS="para"
>As you can see, it is very easy to ask lots of questions about exception handling. Some questions yield easy answers. Others require advance planning in application design. Still others are too basic to be answered by any generic package. Before I explore what a package can do for us in this situation, let's first examine the usual solution to these questions and the general perspective taken on exception handling.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-3.2"
>22.3.2 The Usual Solution</A
></H3
><P
CLASS="para"
>The traditional approach taken by a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> based-development effort goes something like this:</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>Step 1.</EM
> Train developers on how to write exception handlers. The training is basic and does not make any effort to teach programmers "best practices." Students and project managers alike are satisfied to have been at least introduced to the technology. And, of course, there isn't time for more advanced training. These people have an application to write!</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>Step 2.</EM
> Develop some basic set of guidelines for displaying and recording errors in the application. In the more sophisticated and experienced organizations, the best developer might actually design a single log table for everyone to use.</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>Step 3.</EM
> Distribute the guideline as little more than a glorified memo. Plead with or demand that the team members follow the standards as laid out in the document. Given the state of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> development and code management utilities, there really isn't any way to enforce the standards.</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>Step 4.</EM
> Unleash the developers. Already behind in the schedule, there is a mad scramble to write the programs. The guidelines are followed, at best, unevenly. It is difficult to find time to remember what is written in a document and even more challenging to find time to write code as suggested. The main thing now is to simply churn out code without obvious points of failure.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.2.1"
>22.3.2.1 The traditional jumble of exception handling</A
></H4
><P
CLASS="para"
>With this traditional solution to exception handling, you end up with exception handlers that look like the following:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHEN NO_DATA_FOUND
THEN
  DBMS_OUTPUT.PUT_LINE 
    ('Calc Totals Failed for ' ||
     v_company_name || ' at ' ||
     v_address1);
  INSERT INTO log_table
    (errcod, errmsg, progname, err_ts)
  VALUES
    (SQLCODE, SQLERRM, 'calc_totals', SYSDATE);
  RAISE;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>or this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHEN OTHERS
THEN
   /* Transaction has failed. */
   ROLLBACK TO trans_start;
   IF SQLCODE = -942
   THEN
      INSERT INTO log_table
        (errcod, errmsg, progname, err_ts)
      VALUES
        (SQLCODE, 'Company table not available', 'add_company', 
         SYSDATE);
   ELSE
      INSERT INTO log_table
        (errcod, errmsg, progname, err_ts)
      VALUES
        (SQLCODE, TO_CHAR (v_company_id), 'add_company', 
         SYSDATE);
   END IF;
   COMMIT;
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.2.2"
>22.3.2.2 Drawbacks of the usual handlers</A
></H4
><P
CLASS="para"
>Let's examine these handlers in more detail. In the first example, I display a message to the user, write a record to the log table, and then reraise the same exception (NO_DATA_FOUND). What are the problems with this handler? I can think of three drawbacks:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Reliance on DBMS_OUTPUT.</EM
><A
CLASS="indexterm"
NAME="ch22-idx-999354-0"
></A
> The hard-coding of the call to DBMS_OUTPUT.PUT_LINE procedure means that this handler sends the message to the screen only if output has been enabled and the host environment recognizes and supports DMBS_OUTPUT. This handler would not, for example, display anything in an Oracle Forms application. The error message, furthermore, will always be displayed when output is enabled. There is no flexibility available when using DBMS_OUTPUT. Finally, the string resulting from the concatenation might be longer than 255 characters, in which case PUT_LINE itself raises the VALUE_ERROR exception.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch22-idx-999355-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999355-1"
></A
><EM
CLASS="emphasis"
>Exposure of log table implementation.</EM
> The structure of the log table is hard-coded into the exception handler. By exposing this level of implementational detail, the programmer makes it very difficult to change or enhance the way information is sent to the log table. This approach also requires every developer to know the structure of the table, from the name of the table and its columns to the type of data passed to each column. Finally, this code assumes that no rollback of a transaction is required and that none will be issued in the future, since such a rollback would also wipe out the insert to the log table.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Experienced developers needed.</EM
> On the one hand, you could argue that the code in that first example is simple enough. On the other hand, you could point out that a developer needs to know about the DBMS_OUTPUT builtin package, the SQLCODE and SQLERRM builtin functions, and the fact that the RAISE statement issued without any exception will reraise the same exception.[<A
CLASS="footnote"
HREF="#ch22-pgfId-999094"
>1</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch22-pgfId-999094"
>[1]</A
> I will make a confession: at the time that I wrote my first book, <CITE
CLASS="citetitle"
>Oracle PL/SQL Programming</CITE
>, I was not aware of this special form of the RAISE statement.</P
></DIV
></BLOCKQUOTE
></LI
></OL
><P
CLASS="para"
>There was more to that block of code than you might have thought at first! Now let's analyze the second example of the traditional exception handler. In this case, the developer was aware of transaction-related issues. The first step performed is a rollback to the savepoint issued at the start of the transaction. An IF statement then checks for a specific error that occurs when the specified table does not exist. The error information is then inserted in the log table. Immediately after the insert, the developer issues a COMMIT so that the log record is preserved. </P
><P
CLASS="para"
>While it is admirable that the developer thought of these issues, the handler still hard-codes and exposes the log table implementation. In addition, it is simply not always possible to issue a COMMIT inside an exception handler. That code assumes that any DML changes made prior to when the savepoint for <KBD
CLASS="command"
>trans_start</KBD
> was issued should be committed. I hope that is the case. More fundamentally, though, it is not at all clear to me that you want every developer in a project writing code that takes such liberty with the transaction integrity. Hard-coding specific errors like the -942 is also very questionable. Just consider how much time was spent (lost?) in writing that code: find the error number for the problem, write the code, test the different cases. </P
><P
CLASS="para"
>And of course these two examples would represent just a small percentage of all the code written in any application of substantial complexity to handle the full range of errors. There must be a better way to handle exceptions!</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-3.3"
>22.3.3 A Package-Based Solution (Version 1)</A
></H3
><P
CLASS="para"
>Let's now examine how a package-based solution can help overcome some of the weaknesses identified in the previous exception sections (the version of PLVexc I will be discussing and presenting may be found in the file <KBD
CLASS="command"
>PLVexc1.spp</KBD
> on the companion disk).</P
><P
CLASS="para"
>Before I dive into developing such a package, it is very important to come up with a set of objectives for the package, as well as an acknowledgment of those issues that the package does not address. My objective for the PLVexc package when I first attempted such a component was to make it easier for developers to handle exceptions in a consistent manner. Most importantly, this meant hiding the implementation of such complexities as writing to a log table, displaying errors to the end user or to the developer (during test mode). In addition, I wanted to provide a mechanism by which individual developers would have to deal with the EXCEPTION_INIT pragma and the -20NNN errors.</P
><P
CLASS="para"
>Specifically, I envisioned a mode of operation in which a developer could handle the NO_DATA_FOUND exception as shown in the previous example with this kind of code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHEN NO_DATA_FOUND
THEN
   PLVexc.handle
      ('calc_totals', 
       SQLCODE,
       PLVexc.c_recNstop,
       SQLERRM);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With PLVexc, the developer calls the generic <KBD
CLASS="command"
>handle</KBD
> program to handle the exception. Arguments passed to <KBD
CLASS="command"
>handle</KBD
> include the name of the program in which the error occurred, the error code, the type of action to be performed (record and then halt). The fourth argument is the error text, in this case the text returned by SQLERRM.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>handle</KBD
> program offers the first glimmer of a declarative approach to exception handling. I ask PLVexc to handle my error. I pass it the necessary information, including a description of the type of action I want taken. I leave it to PLVexc to figure out how best to satisfy my request.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.3.1"
>22.3.3.1 Implementing the generic handler</A
></H4
><P
CLASS="para"
>I relied heavily on top-down design techniques when implementing the <KBD
CLASS="command"
>handle</KBD
> program. Here is the logical flow for <KBD
CLASS="command"
>handle</KBD
>:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If I am recording the exception, write the information to the table.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If I am displaying the exception, show that information on the screen.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Finally, if the developer has requested a halting action, raise an exception.</P
></LI
></UL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch22-idx-999356-0"
></A
><A
CLASS="xref"
HREF="ch22_03.htm#ch22-SECT-3.3.1"
>Example 22.2</A
> shows the conversion of these requirements into <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> code. As you can see, the <KBD
CLASS="command"
>handle</KBD
> program is very short because it relies heavily on private modules. As a result, the code is very readable. For example, after the call to <KBD
CLASS="command"
>set_context</KBD
> (explained below), I can literally <EM
CLASS="emphasis"
>read</EM
> my program as follows: "If I am recording the exception, record the exception. If I am displaying errors, display the exception." and so on. No comments are needed. And, best of all, I don't yet have to know how I am going to implement the different programs. I have deferred that level of detail to a later time.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="plsql-adv-ex-22-2"
>Example 22.2: The Body of the handle Procedure </A
></H4
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE handle
   (context_in IN VARCHAR2,
    err_code_in IN INTEGER,
    handle_action_in IN VARCHAR2,
    string_in IN VARCHAR2 := SQLERRM)
IS
BEGIN
   set_context (context_in, err_code_in, string_in);

   IF recording_exception (handle_action_in)
   THEN
      record_exception;
   END IF;

   IF showing
   THEN
      display_exception;
   END IF;

   raise_exception (handle_action_in);      
END;</PRE
></BLOCKQUOTE
></DIV
><P
CLASS="para"
>Well, not all that much later. Let's take a look now at each of the modules called within <KBD
CLASS="command"
>handle</KBD
>. We have:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>set_context</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>recording_exception</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>record_exception</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>display_exception</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>raise_exception</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.3.2"
>22.3.3.2 Setting the context</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>set_context</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999357-0"
></A
> procedure is a private module; it does not appear in the package specification. This procedure copies the arguments provided in the call to <KBD
CLASS="command"
>handle</KBD
> to "current exception" private variables, declared as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Current exception information. */
curr_err_code PLVexc_log.code%TYPE;
curr_context VARCHAR2(100);
curr_err_info PLVexc_log.text%TYPE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>PLVexc_log</KBD
> table is the structure used to hold the log of errors written from the PLVexc package.</P
><P
CLASS="para"
>I then reference these package variables in all of my other private modules that handle calls. By taking this approach, I avoid having to pass these values over and over again as parameters to these programs. You might be tempted to argue that I am writing less structured code since I am switching from parameters to package "globals." That would be true if all of my code and variables were not contained inside a single package. Package-level data such as <KBD
CLASS="command"
>curr_err_code</KBD
> does function like global data, but since it is declared in the body of the package I have control over references to and values in that data. Consequently, I do not incur the same risk of side effects as one usually does with nonparameterized references to global data.</P
><P
CLASS="para"
>Once I have set the context variables, I can move on to the substance of <KBD
CLASS="command"
>handle</KBD
>. Next task: record the exception&nbsp;-- if the user has requested this action.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.3.3"
>22.3.3.3 Recording the exception</A
></H4
><P
CLASS="para"
>I created a Boolean function to return TRUE if the <KBD
CLASS="command"
>handle</KBD
> action is a record action, FALSE otherwise, shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION <A
CLASS="indexterm"
NAME="ch22-idx-999358-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999358-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999358-2"
></A
>recording_exception 
   (handle_action_in IN VARCHAR2)
   RETURN BOOLEAN
IS
BEGIN
   RETURN UPPER (handle_action_in) LIKE 'R%' AND
          logging;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There isn't much to this function; it is designed to encapsulate the logic by which I decide if the current exception should be logged. There are two parts to this decision:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Has the user passed a record action in the call to <KBD
CLASS="command"
>handle</KBD
>?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Has the user turned on logging?</P
></LI
></OL
><P
CLASS="para"
>As you can see from the code for <KBD
CLASS="command"
>recording_exception</KBD
>, a record action is one that starts with R. The <KBD
CLASS="command"
>c_recNgo</KBD
> constant is set to RC. The <KBD
CLASS="command"
>c_recNstop</KBD
> constant is set to RH. Notice that this rule is not stated or applied anywhere outside of the <KBD
CLASS="command"
>recording_exception</KBD
> function. It is a level of detail that would be hard (and a waste of brain cells) to remember.</P
><P
CLASS="para"
>The other aspect to returning TRUE from this function is the call to logging. We now see the toggle coming into use. If the user has called the <KBD
CLASS="command"
>nolog</KBD
> procedure to turn off logging, the <KBD
CLASS="command"
>logging</KBD
> function returns FALSE, which means that <KBD
CLASS="command"
>recording_exception</KBD
> will return FALSE, which means that the <KBD
CLASS="command"
>record_exception</KBD
> program will not execute. Notice that even inside the body of PLVexc I do not make a direct reference to the <KBD
CLASS="command"
>log_flag</KBD
> variable. Instead, I always work through the programmatic interface.</P
><P
CLASS="para"
>If <KBD
CLASS="command"
>recording_exception</KBD
> does return TRUE, I call the <KBD
CLASS="command"
>record_exception</KBD
> procedure. This program encapsulates or hides the details involved in writing to the log table and is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE record_exception
IS
BEGIN
   INSERT INTO PLVexc_log
      (context, code, text, create_ts)
   VALUES
      (curr_context, curr_err_code, 
       curr_err_info, SYSDATE);
EXCEPTION
   WHEN OTHERS THEN NULL;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The procedure is nothing more than an INSERT statement based on the current error variables assigned in the <KBD
CLASS="command"
>set_context</KBD
> program.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.3.4"
>22.3.3.4 Displaying the exception</A
></H4
><P
CLASS="para"
>Once the error is recorded (or ignored), I display the exception if so requested. In this case, I check the value returned by showing (see &quot;plsql-adv-ex-22-2&quot;; this is the second application of the toggle inside the package). If TRUE, I call the <KBD
CLASS="command"
>display_exception</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999359-0"
></A
> procedure, which deals with all the niceties of constructing a string for display with DBMS_OUTPUT.PUT_LINE:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE display_exception IS
BEGIN
   DBMS_OUTPUT.PUT_LINE
      (curr_context || ' Code ' || 
       TO_CHAR (curr_err_code));

   DBMS_OUTPUT.PUT_LINE 
      (SUBSTR (curr_err_info, 1, 255));
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that I perform a SUBSTR on the error information before I pass it to the DBMS_OUTPUT.PUT_LINE procedure. A longer string causes a VALUE_ERROR exception; that is just one of the complications when using the builtin package directly. In version 2 of PLVexc, I rely instead on <KBD
CLASS="command"
>PLVprs.display_wrap</KBD
> to automatically wrap the longer strings into a paragraph format.<A
CLASS="indexterm"
NAME="ch22-idx-999360-0"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.3.5"
>22.3.3.5 Responding to the exception action</A
></H4
><P
CLASS="para"
>When I have finished with recording and displaying errors, as directed by the user, it is time to respond to the <KBD
CLASS="command"
>handle</KBD
> action. I do this with the <KBD
CLASS="command"
>raise_exception</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999361-0"
></A
> procedure, the last line in the handle body, shown in full in <A
CLASS="xref"
HREF="ch22_03.htm#ch22-SECT-3.3.1"
>Example 22.3</A
>. In this case, I have moved all the conditional logic ("should I raise an exception and how?") to the body of the private module. First, I check to see if the action (the only argument to <KBD
CLASS="command"
>raise_exception</KBD
>) is a "continue action" (<KBD
CLASS="command"
>c_go</KBD
> or <KBD
CLASS="command"
>c_recNgo</KBD
>). If so, I do nothing by executing NULL&nbsp;-- I do <EM
CLASS="emphasis"
>not</EM
> want to raise an exception if the developer has asked that the process simply continue.</P
><P
CLASS="para"
>On the other hand, if the developer has specified a "halt action" (<KBD
CLASS="command"
>c_stop</KBD
> or <KBD
CLASS="command"
>c_recNstop</KBD
>), I get to perform an additional service for the user of PLVexc: if the error code is between -20,000 and -20,999 (notice the BETWEEN statement that references the minimum and maximum error code constants), then <KBD
CLASS="command"
>raise_exception</KBD
> automatically makes use of the RAISE_APPLICATION_ERROR builtin to raise the exception. Otherwise, the normal RAISE statement is used with the special <KBD
CLASS="command"
>process_halted</KBD
> exception. In either case, an exception is propagated out of PLVexc, causing the enclosing block to halt, as was requested.</P
><P
CLASS="para"
>This feature of PLVexc transfers the burden of having to figure out "which way to raise" from individual developers (some of whom may be novices who are not even aware of RAISE_APPLICATION_ERROR) to the package. If, as I discuss below, you create an application-specific error handling package that contains predefined error numbers and exceptions for codes in the -20NNN range, a developer may not even know that she has raised an error that requires the RAISE_APPLICATION_ERROR builtin. Since PLVexc automatically determines the appropriate raise mechanism, that is one more complexity of which developers can remain blissfully ignorant.</P
><P
CLASS="para"
>Notice that no single program in PLVexc is more than 20 lines in length. Complex steps and expressions are separated and encapsulated behind named elements (variables, procedures, and functions). The result is a package body that looks simplistic, and one which (I hope) makes my readers say to themselves: "Jeez, I can do <EM
CLASS="emphasis"
>that</EM
>!" It is true; you can build packages like this. First, you just need to adopt an impulse to your work that generates the initial ideas (roughly: I can and will improve my environment). Second, you must be fanatically devoted to writing tight, modular code.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="plsql-adv-ex-22-3"
>Example 22.3: The raise_exception Procedure </A
></H4
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE raise_exception 
   (handle_action_in IN VARCHAR2)
IS
BEGIN
   IF handle_action_in = c_go OR 
      handle_action_in = c_recNgo
   THEN
      NULL;
   ELSIF handle_action_in = c_stop OR 
         handle_action_in = c_recNstop
   THEN
      IF curr_err_code 
         BETWEEN min_err_code AND max_err_code
      THEN
         RAISE_APPLICATION_ERROR 
            (curr_err_code, curr_err_info);
      ELSE
         RAISE process_halted;
      END IF;
   END IF;
END;</PRE
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.3.6"
>22.3.3.6 Finding new uses for PLVexc</A
></H4
><P
CLASS="para"
>PLVexc Version 1.0 is so easy to use and so useful that I find myself applying it to other purposes as well. Two realizations ushered in this new phase:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>PLVexc provides a mechanism for writing a message to a table. This could be used for auditing and logging of <EM
CLASS="emphasis"
>any</EM
> information, not simply errors.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I don't have to call <KBD
CLASS="command"
>PLVexc.handle</KBD
> from within an exception handler. I could call it any time I want to write information out to a table for future analysis.</P
></LI
></OL
><P
CLASS="para"
>Suppose that I want to trace the progress of a data transformation and migration job. I find that I can use <KBD
CLASS="command"
>PLVexc.handle</KBD
> to write a message out to a table after every 100 transactions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR upc_rec IN upc_cur
LOOP
   transform_upc (upc_rec.upc);
   migrate_upc (upc_rec.upc);
   IF MOD (upc_cur%ROWCOUNT, 100) = 0
   THEN
      PLVexc.handle
         ('transmigr', 0, 
          PLVexc.c_recNgo,
          upc_rec.upc, upc_rec.description);
   END IF;
END LOOP;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This works wonderfully, and can be seen as a validation of the architecture of the PLVexc package. Difficulty arises, however, when I want to examine the contents of the exception log. Since I am now using it for multiple purposes, I have to distinguish between error records and trace records. In addition, I discover that I may want to record my errors without also recording my trace. Since I am using the same package with the same toggles, however, it's all or nothing&nbsp;-- never a good situation for a developer.</P
><P
CLASS="para"
>I also become uncomfortable with using an exception handler package as a trace mechanism. It's very convenient, but it is also, strictly speaking, outside of the scope of the original package. That fact should set a red flag waving before your eyes. This adaptation of PLVexc is akin to raising an exception to perform a conditional branching in your program. You can make it work, but all it really does is sow confusion and create maintenance/enhancement nightmares.</P
><P
CLASS="para"
>When you find yourself using programs in ways different from those originally intended, you should perform some analysis and figure out if this use is justified. If not, change your code to a more straightforward implementation.</P
><P
CLASS="para"
>In the case of PLVexc, such an analysis yields the realization that I am much better off separating my logging code from my exception handling code. Logging of errors is just one special case of all my logging needs. Tracing code execution is another special case. I am able to adapt PLVexc to meet my other needs, but a better long-term solution would be to create a logging package that can be called by PLVexc and by my trace programs.</P
><P
CLASS="para"
>And so, after my lengthy development cycle for PLVexc, I come to the conclusion that I should rework the internals of the package. Should I be depressed by this development? Not at all. I have learned, over my years of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> development, that while I should make every effort to do it right the first time, it is also absolutely impossible to get it right the first time. "Right" is a moving target based more on philosophy than on requirements.</P
><P
CLASS="para"
>As long as I apply my guidelines for best practices at each stage of development, I am certain that my programs will be both immediately useful and easily enhanced to meet future needs. This first version of PLVexc offers a significant improvement over business-as-usual methods for exception handling. That fact does not stop me, however, from crafting yet another version of PLVexc that is much more powerful and easy to use. <A
CLASS="indexterm"
NAME="ch22-idx-999362-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-3.4"
>22.3.4 <A
CLASS="indexterm"
NAME="ch22-idx-999363-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999363-1"
></A
>Revamping the PLVexc Package</A
></H3
><P
CLASS="para"
>Rather than proceed step-by-step through the implementation of the current version of PLVexc (which is included on the companion disk), I will discuss the ways in which I used other packages of PL/Vision to enhance PLVexc. I will then examine the impact of these changes in specific areas of PLVexc.</P
><P
CLASS="para"
>I found (as explored in previous sections) that PLVexc actually combined functionality from (what should have been) several different packages. The "final" version of PLVexc makes use of the following packages:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>PLVmsg </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Instead of hard-coding the text for messages with a call to SQLERRM or displaying the passed-in string, PLVexc calls the <KBD
CLASS="command"
>PLVmsg.text</KBD
> function. This program offers a much more flexible and centralized means of storing and providing message text.</P
></DD
><DT
CLASS="term"
>PLVlog</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The PL/Vision logging package is used both to perform rollbacks, if necessary, and to write error information to the log.</P
></DD
><DT
CLASS="term"
>PLVtab</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>PLVtab provides the table used to maintain the list of bailout errors.</P
></DD
><DT
CLASS="term"
>PLVprs</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The <KBD
CLASS="command"
>PLVprs.display_wrap</KBD
> program replaces a call to DBMS_OUTPUT.PUT_LINE with a much more interesting and powerful paragraph-wrapping mechanism. You can now view long lines of error text with ease.</P
></DD
><DT
CLASS="term"
>PLVtrc</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The trace package is used to maintain an execution stack. This stack can be used to automatically provide the name of the current program, avoiding the need to hard-code this value in the call to the exception handler.</P
></DD
></DL
><P
CLASS="para"
>By plugging all of the appropriate elements of PL/Vision into the PLVexc environment, I was able to change that package rapidly into a much more powerful and flexible component. Let's look at how I used PLVlog to greatly enhance the logging capability of PLVexc.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.4.1"
>22.3.4.1 <A
CLASS="indexterm"
NAME="ch22-idx-999364-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999364-1"
></A
>Leveraging PLVLog </A
></H4
><P
CLASS="para"
>In the first version of PLVexc, my local <KBD
CLASS="command"
>record_exception</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999365-0"
></A
> procedure contained a hard-coded INSERT statement to a specific table. In the PL/Vision version of PLVexc, I replace that INSERT statement&nbsp;-- indeed, that entire local module&nbsp;-- with a call to PLVlog as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF recording_exception (handle_action_in)
THEN
   PLVlog.put_line 
      (context_in, err_code_in, msg_in, USER,
       rb, TRUE);
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>rb</KBD
> is the function that returns the current "rollback to" behavior for exception handling and TRUE indicates that this call to <KBD
CLASS="command"
>put_line</KBD
> should override the current logging status. This means that even if logging is turned off outside of PLVexc, you will still be able to log your error information.</P
><P
CLASS="para"
>With this simple substitution, I have accomplished the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Disconnected the exception-handling component from a logging capability. If you want to log information that is not an error, you can do so directly with the PLVlog package. You do not have to tweak PLVexc to coincidentally provide this functionality.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Greatly increased the logging capability of PLVexc. Since I am now using PLVlog, my exception logging is no longer restricted to simply writing to a database table. I can log to my choice of database table, <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, standard output, and string. And as new options appear and are integrated into PLVlog, those options become instantly available to PLVexc as well.</P
></LI
></UL
><P
CLASS="para"
>A similar kind of improvement is achieved for showing the error (turned on with a call to <KBD
CLASS="command"
>PLVexc.show</KBD
>). Instead of simply calling DBMS_OUTPUT.PUT_LINE in my <KBD
CLASS="command"
>display_exception</KBD
> program, I can instead call the <KBD
CLASS="command"
>PLVprs.display_wrap</KBD
> so that very long text messages can be displayed in full in wrapped format. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-3.4.2"
>22.3.4.2 Implementing the high-level handlers</A
></H4
><P
CLASS="para"
>The most far-reaching and interesting aspects of the evolution of PLVexc are the high-level handlers. I find it satisfying to be able to type something as simple as:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVexc.<A
CLASS="indexterm"
NAME="ch22-idx-999366-0"
></A
>recNgo;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and have prebuilt code automatically determine the current program, error number, error message, and everything else I need to record that error and then continue.</P
><P
CLASS="para"
>You have already seen the headers for these high-level handlers and learned about the difficulties of tracking the current program in <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>. Now let's go inside the PLVexc package to see how I implemented these handlers.</P
><P
CLASS="para"
>There are a total of eight high-level handlers, with overloadings for string and integer versions for each different action. As you can well imagine, the code that needs to be executed within each of these handlers is very similar. I found, in fact, that the only difference is the action requested and the input (message or error code). Consequently, I built a <EM
CLASS="emphasis"
>private</EM
> procedure (it does not appear in the package specification) that is called by all the high-level handlers. I named this program <KBD
CLASS="command"
>terminate_and_handle</KBD
> for reasons that will be clear in a moment and called it in my <KBD
CLASS="command"
>recNgo</KBD
> handlers as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE recNgo (msg_in IN VARCHAR2 := NULL)
IS
BEGIN
   terminate_and_handle (c_recNgo, msg_in);
END;

PROCEDURE recNgo (err_code_in IN INTEGER)
IS
BEGIN
   <A
CLASS="indexterm"
NAME="ch22-idx-999367-0"
></A
>terminate_and_handle (c_recNgo, err_code_in);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A few things to notice: first, if you do not provide an argument when you call <KBD
CLASS="command"
>recNgo</KBD
>, PLVexc executes the string version, which means that it records the value returned by SQLCODE as the error. Second, I call <KBD
CLASS="command"
>terminate_and_handle</KBD
> in each of these two overloaded procedures&nbsp;-- so <KBD
CLASS="command"
>terminate_and_handle</KBD
> must also be overloaded. Here, in fact, is the body of the code behind the two versions of <KBD
CLASS="command"
>terminate_and_handle</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE terminate_and_handle
   (action_in IN VARCHAR2,
    msg_in IN VARCHAR2 := NULL)
IS
BEGIN
   PLVtrc.terminate;
   handle (PLVtrc.prevmod, SQLCODE, action_in, 
       NVL (msg_in, PLVmsg.text (SQLCODE)));
END;

PROCEDURE terminate_and_handle
   (action_in IN VARCHAR2, 
    err_code_in IN INTEGER)
IS
BEGIN
   PLVtrc.terminate;
   handle 
      (PLVtrc.prevmod, err_code_in, action_in, 
       PLVmsg.text (err_code_in)); 
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can probably see how I came up with the name for this private procedure. It does only two things: first, it calls <KBD
CLASS="command"
>PLVtrc.terminate</KBD
> to remove the current program from the PLVtrc-managed execution stack. Second, it calls that good old, low-level handler program to handle the error according to the information provided to it from various sources. It obtains the context from the <KBD
CLASS="command"
>PLVtrc.prevmod</KBD
> function (this returns the previous module, since the call to <KBD
CLASS="command"
>PLVtrc.terminate</KBD
> has already popped the execution call stack). This convoluted approach was necessary because I couldn't wait to do the terminate after the call to handle. That program might raise an exception!</P
><P
CLASS="para"
>If I have called the string version of a high-level handler and, hence, the string version of <KBD
CLASS="command"
>terminate_and_handle</KBD
>, I rely on SQLCODE to retrieve the error, but then pass the input string as the error text (unless it is NULL). If I have called an integer version of the handler, that value is used as the error code. That same number is also passed to <KBD
CLASS="command"
>PLVmsg.text</KBD
> to retrieve the text for that error.</P
><P
CLASS="para"
>Again, by leveraging all of these other PL/Vision packages, I can actually simplify the code required in my handlers, but end up with a much more robust implementation. <A
CLASS="indexterm"
NAME="ch22-idx-999368-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999368-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999368-2"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999368-3"
></A
></P
><P
CLASS="para"
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch22_02.htm#ch22-SECT-2.1.1"
TITLE="22.2 Application-Specific Exception Packages"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 22.2 Application-Specific Exception Packages"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part06.htm"
TITLE="VI. Testing Your Knowledge"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: VI. Testing Your Knowledge"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>22.2 Application-Specific Exception Packages</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>VI. Testing Your Knowledge</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
