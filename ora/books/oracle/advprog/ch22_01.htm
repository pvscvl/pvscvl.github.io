<HTML
><HEAD
><TITLE
>[Chapter 22] Exception Handling</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:31:48Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part05.htm"
TITLE="V. Plug-and-Play Packages"><LINK
REL="prev"
HREF="ch21_02.htm#ch21-SECT-2.1"
TITLE="21.2 PLVtrc: Tracing Execution of PL/SQL Programs"><LINK
REL="next"
HREF="ch22_02.htm#ch22-SECT-2.1.1"
TITLE="22.2 Application-Specific Exception Packages"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch21_02.htm#ch21-SECT-2.1"
TITLE="21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 22</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch22_02.htm#ch22-SECT-2.1.1"
TITLE="22.2 Application-Specific Exception Packages"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 22.2 Application-Specific Exception Packages"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="plsql-adv-ch-22"
>22. Exception Handling</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch22-26576"
TITLE="22.1 The Challenge of Exception Handling"
>The Challenge of Exception Handling</A
><BR><A
CLASS="sect1"
HREF="ch22_02.htm#ch22-SECT-2.1.1"
TITLE="22.2 Application-Specific Exception Packages"
>Application-Specific Exception Packages</A
><BR><A
CLASS="sect1"
HREF="ch22_03.htm#ch22-SECT-3.3.1"
TITLE="22.3 Implementing PLVexc"
>Implementing PLVexc</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch22-idx-999284-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999284-1"
></A
>The PLVexc (PL/Vision EXCeption handling) package provides a powerful, plug-and-play component to perform exception handling in your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs. It makes use of PLVlog to automatically write errors to the log of your choice (database table, <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, etc.). It offers high-level exception handler programs so that individual developers can simply call a procedure that describes the desired action, such as "record and continue," and PLVexc figures out what to do.</P
><P
CLASS="para"
>This chapter first analyzes the need for exception handling and the traditional solutions in a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> environment. It then presents the elements of the PLVexc package, along with the information you need to apply this functionality in your own programs. Finally, the chapter explores the implementation of PLVexc in two phases.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch22-26576"
>22.1 The Challenge of Exception Handling</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch22-idx-999285-0"
></A
>Do you test your own programs? If you do, I am willing to wager large sums of money that your users feel as if <EM
CLASS="emphasis"
>they</EM
> are the ones doing the testing. Authors of a program cannot find all the bugs in their software. They have, in fact, an uncanny ability to unconsciously follow a path through their code that avoids all bugs and logical holes.Programmers cannot be responsible for testing their own code.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch22-idx-999286-0"
></A
>Tightly linked to proper testing is proper error handling. Even if a program does not have actual bugs, it does need to handle abnormal conditions gracefully. Yet exception handling is the last thing any of us wants to worry about when we build our <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs. To recognize the need to write exception handlers is to acknowledge that things might go wrong. Who can afford the time and resources to focus on the negative? It is all we can do to get our programs to work properly under normal circumstances&nbsp;-- to conform, in other words, to the specifications. How many times do you hear others (never yourself, right?) say things like this: "After I get my program to work, I'll go back and put in the exception handlers." Of course, no one ever has the time to "go back." </P
><P
CLASS="para"
>Anticipating and handling the problems in one's program is crucial to writing a robust application. <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> offers a very powerful architecture for dealing with abnormal conditions: the exception section and exception handlers. Yet this architecture can also be difficult to use, particularly in a manner that ensures consistent error handling across an entire application. This difficulty, combined with the importance of getting it right, makes exception handling an excellent candidate for the use of a plug-and-play component.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.1"
>22.1.1 A Package-Based Solution</A
></H3
><P
CLASS="para"
>A plug-and-play component, based in <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> package technology, can hide the complexities and difficulties of exception handling. It can provide a declarative interface to both responding to and logging problems encountered in an application. With this declarative approach, programmers can, in the exception section, state what they want the program to do and leave it to the underlying engine (the package) to figure out how to get the job done. This is very similar to the theory and practices of the <SPAN
CLASS="acronym"
>SQL</SPAN
> language.</P
><P
CLASS="para"
>To give you a taste of what is possible, the following exception section has two different exception handlers: one for NO_DATA_FOUND and one for all other exceptions. When NO_DATA_FOUND is raised, a message is displayed to the user, the error is recorded, and then the program is halted. When any other error occurs, that error is recorded and then processing continues.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      PLVexc.recNstop ('Company has not been located.');
   WHEN OTHERS
   THEN
      PLVexc.recNgo;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Both of these exception handlers make use of the PLVexc package. This package automatically records the current program, user, error number, and message. It relies on the PLVlog package so that the recording can take place to a database table or to a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table. It performs rollbacks to the last savepoint if requested so that the current transaction is "erased," but the write to the log table is preserved. </P
><P
CLASS="para"
>There is, in other words, a lot going on when a developer makes a simple, high-level call to a PLVexc error handling procedure. Yet all that activity is rendered invisible by the package. All the user of PLVexc has to know is what kind of action he wants to perform. Ignore the error? Record and continue? Record and halt? Just tell PLVexc what it is you want to do and let the component do the rest.</P
><P
CLASS="para"
>The PLVexc package is the best example in PL/Vision of a plug-and-play component, prebuilt code you can plug into your own programs, instantly improving the functionality, reliability, and flexibility of your own applications. In this chapter, I'll first show you how to use PLVexc. Then I'll present the implementation of PLVexc in two stages: the first version I built and the second, "final" version of the package you will find on the disk.</P
><P
CLASS="para"
>I show you the two stages of development and design of PLVexc so that you can follow the thought process I used to move from a specific problem to an increasingly generalized solution. Learning how to use PLVexc in your environment is important, but even more important and more difficult is to develop your own analytical and programming skills so that you can build your own plug-and-play package-based components.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.2"
>22.1.2 Package-Based Exceptions</A
></H3
><P
CLASS="para"
>The PLVexc package provides several predefined exceptions for you to use and also to provide a model for adding additional exceptions in the same way to PLVexc. These exceptions are:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><A
CLASS="indexterm"
NAME="ch22-idx-999287-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999287-1"
></A
>NO_SUCH_TABLE</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>ORA-00942: table or view does not exist</P
></DD
><DT
CLASS="term"
><A
CLASS="indexterm"
NAME="ch22-idx-999288-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999288-1"
></A
>SNAPSHOT_TOO_OLD</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>ORA-01555: snapshot too old (rollback segment too small)</P
></DD
></DL
><P
CLASS="para"
>A third exception, <KBD
CLASS="command"
>process_halted</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999289-0"
></A
>, is used in the bailout feature and is discussed later in this chapter.</P
><P
CLASS="para"
>The code required to declare these exceptions is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>no_such_table EXCEPTION;
PRAGMA EXCEPTION_INIT (no_such_table, -942);

snapshot_too_old EXCEPTION;
PRAGMA EXCEPTION_INIT (snapshot_too_old, -1555);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Why does PLVexc predefine these exceptions (and invite you to add more)? So every developer in your organization does not have to take these steps over and over again. Specifically, to achieve:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Consistent error handling in the application:</EM
> developers will not define their own named exceptions willy-nilly throughout their programs. They make use of existing names for exceptions. Instead of coding their own handlers for WHEN OTHERS, they can use the prebuilt program, <KBD
CLASS="command"
>display_error</KBD
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Less buggy code:</EM
> Novice and intermediate programmers do not have to deal with the EXCEPTION_INIT pragma and other complicated issues related to exception handlers. With the package, these details are shielded from the developer.</P
></LI
></UL
><P
CLASS="para"
>Once such exceptions are defined in a package, individual developers no longer need to know about the specific error numbers, nor do they have to be hassled with EXCEPTION_INIT syntax. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.3"
>22.1.3 Impact of <A
CLASS="indexterm"
NAME="ch22-idx-999290-0"
></A
>Predefined Exceptions</A
></H3
><P
CLASS="para"
>Compare the two <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> blocks below. The first demonstrates the kind of code one would have to write without the predefined exceptions as found in PLVexc. </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   no_such_table EXCEPTION;
   PRAGMA EXCEPTION_INIT (no_such_table, -942);
BEGIN
   perform_action;
EXCEPTION
   WHEN no_such_table
   THEN
      do_something;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The second block shows how one's code would look with PLVexc in place:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   perform_action;
EXCEPTION
   WHEN PLVexc.no_such_table
   THEN
      PLVexc.handle 
        ('action', SQLCODE, PLVexc.c_recNstop);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>No declaration section required, no need for the developer to write all that extra code. Just pick from the package-based selections and keep on developing! The benefits of this approach go well beyond short-term productivity gains. If all developers work from this predefined set of exceptions, overall application code volume is reduced, and along with that the number of bugs that are introduced and then tested <EM
CLASS="emphasis"
>out</EM
> of the application. </P
><P
CLASS="para"
>The PLVexc package contains only two predefined exceptions. When you apply this technique into your own environment you will undoubtedly want to add to this section any of the unnamed system exceptions your developers will encounter routinely. And even if you don't think of them all before development begins, you can always add to the set of exceptions as you proceed. Simply set as a guideline for programmers that they never use the EXCEPTION_INIT pragma in their code. Instead, they take the time to add that exception to the package and then reference the package-based exception. </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.4"
>22.1.4 <A
CLASS="indexterm"
NAME="ch22-idx-999291-0"
></A
>Exception Handling Actions</A
></H3
><P
CLASS="para"
>One of the major improvements offered by PLVexc is the ability for a developer to simply state the kind of action needed in a particular exception handler. You can do this in two ways: pass the action as the third argument to the low-level handle procedure or call a high-level handler whose very name encapsulates the action. </P
><P
CLASS="para"
>PLVexc supports four different exception-handling actions. These are presented in the table below, along with the corresponding packaged constants used in the call to handle and the corresponding high-level handler program.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Action</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Constant</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Handler Program</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Description</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Continue processing</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch22-idx-999292-0"
></A
>c_go</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>go</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Continue processing; do not record the error. This is the equivalent of WHEN OTHERS THEN NULL, which means "ignore this error."</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Record and then continue</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch22-idx-999293-0"
></A
>c_recNgo</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>recNgo</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Record the error and then continue processing. This action would be appropriate when the exception affects the current block but is not severe enough to stop the entire session.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Halt processing</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch22-idx-999294-0"
></A
>c_stop</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>stop</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Stop processing; do not record the error. This action causes PLVexc to raise the <KBD
CLASS="command"
>process_halted</KBD
> exception. This action would be appropriate when the exception is so severe (either in terms of the database or the application) that it requires termination of the entire session.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Record and then halt processing</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch22-idx-999295-0"
></A
>c_recNstop</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>recNstop</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Record the error and then</P
><P
CLASS="para"
>stop processing. This action causes PLVexc to raise the <KBD
CLASS="command"
>process_halted</KBD
> exception, as with <KBD
CLASS="command"
>c_stop</KBD
>.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>By providing named constants, users of PLVexc do not have to be aware of the specific literal values used by PLVexc. This advantage is even greater when calling the <KBD
CLASS="command"
>stop</KBD
> or <KBD
CLASS="command"
>recNgo</KBD
> programs. Instead of passing cryptic acronyms, users can rely on named elements to make their code self-documenting and easy to maintain. Most importantly, users do not have to be aware of either how the recording process takes place or how the program is halted. They can just make the request.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.5"
>22.1.5 What About the Reraise Action?</A
></H3
><P
CLASS="para"
>Another kind of action you might want to take is to reraise the same exception that brought you into the exception section. You can do this in <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> by issuing an unqualified <A
CLASS="indexterm"
NAME="ch22-idx-999296-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999296-1"
></A
>RAISE statement, as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN OTHERS 
   THEN
      p.l ('Error code: ', SQLCODE);
      RAISE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this fragment, when any error occurs, I display the error code and then reraise that same error to propagate the exception out to the enclosing block.</P
><P
CLASS="para"
>This is a very useful feature of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> and it seemed only reasonable to implement this action in PLVexc when I encountered this functionality about six months ago (yet another aspect of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> of which I was ignorant when writing <CITE
CLASS="citetitle"
>Oracle PL/SQL Programming</CITE
> ). Eager to please, I spent an hour or two adding the necessary constant, high-level handler and accompanying code. A simplified version of my high-level handler looked like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE reraise
IS
BEGIN
   p.l ('description of error');
   RAISE;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Confident of my new approach, I even put together the following test script to test out my new functionality:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   p.l ('Divide by zero!', 1/0);
EXCEPTION
   WHEN OTHERS
   THEN
      PLVrec.reraise;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Finally, after all of my furious coding, it was time to compile my PLVexc package and run some tests. Imagine my surprise when I received the following compile error on the <KBD
CLASS="command"
>reraise</KBD
> procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLS-00367: a RAISE statement with no exception name must be inside an
           exception</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It turned out that my great idea was a completely <EM
CLASS="emphasis"
>invalid</EM
> idea! You can only issue the unqualified RAISE statement inside an exception section, which makes a whole lot of sense. If you are not inside an exception section, there is no current exception, so the statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>RAISE;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>makes no sense at all. What are you raising? A roof? A stink? I sheepishly deleted all <KBD
CLASS="command"
>reraise</KBD
>-related code from my package. Some <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> guru! </P
><P
CLASS="para"
>The reason I relate this story to you is that it taught me (well, reminded me of) an important lesson: before you embark on building powerful, generic utilities, do the research necessary to prove that your ideas are possible <EM
CLASS="emphasis"
>and</EM
> practical.<A
CLASS="indexterm"
NAME="ch22-idx-999297-0"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.6"
>22.1.6 Handling Errors</A
></H3
><P
CLASS="para"
>Now that you are familiar with the different kind of actions you can request in PLVexc, let's look at the programs you can call to handle your errors. PLVexc provides two levels of handlers. The low-level program, the <KBD
CLASS="command"
>handle</KBD
> procedure, allows (and expects) you to fully specify all the information about the exception in the argument list. The high-level programs rely on a higher level of abstraction, making it easier to use the PLVexc package; PL/Vision automatically figures out the where, what, and when of the problem.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.6.1"
>22.1.6.1 The <A
CLASS="indexterm"
NAME="ch22-idx-999298-0"
></A
>handle procedure</A
></H4
><P
CLASS="para"
>The header for the low-level, generic exception handler program is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE handle
   (context_in IN VARCHAR2,
    err_code_in IN INTEGER,
    handle_action_in IN VARCHAR2,
    string_in IN VARCHAR2 := SQLERRM);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>handle</KBD
> procedure accepts four arguments, which are explained below:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
> context_in</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The context or program in which the error occurred. This is free-form text, but as I explain later in <A
CLASS="xref"
HREF="ch22_02.htm#ch22-SECT-2.1.1"
>Section 22.2, "Application-Specific Exception Packages"</A
>, you want to use named constants to avoid chaos in this area.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
> err_code_in</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch22-idx-999299-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999299-1"
></A
>The error code. You generally pass in the SQLCODE function for this argument, since that shows the current SQL layer error. You can, however, pass any integer, including application-specific errors in the -20NNN range as well.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
> handle_action_in</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The string constant that informs PLVexc of the action you want to take, such as "record and continue" or "halt." The only values you should pass are the PLVexc constants: <KBD
CLASS="command"
>c_go</KBD
>, <KBD
CLASS="command"
>c_recNgo</KBD
>, <KBD
CLASS="command"
>c_stop</KBD
>, or <KBD
CLASS="command"
>c_recNstop</KBD
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
> string_in</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The error message, the default of which is that string returned by the SQLERRM function.</P
></DD
></DL
><P
CLASS="para"
>If your error code falls within the range -20,000 to -20,999 and you request that the program be halted, then PLVexc automatically calls RAISE_APPLICATION_ERROR to raise the error and communicate the error information back to the client program. Otherwise, when you want the program halted, <KBD
CLASS="command"
>PLVexc.handle </KBD
>uses the RAISE statement to raise the <KBD
CLASS="command"
>process_halted</KBD
> exception defined in the package.</P
><P
CLASS="para"
>The various arguments allow developers to handle exceptions in different ways and pass very specific information to the exception-handling component. Let's look at some examples.</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Write an exception handler to detect NO_DATA_FOUND, in which case information about the current record is saved and the application continues.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      PLVexc.handle
         ('getcompany', 
          SQLCODE,
          PLVexc.c_recNgo,
          TO_CHAR (v_company_id));
END;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
>  Remember that logging or displaying must be turned on in order for a "record" request like that shown above to actually have an impact. See <A
CLASS="xref"
HREF="ch22_01.htm"
>Section 22.1.7, "<A
CLASS="indexterm"
NAME="ch22-idx-999310-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999310-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999310-2"
></A
>Recording Errors"</A
> for more information on these features.</P
></BLOCKQUOTE
></LI
></OL
><OL
CLASS="orderedlist"
START="2"
><LI
CLASS="listitem"
><P
CLASS="para"
>Write an exception to detect a failure in the current program and, instead of relying on <SPAN
CLASS="acronym"
>SQLCODE</SPAN
>, pass a -20NNN error number with an accompanying message. This would be necessary if the error occurs inside a database trigger and must be passed back to the client application. </P
></LI
></OL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN OTHERS
   THEN
      PLVexc.handle
         ('check_emp_age',
          -20500,
          PLVexc.c_recNstop,
          'Employee too young: ' || TO_CHAR (:new.birthdate));
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.6.2"
>22.1.6.2 The high-level handlers</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>PLVexc.handle</KBD
> is a significant improvement over writing your own exception-handling code over and over again. Still, it requires that you enter lots of information. You have to provide the current program, the error code, and the action (the error message is optional). Doesn't it seem silly that you would have to tell a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program the name of the program that is currently executing? Shouldn't that information be accessible from <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> itself? And shouldn't the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> runtime engine know about the current error? </P
><P
CLASS="para"
>The answer to all these questions is "yes and no." Yes, the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> runtime engine should know about the current program name and the current errors&nbsp;-- and in many circumstances it does know about this information. Unfortunately (and here's the "no" part), while the DBMS_UTILITY.FORMAT_CALL_STACK does return the active <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> execution stack, it does not tell you which program <EM
CLASS="emphasis"
>inside</EM
> a package is being executed (see <A
CLASS="xref"
HREF="ch21_01.htm"
>Chapter 21, <CITE
CLASS="chapter"
>PLVlog and PLVtrc: Logging and Tracing</CITE
></A
>, for more information on this phenomenon). And it is quite impossible for <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> to know the current error when it is an application-specific problem (you raised a programmer-defined exception).<A
CLASS="indexterm"
NAME="ch22-idx-999300-0"
></A
></P
><P
CLASS="para"
>It is possible, on the other hand, to overcome these complications. Using the PL/Vision message, trace, and exception-handling packages in an integrated fashion, you can greatly simplify the task of providing comprehensive exception handling in your applications. </P
><P
CLASS="para"
>The high-level handler programs of PLVexc hide almost all the details and data needed to respond to and record exceptions. The headers for these handlers are: </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999301-0"
></A
>recNgo (msg_in IN VARCHAR2 := NULL);
PROCEDURE recNgo (err_code_in IN INTEGER);

PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999302-0"
></A
>go (msg_in IN VARCHAR2 := NULL);
PROCEDURE go (err_code_in IN INTEGER);

PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999303-0"
></A
>recNstop (msg_in IN VARCHAR2 := NULL);
PROCEDURE recNstop (err_code_in IN INTEGER);

PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999304-0"
></A
>stop (msg_in IN VARCHAR2 := NULL);
PROCEDURE stop (err_code_in IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that there is a handler name for each action and there are two versions for each action: one that accepts an additional message and one that has an integer argument. If you call a handler with a string, that string is recorded or displayed as the error message. If you pass a string to a high-level handler like <KBD
CLASS="command"
>recNstop</KBD
>, it will use the value returned by the SQLCODE function as the error number, and your string as the error message.</P
><P
CLASS="para"
>If you call a handler with an integer error code, the error message is retrieved from PLVmsg facility based on that numeric code (see <A
CLASS="xref"
HREF="ch22_01.htm"
>Section 22.1.6.4, "<A
CLASS="indexterm"
NAME="ch22-idx-999305-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999305-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999305-2"
></A
>Defining error messages with PLVmsg"</A
>). And those are the only two types of information to pass to PLVexc.</P
><P
CLASS="para"
>What about the action code? With the high-level handlers, the action you want taken has been moved from the parameter list of the program to the very name of the program itself. </P
><P
CLASS="para"
>What about the current program name? You don't provide it in the call. Instead, you define the current program with a call to <KBD
CLASS="command"
>PLVtrc.startup</KBD
> at the beginning of each program unit (see <A
CLASS="xref"
HREF="ch22_01.htm"
>Section 22.1.6.5, "<A
CLASS="indexterm"
NAME="ch22-idx-999307-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999307-1"
></A
>Integrating PLVexc with PLVtrc "</A
>). Can exception handling get any easier than that?</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.6.3"
>22.1.6.3 Using the high-level handlers</A
></H4
><P
CLASS="para"
>Let's look at some examples of using these handlers.</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>When my implicit query retrieves too many rows, I want to simply continue processing. For any other errors, record and halt.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN TOO_MANY_ROWS
   THEN
      PLVexc.go;

   WHEN OTHERS
   THEN
      PLVexc.recNstop;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When my database trigger on the <KBD
CLASS="command"
>emp</KBD
> table detects that the employee is underage, it raises a packaged exception in the -20NNN range. This error number is given a name in the <KBD
CLASS="command"
>empmaint</KBD
> package, which is then passed to the call to <KBD
CLASS="command"
>PLVexc.recNhalt</KBD
> so that this application-specific exception can be registered.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   IF :new.birthdate &gt; ADD_MONTHS (SYSDATE, -216 /* 12 x 18 */)
   THEN
      RAISE empmaint.too_young;
   END IF;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN too_young</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   THEN
      PLVexc.recNhalt (empmaint.en_too_young);
END;</PRE
></BLOCKQUOTE
></LI
></OL
><OL
CLASS="orderedlist"
START="3"
><LI
CLASS="listitem"
><P
CLASS="para"
>When a duplicate value in an index exception is raised, store the current primary key and other unique information for the new company so that you can figure out what went wrong. Then continue with the processing.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>EXCEPTION
   WHEN DUP_VAL_ON_INDEX
   THEN
      PLVexc.recNgo (TO_CHAR (v_comp_id) || '-' || v_comp_nm));
END;</PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.6.4"
>22.1.6.4 <A
CLASS="indexterm"
NAME="ch22-idx-999305-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999305-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999305-2"
></A
>Defining error messages with PLVmsg</A
></H4
><P
CLASS="para"
>There are two scenarios under which PLVexc obtains the text of an error message from the PLVmsg package:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>When you use an integer version of a high-level handler (you pass in an error number).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When you use the string version of a high-level handler, but pass in a NULL string (the default value).</P
></LI
></OL
><P
CLASS="para"
>In both of these cases, the handler calls <KBD
CLASS="command"
>PLVmsg.text</KBD
>, passing it either the value returned by SQLCODE or your own error number, in order to obtain the error text. If the error number is between -20,000 and -20,999, the PLVmsg package tries to get the error message from the text table maintained by the PLVmsg package. Let's look at how you would put all these pieces in place for the trigger discussed in the previous section. I passed the error number <KBD
CLASS="command"
>empmaint.en_too_young</KBD
> in my call to <KBD
CLASS="command"
>recNhalt</KBD
>. Suppose this constant is defined as:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>en_too_young CONSTANT INTEGER := -20033;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>in the <KBD
CLASS="command"
>empmaint</KBD
> package. Then in the initialization section of that package I should also execute the code necessary to store the message for this error in the PLVmsg table. I would do this by issuing a call to <KBD
CLASS="command"
>PLVmsg.add_text</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999306-0"
></A
> procedure as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE BODY empmaint
IS
   en_too_young CONSTANT INTEGER := -20033;

   ... all the code ..

/* The initialization section */
BEGIN
   PLVmsg.add_text 
      (en_too_young,</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>       'Employee must be at least 18 years old.');   
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In fact, for every error number defined in the package, I would need a call to <KBD
CLASS="command"
>PLVmsg.add_text</KBD
> to make that string accessible through the PLVmsg interface and, thus, to the PLVexc handler programs.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.6.5"
>22.1.6.5 <A
CLASS="indexterm"
NAME="ch22-idx-999307-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999307-1"
></A
>Integrating PLVexc with PLVtrc </A
></H4
><P
CLASS="para"
>As noted in the previous section, when you use the high-level handler programs such as <KBD
CLASS="command"
>go</KBD
> and <KBD
CLASS="command"
>recNstop</KBD
>, you do not have to tell PLVexc the name of the current program. This is true, however, only if you integrate your use of PLVexc with the PLVtrc package.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch22-idx-999308-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999308-1"
></A
>PLVtrc provides two programs to build and maintain its own execution stack of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs. You call <KBD
CLASS="command"
>PLVtrc.startup</KBD
> to indicate to PL/Vision that a new program has started (and this program can be a procedure, function, or even anonymous block). You call <KBD
CLASS="command"
>PLVtrc.terminate</KBD
> to indicate to PL/Vision that the current program has ended. The body of the <KBD
CLASS="command"
>calc_totals</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999309-0"
></A
> procedure below demonstrates this approach:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE calc_totals
IS
BEGIN
   PLVtrc.startup ('ct');

   ALL_OTHER_CODE;

   PLVtrc.terminate;

EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      PLVexc.continue;
   
   WHEN balance_too_low
   THEN
      PLVexc.halt;
   
   WHEN OTHERS
   THEN
      PLVtrc.terminate;
      RAISE;
END;  </PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first line in the body calls <KBD
CLASS="command"
>startup</KBD
>. Then all the rest of the code is executed. The last line in the procedure calls the trace <KBD
CLASS="command"
>terminate</KBD
> program. These statements manage the execution stack for successful execution of <KBD
CLASS="command"
>calc_totals</KBD
>. Now let's look at the exception handlers. In the first two handlers (for NO_DATA_FOUND and <KBD
CLASS="command"
>balance_too_low</KBD
>), I call one of my high-level PLVexc handler programs. These programs automatically maintain the PLVtrc execution stack with a call to <KBD
CLASS="command"
>PLVexc.terminate</KBD
>, so you do not have to do it yourself. The last, OTHERS handler only reraises the exception. Since it does not use a PLVexc handler, I must include an explicit call to <KBD
CLASS="command"
>PLVexc.terminate</KBD
> to update the execution stack.</P
><P
CLASS="para"
>In the next example, I use the <KBD
CLASS="command"
>startup</KBD
> and <KBD
CLASS="command"
>terminate</KBD
> procedures to track execution of a nested, anonymous block.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE annual_calcs (val in number) 
IS
BEGIN
   PLVtrc.startup ('proc');
   calc_gross_revenue;
   BEGIN
      PLVtrc.startup ('analyze');
      calc_rev_distribution;
      PLVtrc.terminate;
   EXCEPTION
      WHEN OTHERS THEN PLVexc.halt;
   END;
   call_profits;
   PLVtrc.terminate;
EXCEPTION
   WHEN OTHERS THEN PLVexc.rec_continue;
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With this code you can see some of the additional power and flexibility available with PL/Vision. There is no way at all to track through the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> stack the startup and execution of a local, anonymous block. Sure, you have to code it yourself, but at least you can get the information you need. Furthermore, if you don't turn on the trace, the overhead incurred by the PLVexc program calls is minimal. </P
><P
CLASS="para"
>Recognizing the difficulty of even remembering to include calls to PLVtrc modules in your programs, the PL/Vision code generator package, PLVgen, generates procedures and functions with calls to <KBD
CLASS="command"
>startup</KBD
> and <KBD
CLASS="command"
>terminate</KBD
> already in place. So if you start to use PLVgen as a starting point for your program creation, you will be able to leverage all of these components of PL/Vision and actually be <EM
CLASS="emphasis"
>more</EM
> productive.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.7"
>22.1.7 <A
CLASS="indexterm"
NAME="ch22-idx-999310-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999310-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999310-2"
></A
>Recording Errors</A
></H3
><P
CLASS="para"
>As you can see from the exception-handling actions, you can record an error in PLVexc. This package gives you two options for how to record the process:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Write the error information to the PL/Vision log through calls to PLVlog.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Display the error information to the screen (or standard output) using the <KBD
CLASS="command"
>p.l</KBD
> procedure.</P
></LI
></OL
><P
CLASS="para"
>You can perform both of these steps simultaneously when an error occurs, or you can turn on only one of these options. The programs to manage these record features are discussed below.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.7.1"
>22.1.7.1 <A
CLASS="indexterm"
NAME="ch22-idx-999311-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999311-1"
></A
>Logging errors</A
></H4
><P
CLASS="para"
>PLVexc provides a standard PL/Vision toggle to control logging of errors with PLVlog. The headers for these programs are:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE log;
PROCEDURE nolog;
FUNCTION logging RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>These toggles allow developers to change the behavior of exception handling in PLVexc without making any changes to their application or to the PLVexc package itself. When you want to record the errors to the PL/Vision log, you simply execute this command before running the application:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVexc.log;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Then each time a PLVexc handler program is executed, the following information is written to the log:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Current program</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Error code</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Error message</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>User who raised the exception</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Time/date of logging</P
></LI
></UL
><P
CLASS="para"
>The default value for logging in PLVexc is that it is turned on. You do not, in other words, have to call <KBD
CLASS="command"
>PLVexc.log</KBD
> to turn on logging if you have just started up your session. </P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.7.2"
>22.1.7.2 Showing errors</A
></H4
><P
CLASS="para"
>PLVexc provides a standard PL/Vision toggle to control showing of errors with PLVshow. The headers for these programs are:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999312-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999312-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999312-2"
></A
>show;
PROCEDURE noshow;
FUNCTION showing RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>These toggles allow developers to change the behavior of exception handling in PLVexc without making any changes to their application or to the PLVexc package itself. When you want to view the exceptions as they occur (or, at least, when the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program completes its execution), you simply enter the following command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVexc.show;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When you are done viewing the errors and only want the information logged (or completely ignored, depending on the value returned by <KBD
CLASS="command"
>PLVexc.logging</KBD
>), you execute this command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVexc.noshow;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The default value for showing exceptions from PLVexc is that it is turned off. You must, in other words, call <KBD
CLASS="command"
>PLVexc.show</KBD
> when you want to view exceptions directly from the screen.</P
><P
CLASS="para"
>Logging and showing of errors are completely independent actions. You do not have to have logging turned on in order to also show the errors.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.7.3"
>22.1.7.3 <A
CLASS="indexterm"
NAME="ch22-idx-999313-0"
></A
>Using the record toggles</A
></H4
><P
CLASS="para"
>The following scenarios will give you a better idea of when and how these toggles would be used.</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>Scenario 1:</EM
>  Suppose that I want to execute a batch procedure that transfers and transforms several million rows from a temporary table to its final resting place. I know in advance that the load process will generate thousands of exceptions. I know also that it is not necessary to keep track of these errors, so I do not want to clog up my log table with that information. In the following script, therefore, I turn off both logging and display of errors and then execute the batch load.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   PLVexc.nolog;
   PLVexc.noshow;
   batch_load (SYSDATE);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
><EM
CLASS="emphasis"
>Scenario 2:</EM
>  I am testing a new program and expect errors to pop up. Rather than go through the trouble of querying the contents of the log table, I would like to simply display errors to the screen and respond immediately.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVexc.nolog;
SQL&gt; exec PLVexc.show;
SQL&gt; exec new_program;
proc1 Code -6502
ORA-06502: PL/SQL: numeric or value error</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Of course, when the application moves to production status, you will want to log errors to a table or some kind of repository. You rarely ever want to display them directly to users. Consequently, these are the default settings for the PLVexc toggles.<A
CLASS="indexterm"
NAME="ch22-idx-999314-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999314-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.8"
>22.1.8 <A
CLASS="indexterm"
NAME="ch22-idx-999315-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999315-1"
></A
>Rolling Back When an Exception Occurs</A
></H3
><P
CLASS="para"
>PLVexc provides a PL/Vision toggle to control whether PLVexc requests a rollback (executed within PLVlog) before error information is written to the log. The headers for these programs are:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999316-0"
></A
>rblast;
PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999317-0"
></A
>rbdef;
PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999318-0"
></A
>norb;
FUNCTION rb RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The default is to perform a rollback to the last savepoint set with a call to <KBD
CLASS="command"
>PLVrb.set_savepoint</KBD
> (<KBD
CLASS="command"
>rblast</KBD
>). If you do not want a rollback to occur before logging the error, issue this command before you start your application:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVexc.norb;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You have only three options concerning rollbacks from within PLVexc: </P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Roll back to the last savepoint set by calling <KBD
CLASS="command"
>PLVrb.set_savepoint</KBD
>. Call <KBD
CLASS="command"
>PLVexc.rblast</KBD
> to select this behavior (the default).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Perform a rollback based on the current/default behavior defined in PLVlog (see <A
CLASS="xref"
HREF="ch21_01.htm"
>Chapter 21</A
>). Call <KBD
CLASS="command"
>PLVexc.rbdef</KBD
> to select this behavior.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not perform any rollback before insertion of error information into the PL/Vision log. Call <KBD
CLASS="command"
>PLVexc.norb</KBD
> to select this behavior (the default).</P
></LI
></OL
><P
CLASS="para"
>If you want to see if PLVexc is currently requesting a rollback, call the <KBD
CLASS="command"
>rb</KBD
> function. It returns the PLVlog rollback action code.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.9"
>22.1.9 <A
CLASS="indexterm"
NAME="ch22-idx-999325-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999325-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999325-2"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999325-3"
></A
>Halting in PLVexc</A
></H3
><P
CLASS="para"
>When you request that the processing in your application halt by calling <KBD
CLASS="command"
>recNstop</KBD
> or simply <KBD
CLASS="command"
>stop</KBD
>, the PLVexc takes all appropriate actions and then issues the following statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>RAISE process_halted;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>process_halted</KBD
> exception is declared by name in the specification of the PLVexc package. It is not associated with any error number in the -20NNN range. As a result, there are only two ways you can trap this exception once it is raised.</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>With an exception handler specifically for this exception, which would look like this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHEN PLVexc.process_halted
THEN
   do_something;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>With a WHEN OTHERS section, which traps any and every kind of exception. </P
></LI
></OL
><P
CLASS="para"
>You can choose to handle the halting exception, in which case the processing of your application might still be able to continue. Generally, however, you will not trap this exception and instead let it propagate up to the top of the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> calling stack, where it goes unhandled. A WHEN OTHERS handler will, of course, trap this exception. As a final option, you might handle this exception at the outermost block so that you can perform a commit and save writes to the error log (if it is a database table).</P
><P
CLASS="para"
>Using the bailout feature, you can also truly and completely bail out of your program regardless of the presence of a WHEN OTHERS section. See <A
CLASS="xref"
HREF="ch22_01.htm"
>Section 22.1.10, "<A
CLASS="indexterm"
NAME="ch22-idx-999335-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999335-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999335-2"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999335-3"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999335-4"
></A
>Bailing Out with PLVexc"</A
> for more information on this feature.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch22-SECT-1.10"
>22.1.10 <A
CLASS="indexterm"
NAME="ch22-idx-999335-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999335-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999335-2"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999335-3"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999335-4"
></A
>Bailing Out with PLVexc</A
></H3
><P
CLASS="para"
>You have already seen how you can stop your current program by requesting a halting action. This request causes PLVexc to raise an exception as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>RAISE <A
CLASS="indexterm"
NAME="ch22-idx-999320-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999320-1"
></A
>process_halted;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This exception propagates out of, and closes, enclosing <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> blocks until it hits an exception handler specifically for that exception or until it encounters a WHEN OTHERS exception.</P
><P
CLASS="para"
>But what if you really want to bail out entirely and immediately from your application? I encountered a situation recently where a very long-running program would work fine for an hour or two, but then raise an ORA-3113 error: "end of file on communication channel". My program had lost its connection; there was no point in going on. Yet because I had made rigorous use of my PLVexc exception handler programs, I trapped the error, logged the problem, and continued on to the next transaction. It made no sense, given the error, but on it went, accumulating error log records until the tablespace was full, at which point the application generated ORA-3113 <EM
CLASS="emphasis"
>and</EM
> ORA-1547 errors. I had a full-scale mess on my hands.</P
><P
CLASS="para"
>This experience brought to light a different class of errors: fatal problems whose occurrence should always signal the need for a total shutdown of the application. There is, after all, little point in continuing when you are not connected to the database.</P
><P
CLASS="para"
>PLVexc supports this functionality by allowing you to specify a set of error codes which, when raised, cause an unstoppable "bail out" from your program. These are called the <EM
CLASS="emphasis"
>bailout errors</EM
>. As long as you use PLVexc handlers in all of your exception sections, a bailout error will propagate out of WHEN OTHERS sections even if you specify a continue action.</P
><P
CLASS="para"
>There are two aspects to the bailout feature: (a) establishing the list of bailout errors; and (b) starting and stopping the bailout itself. It is up to the users of PLVexc to create a list of bailout errors. It is usually left to PLVexc to initiate the bailout; you can, however, do this yourself as well. The programs that support both parts of bailing out are covered below.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.10.1"
>22.1.10.1 Managing the bailout error list</A
></H4
><P
CLASS="para"
>You add an error number to the bailout error list by calling the <KBD
CLASS="command"
>bailout_on</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999341-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999341-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999341-2"
></A
> procedure, whose header is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE bailout_on (err_code_in IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following statements add several error codes to the bailout error list. In a production environment, you might even place these calls inside a <KBD
CLASS="command"
>login.sql</KBD
> script which is run whenever SQL*Plus is initiated to run a regular, batch process.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVexc.bailout_on (-3113); /* end-of-file on comm error */
PLVexc.bailout_on (-1547); /* failed to allocate extent */
PLVexc.bailout_on (-1555); /* snapshot too old */
PLVexc.bailout_on (-1562); /* can't extend rollback */</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To remove an error number from the bailout error list, call the <KBD
CLASS="command"
>nobailout_on</KBD
> procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999342-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999342-1"
></A
>nobailout_on (err_code_in IN INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To clear the entire list of bailout errors, call the <KBD
CLASS="command"
>clear_bailouts</KBD
> procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999343-0"
></A
>clear_bailouts;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To determine if an error number is currently on the bailout list, call the <KBD
CLASS="command"
>bailout_error</KBD
> function, whose header is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION <A
CLASS="indexterm"
NAME="ch22-idx-999344-0"
></A
>bailout_error (err_code_in IN INTEGER) RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Once you have defined your bailout list, you (and, more to the point, PLVexc) can reference this list to determine if a bailout should be initiated or stopped.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch22-SECT-1.10.2"
>22.1.10.2 <A
CLASS="indexterm"
NAME="ch22-idx-999345-0"
></A
>Starting and stopping the bailout</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>bailout</KBD
> procedure raises the <KBD
CLASS="command"
>process_halted</KBD
> exception of the PLVexc package and switches PLVexc into "bailout mode." Here is the header for this procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999346-0"
></A
>bailout;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This program takes two steps: it sets a Boolean flag to indicate PLVexc is now bailing out and it then raises the <KBD
CLASS="command"
>process_halted</KBD
> exception. </P
><P
CLASS="para"
>You can stop a bailout in progress with a call to <KBD
CLASS="command"
>nobailout</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch22-idx-999347-0"
></A
>nobailout;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>PLVexc never calls this program. It is up to you to decide if you want to stop propagation of the exception and continue processing in your application.</P
><P
CLASS="para"
>You can also find out if PLVexc is currently bailing out with a call to the <KBD
CLASS="command"
>bailing_out</KBD
><A
CLASS="indexterm"
NAME="ch22-idx-999348-0"
></A
> function:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION bailing_out RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>bailout</KBD
> procedure is called by the low-level handle procedure if it encounters a bailout error or PLVexc is in bailout mode already. The following IF statement is, in fact, the first line of code in the body of the <KBD
CLASS="command"
>handle</KBD
> procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF bailing_out
THEN
   bailout;
END IF;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So if a bailout error was previously encountered or a developer calls <KBD
CLASS="command"
>PLVexc.bailout</KBD
> directly, the handle program short-circuits. It does not record the error. (PLVexc assumes that the error was recorded as specified when it was first handled.) It does not display the error; it just raises the <KBD
CLASS="command"
>process_halted</KBD
> exception&nbsp;-- again and again for as long as the PLVexc handler programs are called in exception sections of enclosing blocks.<A
CLASS="indexterm"
NAME="ch22-idx-999349-0"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999349-1"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999349-2"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999349-3"
></A
><A
CLASS="indexterm"
NAME="ch22-idx-999349-4"
></A
></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch21_02.htm#ch21-SECT-2.1"
TITLE="21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 21.2 PLVtrc: Tracing Execution of PL/SQL Programs"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch22_02.htm#ch22-SECT-2.1.1"
TITLE="22.2 Application-Specific Exception Packages"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 22.2 Application-Specific Exception Packages"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>21.2 PLVtrc: Tracing Execution of PL/SQL Programs</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>22.2 Application-Specific Exception Packages</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
