<HTML
><HEAD
><TITLE
>[Chapter 10] PLVprs, PLVtkn, and PLVprsps: Parsing Strings</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:27:04Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part03.htm"
TITLE="III. Building Block Packages"><LINK
REL="prev"
HREF="ch09_06.htm"
TITLE="9.6 Implementing load_  from_dbms"><LINK
REL="next"
HREF="ch10_02.htm#ch10-SECT-2.3"
TITLE="10.2 PLVtkn: Managing PL/SQL Tokens"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_06.htm"
TITLE="9.6 Implementing load_  from_dbms"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.6 Implementing load_  from_dbms"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Chapter 10</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.3"
TITLE="10.2 PLVtkn: Managing PL/SQL Tokens"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.2 PLVtkn: Managing PL/SQL Tokens"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="plsql-adv-ch-10"
>10. PLVprs, PLVtkn, and PLVprsps: Parsing Strings</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch10-18384"
TITLE="10.1 PLVprs: Useful String Parsing Extensions"
>PLVprs: Useful String Parsing Extensions</A
><BR><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.3"
TITLE="10.2 PLVtkn: Managing PL/SQL Tokens"
>PLVtkn: Managing PL/SQL Tokens</A
><BR><A
CLASS="sect1"
HREF="ch10_03.htm#ch10-SECT-3.2.2"
TITLE="10.3 PLVprsps: Parsing PL/SQL Strings"
>PLVprsps: Parsing PL/SQL Strings</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-998702-0"
></A
>Parsin<A
CLASS="indexterm"
NAME="ch10-idx-998703-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998703-1"
></A
>g a computer program can be a very frustrating and complex experience. There are all kinds of exceptions to the rules and special rules to handle in one's logic. The only way I could handle all of these details was to deal with as narrow a portion of functionality at a time as I could. The result is a set of four different packages oriented to different levels of the parsing process. By isolating various areas of complexity into these different packages, I can keep each of the individual parsing programs brief and relatively easy to write and understand.</P
><P
CLASS="para"
>PL/Vision offers several different string and source code parsing packages:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>PLVprs</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Generic string-parsing extensions to <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>. This is the lowest level of string-parsing functionality and will prove useful in many different situations.</P
></DD
><DT
CLASS="term"
>PLVtkn</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Interface to the <KBD
CLASS="command"
>PLV_token</KBD
> table, which contains more than 1,200 keywords of the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> language, including those for Oracle Forms. Use <KBD
CLASS="command"
>PLVtkn</KBD
> to determine if an identifier is a keyword.</P
></DD
><DT
CLASS="term"
>PLVlex</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><SPAN
CLASS="acronym"
>PL/SQL</SPAN
> lexical analysis package. Performs similar parsing actions as those available in <KBD
CLASS="command"
>PLVprs</KBD
>, but does so with an awareness of the syntax and delimiters of the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> language.[<A
CLASS="footnote"
HREF="#ch10-pgfId-997991"
>1</A
>] </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch10-pgfId-997991"
>[1]</A
> This package is not described further in the book; see the the companion disk for more information.</P
></DIV
></BLOCKQUOTE
></DD
><DT
CLASS="term"
>PLVprsps</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Highest-level package to parse <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> source code (hence the <KBD
CLASS="command"
>prsps</KBD
> name) into separate atomics. Relies on the other parsing packages to get its job done.</P
></DD
></DL
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch10-18384"
>10.1 PLVprs: Useful String Parsing Extensions</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-998704-0"
></A
>The PLVprs (PL/Vision PaRSe) package offers a set of procedures and functions that provide generic and very flexible string-parsing functionality. These programs extend the builtin string functions of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>. They can:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Parse a string into its atomics</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Count the number of atomics in a string</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Count the frequency of a substring within a string</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Return the <EM
CLASS="emphasis"
>n</EM
> th atomic in a string</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Wrap a long line of text into a paragraph</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Display a wrapped line of text</P
></LI
></UL
><P
CLASS="para"
>You can use PLVprs within other packages and programs to analyze strings and display their contents. It is also used within PL/Vision by PLVvu and PLVdyn to display long messages.</P
><P
CLASS="para"
>All of our applications require manipulation of textual information. I have often encountered the need to parse and analyze those strings in order to answer requests like the following (and I am sure that you could add more to the list):</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Count the number of words in a string.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Separate out all words and punctuation in a string into separate components.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Return the <EM
CLASS="emphasis"
>n</EM
>th value in a semicolon-delimited string. This is a very common situation in Oracle Forms applications, in which a developer might pack a set of values into a global variable like this: "123;5555;6623.11;".</P
></LI
></UL
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.1"
>10.1.1 Developing a General Solution</A
></H3
><P
CLASS="para"
>Taken separately, it is not too hard to develop a solution to any of the items on this list. If you build solutions to each individual requirement on a case-by-case basis, you will end up with an enormous volume of redundant code which you cannot easily enhance or upgrade.</P
><P
CLASS="para"
>Rather than construct a smattering of different, specialized routines to analyze strings, I offer with PLVprs a set of very generic and flexible functions and procedures. Yet the only way to make sure that my approach will handle many different situations and requirements is to base that approach on a general analysis of the components of a string. </P
><P
CLASS="para"
>In the world of PLVprs, a string is made up of a series of atomics, the smallest indivisible elements of the string. An atomic is either a word (defined as a contiguous set of letters and/or numbers) or a delimiter (any one of a set of special characters which separate or delimit words). In the English language, for example, common delimiters, a.k.a. punctuation, include the comma, semicolon, question mark, period, etc. But in a more general scenario, we have to be careful not to assume that the set of delimiters is a constant. For example, if I want to perform operations on a string of values delimited by a semicolon, then the set of delimiters for that particular operation is a single character: the semicolon.</P
><P
CLASS="para"
>Once you see strings as a set of atomics, of words separated by delimiters, you can reinterpret and enhance the kinds of requests listed above, such as "count all words in a string." Do you want to count all the atomics or just the words or just the delimiters? PLVprs gives you that level of flexibility.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.2"
>10.1.2 Customizing the Delimiter Set</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-998705-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998705-1"
></A
>The PLVprs package interprets a string as a series of atomics: words and delimiters. But what is a delimiter? PLVprs predefines two sets of <A
CLASS="indexterm"
NAME="ch10-idx-998707-0"
></A
>delimiters:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Name</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Characters in Delimeter Set</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>std_delimeters</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>!@#$%^&amp;*()&#8208;_=+\|`~{{]};:''&quot;,&lt;.&gt;/?' plus space, tab, and newline characters</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>plsql_delimeters</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>!@%^&amp;*()&#8208;=+\|`~{{]};:''&quot;,&lt;.&gt;/?' plus space, tab, and newline characters</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The only difference between these lists is that the <KBD
CLASS="command"
>plsql_delimiters</KBD
><A
CLASS="indexterm"
NAME="ch10-idx-998708-0"
></A
> set omits the underscore, dollar sign, and pound sign characters. These characters are valid symbols in a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> identifier, which should certainly be considered a word.</P
><P
CLASS="para"
>Would you ever need any other delimiter sets? Sure, why not? You might have a string which is packed with values separated by the vertical bar. In this situation, when you call <KBD
CLASS="command"
>PLVprs.string</KBD
> to separate the string into separate atomics, you will want to be able to specify your special and very short delimiter list.</P
><P
CLASS="para"
>PLVprs lets you specify a non-default delimiter list in the following programs:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
><CODE
CLASS="literal"
>next_atom_loc</CODE
></TD
></TR
><TR
><TD
CLASS="member"
><CODE
CLASS="literal"
>nth_atomic</CODE
></TD
></TR
><TR
><TD
CLASS="member"
><CODE
CLASS="literal"
>display_atomics</CODE
></TD
></TR
><TR
><TD
CLASS="member"
><CODE
CLASS="literal"
>string</CODE
></TD
></TR
><TR
><TD
CLASS="member"
><CODE
CLASS="literal"
>numatomics</CODE
></TD
></TR
></TABLE
><P
CLASS="para"
>Here is an example of how I could parse a string with atomics packed between vertical bars and ignore any other delimiters:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   atomic PLVtab.vc2000_table;
   num INTEGER;
BEGIN
   PLVprs.string ('A#-%|12345|(*&amp;*)|0101R|', atomic, num, '|');
   PLVtab.display (atomic,num);
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This is the output seen after executing the above script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Contents of Table
A#-%
|
12345
|
(*&amp;*)
|
0101R
|</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With the default set of delimiters, this string would have been broken up by <KBD
CLASS="command"
>PLVprs.string</KBD
> into fifteen separate atomics, rather than just eight. So don't forget to use your own delimiter list as needed to simplify your parsing and analysis jobs.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.3"
>10.1.3 Parsing Strings into Atomics</A
></H3
><P
CLASS="para"
>The PLVprs package offers a number of programs that perform different parsing operations on strings. They are each discussed below. The implementations of most of these programs were discussed in <CITE
CLASS="citetitle"
>Oracle PL/SQL Programming</CITE
>, so I will not go beyond an explanation here of how you can use these functions.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.3.1"
>10.1.3.1 next_atom_loc function<A
CLASS="indexterm"
NAME="ch10-idx-998709-0"
></A
></A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>next_atom_loc</KBD
> returns the location in the specified string of the next atomic. It is used by other PLVprs programs, but is also available for use by other PL/Vision packages&nbsp;-- and by you. Its header is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   FUNCTION next_atom_loc 
        (string_in IN VARCHAR2, 
         start_loc_in IN NUMBER,
         direction_in IN NUMBER := +1,
         delimiters_in IN VARCHAR2 := std_delimiters)
   RETURN INTEGER;           </PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>string_in</KBD
> parameter is the string to be scanned. The <KBD
CLASS="command"
>start_loc_in</KBD
> parameter provides the starting position of the search for the start of the next atomic. The <KBD
CLASS="command"
>direction_in</KBD
> parameter indicates whether the search should move forward or backward through the string. The final argument allows you to specify the set of characters to be considered delimiters (which indicate the start of a new atomic).</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>next_atom_loc</KBD
> function returns the location in the string of the starting point of the next atomic (from the start location). The function scans forward if <KBD
CLASS="command"
>direction_in</KBD
> is +1, otherwise it scans backwards through the string. Here is the logic to determine when the next atomic starts:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>If the current atomic is a delimiter (that is, if the character at the <KBD
CLASS="command"
>start_loc_in</KBD
> of the string is a delimiter), then the next character starts the next atomic since all delimiters are a single character in length.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the current atomic is a word (that is, if the character at the <KBD
CLASS="command"
>start_loc_in</KBD
> of the string is a letter or number), then the next atomic starts at the next delimiter. Any letters or numbers in between are part of the current atomic.</P
></LI
></OL
><P
CLASS="para"
>The <KBD
CLASS="command"
>next_atomic_loc</KBD
> function loops through the string one character at a time and applies these tests. It also has to check for the end of string. If it scans forward, the end of string comes when the SUBSTR that pulls out the next character returns NULL. If it scans backward, then the end of the string comes when the location is less than 0.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.3.2"
>10.1.3.2 display_atomics procedure<A
CLASS="indexterm"
NAME="ch10-idx-998710-0"
></A
></A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>display_atomics</KBD
> procedure displays the atomics found in the specified string. Its header is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE display_atomics
   (string_in IN VARCHAR2, 
    delimiters_in IN VARCHAR2 := std_delimiters);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You specify the string you want parsed and the set of characters you want to be treated as delimiters for the parsing. To make it easier to view blank lines, spaces are displayed as a description of the number of spaces present (as in "1 blank" or "6 blanks"). This feature is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVtab.showrow
SQL&gt; exec PLVprs.display_atomics ('Compassion is a human thing.');
Parsed Atomics in String
Row 1 = Compassion
Row 2 = 1 blank
Row 3 = is
Row 4 = 1 blank
Row 5 = a
Row 6 = 1 blank
Row 7 = human
Row 8 = 2 blanks
Row 9 = thing
Row 10 = .</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can specify an alternate delimiter set in order to display the contents of a string according to the format of that string and how it is used. Compare the two calls to <KBD
CLASS="command"
>display_atomics</KBD
> below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVprs.display_atomics ('1234|A$%|67YYY|(big)');
11
Parsed Atomics in String
1234
-|-
A
-$-
-%-
-|-
67YYY
-|-
-(-
big
-)-
SQL&gt; exec PLVprs.display_atomics ('1234|A$%|67YYY|(big)', '|');
7
Parsed Atomics in String
1234
-|-
A$%
-|-
67YYY
-|-
(big)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the second call, I am telling <KBD
CLASS="command"
>display_atomics</KBD
> to consider "|" as the sole delimiter in the string.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.3.3"
>10.1.3.3 numatomics function<A
CLASS="indexterm"
NAME="ch10-idx-998711-0"
></A
></A
></H4
><P
CLASS="para"
>The<A
CLASS="indexterm"
NAME="ch10-idx-998712-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998712-1"
></A
> <KBD
CLASS="command"
>numatomics</KBD
> function returns the number of atomics in a string. You can calculate the number of all atomics, only the words, or only the delimiters. You can specify in your call to the function what characters should be considered delimiters. The header for this function is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION numatomics 
   (string_in IN VARCHAR2, 
    count_type_in IN VARCHAR2 := c_all,
    delimiters_in IN VARCHAR2 := std_delimiters)
RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following examples demonstrate how to use the <KBD
CLASS="command"
>count_type_in</KBD
> argument. The first call relies on the default value of "all atomics." The next two calls pass in a specific request for type of atomic, relying on the constants provided in the package specification.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec p.l (PLVprs.numatomics ('this, is%not.'))
7
SQL&gt; exec p.l (PLVprs.numatomics ('this, is%not.', PLVprs.c_word))
3
SQL&gt; exec p.l (PLVprs.numatomics ('this, is%not.', PLVprs.c_delim))
4</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.3.4"
>10.1.3.4 nth_atomic function</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>nth_atomic</KBD
> function<A
CLASS="indexterm"
NAME="ch10-idx-998713-0"
></A
> returns the <EM
CLASS="emphasis"
>n</EM
> th atomic in a string. You can, for example, ask for the seventh word or the sixth delimiter. The header for <KBD
CLASS="command"
>nth_atomic</KBD
> is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION nth_atomic
   (string_in IN VARCHAR2, 
    nth_in IN NUMBER,
    count_type_in IN VARCHAR2 := c_all,
    delimiters_in IN VARCHAR2 := std_delimiters)
RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>nth_atomic</KBD
> function is very flexible, following the model of the builtin functions, INSTR and SUBSTR<A
CLASS="indexterm"
NAME="ch10-idx-998714-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998714-1"
></A
>. You can scan both forward and backward through the string. If you provide a positive <KBD
CLASS="command"
>nth_in</KBD
> argument, then <KBD
CLASS="command"
>nth_atomic</KBD
> scans forward to the <EM
CLASS="emphasis"
>n</EM
>th atomic. If, on the other hand, the <KBD
CLASS="command"
>nth_in</KBD
> value is negative, <KBD
CLASS="command"
>nth_atomic</KBD
> will scan backwards through the string to the <EM
CLASS="emphasis"
>n</EM
>th atomic. This feature is shown in the examples below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec p.l(PLVprs.nth_atomic ('this, is%not.', 2))
,
SQL&gt; exec p.l(PLVprs.nth_atomic ('this, is%not.', 2, PLVprs.c_word))
is
SQL&gt; exec p.l(PLVprs.nth_atomic ('this, is%not.', 3, PLVprs.c_delim))
%
SQL&gt; exec p.l(PLVprs.nth_atomic ('this, is%not.', -3, PLVprs.c_word))
this</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The PLVdyn package also utilizes <KBD
CLASS="command"
>nth_atomic</KBD
> function to extract the type of program unit and the name of the program unit that is being compiled and stored by the <KBD
CLASS="command"
>compile</KBD
> procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>/* Get the first word.*/
v_name1 := PLVprs.nth_atomic (stg_in, 1, PLVprs.c_word);

/* Get the second word. */
v_name2 := PLVprs.nth_atomic (stg_in, 2, PLVprs.c_word);

/* If a package body, then get the THIRD word. */
IF UPPER (v_name1||' '||v_name2) = 'PACKAGE BODY'
THEN
   v_name1 := v_name1 || ' ' || v_name2;
   v_name2 := PLVprs.nth_atomic (stg_in, 3, PLVprs.c_word);
END IF;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.3.5"
>10.1.3.5 string procedures</A
></H4
><P
CLASS="para"
>There are two, overloaded versions of the <KBD
CLASS="command"
>string</KBD
> procedure<A
CLASS="indexterm"
NAME="ch10-idx-998715-0"
></A
>, which parses a string into its separate atomics. The <KBD
CLASS="command"
>string</KBD
> procedure is available to users of the PLVprs package; it is also used by programs in the PLVprs package. The <KBD
CLASS="command"
>display_atomics</KBD
> procedure, for example, calls the <KBD
CLASS="command"
>string</KBD
> procedure to parse the specified string and then calls <KBD
CLASS="command"
>PLVtab.display</KBD
> to display the table that contains the parsed atomics.</P
><P
CLASS="para"
>The headers for the <KBD
CLASS="command"
>string</KBD
> procedures are:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE string
   (string_in IN VARCHAR2, 
    atomics_list_out OUT PLVtab.vc2000_table, 
    num_atomics_out IN OUT NUMBER,
    delimiters_in IN VARCHAR2 := std_delimiters);

PROCEDURE string 
   (string_in IN VARCHAR2, 
    atomics_list_out IN OUT VARCHAR2, 
    num_atomics_out IN OUT NUMBER,
    delimiters_in IN VARCHAR2 := std_delimiters);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first argument is the string to be parsed. The second and third arguments contain the parsed output of the procedure call. The fourth argument allows you to specify an alternative set of delimiter characters.</P
><P
CLASS="para"
>The table version of <KBD
CLASS="command"
>string</KBD
> fills a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table with the atomics of the string, one atomic per row. The VARCHAR2 version of the <KBD
CLASS="command"
>string</KBD
> procedure returns the atomics in a string separated by the vertical bar delimiter. This "string version" of <KBD
CLASS="command"
>string</KBD
> simply calls the table version and then dumps the contents of the table into a string.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.3.6"
>10.1.3.6 numinstr function<A
CLASS="indexterm"
NAME="ch10-idx-998716-0"
></A
></A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>numinstr</KBD
> function is a good example of how you can supplement the fine, but finite set of builtin string functions with your own basic and quite reusable functions. The <KBD
CLASS="command"
>numinstr</KBD
> function returns the number of times a substring appears in a string. Its header is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION numinstr
   (string_in IN VARCHAR2,
    substring_in IN VARCHAR2,
    ignore_case_in IN VARCHAR2 := c_ignore_case)
RETURN INTEGER;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first argument is the string, the second is the substring, and the third allows you to specify whether you want case to be ignored or respected in the search. The following examples illustrate this flexibility:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec p.l (PLVprs.numinstr ('abcabC', 'c'));
2
SQL&gt; exec p.l (PLVprs.numinstr ('abcabC', 'c', PLVprs.c_respect_case));
1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the following code fragment, I call <KBD
CLASS="command"
>numinstr</KBD
> to determine the number of placeholders for bind variables in a dynamically constructed <SPAN
CLASS="acronym"
>SQL</SPAN
> string (a placeholder is defined as a colon followed by a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> identifier, such as <KBD
CLASS="command"
>:newname</KBD
> or <KBD
CLASS="command"
>:bindvar1</KBD
>). I then use a numeric FOR loop to issue a call to the BIND_VARIABLE procedure of the builtin DBMS_SQL package for each of the bind variables.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>numvars := PLVprs.numinstr (sql_string, ':');
FOR bindvar_ind IN 1 .. numvars
LOOP
   DBMS_SQL.BIND_VARIABLE 
     (cur_handle,
      'bindvar' || TO_CHAR (bindvar_ind), 
      variables_table (bindvar_in));
END LOOP; </PRE
></BLOCKQUOTE
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="AUTOID-12462"
>Finding the Best Solution<A
CLASS="indexterm"
NAME="ch10-idx-998718-0"
></A
></A
></H4
><P
CLASS="para"
>I believe I am a fairly good <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programmer. I can churn out hundreds of lines of complicated code that works, more or less, after just a few rounds of revisions. On the other hand, I feel I am also very much open to the possibility that others can and have done better&nbsp;-- and that I can learn from them. None of us has all the answers&nbsp;-- and some of us have more answers than others. </P
><P
CLASS="para"
>Let me give you an example. In my first book on <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>, <CITE
CLASS="citetitle"
>Oracle PL/SQL Programming</CITE
> (O'Reilly &amp; Associates), I give every impression that I know what I am talking about&nbsp;-- and a big part of what I talk about is writing concise, high-quality code. In Chapter 11, <CITE
CLASS="citetitle"
>Character Functions</CITE
>, I take my readers through the exercise of building a function to count the number of times a substring occurs in a string (a function not provided by <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>). I end up with two implementations, the shorter of which is shown in <A
CLASS="xref"
HREF="ch10_01.htm"
>Example 10.1</A
>.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="PACKAGES-CH-10-EX-1"
>Example 10.1: Counting the Frequency of a Substring Within a String</A
></H4
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION numinstr 
   (string_in IN VARCHAR2, substring_in IN VARCHAR2) 
RETURN INTEGER
IS
   substring_loc NUMBER;  
   return_value NUMBER := 1;
BEGIN
   LOOP
      substring_loc := 
         INSTR (UPPER (string_in), 
                UPPER (substring_in), 1, return_value);

      /* Terminate loop when no more occurrences are found. */
      EXIT WHEN substring_loc = 0;

      /* Found match, so add to total and continue. */
      return_value := return_value + 1;
   END LOOP;   
   RETURN return_value - 1;   
END numinstr;
</PRE
></BLOCKQUOTE
></DIV
><P
CLASS="para"
>I was quite content with this function&nbsp;-- until I received an email from Kevin Loney, author of <EM
CLASS="emphasis"
>ORACLE</EM
> DBA Handbook (Oracle Press). This email very politely complimented me on my book and offered an alternative implementation for <KBD
CLASS="command"
>numinstr</KBD
>&nbsp;-- a simpler, more efficient, and more elegant implementation. As Kevin noted, he came up with this solution before the days of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>, when all he had to work with was <SPAN
CLASS="acronym"
>SQL</SPAN
> (a set-at-a-time, nonprocedural language). In his approach (shown in <A
CLASS="xref"
HREF="ch10_01.htm"
>Example 10.2</A
>), he took advantage of the REPLACE builtin function to substitute NULL for any occurrences of the substring. He could then compare the size of the original string with the "replaced" string and use that as the basis for his calculation.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="PACKAGES-CH-10-EX-2"
>Example 10.2: Counting the Frequency of a Substring Within a String</A
></H4
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION numinstr
    (string_in IN VARCHAR2, sub_string_in IN VARCHAR2)
RETURN INTEGER
/* Divide difference of two lengths by length of substring. */
IS
BEGIN
   RETURN
     ((LENGTH (string_in) -
       NVL (LENGTH (REPLACE (string_in, sub_string_in)), 0))
     / LENGTH (sub_string_in));
END;
</PRE
></BLOCKQUOTE
></DIV
><P
CLASS="para"
>I felt a wave of embarrassment wash over me for just a moment when I first read Kevin's note. Then I regained sanity. <EM
CLASS="emphasis"
>Of course</EM
> there are better ways of doing things. Discovering and sharing these improvements&nbsp;-- programming altruism&nbsp;-- is one of the finest aspects of our work. And programming humility&nbsp;-- the willingness to accept these improvements&nbsp;-- can make our lives much easier. If you are open to the ideas of others, then you are also open to the idea of using the work of others (with permission!). This means that you will spend much less time coding something that is already available&nbsp;-- you will avoid reinventing the wheel. Kevin's implentation for <CODE
CLASS="literal"
>numinstr</CODE
> (enhanced to ignore or respect case) is now in version I provide in PLVprs.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch10-SECT-1.4"
>10.1.4 Wrapping Strings into Paragraphs</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch10-idx-998717-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998717-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998717-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998717-3"
></A
>How many times have you been confronted with the need to display a long string (defined, essentially, as anything longer than 80 characters) in a format which can be read easily? Unfortunately, <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> does not have any paragraph-wrapping capabilities built into it. All you have is DBMS_OUTPUT.PUT_LINE, which accepts a maximum of 255 characters and is displayed in whatever manner handled by your environment.</P
><P
CLASS="para"
>PLVprs fills this gap in functionality by providing the following suite of string-wrapping programs:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><KBD
CLASS="command"
>wrap</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Wraps a long string into a series of lines with a maximum specified length, each line of which is stored in consecutive rows in a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>wrapped_string</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Returns a long string wrapped into a series of lines separated by newline characters.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>display_wrap</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Displays a long string in paragraph-wrapped form at the specified length.</P
></DD
></DL
><P
CLASS="para"
>The <KBD
CLASS="command"
>wrap</KBD
> procedure supplies the core paragraph-wrapping functionality and is called both by <KBD
CLASS="command"
>wrapped_string</KBD
> and <KBD
CLASS="command"
>display_wrap</KBD
>. All three programs are described below.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.4.1"
>10.1.4.1 wrap procedure<A
CLASS="indexterm"
NAME="ch10-idx-998719-0"
></A
></A
></H4
><P
CLASS="para"
>The header for the <KBD
CLASS="command"
>wrap</KBD
> procedure is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE wrap
  (text_in IN VARCHAR2,
   line_length IN INTEGER,
   paragraph_out IN OUT PLVtab.vc2000_table,
   num_lines_out IN OUT INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first parameter is the text to be wrapped. The second parameter, <KBD
CLASS="command"
>line_length</KBD
>, is the length of the line into which the long text is to be wrapped. The <KBD
CLASS="command"
>paragraph_out</KBD
> argument is the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table which will receive the wrapped text (each row, starting from 1, contains a single line of text). The <KBD
CLASS="command"
>num_lines_out</KBD
> argument contains the number of lines of text that have been placed in <KBD
CLASS="command"
>paragraph_out</KBD
>.</P
><P
CLASS="para"
>Examples of <KBD
CLASS="command"
>PLVprs.wrap</KBD
> are shown in the following sections.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.4.2"
>10.1.4.2 display_wrap procedure</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>display_wrap</KBD
> procedure<A
CLASS="indexterm"
NAME="ch10-idx-998720-0"
></A
> comes in handy when you only want to display the end result&nbsp;-- the wrapped string. If you have no need to store that string in a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table or a single string variable for further manipulation, call <KBD
CLASS="command"
>display_wrap</KBD
>. Then you will not have to declare temporary data structures to hold the wrapped text until it is displayed.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE display_wrap
  (text_in IN VARCHAR2,
   line_length IN INTEGER := 80,
   prefix_in IN VARCHAR2 := NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first parameter, <KBD
CLASS="command"
>text_in</KBD
>, is the string to be wrapped and then displayed. The second argument, <KBD
CLASS="command"
>line_length</KBD
>, is the length of the line within which the string is wrapped. The third argument, <KBD
CLASS="command"
>prefix_in</KBD
>, allows you to specify an optional prefix to display before each line of the wrapped string.</P
><P
CLASS="para"
>Here is an example of <KBD
CLASS="command"
>display_wrap</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVprs.display_wrap (RPAD ('a string',120,' to remember'),30);
a string to remember to
remember to remember to
remember to remember to
remember to remember to
remember to remember to</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The implementation of <KBD
CLASS="command"
>display_wrap</KBD
> is short and sweet. It calls the <KBD
CLASS="command"
>wrap</KBD
> procedure to fill up a locally declared <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table with the wrapped lines of text. It then calls <KBD
CLASS="command"
>PLVtab.display</KBD
> to display the contents of that table.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>p</KBD
> package of PL/Vision makes use of the <KBD
CLASS="command"
>display_wrap</KBD
> procedure to automatically wrap long lines of text. As a result, when you call <KBD
CLASS="command"
>p.l</KBD
>, you don't have to worry about the DBMS_OUTPUT restriction of 255 characters displayed in a string. Instead, it will automatically check the length of the string and wrap the output as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ELSIF LENGTH (line_in) &gt; 80
THEN
   PLVprs.display_wrap (line_in, 75, NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now why did I include a third argument of NULL in my call to <KBD
CLASS="command"
>display_wrap</KBD
>? That (lack of a) value is, after all, the default. I could simply have called <KBD
CLASS="command"
>display_wrap</KBD
> as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVprs.display_wrap (line_in, 75);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and received the same results.</P
><P
CLASS="para"
>Usually I am a strong advocate of typing only the absolute minimum necessary to get the job done. Have I violated my own guidelines? Not really. I have, in fact, typed exactly what I needed to get the job done. The question you should now ask is: What is my "job" or requirement? I want to display a wrapped string without any prefix. The way I do that is to pass NULL for the prefix; hence, the inclusion of three arguments. </P
><P
CLASS="para"
>Notice that I did not state my requirement as follows: "I want to display a wrapped string with the default prefix." If that were my desire, I <EM
CLASS="emphasis"
>should</EM
> pass just two arguments. That way, if the default ever changes, my call to <KBD
CLASS="command"
>display_wrap</KBD
> will automatically adapt to the new value. But in the <KBD
CLASS="command"
>p.l</KBD
> package I would not want the output from <KBD
CLASS="command"
>PLVprs.display_wrap</KBD
> to change when the default value changes. I really do want a NULL value, regardless of the actual default value for the <KBD
CLASS="command"
>display_wrap</KBD
> procedure. In <KBD
CLASS="command"
>p.l</KBD
>'s use of <KBD
CLASS="command"
>display_wrap</KBD
>, in other words, the fact that the desired prefix (none) is the same as the default is nothing more than a coincidence.</P
><P
CLASS="para"
>This distinction between needing the default value and happening to match the default value is an important one. If you simply have a coincidence, do not rely on the default value. Instead, pass in the value, even if it is currently the default and not, strictly speaking, needed. Your code will be less likely to break as the underlying layers of code you rely on change.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch10-SECT-1.4.3"
>10.1.4.3 wrapped_string function</A
></H4
><P
CLASS="para"
>The last string-wrapping program is the <KBD
CLASS="command"
>wrapped_string</KBD
> function<A
CLASS="indexterm"
NAME="ch10-idx-998721-0"
></A
>. This function returns a string with the wrapped lines of text concatenated together, with newline characters after every wrapped line. The specification for <KBD
CLASS="command"
>wrapped_string</KBD
> is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION wrapped_string
  (text_in IN VARCHAR2,
   line_length IN INTEGER := 80,
   prefix_in IN VARCHAR2 := NULL)
RETURN VARCHAR2;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first argument, <KBD
CLASS="command"
>text_in</KBD
>, is the string to be wrapped and then displayed. The second argument, <KBD
CLASS="command"
>line_length</KBD
>, is the length of the line within which the string is wrapped. The third argument, <KBD
CLASS="command"
>prefix_in</KBD
>, allows you to specify an optional prefix to display before <EM
CLASS="emphasis"
>each</EM
> line of the wrapped string.</P
><P
CLASS="para"
>This function is useful in situations (such as that currently found in Oracle Developer/2000 Version 1) where you cannot reference and use <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> tables. The <KBD
CLASS="command"
>wrapped_string</KBD
> returns the text in a string which can then be immediately displayed in the right format (because of the embedded newline characters) or passed to another program which works with the wrapped <A
CLASS="indexterm"
NAME="ch10-idx-998722-0"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998722-1"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998722-2"
></A
><A
CLASS="indexterm"
NAME="ch10-idx-998722-3"
></A
>text.</P
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="AUTOID-12601"
>Special Notes on PLVprs</A
></H4
><P
CLASS="para"
>Here are some factors to consider when working with PLVprs:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>PLVprs</KBD
> does not currently recognize many nonprinting characters as delimiters (only newline and tab are in the predefined delimiter lists). If you have, for example, a backspace character in your string, this will not be treated as a delimiter. You can, of course, define your own delimiter list and then pass that set of characters to PLVprs's program.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When you wrap a string, all carriage returns are replaced with single characters. Your "hard-coded" line breaks will be ignored in the wrap process.<A
CLASS="indexterm"
NAME="ch10-idx-998725-0"
></A
></P
></LI
></UL
></DIV
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch09_06.htm"
TITLE="9.6 Implementing load_  from_dbms"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.6 Implementing load_  from_dbms"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch10_02.htm#ch10-SECT-2.3"
TITLE="10.2 PLVtkn: Managing PL/SQL Tokens"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.2 PLVtkn: Managing PL/SQL Tokens"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>9.6 Implementing load_  from_dbms</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10.2 PLVtkn: Managing PL/SQL Tokens</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
