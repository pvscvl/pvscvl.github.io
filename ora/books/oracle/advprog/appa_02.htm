<HTML
><HEAD
><TITLE
>[Appendix A] A.2 Solutions</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:32:44Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="appa_01.htm"
TITLE="A. Appendix: PL/SQL Exercises"><LINK
REL="prev"
HREF="appa_01.htm"
TITLE="A.1 Exercises"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appa_01.htm"
TITLE="A.1 Exercises"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: A.1 Exercises"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="appendix"
REL="up"
HREF="appa_01.htm"
TITLE="A. Appendix: PL/SQL Exercises"
>Appendix A<BR>Appendix: PL/SQL Exercises</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>&nbsp;</TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="appa-19877"
>A.2 Solutions</A
></H2
><P
CLASS="para"
>This section contains the answers to the exercises shown earlier in this appendix.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-SECT-2.1"
>A.2.1 Conditional Logic</A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Rewrite the following IF statements so that you do not use the IF statement to set the value of no_revenue. What is the difference between the two statements?</EM
><A
CLASS="indexterm"
NAME="appa-idx-38736-0"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38736-1"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38736-2"
></A
></P
><P
CLASS="para"
>The first IF statement can be simplified to:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>no_revenue := NVL (total_sales, 1) &lt;= 0;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I use NVL to make sure that <KBD
CLASS="command"
>no_revenue</KBD
> is set to FALSE, as would happen in the original IF statement. Without using NVL, I will set <KBD
CLASS="command"
>no_revenue</KBD
> to NULL if <KBD
CLASS="command"
>total_sales</KBD
> is NULL.</P
><P
CLASS="para"
>The second statement is a bit more complicated, again due to the complexities of handling NULL values. If <KBD
CLASS="command"
>total_sales</KBD
> is NULL, the IF statement does not assign a value to <KBD
CLASS="command"
>no_revenue</KBD
> at all. NULL is never less than or equal to any number. So I still need an IF statement, but not (strictly speaking!) to assign a value to <KBD
CLASS="command"
>no_revenue</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF total_sales IS NOT NULL
THEN
   no_revenue := total_sales &lt;= 0;
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Rewrite the following IF statement to work as efficiently as possible under all conditions, given the following information: the</EM
> <KBD
CLASS="command"
>calc_totals</KBD
> <EM
CLASS="emphasis"
>numeric function takes 3 minutes to return its value, while the</EM
> <KBD
CLASS="command"
>overdue_balance</KBD
> <EM
CLASS="emphasis"
>Boolean function returns TRUE/FALSE in less than a second.</EM
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF NOT overdue_balance (company_id_in =&gt; 1005)
THEN
   IF calc_totals (1994, company_id_in =&gt; 1005)
   THEN
      display_sales_figures (1005);
   ELSE
      contact_vendor
   END IF;
ELSE
   contact_vendor;
END IF;<A
CLASS="indexterm"
NAME="appa-idx-38737-0"
></A
></PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Rewrite the following IF statement to get rid of unnecessary nested IFs:</EM
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF salary &lt; 10000 
THEN 
   bonus := 2000;
ELSIF salary &lt; 20000 
THEN 
   bonus := 1500;
ELSIF salary &lt; 40000 
THEN 
   bonus := 1000;
ELSE
   bonus := 500;
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Which procedure will never be executed in this IF statement?</P
><P
CLASS="para"
>The call to <KBD
CLASS="command"
>queue_order_for_addtl_parts</KBD
> will never run since the previous ELSIF clause will always be true first.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-SECT-2.2"
>A.2.2 <A
CLASS="indexterm"
NAME="appa-idx-38738-0"
></A
>Loops</A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>How many times does the following loop execute?</EM
></P
><P
CLASS="para"
>Not a single time. The first number in the range scheme must <EM
CLASS="emphasis"
>always</EM
> be the smaller value.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Select the type of loop (FOR, WHILE, simple) appropriate to meet each of the following requirements:</EM
></P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
>Numeric FOR loop.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Simple or WHILE loop. The main thing is to not use a FOR loop since there is a conditional exit.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Display the name and address of each employee returned by the cursor. Cursor FOR loop.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>WHILE loop, since there are conditions under which you do not want the loop body to execute even a single time.</P
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Identify the problems with (or areas for improvement in) the following loops. How would you change the loop to improve it?</EM
></P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not use a generic loop index name (i). In addition, the conditional EXIT from the FOR loop should be removed. Instead, use a FOR loop that loops from 1 to 76 (can you see why?).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>This loop relies on two diferent FETCH statements. Better off using a simple loop and just a single FETCH inside the loop. In addition, you should not EXIT from inside a WHILE loop. You should instead rely on the loop boundary condition.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Never attempt to change the values used in the range scheme. It will not actually affect the execution of the loop, since the range scheme is evaluated only once, at the time the loop begins. Such an assignment remains, however, a very bad programming practice.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>First, this program will not compile, since <KBD
CLASS="command"
>emp_rec</KBD
> record has not been defined. Second, you don't really need to declare that record because you should instead use instead a cursor FOR loop to reduce code volume.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not use EXIT WHEN inside WHILE loop. Should only rely on changes in loop boundary condition.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You should not use a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> loop at all. Instead employ straight <SPAN
CLASS="acronym"
>SQL</SPAN
> as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UPDATE monthly_sales 
   SET pct_of_sales = 100
 WHERE company_id = 10006
   AND month_number BETWEEN 1 AND 12;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Never declare the cursor loop index (<KBD
CLASS="command"
>emp_rec</KBD
>). The reference to <KBD
CLASS="command"
>emp_rec.salary</KBD
> after the loop references the still-null record declared in the block, not the record filled inside the loop (which has terminated and erased that record). Also, the final CLOSE will attempt to close a closed cursor.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not use a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> loop. Instead, INSERT directly from the SELECT statement.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INSERT INTO occupancy_history (pet_id, name, checkout_date)
   SELECT pet_id, name, checkout_date 
     FROM occupancy
    WHERE checkout_date IS NOT NULL;</PRE
></BLOCKQUOTE
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>How many times does the following WHILE loop execute?</EM
></P
><P
CLASS="para"
>An infinite number of times. This is an infinite WHILE loop. The local module called inside the loop never returns NULL for <KBD
CLASS="command"
>step_out</KBD
>, so <KBD
CLASS="command"
>next_analysis_step</KBD
> is never NULL, so the loop never terminates.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Rewrite the following loop so that you do not use a loop at all.</EM
></P
><P
CLASS="para"
>This is a "phony loop." You don't need the loop or the IF statement. Just execute the code sequentially.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>give_bonus (president_id, 2000000);
give_bonus (ceo_id, 5000000);</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>What statement would you remove from this block? Why?</EM
></P
><P
CLASS="para"
>Remove the declaration of the <KBD
CLASS="command"
>emp_rec</KBD
> record. The cursor FOR loop implicitly declares a record of the right structure for you. In fact, the <KBD
CLASS="command"
>emp_rec</KBD
> record declared right after the cursor is never used in the block.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-SECT-2.3"
>A.2.3 <A
CLASS="indexterm"
NAME="appa-idx-38743-0"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38743-1"
></A
>Exception Handling</A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>In each of the following PL/SQL blocks, a VALUE_ERROR exception is raised (usually by an attempt to place too large a value into a local variable). Identify which exception handler (if any&nbsp;-- the exception could also go unhandled) will handle the exception by writing down the message that will be displayed by the call to PUT_LINE in the exception handler. Explain your choice.</EM
></P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
>VALUE_ERROR is raised because "Steven" has six characters and the maximum length of string is five characters. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> Exception is unhandled. There is no exception section. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>"Inner block" is displayed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>"Inner block" is displayed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>"Outer block" is displayed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>"Outer block" is displayed. The inner NO_DATA_FOUND handler does not come into play.</P
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Write a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block that allows all of the following <SPAN
CLASS="acronym"
>SQL</SPAN
> DML statements to execute, even if the any of the others fail:</EM
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   BEGIN
      UPDATE emp SET empno = 100 WHERE empno &gt; 5000;
   EXCEPTION
      WHEN OTHERS THEN NULL;
   END;
   BEGIN
      DELETE FROM dept WHERE deptno = 10;
   EXCEPTION
      WHEN OTHERS THEN NULL;
   END;
   BEGIN
      DELETE FROM emp WHERE deptno = 10;
   EXCEPTION
      WHEN OTHERS THEN NULL;
   END;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Write a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block that handles <EM
CLASS="emphasis"
>by name</EM
> the following Oracle error:</EM
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-1014: ORACLE shutdown in progress.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The exception handler should handle the error by propagating the exception by in turn raising a VALUE_ERROR exception. Hint: use the EXCEPTION INIT pragma.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   shutting_down EXCEPTION;
   PRAGRA EXCEPTION INIT (shutting_down, 1014);</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   ... code ...
EXCEPTION
   WHEN shutting_down
   THEN
      ... handler ...
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>When the following block is executed, which of these two messages are displayed?</EM
> </P
><P
CLASS="para"
>The ORA-1403 error message is displayed. The exception, in other words, goes unhandled. Since I have defined a local exception with same name as system predefined, that identifier overrides the system exception in this block. So when the SELECT statement raised NO_DATA_FOUND and <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> moves to the exception section, it does not find a match.</P
><P
CLASS="para"
>You could make sure that the system exception is handled by changing the handler as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHEN SYSTEM.NO_DATA_FOUND
THEN
   ...</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By qualifying the name of the exception, you tell <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> which one you want to handle.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>I create the getval package as shown below. I then call DBMS_OUTPUT.PUT_LINE to display the value returned by the <KBD
CLASS="command"
>getval.get</KBD
> function. What is displayed on the screen?</EM
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ERROR at line 1:
ORA-06502: PL/SQL: numeric or value error
ORA-06512: at line 2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The error, in other words, goes unhandled. When I first reference the <KBD
CLASS="command"
>getval.get</KBD
> function, the package data is instantiated for my session. It then attempts to declare the private <KBD
CLASS="command"
>v</KBD
> variable. The default value for the variable is, unfortunately, too large for the variable, so <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> raises the VALUE_ERROR exception. The exception section of the package only can handle exceptions raised in the initialization section of the package, so this error is unhandled and quite unhandleable from within the package itself.<A
CLASS="indexterm"
NAME="appa-idx-38746-0"
></A
></P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-SECT-2.4"
>A.2.4 <A
CLASS="indexterm"
NAME="appa-idx-38747-0"
></A
>Cursors</A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>What cursor-related statements are missing from the following block?</EM
></P
><P
CLASS="para"
><B
CLASS="emphasis.bold"
>Missing a</B
> CLOSE <B
CLASS="emphasis.bold"
>statement and a declaration of the</B
> <KBD
CLASS="command"
>emp_rec</KBD
> <B
CLASS="emphasis.bold"
>record.</B
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>What statement should be <EM
CLASS="emphasis"
>removed</EM
> from the following block?</EM
></P
><P
CLASS="para"
>Remove the declaration of <KBD
CLASS="command"
>emp_rec</KBD
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Name the cursor attribute (along with the cursor name) you would use (if any) for each of the following requirements:</EM
></P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>company_cur%NOTFOUND</KBD
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>SQL%ROWCOUNT</KBD
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>emp_cur%ISOPEN</KBD
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>sales_cur%FOUND</KBD
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>No cursor attribute can be used. Instead, rely on an exception handler for NO_DATA_FOUND.</P
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>What message is displayed in the following block if the SELECT statement does not return a row?</EM
></P
><P
CLASS="para"
>"No data found." If an implicit cursor does not return any rows, <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> raises the NO_DATA_FOUND exception.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>What message is displayed in the following block if there are no employees in department 15?</EM
></P
><P
CLASS="para"
>"No employees in department!" is displayed. This SELECT statement does not find any rows, but since it is a group operation, <SPAN
CLASS="acronym"
>SQL</SPAN
> returns a single value of 0. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>If you fetch past the last record in a cursor's result set, what will happen?</EM
></P
><P
CLASS="para"
>Nothing. <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> does not raise any errors, nor does it return any data into the record or variable list of the FETCH statement.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>How would you change the SELECT statement in the following block's cursor so that the block can display the sum of salaries in each department?</EM
></P
><P
CLASS="para"
>Add a column alias "total sales" right after the SUM (SAL) expression.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Rewrite the following block to use a cursor parameter. Then rewrite to use a local module, as well as a cursor parameter.</P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
>With cursor parameter:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR dept_cur (dept_in IN emp.deptno%TYPE) IS 
      SELECT dname, SUM (sal) total_sales  
        FROM emp
       WHERE deptno = dept_in;
   dept_rec dept_cur%ROWTYPE;
BEGIN
   OPEN dept_cur (10);
   FETCH dept_cur INTO dept_rec;
   DBMS_OUTPUT.PUT_LINE 
      ('Total for department 10 is: ' || tot_rec.total_sales);
   CLOSE dept_cur;
   OPEN dept_cur;
   FETCH dept_cur INTO dept_rec;
   DBMS_OUTPUT.PUT_LINE 
      ('Total for department 20 is: ' || tot_rec.total_sales);
   CLOSE dept_cur;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>With local module and cursor parameter:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR dept_cur (dept_in IN emp.deptno%TYPE) IS 
      SELECT dname, SUM (sal) total_sales  
        FROM emp
       WHERE deptno = dept_in;
   dept_rec dept_cur%ROWTYPE;
   PROCEDURE display_dept (dept_in IN emp.deptno%TYPE) IS 
   BEGIN
      OPEN dept_cur (dept_in);
      FETCH dept_cur INTO dept_rec;
      DBMS_OUTPUT.PUT_LINE 
         ('Total for department ' || TO_CHAR (dept_in) ||
          ' is: ' || tot_rec.total_sales);
      CLOSE dept_cur;
   END;
BEGIN
   display_dept (10);
   display_dept (20);
END;</PRE
></BLOCKQUOTE
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Place the following cursor inside a package, declaring the cursor as a <EM
CLASS="emphasis"
>public</EM
> element (in the specification). The SELECT statement contains all of the columns in the <KBD
CLASS="command"
>emp</KBD
> table, in the same order.</EM
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PACKAGE emp 
IS
   CURSOR emp_cur (dept_in IN INTEGER) RETURN emp%ROWTYPE;
END emp;
PACKAGE emp 
IS
   CURSOR emp_cur (dept_in IN INTEGER) RETURN emp%ROWTYPE
   IS
      SELECT empno, ename, job, mgr, hiredate, sal, comm, deptno
        FROM emp
       WHERE deptno = dept_in;
END emp;<A
CLASS="indexterm"
NAME="appa-idx-38748-0"
></A
></PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-SECT-2.5"
>A.2.5 <A
CLASS="indexterm"
NAME="appa-idx-38749-0"
></A
>Builtin Functions</A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Identify the appropriate builtin to use for each of the following requirements:</EM
></P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Requirement</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Builtin</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Calculate the number of days until the end of the month.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LAST_DAY</P
><P
CLASS="para"
>SYSDATE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Capitalize the first character in a word and lower-case the rest of the word.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INITCAP</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Convert a date to a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TO_CHAR</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Convert a number to a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TO_CHAR</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Convert a string to a date.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TO_DATE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Convert a string to lower case.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LOWER</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Determine the length of a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LENGTH</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Determine the place of a character in the collating sequence of the character set used by the database.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ASCII</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Extract the last four characters in a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SUBSTR</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Extract the word found between the first and second _ delimiters in a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INSTR and SUBSTR</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fill out a number in a string with leading zeroes.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LPAD</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Find the last blank in a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INSTR</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Find the Saturday nearest to the last day in March 1992.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>ROUND</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Find the third S in a string</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>UPPER and INSTR</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Get the first day in the month for a specified date.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>TRUNC</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>How many months are between <KBD
CLASS="command"
>date1</KBD
> and <KBD
CLASS="command"
>date2</KBD
>?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>MONTHS_BETWEEN</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>I store all my names in uppercase in the database, but want to display them in reports in upper- and lowercase.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>INITCAP</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If it is High Noon in New York, what time is it in Calcutta?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NEW_TIME</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Remove a certain prefix from a string (for example, change <KBD
CLASS="command"
>std_company_id</KBD
> to <KBD
CLASS="command"
>company_id</KBD
>).</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LTRIM or (better yet) SUBSTR</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Replace all instances of _ with a #.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>REPLACE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return the error message associated with a <SPAN
CLASS="acronym"
>SQL</SPAN
> error code.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SQLERRM</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return the largest integer less than a specified value.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>FLOOR or (TRUNC and DECODE)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Review all new hires on the first Wednesday after they'd been working for three months.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>NEXT_DAY</P
><P
CLASS="para"
>ADD_MONTHS</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Strip all leading numeric digits from a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LTRIM</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>What is the current date and time?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SYSDATE</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>What is the date of the last day in the month?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>LAST_DAY</P
></TD
></TR
></TBODY
></TABLE
>
<p>
</LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="appa-idx-38750-0"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38750-1"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38750-2"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38750-3"
></A
>What portion of the string "Curious George deserves what he gets!" (assigned to variable <KBD
CLASS="command"
>curious_george</KBD
>) is returned by each of the following calls to SUBSTR:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SUBSTR Usage</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, -1)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>!</PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, 1, 7)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>Curious</PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, 9 6)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>George</PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, -8, 2)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>he</PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george,
        INSTR (curious_george, -1, ' ') + 1)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>gets!</PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george,
        INSTR (curious_george, -1, ' ', 3) + 1,
        LENGTH ('cute'))</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>what</PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, -1 *
        LENGTH (curious_george))</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <P
CLASS="para"
>entire string</P
> </TD
></TR
></TBODY
></TABLE
>
<p>
</LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-SECT-2.6"
>A.2.6 <A
CLASS="indexterm"
NAME="appa-idx-38751-0"
></A
>Builtin Packages</A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>What program would you use to calculate the elapsed time of your PL/SQL code execution? To what degree of accuracy can you obtain these timings? <A
CLASS="indexterm"
NAME="appa-idx-38752-0"
></A
></P
><P
CLASS="para"
>The DBMS_UTILITY.GET_TIME function returns the number of hundredths of seconds that have elapsed since the <EM
CLASS="emphasis"
>last</EM
> call to DBMS_UTILITY.GET_TIME. So if you compare consecutive calls to this builtin, you have the elapsed time down to the hundredth of a second.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="appa-idx-38753-0"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38753-1"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38753-2"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38753-3"
></A
><EM
CLASS="emphasis"
>What would you call to make your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program pause for a specified number of seconds? What other techniques can you think of which would have this same effect?</EM
></P
><P
CLASS="para"
>The DBMS_LOCK.SLEEP procedure will put your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program to sleep for the number of seconds you pass to it. You can also make a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program pause by calling a number of the DBMS_PIPE builtins, such as RECEIVE_MESSAGE and SEND_MESSAGE. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="appa-idx-38754-0"
></A
><EM
CLASS="emphasis"
>What package can you use to determine if the current session has issued a COMMIT? How would you go about obtaining this information?</EM
></P
><P
CLASS="para"
>The DBMS_LOCK allows you to determine if a COMMIT has occurred. You use the REQUEST procedure to request a lock specifying TRUE for <KBD
CLASS="command"
>release_on_commit</KBD
>. Then later in your program you can request this same lock. If you can get the lock, a commit has been performed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>What do you see when you execute the following statements in SQL*Plus (assuming that you have already called SET SERVEROUTPUT ON)?</EM
></P
><P
CLASS="para"
>I will show the output from each of these calls and then explain them afterwards.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute DBMS_OUTPUT.PUT_LINE (100);
100
SQL&gt; execute DBMS_OUTPUT.PUT_LINE ('     Five spaces in');
Five spaces in
SQL&gt; execute DBMS_OUTPUT.PUT_LINE (NULL);
ERROR at line 1:
ORA-06550: line 1, column 7:
PLS-00307: too many declarations of 'PUT_LINE' match this call
SQL&gt; execute DBMS_OUTPUT.PUT_LINE (SYSDATE &lt; SYSDATE - 5);
ERROR at line 1:
ORA-06550: line 1, column 7:
PLS-00306: wrong number or types of arguments in call to 'PUT_LINE'
SQL&gt; execute DBMS_OUTPUT.PUT_LINE (TRANSLATE ('abc', 'a', NULL));
SQL&gt; execute DBMS_OUTPUT.PUT_LINE (RPAD ('abc', 500, 'def'));
ERROR at line 1:
ORA-20000: ORU-10028: line length overflow, limit of 255 bytes per line</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first answer of "100" verifies that the DBMS_OUTPUT.PUT_LINE procedure (<SPAN
CLASS="acronym"
>DOPL</SPAN
> for short) puts a line of information to the screen or standard out from inside your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program. In the second answer, you notice that the text is <EM
CLASS="emphasis"
>not</EM
> five spaces in. That is because <SPAN
CLASS="acronym"
>DOPL</SPAN
> automatically LTRIMs your text on display in SQL*Plus. When I tried to display NULL, DBMS_OUTPUT could not figure out which of the overloaded versions of PUT_LINE to call because NULL does not have a datatype. </P
><P
CLASS="para"
>When I tried to display the value returned by SYSDATE &lt; SYSDATE - 5, <SPAN
CLASS="acronym"
>DOPL</SPAN
> raised an exception because it is not overloaded for Boolean values. </P
><P
CLASS="para"
>When I tried to display the output from the TRANSLATE function, <EM
CLASS="emphasis"
>nothing happened</EM
>! This non-event was caused by two factors: first, when you specify NULL for the replacement character set in TRANSLATE, that builtin returns NULL. Second, when you try to display a NULL string (which is different from the NULL literal) or blank line, <SPAN
CLASS="acronym"
>DOPL</SPAN
> simply ignores your request and does nothing.</P
><P
CLASS="para"
>When I attempted to display the string "abc" right-padded to a length of 500 with the string "def", I was reminded that <SPAN
CLASS="acronym"
>DOPL</SPAN
> cannot handle pieces of data with more than 255 bytes.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>When an error occurs in your program, you want to be able to see which program is currently executing. What builtin packaged function would you call to get this information? If the current program is a procedure named <KBD
CLASS="command"
>calc_totals</KBD
> in the analysis package, what would you see when you call the builtin function?</EM
></P
><P
CLASS="para"
>The DBMS_UTILITY.FORMAT_CALL_STACK returns the current execution stack in <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>. If the current program is analysis.calc_totals, however, the string returned by FORMAT_CALL_STACK only tells you that you are executing analysis. It does not know which program <EM
CLASS="emphasis"
>inside</EM
> the package you are running.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>You want to build a utility for DBAs that would allow them to create an index from within a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program. Which package would you use? Which programs inside that package would be needed?</EM
></P
><P
CLASS="para"
>To perform <SPAN
CLASS="acronym"
>SQL</SPAN
> DDL inside <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>, you use the DBMS_SQL package. With this package, you dynamically construct the string to create the index and then call the following elements of DBMS_SQL: OPEN_CURSOR to allocate memory for the dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
>; PARSE to parse the statement; and CLOSE_CURSOR to close the cursor. Since you are working with DDL, a parse also executes and commits.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>You need to run a stored procedure named <KBD
CLASS="command"
>update_data</KBD
> every Sunday at 4 AM to perform a set of batch processes. Which builtin package would you use to perform this task?</EM
></P
><P
CLASS="para"
>You need to pass a string to the submit program to tell it how often to run <KBD
CLASS="command"
>update_data</KBD
>. What would that string be? The DBMS_JOB package allows you to queue up stored procedures to be executed on a regular or one-time basis. You would call the SUBMIT program of DBMS_JOB. When you call SUBMIT, you pass it a string (which will be executed as dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>) defining the next time the program will be executed. SYSDATE stands for now and this is the string which means "every Sunday at 4 AM":</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>'NEXT_DAY (TRUNC (SYSDATE), ''SUNDAY'') + 4/24'</PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-SECT-2.7"
>A.2.7 <A
CLASS="indexterm"
NAME="appa-idx-38755-0"
></A
>Modules</A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>In each of the following modules, identify changes you would make to improve their structure, performance or functionality.</EM
></P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
>Use single RETURN statement at end of function to return value. Put in assertion routine or other form of check to handle situation when invalid (unhandled) status code is passed to routine.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Either remove the OUT parameter or change the function to a procedure.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not use a RAISE statement to handle successful completion of function. Consider using explicit cursor rather than implicit cursor.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not issue a RETURN from inside a loop. Also, do not issue a RETURN from inside a procedure. </P
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Given the header for <KBD
CLASS="command"
>calc_profit</KBD
> below, which of the following calls to <KBD
CLASS="command"
>calc_profit</KBD
> are valid:</EM
></P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Call to calc_profit</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Good/Bad? Why?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>calc_profit 
   (1005, profit_level, 1995, 'ALL', 'FINANCE');</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Great</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>calc_profit 
   (new_company, profit_level);</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Bad. Must supply value for fiscal year.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>calc_profit
   (company_id_in =&gt; 32, fiscal_year_in =&gt; 1995,
    profit_out =&gt; big_number);</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Good. All three mandatory params are present, even if not in right order.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>calc_profit
   (company_id_in =&gt; 32, division_in =&gt; 'ACCTG',
    profit_out =&gt; 1000);</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Bad. The actual <KBD
CLASS="command"
>profit_out</KBD
> argument must be a variable.</P
></TD
></TR
></TBODY
></TABLE
><p>
</LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Suppose you had to use <KBD
CLASS="command"
>dispdates</KBD
> to satisfy the following requirement: "Display the list of company start dates stored in the date table without any header." I can think of two ways do this:</EM
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>dispdates (company_list, num_companies);</PRE
></BLOCKQUOTE
><P
CLASS="para"
><EM
CLASS="emphasis"
>and</EM
></P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>dispdates (company_list, num_companies, NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
><EM
CLASS="emphasis"
>Which of these implementations would you choose and why? Is there any reason to choose one over the other?</EM
></P
><P
CLASS="para"
>It would be tempting to take the first approach. It is less typing. The second form is, however, the correct solution. The reason is this: you were asked to display a list without a header&nbsp;-- with, in other words, a NULL header. You were not asked to display a list with the default header. If you were asked to use the default value, then you can and should simply rely on the default. If you were asked to skip the header, then you should explicitly request a NULL header when you call dispdates. That way, if the default value ever changes, your code is not affected and the format of the display does not change.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-SECT-2.8"
>A.2.8 Module Evaluation: Foreign Key Lookup</A
></H3
><P
CLASS="para"
>You were asked to evaluate a function that performs a <A
CLASS="indexterm"
NAME="appa-idx-38756-0"
></A
>foreign key lookup. My evaluation follows. You will undoubtedly have found other problems as well.</P
><P
CLASS="para"
>There are many, many problems with the <KBD
CLASS="command"
>getkey_clrtyp</KBD
> function:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>It is ugly. Everything is in uppercase, which makes the code hard to read. Indentation in the body of the function is inconsistent. All the code between the BEGIN and END statements should be indented. Then within an IF statement, all code should be indented another level. It indents unevenly and also uses different formats for IF statement indentation within this single program. This poor formatting makes it even more difficult to understand the logical flow of the program.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>There are side-effects with IN OUT parameters. A function should never have OUT or IN OUT parameters. The point of a function is to return a value through its RETURN clause. If you need to return multiple values, you can either return a composite data structure (a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table or record) or change the function to a procedure.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The <KBD
CLASS="command"
>nu_inout</KBD
> argument does not need to be IN OUT, only OUT. The <KBD
CLASS="command"
>nu_inout</KBD
> argument is only referenced on the left side of an assignment operator. It is, therefore, simply an OUT parameter.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>No value is returned if <KBD
CLASS="command"
>name_inout</KBD
> is NULL. If the <KBD
CLASS="command"
>name_inout</KBD
> argument is NULL, then this function never executes a RETURN statement. This raises a runtime error and is a fatal flaw in a function's design. You should instead use an approach in which the last line of your function issues the single RETURN for that function. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The cursor is not closed if no record is found. This is a stylistic as opposed to functional weakness. The cursor <EM
CLASS="emphasis"
>will</EM
> be closed when the function terminates, since it is declared and opened locally. If the cursor were based in a package, on the other hand, it would stay open until closed explicitly when the session ends. Always closing cursors is a good habit to develop&nbsp;-- and you can't go wrong.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>"Magic values" of 0, 1, and 2 are used as return values of the function. The return values of this function are obscure and poorly designed. There is no way to know by simply glancing at the function what these return values signify. It would be even more difficult for a user of the function to use <KBD
CLASS="command"
>getkey_clrtyp</KBD
> properly simply by looking at the header of the function. You should always avoid these kinds of "magic values" and literals in your code. If specific values have special meanings, you are much better off defining these as constants in a package and then referencing those constants both inside and outside the function (see the recoding of the function below for an example of this approach).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The function name does not describe the value returned. The name <KBD
CLASS="command"
>getkey_clrtyp</KBD
> describes in the most general terms the objective of the function, but it in no way indicates what kind of value is being returned by the function. Since a function encapsulates a returned value, the name of the function should describe the value.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>There are multiple RETURN statements. A very fundamental rule for structured programming is that there should be one way in to a program and one way out of the program. In <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> terms, this means that you should only have one RETURN statement in the executable section of the function. When you have more than one RETURN, the code is more difficult to understand, debug and enhance.[<A
CLASS="footnote"
HREF="#appa-pgfId-38455"
>1</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="appa-pgfId-38455"
>[1]</A
> You should also have a RETURN statement for each exception handler, but that is a separate issue and in no way contradicts this structured programming rule.</P
></DIV
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>There is an unused variable. I declare the <KBD
CLASS="command"
>typ_nu</KBD
> variable, but then never use it in the program. You are much better off without such clutter.</P
></LI
></UL
><P
CLASS="para"
>Did you find any other problems? I would not be the least bit surprised. Every time I have gone over this program in a class, the students have uncovered additional areas for improvement.<A
CLASS="indexterm"
NAME="appa-idx-38757-0"
></A
></P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="appa-SECT-2.8.1"
>A.2.8.1 A rewrite of the <A
CLASS="indexterm"
NAME="appa-idx-38758-0"
></A
>getkey_clrtyp function</A
></H4
><P
CLASS="para"
>The following version of <KBD
CLASS="command"
>getkey_clrtyp</KBD
> incorporates many of the comments in the previous section. Notice that it is no longer even a function; I have changed it to a procedure so that I can take in and return as many values as needed.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE getkey_clrtyp 
   (name_inout IN OUT VARCHAR2, 
     nu_inout IN OUT NUMBER,
     get_status_out OUT INTEGER) 
IS
   CURSOR clrtyp_cur IS 
      SELECT typ_nu, type_ds 
        FROM caller_type
       WHERE type_ds LIKE name_inout || '%';

   clrtyp_rec clrtyp_cur%ROWTYPE;
   next_rec clrtyp_cur%ROWTYPE;
   retval NUMBER := NULL;
BEGIN
   IF name_inout IS NULL
   THEN
      get_status_out := get.nullname;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   ELSE</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>      OPEN clrtyp_cur; FETCH ...;
      IF clrtyp_cur%NOTFOUND
      THEN
         get_status_out := get.notfound;
      ELSE
         FETCH clrtyp_cur INTO next_rec;
         IF clrtyp_cur%NOTFOUND
         THEN 
            get_status_out := get.unique_match;
         ELSE 
            get_status_out := get.dup_match;
         END IF;
         nu_inout := clrtyp_rec.cllr_typ_nu;
         name_inout := clrtyp_rec.cllr_typ_ds;
      END IF;
      CLOSE clrtyp_cur;
   END IF;
END getkey_clrtyp;<A
CLASS="indexterm"
NAME="appa-idx-38759-0"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38759-1"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appa_01.htm"
TITLE="A.1 Exercises"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: A.1 Exercises"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>A.1 Exercises</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>&nbsp;</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
