<HTML
><HEAD
><TITLE
>[Appendix A] Appendix: PL/SQL Exercises</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:32:36Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="part06.htm"
TITLE="VI. Testing Your Knowledge"><LINK
REL="prev"
HREF="part06.htm"
TITLE="VI. Testing Your Knowledge"><LINK
REL="next"
HREF="appa_02.htm#appa-SECT-2.1"
TITLE="A.2 Solutions"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part06.htm"
TITLE="VI. Testing Your Knowledge"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: VI. Testing Your Knowledge"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
>Appendix A</SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appa_02.htm#appa-SECT-2.1"
TITLE="A.2 Solutions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: A.2 Solutions"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="appendix"
><H1
CLASS="appendix"
><A
CLASS="title"
NAME="appa-32435"
>A. Appendix: PL/SQL Exercises</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#appa-10309"
TITLE="A.1 Exercises"
>Exercises</A
><BR><A
CLASS="sect1"
HREF="appa_02.htm#appa-SECT-2.1"
TITLE="A.2 Solutions"
>Solutions</A
></P
><P
></P
></DIV
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="appa-idx-38718-0"
></A
>The exercises included in this appendix are designed to enhance your ability to write well-structured <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> programs, and also to identify problems with existing code. I recommend that you test out your baseline <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> skills on these exercises before you explore Parts III through V of this book, where you will learn how to apply your skills to building robust and reusable packages.</P
><P
CLASS="para"
>For solutions to these exercises, see <A
CLASS="xref"
HREF="appa_02.htm#appa-SECT-2.1"
>Section A.2, "Solutions"</A
> later in this appendix.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="appa-10309"
>A.1 Exercises</A
></H2
><P
CLASS="para"
>The exercises are arranged by topic:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>Conditional logic</TD
></TR
><TR
><TD
CLASS="member"
>Loops</TD
></TR
><TR
><TD
CLASS="member"
>Exception handling</TD
></TR
><TR
><TD
CLASS="member"
>Cursors</TD
></TR
><TR
><TD
CLASS="member"
>Builtin functions</TD
></TR
><TR
><TD
CLASS="member"
>Builtin packages</TD
></TR
><TR
><TD
CLASS="member"
>Modules</TD
></TR
><TR
><TD
CLASS="member"
>Module evaluation</TD
></TR
></TABLE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-15663"
>A.1.1 Conditional Logic<A
CLASS="indexterm"
NAME="appa-idx-38719-0"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38719-1"
></A
></A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Rewrite the following IF statements so that you do <EM
CLASS="emphasis"
>not</EM
> use an <A
CLASS="indexterm"
NAME="appa-idx-38720-0"
></A
>IF statement to set the value of <KBD
CLASS="command"
>no_revenue</KBD
>. What is the difference between these two statements? How does that difference affect your answer?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF total_sales &lt;= 0
THEN
   no_revenue := TRUE;
ELSE
   no_revenue := FALSE;
END IF;

IF total_sales &lt;= 0
THEN
   no_revenue := TRUE;
ELSIF total_sales &gt; 0
THEN
   no_revenue := FALSE;
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="appa-idx-38721-0"
></A
>Rewrite the following IF statement to work as efficiently as possible under all conditions, given the following information: the <KBD
CLASS="command"
>calc_totals</KBD
> numeric function takes three minutes to return its value, while the <KBD
CLASS="command"
>overdue_balance</KBD
> Boolean function returns TRUE/FALSE in less than a second.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF calc_totals (1994, company_id_in =&gt; 1005) AND
   NOT overdue_balance (company_id_in =&gt; 1005) 
THEN
   display_sales_figures (1005);
ELSE
   contact_vendor;
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Rewrite the following IF statement to get rid of unnecessary nested IFs:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF salary &lt; 10000 
THEN 
   bonus := 2000;
ELSE
   IF salary &lt; 20000 
   THEN 
      bonus := 1500;
   ELSE
      IF salary &lt; 40000 
      THEN 
         bonus := 1000;
      ELSE
         bonus := 500;
      END IF;
   END IF;
END IF;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Which procedure will <EM
CLASS="emphasis"
>never</EM
> be executed in this IF statement?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>IF (order_date &gt; SYSDATE) AND order_total &gt;= min_order_total
THEN
   fill_order (order_id, 'HIGH PRIORITY');
ELSIF (order_date &lt; SYSDATE) OR
      (order_date = SYSDATE)
THEN
   fill_order (order_id, 'LOW PRIORITY');
ELSIF order_date &lt;= SYSDATE AND order_total &lt; min_order_total
THEN
   queue_order_for_addtl_parts (order_id);
ELSIF order_total = 0
THEN
   disp_message (' No items have been placed in this order!');
END IF;</PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-26986"
>A.1.2 Loops<A
CLASS="indexterm"
NAME="appa-idx-38722-0"
></A
></A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>How many times does the following loop execute?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR year_index IN REVERSE 12 .. 1
LOOP
   calc_sales (year_index);
END LOOP:</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Select the type of loop (FOR, WHILE, simple) appropriate to meet each of the following requirements:</P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the status of each company whose company IDs are stored in a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table to closed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>For each of twenty years in the loan-processing cycle, calculate the outstanding loan balance for the specified customer. If the customer is a preferred vendor, stop the calculations after twelve years.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Display the name and address of each employee returned by the cursor.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Scan through the list of employees in the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table, keeping count of all salaries greater than $50,000. Don't even start the scan, though, if the table is empty or if today is a Saturday or if the first employee in the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table is the president of the company.</P
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Identify the problems with (or areas for improvement in) the following loops. How would you change the loop to improve it?</P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR i IN 1 .. 100
LOOP
   calc_totals (i);
   IF i &gt; 75
   THEN
      EXIT;
   END IF;
END LOOP;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>OPEN emp_cur;
FETCH emp_cur INTO emp_rec;
WHILE emp_cur%FOUND
LOOP
   calc_totals (emp_rec.salary);
   FETCH emp_cur INTO emp_rec;
   EXIT WHEN emp_rec.salary &gt; 100000;
END LOOP;
CLOSE emp_cur;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR a_counter IN lo_val .. hi_val
LOOP
   IF a_counter &gt; lo_val * 2
   THEN
      hi_val := lo_val;
   END IF;
END LOOP;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR emp_cur IS SELECT salary FROM emp;
   emp_rec emp_cur%ROWTYPE
BEGIN
   OPEN emp_cur;
   LOOP
      FETCH emp_cur INTO emp_rec;
      EXIT WHEN emp_cur%NOTFOUND;
      calc_totals (emp_rec.salary);
   END LOOP;
   CLOSE emp_cur;
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>WHILE no_more_data
LOOP
   read_next_line (text);
   no_more_data := text IS NULL;
   EXIT WHEN no_more_data;
END LOOP;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR month_index IN 1 .. 12
LOOP
   UPDATE monthly_sales 
      SET pct_of_sales = 100
    WHERE company_id = 10006
      AND month_number = month_index;
END LOOP;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR emp_cur IS SELECT ... ;
BEGIN
   FOR emp_rec IN emp_cur
   LOOP
      calc_totals (emp_rec.salary);
   END LOOP;
   IF emp_rec.salary &lt; 10000
   THEN
      DBMS_OUTPUT.PUT_LINE ('Give ''em a raise!');
   END IF;
   CLOSE emp_cur;
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR checked_out_cur IS 
      SELECT pet_id, name, checkout_date 
        FROM occupancy
       WHERE checkout_date IS NOT NULL;
BEGIN
   FOR checked_out_rec IN checked_out_cur 
   LOOP
      INSERT INTO occupancy_history (pet_id, name, checkout_date)
         VALUES (checked_out_rec.pet_id, 
                 checked_out_rec.name, 
                 checked_out_rec.checkout_date);
   END LOOP;
END;</PRE
></BLOCKQUOTE
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>How many times does the following <A
CLASS="indexterm"
NAME="appa-idx-38723-0"
></A
>WHILE loop execute?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   end_of_analysis BOOLEAN := FALSE;
   CURSOR analysis_cursor IS SELECT ...;
   analysis_rec analysis_cursor%ROWTYPE;
   next_analysis_step NUMBER;
   PROCEDURE get_next_record (step_out OUT NUMBER) IS
   BEGIN
      FETCH analysis_cursor INTO analysis_rec;
      IF analysis_rec.status = 'FINAL'
      THEN
         step_out := 1;
      ELSE
         step_out := 0;
      END IF;
   END;
BEGIN
   OPEN analysis_cursor;
   WHILE NOT end_of_analysis
   LOOP
      get_next_record (next_analysis_step);
      IF analysis_cursor%NOTFOUND AND
         next_analysis_step IS NULL
      THEN
         end_of_analysis := TRUE;
      ELSE
         perform_analysis;
      END IF;
   END LOOP;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Rewrite the following loop so that you do not use a loop at all.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FOR i IN 1 .. 2
LOOP
   IF i = 1
   THEN
      give_bonus (president_id, 2000000);
   ELSIF i = 2
   THEN
      give_bonus (ceo_id, 5000000);
   END IF;
END LOOP;   </PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>What statement would you remove from this block? Why?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR emp_cur IS 
      SELECT ename, deptno, empno 
        FROM emp
       WHERE sal &lt; 2500;
   emp_rec emp_cur%ROWTYPE;
BEGIN
   FOR emp_rec IN emp_cur
   LOOP
      give_raise (emp_rec.empno, 10000);
   END LOOP;
END;<A
CLASS="indexterm"
NAME="appa-idx-38724-0"
></A
></PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-16687"
>A.1.3 Exception Handling<A
CLASS="indexterm"
NAME="appa-idx-38725-0"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38725-1"
></A
></A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In each of the following <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> blocks, a <SPAN
CLASS="acronym"
>VALUE_ERROR</SPAN
><A
CLASS="indexterm"
NAME="appa-idx-38726-0"
></A
> exception is raised (usually by an attempt to place too large a value into a local variable). Identify which exception handler (if any&nbsp;-- the exception could also go unhandled) will handle the exception by writing down the message that will be displayed by the call to <SPAN
CLASS="acronym"
>PUT_LINE</SPAN
> in the exception handler. Explain your choice.</P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   string_of_5_chars VARCHAR2(5);
BEGIN
   string_of_5_chars := 'Steven';
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   string_of_5_chars VARCHAR2(5);
BEGIN
   BEGIN
      string_of_5_chars := 'Steven';
   EXCEPTION
      WHEN VALUE_ERROR
      THEN
         DBMS_OUTPUT.PUT_LINE ('Inner block');
   END;
EXCEPTION
   WHEN VALUE_ERROR
   THEN
      DBMS_OUTPUT.PUT_LINE ('Outer block');
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   string_of_5_chars VARCHAR2(5) := 'Eli';
BEGIN
   BEGIN
      string_of_5_chars := 'Steven';
   EXCEPTION
      WHEN VALUE_ERROR
      THEN
         DBMS_OUTPUT.PUT_LINE ('Inner block');
   END;
EXCEPTION
   WHEN VALUE_ERROR
   THEN DBMS_OUTPUT.PUT_LINE ('Outer block');
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   string_of_5_chars VARCHAR2(5) := 'Eli';
BEGIN
   DECLARE
      string_of_3_chars VARCHAR2(3) := 'Chris';
   BEGIN
      string_of_5_chars := 'Veva';
   EXCEPTION
      WHEN VALUE_ERROR
      THEN DBMS_OUTPUT.PUT_LINE ('Inner block');
   END;
EXCEPTION
   WHEN VALUE_ERROR
   THEN DBMS_OUTPUT.PUT_LINE ('Outer block');
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   string_of_5_chars VARCHAR2(5);
BEGIN
   BEGIN
      string_of_5_chars := 'Steven';
   EXCEPTION
      WHEN VALUE_ERROR
      THEN
         RAISE NO_DATA_FOUND;
      WHEN NO_DATA_FOUND
      THEN
         DBMS_OUTPUT.PUT_LINE ('Inner block');
   END;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      DBMS_OUTPUT.PUT_LINE ('Outer block');
END;
</PRE
></BLOCKQUOTE
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Write a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block that allows all of the following <SPAN
CLASS="acronym"
>SQL</SPAN
> DML statements to execute, even if any of the others fail:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>UPDATE emp SET empno = 100 WHERE empno &gt; 5000;
DELETE FROM dept WHERE deptno = 10;
DELETE FROM emp WHERE deptno = 10;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Write a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block that handles by name the following Oracle error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-1014: ORACLE shutdown in progress.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The exception handler should, in turn, raise a VALUE_ERROR exception. Hint: use the EXCEPTION INIT pragma.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When the following block is executed, which of the two messages shown below are displayed? Explain your choice. </P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Message from Exception Handler</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Output from Unhandled Exception</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Predefined or
programmer-defined?
</PRE
></BLOCKQUOTE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Error at line 1:
ORA-1403: no data found
ORA-6512: at line 5
</PRE
></BLOCKQUOTE
></P
></TD
></TR
></TBODY
></TABLE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   d VARCHAR2(1);
   /* Create exception with a predefined name. */
   no_data_found EXCEPTION; 
BEGIN
   SELECT dummy INTO d FROM dual WHERE 1=2;
   IF d IS NULL 
   THEN
      /* 
      || Raise my own exception, not the predefined 
      || STANDARD exception of the same name.
      */
      RAISE no_data_found; 
   END IF;
EXCEPTION
   /* This handler only responds to the RAISE statement. */
   WHEN no_data_found
   THEN 
      DBMS_OUTPUT.PUT_LINE ('Predefined or programmer-defined?');
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I create the <KBD
CLASS="command"
>getval</KBD
> package as shown below. I then call DBMS_OUTPUT.PUT_LINE to display the value returned by the <KBD
CLASS="command"
>getval.get</KBD
> function. What is displayed on the screen?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CREATE OR REPLACE PACKAGE getval
IS
   FUNCTION get RETURN VARCHAR2;
END getval;
/
CREATE OR REPLACE PACKAGE BODY getval
IS
   v VARCHAR2(1) := 'abc';
   FUNCTION get RETURN VARCHAR2 IS
   BEGIN
      RETURN v;
   END;
BEGIN
   NULL;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE ('Trapped!');
END getval;
/<A
CLASS="indexterm"
NAME="appa-idx-38727-0"
></A
></PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-28382"
>A.1.4 Cursors<A
CLASS="indexterm"
NAME="appa-idx-38728-0"
></A
></A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>What cursor-related statements are missing from the following block?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR emp_cur IS SELECT * FROM emp;
BEGIN
   OPEN emp_cur;
   FETCH emp_cur INTO emp_rec;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>What statement should be <EM
CLASS="emphasis"
>removed</EM
> from the following block?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR emp_cur IS SELECT * FROM emp;
   emp_rec emp_cur%ROWTYPE;
BEGIN
   FOR emp_rec IN emp_cur
   LOOP
      give_raise (emp_rec.empno);
   END LOOP;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Name the cursor attribute (along with the cursor name) you would use (if any) for each of the following requirements:</P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><P
CLASS="para"
>If the FETCH did not return any records from the <KBD
CLASS="command"
>company_cur</KBD
> cursor, exit the loop.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the number of rows deleted exceeded 100, notify the manager.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the <KBD
CLASS="command"
>emp_cur</KBD
> cursor is already open, fetch the next record. Otherwise, open the cursor.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If the FETCH returns a row from the <KBD
CLASS="command"
>sales_cur</KBD
> cursor, display the total sales information.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I use an implicit cursor SELECT statement to obtain the latest date of sales for my store number 45067. If no data is fetched or returned by the SELECT, display a warning.</P
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>What message is displayed in the following block if the SELECT statement does not return a row? </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE display_dname (emp_in IN INTEGER) IS
   department# dept.deptno%TYPE := NULL;
BEGIN
   SELECT deptno INTO department#
     FROM emp
    WHERE empno = emp_in;
   IF department# IS NULL
   THEN
      DBMS_OUTPUT.PUT_LINE ('Dept is not found!');
   ELSE
      DBMS_OUTPUT.PUT_LINE ('Dept is ' || TO_CHAR (department#));
   END IF;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      DBMS_OUTPUT.PUT_LINE ('No data found');
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>What message is displayed in the following block if there are no employees in department 15? </P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE display_dept_count 
IS
   total_count INTEGER := 0;
BEGIN
   SELECT COUNT(*) INTO total_count
     FROM emp
    WHERE deptno = 15;
   IF total_count = 0
   THEN
      DBMS_OUTPUT.PUT_LINE ('No employees in department!');
   ELSE
      DBMS_OUTPUT.PUT_LINE
         ('Count of employees in dept 15 = ' || TO_CHAR (total_count));
   END IF;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      DBMS_OUTPUT.PUT_LINE ('No data found');
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you fetch past the last record in a cursor's result set, what will happen?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>How would you change the SELECT statement in the following block's cursor so that the block can display the sum of salaries in each department?</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR tot_cur IS 
      SELECT deptno, SUM (sal)   
        FROM emp
       GROUP BY deptno;
BEGIN
   FOR tot_rec IN tot_cur
   LOOP
      DBMS_OUTPUT.PUT_LINE 
         ('Total is: ' || tot_rec.total_sales);
   END LOOP;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Rewrite the following block to use a cursor parameter. Then rewrite to use a local module, as well as a cursor parameter.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   CURSOR dept10_cur IS 
      SELECT dname, SUM (sal) total_sales  
        FROM emp
       WHERE deptno = 10;
   dept10_rec dept10_cur%ROWTYPE;
   CURSOR dept20_cur IS 
      SELECT dname, SUM (sal)   
        FROM emp
       WHERE deptno = 20;
   dept20_rec dept20_cur%ROWTYPE;
BEGIN
   OPEN dept10_cur;
   FETCH dept10_cur INTO dept10_rec;
   DBMS_OUTPUT.PUT_LINE 
      ('Total for department 10 is: ' || tot_rec.total_sales);
   CLOSE dept10_cur;
   OPEN dept20_cur;
   FETCH dept20_cur INTO dept20_rec;
   DBMS_OUTPUT.PUT_LINE 
      ('Total for department 20 is: ' || tot_rec.total_sales);
   CLOSE dept20_cur;
END;</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Place the following cursor inside a package, declaring the cursor as a <EM
CLASS="emphasis"
>public</EM
> element (in the specification). The SELECT statement contains all of the columns in the <KBD
CLASS="command"
>emp</KBD
> table, in the same order.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>CURSOR emp_cur (dept_in IN INTEGER) IS
   SELECT empno, ename, job, mgr, hiredate, sal, comm, deptno
     FROM emp
    WHERE deptno = dept_in;<A
CLASS="indexterm"
NAME="appa-idx-38729-0"
></A
></PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-22833"
>A.1.5 Builtin Functions<A
CLASS="indexterm"
NAME="appa-idx-38730-0"
></A
></A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Identify the appropriate builtin to use for each of the following requirements:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Requirement</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Builtin</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Calculate the number of days until the end of the month.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Capitalize the first character in a word and lowercase the rest of the word.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Convert a date to a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Convert a number to a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Convert a string to a date.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Convert a string to lower case.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Determine the length of a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Determine the place of a character in the collating sequence of the character set used by the database.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Extract the last four characters in a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Extract the word found between the first and second _ delimiters in a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fill out a number in a string with leading zeroes.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Find the last blank in a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Find the Saturday nearest to the last day in March 1992.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Find the third S in a string</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Get the first day in the month for a specified date.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>How many months are between <KBD
CLASS="command"
>date1</KBD
> and <KBD
CLASS="command"
>date2</KBD
>?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>I store all my names in uppercase in the database, but want to display them in reports in upper and lowercase.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If it is High Noon in New York, what time is it in Calcutta?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Remove a certain prefix from a string (for example, change <KBD
CLASS="command"
>std_company_id</KBD
> to <KBD
CLASS="command"
>company_id</KBD
>).</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Replace all instances of _ with a #.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return the error message associated with a <SPAN
CLASS="acronym"
>SQL</SPAN
> error code.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Return the largest integer less than a specified value.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Review all new hires on the first Wednesday after they'd been working for three months.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Strip all leading numeric digits from a string.</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>What is the current date and time?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>What is the date of the last day in the month?</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
></TBODY
></TABLE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>What portion of the string "Curious George deserves what he gets!" (assigned to variable <KBD
CLASS="command"
>curious_george</KBD
>) is returned by each of the following calls to SUBSTR:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>1234567890123456789012345678901234567
Curious George deserves what he gets!</PRE
></BLOCKQUOTE
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>SUBSTR Usage</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, -1)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, 1, 7)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, 9, 6)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, -8, 2)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george,
        INSTR (curious_george, -1, ' ') + 1)</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, 
        INSTR (curious_george, ' ', -1, 3) + 1,
        LENGTH ('cute'))</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>SUBSTR (curious_george, -1 * LENGTH (curious_george))</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
></P
>&nbsp;</TD
></TR
></TBODY
></TABLE
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-22282"
>A.1.6 Builtin Packages<A
CLASS="indexterm"
NAME="appa-idx-38731-0"
></A
><A
CLASS="indexterm"
NAME="appa-idx-38731-1"
></A
></A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>What program would you use to calculate the elapsed time of your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> code execution? To what degree of accuracy can you obtain these timings?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>What would you call to make your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program pause for a specified number of seconds? What other techniques can you think of which would have this same effect?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>What package can you use to determine if the current session has issued a COMMIT? How would you go about obtaining this information?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>What do you see when you execute the following statements in SQL*Plus (assuming that you have already called SET SERVEROUTPUT ON):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute DBMS_OUTPUT.PUT_LINE (100);
SQL&gt; execute DBMS_OUTPUT.PUT_LINE ('     Five spaces in');
SQL&gt; execute DBMS_OUTPUT.PUT_LINE (NULL);
SQL&gt; execute DBMS_OUTPUT.PUT_LINE (SYSDATE &lt; SYSDATE - 5);
SQL&gt; execute DBMS_OUTPUT.PUT_LINE (TRANSLATE ('abc', NULL));
SQL&gt; execute DBMS_OUTPUT.PUT_LINE (RPAD ('abc', 500, 'def'));</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When an error occurs in your program, you want to be able to see which program is currently executing. What builtin packaged function would you call to get this information? If the current program is a procedure named <KBD
CLASS="command"
>calc_totals</KBD
> in the analysis package, what would you see when you call the builtin function?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You want to build a utility for DBAs that would allow them to create an index from within a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program. Which package would you use? Which programs inside that package would be needed?</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You need to run a stored procedure named <KBD
CLASS="command"
>update_data</KBD
> every Sunday at 4 AM to perform a set of batch processes. Which builtin package would you use to perform this task? You will need to pass a string to the <KBD
CLASS="command"
>submit</KBD
> program to tell it how often to run <KBD
CLASS="command"
>update_data</KBD
>. What would that string be?</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-26470"
>A.1.7 Modules<A
CLASS="indexterm"
NAME="appa-idx-38732-0"
></A
></A
></H3
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>In each of the following modules, identify changes you would make to improve their structure, performance, or functionality.</P
><OL
CLASS="orderedlist"
TYPE="a"
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION status_desc (status_cd_in IN VARCHAR2) RETURN VARCHAR2
IS
BEGIN
   IF    status_cd_in = 'C' THEN RETURN 'CLOSED';
   ELSIF status_cd_in = 'O' THEN RETURN 'OPEN';
   ELSIF status_cd_in = 'A' THEN RETURN 'ACTIVE';
   ELSIF status_cd_in = 'I' THEN RETURN 'INACTIVE';
   END IF;
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION status_desc
            (status_cd_in IN VARCHAR2, status_dt_out OUT DATE) 
RETURN VARCHAR2
IS
BEGIN
   ... /* same function as above */
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION company_name (company_id_in IN company.company_id%TYPE)
   RETURN VARCHAR2
IS
   cname company.company_id%TYPE;
   found_it EXCEPTION;
BEGIN
   SELECT name INTO cname FROM company
    WHERE company_id = company_id_in;
   RAISE found_it;
EXCEPTION
   WHEN NO_DATA_FOUND 
   THEN
       RETURN NULL;
   WHEN found_it
    THEN
       RETURN cname;
END;
</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE compute_net (company_id IN INTEGER)
IS
   balance_remaining NUMBER := annual_sales (company_id);
BEGIN
   FOR month_index IN 1 .. 12
   LOOP
      IF balance_remaining &lt;= 0
      THEN
         RETURN 0;
      ELSE
         balance_remaining := debt (company_id, month_index);
      END IF;
   END LOOP;
END;</PRE
></BLOCKQUOTE
></LI
></OL
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Given the header for <KBD
CLASS="command"
>calc_profit</KBD
> below, which of the following calls to <KBD
CLASS="command"
>calc_profit</KBD
> are valid:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE calc_profit 
   (company_id_in IN NUMBER,
    profit_out OUT NUMBER
    fiscal_year_in IN NUMBER,
    profit_type_in IN VARCHAR2 := 'NET_PROFITS',
    division_in IN VARCHAR2 := 'ALL_DIVISIONS')</PRE
></BLOCKQUOTE
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Call to calc_profit</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Good/Bad? Why?</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>calc_profit 
   (1005, profit_level, 1995, 'ALL', 'FINANCE');</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>calc_profit 
   (new_company, profit_level);</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>calc_profit
   (company_id_in =&gt; 32, fiscal_year_in =&gt; 1995,
    profit_out =&gt; big_number);</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
>calc_profit
   (company_id_in =&gt; 32, fiscal_year_in =&gt; 1995,
    profit_out =&gt; 1000);</PRE
></BLOCKQUOTE
> </TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
> <BLOCKQUOTE
><PRE
CLASS="programlisting"
></PRE
></BLOCKQUOTE
> </TD
></TR
></TBODY
></TABLE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Suppose that I have a general utility that displays the contents of a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> table of dates. The header for this procedure is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE dispdates 
   (table_in IN PLVtab.date_table, 
    num_rows_in IN INTEGER, 
    header_in IN VARCHAR2 := NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where <KBD
CLASS="command"
>PLVtab.date_table</KBD
> is a predefined table TYPE stored in the PLVtab package. Notice that the default value for the header is NULL, which means that no header is displayed with the table contents.</P
><P
CLASS="para"
>Here is an example of a call to this program:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>dispdates (birthdays, bday_count, 'List of Birthdays');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now suppose that you had to use <KBD
CLASS="command"
>dispdates</KBD
> to satisfy the following requirement: "Display the list of company start dates stored in the date table without any header." I can think of two ways do this:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>dispdates (company_list, num_companies);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>dispdates (company_list, num_companies, NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Which of these implementations would you choose and why? Is there any reason to choose one over the other?</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="appa-36598"
>A.1.8 Module Evaluation: Foreign Key Lookup</A
></H3
><P
CLASS="para"
>I have found that there are two ways to improve your skills in module construction:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Write lots of procedures and functions.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Critique someone else's efforts.</P
></LI
></OL
><P
CLASS="para"
>Certainly, there is no substitute for doing the work yourself. I find, on the other hand, that when I have the opportunity to look at another developer's work, a different kind of dynamic sets in. I am not sure that it speaks well of my personality, but I find it a whole lot easier to find the weaknesses in someone else's programs than in my own.</P
><P
CLASS="para"
>So assuming that everyone in the world in the same as me (a scary thought, but one I must entertain as a possibility), I offer a function for you to evaluate that I built myself long ago that does foreign-key lookups. No holds barred. No one to insult. See just how many problems you can find in the <KBD
CLASS="command"
>getkey_clrtyp</KBD
>. You might even try to rewrite the program to suit your tastes&nbsp;-- and then evaluate that!</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="appa-idx-38733-0"
></A
>We spend way too much of our time writing software to perform foreign key lookups. And in many situations, the interface we offer to our users to support easy access to foreign key information is inadequate. The approach I like to take is to hide the foreign keys themselves (users rarely need to know, after all, that the ID number for Acme Flooring, Inc. is 2765). Instead, I let the user type in as much of the name as she wants. I then see if there if there are any matches for that string. If there are no matches, I prompt for another entry. If there is just one match, I return the full name and the ID to the host application. If there are more than one match, I display a list. </P
><P
CLASS="para"
>The <KBD
CLASS="command"
>getkey_clrtyp</KBD
><A
CLASS="indexterm"
NAME="appa-idx-38734-0"
></A
> function encapsulates this logic. The function itself returns a numeric code as follows:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0 = No match</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1 = Unique</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>2 = Duplicate</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>It also returns through the parameter list the full name of the caller type and the numeric foreign key value. This function has a number of weaknesses in its design. See how many you can identify.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION GETKEY_CLRTYP 
(NAME_INOUT IN OUT VARCHAR2, NU_INOUT OUT NUMBER) 
RETURN NUMBER IS
   CURSOR CLRTYP_CUR IS 
      SELECT TYP_NU, TYPE_DS 
        FROM CALLER_TYPE
       WHERE TYPE_DS LIKE NAME_INOUT || '%';
   CLRTYP_REC CLRTYP_CUR%ROWTYPE;
   NEXT_REC CLRTYP_CUR%ROWTYPE;
   TYP_NU VARCHAR2(10) := NULL;
   RETVAL NUMBER := NULL;
BEGIN
IF NAME_INOUT IS NOT NULL
THEN
OPEN CLRTYP_CUR; 
   FETCH CLRTYP_CUR INTO CLRTYP_REC;
   IF CLRTYP_CUR%NOTFOUND
   THEN RETURN 0; ELSE
   FETCH CLRTYP_CUR INTO NEXT_REC;
   IF CLRTYP_CUR%NOTFOUND
   THEN RETVAL := 1;
   ELSE RETVAL := 2;
   END IF;
   NU_INOUT := CLRTYP_REC.TYP_NU;
   NAME_INOUT := CLRTYP_REC.TYP_DS;
   END IF;
CLOSE CLRTYP_CUR;
RETURN RETVAL;
END IF;
END GETKEY_CLRTYP;<A
CLASS="indexterm"
NAME="appa-idx-38735-0"
></A
></PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="part"
HREF="part06.htm"
TITLE="VI. Testing Your Knowledge"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: VI. Testing Your Knowledge"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="appa_02.htm#appa-SECT-2.1"
TITLE="A.2 Solutions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: A.2 Solutions"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>VI. Testing Your Knowledge</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>A.2 Solutions</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
