<HTML
><HEAD
><TITLE
>[Chapter 19] 19.5 DML Operations</TITLE
><META
NAME="DC.Creator"
CONTENT="Steven Feuerstein"><META
NAME="DC.Date"
CONTENT="2000-04-29T18:30:46Z"><META
NAME="DC.Format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.Identifier"
CONTENT="O'Reilly and Associates-1-56592-238-7E"><META
NAME="DC.Language"
CONTENT="en-US"><META
NAME="DC.Publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.Source"
CONTENT="1-56592-238-7E"
SCHEME="ISBN"><META
NAME="DC.Subject.Keyword"
CONTENT="PL/SQL SQL Oracle Packages"><META
NAME="DC.Title"
CONTENT="Advanced Oracle PL/SQL Programming with Packages"><META
NAME="DC.Type"
CONTENT="Text.Monograph"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REL="stylesheet"
TYPE="text/css"
HREF="../style/style1.css"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch19_01.htm"
TITLE="19. PLVdyn and PLVfk: Dynamic SQL and PL/SQL"><LINK
REL="prev"
HREF="ch19_04.htm#ch19-SECT-4.1.7"
TITLE="19.4 PLVdyn: A Code Layer over DBMS_SQL"><LINK
REL="next"
HREF="ch19_06.htm#ch19-SECT-6.4"
TITLE="19.6 PLVfk: Generic Foreign Key Lookups"></HEAD>
<BODY><DIV CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Advanced Oracle PL/SQL Programming with Packages"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="jobjects/fsearch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_04.htm#ch19-SECT-4.1.7"
TITLE="19.4 PLVdyn: A Code Layer over DBMS_SQL"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 19.4 PLVdyn: A Code Layer over DBMS_SQL"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><SPAN
CLASS="NAVTITLE"
><A
CLASS="chapter"
REL="up"
HREF="ch19_01.htm"
TITLE="19. PLVdyn and PLVfk: Dynamic SQL and PL/SQL"
>Chapter 19<BR>PLVdyn and PLVfk: Dynamic SQL and PL/SQL</A
></SPAN
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_06.htm#ch19-SECT-6.4"
TITLE="19.6 PLVfk: Generic Foreign Key Lookups"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 19.6 PLVfk: Generic Foreign Key Lookups"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch19-32901"
>19.5 DML Operations</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999308-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999308-1"
></A
>Although it is possible to execute DML statements with static strings in <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>, the dynamic nature of DBMS_SQL does offer many new opportunities. The PLVdyn packages offers a programmatic interface for several common DML operations to make it easier for you to take advantage of this technology.</P
><P
CLASS="para"
>PLVdyn offers three different DML operations: <KBD
CLASS="command"
>dml_insert_select</KBD
>, <KBD
CLASS="command"
>dml_delete</KBD
>, and <KBD
CLASS="command"
>dml_update</KBD
>. There are many other possibilities for dynamic DML in PLVdyn; I encourage you to experiment with your own extensions to this package.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
>  <A
CLASS="indexterm"
NAME="ch19-idx-999309-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999309-1"
></A
>You cannot include bind variables for any of the DML programs in PLVdyn. Generally, PLVdyn does not support bind variables. The consequence of this is that the <SPAN
CLASS="acronym"
>WHERE</SPAN
> clauses may not contain any colons unless they are embedded in a literal string. The PLVdyn1 package (described on the companion disk) does allow you to specify single bind variable values for a variety of DML statements.</P
></BLOCKQUOTE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.0.1"
>19.5.1 Performing an INSERT-SELECT FROM</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999310-0"
></A
>You can execute an INSERT-SELECT FROM statement using the <KBD
CLASS="command"
>dml_insert_select</KBD
>. The header for this procedure is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE dml_insert_select
   (table_in IN VARCHAR2, select_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the first argument you provide the name of the table that is going to receive the rows from the SELECT statement. The second argument is the SELECT statement itself. Here is an example of using this procedure to copy current invoices to a history table.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn.dml_insert_select
   ('inv_history', 
    'SELECT * FROM inv_current' ||
    ' WHERE inv_date &lt; ' || TO_CHAR (v_enddate));</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.0.2"
>19.5.2 Executing dynamic DELETEs</A
></H3
><P
CLASS="para"
>The <KBD
CLASS="command"
>dml_delete</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999311-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999311-1"
></A
> procedure allows you to delete from any table. The header is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE dml_delete
   (table_in IN VARCHAR2, where_in IN VARCHAR2 := NULL);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first argument is the table from which rows are to be deleted. The second argument is an optional WHERE clause, which restricts the number of rows deleted. As with static <SPAN
CLASS="acronym"
>SQL</SPAN
>, the simplest form of a call to <KBD
CLASS="command"
>dml_delete</KBD
> (a NULL WHERE clause) results in the largest number of rows deleted. </P
><P
CLASS="para"
>The following call to <KBD
CLASS="command"
>dml_delete</KBD
> removes all employees in department 10 from the <KBD
CLASS="command"
>emp</KBD
> table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn.dml_delete ('emp', 'deptno = 10');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Clearly, this syntax offers very little in the way of productivity enhancement over simply executing this <SPAN
CLASS="acronym"
>SQL</SPAN
> statement:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; delete from emp where deptno=10;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The big news about PLV<KBD
CLASS="command"
>dyn.dml_delete</KBD
> is that you can execute it from within a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> environment.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.0.3"
>19.5.3 Executing dynamic UPDATEs</A
></H3
><P
CLASS="para"
>The <KBD
CLASS="command"
>dml_update</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999312-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999312-1"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999312-2"
></A
> procedure is overloaded to allow you to easily perform updates of single columns of date, number or string datatypes. Here is the overloaded header for <KBD
CLASS="command"
>dml_update</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE dml_update
   (table_in IN VARCHAR2, 
    column_in IN VARCHAR2,
    value_in IN VARCHAR2|DATE|NUMBER,
    where_in IN VARCHAR2 := NULL); </PRE
></BLOCKQUOTE
><P
CLASS="para"
>The only optional argument is the WHERE clause. If you do not supply a WHERE clause, the requested UPDATE will be performed for <EM
CLASS="emphasis"
>all</EM
> rows in the table. </P
><P
CLASS="para"
>The following examples demonstrate the different ways to use <KBD
CLASS="command"
>dml_update</KBD
>.</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the salary of all employees to $100,000.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn.dml_update ('emp', 'sal', 100000);</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Set the last updated time stamp to SYSDATE for all invoices with creation dates in the last three months.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn.dml_update 
   ('invoice', 'update_ts', SYSDATE, 
    'create_ts &gt;= ADD_MONTHS(SYSDATE,-3)');</PRE
></BLOCKQUOTE
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.0.4"
>19.5.4 Checking feedback on DML</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999313-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999313-1"
></A
>Each of the PLVdyn DML programs calls the <KBD
CLASS="command"
>PLVdyn.execute</KBD
> procedure, which, in turn, calls the DBMS_SQL.EXECUTE builtin to actually execute the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement. DBMS_SQL.EXECUTE is a function that returns an integer, telling you the number of rows affected by the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement. </P
><P
CLASS="para"
>PLVdyn saves and hides this feedback value to make it easier to execute your <SPAN
CLASS="acronym"
>SQL</SPAN
>. You can, however, check the result of your latest dynamic execution by calling the <KBD
CLASS="command"
>dml_result</KBD
> function. In the example following, I delete rows from the <KBD
CLASS="command"
>emp</KBD
> table and then check to see how many rows were actually deleted.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   PLVdyn.dml_delete ('emp');
   IF PLVdyn.dml_result &gt; 100
   THEN
      /*
      || Too many deletes. There is some kind
      || of data problem. Issue a rollback. 
      */
      PLVrb.do_rollback;
   END IF;<A
CLASS="indexterm"
NAME="ch19-idx-999314-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999314-1"
></A
></PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.1"
>19.5.5 <A
CLASS="indexterm"
NAME="ch19-idx-999315-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999315-1"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999315-2"
></A
>Executing Dynamic PL/SQL Code</A
></H3
><P
CLASS="para"
>PLVdyn makes it easy for you to execute dynamically constructed <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> statements with the <KBD
CLASS="command"
>plsql</KBD
> procedure. The header for this program is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE plsql (string_in IN VARCHAR2);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You construct a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> statement or block of statements and then pass that string to <KBD
CLASS="command"
>PLVdyn.plsql</KBD
>. It then executes that code. By using <KBD
CLASS="command"
>PLVdyn.plsql</KBD
>, you do not have to code the separate open, parse, and execute steps that are required with dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>. In addition, this procedure relieves you of the burden of dealing with the following rules about dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The statement must end in a semicolon.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The statement must be a valid <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block. It must begin, in other words, with either the DECLARE or BEGIN keywords, and end with the END; statement.</P
></LI
></OL
><P
CLASS="para"
>You can provide to <KBD
CLASS="command"
>PLVdyn.plsql</KBD
> a string that meets these requirements, or you can ignore those requirements and <KBD
CLASS="command"
>plsql</KBD
> takes care of things for you. As a result, any of the following calls to <KBD
CLASS="command"
>PLVdyn.plsql</KBD
> properly executes the <KBD
CLASS="command"
>calc_totals</KBD
> procedure:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVdyn.plsql ('calc_totals');
SQL&gt; exec PLVdyn.plsql ('calc_totals;');
SQL&gt; exec PLVdyn.plsql ('BEGIN calc_totals; END;');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>plsql</KBD
> procedure accomplishes this by stripping off any trailing semicolons and wrapping your string inside a BEGIN-END block, regardless of whether or not you have already done so.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.1.1"
>19.5.5.1 Implementation of PLVdyn.plsql</A
></H4
><P
CLASS="para"
>The implementation of <KBD
CLASS="command"
>plsql</KBD
>, shown below, is a good example of how you can build additional smarts into your software so that it is easier and more intuitive to use. It also demonstrates how I combine other, bundled operations to construct higher-level programs (these bundled operations are explored in a later section).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE plsql (string_in IN VARCHAR2)
IS
   cur INTEGER := 
      open_and_parse (plsql_block (string_in));
BEGIN
   execute_and_close (cur);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>plsql_block</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999316-0"
></A
> function is designed specifically to return a valid <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION plsql_block (string_in IN VARCHAR2) RETURN VARCHAR2
IS
BEGIN
   RETURN 'BEGIN ' || RTRIM (string_in, ';') || '; END;';
END;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
>  The <KBD
CLASS="command"
>plsql</KBD
> procedure assumes that you do not have any bind variables. If a colon appears in the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> code and it is not within single quotes (part, that is, of a literal string), <KBD
CLASS="command"
>PLVdyn.plsql</KBD
> will not be able to execute your statement successfully.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.1.2"
>19.5.5.2 Scope of a dynamic PL/SQL block</A
></H4
><P
CLASS="para"
>Precisely what kind of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> code can you execute with DBMS_SQL? The answer is not as simple as it might seem at first glance. The rule you must follow is this: </P
><BLOCKQUOTE
CLASS="blockquote"
><P
CLASS="para"
><EM
CLASS="emphasis"
>A dynamically-constructed <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block can only execute programs and reference data structures which are defined in the specification of a package.</EM
></P
></BLOCKQUOTE
><P
CLASS="para"
>Consider, for example, the following simple script:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;&lt;dynamic&gt;&gt;
DECLARE
   n NUMBER;
BEGIN   
   PLVdyn.plsql ('n := 5');
END;
/   </PRE
></BLOCKQUOTE
><P
CLASS="para"
>All I am doing is assigning a value of 5 to the local variable n. This string is executed within its own BEGIN-END block, that would appear to be a nested block within the anonymous block named "dynamic" with the label. Yet when I execute this script I receive the following error:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLS-00302: component 'N' must be declared
ORA-06512: at &quot;SYS.DBMS_SYS_SQL&quot;, line 239</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> engine is unable to resolve the reference to the variable named n. I get the same error even if I qualify the variable name with its block name:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;&lt;dynamic&gt;&gt;
DECLARE
   n NUMBER;
BEGIN
   /* Also causes a PLS-00302 error! */
   PLVdyn.plsql ('dynamic.n := 5');
END;
/   </PRE
></BLOCKQUOTE
><P
CLASS="para"
>Yet if instead of modifying the value of n, I modify the <KBD
CLASS="command"
>PLV.plsql_identifier </KBD
>variable as shown below, I am able to execute the dynamic assignment successfully.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>&lt;&lt;dynamic&gt;&gt;
DECLARE
   n NUMBER;
BEGIN   
   PLVdyn.plsql ('PLV.plsql_identifier := ''5''');
END;
/   </PRE
></BLOCKQUOTE
><P
CLASS="para"
>What's the difference between these two pieces of data? The variable n is defined locally in the anonymous <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block. The <KBD
CLASS="command"
>plsql_identifier</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999317-0"
></A
> variable is a public global defined in the PLV package. This distinction makes all the difference with dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999318-0"
></A
>It turns out that a dynamically constructed and executed <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block is not treated as a <EM
CLASS="emphasis"
>nested</EM
> block. Instead, it is handled like a procedure or function called from within the current block. So any variables local to the current or enclosing blocks are not recognized in the dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block. You can only make references to globally defined programs and data structures. These <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> elements include standalone functions and procedures and any element defined in the specification of a package. That is why my reference to the <KBD
CLASS="command"
>plsql_identifier</KBD
> variable of the PLV package passed without error. It is defined in the package specification and is globally available. </P
><P
CLASS="para"
>Fortunately, the dynamic block is executed within the context of the calling block. If you have an exception section within the calling block, it traps exceptions raised in the dynamic block.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.1.3"
>19.5.5.3 The overhead of dynamic PL/SQL</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999319-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999319-1"
></A
>As soon as you move to dynamic processing, you can expect that there will be some overhead associated with the extra work performed (construct the string, parse the string, and&nbsp;-- with dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>&nbsp;-- compile the anonymous block). Dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> is really neat stuff&nbsp;-- but is it practical? What is the performance penalty when executing, for example, the <KBD
CLASS="command"
>PLVdyn.plsql</KBD
> procedure?</P
><P
CLASS="para"
>I came up with an answer by using the <A
CLASS="indexterm"
NAME="ch19-idx-999320-0"
></A
>PLVtmr package (see <A
CLASS="xref"
HREF="ch14_01.htm"
>Chapter 14, <CITE
CLASS="chapter"
>PLVtmr: Analyzing Program Performance</CITE
></A
>). The script below first determines how much time it takes to do, well, nothing with a call to the <SPAN
CLASS="acronym"
>NULL</SPAN
> statement. This provides a baseline for static code execution (and you can't get much more base than that). I then execute the NULL statement dynamically, with a call to the <KBD
CLASS="command"
>PLVdyn.plsql </KBD
>procedure. The single substitution parameter, <KBD
CLASS="command"
>&amp;1</KBD
>, allows me to specify the number of iterations for the test.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>BEGIN
   PLVtmr.capture;
   FOR rep IN 1 .. &amp;1
   LOOP
      NULL;
   END LOOP;
   PLVtmr.show_elapsed ('static');

   PLVtmr.capture;
   FOR rep IN 1 .. &amp;1
   LOOP
      PLVdyn.plsql ('NULL');
   END LOOP;
   PLVtmr.show_elapsed ('dynamic');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999322-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999322-1"
></A
>I then executed this script in SQL*Plus several times to make sure my results were consistent:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; @temp 100
static Elapsed: 0 seconds.
dynamic Elapsed: 1.38 seconds.
SQL&gt; @temp 1000
static Elapsed: .11 seconds.
Dynamic Elapsed: 13.57 seconds.
SQL&gt; set verify off
SQL&gt; @temp 1000
static Elapsed: .16 seconds.
dynamic Elapsed: 13.41 seconds.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I conclude, therefore, that the overhead of constructing, compiling, and executing a dynamic block of <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> code is at least (and approximately) .0133 seconds. I say "at least" because if your <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> block is bigger (consisting of more than, say, a single statement or call to a stored procedure), your overhead increases. It looks to me that for most situations the additional processing time required for dynamic <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> should not deter you from using this technique.<A
CLASS="indexterm"
NAME="ch19-idx-999321-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999321-1"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.2"
>19.5.6 Bundled and Passthrough Elements </A
></H3
><P
CLASS="para"
>While PLVdyn does offer a number of useful, high-level operations to perform dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
>, there is no way that I can build enough of these kinds of programs to handle all dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> needs. I can, however, still add value for a developer who has very unique requirements: I can bundle together common, often-repeated steps into single lines of code. The developer still has to write his or her own full-fledged dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> program, but can rely on these lower-level "prebuilts" (as opposed to "builtins") to improve productivity and code quality.</P
><P
CLASS="para"
>The PLVdyn package offers these bundled elements:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
> open_and_parse</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Performs the open and parse phases.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
> execute_and_close</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Executes and closes the cursor.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
> parse_delete</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Constructs and parses a DELETE statement from its components.</P
></DD
></DL
><P
CLASS="para"
>PLVdyn adds value in one other way: with passthrough programs. These passthroughs do not (in normal operation) necessarily do anything but execute their corresponding DBMS_SQL program. Since they are a layer of code around the builtins, however, the passthroughs provide an opportunity to add functionality in other ways. </P
><P
CLASS="para"
>The passthroughs of PLVdyn are <KBD
CLASS="command"
>execute</KBD
> and <KBD
CLASS="command"
>execute_and_fetch</KBD
>; they are discussed after the bundled elements below.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.2.1"
>19.5.6.1 Open and parse</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>open_and_parse</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999323-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999323-1"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999323-2"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999323-3"
></A
> function calls DBMS_SQL.OPEN_CURSOR and DBMS_SQL.PARSE. These are both mandatory steps for <EM
CLASS="emphasis"
>any</EM
> method of dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> you choose to implement with DBMS_SQL. So rather than have to call these two separate programs over and over again, you can simply call the single function. In addition, the function hides the need to pass the database version (in the form of a constant such DBMS_SQL.V7) when you call PARSE. The header for <KBD
CLASS="command"
>open_and_parse</KBD
> is:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>FUNCTION open_and_parse 
   (string_in IN VARCHAR2 SEF,
    mode_in IN INTEGER := DBMS_SQL.NATIVE) 
RETURN INTEGER</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With this bundled operation, you can open and parse a <SPAN
CLASS="acronym"
>SQL</SPAN
> statement with the following single line of code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>cur := PLVdyn.open_and_parse (string_in);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Without <KBD
CLASS="command"
>open_and_parse</KBD
>, you type the following lines of code:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>cur := DBMS_SQL.OPEN_CURSOR;
DBMS_SQL.PARSE (cur, string_in, DBMS_SQL.V7);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>PLVdyn programs themselves make use of <KBD
CLASS="command"
>open_and_parse</KBD
>. Any time you parse a <SPAN
CLASS="acronym"
>SQL</SPAN
> statement through PLVdyn, you are, in fact, executing <KBD
CLASS="command"
>open_and_parse</KBD
>. This bundled program therefore acts as a kind of gateway through which all dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> must pass. I took advantage of this fact when I constructed a trace or window for PLVdyn (covered later in this chapter).</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.2.2"
>19.5.6.2 Execute and close</A
></H4
><P
CLASS="para"
>In many (but not all) situations, you want to execute your cursor and then immediately close it. If you are executing an INSERT, UPDATE, or DELETE, for example, you do not have to fetch rows from the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement. After executing, you are ready to close. </P
><P
CLASS="para"
>The header for <KBD
CLASS="command"
>execute_and_close</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999324-0"
></A
> is as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE execute_and_close (cur_inout IN OUT INTEGER)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, you pass in the cursor and PLVdyn does the rest for you. Using this bundled operation, you can execute and close with this single line:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn.execute_and_close (cur);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Otherwise, you have to code these lines (and declare a variable to hold the feedback from the EXECUTE statement):</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>fdbk := DBMS_SQL.EXECUTE (cur);
DBMS_SQL.CLOSE (cur);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>With PLVdyn, you don't have to deal with the EXECUTE feedback unless you want to. If you need to know the results of the operation, you can access it through the <KBD
CLASS="command"
>dml_result</KBD
> or <KBD
CLASS="command"
>fdbk</KBD
> functions. These programs return the feedback from the most recent execution of <KBD
CLASS="command"
>execute_and_close</KBD
>.</P
><P
CLASS="para"
>By calling PLV<KBD
CLASS="command"
>dyn.execute_and_close</KBD
> instead of DBMS_SQL.EXECUTE, you can also take advantage of the execute toggle in PLVdyn, which is covered below.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.2.3"
>19.5.6.3 Parse for delete</A
></H4
><P
CLASS="para"
>The last bundled operation is <KBD
CLASS="command"
>parse_delete</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999325-0"
></A
>. It is a bit more complex than the other operations. It is used by the <KBD
CLASS="command"
>dml_delete</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999326-0"
></A
> procedure to construct the <SPAN
CLASS="acronym"
>SQL</SPAN
> DELETE and then parse it, as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE dml_delete
   (table_in IN VARCHAR2, where_in IN VARCHAR2 := NULL)
IS
   cur INTEGER;
BEGIN
   parse_delete (table_in, where_in, cur);
   execute_and_close (cur);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You might ask why I built a separate <KBD
CLASS="command"
>parse_delete</KBD
> procedure for this single call in <KBD
CLASS="command"
>dml_delete</KBD
> (it is not used anywhere else in PLVdyn). That is a reasonable question to ask. After all, one should be careful not to over-modularize. You can argue that it never hurts to break out functionality into separate programs. Then it is at least potentially reusable. You could, however, spend (waste?) many hours constructing individual modules that are never actually reused. Find the right balance.</P
><P
CLASS="para"
>In the case of <KBD
CLASS="command"
>parse_delete</KBD
>, it only looks as if the procedure is used once. In fact, <KBD
CLASS="command"
>parse_delete</KBD
> is also used in a second dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> package, PLVdyn1 (the code for which is found at the end of this chapter). This package contains a series of overloaded delete programs that take a single bind variable as input. For example, I could delete all employees where the <KBD
CLASS="command"
>hiredate</KBD
> is more than 100 years in the past with this call:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn1.dml_delete
  ('emp', 
   ADD_MONTHS (SYSDATE, -1200),
   'hiredate &lt; :indate');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So I do, in fact, need a consolidated <KBD
CLASS="command"
>parse_delete</KBD
> function to handle common operations across at least four different delete programs. Now that I have justified my development process to my readers, let's take a look at the specification for <KBD
CLASS="command"
>parse_delete</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE parse_delete
   (table_in IN VARCHAR2, 
    where_in IN VARCHAR2, 
    cur_out OUT INTEGER);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You pass a table and the WHERE clause and receive a cursor handle in return. You can then use this cursor handle in a call to <KBD
CLASS="command"
>execute_and_close</KBD
>. The implementation of <KBD
CLASS="command"
>parse_delete</KBD
> is shown below. It constructs the DELETE string based on the inputs and then calls the prebuilt <KBD
CLASS="command"
>open_and_parse</KBD
> (notice that it does not need the "PLVdyn" prefix on the call to <KBD
CLASS="command"
>open_and_parse</KBD
>, since it is coded <EM
CLASS="emphasis"
>within</EM
> the package).</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE parse_delete
  (table_in IN VARCHAR2, 
   where_in IN VARCHAR2, 
   cur_out OUT INTEGER)
IS
   delete_stg PLV.dbmax_varchar2%TYPE := 'DELETE FROM ' || table_in;
   cur INTEGER;
BEGIN
   IF where_in IS NOT NULL
   THEN
      delete_stg := delete_stg || ' WHERE ' || where_in;
   END IF;
   cur_out := open_and_parse (delete_stg);
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>These low-level, bundled operations are very handy when constructing more complex, full-featured dynamic SQL programs. Consider the <KBD
CLASS="command"
>ddl</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999327-0"
></A
> procedure described earlier in <A
CLASS="xref"
HREF="ch19_05.htm#ch19-SECT-5.0.4"
>Section 19.5, "DML Operations"</A
>. The implementation of <KBD
CLASS="command"
>PLVdyn.ddl</KBD
> is shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE ddl (string_in IN VARCHAR2)
IS
   cur INTEGER;
BEGIN
   IF NOT executing
   THEN
      p.l ('PLVdyn: No parse/execute of DDL.');
      display_dynamic_sql (string_in);
   ELSE
      cur := open_and_parse (string_in);
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The executing function and the <KBD
CLASS="command"
>display_dynamic_sql</KBD
> support the execution toggle and execution trace features of PLVdyn. Disregarding those lines for the time being, the entire body of the <KBD
CLASS="command"
>ddl</KBD
> procedure is simply:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>cur := open_and_parse (string_in);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Since it is a DDL statement, the parse automatically executes <EM
CLASS="emphasis"
>and</EM
> commits, so this is all the code that is needed. The bundled operations (<KBD
CLASS="command"
>open_and_parse</KBD
>, <KBD
CLASS="command"
>execute_and_close</KBD
>, and so on) are called throughout the body of the PLVdyn package to minimize code volume and maximize code reuse.<A
CLASS="indexterm"
NAME="ch19-idx-999328-0"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.2.4"
>19.5.6.4 Passthrough elements</A
></H4
><P
CLASS="para"
>PLVdyn offers two execute-related programs that are nothing more than passthroughs to the corresponding DBMS_SQL element. The headers for these passthroughs are:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch19-idx-999329-0"
></A
>execute (cur_in IN INTEGER);
PROCEDURE <A
CLASS="indexterm"
NAME="ch19-idx-999330-0"
></A
>execute_and_fetch
   (cur_in IN INTEGER, match_in IN BOOLEAN := FALSE);</PRE
></BLOCKQUOTE
><P
CLASS="para"
><KBD
CLASS="command"
>PLVdyn.execute</KBD
> calls the DBMS_SQL.EXECUTE builtin, while <KBD
CLASS="command"
>PLVdyn.execute_and_fetch</KBD
> calls the DBMS_SQL.EXECUTE_AND_FETCH builtin. </P
><P
CLASS="para"
>Why did I bother building these procedures and why should you bother to use them? There are two basic reasons:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>Ease of use.</EM
> The DBMS_SQL versions of these programs are functions. They return the number of rows affected by the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement executed. This is important information, but it is not always needed. With PLVdyn passthroughs, you can simply call the procedure to perform the execute. If you then need to see the feedback value, you can call the <KBD
CLASS="command"
>PLVdyn.fdbk</KBD
> function.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><EM
CLASS="emphasis"
>PLVdyn has placed a layer of code between your program and the native builtin function.</EM
> Once this layer is in place, PLVdyn can add functionality around the DBMS_SQL execute operation. The <KBD
CLASS="command"
>execsql</KBD
> toggle, for example, allows you to turn on or off the actual execution of your dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
>&nbsp;-- without having to change your application's code. PLVdyn could also enhance the trace to show you when code is executed. </P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.3"
>19.5.7 Displaying a Table</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999331-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999331-1"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999331-2"
></A
>PLVdyn offers the <KBD
CLASS="command"
>disptab</KBD
> procedure to display the contents of any database table from within the <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> environment. This procedure is both a useful utility (one that is used by PLVlog, as is shown below) and an excellent demonstration of how to build programs that support Method 4 dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> with the DBMS_SQL package.</P
><P
CLASS="para"
>The header of <KBD
CLASS="command"
>disptab</KBD
> follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   PROCEDURE disptab
     (table_in IN VARCHAR2,
      string_length_in IN INTEGER := 20,
      where_in IN VARCHAR2 := NULL,
      date_format_in IN VARCHAR2 := PLV.datemask);</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The four arguments to <KBD
CLASS="command"
>disptab</KBD
> are as follows:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
> table_in</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The name of the table to be displayed. This is the only required argument.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
> string_length_in</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The maximum number of characters to be used in displaying string columns. I do not even attempt to do the kind of string wrapping performed in SQL*Plus. Instead, I use SUBSTR to truncate the values.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
> where_in</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>An optional WHERE clause to restrict the rows displayed. If not specified, all rows are retrieved. You can also use this argument to pass in ORDER BY and HAVING clauses, since they follow immediately after the WHERE clause.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
> date_format_in</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The format to be used to display dates. The default is the default date mask for PL/Vision, maintained in the PLV package.</P
></DD
></DL
><P
CLASS="para"
>Here are some examples of output from <KBD
CLASS="command"
>disptab</KBD
>:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Display the full contents of the employee table:</P
></LI
></OL
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute PLVdyn.disptab ('emp');</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>-----------------------------------------------------------------------
                           Contents of emp
-----------------------------------------------------------------------
EMPNO ENAME      JOB       MGR  HIREDATE        SAL     COMM    DEPTNO
-----------------------------------------------------------------------
7839  KING       PRESIDENT      11/17/81 120000 5000            10
7698  BLAKE      MANAGER   7839 05/01/81 120000 2850            30
7782  CLARK      MANAGER   7839 06/09/81 120000 2450            10
7566  JONES      MANAGER   7839 04/02/81 120000 2975            20
7654  MARTIN     SALESMAN  7698 09/28/81 120000 1250    1400    30
7499  ALLEN      SALESMAN  7698 02/20/81 120000 1600    300     30
7844  TURNER     SALESMAN  7698 09/08/81 120000 1500    0       30
7900  JAMES      CLERK     7698 12/03/81 120000 950             30
7521  WARD       SALESMAN  7698 02/22/81 120000 1250    500     30
7902  FORD       ANALYST   7566 12/03/81 120000 3000            20
7369  SMITH      CLERK     7902 12/17/80 120000 800             20
7788  SCOTT      ANALYST   7566 12/09/82 120000 3000            20
7876  ADAMS      CLERK     7788 01/12/83 120000 1100            20
7934  MILLER     CLERK     7782 01/23/82 120000 1300            10</PRE
></BLOCKQUOTE
><OL
CLASS="orderedlist"
START="2"
><LI
CLASS="listitem"
><P
CLASS="para"
>Display only those rows of the <KBD
CLASS="command"
>emp</KBD
> table in department 10, ordering the rows by salary in increasing order. I also request that a maximum of 20 characters be used to display string information.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; execute PLVdyn.disptab ('emp', 20, 'deptno = 10 order by sal');
-----------------------------------------------------------------------
                           Contents of emp
-----------------------------------------------------------------------
EMPNO ENAME      JOB       MGR  HIREDATE        SAL     COMM    DEPTNO
-----------------------------------------------------------------------
7934  MILLER     CLERK     7782 01/23/82 120000 1300            10
7782  CLARK      MANAGER   7839 06/09/81 120000 2450            10
7839  KING       PRESIDENT      11/17/81 120000 5000            10</PRE
></BLOCKQUOTE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>I use the <KBD
CLASS="command"
>disptab</KBD
> procedure inside the PLVlog package to display the contents of the log table when the user has requested logging to a database table. The PLVlog display procedure is shown below. If the log type is set to database table, <KBD
CLASS="command"
>disptab</KBD
> is called. Otherwise the PLVtab package is used to display the contents of the PL/SQL table containing the log.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE display IS
BEGIN
   IF log_type = PLV.dbtab
   THEN
      /* Use generic table display program? */
      PLVdyn.disptab (log_struc.table_name, 30);
   ELSIF log_type = PLV.pstab</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>   THEN
      PLVtab.display
         (log_pstable,</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>          pstab_count,
          'PL/Vision Log');   
   END IF;
END;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Notice that the user does not have to provide any information about the structure of the table. The <KBD
CLASS="command"
>disptab</KBD
> procedure gets that information itself&nbsp;-- and this is precisely the aspect of <KBD
CLASS="command"
>disptab</KBD
> that makes it a Method 4 dynamic SQL example and very useful.<A
CLASS="indexterm"
NAME="ch19-idx-999332-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999332-1"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999332-2"
></A
></P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.4"
>19.5.8 Controlling Execution of Dynamic SQL</A
></H3
><P
CLASS="para"
>You can never have enough flexibility. That's my motto. I built this package to execute my dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> and then I actually encountered circumstances in which I wanted to run all of my code, but preferred to not actually <EM
CLASS="emphasis"
>execute</EM
> the dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
>. So I added yet another toggle to the PLVdyn package that would give me just this capability.</P
><P
CLASS="para"
>To turn on execution of dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> with PLVdyn, you call the <KBD
CLASS="command"
>execsql</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999333-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999333-1"
></A
> procedure. Here is an example of calling <KBD
CLASS="command"
>execsql</KBD
> from within a SQL*Plus session:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVdyn.execsql</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To turn off execute of dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> in PLVdyn, call <KBD
CLASS="command"
>noexecsql</KBD
> as shown below:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SQL&gt; exec PLVdyn.noexecsql</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The executing function returns TRUE if PLVdyn is currently executing the <SPAN
CLASS="acronym"
>SQL</SPAN
> statements passed to it. You can call this function; PLVdyn calls the function itself to decide if it should call DBMS_SQL.EXECUTE, as you can see in the implementation of <KBD
CLASS="command"
>PLVdyn.execute</KBD
>:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE execute (cur_in IN INTEGER) IS
BEGIN
   IF executing
   THEN
      dml_feedback := DBMS_SQL.EXECUTE (cur_in);
   ELSE
      p.l ('PLVdyn: Execution disabled...');
   END IF;
END;</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.5"
>19.5.9 <A
CLASS="indexterm"
NAME="ch19-idx-999334-0"
></A
>Tracing Use of Dynamic SQL</A
></H3
><P
CLASS="para"
>With PLVdyn, you construct a <SPAN
CLASS="acronym"
>SQL</SPAN
> statement and pass that string to a PLVdyn program for parsing or execution. It's a big time saver, but it also implies a loss of some control. You trust PLVdyn to do the right thing&nbsp;-- and it does. The question remains, however: what is <EM
CLASS="emphasis"
>your</EM
> code passing to PLVdyn? </P
><P
CLASS="para"
>The code used to construct the dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> statement is often complicated (you can see this in some of my high-level operators). As I began to use PLVdyn, I often found that I wanted to see the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement that PLVdyn was executing. I needed to verify that my calling program had put the <SPAN
CLASS="acronym"
>SQL</SPAN
> together properly. </P
><P
CLASS="para"
>There were two ways I could display my <SPAN
CLASS="acronym"
>SQL</SPAN
> statement:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Put calls to DBMS_OUTPUT <EM
CLASS="emphasis"
>before</EM
> each of my calls to PLVdyn modules. In this way, I do not have to change PLVdyn. (It is not, after all, the fault of PLVdyn&nbsp;-- or its author!&nbsp;-- that I wasn't sure what my code was doing.)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Put the trace <EM
CLASS="emphasis"
>inside</EM
> PLVdyn. This approach would require changes to the base package. On the other hand, it would be done once and then be available for all users of PLVdyn. </P
></LI
></OL
><P
CLASS="para"
>To me, the second approach was clearly preferable. If I were going to put this trace inside the package, I needed to make sure that the trace displayed only my <SPAN
CLASS="acronym"
>SQL</SPAN
> statement when I wanted to see it. When the package was used in a production environment, I couldn't have extraneous messages showing up on the user's screen.</P
><P
CLASS="para"
>I therefore implemented my trace with the following procedures and functions:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PROCEDURE <A
CLASS="indexterm"
NAME="ch19-idx-999335-0"
></A
>showsql (start_with_in IN VARCHAR2 := NULL);
PROCEDURE <A
CLASS="indexterm"
NAME="ch19-idx-999338-0"
></A
>noshowsql;
FUNCTION showing RETURN BOOLEAN;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>showsql</KBD
> procedure turns on the trace. If you execute <KBD
CLASS="command"
>PLVdyn.noshowsql</KBD
>, you turn off the trace. The <KBD
CLASS="command"
>showing</KBD
><A
CLASS="indexterm"
NAME="ch19-idx-999339-0"
></A
> function tells you the current state of the toggle. </P
><P
CLASS="para"
>When you turn on the PLVdyn trace, you can specify a "start with" string. If this string is not NULL, then that serves as the starting point for display of the dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
>. You can use that option to skip over portions of <SPAN
CLASS="acronym"
>SQL</SPAN
> in which you have no interest. This feature was more useful and necessary in the early days of the PLVdyn trace when I had not incorporated the PLVprs string-wrapping functionality.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.5.1"
>19.5.9.1 Using the dynamic SQL trace</A
></H4
><P
CLASS="para"
>In the following script, I turn on the trace and then execute a request to open and parse an INSERT statement.</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>SET SERVEROUTPUT ON
execute PLVdyn.showsql;</PRE
></BLOCKQUOTE
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>DECLARE
   cur INTEGER;
BEGIN
   cur := PLVdyn.open_and_parse
     ('insert into emp (empno, deptno) values (1505, 100)');
END;
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>I then receive this output:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>Dynamic SQL: insert into emp (empno, deptno) values (1505, 100)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The trace comes in especially handy when you encounter errors in your dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> execution. Suppose you make extensive use of PLVdyn in your application. You start testing the code and have tossed in your face the following exception:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>ORA-06510: PL/SQL: unhandled user-defined exception</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can turn on logging or displaying of exceptions if you are using PLVexc. Or you can simply issue this command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn.showsql;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>and then re-execute your application. Suddenly, every time you parse <SPAN
CLASS="acronym"
>SQL</SPAN
> through PLVdyn, you see the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement appear on the screen. When the problematic <SPAN
CLASS="acronym"
>SQL</SPAN
> fails, you will be able to identify the text and, from that, the part of your code that constructs that dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> string. Moving from that point to a solution is usually fairly straightforward.</P
><P
CLASS="para"
>The trace facility of PLVdyn illustrates some important principles of both generic package structure and high-quality reusable code. First, the public-private nature of the package allows me to construct a window into PLVdyn. This window offers a very controlled glimpse into the interior of the package. I let developers view the dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> string, but they can't look at or do anything else. This level of control allows Oracle to give us all of those wonderful builtin packages like DBMS_SQL and DBMS_PIPE. And it lets developers provide reusable <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> components to other developers without fearing corruption of internal data structures.</P
><P
CLASS="para"
>See <A
CLASS="xref"
HREF="ch02_01.htm"
>Chapter 2, <CITE
CLASS="chapter"
>Best Practices for Packages</CITE
></A
>, for more information on windows into packages.<A
CLASS="indexterm"
NAME="ch19-idx-999336-0"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch19-SECT-5.6"
>19.5.10 Executing PLVdyn in Different Schemas</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999337-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999337-1"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999337-2"
></A
>When you execute stored code, you run it under the authority of the owner of that code. This has some startling implications for a package that frontends the DBMS_SQL package. Suppose that you install PLVdyn along with all of the other PL/Vision packages in a single account and then grant execute authority on PLVdyn to PUBLIC. This way all users can more easily take advantage of dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> in <SPAN
CLASS="acronym"
>PL/SQL</SPAN
>. Let's look at the implications of such an architecture.</P
><P
CLASS="para"
>Suppose that PL/Vision (and PLVdyn) is owned by the PLVISION account and that SCOTT is another account in the database instance. A DBA logs in to SCOTT to perform some database tuning. It seems that the company has added many employees over the years and the <KBD
CLASS="command"
>emp</KBD
> table now has 6,000,000 rows. An index is needed on the <KBD
CLASS="command"
>ename</KBD
> table to improve query performance.</P
><P
CLASS="para"
>So the DBA logs into the new Oracle Forms frontend she built to make her life easier. It uses PLVdyn to perform a variety of administrative tasks. Through a fill-in-the-form process, she ends up executing a <SPAN
CLASS="acronym"
>CREATE</SPAN
> <SPAN
CLASS="acronym"
>INDEX</SPAN
> command as follows:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn.ddl ('create index empname_idx on emp(ename)');</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So PLVdyn does its thing and the Oracle Forms application notifies the DBA that the job is done. The DBA is impressed at how rapidly the index was built and notifies the application development team that all is better now. Fifteen minutes of quiet pass for the DBA before she gets an angry call from a developer:</P
><P
CLASS="para"
>"The performance hasn't changed one bit!" he says angrily. "The screens still work just as slowly as before when I try to search for an employee by name."</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.6.1"
>19.5.10.1 Checking the indexes</A
></H4
><P
CLASS="para"
>The DBA is bewildered and quickly runs the following script to examine the indexes on the <KBD
CLASS="command"
>emp</KBD
> table:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>REM vuindex.sql
SELECT i.index_name, i.tablespace_name, 
       uniqueness u, column_name, column_position pos
  FROM all_indexes i, all_ind_columns c
 WHERE i.index_name = c.index_name
   AND i.table_name = upper ('&amp;1'); 
SQL&gt; start vuindex emp
INDEX_NAME          TABLESPACE_NAME      U         COLUMN_NAME          POS
------------------- -------------------- --------- -------------------- ---
EMP_PRIMARY_KEY     USER_DATA            UNIQUE    EMPNO                  1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There is no <KBD
CLASS="command"
>empname_idx</KBD
> index! What has gone wrong? On a hunch, the DBA connects to the PLVISION account, re-executes the same script, and sees these results:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>INDEX_NAME          TABLESPACE_NAME      U         COLUMN_NAME          POS
------------------- -------------------- --------- -------------------- ---
EMPNAME_IDX         USER_DATA            NONUNIQUE ENAME                  1
EMP_PRIMARY_KEY     USER_DATA            UNIQUE    EMPNO                  1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The index was created in the PLVISION schema! Why did this happen? </P
><P
CLASS="para"
>When the DBA executed the index creation statement from within a call to <KBD
CLASS="command"
>PLVdyn.ddl</KBD
>, the DDL statement was processed as though it were being executed by PLVISION, not by SCOTT. If the DBA had wanted to create an index in her own schema, she should have entered the following command:</P
><BLOCKQUOTE
><PRE
CLASS="programlisting"
>PLVdyn.ddl ('create index SCOTT.ename_idx on SCOTT.emp(ename)');</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="ch19-SECT-5.6.2"
>19.5.10.2 Avoiding schema confusion for DDL</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch19-idx-999340-0"
></A
>It is very difficult to make sure that all developers who use PLVdyn remember this unusual twist. As a result, you may want to treat PLVdyn differently in terms of how you make it available to developers. </P
><P
CLASS="para"
>Ideally, one could enhance a package like PLVdyn to make sure that the correct schema (that returned by a call to USER) is applied to all DDL. As far as I can tell, however, that is a near-impossible task. How can a <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> program parse the <SPAN
CLASS="acronym"
>SQL</SPAN
> statement and figure out where a schema must be added?</P
><P
CLASS="para"
>The alternative is ugly, but practical. Instead of creating the package in one account and granting execute authority to all others, consider creating the PLVdyn package directly in the accounts of each of the users of the package. This creates something of a maintenance headache, but it also guarantees that any <SPAN
CLASS="acronym"
>SQL</SPAN
> and <SPAN
CLASS="acronym"
>PL/SQL</SPAN
> developers run dynamically run under their own schema.</P
><P
CLASS="para"
>A final approach might be to strictly limit who has access to PLVdyn; perhaps it can only be executed through an interface that guarantees that schemas are applied correctly in the <SPAN
CLASS="acronym"
>SQL</SPAN
> before it is passed to PLVdyn for parsing.</P
><DIV
CLASS="sidebar"
><H4
CLASS="sidebar"
><A
CLASS="title"
NAME="AUTOID-20444"
>Special Notes on PLVdyn</A
></H4
><P
CLASS="para"
>Here are some factors to consider when working with PLVdyn:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The PLVdyn package does not provide support for <A
CLASS="indexterm"
NAME="ch19-idx-999341-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999341-1"
></A
>bind variables. The PLVdyn1 package offers a programmatic interface to a variety of dynamic <SPAN
CLASS="acronym"
>SQL</SPAN
> operations that have a single bind variable. This package is provided on the companion disk, and you will find documentation for it there. You will be able to see how to use its programs simply by examining the specification and body of PLVdyn1.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The <KBD
CLASS="command"
>disptab</KBD
> procedure has lots of room for fine-tuning and enhancement. It would be nice, for example, to specify a maximum length for numeric values, alternate titles for columns, and a restricted set of columns. Future versions of PL/Vision Professional may incorporate these ideas. I strongly recommend, however, that in the meantime you make a copy of <KBD
CLASS="command"
>disptab</KBD
> and play around with it yourself.<A
CLASS="indexterm"
NAME="ch19-idx-999342-0"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999342-1"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999342-2"
></A
><A
CLASS="indexterm"
NAME="ch19-idx-999342-3"
></A
></P
></LI
></UL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_04.htm#ch19-SECT-4.1.7"
TITLE="19.4 PLVdyn: A Code Layer over DBMS_SQL"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 19.4 PLVdyn: A Code Layer over DBMS_SQL"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Advanced Oracle PL/SQL Programming with Packages"
><IMG
SRC="../gifs/txthome.gif"
ALT="Advanced Oracle PL/SQL Programming with Packages"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch19_06.htm#ch19-SECT-6.4"
TITLE="19.6 PLVfk: Generic Foreign Key Lookups"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 19.6 PLVfk: Generic Foreign Key Lookups"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>19.4 PLVdyn: A Code Layer over DBMS_SQL</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>19.6 PLVfk: Generic Foreign Key Lookups</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The Oracle Library Navigation">

<P><font size="-1">
<a href="../copyrght.htm#copy">Copyright (c) 2000</a> O'Reilly & Associates. All rights reserved.
</font></P>

<MAP NAME="map">

<AREA SHAPE="RECT"
COORDS="0,0,35,30"
HREF="../index.htm"
ALT="Library Home">

<AREA SHAPE="RECT"
COORDS="40,0,95,30"
HREF="../prog2/index.htm"
ALT="Oracle PL/SQL Programming, 2nd. Ed.">

<AREA SHAPE="RECT"
COORDS="100,0,200,30"
HREF="../guide8i/index.htm"
ALT="Guide to Oracle 8i Features">

<AREA SHAPE="RECT"
COORDS="205,0,245,30"
HREF="../bipack/index.htm"
ALT="Oracle Built-in Packages">

<AREA SHAPE="RECT"
COORDS="250,0,320,30"
HREF="index.htm"
ALT="Advanced PL/SQL Programming with Packages">

<AREA SHAPE="RECT"
COORDS="325,0,420,30"
HREF="../webapp/index.htm"
ALT="Oracle Web Applications">

<AREA SHAPE="RECT"
COORDS="425,0,490,30"
HREF="../langpkt/index.htm"
ALT="Oracle PL/SQL Language Pocket Reference">

<AREA SHAPE="RECT"
COORDS="495,0,570,30"
HREF="../bipkt/index.htm"
ALT="Oracle PL/SQL Built-ins Pocket Reference">
</MAP>
</BODY
>
<!-- Mirrored from liso.cs.pusan.ac.kr by HTTrack Website Copier/3.x [XR&CO'2001] -->
</HTML
>
