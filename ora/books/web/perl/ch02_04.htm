<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 2] 2.4 Pattern Matching</TITLE>
<meta name="author" content="Larry Wall, Tom Christiansen, and Randal Schwartz">
<meta name="date" content="Mon Mar 17 13:02:38 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="Perl">
<meta name="title" content="Programming Perl, Second Edition">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="Programming Perl, Second Edition"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch02_03.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 2</b></td>
<td width=172 align=right valign=top><a href="ch02_05.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="PERL2-CH-2-SECT-4">2.4 Pattern Matching</A></h2>

<p class=para>
<a name="CH02.PAT"></A>The two main pattern matching operators are <tt class=literal>m//</tt>,
the match operator, and <tt class=literal>s///</tt>, the substitution
operator.  There is also a <a href="ch03_02.htm">split</A>
operator, which takes an ordinary match operator as its first argument
but otherwise behaves like a function, and is therefore documented in
<a href="ch03_01.htm">Chapter 3, <i>Functions</i></A>.

<p class=para>
Although we write <tt class=literal>m//</tt> and <tt class=literal>s///</tt> here, you'll recall that you can
pick your own quote characters.  On the other hand, for the <tt class=literal>m//</tt>
operator only, the <tt class=literal>m</tt> may be omitted if the delimiters you pick are in
fact slashes.  (You'll often see patterns written this way, for
historical reasons.)

<p class=para>
Now that we've gone to all the trouble of enumerating these weird,
quote-like operators, you might
wonder what it is we've gone to all the trouble of quoting.  The answer
is that the string inside the quotes specifies a <i class=emphasis>regular expression</I>.
We'll discuss regular expressions in the next section, because there's a lot
to discuss.

<p class=para>
The matching operations can have various modifiers, some of which affect
the interpretation of the regular expression inside:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-6"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Modifier</TH>
<th align="LEFT">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>i</tt></TD>
<td align="LEFT">Do case-insensitive pattern matching.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>m</tt></TD>
<td align="LEFT">

<p class=para>
Treat string as multiple lines (<tt class=literal>^</tt>
and <tt class=literal>$</tt> match internal <tt class=literal>\n</tt>).</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>s</tt></TD>
<td align="LEFT">

<p class=para>
Treat string as single line (<tt class=literal>^</tt> and 
<tt class=literal>$</tt> ignore <tt class=literal>\n</tt>, but <tt class=literal>.</tt>
matches <tt class=literal>\n</tt>).</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>x</tt></TD>
<td align="LEFT">

<p class=para>
Extend your pattern's legibility with whitespace and comments.</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
These are usually written as "the <b>/x</B> modifier", even though the
delimiter in question might not actually be a slash.  In fact, any of
these modifiers may also be embedded within the regular expression
itself using the <tt class=literal>(?...)</tt> construct.  See the section
"Regular Expression Extensions" later in this chapter.

<p class=para>
The <b>/x</B> modifier itself needs a little more explanation.  It tells
the regular expression parser to ignore whitespace that is not
backslashed or within a character class.  You can use this modifier to break up
your regular expression into (slightly) more readable parts.  The <tt class=literal>#</tt>
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  Taken together, these features go a
long way toward making Perl a readable language.

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-4.1">Regular Expressions</A></h3>

<p class=para>
<a name="CH02.RE"></A>The regular expressions used in the pattern matching and substitution
operators are syntactically similar to those used by the UNIX <i class=emphasis>egrep</I> program.  When
you write a regular expression, you're actually writing a grammar for a
little language.  The regular expression interpreter (which we'll call
the Engine) takes your grammar and compares it to the string you're
doing pattern matching on.  If some portion of the string can be parsed
as a sentence of your little language, it says "yes".  If not, it says
"no".

<p class=para>
What happens after the Engine has said "yes" depends on how you invoked
it.  An ordinary pattern match is usually used as a conditional
expression, in which case you don't care <i class=emphasis>where</I> it matched, only
<i class=emphasis>whether</I> it matched.  (But you can also find out where it matched if
you need to know that.)  A substitution command will take the part that
matched and replace it with some other string of your choice.  And the
<a href="ch03_02.htm">split</A> operator will return (as a
list) all the places your pattern didn't match.

<p class=para>
Regular expressions are powerful, packing a lot of meaning into a
short space.  They can therefore be quite daunting if you try to
intuit the meaning of a large regular expression as a whole.  But if you
break it up into its parts, and if you know how the Engine interprets
those parts, you can understand any regular expression.

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-4.1.1">The regular expression bestiary</A></h4>

<p class=para>
Before we dive into the rules for interpreting regular expressions,
let's take a look at some of the things you'll see in regular expressions.
First of all, you'll see literal strings.  Most characters[23]
in a regular expression simply match themselves.  If you string several
characters in a row, they must match in order, just as you'd expect.  So
if you write the pattern match:

<blockquote class=footnote>
<p class=para>[23] 
In this section we are misusing the term "character" to mean "byte".
So far, Perl only knows about byte-sized characters, but this will
change someday, at which point "character" will be a more appropriate
word.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
/Fred/
</PRE>
</DIV>

<p class=para>
you can know that the pattern won't match unless the string contains
the substring "<tt class=literal>Fred</tt>" somewhere.

<p class=para>
Other characters don't match themselves, but are <i class=emphasis>metacharacters</I>.
(Before we explain what metacharacters do, we should reassure
you that you can always match such a character literally by putting a
backslash in front of it.  For example, backslash is itself a
metacharacter, so to match a literal backslash, you'd backslash the
backslash: <tt class=literal>\\</tt>.)  The list of metacharacters is:

<p class=para>
<div class=programlisting>
<p>
<pre>
\ | ( ) [  {  ^ $ * + ? .
</PRE>
</DIV>

<p class=para>
We said that backslash turns a metacharacter into a literal character,
but it does the opposite to an alphanumeric character: it turns
the literal character into a sort of metacharacter or sequence.  So
whenever you see a two-character sequence:

<div class=programlisting>
<p>
<pre>
\b \D \t \3 \s
</PRE>
</DIV>

<p class=para>
you'll know that the sequence matches something strange.  A <tt class=literal>\b</tt>
matches a word boundary, for instance, while <tt class=literal>\t</tt> matches an ordinary
tab character.  Notice that a word boundary is zero characters wide,
while a tab character is one character wide.  Still, they're alike in
that they both assert that something is true about a particular spot
in the string.  Most of the things in a regular expression fall into the
class of assertions, including the ordinary characters that simply
assert that they match themselves.  (To be precise, they also assert
that the next thing will match one character later in the string, which
is why we talk about the tab character being "one character wide".  Some
assertions eat up some of the string as they match, and others don't.
But we usually reserve the term "assertion" for the zero-width
assertions.  We'll call these assertions with nonzero width <i class=emphasis>atoms</I>.)
You'll also see some things that aren't assertions.  Alternation is indicated
with a vertical bar:

<div class=programlisting>
<p>
<pre>
/Fred|Wilma|Barney|Betty/
</PRE>
</DIV>

<p class=para>
That means that any of those strings can trigger a match.
Grouping of various sorts is done with parentheses, including grouping
of alternating substrings within a longer regular expression:

<div class=programlisting>
<p>
<pre>
/(Fred|Wilma|Pebbles) Flintstone/
</PRE>
</DIV>

<p class=para>
Another thing you'll see are what we call quantifiers.  They say how many
of the previous thing should match in a row.  Quantifiers look like:

<div class=programlisting>
<p>
<pre>
* + ? *? {2,5}
</PRE>
</DIV>

<p class=para>
Quantifiers only make sense when attached to atoms, that is, assertions
that have width.  Quantifiers attach only to the previous atom, which in
human terms means they only quantify one character.  So if you want to
match three copies of "<tt class=literal>moo</tt>" in a row, you need to group the
"<tt class=literal>moo</tt>" with
parentheses, like this:

<div class=programlisting>
<p>
<pre>
/(moo){3}/
</PRE>
</DIV>

<p class=para>
That will match "<tt class=literal>moomoomoo</tt>".  If you'd said <tt class=literal>/moo{3}/</tt>, it
would only have matched "<tt class=literal>moooo</tt>".

<p class=para>
Since patterns are processed as double-quoted strings, the normal
double-quoted interpolations will work.  (See "String Literals" earlier in
this chapter.)  These are applied before the string is interpreted as
a regular expression.  One caveat though: any <tt class=literal>$</tt> immediately followed
by a vertical bar, closing parenthesis, or the end of the string will
be interpreted as an end-of-line assertion rather than a variable
interpolation.  So if you say:

<p class=para>
<div class=programlisting>
<p>
<pre>
$foo = "moo";
/$foo$/;
</PRE>
</DIV>

<p class=para>
it's equivalent to saying:

<p class=para>
<div class=programlisting>
<p>
<pre>
/moo$/;
</PRE>
</DIV>

<p class=para>
You should also know that interpolating variables into a pattern slows
down the pattern matcher considerably, because it feels it needs to recompile the
pattern each time through, since the variable might have changed.

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-4.1.2">The rules of regular expression matching</A></h4>

<p class=para>
<a name="CH02.OREM"></A><a name="CH02.REMO"></A><a name="CH02.PMO"></A>Now that you've seen some of the things you'll be seeing, we'll lay out
the rules that the Engine uses to match your pattern against the string.
The Perl Engine uses a nondeterministic finite-state automaton (NFA) to
find a match.  That just means that it keeps track of what it has tried
and what it hasn't, and when something doesn't pan out, it backs up and
tries something else.  This is called
<i class=emphasis>backtracking</I>.  The Perl Engine is capable of
trying a million things at one spot, then giving up on all those,
backing up to within one choice of the beginning, and trying the million
things again at a different spot.  If you're cagey, you can write
efficient patterns that don't do a lot of silly backtracking.

<p class=para>
The order of the rules below specifies which order the Engine tries
things.  So when someone trots out a stock phrase like "left-most,
longest match", you'll know that overall Perl prefers left-most over
longest.  But the Engine doesn't realize it's preferring anything at
that level.  The global preferences result from a lot of localized
choices.  The Engine thinks locally and acts globally.

<p class=para>
<b>Rule 1.</B>  The Engine tries to match as far left in the string
as it can, such that the entire regular expression matches under Rule 2.

<p class=para>
In order to do this, its first choice is to start just before the first
character (it could have started anywhere), and to try to match the
entire regular expression at that point.  The regular expression matches
if and only if Engine reaches the end of the regular expression before
it runs off the end of the string.  If it matches, it quits
immediately--it doesn't keep looking for a "better" match, even though
the regular expression could match in many different ways.  The match
only has to reach the end of the regular expression; it doesn't have to
reach the end of the string, unless there's an assertion in the regular
expression that says it must.  If it exhausts all possibilities at the
first position, it realizes that its very first choice was wrong, and
proceeds to its second choice.  It goes to the second position in the
string (between the first and second characters), and tries all the
possibilities again.  If it succeeds, it stops.  If it fails, it
continues on down the string.  The pattern match as a whole doesn't fail
until it has tried to match the entire regular expression at every
position in the string, including after the last character in the
string.

<p class=para>
Note that the positions it's trying to match at are <i class=emphasis>between</I> the
characters of the string.  This rule sometimes surprises people when
they write a pattern like <tt class=literal>/x*/</tt> that can match zero or more <tt class=literal>x</tt>'s.
If you try the pattern on a string like "<tt class=literal>fox</tt>", it will match the null
string before the "<tt class=literal>f</tt>" in preference to the "<tt class=literal>x</tt>" that's later in the
string.  If you want it to match one or more <tt class=literal>x</tt>'s, you need to tell
it that by using <tt class=literal>/x+/</tt> instead.  See the quantifiers under Rule 5.

<p class=para>
A corollary to this rule is that any regular expression that can match
the null string is guaranteed to match at the leftmost position in the string.

<p class=para>
<b>Rule 2.</B>  For this rule, the whole
regular expression is regarded as a set of alternatives (where the
degenerate case is just a set with one alternative). If there are two
or more alternatives, they are syntactically separated by the
<tt class=literal>|</tt> character (usually called a vertical bar). A set 
of alternatives matches a string if any of the
alternatives match under Rule 3.  It tries the alternatives
left-to-right (according to their position in the regular expression),
and stops on the first match that allows successful completion of the
entire regular expression.  If none of the alternatives matches, it
backtracks to the Rule that invoked this Rule, which is usually Rule 1,
but could be Rule 4 or 6.  That rule will then look for a new position
at which to apply Rule 2.

<p class=para>
If there's only
one alternative, then it either it matches or doesn't, and the rule
still applies.  (There's no such thing as zero alternatives, because a
null string can always match something of zero width.)

<p class=para>
<b>Rule 3.</B>  Any particular alternative matches if every item in the
alternative matches sequentially according to Rules 4 and 5 (such that the
entire regular expression can be satisfied).  An item consists of either
an assertion, which is covered in Rule 4, or a quantified atom, which is
covered by Rule 5.  Items that have choices on how to match are given
"pecking order" from left to right.  If the items cannot be matched in
order, the Engine backtracks to the next alternative under Rule 2.

<p class=para>
Items that must be matched sequentially aren't separated in the regular
expression by anything
syntactic--they're merely juxtaposed in the order they must match.
When you ask to match <tt class=literal>/^foo/</tt>, you're actually asking for four items
to be matched one after the other.  The first is a zero-width assertion,
and the other three are ordinary letters that must match themselves, one
after the other.

<p class=para>
The left-to-right pecking order means that in a pattern like:

<div class=programlisting>
<p>
<pre>
/x*y*/
</PRE>
</DIV>

<p class=para>
<tt class=literal>x</tt> gets to pick one way to match, and then <tt class=literal>y</tt> tries all its ways.  If that
fails, then <tt class=literal>x</tt> gets to pick its second choice, and make <tt class=literal>y</tt> try all of its
ways again.  And so on.  The items to the right vary faster, to borrow
a phrase from multi-dimensional arrays.

<p class=para>
<b>Rule 4.</B>  An assertion must match according to this table.  If the
assertion does not match at the current position, the Engine backtracks to
Rule 3 and retries higher-pecking-order items with different choices.

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-7"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Assertion</TH>
<th align="LEFT">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>^</tt></TD>
<td align="LEFT">

<p class=para>
Matches at the beginning of the string (or line, if <b>/m</B> used)</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>$</tt></TD>
<td align="LEFT">

<p class=para>
Matches at the end of the string (or line, if <b>/m</B> used)</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\b</tt></TD>
<td align="LEFT">

<p class=para>
Matches at word boundary (between <tt class=literal>\w</tt> and <tt class=literal>\W</tt>)</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\B</tt></TD>
<td align="LEFT">

<p class=para>
Matches except at word boundary</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\A</tt></TD>
<td align="LEFT">

<p class=para>
Matches at the beginning of the string</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\Z</tt></TD>
<td align="LEFT">

<p class=para>
Matches at the end of the string</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\G</tt></TD>
<td align="LEFT">

<p class=para>
Matches where previous <tt class=literal>m//g</tt> left off</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>(?=...)</tt></TD>
<td align="LEFT">

<p class=para>
Matches if engine would match <tt class=literal>...</tt> next</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>(?!...)</tt></TD>
<td align="LEFT">

<p class=para>
Matches if engine wouldn't match <tt class=literal>...</tt> next</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
The <tt class=literal>$</tt> and <tt class=literal>\Z</tt> assertions can match not only at the end of the
string, but also one character earlier than that, if the last character
of the string happens to be a newline.

<p class=para>
The positive <tt class=literal>(?=...)</tt> and negative <tt class=literal>(?!...)</tt> lookahead assertions are
zero-width themselves, but assert that the regular expression
represented above by <tt class=literal>...</tt> would (or would not) match at this point,
were we to attempt it.  In fact, the Engine does attempt it.  The Engine
goes back to Rule 2 to test the subexpression, and then wipes out any
record of how much string was eaten, returning only the success or
failure of the subexpression as the value of the assertion.  We'll show
you some examples later.
<p class=para>
<a name="CH02.ATOMS"></A><b>Rule 5.</B>  A quantified atom matches only if the atom itself matches
some number of times allowed by the quantifier.  (The atom is matched
according to Rule 6.) Different quantifiers require different numbers of
matches, and most of them allow a range of numbers of matches.  Multiple
matches must all match in a row, that is, they must be adjacent within
the string.  An unquantified atom is assumed to have a quantifier
requiring exactly one match.  Quantifiers constrain and control matching
according to the table below.  If no match can be found at the current
position for any allowed quantity of the atom in question, the Engine
backtracks to Rule 3 and retries higher-pecking-order items with
different choices.

<p class=para>
Quantifiers are:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-8"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left"><b>Maximal</B></TH>
<th align="left"><b>Minimal</B></TH>
<th align="LEFT"><b>Allowed Range</B></TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>{</tt><i class=emphasis>n</I>,<i class=emphasis>m</I><tt class=literal>}</tt></TD>
<td align="left"><tt class=literal>{</tt><i class=emphasis>n</I>,<i class=emphasis>m</I><tt class=literal>}?</tt></TD>
<td align="LEFT">

<p class=para>
Must occur at least <i class=emphasis>n</I> times but no more than <i class=emphasis>m</I> times</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>{</tt><i class=emphasis>n</I><tt class=literal>,}</tt></TD>
<td align="left"><tt class=literal>{</tt><i class=emphasis>n</I><tt class=literal>,}?</tt></TD>
<td align="LEFT">

<p class=para>
Must occur at least <i class=emphasis>n</I> times</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>{</tt><i class=emphasis>n</I><tt class=literal>}</tt></TD>
<td align="left"><tt class=literal>{</tt><i class=emphasis>n</I><tt class=literal>}?</tt></TD>
<td align="LEFT">

<p class=para>
Must match exactly <i class=emphasis>n</I> times</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>*</tt></TD>
<td align="left"><tt class=literal>*?</tt></TD>
<td align="LEFT">

<p class=para>
0 or more times (same as <tt class=literal>{0,}</tt>)</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>+</tt></TD>
<td align="left"><tt class=literal>+?</tt></TD>
<td align="LEFT">

<p class=para>
1 or more times (same as <tt class=literal>{1,}</tt>)</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>?</tt></TD>
<td align="left"><tt class=literal>??</tt></TD>
<td align="LEFT">

<p class=para>
0 or 1 time (same as <tt class=literal>{0,1}</tt>)</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
If a brace occurs in any other context, it is treated as a regular
character.  <i class=emphasis>n</I> and <i class=emphasis>m</I> are
limited to integral values less than 65,536.

<p class=para>
If you use the
<tt class=literal>{</tt><i class=emphasis>n</I><tt class=literal>}</tt> form,
then there is no choice, and the atom must match exactly that number
of times or not at all.  Otherwise, the atom can match over a range of
quantities, and the Engine keeps track of all the choices so that it
can backtrack if necessary.  But then the question arises as to which
of these choices to try first.  One could start with the maximal
number of matches and work down, or the minimal number of matches and
work up.

<p class=para>
The quantifiers in the left column above try the biggest quantity first.
This is often called "greedy" matching.  To find the greediest match,
the Engine doesn't actually count down from the maximum value, which
after all could be infinity.   What actually happens in this case is
that the Engine first counts up to find out how many atoms it's
possible to match in a row in the current string, and then it
remembers all the shorter choices and starts out from the longest one.  This could fail, of course, in which case it backtracks
to a shorter choice.

<p class=para>
If you say <tt class=literal>/.*foo/</tt>, for example, it will try to match the maximal
number of "any" characters (represented by the dot) clear out to the end
of the line before it ever tries looking for "<tt class=literal>foo</tt>", and then when the
"<tt class=literal>foo</tt>" doesn't match there (and it can't, because there's not enough room
for it at the end of the string), the Engine will back off one character
at a time until it finds a "<tt class=literal>foo</tt>".  If there is more than one "<tt class=literal>foo</tt>" in
the line, it'll stop on the last one, and throw away all the shorter
choices it could have made.

<p class=para>
By placing a question mark after any of the greedy quantifiers, they
can be made to choose the smallest quantity for the first try.  So if
you say <tt class=literal>/.*?foo/</tt>, the <tt class=literal>.*?</tt> first
tries to match 0 characters, then 1 character, then 2, and so on until
it can match the "<tt class=literal>foo</tt>".  Instead of backtracking backward, it
backtracks forward, so to speak, and ends up finding the first "<tt class=literal>foo</tt>"
on the line instead of the last.

<p class=para>
<b>Rule 6.</B> Each atom matches according to
its type, listed below.  If the atom doesn't match (or doesn't allow a
match of the rest of the regular expression), the Engine backtracks to
Rule 5 and tries the next choice for the atom's quantity.

<p class=para>
Atoms match according to the following types:

<p>
<ul class=itemizedlist>
<li class=listitem>A regular expression in parentheses, <tt class=literal>(...)</tt>, matches whatever the
regular expression (represented by <tt class=literal>...</tt>) matches according to Rule 2.
Parentheses therefore serve as a grouping operator for quantification.
Parentheses also have the side effect of remembering the matched
substring for later use in a <i class=emphasis>backreference</I> (to be
discussed later).  This side
effect can be suppressed by using <tt class=literal>(?:...)</tt> instead, which has only
the grouping semantics--it doesn't store anything in <b>$1</B>, <b>$2</B>, and so on.

<p>
<li class=listitem>A "<tt class=literal>.</tt>" matches any character except <tt class=literal>\n</tt>.  (It also matches
<tt class=literal>\n</tt> if you use the <b>/s</B> modifier.)  The main use of
dot is as a vehicle for a minimal or maximal quantifier.  A
<tt class=literal>.*</tt> matches a maximal number of don't-care characters, while a
<tt class=literal>.*?</tt> matches a minimal number of don't-care characters.  But it's
also sometimes used within parentheses for its width:
<tt class=literal>/(..):(..):(..)/</tt> matches three colon-separated fields, each of
which is two characters long.

<p>
<li class=listitem>A list of characters in square brackets (called a <i class=emphasis>character class</I>) matches
any one of the characters in the list.
A caret at the front of the list causes it to match only characters that
are <i class=emphasis>not</I> in the list.  Character ranges may be indicated using the
<tt class=literal>a-z</tt> notation.  You may also use any of <tt class=literal>\d</tt>, <tt class=literal>\w</tt>,
<tt class=literal>\s</tt>, <tt class=literal>\n</tt>, <tt class=literal>\r</tt>, <tt class=literal>\t</tt>, <tt class=literal>\f</tt>, or
<tt class=literal>\</tt><i class=emphasis>nnn</I>, as listed below.  A <tt class=literal>\b</tt> means a backspace
in a character class.  You may use a backslash to protect a hyphen that
would otherwise be interpreted as a range delimiter.  To match a right
square bracket, either backslash it or place it first in the list.  To
match a caret, <i class=emphasis>don't</I> put it first.  Note that most other
metacharacters lose their meta-ness inside square brackets.  In
particular, it's meaningless to specify alternation in a character
class, since the characters are interpreted individually.  For example,
<tt class=literal>[fee|fie|foe]</tt> means the same thing as <tt class=literal>[feio|]</tt>.

<p>
<li class=listitem>A backslashed letter matches a special character or character class:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-9"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Code</TH>
<th align="left">Matches</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\a</tt></TD>
<td align="left">Alarm (beep)</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\n</tt></TD>
<td align="left">Newline</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\r</tt></TD>
<td align="left">Carriage return</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\t</tt></TD>
<td align="left">Tab</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\f</tt></TD>
<td align="left">Formfeed</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\e</tt></TD>
<td align="left">Escape</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\d</tt></TD>
<td align="left">A digit, same as <tt class=literal>[0-9]</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\D</tt></TD>
<td align="left">A nondigit</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\w</tt></TD>
<td align="left">A word character (alphanumeric), same as <tt class=literal>[a-zA-Z_0-9]</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\W</tt></TD>
<td align="left">A nonword character</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\s</tt></TD>
<td align="left">A whitespace character, same as <tt class=literal>[ \t\n\r\f]</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\S</tt></TD>
<td align="left">A non-whitespace character</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
Note that <tt class=literal>\w</tt> matches a character of a word, not a whole word.  Use
<tt class=literal>\w+</tt> to match a word.

<p>
<li class=listitem>A backslashed single-digit number matches whatever the corresponding
parentheses actually matched (except that <tt class=literal>\0</tt> matches a null
character).  This is called a <i class=emphasis>backreference</I> to a substring.  A
backslashed multi-digit number such as <tt class=literal>\10</tt> will be considered a
backreference if the pattern contains at least that many substrings
prior to it, and the number does not start with a <tt class=literal>0</tt>.  Pairs of
parentheses are numbered by counting left parentheses from the left.

<p>
<li class=listitem>A backslashed two- or three-digit octal number such as <tt class=literal>\033</tt> matches the
character with the specified value, unless it would be interpreted as a
backreference.

<p>
<li class=listitem>A backslashed <tt class=literal>x</tt> followed by one or two hexadecimal digits, such as
<tt class=literal>\x7f</tt>, matches the character having that hexadecimal value.

<p>
<li class=listitem>A backslashed <tt class=literal>c</tt> followed by a single character, such as <tt class=literal>\cD</tt>,
matches the corresponding control character.

<p>
<li class=listitem>Any other backslashed character matches that character.

<p>
<li class=listitem>Any character not mentioned above matches itself.

<p>
</UL>
</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-4.1.3">The fine print</A></h4>

<p class=para>
As mentioned above, <tt class=literal>\1</tt>, <tt class=literal>\2</tt>, <tt class=literal>\3</tt>, and so on, are
equivalent to whatever the corresponding set of parentheses matched,
counting opening parentheses from left to right.  (If the particular
pair of parentheses had a quantifier such as <tt class=literal>*</tt> after it, such
that it matched a series of substrings, then only the last match counts
as the backreference.) Note that such a backreference matches whatever
actually matched for the subpattern in the string being examined;
it's not just a shorthand for the rules of that subpattern.  Therefore,
<tt class=literal>(0|0x)\d*\s\1\d*</tt> will match "<tt class=literal>0x1234 0x4321</tt>", but not "<tt class=literal>0x1234
01234</tt>", since subpattern <tt class=literal>1</tt> actually matched "<tt class=literal>0x</tt>", even though the rule
<tt class=literal>0|0x</tt> could potentially match the leading <tt class=literal>0</tt> in the second number.

<p class=para>
Outside of the pattern (in particular, in the replacement of a
substitution operator) you can continue to refer to backreferences by
using <tt class=literal>$</tt> instead of <tt class=literal>\</tt> in front of
the number.  The variables <b>$1</B>,
<b>$2</B>, <b>$3</B> . . . are automatically localized, and their
scope (and that of <b>$</B>&nbsp;<tt class=literal>`</tt>, <b>$&amp;</B>, and <b>$</B>&nbsp;<tt class=literal>'</tt> below) extends to the end of the enclosing block or <a href="ch03_02.htm">eval</A> string, or to the next successful pattern
match, whichever comes first.
(The <tt class=literal>\1</tt> notation sometimes works outside the current pattern, but
should not be relied upon.) <b>$+</B> returns whatever the last bracket
match matched.  <b>$&amp;</B> returns the entire matched string. <b>$</B><tt class=literal>`</tt> returns everything before the matched string.[24]
<b>$</B><tt class=literal>'</tt> returns everything after the matched string.  For more explanation
of these magical variables (and for a way to write them in English), see
the section "Special Variables" at the end of this chapter.

<blockquote class=footnote>
<p class=para>[24] 
In the case of something like
<tt class=literal>s/pattern/length($`)/eg</tt>, which does
multiple replacements if the pattern occurs multiple times, the value of
<b>$</B><tt class=literal>`</tt> does not include any modifications done by previous replacement
iterations.  To get the other effect, say:
<p class=para>
<div class=programlisting>
<p>
<pre>
1 while s/pattern/length($`)/e;
</PRE>
</DIV>
<p class=para>
For example, to change all tabs to the corresponding number of spaces,
you could say:
<p class=para>
<div class=programlisting>
<p>
<pre>
1 while s/\t+/' ' x (length($&amp;) * 8 - length($`) % 8)/e;
</PRE>
</DIV>
</blockquote>
<p class=para>
You may have as many parentheses as you wish.  If you have more
than nine pairs, the variables <b>$10</B>, <b>$11</B>, . . . refer to the
corresponding substring.  Within the pattern, <tt class=literal>\10</tt>, <tt class=literal>\11</tt>, and so on, refer back
to substrings if there have been at least that many left parentheses before
the backreference.  Otherwise (for backward compatibility) <tt class=literal>\10</tt> is the
same as <tt class=literal>\010</tt>, a backspace, and <tt class=literal>\11</tt> the same as <tt class=literal>\011</tt>, a tab.  And so
on.  (<tt class=literal>\1</tt> through <tt class=literal>\9</tt> are always backreferences.)

<p class=para>
Examples:

<p class=para>
<div class=programlisting>
<p>
<pre>
s/^([^ ]+) +([^ ]+)/$2 $1/;   # swap first two words
/(\w+)\s*=\s*\1/;             # match "foo = foo"
/.{80,}/;                     # match line of at least 80 chars
/^(\d+\.?\d*|\.\d+)$/;        # match valid number
if (/Time: (..):(..):(..)/) { # pull fields out of a line
        $hours   = $1;
        $minutes = $2;
        $seconds = $3;
}
</PRE>
</DIV>

<p class=para>
Hint: instead of writing patterns like <tt class=literal>/(...)(..)(.....)/</tt>, use the
<a href="ch03_02.htm">unpack</A> function.  It's more efficient.

<p class=para>
A word boundary (<tt class=literal>\b</tt>) is defined as a spot between two
characters that has a <tt class=literal>\w</tt> on one side of it and a
<tt class=literal>\W</tt> on the other side of it (in either order), counting the
imaginary characters off the beginning and end of the string as matching
a <tt class=literal>\W</tt>.  (Within character classes <tt class=literal>\b</tt> represents
backspace rather than a word boundary.)

<p class=para>
Normally, the <tt class=literal>^</tt> character is guaranteed to match only at the
beginning of the string, the <tt class=literal>$</tt> character only at the end (or
before the newline at the end), and Perl does certain optimizations with
the assumption that the string contains only one line.  Embedded
newlines will not be matched by <tt class=literal>^</tt> or <tt class=literal>$</tt>.  However, you may
wish to treat a string as a multi-line buffer, such that the
<tt class=literal>^</tt> will also match after any newline within the string, and <tt class=literal>$</tt>
will also match before any newline.  At the cost of a little more overhead,
you can do this by using the <b>/m</B> modifier on the pattern match
operator.  (Older programs did this by setting <b>$*</B>, but this
practice is now deprecated.)  <tt class=literal>\A</tt> and <tt class=literal>\Z</tt> are just
like <tt class=literal>^</tt> and <tt class=literal>$</tt> except that they won't match multiple times
when the <b>/m</B> modifier is used, while <tt class=literal>^</tt> and <tt class=literal>$</tt> will
match at every internal line boundary.  To match the actual end of the
string, not ignoring newline, you can use <tt class=literal>\Z(?!\n)</tt>.  There's
an example of a negative lookahead assertion.

<p class=para>
To facilitate multi-line substitutions, the <tt class=literal>.</tt> character never matches a
newline unless you use the <b>/s</B> modifier, which tells Perl to pretend
the string is a single line--even if it isn't.  (The <b>/s</B> modifier also
overrides the setting of <b>$*</B>, in case you have some (badly behaved) older
code that sets it in another module.)
In particular, the following leaves a newline on the <b>$_</B> string:

<p class=para>
<div class=programlisting>
<p>
<pre>
$_ = &lt;STDIN&gt;;
s/.*(some_string).*/$1/;
</PRE>
</DIV>

<p class=para>
If the newline is unwanted, use any of these:

<p class=para>
<div class=programlisting>
<p>
<pre>
s/.*(some_string).*/$1/s;
s/.*(some_string).*\n/$1/;
s/.*(some_string)[^\0]*/$1/;
s/.*(some_string)(.|\n)*/$1/;
chop; s/.*(some_string).*/$1/;
/(some_string)/ &amp;&amp; ($_ = $1);
</PRE>
</DIV>

<p class=para>
Note that all backslashed metacharacters in Perl are
alphanumeric, such as <tt class=literal>\b</tt>, <tt class=literal>\w</tt>,
and <tt class=literal>\n</tt>.  Unlike some regular expression languages, there are no backslashed
symbols that aren't alphanumeric.  So anything that looks like
<tt class=literal>\\</tt>, <tt class=literal>\(</tt>, <tt class=literal>\)</tt>, <tt class=literal>\&lt;</tt>, <tt class=literal>\&gt;</tt>,
<tt class=literal>\{</tt>, or <tt class=literal>\}</tt> is always interpreted as a literal
character, not a metacharacter.  This makes it simple to quote a string
that you want to use for a pattern but that you are afraid might contain
metacharacters.
Just quote all the non-alphanumeric characters:

<p class=para>
<div class=programlisting>
<p>
<pre>
$pattern =~ s/(\W)/\\$1/g;
</PRE>
</DIV>

<p class=para>
You can also use the built-in <a href="ch03_02.htm">quotemeta</A> function to do this.
An even easier way to quote metacharacters right in the match operator
is to say:

<p class=para>
<div class=programlisting>
<p>
<pre>
/$unquoted\Q$quoted\E$unquoted/
</PRE>
</DIV>

<p class=para>
Remember that the first and last alternatives (before the first <tt class=literal>|</tt> and
after the last one) tend to gobble up the other elements of the regular
expression on either side, out
to the ends of the expression, unless there are enclosing parentheses.  A
common mistake is to ask for:

<p class=para>
<div class=programlisting>
<p>
<pre>
/^fee|fie|foe$/
</PRE>
</DIV>

<p class=para>
when you really mean:

<p class=para>
<div class=programlisting>
<p>
<pre>
/^(fee|fie|foe)$/
</PRE>
</DIV>

<p class=para>
The first matches "<tt class=literal>fee</tt>" at the beginning of the string, or
"<tt class=literal>fie</tt>" anywhere, or "<tt class=literal>foe</tt>" at the end of the string.  The second
matches any string consisting solely of "<tt class=literal>fee</tt>" or "<tt class=literal>fie</tt>" or
"<tt class=literal>foe</tt>".

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-4.1.4">Regular expression extensions</A></h4>

<p class=para>
Perl defines a consistent extension syntax for regular expressions.
You've seen some of them already.
The syntax is a pair of parentheses with a question mark as the first thing
within the parentheses.[25]
The character after the question mark gives the function of the extension.
Several extensions are already supported:

<blockquote class=footnote>
<p class=para>[25] 
This was a syntax error in older versions of Perl.  If you try to use this
and have problems, upgrade to the newest version.
</blockquote>
<p>
<dl class=variablelist>
<dt class=varlistentry><tt class=literal>(?#text)</tt><dd>

<p class=para>
A comment.  The text is ignored.  If the <b>/x</B> switch is used to enable
whitespace formatting, a simple <tt class=literal>#</tt> will suffice.

<p>
<dt class=varlistentry><tt class=literal>(?:...)</tt><dd>

<p class=para>
This groups things like "<tt class=literal>(...)</tt>" but doesn't make backreferences like "<tt class=literal>(...)</tt>" does.  So:

<p class=para>
<div class=programlisting>
<p>
<pre>
split(/\b(?:a|b|c)\b/)
</PRE>
</DIV>

<p class=para>
is like:

<p class=para>
<div class=programlisting>
<p>
<pre>
split(/\b(a|b|c)\b/)
</PRE>
</DIV>

<p class=para>
but doesn't actually save anything in <b>$1</B>, which means
that the first <a href="ch03_02.htm">split</A> doesn't spit out extra delimiter fields
as the second one does.

<p>
<dt class=varlistentry><tt class=literal>(?=...)</tt><dd>

<p class=para>
A zero-width positive lookahead assertion.  For example, <tt class=literal>/\w+(?=\t)/</tt>
matches a word followed by a tab, without including the tab in <b>$&amp;</B>.

<p>
<dt class=varlistentry><tt class=literal>(?!...)</tt><dd>

<p class=para>
A zero-width negative lookahead assertion.  For example <tt class=literal>/foo(?!bar)/</tt>
matches any occurrence of "<tt class=literal>foo</tt>" that isn't followed by "<tt class=literal>bar</tt>".  Note,
however, that lookahead and lookbehind are <i class=emphasis>not</I> the same thing.  You cannot
use this for lookbehind: <tt class=literal>/(?!foo)bar/</tt> will not find an occurrence of
"<tt class=literal>bar</tt>" that is preceded by something that is not "<tt class=literal>foo</tt>".  That's because
the <tt class=literal>(?!foo)</tt> is just saying that the next thing cannot be "<tt class=literal>foo</tt>"--and
it's not, it's a "<tt class=literal>bar</tt>", so "<tt class=literal>foobar</tt>" will match.  You would have to do
something like <tt class=literal>/(?!foo)</tt>...<tt class=literal>bar/</tt> for that.   We say "like" because there's
the case of your "<tt class=literal>bar</tt>" not having three characters before it.  You could
cover that this way: <tt class=literal>/(?:(?!foo)</tt>. . .<tt class=literal>|^</tt>. .<tt class=literal>?)bar/</tt>.  Sometimes it's still
easier just to say:

<p class=para>
<div class=programlisting>
<p>
<pre>
if (/bar/ and $` !~ /foo$/)
</PRE>
</DIV>

<p>
<dt class=varlistentry><tt class=literal>(?imsx)</tt><dd>

<p class=para>
One or more embedded pattern-match modifiers.  This is particularly
useful for patterns that are specified in a table somewhere, some of
which want to be case-sensitive, and some of which don't.  The case-insensitive ones merely need to include <tt class=literal>(?i)</tt> at the front of the
pattern.  For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
# hardwired case insensitivity
$pattern = "buffalo";
if ( /$pattern/i )
# data-driven case insensitivity
$pattern = "(?i)buffalo";
if ( /$pattern/ )
</PRE>
</DIV>

</DL>
<p class=para>
We chose to use the question mark for this (and for the new minimal
matching construct) because (1) question mark is pretty rare in older
regular expressions, and (2) whenever you see one, you should stop
and <i class=emphasis>question</I> exactly what is going on.  That's psychology.

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-4.2">Pattern-Matching Operators</A></h3>

<p class=para>
Now that we've got all that out of the way, here finally are the
quotelike operators (er, terms) that perform pattern matching and related
activities.<a name="CH02.MO1"></A><a name="CH02.MO2"></A>

<p>
<dl class=variablelist>
<dt class=varlistentry><tt class=literal>m/</tt><tt class=replaceable><i>PATTERN</i></tt><tt class=literal>/gimosx</tt> <tt class=literal>/</tt><tt class=replaceable><i>PATTERN</i></tt><tt class=literal>/gimosx</tt><dd>

<p class=para>
This operator searches a string for a pattern match, and in a scalar context
returns true (<tt class=literal>1</tt>) or false (<tt class=literal>"&nbsp;"</tt>).  If no string is specified via
the <tt class=literal>=~</tt> or <tt class=literal>!~</tt> operator, the
<b>$_</B> string is searched.  (The string
specified with <tt class=literal>=~</tt> need not be an lvalue--it
may be the result of an expression evaluation, but remember the
<tt class=literal>=~</tt> binds rather tightly, so you may need
parentheses around your expression.)</DL>
<p class=para>
Modifiers are:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-9A"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Modifier</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>g</tt></TD>
<td align="left">Match globally, that is, find all occurrences.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>i</tt></TD>
<td align="left">Do case-insensitive pattern matching.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>m</tt></TD>
<td align="left">Treat string as multiple lines.      <i class=emphasis>(continued)</I></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>o</tt></TD>
<td align="left">Only compile pattern once.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>s</tt></TD>
<td align="left">Treat string as single line.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>x</tt></TD>
<td align="left">Use extended regular expressions.</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
If <tt class=literal>/</tt> is the delimiter then the initial <tt class=literal>m</tt> is optional.  With the <tt class=literal>m</tt>
you can use any pair of non-alphanumeric, non-whitespace characters as
delimiters.  This is particularly useful for matching filenames
that contain "<tt class=literal>/</tt>", thus avoiding LTS (leaning toothpick syndrome).

<p class=para>
<tt class=replaceable><i>PATTERN</i></tt> may contain variables, which will be interpolated (and the
pattern recompiled) every time the pattern search is evaluated.  (Note
that <b>$)</B> and <b>$|</B> will not be interpolated because they look
like end-of-line tests.)  If you want such a pattern to be compiled only
once, add a <b>/o</B> after the trailing delimiter.  This avoids
expensive run-time recompilations, and is useful when the value you are
interpolating won't change during execution.  However,
mentioning <b>/o</B> constitutes a promise that you won't change the
variables in the pattern.  If you do change them, Perl won't even
notice.

<p class=para>
If the <tt class=replaceable><i>PATTERN</i></tt> evaluates to a null string, the last successfully
executed regular expression not hidden within an inner block (including
<a href="ch03_02.htm">split</A>, <a href="ch03_02.htm">grep</A>, and <a href="ch03_02.htm">map</A>) is used instead.

<p class=para>
If used in a context that requires a list value, a pattern match returns
a list consisting of the subexpressions matched by the parentheses in
the pattern--that is, (<b>$1</B>, <b>$2</B>, <b>$3</B> . . . ). (The variables are
also set.)  If the match fails, a null list is returned.  If the match
succeeds, but there were no parentheses, a list value of (1) is
returned.

<p class=para>
Examples:

<p class=para>
<div class=programlisting>
<p>
<pre>
# case insensitive matching
open(TTY, '/dev/tty');
&lt;TTY&gt; =~ /^y/i and foo();    # do foo() if they want it
# pulling a substring out of a line
if (/Version: *([0-9.]+)/) { $version = $1; }
# avoiding Leaning Toothpick Syndrome
next if m#^/usr/spool/uucp#;
# poor man's grep
$arg = shift;
while (&lt;&gt;) {
    print if /$arg/o;       # compile only once
}
# get first two words and remainder as a list
if (($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/))
</PRE>
</DIV>

<p class=para>
This last example splits <tt class=literal>$foo</tt> into the first two words and the
remainder of the line, and assigns those three fields to <tt class=literal>$F1</tt>,
<tt class=literal>$F2</tt>, and <tt class=literal>$Etc</tt>.  The conditional is true if any variables
were assigned, that is, if the pattern matched.  Usually, though, one would
just write the equivalent <a href="ch03_02.htm">split</A>:

<p class=para>
<div class=programlisting>
<p>
<pre>
if (($F1, $F2, $Etc) = split(' ', $foo, 3))
</PRE>
</DIV>

<p class=para>
The <b>/g</B> modifier specifies global pattern matching--that is, matching
as many times as possible within the string.  How it behaves depends on
the context.  In a list context, it returns a list of all the
substrings matched by all the parentheses in the regular expression.
If there are no parentheses, it returns a list of all the matched
strings, as if there were parentheses around the whole pattern.

<p class=para>
In a scalar context, <b>m//g</B> iterates through the string, returning true
each time it matches, and false when it eventually runs out of
matches.  (In other words, it remembers where it left off last time and
restarts the search at that point.  You can find the current
match position of a string using the <a href="ch03_02.htm">pos</A> function--see <a href="ch03_01.htm">Chapter 3, <i>Functions</i></A>.)
If you modify the string in any way, the match position is reset to the
beginning.  Examples:

<p class=para>
<div class=programlisting>
<p>
<pre>
# list context--extract three numeric fields from uptime command
($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);
# scalar context--count sentences in a document by recognizing
# sentences ending in [.!?], perhaps with quotes or parens on 
# either side.  Observe how dot in the character class is a literal
# dot, not merely any character.
$/ = "";  # paragraph mode
while ($paragraph = &lt;&gt;) {
    while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
        $sentences++;
    }
}
print "$sentences\n";
# find duplicate words in paragraphs, possibly spanning line boundaries.
#   Use /x for space and comments, /i to match the both `is' 
#   in "Is is this ok?", and use /g to find all dups.
$/ = "";        # paragrep mode again
while (&lt;&gt;) {
    while ( m{
                \b            # start at a word boundary
                (\w\S+)       # find a wordish chunk
                ( 
                    \s+       # separated by some whitespace
                    \1        # and that chunk again
                ) +           # repeat ad lib
                \b            # until another word boundary
             }xig
         ) 
    {
        print "dup word `$1' at paragraph $.\n";
    } 
}
</PRE>
</DIV>

<p>
<dl class=variablelist>
<dt class=varlistentry><tt class=literal>?</tt><tt class=replaceable><i>PATTERN</i></tt><tt class=literal>?</tt><dd>

<p class=para>
This is just like the
<tt class=literal>/</tt><tt class=replaceable><i>PATTERN</i></tt><tt class=literal>/</tt>
search, except that it matches only once between calls to the
<a href="ch03_02.htm">reset</A> operator.  This is a useful
optimization when you only want to see the first occurrence of
something in each file of a set of files, for instance.  Only
<tt class=literal>??</tt> patterns local to the current package are reset.</DL>
<p class=para>
This usage is vaguely deprecated, and may be removed in some future
version of Perl.  Most people just bomb out of the loop when they
get the match they want.

<p>
<dl class=variablelist>
<dt class=varlistentry><tt class=literal>s/</tt><tt class=replaceable><i>PATTERN</i></tt><tt class=literal>/</tt><tt class=replaceable><i>REPLACEMENT</i></tt><tt class=literal>/egimosx</tt><dd>

<p class=para>
<a name="CH02.SO1"></A><a name="CH02.SO2"></A>This operator searches a string for <tt class=replaceable><i>PATTERN</i></tt>, and if found, replaces
that match with the <tt class=replaceable><i>REPLACEMENT</i></tt> text and returns the number of
substitutions made, which can be more than one with the <b>/g</B> modifier.
Otherwise it returns false (0).</DL>
<p class=para>
If no string is specified via the <tt class=literal>=~</tt> or <tt class=literal>!~</tt> operator, the
<b>$_</B> variable is searched and modified.  (The string specified with
<tt class=literal>=~</tt> must be a scalar variable, an array element, a hash element,
or an assignment to one of those, that is, an lvalue.)

<p class=para>
If the delimiter you choose happens to be a single quote, no variable
interpolation is done on either the <tt class=replaceable><i>PATTERN</i></tt> or the <tt class=replaceable><i>REPLACEMENT</i></tt>.
Otherwise, if the <tt class=replaceable><i>PATTERN</i></tt> contains a <tt class=literal>$</tt> that looks like a variable rather
than an end-of-string test, the variable will be interpolated into the
<tt class=replaceable><i>PATTERN</i></tt> at run-time.  If you want the <tt class=replaceable><i>PATTERN</i></tt>
compiled only once, when the
variable is first interpolated, use the <b>/o</B> option.  If the
<tt class=replaceable><i>PATTERN</i></tt> evaluates to a null string, the
last successfully executed
regular expression is used instead.  The <tt class=replaceable><i>REPLACEMENT</i></tt> pattern also
undergoes variable interpolation, but it does so each time the <tt class=replaceable><i>PATTERN</i></tt>
matches, unlike the <tt class=replaceable><i>PATTERN,</i></tt> which just gets interpolated once when
the operator is evaluated.  (The <tt class=replaceable><i>PATTERN</i></tt> can match multiple times in one
evaluation if you use the <b>/g</B> option below.)

<p class=para>
Modifiers are:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-9B"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Modifier</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>e</tt></TD>
<td align="left">Evaluate the right side as an expression.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>g</tt></TD>
<td align="left">Replace globally, that is, all occurrences.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>i</tt></TD>
<td align="left">Do case-insensitive pattern matching.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>m</tt></TD>
<td align="left">Treat string as multiple lines.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>o</tt></TD>
<td align="left">Only compile pattern once.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>s</tt></TD>
<td align="left">Treat string as single line.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>x</tt></TD>
<td align="left">Use extended regular expressions.</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
Any non-alphanumeric, non-whitespace delimiter may replace the slashes.
If single quotes are used, no interpretation is done on the replacement
string (the <b>/e</B> modifier overrides this, however). If the <tt class=replaceable><i>PATTERN</i></tt> is contained
within naturally paired delimiters (such as parentheses), the
<tt class=replaceable><i>REPLACEMENT</i></tt> has its own pair of delimiters, which may or may not be
the same ones used for <tt class=replaceable><i>PATTERN</i></tt>--for example, <tt class=literal>s(foo)(bar)</tt> or
<tt class=literal>s&lt;foo&gt;/bar/</tt>.  A <b>/e</B> will cause the replacement portion to be
interpreted as a full-fledged Perl expression instead of as a
double-quoted string.  (It's kind of like an <a href="ch03_02.htm">eval</A>, but its
syntax is checked at compile-time.)

<p class=para>
Examples:

<p class=para>
<div class=programlisting>
<p>
<pre>
# don't change wintergreen
s/\bgreen\b/mauve/g;
# avoid LTS with different quote characters
$path =~ s(/usr/bin)(/usr/local/bin);
# interpolated pattern and replacement
s/Login: $foo/Login: $bar/;
# modifying a string "en passant"
($foo = $bar) =~ s/this/that/;
# counting the changes
$count = ($paragraph =~ s/Mister\b/Mr./g);
# using an expression for the replacement
$_ = 'abc123xyz';
s/\d+/$&amp;*2/e;               # yields 'abc246xyz'
s/\d+/sprintf("%5d",$&amp;)/e;  # yields 'abc  246xyz'
s/\w/$&amp; x 2/eg;             # yields 'aabbcc  224466xxyyzz'
# how to default things with /e
s/%(.)/$percent{$1}/g;            # change percent escapes; no /e
s/%(.)/$percent{$1} || $&amp;/ge;     # expr now, so /e
s/^=(\w+)/&amp;pod($1)/ge;            # use function call
# /e's can even nest; this will expand simple embedded variables in $_
s/(\$\w+)/$1/eeg;
# delete C comments
$program =~ s {
    /\*     # Match the opening delimiter.
    .*?     # Match a minimal number of characters.
    \*/     # Match the closing delimiter.
} []gsx;
# trim white space
s/^\s*(.*?)\s*$/$1/;
# reverse 1st two fields
s/([^ ]*) *([^ ]*)/$2 $1/;
</PRE>
</DIV>

<p class=para>
Note the use of <tt class=literal>$</tt> instead of <tt class=literal>\</tt> in the last example.
Some people get a little too used to writing things like:

<p class=para>
<div class=programlisting>
<p>
<pre>
$pattern =~ s/(\W)/\\\1/g;
</PRE>
</DIV>

<p class=para>
This is grandfathered for the right-hand side of a substitution to avoid
shocking the <i class=emphasis>sed</I> addicts, but it's a dirty habit to get into.[26]
That's because in PerlThink, the right-hand side of a <tt class=literal>s///</tt> is a
double-quoted string.  In an ordinary double-quoted string, <tt class=literal>\1</tt>
would mean a control-A, but for <tt class=literal>s///</tt> the customary UNIX meaning
of <tt class=literal>\1</tt> is kludged in.  (The lexer actually translates it to
<b>$1</B> on the fly.)  If you start to rely on that, however, you get
yourself into trouble if you then add an <b>/e</B> modifier:

<blockquote class=footnote>
<p class=para>[26] 
Or to not get out of, depending on how you look at it.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
s/(\d+)/ \1 + 1 /eg;   # a scalar reference plus one?
</PRE>
</DIV>

<p class=para>
Or if you try to do:

<p class=para>
<div class=programlisting>
<p>
<pre>
s/(\d+)/\&nbsp;1000/;        # "\&nbsp;100" . "0" == "@0"?
</PRE>
</DIV>

<p class=para>
You can't disambiguate that by saying <tt class=literal>\{1}000</tt>, whereas you
<i class=emphasis>can</I> fix it with <tt class=literal>${1}000</tt>.  Basically, the operation of
interpolation should not be confused with the operation of matching a
backreference.  Certainly, interpolation and matching mean two different
things on the <i class=emphasis>left</I> side of the <tt class=literal>s///</tt>.

<p class=para>
Occasionally, you can't just use a <b>/g</B> to get all the changes to
occur, either because the substitutions have to happen right-to-left, or
because you need the length of <b>$</B><tt class=literal>`</tt> to change between matches.  In this
case you can usually do what you want by calling the substitution
repeatedly.  Here are two common cases:

<p class=para>
<div class=programlisting>
<p>
<pre>
# put commas in the right places in an integer
1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/;
# expand tabs to 8-column spacing
1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;
</PRE>
</DIV>

<p>
<dl class=variablelist>
<dt class=varlistentry><tt class=literal>tr/</tt><tt class=replaceable><i>SEARCHLIST</i></tt><tt class=literal>/</tt><tt class=replaceable><i>REPLACEMENTLIST</i></tt><tt class=literal>/cds</tt> <tt class=literal>y/</tt><tt class=replaceable><i>SEARCHLIST</i></tt><tt class=literal>/</tt><tt class=replaceable><i>REPLACEMENTLIST</i></tt><tt class=literal>/cds</tt><dd>

<p class=para>
Strictly speaking, this operator doesn't belong in a section on pattern
matching because it doesn't use regular expressions.  Rather, it scans
a string character by character, and replaces
all occurrences of the characters found in the <tt class=replaceable><i>SEARCHLIST</i></tt> 
with the corresponding character in the <tt class=replaceable><i>REPLACEMENTLIST</i></tt>.  It returns
the number of characters replaced or deleted.  If no string is
specified via the <tt class=literal>=~</tt> or <tt class=literal>!~</tt> operator, the <b>$_</B> string is translated.  (The
string specified with <tt class=literal>=~</tt> must be a scalar variable, an array element,
or an assignment to one of those, that is, an lvalue.)  For <i class=emphasis>sed</I> devotees,
<b>y</B> is provided as a synonym for <a href="ch03_02.htm">tr///</A>.  If the <tt class=replaceable><i>SEARCHLIST</i></tt> is
contained within naturally paired delimiters (such as parentheses), the
<tt class=replaceable><i>REPLACEMENTLIST</i></tt> has its own pair of delimiters, which may or may
not be naturally paired ones--for example, <tt class=literal>tr[A-Z][a-z]</tt>
or <tt class=literal>tr(+-*/)/ABCD/</tt>.</DL>
<p class=para>
Modifiers:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-9C"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Modifier</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>c</tt></TD>
<td align="left">Complement the <tt class=replaceable><i>SEARCHLIST</i></tt>.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>d</tt></TD>
<td align="left">Delete found but unreplaced characters.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>s</tt></TD>
<td align="left">Squash duplicate replaced characters.</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
If the <b>/c</B> modifier is specified, the
<tt class=replaceable><i>SEARCHLIST</i></tt> character set is complemented; that
is, the effective search list consists of all the characters
<i class=emphasis>not</I> in <tt class=replaceable><i>SEARCHLIST</i></tt>.  If the
<b>/d</B> modifier is specified, any
characters specified by <tt class=replaceable><i>SEARCHLIST</i></tt> but not given
a replacement in <tt class=replaceable><i>REPLACEMENTLIST</i></tt> are deleted.
(Note that this is slightly more flexible than the behavior of some
<a href="ch03_02.htm">tr///</A> programs, which delete anything they
find in the <tt class=replaceable><i>SEARCHLIST</i></tt>, period.)  If the
<b>/s</B> modifier is specified, sequences of
characters that were translated to the same character are squashed
down to a single instance of the character.

<p class=para>
If the <b>/d</B> modifier is used, the
<tt class=replaceable><i>REPLACEMENTLIST</i></tt> is always interpreted exactly as
specified.  Otherwise, if the <tt class=replaceable><i>REPLACEMENTLIST</i></tt> is
shorter than the <tt class=replaceable><i>SEARCHLIST</i></tt>, the final character
is replicated until it is long enough.  If the
<tt class=replaceable><i>REPLACEMENTLIST</i></tt> is null, the
<tt class=replaceable><i>SEARCHLIST</i></tt> is replicated.  This latter is useful
for counting characters in a class or for squashing character
sequences in a class.

<p class=para>
Examples:

<p class=para>
<div class=programlisting>
<p>
<pre>
$ARGV[1] =~ tr/A-Z/a-z/;    # canonicalize to lower case
$cnt = tr/*/*/;             # count the stars in $_
$cnt = $sky =~ tr/*/*/;     # count the stars in $sky
$cnt = tr/0-9//;            # count the digits in $_
tr/a-zA-Z//s;               # bookkeeper -&gt; bokeper
($HOST = $host) =~ tr/a-z/A-Z/;
tr/a-zA-Z/ /cs;             # change non-alphas to single space
tr [\200-\377]
   [\000-\177];             # delete 8th bit
</PRE>
</DIV>

<p class=para>
If multiple translations are given for a character, only the first one is used:

<p class=para>
<div class=programlisting>
<p>
<pre>
tr/AAA/XYZ/
</PRE>
</DIV>

<p class=para>
will translate any A to X.

<p class=para>
Note that because the translation table is built at compile time, neither
the <tt class=replaceable><i>SEARCHLIST</i></tt> nor the <tt class=replaceable><i>REPLACEMENTLIST</i></tt>
are subject to double quote
interpolation.  That means that if you want to use variables, you must use
an <a href="ch03_02.htm">eval</A>:

<p class=para>
<div class=programlisting>
<p>
<pre>
eval "tr/$oldlist/$newlist/";
die $@ if $@;
eval "tr/$oldlist/$newlist/, 1" or die $@;
</PRE>
</DIV>

<p class=para>
One more note: if you want to change your text to uppercase or
lowercase, it's better to use the <tt class=literal>\U</tt> or <tt class=literal>\L</tt> sequences
in a double-quoted string, since they will pay attention to locale
information, but <tt class=literal>tr/a-z/A-Z/</tt> won't.

</DIV>

</DIV>


<div class=htmlnav>
<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch02_03.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch02_05.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Terms</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Operators</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>
</BODY>
</HTML>
