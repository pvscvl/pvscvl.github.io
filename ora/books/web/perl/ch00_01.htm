<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Preface 0] Preface</TITLE>
<meta name="author" content="Larry Wall, Tom Christiansen, and Randal Schwartz">
<meta name="date" content="Mon Mar 17 12:58:19 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="Perl">
<meta name="title" content="Programming Perl, Second Edition">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF" text="#000000">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="Programming Perl, Second Edition"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top>&nbsp;</td>
<td width=171 align=center valign=top><b>Preface</b></td>
<td width=172 align=right valign=top><a href="ch00_02.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<h1 class=preface><a class="TITLE" name="PERL2-PREFACE">Preface</A></H1>

<div class=htmltoc>

<p>
<b>Contents:</b><br>
Perl in a Nutshell<br>
<a href="ch00_02.htm">The Rest of This Book</A><br>
<a href="ch00_03.htm">Additional Resources</A><br>
<a href="ch00_04.htm">How to Get Perl</A><br>
<a href="ch00_05.htm">Conventions Used in This Book</A><br>
<a href="ch00_06.htm">Acknowledgments</A><br>
<a href="ch00_07.htm">We'd Like to Hear from You</A><br>

</DIV>

<div class=sect1>
<h2 class=sect1><a class="TITLE" name="PERL2-PREFACE-SECT-1">0.1 Perl in a Nutshell</A></h2>

<p class=para>
Perl is a language for getting your job done.

<p class=para>
Of course, if your job is programming, you can get your job done with
any "complete" computer language, theoretically speaking.  But we know
from experience that computer languages differ not so much in what they
make <i class=emphasis>possible</I>, but in what they make <i class=emphasis>easy</I>.  At one extreme,
the so-called "fourth generation languages" make it easy to do some things,
but nearly impossible to do other things.  At the other extreme, certain
well known, "industrial-strength" languages make it equally difficult to
do almost everything.

<p class=para>
Perl is different.  In a nutshell, Perl is designed to make the easy
jobs easy, without making the hard jobs impossible.

<p class=para>
And what are these "easy jobs" that ought to be easy?  The ones you do
every day, of course.  You want a language that makes it easy to
manipulate numbers and text, files and directories, computers and
networks, and especially programs.  It should be easy to run external
programs and scan their output for interesting tidbits.  It should be
easy to send those same tidbits off to other programs that can do
special things with them.  It should be easy to develop, modify, and
debug your own programs too.  And, of course, it should be easy to compile
and run your programs, and do it portably, on any modern operating
system.

<p class=para>
Perl does all that, and a whole lot more.

<p class=para>
Initially designed as a glue language for the UNIX operating system (or
any of its myriad variants), Perl also runs on numerous other systems,
including MS-DOS, VMS, OS/2, Plan 9, Macintosh, and any variety of
Windows you care to mention.  It is one of the most portable programming
languages available today.  To program C portably, you have to put in
all those strange <tt class=literal>#ifdef</tt> markings for different operating
systems.  And to program a shell portably, you have to remember the
syntax for each operating system's version of each command, and somehow
find the least common denominator that (you hope) works everywhere.
Perl happily avoids both of these problems, while retaining many of the
benefits of both C and shell programming, with some additional magic of
its own.  Much of the explosive growth of Perl has been fueled by the
hankerings of <i class=emphasis>former</I> UNIX programmers who wanted to take along
with them as much of the "old country" as they could.  For them, Perl is
the portable distillation of UNIX culture, an oasis in the wilderness of
"can't get there from here".  On the other hand, it works in the other
direction, too: Web programmers are often delighted to discover that they
can take their scripts from a Windows machine and run them unchanged on
their UNIX servers.

<p class=para>
Although Perl is especially popular with systems programmers and Web
developers, it also appeals to a much broader audience.  The hitherto
well-kept secret is now out:  Perl is no longer just for text
processing.  It has grown into a sophisticated, general-purpose
programming language with a rich software development environment
complete with debuggers, profilers, cross-referencers, compilers,
interpreters, libraries, syntax-directed editors, and all the rest of the trappings
of a "real" programming language.  (But don't let that scare you:
nothing requires you to go tinkering under the hood.)  Perl is being
used daily in every imaginable field, from aerospace engineering to molecular
biology, from computer-assisted design/computer-assisted manufacturing
(CAD/CAM) to document processing, from database manipulation
to client-server network management.  Perl is used by people who are
desperate to analyze or convert lots of data quickly, whether
you're talking DNA sequences, Web pages, or pork belly futures.  Indeed,
one of the jokes in the Perl community is that the next big stock market
crash will probably be triggered by a bug in a Perl script.  (On the
brighter side, any unemployed stock analysts will still have a
marketable skill, so to speak.)

<p class=para>
There are many reasons for the success of Perl.  It certainly helps
that Perl is freely available, and freely redistributable.  But
that's not enough to explain the Perl phenomenon, since many freeware
packages fail to thrive.  Perl is not just free; it's also fun.  People
feel like they can be creative in Perl, because they have freedom of
expression: they get to choose what to optimize for, whether that's
computer speed or programmer speed, verbosity or conciseness,
readability or maintainability or reusability or portability or
learnability or teachability.  You can even optimize for obscurity, if
you're entering an Obfuscated Perl contest.

<p class=para>
Perl can give you all these degrees of freedom because it's essentially
a language with a split personality.  It's both a very simple language
and a very rich language.  It has taken good ideas from nearly
everywhere, and installed them into an easy-to-use mental framework.  To
those who merely like it, Perl is the <i class=emphasis>Practical Extraction and Report
Language</I>.  To those who love it, Perl is the <i class=emphasis>Pathologically
Eclectic Rubbish Lister</I>.  And to the minimalists in the crowd, Perl
seems like a pointless exercise in redundancy.  But that's okay.  The
world needs a few reductionists (mainly as physicists).  Reductionists
like to take things apart.  The rest of us are just trying to get it
together.

<p class=para>
Perl is in many ways a simple language.  You don't have to know many
special incantations to compile a Perl program--you can just execute it
like a shell script.  The types and structures used by Perl are easy to
use and understand.  Perl doesn't impose arbitrary limitations on your
data--your strings and arrays can grow as large as they like (so long as
you have memory), and they're designed to scale well as they grow.
Instead of forcing you to learn new syntax and semantics, Perl borrows
heavily from other languages you may already be familiar with (such as
C, and <i class=emphasis>sed</I>, and <i class=emphasis>awk</I>, and English, and Greek).  In fact, just
about any programmer can read a well-written piece of Perl code and have
some idea of what it does.

<p class=para>
Most important, you don't have to know everything there is to know
about Perl before you can write useful programs.  You can learn Perl
"small end first".  You can program in Perl Baby-Talk, and we promise
not to laugh.  Or more precisely, we promise not to laugh any more than
we'd giggle at a child's creative way of putting things.  Many of the
ideas in Perl are borrowed from natural language, and one of the best
ideas is that it's okay to use a subset of the language as long as you
get your point across.  Any level of language proficiency is acceptable
in Perl culture.  We won't send the language police after you.  A Perl
script is "correct" if it gets the job done before your boss fires you.

<p class=para>
Though simple in many ways, Perl is also a rich language, and there is
much to be learned about it.  That's the price of making hard things
possible.  Although it will take some time for you to absorb all that
Perl can do, you will be glad that you have access to the extensive
capabilities of Perl when the time comes that you need them.  We noted
above that Perl borrows many capabilities from the shells and C, but
Perl also possesses a strict superset of <i class=emphasis>sed</I> and <i class=emphasis>awk</I>
capabilities.  There are, in fact, translators supplied with Perl to
turn your old <i class=emphasis>sed</I> and <i class=emphasis>awk</I> scripts into Perl scripts, so you
can see how the features you may already be familiar with correspond to
those of Perl.

<p class=para>
Because of that heritage, Perl was a rich language even when it was
"just" a data-reduction language, designed for navigating files,
scanning large amounts of text, creating and obtaining dynamic data, and
printing easily formatted reports based on that data.  But somewhere
along the line, Perl started to blossom.  It also became a language for
filesystem manipulation, process management, database administration,
client-server programming, secure programming, Web-based information
management, and even for object-oriented and functional programming.
These capabilities were not just slapped onto the side of Perl--each new
capability works synergistically with the others, because Perl
was designed to be a glue language from the start.

<p class=para>
But Perl can glue together more than its own features.  Perl is designed
to be modularly extensible.  Perl allows you to rapidly design, program,
debug, and deploy applications, but it also allows you to easily
extend the functionality of these applications as the need arises.  
You can embed Perl in other languages, and you can embed other languages
in Perl.  Through the module importation mechanism, you can
use these external definitions as if they were built-in features of Perl.
Object-oriented external libraries retain their object-orientedness in Perl.

<p class=para>
Perl helps you in other ways too.  Unlike a strictly interpreted
language such as the shell, which compiles and executes a script one
command at a time, Perl first compiles your whole program quickly into
an intermediate format.  Like any other compiler, it performs various
optimizations, and gives you instant feedback on everything from syntax
and semantic errors to library binding mishaps.  Once Perl's compiler
frontend is happy with your program, it passes off the intermediate
code to the interpreter to execute (or optionally to any of several
modular back ends that can emit C or bytecode.)  This all sounds
complicated, but the compiler and interpreter are quite efficient, and
most of us find that the typical compile-run-fix cycle is measured in
mere seconds.  Together with Perl's many fail-soft characteristics, this
quick turnaround capability makes Perl a language in which you really
can do rapid prototyping.  Then later, as your program matures, you can
tighten the screws on yourself, and make yourself program with less
flair but more discipline.  Perl helps you with that too, if you ask
nicely.

<p class=para>
Perl also helps you to write programs more securely.  While running in
privileged mode, you can temporarily switch your identity to something
innocuous before accessing system resources.  Perl also guards against
accidental security errors through a data tracing mechanism that
automatically determines which data was derived from insecure sources
and prevents dangerous operations before they can happen.  Finally, Perl
lets you set up specially protected compartments in which you can safely
execute Perl code of dubious lineage, masking out dangerous operations.
System administrators and CGI programmers will particularly welcome
these features.

<p class=para>
But, paradoxically, the way in which Perl helps you the most has almost
nothing to do with Perl, and everything to do with the people who use
Perl.  Perl folks are, frankly, some of the most helpful folks on
earth.  If there's a religious quality to the Perl movement, then this
is at the heart of it.  Larry wanted the Perl community to function like
a little bit of heaven, and he seems to have gotten his wish, so far.
Please do your part to keep it that way.

<p class=para>
Whether you are learning Perl because you want to save the world, or just
because you are curious, or because your boss told you to, this handbook
will lead you through both the basics and the intricacies.  And although
we don't intend to teach you how to program, the perceptive reader will
pick up some of the art, and a little of the science, of programming.
We will encourage you to develop the three great virtues of a
programmer: <i class=emphasis>laziness</I>, 
<i class=emphasis>impatience</I>, and <i class=emphasis>hubris</I>.  Along
the way, we hope you find the book mildly amusing in some spots (and
wildly amusing in others).  And if none of this is enough to keep you
awake, just keep reminding yourself that learning Perl will increase the
value of your resume.  So keep reading.

</DIV>


<div class=htmlnav>
<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top>&nbsp;</td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch00_02.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>&nbsp;</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>The Rest of This Book</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>
</BODY>
</HTML>
