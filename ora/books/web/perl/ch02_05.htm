<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 2] 2.5 Operators</TITLE>
<meta name="author" content="Larry Wall, Tom Christiansen, and Randal Schwartz">
<meta name="date" content="Mon Mar 17 13:02:58 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="Perl">
<meta name="title" content="Programming Perl, Second Edition">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="Programming Perl, Second Edition"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch02_04.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 2</b></td>
<td width=172 align=right valign=top><a href="ch02_06.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="PERL2-CH-2-SECT-5">2.5 Operators</A></h2>

<p class=para>
<a name="CH02.OPERATORS"></A>The terms of an expression often need to be combined and modified
in various ways, and that's what operators are for.  The tightness
with which operators bind is controlled by the <i class=emphasis>precedence</I> of
the operators.
Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.[27]

<blockquote class=footnote>
<p class=para>[27] 
Classic Camel readers will note that we reversed this table from the old
edition.  The higher precedence operators are now higher on the page,
which makes some kind of metaphorical sense.
</blockquote>
<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-10"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Associativity</TH>
<th align="left">Operators</TH>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left">Terms and list operators (leftward)</TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>-&gt;</tt></TD>
</TR>
<tr class=row>
<td align="left">Nonassociative</TD>
<td align="left"><tt class=literal>++ - -</tt></TD>
</TR>
<tr class=row>
<td align="left">Right</TD>
<td align="left"><tt class=literal>**</tt></TD>
</TR>
<tr class=row>
<td align="left">Right</TD>
<td align="left"><tt class=literal>! ~ \</tt> and unary <tt class=literal>+</tt> and <tt class=literal>-</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>=~ !~ </tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>* / % x</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>+ - .</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>&lt;&lt; &gt;&gt;</tt></TD>
</TR>
<tr class=row>
<td align="left">Nonassociative</TD>
<td align="left">Named unary operators</TD>
</TR>
<tr class=row>
<td align="left">Nonassociative</TD>
<td align="left"><tt class=literal>&lt; &gt; &lt;= &gt;= lt gt le ge</tt></TD>
</TR>
<tr class=row>
<td align="left">Nonassociative</TD>
<td align="left"><tt class=literal>== != &lt;=&gt; eq ne cmp</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>&amp;</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>| ^</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>&amp;&amp;</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>||</tt></TD>
</TR>
<tr class=row>
<td align="left">Nonassociative</TD>
<td align="left"><tt class=literal>.</tt></TD>
</TR>
<tr class=row>
<td align="left">Right</TD>
<td align="left"><tt class=literal>?:</tt></TD>
</TR>
<tr class=row>
<td align="left">Right</TD>
<td align="left"><tt class=literal>= += -= *=</tt> and so on</TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>, =&gt;</tt></TD>
</TR>
<tr class=row>
<td align="left">Nonassociative</TD>
<td align="left">List operators (rightward)</TD>
</TR>
<tr class=row>
<td align="left">Right</TD>
<td align="left"><tt class=literal>not</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>and</tt></TD>
</TR>
<tr class=row>
<td align="left">Left</TD>
<td align="left"><tt class=literal>or xor</tt></TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
It may seem like there are too many precedence levels.  Well, you're
right, there are.  Fortunately, there are two things going for you here.
First, the precedence levels as they're defined usually follow your
intuition, presuming you're not psychotic.  And second, if you're merely
neurotic, you can always put in extra parentheses to relieve your
anxiety.

<p class=para>
Note that any operators borrowed from C keep the same precedence
relationship with each other, even where C's precedence is slightly screwy.
(This makes learning Perl easier for C folks.)

<p class=para>
In the following sections, these operators are covered in precedence
order.  With very few exceptions, these all operate on scalar values
only, not list values.  We'll mention the exceptions as they come up.

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.1">Terms and List Operators (Leftward)</A></h3>

<p class=para>
<a name="CH02.TERMS1"></A><a name="CH02.TERMS2"></A>Any <i class=emphasis>term</I> is of highest precedence in Perl.  These include variables,
quote and quotelike operators, any expression in parentheses, and any
function whose arguments are parenthesized.  Actually, there aren't really
any functions in this sense, just list operators and unary operators behaving
as functions because you put parentheses around their arguments.
These operators are
all covered in <a href="ch03_01.htm">Chapter 3, <i>Functions</i></A>.

<p class=para>
Now, listen carefully.  Here are a couple of rules that are very important
and simplify things greatly, but may occasionally produce counterintuitive
results for the unwary.  If any list operator (such as <a href="ch03_02.htm">print</A>) or any
named unary operator (such as <a href="ch03_02.htm">chdir</A>) is followed by a left parenthesis as
the next token on the same line,[28]
the operator and its arguments within parentheses are taken to be of
highest precedence, just like a normal function call.  The rule is: If
it <i class=emphasis>looks</I> like a function call, it is a function call.
You can
make it look like a non-function by prefixing the arguments with a unary
plus, which does absolutely nothing, semantically speaking--it doesn't
even convert the argument to numeric.  

<blockquote class=footnote>
<p class=para>[28] 
And we nearly had you convinced Perl was a free-form language.
</blockquote>
<p class=para>
For example, since || has lower
precedence than <a href="ch03_02.htm">chdir</A>, we get:

<p class=para>
<div class=programlisting>
<p>
<pre>
chdir $foo    || die;       # (chdir $foo) || die
chdir($foo)   || die;       # (chdir $foo) || die
chdir ($foo)  || die;       # (chdir $foo) || die
chdir +($foo) || die;       # (chdir $foo) || die
</PRE>
</DIV>

<p class=para>
but, because <tt class=literal>*</tt> has higher precedence than <a href="ch03_02.htm">chdir</A>, we get:

<p class=para>
<div class=programlisting>
<p>
<pre>
chdir $foo * 20;            # chdir ($foo * 20)
chdir($foo) * 20;           # (chdir $foo) * 20
chdir ($foo) * 20;          # (chdir $foo) * 20
chdir +($foo) * 20;         # chdir ($foo * 20)
</PRE>
</DIV>

<p class=para>
Likewise for numeric operators:

<p class=para>
<div class=programlisting>
<p>
<pre>
rand 10 * 20;               # rand (10 * 20)
rand(10) * 20;              # (rand 10) * 20
rand (10) * 20;             # (rand 10) * 20
rand +(10) * 20;            # rand (10 * 20)
</PRE>
</DIV>

<p class=para>
In the absence of parentheses, the precedence of list operators such
as <a href="ch03_02.htm">print</A>, <a href="ch03_02.htm">sort</A>, or <a href="ch03_02.htm">chmod</A> is
either very high or very low depending on whether you look at the left
side of the operator or the right side of it.  (That's what the
"Leftward" is doing in the title of this section.)  For example, in:

<p class=para>
<div class=programlisting>
<p>
<pre>
@ary = (1, 3, sort 4, 2);
print @ary;         # prints 1324
</PRE>
</DIV>

<p class=para>
the commas on the right of the <b>sort</B> are evaluated before the <b>sort</B>, but
the commas on the left are evaluated after.  In other words, a list
operator tends to gobble up all the arguments that follow it, and
then act like a simple term with regard to the preceding expression.
Note that you have to be careful with parentheses:

<p class=para>
<div class=programlisting>
<p>
<pre>
# These evaluate exit before doing the print:
print($foo, exit);  # Obviously not what you want.
print $foo, exit;   # Nor is this.
# These do the print before evaluating exit:
(print $foo), exit; # This is what you want.
print($foo), exit;  # Or this.
print ($foo), exit; # Or even this.
</PRE>
</DIV>

<p class=para>
Also note that:

<p class=para>
<div class=programlisting>
<p>
<pre>
print ($foo &amp; 255) + 1, "\n";   # prints ($foo &amp; 255)
</PRE>
</DIV>

<p class=para>
probably doesn't do what you expect at first glance.  Fortunately,
mistakes of this nature generally produce warnings like "<tt class=literal>Useless use
of addition in a void context</tt>" when you use the <b>-w</B> command-line switch.

<p class=para>
Also parsed as terms are the <tt class=literal>do {}</tt> and <tt class=literal>eval {}</tt> constructs,
as well as subroutine and method calls, the anonymous array and hash
composers <tt class=literal>[]</tt> and <tt class=literal>{}</tt>, and the anonymous subroutine
composer <tt class=literal>sub {}</tt>.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.2">The Arrow Operator</A></h3>

<p class=para>
Just as in C and C++, <tt class=literal>-&gt;</tt> is an infix dereference operator.  If the
right side is either a <tt class=literal>[...]</tt> or <tt class=literal>{...}</tt> subscript, then the left
side must be either a hard or symbolic reference to an array or hash (or
a location capable of holding a hard reference, if it's an lvalue
(assignable)).  More on this in <a href="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>.

<p class=para>
Otherwise, the right side must be a method name or a simple scalar
variable containing the method name, and the value of the left side must
either be an object (a blessed reference) or a class name (that is, a
package name).  See <a href="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.3">Autoincrement and Autodecrement</A></h3>

<p class=para>
The <tt class=literal>++</tt> and <tt class=literal>- -</tt> operators work as in C.
That is, if placed before a variable, they
increment or decrement the variable before returning the value, and if
placed after, they increment or decrement the variable after returning the
value.  For example, <tt class=literal>$a++</tt> increments the value of scalar variable
<tt class=literal>$a</tt>, returning the value <i class=emphasis>before</I> it performs the increment.
Similarly, <tt class=literal>- -$b{(/(\w+)/)[0]}</tt> decrements the element of the
hash <tt class=literal>%b</tt> indexed by the first "word" in the default search
variable (<b>$_</B> ) and returns the value <i class=emphasis>after</I> the decrement.[29]

<blockquote class=footnote>
<p class=para>[29] 
OK, so that wasn't exactly fair.  We just wanted to make sure you were
paying attention.  Here's how that expression works.  First the pattern
match finds the first word in <b>$_</B> using the regular expression
<tt class=literal>\w+</tt>.  The parentheses around that causes the word to be returned as
a single-element list value, because the pattern match is in a list
context.  The list context is supplied by the list slice operator,
<tt class=literal>(...)[0]</tt>, which returns the first (and only) element of the list.
That value is then used as the key for the hash, and the hash entry (value) is
decremented and returned.  In general, when confronted with a complex
expression, analyze it from the inside out to see what order things happen in.
</blockquote>
<p class=para>
The autoincrement operator has a little extra built-in magic to it.  If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.  If, however, the
variable has only been used in string contexts since it was set, and
has a value that is not null and matches the pattern
<tt class=literal>/^[a-zA-Z]*[0-9]*$/</tt>, the increment is done as a string, preserving each
character within its range, with carry:

<p class=para>
<div class=programlisting>
<p>
<pre>
print ++($foo = '99');      # prints '100'
print ++($foo = 'a0');      # prints 'a1'
print ++($foo = 'Az');      # prints 'Ba'
print ++($foo = 'zz');      # prints 'aaa'
</PRE>
</DIV>

<p class=para>
The autodecrement operator, however, is not magical.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.4">Exponentiation</A></h3>

<p class=para>
Binary <tt class=literal>**</tt> is the exponentiation operator.  Note that it binds even
more tightly than unary minus, so <tt class=literal>-2**4</tt> is <tt class=literal>-(2**4)</tt>, not
<tt class=literal>(-2)**4</tt>.  The operator is implemented using C's <i class=emphasis>pow</I> (3) function,
which works with doubles internally.  It calculates using
logarithms, which means that it works with fractional powers, but you
sometimes get results that aren't as exact as a straight multiplication
would produce.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.5">Ideographic Unary Operators</A></h3>

<p class=para>
Most unary operators just have names (see "Named Unary and File Test Operators"
below), but some operators are deemed important enough to merit their
own special symbolic representation.  Most of these operators seem to
have something to do with negation.  Blame the mathematicians.

<p class=para>
Unary ! performs logical negation, that is, "not".  See also <b>not</B>
for a lower precedence version of this.  The value of a negated
operation is 1 if the operand is false (numeric 0, string <tt class=literal>"0"</tt>, null
string, or undefined); otherwise, the value is that of the null string.

<p class=para>
Unary <tt class=literal>-</tt> performs arithmetic negation if the operand is numeric.  If
the operand is an identifier, a string consisting of a minus sign
concatenated with the identifier is returned.  Otherwise, if the string
starts with a plus or minus, a string starting with the opposite sign
is returned.  One effect of these rules is that <tt class=literal>-bareword</tt> is
equivalent to <tt class=literal>`-bareword`</tt>.  This is most useful for Tk and CGI programmers.

<p class=para>
Unary <tt class=literal>~</tt> performs bitwise negation, that is, 1's complement.
For example, on a 32-bit machine, <tt class=literal>~123</tt> is <tt class=literal>4292967172</tt>.  But you knew
that already.

<p class=para>
(What you perhaps didn't know is that if the argument to <tt class=literal>~</tt> happens to
be a string instead of a number, a string of identical length is
returned, but with all the bits of the string complemented.  This is
a fast way to flip a lot of bits all at once.  See also the bitwise
logical operators, which also have stringish variants.)

<p class=para>
Unary <tt class=literal>+</tt> has no semantic effect whatsoever, even on strings.  It is
syntactically useful for separating a function name from a parenthesized
expression that would otherwise be interpreted as the complete list of
function arguments.  (See examples above under the section "Terms
and List
Operators".)

<p class=para>
Unary <tt class=literal>\</tt> creates a reference to whatever follows it (see <a href="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>).
Do not confuse this behavior with the behavior of backslash within a
string, although both forms do convey the notion of protecting the next
thing from interpretation.  This resemblance is not entirely accidental.

<p class=para>
The <tt class=literal>\</tt> operator may also be used on a parenthesized list value in a list
context, in which case it returns references to each element of the list.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.6">Binding Operators</A></h3>

<p class=para>
Binary <tt class=literal>=~</tt> binds a scalar expression to a pattern match, substitution,
or translation.  These operations search or modify the string <b>$_</B> by
default.  The binding operator makes those operations work on some other
string instead.  The argument on the right is the search pattern, substitution,
or translation.  The left argument is what is supposed to be searched,
substituted, or translated instead of the default <b>$_</B>.  The return
value indicates the success of the operation.  If the right argument is
an expression rather than a search pattern, substitution, or
translation, it is interpreted as a search pattern at run-time.  That
is, <tt class=literal>$_ =~ $pat</tt> is equivalent to <tt class=literal>$_ =~ /$pat/</tt>.  This is less
efficient than an explicit search, since the pattern must be compiled
every time the expression is evaluated.  (But <tt class=literal>/$pat/o</tt> doesn't
recompile it because of the <b>/o</B> modifier.)

<p class=para>
Binary <tt class=literal>!~</tt> is just like <tt class=literal>=~</tt> except the return value is negated in
the logical sense.  The following expressions are functionally equivalent:

<p class=para>
<div class=programlisting>
<p>
<pre>
$string !~ /pattern/
not $string =~ /pattern/
</PRE>
</DIV>

<p class=para>
We said that the return value indicates success, but there are many
kinds of success.  Substitutions return the number of successful
substitutions, as do translations.  (In fact, the translation operator
is often used to count characters.)  Since any non-zero result is true,
it all works out.  The most spectacular kind of true value is a list
value: in a list context, pattern matches can return substrings matched
by the parentheses in the pattern.  But again, according to the rules of
list assignment, the list assignment itself will return true if anything
matched and was assigned, and false otherwise.  So you sometimes see
things like:

<p class=para>
<div class=programlisting>
<p>
<pre>
if ( ($k,$v) = $string =~ m/(\w+)=(\w*)/ ) {
    print "KEY $k VALUE $v\n";
}
</PRE>
</DIV>

<p class=para>
Let's pick that apart.  The <tt class=literal>=~</tt> binds <tt class=literal>$string</tt> to the
pattern match on the right, which is scanning for occurrences of things
that look like <tt class=replaceable><i>KEY=VALUE</i></tt> in your string.  It's in a list context because
it's on the right side of a list assignment.  If it matches, it
does a list assignment to <tt class=literal>$k</tt> and <tt class=literal>$v</tt>.  The list
assignment itself is in a scalar context, so it returns <tt class=literal>2</tt>, the number of
values on the right side of the assignment.  And <tt class=literal>2</tt> happens to be true,
since our scalar context is also a Boolean context.  When the match
fails, no values are assigned, which returns 0, which is false.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.7">Multiplicative Operators</A></h3>

<p class=para>
Perl provides the C-like operators <tt class=literal>*</tt> (multiply),
<tt class=literal>/</tt> (divide),
and <tt class=literal>%</tt> (modulus).
The <tt class=literal>*</tt> and <tt class=literal>/</tt> work exactly as you might expect, multiplying or
dividing their two operands.  Division is done in floating-point,
unless you've used the integer library module.

<p class=para>
The <tt class=literal>%</tt> operator converts its operands to integers before finding the
remainder according to integer division.  For the same operation in
floating-point, you may prefer to use the <tt class=literal>fmod( )</tt> function from the
POSIX module (see <a href="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>).

<p class=para>
Binary <b>x</B> is the repetition operator.  In scalar context, it
returns a concatenated string consisting of the left operand repeated
the number of times specified by the right operand.

<p class=para>
<div class=programlisting>
<p>
<pre>
print '-' x 80;             # print row of dashes
print "\t" x ($tab/8), ' ' x ($tab%8);      # tab over
</PRE>
</DIV>

<p class=para>
In list context, if the left operand is a list in parentheses, the <b>x</B>
works as a list replicator rather than a string replicator.  This is
useful for initializing all the elements of an array of indeterminate
length to the same value:

<p class=para>
<div class=programlisting>
<p>
<pre>
@ones = (1) x 80;           # a list of 80 1's
@ones = (5) x @ones;        # set all elements to 5
</PRE>
</DIV>

<p class=para>
Similarly, you can also use <b>x</B> to initialize array and hash slices:

<p class=para>
<div class=programlisting>
<p>
<pre>
@keys = qw(perls before swine);
@hash{@keys} = ("") x @keys;
</PRE>
</DIV>

<p class=para>
If this mystifies you, note that <tt class=literal>@keys</tt> is being
used both as a list on the left side of the assignment, and as a scalar
value (returning the array length) on the right side of the assignment.
The above has the same effect on <tt class=literal>%hash</tt> as:

<p class=para>
<div class=programlisting>
<p>
<pre>
$hash{perls}  = "";
$hash{before} = "";
$hash{swine}  = "";
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.8">Additive Operators</A></h3>

<p class=para>
Strangely enough, Perl also has the customary <tt class=literal>+</tt> (addition) and <tt class=literal>-</tt>
(subtraction) operators.  Both operators convert their arguments
from strings to numeric values if necessary, and return a numeric result.

<p class=para>
Additionally, Perl provides a string concatenation operator "<tt class=literal>.</tt>".  For
example:

<div class=programlisting>
<p>
<pre>
$almost = "Fred" . "Flintstone";    # returns FredFlintstone
</PRE>
</DIV>

<p class=para>
Note that Perl does not place a space between the strings being
concatenated.  If you want the space, or if you have more than two
strings to concatenate, you can use the <a href="ch03_02.htm">join</A> operator, described in
<a href="ch03_01.htm">Chapter 3, <i>Functions</i></A>.  Most often, though, people do their
concatenation implicitly inside a double-quoted string:

<p class=para>
<div class=programlisting>
<p>
<pre>
$fullname = "$firstname $lastname";
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.9">Shift Operators</A></h3>

<p class=para>
The bit-shift operators (<tt class=literal>&lt;&lt;</tt> and <tt class=literal>&gt;&gt;</tt>) return the value of the
left argument shifted to the left (<tt class=literal>&lt;&lt;</tt>) or to the right
(<tt class=literal>&gt;&gt;</tt>) by the number of
bits specified by the right argument.  The arguments should be integers.
For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
1 &lt;&lt; 4;     # returns 16
32 &gt;&gt; 4;    # returns 2
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.10">Named Unary and File Test Operators</A></h3>

<p class=para>
<a name="CH02.UNARY1"></A><a name="CH02.UNARY2"></A><a name="CH02.UNARY3"></A>Some of "functions" described in <a href="ch03_01.htm">Chapter 3, <i>Functions</i></A> are really unary operators,
including:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-11"></A>

<table class=INFORMALTABLE>
<tr class=row>
<td align="LEFT">-X (file tests)</TD>
<td align="LEFT">gethostbyname</TD>
<td align="LEFT">localtime</TD>
<td align="LEFT">rmdir</TD>
</TR>
<tr class=row>
<td align="LEFT">alarm</TD>
<td align="LEFT">getnetbyname</TD>
<td align="LEFT">log</TD>
<td align="LEFT">scalar</TD>
</TR>
<tr class=row>
<td align="LEFT">caller</TD>
<td align="LEFT">getpgrp</TD>
<td align="LEFT">lstat</TD>
<td align="LEFT">sin</TD>
</TR>
<tr class=row>
<td align="LEFT">chdir</TD>
<td align="LEFT">getprotobyname</TD>
<td align="LEFT">my</TD>
<td align="LEFT">sleep</TD>
</TR>
<tr class=row>
<td align="LEFT">chroot</TD>
<td align="LEFT">glob</TD>
<td align="LEFT">oct</TD>
<td align="LEFT">sqrt</TD>
</TR>
<tr class=row>
<td align="LEFT">cos</TD>
<td align="LEFT">gmtime</TD>
<td align="LEFT">ord</TD>
<td align="LEFT">srand</TD>
</TR>
<tr class=row>
<td align="LEFT">defined</TD>
<td align="LEFT">goto</TD>
<td align="LEFT">quotemeta</TD>
<td align="LEFT">stat</TD>
</TR>
<tr class=row>
<td align="LEFT">delete</TD>
<td align="LEFT">hex</TD>
<td align="LEFT">rand</TD>
<td align="LEFT">uc</TD>
</TR>
<tr class=row>
<td align="LEFT">do</TD>
<td align="LEFT">int</TD>
<td align="LEFT">readlink</TD>
<td align="LEFT">ucfirst</TD>
</TR>
<tr class=row>
<td align="LEFT">eval</TD>
<td align="LEFT">lc</TD>
<td align="LEFT">ref</TD>
<td align="LEFT">umask</TD>
</TR>
<tr class=row>
<td align="LEFT">exists</TD>
<td align="LEFT">lcfirst</TD>
<td align="LEFT">require</TD>
<td align="LEFT">undef</TD>
</TR>
<tr class=row>
<td align="LEFT">exit</TD>
<td align="LEFT">length</TD>
<td align="LEFT">reset</TD>
<td align="LEFT">&nbsp;</TD>
</TR>
<tr class=row>
<td align="LEFT">exp</TD>
<td align="LEFT">local</TD>
<td align="LEFT">return</TD>
<td align="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
These are all unary operators, with a higher precedence than some of the
other binary operators.  For example:

<div class=programlisting>
<p>
<pre>
sleep 4 | 3;
</PRE>
</DIV>

<p class=para>
does not sleep for 7 seconds; it sleeps for 4 seconds, and then takes the
return value of <a href="ch03_02.htm">sleep</A> (typically zero) and ORs that with 3, as if
the expression were parenthesized as:

<p class=para>
<div class=programlisting>
<p>
<pre>
(sleep 4) | 3;
</PRE>
</DIV>

<p class=para>
Compare this with:

<p class=para>
<div class=programlisting>
<p>
<pre>
print 4 | 3;
</PRE>
</DIV>

<p class=para>
which <i class=emphasis>does</I> take the value of 4 ORed with 3 before printing it (7 in
this case), as if it were written:

<p class=para>
<div class=programlisting>
<p>
<pre>
print (4 | 3);
</PRE>
</DIV>

<p class=para>
This is because <a href="ch03_02.htm">print</A> is a list operator, not a simple unary
operator.  Once you've learned which operators are list operators, you'll
have no trouble telling them apart.  When in doubt, you can always use
parentheses to turn a named unary operator into a function.  Remember, if it
looks like a function, it is a function.

<p class=para>
Another funny thing about named unary operators is that many of them
default to <b>$_</B> if you don't supply an argument.  However.  If the
thing following the named unary operator looks like it might be the
start of an argument, Perl will get confused.  When the next character in
your program is one of the following characters, the Perl tokener returns
different token types depending on whether a term or operator is expected:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-12"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Char</TH>
<th align="left">Operator</TH>
<th align="left">Term</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>+</tt></TD>
<td align="left">Addition</TD>
<td align="left">Unary plus</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-</tt></TD>
<td align="left">Subtraction</TD>
<td align="left">Unary minus</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>*</tt></TD>
<td align="left">Multiplication</TD>
<td align="left"><tt class=literal>*typeglob</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>/</tt></TD>
<td align="left">Division</TD>
<td align="left"><tt class=literal>/pattern/</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>&lt;</tt></TD>
<td align="left">Less than, left shift</TD>
<td align="left"><tt class=literal>&lt;HANDLE&gt;, &lt;&lt;END</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>.</tt></TD>
<td align="left">Concatenation</TD>
<td align="left"><tt class=literal>.3333</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>?</tt></TD>
<td align="left"><tt class=literal>?:</tt></TD>
<td align="left"><tt class=literal>?pattern?</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>%</tt></TD>
<td align="left">Modulo</TD>
<td align="left"><tt class=literal>%assoc</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>&amp;</tt></TD>
<td align="left"><tt class=literal>&amp;, &amp;&amp;</tt></TD>
<td align="left"><tt class=literal>&amp;subroutine</tt></TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
So a typical boo-boo is:

<p class=para>
<div class=programlisting>
<p>
<pre>
next if length &lt; 80;
</PRE>
</DIV>

<p class=para>
in which the <tt class=literal>&lt;</tt> looks to the parser like the beginning of the
<tt class=literal>&lt;&gt;</tt> input symbol (a term) instead of the "less than" (an operator) you
were thinking of.  There's really no way to fix this, and still keep Perl
pathologically eclectic.  If you're so incredibly lazy that you cannot
bring yourself to type the two characters <b>$_</B>, then say one of these
instead:

<p class=para>
<div class=programlisting>
<p>
<pre>
next if length() &lt; 80;
next if (length) &lt; 80;
next if 80 &gt; length;
next unless length &gt;= 80;
</PRE>
</DIV>

<p class=para>
A file test operator is a unary operator that takes one argument, either a
filename or a filehandle, and tests the associated file to see if something
is true about it.  If the argument is omitted, it tests <b>$_</B>, except for
<tt class=literal>-t</tt>, which tests <tt class=literal>STDIN</tt>.  Unless otherwise documented, it returns
<tt class=literal>1</tt> for true and <tt class=literal>``</tt> for false, or the undefined
value if the file doesn't exist.  The operator may be any of the following:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-12A"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Operator</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-r</tt></TD>
<td align="left">File is readable by effective uid/gid.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-w</tt></TD>
<td align="left">File is writable by effective uid/gid.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-x</tt></TD>
<td align="left">File is executable by effective uid/gid.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-o</tt></TD>
<td align="left">File is owned by effective uid.</TD>
</TR>
<tr class=row>
<td align="left">&nbsp;</TD>
<td align="left">&nbsp;</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-R</tt></TD>
<td align="left">File is readable by real uid/gid.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-W</tt></TD>
<td align="left">File is writable by real uid/gid.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-X</tt></TD>
<td align="left">File is executable by real uid/gid.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-O</tt></TD>
<td align="left">File is owned by real uid.</TD>
</TR>
<tr class=row>
<td align="left">&nbsp;</TD>
<td align="left">&nbsp;</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-e</tt></TD>
<td align="left">File exists.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-z</tt></TD>
<td align="left">File has zero size.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-s</tt></TD>
<td align="left">File has non-zero size (returns size).</TD>
</TR>
<tr class=row>
<td align="left">&nbsp;</TD>
<td align="left">&nbsp;</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-f</tt></TD>
<td align="left">File is a plain file.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-d</tt></TD>
<td align="left">File is a directory.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-l</tt></TD>
<td align="left">File is a symbolic link.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-p</tt></TD>
<td align="left">File is a named pipe (FIFO).</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-S</tt></TD>
<td align="left">File is a socket.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-b</tt></TD>
<td align="left">File is a block special file.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-c</tt></TD>
<td align="left">File is a character special file.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-t</tt></TD>
<td align="left">Filehandle is opened to a tty.</TD>
</TR>
<tr class=row>
<td align="left">&nbsp;</TD>
<td align="left">&nbsp;</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-u</tt></TD>
<td align="left">File has setuid bit set.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-g</tt></TD>
<td align="left">File has setgid bit set.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-k</tt></TD>
<td align="left">File has sticky bit set.</TD>
</TR>
<tr class=row>
<td align="left">&nbsp;</TD>
<td align="left">&nbsp;</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-T</tt></TD>
<td align="left">File is a text file.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-B</tt></TD>
<td align="left">File is a binary file (opposite of <tt class=literal>-T</tt>).</TD>
</TR>
<tr class=row>
<td align="left">&nbsp;</TD>
<td align="left">&nbsp;</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-M</tt></TD>
<td align="left">Age of file (at startup) in days since modification.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-A</tt></TD>
<td align="left">Age of file (at startup) in days since last access.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>-C</tt></TD>
<td align="left">Age of file (at startup) in days since inode change.</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
The interpretation of the file permission operators
<tt class=literal>-r</tt>, <tt class=literal>-R</tt>, <tt class=literal>-w</tt>,
<tt class=literal>-W</tt>, <tt class=literal>-x</tt>, and <tt class=literal>-X</tt>
is based solely on the mode of the file and the user and group IDs of
the user.  There may be other reasons you can't actually read, write,
or execute the file, such as Andrew File System (AFS) access control lists.  Also note that
for the superuser, <tt class=literal>-r</tt>, <tt class=literal>-R</tt>,
<tt class=literal>-w</tt>, and <tt class=literal>-W</tt> always return 1, and
<tt class=literal>-x</tt>, and <tt class=literal>-X</tt> return 1 if any
execute bit is set in the mode.  Scripts run by the superuser may thus
need to do a <a href="ch03_02.htm">stat</A> in order to determine
the actual mode of the file, or temporarily set the uid to something
else. Example:

<p class=para>
<div class=programlisting>
<p>
<pre>
while (&lt;&gt;) {
    chomp;
    next unless -f $_;      # ignore "special" files
    ...
}
</PRE>
</DIV>

<p class=para>
Note that <tt class=literal>-s/a/b/</tt> does not do a negated substitution.  Saying
<tt class=literal>-exp($foo)</tt> still works as expected, however--only single letters
following a minus are interpreted as file tests.

<p class=para>
The <tt class=literal>-T</tt> and <tt class=literal>-B</tt> switches work as follows.  The first block or so
of the file is examined for odd characters such as strange control codes or
characters with the high bit set.  If too many odd characters (&gt;30%) are
found, it's a <tt class=literal>-B</tt> file, otherwise it's a <tt class=literal>-T</tt> file.  Also, any
file containing null in the first block is considered a binary file.  If
<tt class=literal>-T</tt> or <tt class=literal>-B</tt> is used on a
filehandle, the current input (standard I/O or "stdio")
buffer is examined rather than the first block of the file.
Both <tt class=literal>-T</tt> and <tt class=literal>-B</tt> return
true on a null file, or on a file at EOF (end of file) when testing a
filehandle.  Because you have to read a file to do the <tt class=literal>-T</tt> test, on
most occasions you want to use a <tt class=literal>-f</tt> against the file first, as in:

<p class=para>
<div class=programlisting>
<p>
<pre>
next unless -f $file &amp;&amp; -T _;
</PRE>
</DIV>

<p class=para>
If any of the file tests (or either the <a href="ch03_02.htm">stat</A> or <a href="ch03_02.htm">lstat</A> operators)
are given the special filehandle consisting of a solitary underline,
then the <i class=emphasis>stat</I> structure of the previous file test (or <a href="ch03_02.htm">stat</A> operator) is
used, thereby saving a system call.  (This doesn't work with <tt class=literal>-t</tt>, and
you need to remember that <a href="ch03_02.htm">lstat</A> and <tt class=literal>-l</tt> will leave values in the
<i class=emphasis>stat</I> structure for the symbolic link, not the real file.)[30]
Example:

<blockquote class=footnote>
<p class=para>[30] 
Likewise, <tt class=literal>-l _</tt> will always be false after a normal <a href="ch03_02.htm">stat</A>.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
print "Can do.\n" if -r $a || -w _ || -x _;
stat($filename);
print "Readable\n" if -r _;
print "Writable\n" if -w _;
print "Executable\n" if -x _;
print "Setuid\n" if -u _;
print "Setgid\n" if -g _;
print "Sticky\n" if -k _;
print "Text\n" if -T _;
print "Binary\n" if -B _;
</PRE>
</DIV>

<p class=para>
File ages for <tt class=literal>-M</tt>, <tt class=literal>-A</tt>, and <tt class=literal>-C</tt> are returned in days
(including fractional days) since the time when the script started running.
(This time is stored in
the special variable <b>$^T</B>.)  Thus, if the file changed after the
script started, you would get a negative time.
Note that most times (86,399 out of 86,400, on average) are fractional,
so testing for equality with an integer without using the <a href="ch03_02.htm">int</A>
function is usually futile.  Examples:

<p class=para>
<div class=programlisting>
<p>
<pre>
next unless -M $file &gt; .5;      # files older than 12 hours
&amp;newfile if -M $file &lt; 0;       # file is newer than process
&amp;mailwarning if int(-A) == 90;  # file ($_) accessed 90 days ago today
</PRE>
</DIV>

<p class=para>
To reset the script's start time to the current time, change <b>$^T</B>
as follows:

<p class=para>
<div class=programlisting>
<p>
<pre>
$^T = time;
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.11">Relational Operators</A></h3>

<p class=para>
Perl has two classes of relational operators.  One class operates on
numeric values, and the other class operates on string values.  To
repeat the table given in the overview:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-13"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Numeric</TH>
<th align="left">String</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>&gt;</tt></TD>
<td align="left"><tt class=literal>gt</tt></TD>
<td align="left">Greater than</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>&gt;=</tt></TD>
<td align="left"><tt class=literal>ge</tt></TD>
<td align="left">Greater than or equal to</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>&lt;</tt></TD>
<td align="left"><tt class=literal>lt</tt></TD>
<td align="left">Less than</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>&lt;=</tt></TD>
<td align="left"><tt class=literal>le</tt></TD>
<td align="left">Less than or equal to</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
These operators return <tt class=literal>1</tt> for true, and <tt class=literal>``</tt> for false.  String
comparisons are based on the ASCII collating sequence, and unlike in some
languages, trailing spaces count in the comparison. 
Note that relational operators are non-associating, which means that
<tt class=literal>$a &lt; $b &lt; $c</tt> is a syntax error.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.12">Equality Operators</A></h3>

<p class=para>
The equality operators are much like the relational operators.

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-14"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Numeric</TH>
<th align="left">String</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>==</tt></TD>
<td align="left"><tt class=literal>eq</tt></TD>
<td align="left">Equal to</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>!=</tt></TD>
<td align="left"><tt class=literal>ne</tt></TD>
<td align="left">Not equal to</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>&lt;=&gt;</tt></TD>
<td align="left"><tt class=literal>cmp</tt></TD>
<td align="left">Comparison, with signed result</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
The equal and not-equal operators return 1 for true, and <tt class=literal>``</tt> for false (just as
the relational operators do).  The <tt class=literal>&lt;=&gt;</tt> and <b>cmp</B> operators return
-1 if the left operand is less than the right operand, 0 if they are
equal, and +1 if the left operand is greater than the right.  Although
these appear to be very similar to the relational operators, they do
have a different precedence level, so <tt class=literal>$a &lt; $b &lt;=&gt; $c &lt; $d</tt> is
syntactically valid.

<p class=para>
For reasons that are apparent to anyone who has seen <i class=emphasis>Star Wars</I>, the <tt class=literal>&lt;=&gt;</tt>
operator is known as the "spaceship" operator.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.13">Bitwise Operators</A></h3>

<p class=para>
Like C, Perl has bitwise AND, OR, and XOR (exclusive
OR) operators: <tt class=literal>&amp;</tt>, <tt class=literal>|</tt>, and <tt class=literal>^</tt>.  Note from the table at the
start of this section that bitwise-AND has a higher precedence.  These
operators work differently on numeric values than they do on strings.
(This is one of the few places where Perl cares about the difference.)
If either operand is a number (or has been used as a number), then both
operands are converted to type integer, and the bitwise operation is
performed between the two integers.  These integers are guaranteed to
be at least 32 bits long, but may be 64 bits on some machines.  The point
is that there's an arbitrary limit imposed by the machine's architecture.

<p class=para>
If both operands are strings (and have not been used as numbers since
being set), these operators do bitwise operations between corresponding
bits from the two strings.  In this case, there's no arbitrary limit,
since strings aren't arbitrarily limited in size.  If one string is
longer than the other, the shorter string is considered to have a sufficient
number of 0 bits on the end to make up the difference.

<p class=para>
For example, if you AND together two strings:

<div class=programlisting>
<p>
<pre>
"123.45" &amp; "234.56"
</PRE>
</DIV>

<p class=para>
you get another string:

<div class=programlisting>
<p>
<pre>
"020.44"
</PRE>
</DIV>

<p class=para>
But if you AND together a string and a number:

<div class=programlisting>
<p>
<pre>
"123.45" &amp; 234.56
</PRE>
</DIV>

<p class=para>
The string is first converted to a number, giving:

<div class=programlisting>
<p>
<pre>
123.45 &amp; 234.56
</PRE>
</DIV>

<p class=para>
The numbers are then converted to integer:

<div class=programlisting>
<p>
<pre>
123 &amp; 234
</PRE>
</DIV>

<p class=para>
which evaluates to 106.

<p class=para>
Note that all bit strings are true
(unless they come out to being the string "<tt class=literal>0</tt>").  This means
that tests of the form:

<div class=programlisting>
<p>
<pre>
if ( "fred" &amp; "\1\2\3\4" ) { ... }
</PRE>
</DIV>

<p class=para>
would need to be written instead as:

<p class=para>
<div class=programlisting>
<p>
<pre>
if ( ("fred" &amp; "\1\2\3\4") !~ /^\0+$/ ) { ... }
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.14">C-style Logical (Short Circuit) Operators</A></h3>

<p class=para>
Like C, Perl provides the <tt class=literal>&amp;&amp;</tt> (logical AND)
and <tt class=literal>||</tt> (logical OR) operators.  They evaluate from
left to right (with <tt class=literal>&amp;&amp;</tt> having slightly
higher precedence than <tt class=literal>||</tt>) testing the truth of the
statement.  These operators are known as short-circuit operators
because they determine the truth of the statement by evaluating the
fewest number of operands possible.  For example, if the left operand
of an <tt class=literal>&amp;&amp;</tt> operator is false, the right operand
is never evaluated because the result of the operator is false
regardless of the value of the right operand.

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-15"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Example</TH>
<th align="left">Name</TH>
<th align="left">Result</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>$a &amp;&amp; $b</tt></TD>
<td align="left">And</TD>
<td align="left"><tt class=literal>$a</tt> if <tt class=literal>$a</tt> is false, <tt class=literal>$b</tt> otherwise</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>$a || $b</tt></TD>
<td align="left">Or</TD>
<td align="left"><tt class=literal>$a</tt> if <tt class=literal>$a</tt> is true, <tt class=literal>$b</tt> otherwise</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
Such short circuits are not only time savers, but are frequently used
to control the flow of evaluation.  For example, an oft-appearing idiom
in Perl programs is:

<p class=para>
<div class=programlisting>
<p>
<pre>
open(FILE, "somefile") || die "Cannot open somefile: $!\n";
</PRE>
</DIV>

<p class=para>
In this case, Perl first evaluates the <a href="ch03_02.htm">open</A> function.  If the value
is true (because <i class=emphasis>somefile</I> was successfully opened), the execution
of the <a href="ch03_02.htm">die</A> function is unnecessary, and is skipped.  You can read
this literally as "Open some file or die!"

<p class=para>
The <tt class=literal>||</tt> and <tt class=literal>&amp;&amp;</tt> operators differ from C's in that, rather than
returning 0 or 1, they return the last value evaluated.  This has the
delightful result that you can select the first of a series of values
that happens to be true.  Thus, a reasonably portable way to find out
the home directory might be:

<p class=para>
<div class=programlisting>
<p>
<pre>
$home = $ENV{HOME} 
     || $ENV{LOGDIR} 
     || (getpwuid($&lt;))[7] 
     || die "You're homeless!\n";
</PRE>
</DIV>

<p class=para>
Perl also provides lower precedence <b>and</B> and <b>or</B> operators that are
more readable and don't force you to use parentheses as much.  They also
short-circuit.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.15">Range Operator</A></h3>

<p class=para>
<a name="CH02.RANGE1"></A><a name="CH02.RANGE2"></A>The <tt class=literal>..</tt> range operator is really two different
operators depending on the context.  In a list context, it returns a
list of values counting (by ones) from the left value to the right
value.  This is useful for writing <tt class=literal>for (1..10)</tt> loops and for doing
slice operations on arrays.[31]

<blockquote class=footnote>
<p class=para>[31] 
Be aware that under the current implementation,
a temporary array is created, so you'll burn a <i class=emphasis>lot</I> of memory if you 
write something like this:
<p class=para>
<div class=programlisting>
<p>
<pre>
for (1 .. 1_000_000) {
    # code
}
</PRE>
</DIV>
</blockquote>
<p class=para>
In a scalar context, <tt class=literal>..</tt> returns a Boolean value.  The operator
is bi-stable, like an electronic flip-flop, and emulates the line-range
(comma) operator of <i class=emphasis>sed</I>, <i class=emphasis>awk</I>, and various editors.  Each
scalar <tt class=literal>..</tt> operator maintains its own Boolean state.  It is false
as long as its left operand is false.  Once the left operand is true,
the range operator stays true until the right operand is true,
<i class=emphasis>after</I> which the range operator becomes false again.  (The operator doesn't
become false until the next time it is evaluated.  It can test the right operand
and become false on the same evaluation as the one where it became true (the way
<i class=emphasis>awk</I>'s range operator behaves), but it still returns true once.  If you
don't want it to test the right operand until the next evaluation (which is how
<i class=emphasis>sed</I>'s range operator works), just use three dots (<tt class=literal>. . .</tt>) instead of
two.)  The right operand is not evaluated while the operator is in the false
state, and the left operand is not evaluated while the operator is in the true
state.

<p class=para>
The precedence is a little lower than <tt class=literal>||</tt> and <tt class=literal>&amp;&amp;</tt>.
The value returned is
either the null string for false, or a sequence number (beginning with
<tt class=literal>1</tt>) for true.  The sequence number is reset for each range encountered.
The final sequence number in a range has the string "E0" appended to it,
which doesn't affect its numeric value, but gives you something to
search for if you want to exclude the endpoint.  You can exclude the
beginning point by waiting for the sequence number to be greater than 1.
If either operand of scalar <tt class=literal>..</tt> is a numeric literal, that operand is
evaluated by comparing it to the <b>$.</B> variable, which contains the current
line number for your input file.  Examples:

<p class=para>
As a scalar operator:

<p class=para>
<div class=programlisting>
<p>
<pre>
if (101 .. 200) { print; }  # print 2nd hundred lines
next line if (1 .. /^$/);   # skip header lines
s/^/&gt; / if (/^$/ .. eof()); # quote body
</PRE>
</DIV>

<p class=para>
As a list operator:

<p class=para>
<div class=programlisting>
<p>
<pre>
for (101 .. 200) { print; }            # prints 101102...199200
@foo = @foo[0 .. $#foo];               # an expensive no-op
@foo = @foo[ -5 .. -1];                # slice last 5 items
</PRE>
</DIV>

<p class=para>
The range operator (in a list context) makes use of the magical
autoincrement algorithm if the operands are strings.[32]
So you can say:

<blockquote class=footnote>
<p class=para>[32] 
If the final value specified is not in the sequence that the magical increment
would produce, the sequence goes until the next value would be longer than
the final value specified.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
@alphabet = ('A' .. 'Z');
</PRE>
</DIV>

<p class=para>
to get all the letters of the alphabet, or:

<p class=para>
<div class=programlisting>
<p>
<pre>
$hexdigit = (0 .. 9, 'a' .. 'f')[$num &amp; 15];
</PRE>
</DIV>

<p class=para>
to get a hexadecimal digit, or:

<p class=para>
<div class=programlisting>
<p>
<pre>
@z2 = ('01' .. '31');  print $z2[$mday];
</PRE>
</DIV>

<p class=para>
to get dates with leading zeros.  You can also say:

<p class=para>
<div class=programlisting>
<p>
<pre>
@combos = ('aa' .. 'zz');
</PRE>
</DIV>

<p class=para>
to get all combinations of two lowercase letters. However, be careful of
something like:

<p class=para>
<div class=programlisting>
<p>
<pre>
@bigcombos = ('aaaaaa' .. 'zzzzzz');
</PRE>
</DIV>

<p class=para>
since that will require lots of memory.  More precisely, it'll need
space to store 308,915,776 scalars.  Let's hope you allocated a <i class=emphasis>large</I>
swap partition.  Perhaps you should consider an iterative approach instead.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.16">Conditional Operator</A></h3>

<p class=para>
Trinary <tt class=literal>?:</tt> is the conditional operator, just as in C.  It works as:

<p class=para>
<div class=programlisting>
<p>
<pre>
<tt class=replaceable><i>TEST_EXPR</i></tt> ? <tt class=replaceable><i>IF_TRUE_EXPR</i></tt> : <tt class=replaceable><i>IF_FALSE_EXPR</i></tt>
</PRE>
</DIV>

<p class=para>
much like an if-then-else, except that it can safely be embedded within other
operations and functions.  If the <tt class=replaceable><i>TEST_EXPR</i></tt> is true, only the
<tt class=replaceable><i>IF_TRUE_EXPR</i></tt> is evaluated, and the value of that expression becomes
the value of the entire expression.  Otherwise, only the <tt class=replaceable><i>IF_FALSE_EXPR</i></tt>
is evaluated, and its value becomes the value of the entire
expression.

<p class=para>
<div class=programlisting>
<p>
<pre>
printf "I have %d dog%s.\n", $n, 
        ($n == 1) ? "" : "s";
</PRE>
</DIV>

<p class=para>
Scalar or list context propagates downward into the second
or third argument, whichever is selected. (The first argument is always
in scalar context, since it's a conditional.)

<p class=para>
<div class=programlisting>
<p>
<pre>
$a = $ok ? $b : $c;  # get a scalar
@a = $ok ? @b : @c;  # get an array
$a = $ok ? @b : @c;  # get a count of elements in one of the arrays
</PRE>
</DIV>

<p class=para>
You can assign to the conditional operator[33]
if both the second and third
arguments are
legal lvalues (meaning that you can assign to them), provided that both are
scalars or both are lists (or Perl won't know which context to supply to
the right side of the assignment):

<blockquote class=footnote>
<p class=para>[33] 
This is not necessarily guaranteed to contribute to the readability of your 
program.  But it can be used to create some cool entries in an Obfuscated
Perl contest.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
($a_or_b ? $a : $b) = $c;  # sets either $a or $b to equal $c
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.17">Assignment Operators</A></h3>

<p class=para>

Perl recognizes the C assignment operators, as well as providing some of its
own.  There are quite a few of them:

<p class=para>
<div class=programlisting>
<p>
<pre>
=    **=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=
            -=    /=    |=    &gt;&gt;=    ||=
            .=    %=    ^=
                  x=
</PRE>
</DIV>

<p class=para>
Each operator requires an lvalue (a variable or array element) on the left
side, and some expression on the right side.  For the simple assignment
operator, <tt class=literal>=</tt>, the value of the expression is stored into the designated
variable.  For the other operators, Perl evaluates the expression:

<p class=para>
<div class=programlisting>
<p>
<pre>
$var <tt class=replaceable><i>OP</i></tt>= $value
</PRE>
</DIV>

<p class=para>
as if it were written:

<p class=para>
<div class=programlisting>
<p>
<pre>
$var = $var <tt class=replaceable><i>OP</i></tt> $value
</PRE>
</DIV>

<p class=para>
except that <tt class=literal>$var</tt> is evaluated only once.  Compare the following two
operations:

<p class=para>
<div class=programlisting>
<p>
<pre>
$var[$a++] += $value;               # $a is incremented once
$var[$a++] = $var[$a++] + $value;   # $a is incremented twice
</PRE>
</DIV>

<p class=para>
Unlike in C, the assignment operator produces a valid lvalue.  Modifying
an assignment is equivalent to doing the assignment and then modifying
the variable that was assigned to.  This is useful for modifying
a copy of something, like this:

<p class=para>
<div class=programlisting>
<p>
<pre>
($tmp = $global) += $constant;
</PRE>
</DIV>

<p class=para>
which is the equivalent of:

<p class=para>
<div class=programlisting>
<p>
<pre>
$tmp = $global + $constant;
</PRE>
</DIV>

<p class=para>
Likewise:

<p class=para>
<div class=programlisting>
<p>
<pre>
($a += 2) *= 3;
</PRE>
</DIV>

<p class=para>
is equivalent to:

<p class=para>
<div class=programlisting>
<p>
<pre>
$a += 2;
$a *= 3;
</PRE>
</DIV>

<p class=para>
That's not actually very useful, but you often see this idiom:

<p class=para>
<div class=programlisting>
<p>
<pre>
($new = $old) =~ s/foo/bar/g;
</PRE>
</DIV>

<p class=para>
In all cases, the value of the assignment is the new value of the variable.
Since assignment operators associate right-to-left, this can be used to assign
many variables the same value, as in:

<p class=para>
<div class=programlisting>
<p>
<pre>
$a = $b = $c = 0;
</PRE>
</DIV>

<p class=para>
which assigns <tt class=literal>0</tt> to <tt class=literal>$c</tt>, and the result of that (still <tt class=literal>0</tt>) to
<tt class=literal>$b</tt>, and the result of that (<i class=emphasis>still</I> <tt class=literal>0</tt>) to <tt class=literal>$a</tt>.

<p class=para>
List assignment may be done only with the plain assignment operator, <tt class=literal>=</tt>.
In a list context, list assignment returns the list of new values just as
scalar assignment does.  In a scalar context, list assignment returns the
number of values that were available on the right side of the assignment,
as we mentioned earlier in "List Values and Arrays".  This makes it
useful for testing functions that return a null list when they're
"unsuccessful", as in:

<p class=para>
<div class=programlisting>
<p>
<pre>
while (($key, $value) = each %gloss) { ... }
next unless ($dev, $ino, $mode) = stat $file;
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.18">Comma Operators</A></h3>

<p class=para>
Binary "<tt class=literal>,</tt>" is the comma operator.  In a scalar context it evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value.  This is just like C's comma operator.
For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
$a = (1, 3);
</PRE>
</DIV>

<p class=para>
assigns <tt class=literal>3</tt> to <tt class=literal>$a</tt>.  Do not confuse the scalar context use with the list
context use.  In a list context, it's just the list argument separator, and 
inserts both its arguments into the <tt class=replaceable><i>LIST</i></tt>.  It does not throw any values
away.  

<p class=para>
For example, if you change the above to:

<p class=para>
<div class=programlisting>
<p>
<pre>
@a = (1, 3);
</PRE>
</DIV>

<p class=para>
you are constructing a two-element list, while:

<p class=para>
<div class=programlisting>
<p>
<pre>
atan2(1, 3);
</PRE>
</DIV>

<p class=para>
is calling the function <a href="ch03_02.htm">atan2</A> with two arguments.

<p class=para>
The <tt class=literal>=&gt;</tt> digraph is mostly just a synonym for the comma operator.
It's useful for documenting arguments that come in pairs.  It also
forces any identifier to the left of it to be interpreted as a string.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.19">List Operators (Rightward)</A></h3>

<p class=para>
The right side of a list operator governs all the list operator's
arguments, which are comma separated, so the precedence of list operators is
looser than comma if you're looking to the right.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.20">Logical and, or, not, and xor</A></h3>

<p class=para>
As more readable alternatives to <tt class=literal>&amp;&amp;</tt>, <tt class=literal>||</tt>, and <tt class=literal>!</tt>,
Perl provides the <b>and</B>, <b>or</B> and <b>not</B> operators.  The
behavior of these operators is identical--in particular, they
short-circuit the same way.[34]

<blockquote class=footnote>
<p class=para>[34] 
Obviously the unary <b>not</B> doesn't short circuit, just as <tt class=literal>!</tt> doesn't.
</blockquote>
<p class=para>
The precedence of these operators is much lower, however, so you can
safely use them after a list operator without the need for
parentheses:

<p class=para>
<div class=programlisting>
<p>
<pre>
unlink "alpha", "beta", "gamma"
        or gripe(), next LINE;
</PRE>
</DIV>

<p class=para>
With the C-style operators that would have to be written like this:

<p class=para>
<div class=programlisting>
<p>
<pre>
unlink("alpha", "beta", "gamma")
        || (gripe(), next LINE);
</PRE>
</DIV>

<p class=para>
There is also a logical <b>xor</B> operator that has no exact counterpart in
C or Perl, since the other XOR operator (<tt class=literal>^</tt>) works on bits.  The
best equivalent for <tt class=literal>$a xor $b</tt> is perhaps <tt class=literal>!$a != !$b</tt>.[35]
This operator can't short-circuit either, since both sides must be evaluated.

<blockquote class=footnote>
<p class=para>[35] 
One could also write <tt class=literal>!$a ^ !$b</tt> or even <tt class=literal>$a ? !$b : !!$b</tt>,
of course.  The point is that both <tt class=literal>$a</tt> and <tt class=literal>$b</tt> have to
evaluate to true or false in a Boolean context, and the existing bitwise
operator doesn't provide a Boolean context.
</blockquote>
</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-5.21">C Operators Missing from Perl</A></h3>

<p class=para>
Here is what C has that Perl doesn't:

<p>
<dl class=variablelist>
<dt class=varlistentry><tt class=literal>unary &amp;</tt><dd>

<p class=para>
The address-of operator.  Perl's <tt class=literal>\</tt> operator (for taking a reference)
fills the same ecological niche, however:

<p class=para>
<div class=programlisting>
<p>
<pre>
$ref_to_var = \$var;
</PRE>
</DIV>

<p class=para>
But references are much safer than addresses.

<p>
<dt class=varlistentry><tt class=literal>unary *</tt><dd>

<p class=para>
The dereference-address operator.  Since Perl doesn't have addresses, it
doesn't need to dereference addresses.  It does have references though,
so Perl's variable prefix characters serve as dereference operators,
and indicate type as well: <tt class=literal>$</tt>, <tt class=literal>@</tt>, <tt class=literal>%</tt> and
<tt class=literal>&amp;</tt>.  Oddly enough, there actually is a <tt class=literal>*</tt> dereference
operator, but since <tt class=literal>*</tt> is the funny character
indicating a typeglob, you wouldn't use it the same way.

<p>
<dt class=varlistentry><tt class=literal>(TYPE)</tt><dd>

<p class=para>
The typecasting operator.  Nobody likes to be typecast anyway.</DL>
</DIV>

</DIV>


<div class=htmlnav>
<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch02_04.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch02_06.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Pattern Matching</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Statements and Declarations</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>
</BODY>
</HTML>
