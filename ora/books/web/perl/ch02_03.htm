<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 2] 2.3 Terms</TITLE>
<meta name="author" content="Larry Wall, Tom Christiansen, and Randal Schwartz">
<meta name="date" content="Mon Mar 17 13:02:20 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="Perl">
<meta name="title" content="Programming Perl, Second Edition">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="Programming Perl, Second Edition"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch02_02.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 2</b></td>
<td width=172 align=right valign=top><a href="ch02_04.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="PERL2-CH-2-SECT-3">2.3 Terms</A></h2>

<p class=para>
Now that we've talked about the kinds of data you can represent in Perl,
we'd like to introduce you to the various kinds of terms you can use
to pull that data into expressions.  We'll use the technical term
<i class=emphasis>term</I> when we want to talk in terms of these syntactic units.  (Hmm,
this could get confusing.)  The first terms we'll talk about are
<i class=emphasis>variables</I>.

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-3.1">Variables</A></h3>

<p class=para>
<a name="CH02.VAR"></A>There are variable types corresponding to each of the three data types
we mentioned. Each of these is introduced (grammatically speaking) by
what we call a "funny character". Scalar variables are always named
with an initial <tt class=literal>$</tt>,
even when referring to a scalar that is part of an array or hash.  It works
a bit like the English word "the". Thus, we have:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-1"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Construct</TH>
<th align="LEFT">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>$days</tt></TD>
<td align="LEFT">Simple scalar value <tt class=literal>$days</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>$days[28]</tt></TD>
<td align="LEFT">29th element of array <tt class=literal>@days</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>$days{'Feb'}</tt></TD>
<td align="LEFT">"<tt class=literal>Feb</tt>" value from hash <tt class=literal>%days</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>$#days</tt></TD>
<td align="LEFT">Last index of array <tt class=literal>@days</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>$days-&gt;[28]</tt></TD>
<td align="LEFT">

<p class=para>
29th element of array pointed to by reference <tt class=literal>$days</tt></TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
Entire arrays or array slices (and also slices of hashes) are named with
<tt class=literal>@</tt>, which works much like the words "these" or "those":

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-2"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Construct</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>@days</tt></TD>
<td align="left">Same as <tt class=literal>($days[0], $days[1],... $days[n])</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>@days[3..5]</tt></TD>
<td align="left">Same as <tt class=literal>($days[3], $days[4], $days[5])</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>@days[3..5]</tt></TD>
<td align="left">Same as <tt class=literal>@days[3,4,5]</tt></TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>@days{'Jan','Feb'}</tt></TD>
<td align="left">Same as <tt class=literal>($days{'Jan'},$days{'Feb'})</tt></TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
Entire hashes are named by <tt class=literal>%</tt>:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-3"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Construct</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>%days</tt></TD>
<td align="left"><tt class=literal>(Jan =&gt; 31, Feb =&gt; $leap ? 29 : 28, ...)</tt></TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
Any of these nine constructs may serve as an <i class=emphasis>lvalue</I>,
that is, they specify a location that you could assign a value to,
among other things.[2]

<blockquote class=footnote>
<p class=para>[2] 
 Assignment itself is an <i class=emphasis>lvalue</I>
in certain contexts--see examples under <b>s///</B>, <a href="ch03_02.htm">tr///</A>,
<b>chop</B>, and <b>chomp</B> in <a href="ch03_01.htm">Chapter 3, <i>Functions</i></A>.  
</blockquote>
<p class=para>
In addition, subroutine calls are named with an initial <tt class=literal>&amp;</tt>,
although this is optional when it's otherwise unambiguous (just as "do" is
often redundant in English).  Symbol table entries can be named with an
initial <tt class=literal>*</tt>, but you don't really care about that yet.

<p class=para>
Every variable type has its own namespace.  You can, without fear of
conflict, use the same name for a scalar variable, an array, or a hash
(or, for that matter, a filehandle, a subroutine name, a label, or your
pet llama).  This means that <tt class=literal>$foo</tt> and <tt class=literal>@foo</tt> are two
different variables.  It also means that <tt class=literal>$foo[1]</tt> is an element
of <tt class=literal>@foo</tt>, not a part of <tt class=literal>$foo</tt>.  This may seem a bit weird,
but that's okay, because it is weird.

<p class=para>
Since variable names always start with <tt class=literal>$</tt>, <tt class=literal>@</tt>, or
<tt class=literal>%</tt>, the reserved words can't conflict with variable names.  But
they can conflict with nonvariable identifiers, such as labels and
filehandles, which don't have an
initial funny character.  Since reserved words are always entirely
lowercase, we recommend that you pick label and filehandle names that do not
appear all in lowercase.  For example, you could say
<tt class=literal>open(LOG,'logfile')</tt> rather
than the regrettable <tt class=literal>open(log,'logfile')</tt>.[3]
Using uppercase filehandles also improves readability and protects you from
conflict with future reserved words.

<blockquote class=footnote>
<p class=para>[3] 
Regrettable because <tt class=literal>log</tt> is a predefined function returning 
the base <i class=emphasis>e</I> logarithm of its argument, or of <tt class=literal>$_</tt> if 
its argument is missing, as it is in this case.
</blockquote>
<p class=para>
Case <i class=emphasis>is</I> significant--<tt class=literal>FOO</tt>,
<tt class=literal>Foo</tt> and <tt class=literal>foo</tt> are all different
names.  Names that start with a letter or underscore may be of any
length (well, 255 characters, at least) and may contain letters, digits, and
underscores.  Names that start with a digit may only contain more
digits.  Names that start with anything else are limited to that one
character (like <b>$?</B> or <b>$$</B>), and generally have a predefined significance
to Perl.  For example, just as in the Bourne shell, <b>$$</B> is the current process ID and <b>$?</B> the exit status of your last child process.

<p class=para>
Sometimes you want to name something indirectly.  It is possible to
replace an alphanumeric name with an expression that returns a reference
to the actual variable (see <a href="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>).

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-3.2">Scalar Values</A></h3>

<p class=para>
<a name="CH02.SCALAR"></A>Whether it's named directly or indirectly, or is just a temporary value
on a stack, a scalar always contains a single value.  This value may be
a number,[4]
a string,[5]
or a reference to another piece of data.  (Or there may be no value at
all, in which case the scalar is said to be <i class=emphasis>undefined</I>.) While we might
speak of a scalar as "containing" a number or a string, scalars are
essentially typeless; there's no way to declare a scalar to be of type
"number" or "string".  Perl converts between the various subtypes as
needed, so you can treat a number as a string or a string as a number,
and Perl will do the Right Thing.[6]

<blockquote class=footnote>
<p class=para>[4] 
Perl stores numbers as signed integers if possible, or as double-precision
floating-point values in the machine's native format otherwise.
Floating-point values are not infinitely precise.  This is very
important to remember, since comparisons like <tt class=literal>(10/3 == 1/3*10)</tt> tend to
fail mysteriously.

<p class=para>[5] 
Perl stores strings as sequences of bytes, with no arbitrary constraints
on length or content.  In human terms, you don't have to decide in
advance how long your strings are going to get, and you can include any
characters including null characters within your string.

<p class=para>[6] 
To convert from string to number, Perl uses C's <i class=emphasis>atof</I> (3) function.  To
convert from number to string, it does the equivalent of an
<i class=emphasis>sprintf</I> (3) with a format of <tt class=literal>"%.14g"</tt> on most machines.
</blockquote>
<p class=para>
While strings and numbers are interchangeable for nearly all intents and 
purposes, references are a bit different.  They're strongly typed,
uncastable[7]
pointers with built-in reference-counting and destructor invocation.
You can use them to create complex data types, including user-defined
objects.  But they're still scalars, for all that.  See <a href="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A> for
more on references.

<blockquote class=footnote>
<p class=para>[7] 
By which we mean that you can't, for instance, convert a reference to an
array into a reference to a hash.  References are not castable to other
pointer types.  However, if you use a reference as a number or a string,
you will get a numeric or string value, which is guaranteed to retain the
uniqueness of the reference even though the "referenceness" of the value
is lost when the value is copied from the real reference.  You can compare
such values or test whether they are defined.  But you can't do much else with
the values, since there's no way to convert numbers or strings into
references.  In general this is not a problem, since Perl doesn't force you
to do pointer arithmetic--or even allow it.
</blockquote>
<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.2.1">Numeric literals</A></h4>

<p class=para>
Numeric literals are specified in any of several customary[8]
floating point or integer formats:

<blockquote class=footnote>
<p class=para>[8] 
Customary in UNIX culture, that is.  If you're from a different culture,
welcome to ours!
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
12345               # integer
12345.67            # floating point
6.02E23             # scientific notation
0xffff              # hexadecimal
0377                # octal
4_294_967_296       # underline for legibility
</PRE>
</DIV>

<p class=para>
Since Perl uses the comma as a list separator, you cannot use it to delimit
the triples in a large number.  To improve legibility, Perl does allow you
to use an underscore character instead.  The underscore only
works within literal numbers specified in your program, not for strings
functioning as numbers or data read from somewhere else.  Similarly, the
leading <tt class=literal>0x</tt> for hex and <tt class=literal>0</tt> for octal work only for literals.
The automatic conversion of a string to a number does not recognize these
prefixes--you must do an explicit conversion[9]
with the <a href="ch03_02.htm">oct</A> function (which works for hex-looking data, too, as it
happens).

<blockquote class=footnote>
<p class=para>[9] 
Sometimes people think Perl should convert all incoming data for them.  But
there are far too many decimal numbers with leading zeroes in the world
to make Perl do this automatically.  For example, the zip code for O'Reilly
&amp; Associates' office in Cambridge, MA is <tt class=literal>02140</tt>.  The postmaster would
get upset if your mailing label program turned <tt class=literal>02140</tt> into <tt class=literal>1120</tt>
decimal.
</blockquote>
</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.2.2">String literals</A></h4>

<p class=para>
<a name="CH02.STRING"></A>String literals are usually delimited by either single or double quotes.
They work much like UNIX shell quotes: double-quoted string literals
are subject to backslash and variable interpolation; single-quoted
strings are not (except for <tt class=literal>\'</tt> and <tt class=literal>\\</tt>, so that you
can put single quotes and backslashes into single-quoted strings).

<p class=para>
You can also embed newlines directly in your strings; that is, they can
begin and end on different lines.  This is nice for many reasons,
but it also means that if you forget a trailing quote, the error will
not be reported until Perl finds another line containing the quote
character, which may be much further on in the script.  Fortunately,
this usually causes an immediate syntax error on the same line, and Perl
is then smart enough to warn you that you might have a runaway string.

<p class=para>
Note that a single-quoted string must be separated from a preceding word by
a space, since a single quote is a valid (though deprecated) character in
an identifier; see <a href="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>.

<p class=para>
With double-quoted strings, the usual C-style backslash rules apply for
inserting characters such as newline, tab, and so on.  You may also specify
characters in octal and hexadecimal, or as control characters:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-4"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Code</TH>
<th align="left">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\n</tt></TD>
<td align="left">Newline</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\r</tt></TD>
<td align="left">Carriage return</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\t</tt></TD>
<td align="left">Horizontal tab</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\f</tt></TD>
<td align="left">Form feed</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\b</tt></TD>
<td align="left">Backspace</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\a</tt></TD>
<td align="left">Alert (bell)</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\e</tt></TD>
<td align="left">ESC character</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\033</tt></TD>
<td align="left">ESC in octal</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\x7f</tt></TD>
<td align="left">DEL in hexadecimal</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\cC</tt></TD>
<td align="left">Control-C</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
In addition, there are escape sequences to modify the case of subsequent
characters, as with the substitution operator in the <i class=emphasis>vi</I> editor:

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-5"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Code</TH>
<th align="LEFT">Meaning</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\u</tt></TD>
<td align="LEFT">Force next character to uppercase.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\l</tt></TD>
<td align="LEFT">Force next character to lowercase.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\U</tt></TD>
<td align="LEFT">Force all following characters to uppercase.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\L</tt></TD>
<td align="LEFT">Force all following characters to lowercase.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\Q</tt></TD>
<td align="LEFT">

<p class=para>
Backslash all following non-alphanumeric characters.</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>\E</tt></TD>
<td align="LEFT">

<p class=para>
End <tt class=literal>\U</tt>, <tt class=literal>\L</tt>, or <tt class=literal>\Q</tt>.</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
<p class=para>
Besides the backslash escapes listed above, double-quoted strings are
subject to <i class=emphasis>variable interpolation</I> of scalar and list values.  
This means that you can insert the values of certain variables directly
into a string literal.  It's really just a handy form of string
concatenation.
Variable interpolation may only be done for scalar variables, entire arrays (but not
hashes), single elements from an array or hash, or slices (multiple
subscripts) of an array or hash.  In other words, you may only interpolate
expressions that begin with <tt class=literal>$</tt> or <tt class=literal>@</tt>, because those are the
two characters (along with backslash) that the string parser looks for.[10]
Although a complete hash specified with a <tt class=literal>%</tt> may not be interpolated
into the string, single hash values and hash slices are okay, because they
begin with <tt class=literal>$</tt> and <tt class=literal>@</tt> respectively.

<blockquote class=footnote>
<p class=para>[10] 
Inside strings a literal <tt class=literal>@</tt> that is not part of an array or slice
identifier must be escaped with a backslash (<tt class=literal>\@</tt>), or else a
compilation error
will result.  See <a href="ch09_01.htm">Chapter 9, <i>Diagnostic Messages</i></A>.
</blockquote>
<p class=para>
The following code segment prints out: "<tt class=literal>The price is $100.</tt>"

<p class=para>
<div class=programlisting>
<p>
<pre>
$Price = '$100';                    # not interpolated
print "The price is $Price.\n";     # interpolated
</PRE>
</DIV>

<p class=para>
As in some shells, you can put braces around the identifier to
distinguish it from following alphanumerics: <tt class=literal>"How ${verb}able!"</tt>.
In fact, an identifier within such braces is
forced to be a string, as is any single identifier within a hash subscript.
For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
$days{'Feb'}
</PRE>
</DIV>

<p class=para>
can be written as:

<p class=para>
<div class=programlisting>
<p>
<pre>
$days{Feb}
</PRE>
</DIV>

<p class=para>
and the quotes will be assumed automatically.  But anything more complicated
in the subscript will be interpreted as an expression.

<p class=para>
Apart from the subscripts of interpolated array and hash variables,
there are no multiple levels of interpolation.  In particular, contrary
to the expectations of shell programmers, backquotes do not
interpolate within double quotes, nor do single quotes impede evaluation
of variables when used within double quotes.

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.2.3">Pick your own quotes</A></h4>

<p class=para>
<a name="CH02.QUOTE"></A>While we usually think of quotes as literal values, in Perl they
function more like operators, providing various kinds of interpolating
and pattern matching capabilities.  Perl provides the customary quote
characters for these behaviors, but also provides a way for you to
choose your quote character for any of them.

<div class=informaltable>
<p>
<a name="PERL2-CH-2-TAB-5A"></A>

<table class=INFORMALTABLE>
<tr class=row>
<th align="left">Customary</TH>
<th align="left">Generic</TH>
<th align="left">Meaning</TH>
<th align="left">Interpolates</TH>
</TR>
<tr class=row>
<td align="left"><tt class=literal>''</tt></TD>
<td align="left"><tt class=literal>q//</tt></TD>
<td align="left">Literal</TD>
<td align="left">No</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>""</tt></TD>
<td align="left"><tt class=literal>qq//</tt></TD>
<td align="left">Literal</TD>
<td align="left">Yes</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>``</tt></TD>
<td align="left"><tt class=literal>qx//</tt></TD>
<td align="left">Command</TD>
<td align="left">Yes</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>()</tt></TD>
<td align="left"><tt class=literal>qw//</tt></TD>
<td align="left">Word list</TD>
<td align="left">No</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>//</tt></TD>
<td align="left"><tt class=literal>m//</tt></TD>
<td align="left">Pattern match</TD>
<td align="left">Yes</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>s///</tt></TD>
<td align="left"><tt class=literal>s///</tt></TD>
<td align="left">Substitution</TD>
<td align="left">Yes</TD>
</TR>
<tr class=row>
<td align="left"><tt class=literal>y///</tt></TD>
<td align="left"><tt class=literal>tr///</tt></TD>
<td align="left">Translation</TD>
<td align="left">No</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
Some of these are simply forms of "syntactic sugar" to let you avoid
putting too many backslashes into quoted strings.  Any non-alphanumeric,
non-whitespace delimiter can be used in place of <tt class=literal>/</tt>.[11]
If the delimiters are single quotes, no variable interpolation is done
on the pattern. If the opening delimiter is a parenthesis, bracket, brace, or angle
bracket, the closing delimiter will be the matching construct.
(Embedded occurrences of the delimiters must match in pairs.)
Examples:

<blockquote class=footnote>
<p class=para>[11] 
In particular, the newline and space characters are not allowed as
delimiters.  (Ancient versions of Perl allowed this.)
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
$single = q!I said, "You said, 'She said it.'"!;
$double = qq(Can't we get some "good" $variable?);
$chunk_of_code = q {
    if ($condition) {
        print "Gotcha!";
    }
};
</PRE>
</DIV>

<p class=para>
Finally, for two-string constructs like <tt class=literal>s///</tt> and <tt class=literal>tr///</tt>, if the
first pair of quotes is a bracketing pair, then the second part gets its
own starting quote character, which needn't be the same as the first
pair.  So you can write things like <tt class=literal>s{foo}(bar)</tt> or <tt class=literal>tr[a-z][A-Z]</tt>.
Whitespace is allowed between the two inner quote characters, so you
could even write that last one as:

<p class=para>
<div class=programlisting>
<p>
<pre>
tr [a-z]
   [A-Z];
</PRE>
</DIV>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.2.4">Or leave the quotes out entirely</A></h4>

<p class=para>
A word that has no other interpretation in the grammar will be treated as
if it were a quoted string.  These are known as <i class=emphasis>barewords</I>.[12]
For example:

<blockquote class=footnote>
<p class=para>[12] 
As with filehandles and labels, a bareword that consists entirely of
lowercase letters risks conflict with future reserved words.  If you use
the <b>-w</B> switch, Perl will warn you about barewords.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
@days = (Mon,Tue,Wed,Thu,Fri);
print STDOUT hello, ' ', world, "\n";
</PRE>
</DIV>

<p class=para>
sets the array <tt class=literal>@days</tt> to the short form of the weekdays and prints
<tt class=literal>hello world</tt> followed by a newline on <tt class=literal>STDOUT</tt>.  If you leave the
filehandle out, Perl tries to interpret <tt class=literal>hello</tt> as a filehandle,
resulting in a syntax error.  Because this is so error-prone, some people
may wish to outlaw barewords entirely.  If you say:

<p class=para>
<div class=programlisting>
<p>
<pre>
use strict 'subs';
</PRE>
</DIV>

<p class=para>
then any bareword that would not be interpreted as a subroutine call
produces a compile-time error instead.  The restriction lasts to the
end of the enclosing block.  An inner block may countermand this 
by saying:

<p class=para>
<div class=programlisting>
<p>
<pre>
no strict 'subs';
</PRE>
</DIV>

<p class=para>
Note that the bare identifiers in constructs like:

<p class=para>
<div class=programlisting>
<p>
<pre>
"${verb}able"
$days{Feb}
</PRE>
</DIV>

<p class=para>
are not considered barewords, since they're allowed by explicit rule
rather than by having "no other interpretation in the grammar".

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.2.5">Interpolating array values</A></h4>

<p class=para>
Array variables are interpolated into double-quoted strings by joining all
the elements of the array with the delimiter specified in the
<b>$"</B> variable[13]
(which is a space by default).  The following are equivalent:

<blockquote class=footnote>
<p class=para>[13] 
<tt class=literal>$LIST_SEPARATOR</tt> if you use the English library module.
See <a href="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
$temp = join($",@ARGV);
print $temp;
print "@ARGV";
</PRE>
</DIV>

<p class=para>
Within search patterns (which also undergo double-quotish interpolation)
there is a bad ambiguity:  Is <tt class=literal>/$foo[bar]/</tt> to be interpreted as
<tt class=literal>/${foo}[bar]/</tt> (where <tt class=literal>[bar]</tt> is a character class for the regular
expression) or as <tt class=literal>/${foo[bar]}/</tt> (where <tt class=literal>[bar]</tt> is the
subscript to array <tt class=literal>@foo</tt>)?  If <tt class=literal>@foo</tt> doesn't otherwise exist,
then it's obviously a character class.  If <tt class=literal>@foo</tt> exists, Perl takes
a good guess about <tt class=literal>[bar]</tt>, and is almost always right.[14]
If it does guess wrong, or if you're just plain paranoid, you can force the
correct interpretation with braces as above.  Even if you're merely
prudent, it's probably not a bad idea.

<blockquote class=footnote>
<p class=para>[14] 
The guesser is too boring to describe in full, but basically takes a
weighted average of all the things that look like character classes
(<tt class=literal>a-z, \w,</tt> initial <tt class=literal>^</tt>) versus things that look like expressions
(variables or reserved words).
</blockquote>
</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.2.6">"Here" documents</A></h4>

<p class=para>
A line-oriented form of quoting is based on the shell's <i class=emphasis>here-document</I>
syntax.[15]
Following a <tt class=literal>&lt;&lt;</tt> you specify a string to terminate the
quoted material, and all lines following the current line down to the
terminating string are quoted.  The terminating string
may be either an identifier (a word), or some quoted text.  If quoted,
the type of quote you use determines the treatment of the text, just as
in regular quoting.  An unquoted identifier works like double quotes.
There must be no space between the <tt class=literal>&lt;&lt;</tt> and the identifier.  (If
you insert a space, it will be treated as a null identifier, which is valid
but deprecated, and matches the first blank line--see the first <tt class=literal>Hurrah!</tt>
example below.)  The terminating string must appear by itself (unquoted
and with no surrounding whitespace) on the terminating line.

<blockquote class=footnote>
<p class=para>[15] 
It's line-oriented in the sense that delimiters are lines rather than
characters.  The starting delimiter is the current line, and the terminating
delimiter is a line consisting of the string you specify.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
    print &lt;&lt;EOF;    # same as earlier example    
The price is $Price.
EOF
    print &lt;&lt;"EOF";  # same as above, with explicit quotes
The price is $Price.
EOF
    print &lt;&lt;'EOF';    # single-quoted quote
All things (e.g. a camel's journey through
A needle's eye) are possible, it's true.
But picture how the camel feels, squeezed out
In one long bloody thread, from tail to snout.
                                -- C.S. Lewis
EOF
    print &lt;&lt; x 10;    # print next line 10 times
The camels are coming!  Hurrah!  Hurrah!
    print &lt;&lt;"" x 10;  # the preferred way to write that
The camels are coming!  Hurrah!  Hurrah!
    print &lt;&lt;`EOC`;    # execute commands
echo hi there
echo lo there
EOC
    print &lt;&lt;"dromedary", &lt;&lt;"camelid"; # you can stack them
I said bactrian.
dromedary
She said llama.
camelid
</PRE>
</DIV>

<p class=para>
Just don't forget that you have to put a semicolon on the end 
to finish the statement, as Perl doesn't know you're not going to 
try to do this:

<p class=para>
<div class=programlisting>
<p>
<pre>
print &lt;&lt;ABC
179231
ABC
    + 20;   # prints 179251
</PRE>
</DIV>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.2.7">Other literal tokens</A></h4>

<p class=para>
Two special literals are _ _<tt class=literal>LINE</tt>_ _ and _ _<tt class=literal>FILE</tt>_ _, which represent
the current line number and filename at that point in your program.
They may only be used as separate tokens; they will not be interpolated
into strings.  In addition, the token _ _<tt class=literal>END</tt>_ _ may be used to indicate
the logical end of the script before the actual end of file.  Any
following text is ignored, but may be read via the <tt class=literal>DATA</tt> filehandle.

<p class=para>
The _ _<tt class=literal>DATA</tt>_ _ token functions similarly to the _ _<tt class=literal>END</tt>_ _ token, but
opens the <tt class=literal>DATA</tt> filehandle within the current package's namespace, so that
<a href="ch03_02.htm">require</A>d files can each have their own <tt class=literal>DATA</tt> filehandles open
simultaneously.  For more information, see <a href="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A>.

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-3.3">Context</A></h3>

<p class=para>
<a name="CH02.CON"></A>Until now we've seen a number of terms that can produce scalar values.
Before we can discuss terms further, though, we must come to terms
with the notion of <i class=emphasis>context</I>.

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.3.1">Scalar and list context</A></h4>

<p class=para>
<p class=para>
<a name="CH02.LCON"></A><a name="CH02.SCON"></A>Every operation[16]
that you invoke in a Perl script is evaluated in a
specific context, and how that operation behaves may depend on
the requirements of that context.  There are two major contexts:
<i class=emphasis>scalar</I> and <i class=emphasis>list</I>.  For example, assignment to a scalar variable
evaluates the right-hand side in a scalar context, while assignment to an
array or a hash (or slice of either) evaluates the right-hand side in a
list context.  Assignment to a list of scalars would also provide a list
context to the right-hand side.

<blockquote class=footnote>
<p class=para>[16] 
Here we use the term "operation" loosely to mean either an operator or a term.
The two concepts fuzz into each other when you start talking about
functions that parse like terms but look like unary operators.
</blockquote>
<p class=para>
You will be miserable until you learn the difference between scalar and
list context, because certain operators know which context they are in,
and return lists in contexts wanting a list, and scalar values in
contexts wanting a scalar.  (If this is true of an operation, it will be
mentioned in the documentation for that operation.)  In computer lingo,
the functions are <i class=emphasis>overloaded</I> on the type of their return value.  But
it's a very simple kind of overloading, based only on the
distinction between singular and plural values, and nothing else.

<p class=para>
Other operations <i class=emphasis>supply</I> the list contexts to their operands, and you
can tell which ones they are because they all have <tt class=replaceable><i>LIST</i></tt> in their
syntactic descriptions.  Generally it's quite intuitive.[17]
If necessary, you can force a scalar context in the middle of a <tt class=replaceable><i>LIST</i></tt> by
using the <a href="ch03_02.htm">scalar</A> function.  (Perl provides no way to force a list
context in a scalar context, because anywhere you would want a list
context it's already provided by the <tt class=replaceable><i>LIST</i></tt> of some controlling function.)

<blockquote class=footnote>
<p class=para>[17] 
Note, however, that the list context of a 
<tt class=replaceable><i>LIST</i></tt> can propagate down through subroutine calls, so it's not always obvious by inspection whether a
given simple statement is going to be evaluated in a scalar or list
context.  The program can find out its context within a subroutine by
using the <a href="ch03_02.htm">wantarray</A> function.
</blockquote>
<p class=para>
Scalar context can be further classified into string context, numeric
context, and don't-care context.  Unlike the scalar versus list
distinction we just made, operations never know which scalar context
they're in.  They simply return whatever kind of scalar value they want to,
and let Perl translate numbers to strings in string context, and strings to
numbers in numeric context.
Some scalar contexts don't care whether a string or number is returned,
so no conversion will happen.  (This happens, for example, when you are
assigning the value to another variable.  The new variable just takes
on the same subtype as the old value.)

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.3.2">Boolean context</A></h4>

<p class=para>
One special scalar context is called <i class=emphasis>Boolean context</I>.  Boolean context is
simply any place where an expression is being evaluated to see whether it's
true or false.  We sometimes write true and false when we mean
the technical definition that Perl uses: a scalar value is
true if it is not the null string or the number 0 (or its string
equivalent, <tt class=literal>"0"</tt>).  References are always true.

<p class=para>
A Boolean context is a don't-care context in the sense that it never
causes any conversions to happen (at least, no conversions beyond what
scalar context would impose).

<p class=para>
We said that a null string is false, but there are actually
two varieties of null scalars: defined and undefined.
Boolean context doesn't distinguish between defined and undefined
scalars.  Undefined null scalars are returned when there is no real
value for something, such as when there was an error, or at end of
file, or when you refer to an uninitialized variable or element of an
array.  An undefined null scalar may become defined the first time you
use it as if it were defined, but prior to that you can use the
<a href="ch03_02.htm">defined</A> operator to determine whether the value is defined or not.
(The return value of <a href="ch03_02.htm">defined</A> is always defined, but not always true.)

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.3.3">Void context</A></h4>

<p class=para>
Another peculiar kind of scalar context is the <i class=emphasis>void</I> context.  This
context not only doesn't care what the return value is, it doesn't even
<i class=emphasis>want</I> a return value.  From the standpoint of how functions work, it's
no different from an ordinary scalar context.  But if you use the <b>-w</B>
command-line switch, the Perl compiler will warn you if you use an
expression with no side effects in a place that doesn't want a value,
such as in a statement that doesn't return a value.  For example, if you
use a string as a statement:

<p class=para>
<div class=programlisting>
<p>
<pre>
"Camel Lot";
</PRE>
</DIV>

<p class=para>
you may get a warning like this:

<p class=para>
<div class=programlisting>
<p>
<pre>
Useless use of a constant in void context in myprog line 123;
</PRE>
</DIV>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.3.4">Interpolative context</A></h4>

<p class=para>
We mentioned that double-quoted literal strings do backslash
interpretation and variable interpolation, but the interpolative context
(often called "double-quote context") applies to more than just
double-quoted strings.  Some other double-quotish constructs are the
generalized backtick operator <tt class=literal>qx//</tt>, the pattern match operator
<tt class=literal>m//</tt>, and the substitution operator <tt class=literal>s///</tt>.  In fact, the
substitution operator does interpolation on its left side before doing a
pattern match, and then does interpolation on its right side each time
the left side matches.

<p class=para>
The interpolative context only happens inside quotes, or things that
work like quotes, so perhaps it's not fair to call it a context in
the same sense as scalar and list context.  (Then again, maybe it is.)

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-3.4">List Values and Arrays</A></h3>

<p class=para>
<a name="CH02.LISTS"></A><a name="CH02.LVAL"></A><a name="CH02.ARRAY"></A>Now that we've talked about context, we can talk about list values, and
how they behave in context.
List values are denoted by separating individual values by commas
(and enclosing the list in parentheses where precedence requires it):

<p class=para>
<div class=programlisting>
<p>
<pre>
(<tt class=replaceable><i>LIST</i></tt>)
</PRE>
</DIV>

<p class=para>
In a list context, the value of the list literal is all the values of
the list in order.  In a scalar context, the value of a list literal is
the value of the final element, as with the C comma operator, which
always throws away the value on the left and returns the value on the
right.  (In terms of what we discussed earlier, the left side of the
comma operator provides a void context.)  For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
@stuff = ("one", "two", "three");
</PRE>
</DIV>

<p class=para>
assigns the entire list value to array <tt class=literal>@stuff</tt>, but:

<p class=para>
<div class=programlisting>
<p>
<pre>
$stuff = ("one", "two", "three");
</PRE>
</DIV>

<p class=para>
assigns only the value <tt class=literal>three</tt> to variable <tt class=literal>$stuff</tt>.  The comma operator
knows whether it is in a scalar or a list context.  An actual
array variable also knows its context.  In a list context, it
would return its entire contents, but in a scalar context it returns only
the length of the array (which works out nicely if you mention the
array in a conditional).  The following assigns to <tt class=literal>$stuff</tt> the value 3:

<p class=para>
<div class=programlisting>
<p>
<pre>
@stuff = ("one", "two", "three");
$stuff = @stuff;      # $stuff gets 3, not "three"
</PRE>
</DIV>

<p class=para>
Until now we've pretended that <tt class=replaceable><i>LIST</i></tt>&nbsp;s are just lists of literals.
But in fact, any expressions that return values may be used within
lists.  The values so used may either be scalar values or list values.
<tt class=replaceable><i>LIST</i></tt>&nbsp;s do automatic interpolation of sublists.
That is, when a <tt class=replaceable><i>LIST</i></tt> is
evaluated, each element of the list is evaluated in a list context, and
the resulting list value is interpolated into <tt class=replaceable><i>LIST</i></tt> just as if each
individual element were a member of <tt class=replaceable><i>LIST</i></tt>.  Thus arrays lose their
identity in a <tt class=replaceable><i>LIST</i></tt>.  The list:

<p class=para>
<div class=programlisting>
<p>
<pre>
(@foo,@bar,&amp;SomeSub)
</PRE>
</DIV>

<p class=para>
contains all the elements of <tt class=literal>@foo</tt>, followed by all the elements of
<tt class=literal>@bar</tt>, followed by all the elements returned by the subroutine named
<tt class=literal>SomeSub</tt> when it's called in a list context.  You can use a reference
to an array if you do not want it to interpolate.  See <a href="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A>, yet again.

<p class=para>
The null list is represented by <tt class=literal>()</tt>.  Interpolating it in a list has
no effect.  Thus, <tt class=literal>((),(),())</tt> is equivalent to <tt class=literal>()</tt>.  Similarly, interpolating
an array with no elements is the same as if no array had been interpolated
at that point.

<p class=para>
You may place an optional comma at the end of any list value.
This makes it easy to come back later and add more elements.

<p class=para>
<div class=programlisting>
<p>
<pre>
@numbers = (
    1,
    2,
    3,
);
</PRE>
</DIV>

<p class=para>
Another way to specify a literal list is with the <b>qw</B> (quote words)
syntax we mentioned earlier.  This construct is equivalent to splitting
a single-quoted string on whitespace.  For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
@foo = qw(
    apple       banana      carambola
    coconut     guava       kumquat
    mandarin    nectarine   peach
    pear        persimmon   plum
);
</PRE>
</DIV>

<p class=para>
(Note that those parentheses are behaving as quote characters, not
ordinary parentheses.  We could just as easily have picked angle
brackets or braces or slashes.)

<p class=para>
A list value may also be subscripted like a normal array.  You must put the
list in parentheses (real ones) to avoid ambiguity.  Examples:

<p class=para>
<div class=programlisting>
<p>
<pre>
# Stat returns list value.
$modification_time = (stat($file))[8];
# SYNTAX ERROR HERE.
$modification_time = stat($file)[8];  # OOPS, FORGOT PARENS
# Find a hex digit.
$hexdigit = ('a','b','c','d','e','f')[$digit-10];
# A "reverse comma operator".
return (pop(@foo),pop(@foo))[0];
</PRE>
</DIV>

<p class=para>
Lists may be assigned to if and only if each element of the list
is legal to assign to:

<p class=para>
<div class=programlisting>
<p>
<pre>
($a, $b, $c) = (1, 2, 3);
($map{red}, $map{green}, $map{blue}) = (0x00f, 0x0f0, 0xf00);
</PRE>
</DIV>

<p class=para>
List assignment in a scalar context returns the number of elements
produced by the expression on the right side of the assignment:

<div class=programlisting>
<p>
<pre>
$x = ( ($foo,$bar) = (7,7,7) );       # set $x to 3, not 2
$x = ( ($foo,$bar) = f() );           # set $x to f()'s return count
</PRE>
</DIV>

<p class=para>
This is handy when you want to do a list assignment in a Boolean
context, since most list functions return a null list when finished, which
when assigned produces a 0, which is interpreted as false. The final list element may be an array or a hash:

<div class=programlisting>
<p>
<pre>
($a, $b, @rest) = split;
my ($a, $b, %rest) = @arg_list;
</PRE>
</DIV>

<p class=para>
You can actually put an array or hash anywhere in the list you assign
to, but the first one in the list will soak up all the values, and
anything after it will get an undefined value.  This may be useful in a
<a href="ch03_02.htm">local</A> or <a href="ch03_02.htm">my</A>, where you probably want the arrays initialized
to be empty anyway.

<p class=para>
You may find the number of elements in the array <tt class=literal>@days</tt> by 
evaluating <tt class=literal>@days</tt> in a scalar context, such as:

<div class=programlisting>
<p>
<pre>
@days + 0;      # implicitly force @days into a scalar context
scalar(@days)   # explicitly force @days into a scalar context
</PRE>
</DIV>

<p class=para>
Note that this only works for arrays.  It does not work for list values
in general.  A comma-separated list evaluated in a scalar context will return the last
value, like the C comma operator.

<p class=para>
Closely related to the scalar evaluation of <tt class=literal>@days</tt> is <tt class=literal>$#days</tt>.
This will return the subscript of the last element of the array, or one
less than the length, since there is (ordinarily) a 0th element.[18]
Assigning to <tt class=literal>$#days</tt> changes the length of the array.  Shortening an
array by this method destroys intervening values.  You can gain some
measure of efficiency by pre-extending an array that is going to get big.
(You can also extend an array by assigning to an element that is off the
end of the array.) You can truncate an array down to nothing by assigning
the null list <tt class=literal>()</tt> to it.[19]
The following two statements are equivalent:

<blockquote class=footnote>
<p class=para>[18] 
For historical reasons, the special variable <b>$[</B> can be used to change
the array base.  Its use is not recommended, however.  In fact, this is
the last we'll even mention it.  Just don't use it.

<p class=para>[19] 
In the current version of Perl, re-extending a truncated array does
not recover the values in the array.  (It did in earlier versions.)
</blockquote>
<div class=programlisting>
<p>
<pre>
@whatever = ();
$#whatever = -1;
</PRE>
</DIV>

<p class=para>
And the following is always true:[20]

<blockquote class=footnote>
<p class=para>[20] 
Unless you've diddled the deprecated <b>$[</B>
variable. Er, <i class=emphasis>this</I> is the last time we'll mention
it . . .
</blockquote>
<div class=programlisting>
<p>
<pre>
scalar(@whatever) == $#whatever + 1;
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-3.5">Hashes (Associative Arrays)</A></h3>

<p class=para>
As we indicated previously, a hash is just a funny kind of array in which
you look values up using key strings instead of numbers.  It defines
associations between keys and values, so hashes are often called
associative arrays.

<p class=para>
There really isn't any such thing as a hash literal in Perl, but
if you assign an ordinary list to a hash, each pair of values in the
list will be taken to indicate one key/value association:

<p class=para>
<div class=programlisting>
<p>
<pre>
%map = ('red',0x00f,'green',0x0f0,'blue',0xf00);
</PRE>
</DIV>

<p class=para>
This has the same effect as:

<p class=para>
<div class=programlisting>
<p>
<pre>
%map = ();            # clear the hash first
$map{red}   = 0x00f;
$map{green} = 0x0f0;
$map{blue}  = 0xf00;
</PRE>
</DIV>

<p class=para>
It is often more readable to use the <tt class=literal>=&gt;</tt> operator between key/value
pairs.  The <tt class=literal>=&gt;</tt> operator is just a synonym for a comma, but it's
more visually distinctive, and it also quotes any bare identifiers to
the left of it (just like the identifiers in braces above), which makes
it nice for initializing hash variables:

<p class=para>
<div class=programlisting>
<p>
<pre>
%map = (
    red   =&gt; 0x00f,
    green =&gt; 0x0f0,
    blue  =&gt; 0xf00,
);
</PRE>
</DIV>

<p class=para>
or for initializing anonymous hash references to be used as records:

<p class=para>
<div class=programlisting>
<p>
<pre>
$rec = {
    witch =&gt; 'Mable the Merciless',
    cat   =&gt; 'Fluffy the Ferocious',
    date  =&gt; '10/31/1776',
};
</PRE>
</DIV>

<p class=para>
or for using call-by-named-parameter to invoke complicated functions:

<p class=para>
<div class=programlisting>
<p>
<pre>
$field = $query-&gt;radio_group( 
                    NAME      =&gt; 'group_name',
                    VALUES    =&gt; ['eenie','meenie','minie'],
                    DEFAULT   =&gt; 'meenie',
                    LINEBREAK =&gt; 'true',
                    LABELS    =&gt; \%labels,
                );
</PRE>
</DIV>

<p class=para>
But we're getting ahead of ourselves.  Back to hashes.

<p class=para>
You can use a hash variable (<tt class=literal>%hash</tt>) in a list context, in which case it
interpolates all the key/value pairs into the list.  But just because
the hash was initialized in a particular order doesn't mean that the
values come back in that order.  Hashes are implemented internally using
hash tables for speedy lookup, which means that the order in which
entries are stored is dependent on the nature of the hash function used
to calculate positions in the hash table, and not on anything
interesting.  So the entries come back in a seemingly random order.
(The two elements of each key/value pair come out in the right order, of
course.)  
For examples of how to arrange for an output ordering, see the 
<b>keys</B> 
entry in <a href="ch03_01.htm">Chapter 3, <i>Functions</i></A>, or <tt class=literal>DB_BTREE</tt>
description in the DB_File documentation in <a href="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.

<p class=para>
If you evaluate a hash variable in a scalar context, it returns a value
that is true if and only if the hash contains any key/value pairs.  (If
there are any key/value pairs, the value returned is a string consisting
of the number of used buckets and the number of allocated buckets,
separated by a slash.  This is pretty much only useful to find out
whether Perl's (compiled in) hashing algorithm is performing poorly on
your data set.  For example, you stick 10,000 things in a hash, but
evaluating <tt class=literal>%HASH</tt> in scalar context reveals "<tt class=literal>1/8</tt>", which means only
one out of eight buckets has been touched, and presumably that one
bucket contains all 10,000 of your items.  This isn't supposed to
happen.)

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-3.6">Typeglobs and Filehandles</A></h3>

<p class=para>
Perl uses an internal type called a <i class=emphasis>typeglob</I> to hold an entire
symbol table entry.  The type prefix of a typeglob is a <tt class=literal>*</tt>, because
it represents all types.  This used to be the preferred way to 
pass arrays and hashes by reference into a function, but now that
we have real references, this mechanism is seldom needed.

<p class=para>
Typeglobs (or references thereto) are still used
for passing or storing filehandles.  If you want to save away
a filehandle, do it this way:

<p class=para>
<div class=programlisting>
<p>
<pre>
$fh = *STDOUT;
</PRE>
</DIV>

<p class=para>
or perhaps as a real reference, like this:

<p class=para>
<div class=programlisting>
<p>
<pre>
$fh = \*STDOUT;
</PRE>
</DIV>

<p class=para>
This is also the way to create a local filehandle.  For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
sub newopen {
    my $path = shift;
    local *FH;  # not my!
    open (FH, $path) || return undef;
    return *FH;
}
$fh = newopen('/etc/passwd');
</PRE>
</DIV>

<p class=para>
See the <a href="ch03_02.htm">open</A> entry in <a href="ch03_01.htm">Chapter 3, <i>Functions</i></A> and
the FileHandle module in <a href="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>, for how to
generate new filehandles.

<p class=para>
But the main use of typeglobs nowadays is to alias one symbol table
entry to another symbol table entry.  If you say:

<p class=para>
<div class=programlisting>
<p>
<pre>
*foo = *bar;
</PRE>
</DIV>

<p class=para>
it makes everything named "<tt class=literal>foo</tt>" a synonym for every corresponding
thing named "<tt class=literal>bar</tt>".  You can alias just one of the variables in a
typeglob by assigning a reference instead:

<p class=para>
<div class=programlisting>
<p>
<pre>
*foo = \$bar;
</PRE>
</DIV>

<p class=para>
makes <tt class=literal>$foo</tt> an alias for <tt class=literal>$bar</tt>,
but doesn't make <tt class=literal>@foo</tt> an alias for
<tt class=literal>@bar</tt>, or <tt class=literal>%foo</tt> an alias for
<tt class=literal>%bar</tt>.  Aliasing variables like this may seem like a
silly thing to want to do, but it turns out that the entire module
export/import mechanism is built around this feature, since there's
nothing that says the symbol you're aliasing has to be in your
namespace.  See <a href="ch04_01.htm">Chapter 4, <i>References and Nested Data Structures</i></A> and <a href="ch05_01.htm">Chapter 5, <i>Packages, Modules, and Object Classes</i></A> for more discussion on typeglobs.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="PERL2-CH-2-SECT-3.7">Input Operators</A></h3>

<p class=para>
<a name="CH02.IO"></A>There are several input operators we'll discuss here because they parse
as terms.  In fact, sometimes we call them pseudo-literals because they
act like quoted strings in many ways.  (Output operators like <a href="ch03_02.htm">print</A>
parse as list operators and are discussed in <a href="ch03_01.htm">Chapter 3, <i>Functions</i></A>.)

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.7.1">Command input (backtick) operator</A></h4>

<p class=para>
First of all, we have the command input operator, also known as the
backticks operator, because it looks like this:

<p class=para>
<div class=programlisting>
<p>
<pre>
$info = `finger $user`;
</PRE>
</DIV>

<p class=para>
A string enclosed by backticks (grave accents) first undergoes
variable interpolation just like a double-quoted string.  The result of
that is then interpreted as a command by the shell, and the output of
that command becomes the value of the pseudo-literal.  (This is modeled
after a similar operator in some of the UNIX shells.)  In scalar
context, a single string consisting of all the output is returned.  In
list context, a list of values is returned, one for each line of output.
(You can set <b>$/</B> to use a different line terminator.)

<p class=para>
The command is executed each time the pseudo-literal is evaluated.
The numeric status value of the command is saved in <b>$?</B> (see the section
"Special Variables" later in this chapter for the interpretation of <b>$?</B>).  Unlike the <i class=emphasis>csh</I> version
of this command, no translation is done on the return
data--newlines remain newlines.  Unlike any of the shells, single
quotes do not hide variable names in the command from interpretation.
To pass a <tt class=literal>$</tt> through to the shell you need to hide
it with a backslash.  The <tt class=literal>$user</tt> in our example
above is interpolated by Perl, not by the shell.  (Because the command
undergoes shell processing, see <a href="ch06_01.htm">Chapter 6, <i>Social Engineering</i></A>, for
security concerns.)

<p class=para>
The generalized form of backticks is <tt class=literal>qx//</tt> (for "quoted execution"), but
the operator works exactly the same way as ordinary backticks.  You just
get to pick your quote characters.

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.7.2">Line input (angle) operator</A></h4>

<p class=para>
<a name="CH02.AB1"></A><a name="CH02.AB2"></A><a name="CH02.AO"></A>The most heavily used input operator is the line input operator, also
known as the angle operator.
Evaluating a filehandle in angle brackets (<tt class=literal>&lt;STDIN&gt;</tt>, for example)
yields the next line from the associated
file.  (The newline is included, so according to Perl's criteria for
truth, a freshly input line is always true, up until end of file, at
which point an undefined value is returned, which is false.)  Ordinarily
you would assign the input value to a variable, but there is one situation
where an automatic assignment happens.  If and only if the line input
operator is the only thing inside the conditional of a <b>while</B> loop, the
value is automatically assigned to the special variable <b>$_</B>.  The assigned
value is
then tested to see whether it is defined.  (This may seem like an odd thing to
you, but you'll use the construct in almost every Perl script you write.)
Anyway, the following lines are equivalent to each other:

<p class=para>
<div class=programlisting>
<p>
<pre>
while (defined($_ = &lt;STDIN&gt;)) { print $_; }   # the long way
while (&lt;STDIN&gt;) { print; }                    # the short way
for (;&lt;STDIN&gt;;) { print; }                    # while loop in disguise
print $_ while defined($_ = &lt;STDIN&gt;);         # long statement modifier
print while &lt;STDIN&gt;;                          # short statement modifier
</PRE>
</DIV>

<p class=para>
Remember that this special magic requires a <b>while</B> loop.  If you use
the input operator anywhere else, you must assign the result explicitly
if you want to keep the value:

<p class=para>
<div class=programlisting>
<p>
<pre>
if (&lt;STDIN&gt;)      { print; }   # WRONG, prints old value of $_
if ($_ = &lt;STDIN&gt;) { print; }   # okay
</PRE>
</DIV>

<p class=para>
The filehandles <tt class=literal>STDIN</tt>, <tt class=literal>STDOUT</tt>, and <tt class=literal>STDERR</tt>
are predefined and pre-opened.[21]
Additional filehandles may be created with the <a href="ch03_02.htm">open</A> function.  See
the <a href="ch03_02.htm">open</A> entry in <a href="ch03_01.htm">Chapter 3, <i>Functions</i></A> for details on this.  Some
object modules also create object references that can be used as filehandles.
See the FileHandle module in <a href="ch07_01.htm">Chapter 7, <i>The Standard Perl Library</i></A>.

<blockquote class=footnote>
<p class=para>[21] 
The filehandles <tt class=literal>stdin</tt>, <tt class=literal>stdout</tt>, and <tt class=literal>stderr</tt>
will also work except in packages, where they would be interpreted as
local identifiers rather than global.  They're only there for
compatibility with very old scripts, so use the uppercase versions.
</blockquote>
<p class=para>
In the <b>while</B> loops above, we were evaluating the line input operator in
a scalar context, so it returned each line separately.  However,
if you use it in a list context, a
list consisting of all the remaining input lines is returned, one line
per list element.  It's easy to make a <i class=emphasis>large</I> data space this way, so
use this feature with care:

<p class=para>
<div class=programlisting>
<p>
<pre>
$one_line = &lt;MYFILE&gt;;   # Get first line.
@all_lines = &lt;MYFILE&gt;;  # Get the rest of the lines.
</PRE>
</DIV>

<p class=para>
There is no <b>while</B> magic associated with the list form of the input
operator, because the condition of a <b>while</B> loop is always a scalar
context (as is any conditional).

<p class=para>
Using the null filehandle within the angle operator is special and can be used to
emulate the command-line behavior of typical UNIX filter programs such as
<i class=emphasis>sed</I> and <i class=emphasis>awk</I>.  When you read
lines from <tt class=literal>&lt;&gt;</tt>, it magically gives you all the
lines from all the files mentioned on the command line.  If no files
were mentioned, it gives you standard input instead, so your program
is easy to insert into the middle of a pipeline of processes.

<p class=para>
Here's how it works: the first time <tt class=literal>&lt;&gt;</tt> is
evaluated, the <b>@ARGV</B> array is checked,
and if it is null, <tt class=literal>$ARGV[0]</tt> is set to "<tt class=literal>-</tt>", which
when opened gives you standard input.  The <b>@ARGV</B> array is then processed as a list of
filenames.  The loop:

<p class=para>
<div class=programlisting>
<p>
<pre>
while (&lt;&gt;) {
    ...                     # code for each line
}
</PRE>
</DIV>

<p class=para>
is equivalent to the following Perl-like pseudocode:

<p class=para>
<div class=programlisting>
<p>
<pre>
@ARGV = ('-') unless @ARGV;
while ($ARGV = shift) {
    open(ARGV, $ARGV) or warn "Can't open $ARGV: $!\n";
    while (&lt;ARGV&gt;) {
        ...         # code for each line
    }
}
</PRE>
</DIV>

<p class=para>
except that it isn't so cumbersome to say, and will actually work.  It
really does shift array <b>@ARGV</B> and put
the current filename into variable <tt class=literal>$ARGV</tt>.  It also
uses filehandle <b>ARGV</B>
internally--<tt class=literal>&lt;&gt;</tt> is just a synonym for
<tt class=literal>&lt;ARGV&gt;</tt>, which is magical.  (The pseudocode
above doesn't work because it treats <tt class=literal>&lt;ARGV&gt;</tt>
as non-magical.)

<p class=para>
You can modify <b>@ARGV</B> before the first
<tt class=literal>&lt;&gt;</tt> as long as the array ends up containing
the list of filenames you really want.  Line numbers (<b>$.</B>) continue as if the input were one big happy
file.  (But see the example under <a href="ch03_02.htm">eof</A> for
how to reset line numbers on each file.)

<p class=para>
If you want to set <b>@ARGV</B> to your own list of files, go right ahead.
If you want to pass switches into your script, you can use one of the
Getopts modules or put a loop on the front like this:

<p class=para>
<div class=programlisting>
<p>
<pre>
while ($_ = $ARGV[0], /^-/) {
    shift;
    last if /^--$/;
    if (/^-D(.*)/) { $debug = $1 }
    if (/^-v/)     { $verbose++  }
    ...             # other switches
}
while (&lt;&gt;) {
    ...             # code for each line
}
</PRE>
</DIV>

<p class=para>
The <tt class=literal>&lt;&gt;</tt> symbol will return false only once.  If you call it again after
this it will assume you are processing another <b>@ARGV</B> list, and if you
haven't set <b>@ARGV</B>, it will input from <tt class=literal>STDIN</tt>.

<p class=para>
If the string inside the angle brackets is a scalar
variable (for example, <tt class=literal>&lt;$foo&gt;</tt>),
then that variable contains the name of the
filehandle to input from, or a reference to the same.  For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
$fh = \*STDIN;
$line = &lt;$fh&gt;;
</PRE>
</DIV>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="PERL2-CH-2-SECT-3.7.3">Filename globbing operator</A></h4>

<p class=para>
<a name="CH02.GF"></A><a name="CH02.GO"></A><a name="CH02.ABG1"></A><a name="CH02.ABG2"></A>You might wonder what happens to a line input operator if you put something
fancier inside the angle brackets.  What happens is that it mutates into
a different operator.
If the string inside the angle brackets is anything other than a
filehandle name or a scalar variable (even if there are just extra spaces),
it is interpreted as a filename pattern to be "globbed".[22]
The pattern is matched against the files in the current directory (or
the directory specified as part of the glob pattern), and the filenames
so matched are returned by the operator.  As with line input, the
names are returned one at a time in scalar context, or all at once
in list context.  In fact, the latter usage is more prevalent.  You
generally see things like:

<blockquote class=footnote>
<p class=para>[22] 
This has nothing to do with the previously mentioned typeglobs, other than
that they both use the <tt class=literal>*</tt> character in a wildcard fashion.  The
<tt class=literal>*</tt> character has the nickname "glob" when used like this.  With typeglobs
you're globbing symbols with the same name from the symbol table.  With
a filename glob, you're doing wildcard matching on the filenames in
a directory, just as the various shells do.
</blockquote>
<p class=para>
<div class=programlisting>
<p>
<pre>
my @files = &lt;*.html&gt;;
</PRE>
</DIV>

<p class=para>
As with other kinds of pseudo-literals, one level of variable
interpolation is done first, but you can't say <tt class=literal>&lt;$foo&gt;</tt> because
that's an indirect filehandle as explained earlier.
(In older version of Perl, programmers would insert braces to
force interpretation as a filename glob: <tt class=literal>&lt;${foo}&gt;</tt>.  These days,
it's considered cleaner to call the internal function directly as
<tt class=literal>glob($foo)</tt>, which is probably the right way to have invented it in the
first place.)

<p class=para>
Whether you use the <a href="ch03_02.htm">glob</A> function or
the old angle-bracket form, the globbing operator also does <b>while</B> magic like the line input operator, and
assigns the result to <b>$_</B>.  For example:

<p class=para>
<div class=programlisting>
<p>
<pre>
while (&lt;*.c&gt;) {
    chmod 0644, $_;
}
</PRE>
</DIV>

<p class=para>
is equivalent to:

<p class=para>
<div class=programlisting>
<p>
<pre>
open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");
while (&lt;FOO&gt;) {
    chop;
    chmod 0644, $_;
}
</PRE>
</DIV>

<p class=para>
In fact, it's currently implemented that way, more or less.  (Which
means it will not work on filenames with spaces in them unless you have
<i class=emphasis>csh</I> (1) on your machine.)  Of course, the shortest way to do the
above is:

<p class=para>
<div class=programlisting>
<p>
<pre>
chmod 0644, &lt;*.c&gt;;
</PRE>
</DIV>

<p class=para>
Because globbing invokes a subshell, it's often faster to call
<a href="ch03_02.htm">readdir</A> yourself and just do your own
<a href="ch03_02.htm">grep</A> on the filenames.  Furthermore,
due to its current implementation of using a shell, the <a href="ch03_02.htm">glob</A> routine may get "<tt class=literal>Arg list too long</tt>" errors
(unless you've installed <i class=emphasis>tcsh</I> (1) as
<i class=emphasis>/bin/csh</I>).

<p class=para>
A glob evaluates its (embedded) argument only when it is starting a new
list.  All values must be read before it will start over.  In a list
context this isn't important, because you automatically get them all
anyway.  In a scalar context, however, the operator returns the next value
each time it is called, or a false value if you've just run out.  Again,
false is returned only once.  So if you're expecting a single value from
a glob, it is much better to say:

<p class=para>
<div class=programlisting>
<p>
<pre>
($file) = &lt;blurch*&gt;;  # list context
</PRE>
</DIV>

<p class=para>
than to say:

<p class=para>
<div class=programlisting>
<p>
<pre>
$file = &lt;blurch*&gt;;    # scalar context
</PRE>
</DIV>

<p class=para>
because the former slurps all the matched filenames and resets the
operator, while the latter will alternate between returning a filename
and returning false.

<p class=para>
It you're trying to do variable interpolation, it's definitely better
to use the <a href="ch03_02.htm">glob</A> operator, because the
older notation can cause people to become confused with the indirect
filehandle notation.  But with things like this, it begins to become
apparent that the borderline between terms and operators is a bit
mushy:

<p class=para>
<div class=programlisting>
<p>
<pre>
@files = glob("$dir/*.[ch]");   # call glob as function
@files = glob $some_pattern;    # call glob as operator
</PRE>
</DIV>

<p class=para>
We left the parentheses off of the second example to illustrate that
<a href="ch03_02.htm">glob</A> can be used as a
<i class=emphasis>unary</I> operator; that is, a prefix operator that
takes a single argument.  The <a href="ch03_02.htm">glob</A>
operator is an example of a <i class=emphasis>named unary operator</I>,
which is just one of the kinds of operators we'll talk about in the
section "Operators" later in this chapter.  But first we're going to talk about pattern
matching operations, which also parse like terms but operate like
operators.

</DIV>

</DIV>

</DIV>


<div class=htmlnav>
<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch02_02.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch02_04.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Built-in Data Types</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Pattern Matching</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>
</BODY>
</HTML>
