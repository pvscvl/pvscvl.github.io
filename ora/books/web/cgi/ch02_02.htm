<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 2] 2.2 Using Environment Variables</TITLE>
<meta name="author" content="Shishir Gundavaram">
<meta name="date" content="Mon Mar 17 13:20:59 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="cgi programming">
<meta name="title" content="CGI Programming on the World Wide Web">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="CGI Programming on the World Wide Web"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch02_01.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 2</b></td>
<td width=172 align=right valign=top><a href="ch02_03.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="CGI-CHP-2-SECT-2">2.2 Using Environment Variables</A></h2>

<p class=para>
Much
of the most crucial information needed by CGI applications is made
available via UNIX environment variables. Programs
can access this information as they would any environment variable
(e.g., via the <i class=emphasis>%ENV</I> associative array in Perl).

<p class=para>
This section concentrates on showing examples of some of the more
typical uses of environment variables in CGI programs. First, however,
<a href="#CGI-CHP-2-TBL-1">Table 2.1</A> shows a full list of environment
variables available for CGI.

<p>
<div class=table>
<table>
<caption><a class="TITLE" name="CGI-CHP-2-TBL-1">Table 2-1: List of CGI Environment Variables</A></CAPTION>
<tr class=row>
<th align="left">

<p class=para>
Environment Variable</TH>
<th align="left">

<p class=para>
Description</TH>
</TR>
<tr class=row>
<td align="left">

<p class=para>
GATEWAY_INTERFACE</TD>
<td align="left">

<p class=para>
The revision of the Common Gateway Interface
that the server uses.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
SERVER_NAME</TD>
<td align="left">

<p class=para>
The server's hostname or IP address.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
SERVER_SOFTWARE</TD>
<td align="left">

<p class=para>
The name and version of the server software
that is answering the client request.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
SERVER_PROTOCOL</TD>
<td align="left">

<p class=para>
The name and revision of the information
protocol the request came in with.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
SERVER_PORT</TD>
<td align="left">

<p class=para>
The port number of the host on which
the server is running.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
REQUEST_METHOD</TD>
<td align="left">

<p class=para>
The method with which the information
request was issued.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
PATH_INFO</TD>
<td align="left">

<p class=para>
Extra path information passed to a CGI
program.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
PATH_TRANSLATED</TD>
<td align="left">

<p class=para>
The translated version of the path given
by the variable PATH_INFO.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
SCRIPT_NAME</TD>
<td align="left">

<p class=para>
The virtual path (e.g., <i class=emphasis>/cgi-bin/program.pl</I>)
of the script being executed.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
DOCUMENT_ROOT</TD>
<td align="left">

<p class=para>
The directory from which Web documents
are served.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
QUERY_STRING</TD>
<td align="left">

<p class=para>
The query information passed to the program.
It is appended to the URL with a "?".</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
REMOTE_HOST</TD>
<td align="left">

<p class=para>
The remote hostname of the user making
the request.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
REMOTE_ADDR</TD>
<td align="left">

<p class=para>
The remote IP address of the user making
the request.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
AUTH_TYPE</TD>
<td align="left">

<p class=para>
The authentication method used to validate
a user.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
REMOTE_USER</TD>
<td align="left">

<p class=para>
The authenticated name of the user.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
REMOTE_IDENT</TD>
<td align="left">

<p class=para>
The user making the request. This variable
will only be set if NCSA <i class=emphasis>IdentityCheck</I> flag
is enabled, and the client machine supports the RFC 931 identification
scheme (ident daemon).</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
CONTENT_TYPE</TD>
<td align="left">

<p class=para>
The MIME type of the query data, such
as "text/html".</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
CONTENT_LENGTH</TD>
<td align="left">

<p class=para>
The length of the data (in bytes or the
number of characters) passed to the CGI program through standard
input.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
HTTP_FROM</TD>
<td align="left">

<p class=para>
The email address of the user making
the request. Most browsers do not support this variable.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
HTTP_ACCEPT</TD>
<td align="left">

<p class=para>
A list of the MIME types that the client
can accept.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
HTTP_USER_AGENT</TD>
<td align="left">

<p class=para>
The browser the client is using to issue
the request.</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
HTTP_REFERER</TD>
<td align="left">

<p class=para>
The URL of the document that the client
points to before accessing the CGI program.</TD>
</TR>
</TABLE>
<p>
</DIV>
<p class=para>
We'll use examples to demonstrate how these variables are
typically used within a CGI program.

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-2-SECT-2.1">About This Server</A></h3>

<p class=para>
Let's
start with a simple program that displays various information about
the server, such as the CGI and HTTP revisions
used and the name of the server software.

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl
print "Content-type: text/html", "\n\n";
print "&lt;HTML&gt;", "\n";
print "&lt;HEAD&gt;&lt;TITLE&gt;About this Server&lt;/TITLE&gt;&lt;/HEAD&gt;", "\n";
print "&lt;BODY&gt;&lt;H1&gt;About this Server&lt;/H1&gt;", "\n";
print "&lt;HR&gt;&lt;PRE&gt;";
print "Server Name:      ", $ENV{'SERVER_NAME'}, "&lt;BR&gt;", "\n";
print "Running on Port:  ", $ENV{'SERVER_PORT'}, "&lt;BR&gt;", "\n";
print "Server Software:  ", $ENV{'SERVER_SOFTWARE'}, "&lt;BR&gt;", "\n";
print "Server Protocol:  ", $ENV{'SERVER_PROTOCOL'}, "&lt;BR&gt;", "\n";
print "CGI Revision:     ", $ENV{'GATEWAY_INTERFACE'}, "&lt;BR&gt;", "\n";
print "&lt;HR&gt;&lt;/PRE&gt;", "\n";
print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";
exit (0);
</PRE>
</DIV>

<p class=para>
Let's go through this program step by step. The first line
is very important. It instructs the server to use the Perl interpreter
located in the <i class=emphasis>/usr/local/bin</I> directory to
execute the CGI program. Without this line, the server won't know
how to run the program, and will display an error stating that it
cannot execute the program.

<p class=para>
Once the CGI script is running, the first thing it needs to
generate is a valid HTTP header, ending with
a blank line. The header generally contains a content type, also
known as a MIME type. In this case, the content
type of the data that follows is <i class=command>text/html</i>.

<p class=para>
After
the MIME content type is output, we can go ahead
and display output in HTML. We send the information
directly to standard output, which is read and processed by the
server, and then sent to the client for display. Five environment
variables are output, consisting of the server name (the IP name
or address of the machine where the server is running), the port
the server is running on, the server software, and the HTTP
and CGI revisions. In Perl, you can access the environment variables
through the <i class=emphasis>%ENV</I> associative array, keyed by
name.

<p class=para>
A typical output of this program might look like this:

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;About this Server&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;&lt;H1&gt;About this Server&lt;/H1&gt;
&lt;HR&gt;&lt;PRE&gt;
Server Name:      bu.edu
Running on Port:  80
Server Software:  NCSA/1.4.2
Server Protocol:  HTTP/1.0
CGI Revision:     CGI/1.1
&lt;HR&gt;&lt;/PRE&gt;
&lt;/BODY&gt;&lt;/HTML&gt;
</PRE>
</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-2-SECT-2.2">Check the Client Browser</A></h3>

<p class=para>
Now,
let's look at a slightly more complicated example. One of the more
useful items that the server passes to the CGI program is the client
(or browser) name. We can put this information to good use by checking
the browser type, and then displaying either a text or graphic document.

<p class=para>
Different
Web browsers support different HTML tags and
different types of information. If your CGI program generates an
inline image, you need to be sensitive that some browsers support

&lt;IMG&gt; extensions
that others don't, some browsers support JPEG
images as well as GIF images, and some browsers (notably, Lynx and
the old <i class=emphasis>www</I> client) don't support images at
all. Using the 
HTTP_USER_AGENT
environment variable, you can determine which browser is being used,
and with that information you can fine-tune your CGI program to
generate output that is optimized for that browser.

<p class=para>
Let's build a short program that delivers a different document
depending on whether the browser supports graphics. First, identify
the browsers that you know don't support graphics. Then get the
name of the browser from the HTTP_USER_AGENT
variable:

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl
$nongraphic_browsers = 'Lynx|CERN-LineMode';
$client_browser  = $ENV{'HTTP_USER_AGENT'};
</PRE>
</DIV>

<p class=para>
The variable <i class=emphasis>$nongraphic_browsers</I> contains
a list of the browsers that don't support graphics. Each browser
is separated by the "|" character, which represents alternation
in the regular expression we use later in the program. In this instance,
there are only two browsers listed, Lynx and <i class=emphasis>www</I>.
("CERN-LineMode" is the string the <i class=emphasis>www</I> browser
uses to identify itself.)

<p class=para>
The HTTP_USER_AGENT
environment variable contains the name of the browser. All environment
variables that start with HTTP represent information
that is sent by the client. The server adds the prefix and sends
this data with the other information to the CGI program.

<p class=para>
Now identify the files that you intend to return depending
on whether the browser supports graphics:

<div class=screen>
<p>
<pre>
$graphic_document = "full_graphics.html";
$text_document = "text_only.html";
</PRE>
</DIV>

<p class=para>
The variables <i class=emphasis>$graphic_document</I> and <i class=emphasis>$text_document</I>
contain the names of the two documents that we will use.

<p class=para>
The next thing to do is simply to check if the browser name
is included in the list of non-graphic browsers.

<div class=screen>
<p>
<pre>
if ($client_browser =~ /$nongraphic_browsers/) {
    $html_document = $text_document;
} else {
    $html_document = $graphic_document;
}
</PRE>
</DIV>

<p class=para>
The conditional checks whether the client browser is one that
we know does not support graphics. If it is, the variable <i class=emphasis>$html_document</I>
will contain the name of the text-only version of the HTML
file. Otherwise, it will contain the name of the version of the
HTML document that contains graphics.

<p class=para>
Finally, print the partial header and open the file. (We need
to get the document root from the 
DOCUMENT_ROOT
variable and prepend it to the filename, so the Perl program can
locate the document in the file system.)

<div class=screen>
<p>
<pre>
print "Content-type: text/html", "\n\n";
$document_root = $ENV{'DOCUMENT_ROOT'};
$html_document = join ("/", $document_root, $html_document);    
if (open (HTML, "&lt;" . $html_document)) {
    while (&lt;HTML&gt;) {
	       print;
	}
    close (HTML);
} else {
    print "Oops! There is a problem with the configuration on this system!", "\n";
    print "Please inform the Webmaster of the problem. Thanks!", "\n";
}
exit (0);
</PRE>
</DIV>

<p class=para>
If the filename stored in <i class=emphasis>$html_document</I>
can be opened for reading (as specified by the "&lt;" character),
the <i class=emphasis>while</I> loop iterates through the file and
displays it. The <i class=emphasis>open</I> command creates a handle,
HTML, which is then used to access the file.
During the <i class=emphasis>while</I> loop, as Perl reads a line
from the HTML file handle, it places that line
in its default variable <i class=emphasis>$_</I>. The <i class=emphasis>print</I>
statement without any arguments displays the value stored in <i class=emphasis>$_</I>.
After the entire file is displayed, it is closed. If the file cannot
be opened, an error message is output.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-2-SECT-2.3">Restricting Access for Specified Domains</A></h3>

<p class=para>
Suppose you have a set of HTML
documents: one for users in your IP domain (e.g., bu.edu), and another
one for users outside of your domain. Why would anyone want to do
this, you may ask? Say you have a document containing internal company
phone numbers, meeting schedules, and other company information.
You certainly don't want everyone on the Internet to see this document.
So you need to set up some type of security to keep your documents
away from prying eyes.

<p class=para>
You can configure most servers to restrict access to your
documents according to what domain the user connects from. For example,
under the NCSA server, you can list the domains which you want to
allow or deny access to certain directories by editing the 
access.conf configuration file. However,
you can also control domain-based access in a CGI script. The advantage
of using a CGI script is that you don't have to turn away other
domains, just send them different documents. Let's look at a CGI
program that performs pseudo 
authentication:

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl
$host_address = 'bu\.edu';
$ip_address = '128\.197';
</PRE>
</DIV>

<p class=para>
These two variables hold the IP domain name and address that
are considered local. In other words, users in this domain can access
the internal information. The period is "escaped" in both of these
variables (by placing a "\" before the character), because the variables
will be interpolated in a regular expression later in this program.
The "." character has a special significance in a regular expression;
it is used to match any character other than a newline.

<div class=screen>
<p>
<pre>
$remote_address = $ENV{'REMOTE_ADDR'};
$remote_host = $ENV{'REMOTE_HOST'};
</PRE>
</DIV>

<p class=para>
The environment variable 
REMOTE_ADDR
returns the IP numerical address for the remote user, while REMOTE_HOST
contains the IP alphanumeric name for the remote user. There are
times when REMOTE_HOST will not return the name,
but only the address (if the DNS server does not have an entry for
the domain). In such a case, you can use the following snippet of
code to convert an IP address to its corresponding name:

<div class=screen>
<p>
<pre>
@subnet_numbers = split (/\./, $remote_address);
$packed_address = pack ("C4", @subnet_numbers);
($remote_host)  = gethostbyaddr ($packed_address, 2);
</PRE>
</DIV>

<p class=para>
Don't worry about this code yet. We will discuss functions
like these in <a href="ch09_01.htm">Chapter 9, <i>Gateways, Databases, and Search/Index Utilities</i></A>. Now, let's continue with the rest of this
program.

<div class=screen>
<p>
<pre>
$local_users = "internal_info.html";
$outside_users = "general.html";
if (($remote_host =~ /\.$host_address$/) &amp;&amp; ($remote_address =~ /^$ip_address/)) {
    $html_document = $local_users;
} else {
    $html_document = $outside_users;
}
</PRE>
</DIV>

<p class=para>
The remote host is examined to see if it ends with the domain
name, as specified by the <i class=emphasis>$host_address</I> variable,
and the remote address is checked to make sure it starts with the
domain address stored in <i class=emphasis>$ip_address</I>. Depending
on the outcome of the conditional, the <i class=emphasis>$html_document</I>
variable is set accordingly.

<div class=screen>
<p>
<pre>
print "Content-type: text/html", "\n\n";
$document_root = $ENV{'DOCUMENT_ROOT'};
$html_document = join ("/", $document_root, $html_document); 
if (open (HTML, "&lt;" . $html_document)) {
    while (&lt;HTML&gt;) {
	       print;
	}
    close (HTML);
} else {
    print "Oops! There is a problem with the configuration on this system!", "\n";
    print "Please inform the Webmaster of the problem. Thanks!", "\n";
}
exit (0);
</PRE>
</DIV>

<p class=para>
The specified document is opened and the information stored
within it is 
displayed. 

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-2-SECT-2.4">User Authentication and Identification</A></h3>

<p class=para>
In addition to domain-based
security, most HTTP servers also support a more
complicated method of security, known as user authentication. When
configured for user authentication, specified files or directories
are set up to allow access only by certain users. A user attempting
to open the URLs associated with these files is prompted for a name
and password.

<p class=para>
The user name and 
password
(which, incidentally, need have no relation to the user's real user
name and password on any system) is checked by the server, and if
legitimate, the user is allowed access. In addition to allowing
the user access to the protected file, the server also maintains
the user's name and passes it to any subsequent CGI programs that
are called. The server passes the user name in the 
REMOTE_USER environment variable.

<p class=para>
A CGI script can therefore use server authentication information
to identify users.[1]
This isn't what user authentication was meant for, but if the information
is available, it can come in mighty handy. Here is a snippet of
code that illustrates what you can do with the REMOTE_USER
environment variable:

<blockquote class=footnote>
<p class=para>[1] 
The 
HTTP_FROM
environment variable also carries information that can be used to
identify a user-generally, the user's email address.  However, this
variable depends on the browser to make it available, and few browsers
do, so HTTP_FROM is of limited use.
</blockquote>
<div class=screen>
<p>
<pre>
$remote_user = $ENV{'REMOTE_USER'};
if ($remote_user eq "jack") {
    print "Welcome Jack, how is Jack Manufacturing doing these days?", "\n";
} elsif ($remote_user eq "bob") {
    print "Hey Bob, how's the wife doing? I heard she was sick.", "\n";
}
.
.
.
</PRE>
</DIV>

<p class=para>
Server authentication does not provide complete security:
Since the user name and password are sent unencrypted over the network,
it's possible for a "snoop" to look at this data. For that reason,
it's a bad idea to use your real login name and password for server
authentication.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-2-SECT-2.5">Where Did You Come From?</A></h3>

<p class=para>
Companies who provide services on the
Web often want to know from what server (or document) the remote
users came. For example, say you visit the server located at http://www.cgi.edu,
and then from there you go to http://www.flowers.com. A CGI program
on www.flowers.com can actually determine that you were previously
at www.cgi.edu.

<p class=para>
How is this useful? For advertising, of course. If a company
determines that 90% of all users that visit them come from a certain
server, then they can perhaps work something out financially with
the webmaster at that server to provide advertising. Also, if your
site moves or the content at your site changes dramatically, you
can help avoid frustration among your visitors by informing the
webmasters at the sites referring to yours to change their links.
Here is a simple program that displays this "referral" information:

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl
print "Content-type: text/plain", "\n\n";
$remote_address = $ENV{'REMOTE_ADDR'};
$referral_address = $ENV{'HTTP_REFERER'};
print "Hello user from $remote_address!", "\n";
print "The last site you visited was: $referral_address. Am I genius or what?", "\n";
exit (0);
</PRE>
</DIV>

<p class=para>
The environment variable 
HTTP_REFERER,
which is passed to the server by the client, contains the last site
the user visited before accessing the current server.

<p class=para>
Now for the caveats. There are three important things you
need to remember before using the HTTP_REFERER
variable:

<p>
<ul class=itemizedlist>
<li class=listitem>First, not all browsers set this variable.

<p>
<li class=listitem>Second, if a user accesses your server first, right
at startup, this variable will not be set.

<p>
<li class=listitem>Third, if someone accesses your site via a bookmark
or just by typing in the URL, the referring document is meaningless.
So if you are keeping some sort of count to determine where users
are coming from, it won't be totally accurate. 

<p>
</UL>
</DIV>

</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch02_01.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch02_03.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Introduction</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Accessing Form Input</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>

</BODY>
</HTML>
