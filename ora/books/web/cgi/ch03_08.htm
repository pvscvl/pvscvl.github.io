<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 3] 3.8 Complete (Non-Parsed) Headers</TITLE>
<meta name="author" content="Shishir Gundavaram">
<meta name="date" content="Mon Mar 17 13:22:16 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="cgi programming">
<meta name="title" content="CGI Programming on the World Wide Web">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="CGI Programming on the World Wide Web"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch03_07.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 3</b></td>
<td width=172 align=right valign=top><a href="ch04_01.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="CGI-CHP-3-SECT-8">3.8 Complete (Non-Parsed) Headers</A></h2>

<p class=para>
Thus
far, we've only seen examples with partial HTTP headers. That is,
when all you include is a <i class=command>Content-type</i> header,
the server intercepts the output and completes the header information
with header information of its own. The header information generated
by the server might include a "200 OK" status code (if you haven't
overridden it with a <i class=command>Status</i> header), the date
and time, the version of the server, and any other information that
it thinks a browser might find useful.

<p class=para>
But as we mentioned in <a href="ch03_01.htm">Chapter 3, <i>Output from the Common Gateway Interface</i></A>
CGI programs can override the header information generated by the
server by generating a complete HTTP header on its own.

<p class=para>
Why go to all the trouble of generating your own header? When
your program returns a complete HTTP header, there is no extra overhead
incurred by the server. Instead, the output of the CGI program goes
directly to the client, as shown in <a href="#CGI-CHP-3-FIG-2">Figure 3.2</A>. This may mean faster
response time for the user. However, it also means you need to be
especially careful when generating your own headers, since the server
won't be able to circumvent any errors.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-3-FIG-2">Figure 3-2: Partial and complete headers</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0302.gif" alt="[Graphic: Figure 3-2]" width=502 height=273>

</DIV>

<p class=para>
How does the server know if the CGI program has output a partial
or a complete HTTP header without "looking" at it? It depends on
which server you use. On the NCSA and CERN servers, programs that
output complete headers must start with the "nph-" prefix (e.g.,
<i class=emphasis>nph-test.pl</I>), which stands for Non-Parsed Header.

<p class=para>
The following example illustrates the usefulness of creating
an NPH script:

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl
$server_protocol = $ENV{'SERVER_PROTOCOL'};
$server_software = $ENV{'SERVER_SOFTWARE'};
print "$server_protocol 200 OK", "\n";
print "Server: $server_software", "\n";
print "Content-type: text/plain", "\n\n";
print "OK, Here I go. I am going to count from 1 to 50!", "\n";
$| = 1;
for ($loop=1; $loop &lt;= 50; $loop++) {
		print $loop, "\n";
		sleep (2);
}
print "All Done!", "\n";
exit (0);
</PRE>
</DIV>

<p class=para>
When you output a complete header, you should <i class=emphasis>at
least</I> return header lines consisting of the HTTP protocol
revision and the status of the program, the server name/version
(e.g., NCSA/1.4.2), and the MIME content type of the data.

<p class=para>
You can run this program by opening the URL to:

<div class=screen>
<p>
<pre>
http://your.machine/cgi-bin/nph-count.pl
</PRE>
</DIV>

<p class=para>
When you run this CGI script, you should see the output in
"real time": the client will display the number, wait two seconds,
display the next number, etc.

<p class=para>
Now remove the complete header information (except for <i class=command>Content-type</i>),
change the name to <i class=emphasis>count.pl</I> (instead of <i class=emphasis>nph-count.pl</I>),
and run it again. What's the difference? You will no longer see
the output in "real time"; the client will display the entire document
at 
once.
</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch03_07.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch04_01.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Status Codes</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Forms and CGI</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>

</BODY>
</HTML>
