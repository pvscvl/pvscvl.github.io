<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 9] Gateways, Databases, and Search/Index Utilities</TITLE>
<meta name="author" content="Shishir Gundavaram">
<meta name="date" content="Mon Mar 17 13:33:36 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="cgi programming">
<meta name="title" content="CGI Programming on the World Wide Web">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF" text="#000000">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="CGI Programming on the World Wide Web"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch08_03.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 9</b></td>
<td width=172 align=right valign=top><a href="ch09_02.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<h1 class=chapter><a class="TITLE" name="CGI-CHP-9">Gateways, Databases, and Search/Index Utilities</A></H1>

<div class=htmltoc>

<p>
<b>Contents:</b><br>
UNIX Manual Page Gateway<br>
<a href="ch09_02.htm">Mail Gateway</A><br>
<a href="ch09_03.htm">Relational Databases</A><br>
<a href="ch09_04.htm">Search/Index Gateway</A><br>

</DIV>

<p class=para>
Imagine a situation where you have an enormous amount of data
stored in a format that is foreign to a typical web browser. And
you need to find a way to present this information on the Web, as
well as allowing potential users to search through the information.
How would you accomplish such a task?

<p class=para>
Many information providers on the Web find themselves in situations
like this. Such a problem can be solved by writing a CGI program
that acts as a gateway between the data and the Web. A simple gateway
program was presented in <a href="ch07_01.htm">Chapter 7, <i>Advanced Form Applications</i></A>.
The pie graph program can read the ice cream data file and produce
a graph illustrating the information contained within it. In this
chapter, we will discuss gateways to UNIX programs,
relational databases, and search engines.

<div class=sect1>
<h2 class=sect1><a class="TITLE" name="CGI-CHP-9-SECT-1">9.1 UNIX Manual Page Gateway</A></h2>

<p class=para>
Manual
pages on a UNIX operating system provide documentation
on the various software and utilities installed on the system. In
this section, I will write a gateway that reads the requested manual
page, converts it to HTML, and displays it (see <a href="#CGI-CHP-9-FIG-1">Figure 9.1</A>). We
will let the standard utility for formatting manual pages, <i class=emphasis>nroff</I>,
do most of the work. But this example is useful for showing what
a little HTML can do to spruce up a document.
The key technique you need is to examine the input expected by a
program and the output that it generates, so that you can communicate
with it.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-1">Figure 9-1: Converting manual page to HTML</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0901.gif" alt="[Graphic: Figure 9-1]" width=502 height=363>

</DIV>

<p class=para>
Here is the form that is presented to the user:

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;UNIX Manual Page Gateway&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;UNIX Manual Page Gateway&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/manpage.pl" METHOD="POST"&gt;
&lt;EM&gt;What manual page would you like to see?&lt;/EM&gt;
&lt;BR&gt;
&lt;INPUT TYPE="text" NAME="manpage" SIZE=40&gt;
&lt;P&gt;
&lt;EM&gt;What section is that manual page located in?&lt;/EM&gt;
&lt;BR&gt;
&lt;SELECT NAME="section" SIZE=1&gt;
&lt;OPTION SELECTED&gt;1
&lt;OPTION&gt;2
&lt;OPTION&gt;3
&lt;OPTION&gt;4
&lt;OPTION&gt;5
&lt;OPTION&gt;6
&lt;OPTION&gt;7
&lt;OPTION&gt;8
&lt;OPTION&gt;Don't Know
&lt;/SELECT&gt;
&lt;P&gt;
&lt;INPUT TYPE="submit" VALUE="Submit the form"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
This form will be rendered as shown in <a href="#CGI-CHP-9-FIG-2">Figure 9.2</A>.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-2">Figure 9-2: UNIX manual page form</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0902.gif" alt="[Graphic: Figure 9-2]" width=446 height=278>

</DIV>

<p class=para>
On nearly all UNIX systems, manual pages
are divided into eight or more sections (or subdirectories), located
under one main directory-usually<i class=emphasis> /usr/local/man</I>
or <i class=emphasis>/usr/man</I>.<i class=emphasis> </I>This form
asks the user to provide the section number for the desired manual
page.

<p class=para>
The CGI program follows. The main program is devoted entirely
to finding the right section, and the particular manual page. A
subroutine invokes <i class=emphasis>nroff</I>
on the page to handle the internal <i class=emphasis>nroff</I> codes
that all manual pages are formatted in, then converts the <i class=emphasis>nroff</I>
output to HTML.

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl
$webmaster = "Shishir Gundavaram (shishir\@bu\.edu)";
$script = $ENV{'SCRIPT_NAME'};
$man_path = "/usr/local/man";
$nroff = "/usr/bin/nroff -man";
</PRE>
</DIV>

<p class=para>
The program assumes that the manual pages are stored in the
<i class=emphasis>/usr/local/man</I> directory. The <i class=emphasis>nroff</I>
utility formats the manual page according to the directives found
within the document. A typical unformatted manual page looks like
this:

<div class=screen>
<p>
<pre>
.TH EMACS 1 "1994 April 19"
.UC 4
.SH NAME
emacs \- GNU project Emacs
.SH SYNOPSIS
.B emacs
[
.I command-line switches
] [
.I files ...
]
.br
.SH DESCRIPTION
.I GNU Emacs
is a version of
.I Emacs,
written by the author of the original (PDP-10)
.I Emacs,
Richard Stallman.
.br
.
.
.
</PRE>
</DIV>

<p class=para>
Once it is formatted by <i class=emphasis>nroff</I>, it looks
like this:

<div class=screen>
<p>
<pre>
EMACS(1)                 USER COMMANDS                   EMACS(1)
NAME
     emacs - GNU project Emacs
SYNOPSIS
     emacs [ command-line switches ] [ files ... ]
DESCRIPTION
     GNU Emacs is a version of Emacs, written by  the  author  of
     the original (PDP-10) Emacs, Richard Stallman.
.
.
.
Sun Release 4.1    Last change: 1994 April 19                   1
</PRE>
</DIV>

<p class=para>
Now, let's continue with the program to see how this information
can be further formatted for display on a web browser.

<div class=screen>
<p>
<pre>
$last_line = "Last change:";
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>$last_line</I> variable contains the
text that is found on the last line of each page in a manual. This
variable is used to remove that line when formatting for the Web.

<div class=screen>
<p>
<pre>
&amp;parse_form_data (*FORM);
($manpage = $FORM{'manpage'}) =~ s/^\s*(.*)\b\s*$/$1/;
$section = $FORM{'section'};
</PRE>
</DIV>

<p class=para>
The data in the form is parsed and stored. The <i class=emphasis>parse_form_data</I>
subroutine is the one used initially in the last chapter. Leading
and trailing spaces are removed from the information in the <i class=emphasis>manpage</I>
field. The reason for doing this is so that the specified page can
be found.

<div class=screen>
<p>
<pre>
if ( (!$manpage) || ($manpage !~ /^[\w\+\-]+$/) ) {
    &amp;return_error (500, "UNIX Manual Page Gateway Error",
                        "Invalid manual page specification.");
</PRE>
</DIV>

<p class=para>
This block is very important! If a manual page was not specified,
or if the information contains characters other than (A-Z, a-z,
0-9, _, +, -), an error message is returned. As discussed in <a href="ch07_01.htm">Chapter 7, <i>Advanced Form Applications</i></A>, it is always important to check for shell metacharacters
for security reasons.

<div class=screen>
<p>
<pre>
} else {
    if ($section !~ /^\d+$/) {
        $section = &amp;find_section ();
    } else {
        $section = &amp;check_section ();
    }
</PRE>
</DIV>

<p class=para>
If the <i class=emphasis>section</I> field consists of a number,
the <i class=emphasis>check_section</I> subroutine is called to check
the specified section for the particular manual page. If non-numerical
information was passed, such as "Don't Know," the <i class=emphasis>find_section</I>
subroutine iterates through all of the sections to determine the
appropriate one. In the regular expression, "\d" stands for digit,
"+" allows for one or more of them, and the "^" and "$" ensure that
nothing but digits are in the string. To simplify this part of the
search, we do not allow the "nonstandard" subsections some systems
offer, such as <i class=emphasis>2v</I> or <i class=emphasis>3m</I>.

<p class=para>
Both of these search subroutines return values upon termination.
These return values are used by the code below to make sure that
there are no errors.

<div class=screen>
<p>
<pre>
    if ( ($section &gt;= 1) &amp;&amp; ($section &lt;= 8) ) {
        &amp;display_manpage ();
    } else {
        &amp;return_error (500, "UNIX Manual Page Gateway Error",
                            "Could not find the requested document.");
    }
}
exit (0);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>find_section</I> and <i class=emphasis>check_section</I>
subroutines called above return a value of zero (0) if the specified
manual page does not exist. This return value is stored in the <i class=emphasis>section</I>
variable. If the information contained in <i class=emphasis>section</I>
is in the range of 1 through 8, the <i class=emphasis>display_manpage</I>
subroutine is called to display the manual page. Otherwise, an error
is returned.

<p class=para>
The <i class=emphasis>find_section</I> subroutine searches
for a particular manual page in all the sections (from 1 through
8).

<div class=screen>
<p>
<pre>
sub find_section
{
    local ($temp_section, $loop, $temp_dir, $temp_file);
    $temp_section = 0;
    for ($loop=1; $loop &lt;= 8; $loop++) {
        $temp_dir  = join("", $man_path, "/man", $loop);
        $temp_file = join("", $temp_dir, "/", $manpage, ".", $loop);
</PRE>
</DIV>

<p class=para>
<i class=emphasis>find_section</I> searches in the subdirectories
called "man1," "man2," "man3," etc. And each manual page in the
subdirectory is suffixed with the section number, such as "zmore.1,"
and "emacs.1." Thus, the first pass through the loop might join
"/usr/local/man" with "man1" and "zmore.1" to make "<i class=emphasis>/usr/local/man/
man1/zmore.1</I>", which is stored in the <i class=emphasis>$temp_file</I>
variable.

<div class=screen>
<p>
<pre>
        if (-e $temp_file) {
            $temp_section = $loop;
        }
    }
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>-e</I> switch returns TRUE if the file
exists. If the manual page is found, the <i class=emphasis>temp_section</I>
variable contains the section number.

<div class=screen>
<p>
<pre>
    return ($temp_section);
}
</PRE>
</DIV>

<p class=para>
The subroutine returns the value stored in <i class=emphasis>$temp_section</I>.
If the specified manual page is not found, it returns zero.

<p class=para>
The <i class=emphasis>check_section</I> subroutine checks the
specified section for the particular manual page. If it exists,
the section number passed to the subroutine is returned. Otherwise,
the subroutine returns zero to indicate failure. Remember that you
may have to modify this program to reflect the directories and filenames
of manual pages on your system.

<div class=screen>
<p>
<pre>
sub check_section
{
    local ($temp_section, $temp_file);
    $temp_section = 0;
    $temp_file    = join ("", $man_path, "/man", $section,
                              "/", $manpage, ".", $section);
    if (-e $temp_file) {
        $temp_section = $section;
    }
    return ($temp_section);
}
</PRE>
</DIV>

<p class=para>
The heart of this gateway is the <i class=emphasis>display_manpage</I>
subroutine. It does not try to interpret the <i class=emphasis>nroff</I> codes in the manual page. Manual
page style is complex enough that our best bet is to invoke <i class=emphasis>nroff</I>,
which has always been used to format the pages. But there are big
differences between the output generated by <i class=emphasis>nroff</I>
and what we want to see on a web browser. The <i class=emphasis>nroff</I>
utility produces output suitable for an old-fashioned line printer,
which produced bold and underlined text by backspacing and reprinting.
<i class=emphasis>nroff</I> also puts a header at the top of each
page and a footer at the bottom, which we have to remove. Finally,
we can ignore a lot of the blank space generated by <i class=emphasis>nroff</I>,
both at the beginning of each line and in between lines.

<p class=para>
The <i class=emphasis>display_manpage</I> subroutine starts
by running the page through <i class=emphasis>nroff</I>. Then, the
subroutine performs a few substitutions to make the page look good
on a web browser.

<div class=screen>
<p>
<pre>
sub display_manpage
{
    local ($file, $blank, $heading);
    $file = join ("", $man_path, "/man", $section, 
                      "/", $manpage, ".", $section);
    print "Content-type: text/html", "\n\n";
		print "&lt;HTML&gt;", "\n";
    print "&lt;HEAD&gt;&lt;TITLE&gt;UNIX Manual Page Gateway&lt;/TITLE&gt;&lt;/HEAD&gt;", "\n";
		print "&lt;BODY&gt;", "\n";    
		print "&lt;H1&gt;UNIX Manual Page Gateway&lt;/H1&gt;", "\n";
    print "&lt;HR&gt;&lt;PRE&gt;";
</PRE>
</DIV>

<p class=para>
The usual MIME header and HTML
text are displayed.

<div class=screen>
<p>
<pre>
    open (MANUAL, "$nroff $file |");
</PRE>
</DIV>

<p class=para>
A pipe to the <i class=emphasis>nroff</I> program is opened
for output. Whenever you open a pipe, it is critical to check that
there are no shell metacharacters on the command line. Otherwise,
a malicious user can execute commands on your machine! This is why
we performed the check at the beginning of this program.

<div class=screen>
<p>
<pre>
    $blank = 0;
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>blank</I> variable keeps track of the
number of consecutive empty lines in the document. If there is more
than one consecutive blank line, it is ignored.

<div class=screen>
<p>
<pre>
    while (&lt;MANUAL&gt;) {
        next if ( (/^$manpage\(\w+\)/i) || (/\b$last_line/o) );
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>while</I> loop iterates through each
line in the manual page. The <i class=emphasis>next</I> construct
ignores the first and last lines of each page. For example, the
first and last lines of each page of the <i class=emphasis>emacs</I>
manual page look like this:

<div class=screen>
<p>
<pre>
EMACS(1)                 USER COMMANDS                   EMACS(1)
.
.
.
Sun Release 4.1    Last change: 1994 April 19                   1
</PRE>
</DIV>

<p class=para>
This is unnecessary information, and therefore we skip over
it. The <i class=emphasis>if</I> statement checks for a string that
does not contain any spaces. The previous <i class=emphasis>while</I>
statement stores the current line in Perl's default variable, <i class=emphasis>$_</I>.
A regular expression without a corresponding variable name matches
against the value stored in <i class=emphasis>$_</I>.

<div class=screen>
<p>
<pre>
        if (/^([A-Z0-9_ ]+)$/) {
            $heading = $1;
            print "&lt;H2&gt;", $heading, "&lt;/H2&gt;", "\n";
</PRE>
</DIV>

<p class=para>
All manual pages consist of distinct headings such as "NAME,"
"SYNOPSIS," "DESCRIPTION," and "SEE ALSO," which are displayed as
all capital letters. This conditional checks for such headings,
stores them in the variable <i class=emphasis>heading</I>, and displays
them as HTML level 2 headers. The heading is
stored to be used later on.

<div class=screen>
<p>
<pre>
        } elsif (/^\s*$/) {
            $blank++;
            if ($blank &lt; 2) {
                print;
            }
</PRE>
</DIV>

<p class=para>
If the line consists entirely of whitespace, the subroutine
increments the <i class=emphasis>$blank</I> variable. If the value
of that variable is greater than two, the line is ignored. In other
words, consecutive blank lines are ignored.

<div class=screen>
<p>
<pre>
        } else {
        
            $blank = 0;
            s//&amp;amp;/g       if (/&amp;/);
            s//&amp;lt;/g        if (/&lt;/);
            s//&amp;gt;/g        if (/&gt;/);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>blank</I> variable is initialized to
zero, since this block is executed only if the line contains non-whitespace
characters. The regular expressions replace the "&amp;", "&lt;",
and "&gt;" characters with their HTML equivalents,
since these characters have a special meaning to the browser.

<div class=screen>
<p>
<pre>
            if (/((_\010\S)+)/) {
                s//&lt;B&gt;$1&lt;\/B&gt;/g;
                s/_\010//g;
            }
</PRE>
</DIV>

<p class=para>
All manual pages have text strings
that are underlined for emphasis. The <i class=emphasis>nroff</I>
utility creates an underlined effect by using the "_" and the "^H"
(Control-H or \010) characters. Here is how the word "options" would
be underlined:

<div class=screen>
<p>
<pre>
_^Ho_^Hp_^Ht_^Hi_^Ho_^Hn_^Hs
</PRE>
</DIV>

<p class=para>
The regular expression in the <i class=emphasis>if</I> statement
searches for an underlined word and stores it in <i class=emphasis>$1</I>,
as illustrated below.


<p>
<img aindex.htmllign=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0903.gif" alt="[Graphic: Figure from the text]" width=446 height=370>

<p class=para>
This first substitution statement adds the &lt;B&gt; .. &lt;/B&gt;
tags to the string:

<div class=screen>
<p>
<pre>
&lt;B&gt;_^Ho_^Hp_^Ht_^Hi_^Ho_^Hn_^Hs&lt;/B&gt;
</PRE>
</DIV>

<p class=para>
Finally, the "_^H" characters are removed to create:

<div class=screen>
<p>
<pre>
&lt;B&gt;options&lt;/B&gt;
</PRE>
</DIV>

<p class=para>
Let's modify the file in one more way before we start to display
the information:

<div class=screen>
<p>
<pre>
            if ($heading =~ /ALSO/) {
                if (/([\w\+\-]+)\((\w+)\)/) {
                s//&lt;A HREF="$script\?manpage=$1&amp;section=$2"&gt;$1($2)&lt;\/A&gt;/g;
                }
            }
</PRE>
</DIV>

<p class=para>
Most manual pages contain a "SEE ALSO" heading under which
related software applications are listed. Here is an example:

<div class=screen>
<p>
<pre>
SEE ALSO
     X(1), xlsfonts(1), xterm(1), xrdb(1)
</PRE>
</DIV>

<p class=para>
The regular expression stores the command name in <i class=emphasis>$1</I>
and the manpage section number in <i class=emphasis>$2</I>, as seen
below. Using this regular expression, we add a hypertext link to
this program for each one of the listed applications. The query
string contains the manual page title, as well as the section number.


<p>
<img aindex.htmllign=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0904.gif" alt="[Graphic: Figure from the text]" width=445 height=368>

<p class=para>
The program continues as follows:

<div class=screen>
<p>
<pre>
            print;
        }
    }
    print "&lt;/PRE&gt;&lt;HR&gt;", "\n";
		print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";
    
    close (MANUAL);
}
</PRE>
</DIV>

<p class=para>
Finally, the modified line is displayed. After all the lines
in the file-or pipe-are read, it is closed. <a href="#CGI-CHP-9-FIG-3">Figure 9.3</A> shows the
output produced by this application.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-3">Figure 9-3: Manual page gateway</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0905.gif" alt="[Graphic: Figure 9-3]" width=446 height=368>

</DIV>

<p class=para>
This particular gateway program concerned itself mostly with
the output of the program it invoked (<i class=emphasis>nroff</I>).
You will see in this chapter that you often have to expend equal
effort (or even more effort) fashioning input in the way the existing
program expects it. Those are the general tasks of gateways.

</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch08_03.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch09_02.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Netscape Persistent Cookies</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Mail Gateway</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>

</BODY>
</HTML>
