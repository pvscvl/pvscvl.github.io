<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 7] 7.3 Quiz/Test Form Application</TITLE>
<meta name="author" content="Shishir Gundavaram">
<meta name="date" content="Mon Mar 17 13:31:11 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="cgi programming">
<meta name="title" content="CGI Programming on the World Wide Web">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="CGI Programming on the World Wide Web"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch07_02.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 7</b></td>
<td width=172 align=right valign=top><a href="ch07_04.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="CGI-CHP-7-SECT-3">7.3 Quiz/Test Form Application</A></h2>

<p class=para>
The
application that we are about to discuss allows you to embed special
tags within <tt class=literal>HTML</tt> to create quizzes and tests.
The program then parses the new tags to create valid forms.

<p class=para>
The special tags I designed for the quiz application are shown
in <a href="#CGI-CHP-7-TBL-1">Table 7.1</A>.

<p>
<div class=table>
<table>
<caption><a class="TITLE" name="CGI-CHP-7-TBL-1">Table 7-1: Special Tags for Quiz Application</A></CAPTION>
<tr class=row>
<th align="left">

<p class=para>
Tag</TH>
<th align="left">

<p class=para>
Use</TH>
</TR>
<tr class=row>
<td align="left">

<p class=para>
<tt>&lt;QUIZ&gt;</TT>, <tt>&lt;/QUIZ&gt;</TT></TD>
<td align="left">

<p class=para>
start/end a quiz</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
<tt>&lt;QUESTION&gt;</TT>, <tt>&lt;/QUESTION&gt;</TT>,
<tt class=literal>TYPE</tt>="Text", <tt class=literal>TYPE</tt>="Multiple"</TD>
<td align="left">

<p class=para>
start/end a question block, text field, multiple choice</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
<tt>&lt;ASK&gt;</TT>, <tt>&lt;/ASK&gt;</TT></TD>
<td align="left">

<p class=para>
start/end the question text</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
<tt>&lt;HINT&gt;</TT>, <tt>&lt;/HINT&gt;</TT></TD>
<td align="left">

<p class=para>
start/end hint text</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
<tt>&lt;ANSWER&gt;</TT>, <tt>&lt;/ANSWER&gt;</TT></TD>
<td align="left">

<p class=para>
start/end answer text</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
<tt>&lt;RESPONSE&gt;</TT>, <tt>&lt;/RESPONSE&gt;</TT></TD>
<td align="left">

<p class=para>
start/end response message</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
<tt>&lt;CHOICE&gt;</TT>, <tt>&lt;/CHOICE&gt;</TT></TD>
<td align="left">

<p class=para>
start/end multiple choice item</TD>
</TR>
</TABLE>
<p>
</DIV>
<p class=para>
Before I show the application, I'll show
you how the tags are used. Here is an example:

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;CGI Quiz/Test Application&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;World Wide Web Quiz&lt;/H1&gt;
&lt;HR&gt;
&lt;QUIZ&gt;
</PRE>
</DIV>

<p class=para>
The <tt>&lt;QUIZ&gt;</TT> tag represents the start
of the quiz. It is similar to the <tt>&lt;FORM&gt;</TT>
tag. These new tags are similar to traditional <tt class=literal>HTML</tt>,
in that they ignore whitespace, and disregard the case of the string.
You can also embed other <tt class=literal>HTML</tt> tags through a
quiz, with the exception of <tt>&lt;FORM&gt;</TT>.

<div class=screen>
<p>
<pre>
&lt;QUESTION TYPE="Text"&gt;
&lt;ASK&gt;Who is credited with the invention of the World Wide Web?&lt;/ASK&gt;
</PRE>
</DIV>

<p class=para>
The <tt>&lt;QUESTION&gt;</TT> tag supports two types
of questions: fill-in-the-blank (or "text"), and multiple choice
(or "multiple"). The actual question is displayed by the <tt>&lt;ASK&gt;</TT>
tag. Remember to close the <tt>&lt;ASK&gt;</TT> tag with
<tt>&lt;/ASK&gt;</TT>.

<div class=screen>
<p>
<pre>
&lt;HINT&gt;WWW was created at CERN&lt;/HINT&gt;
&lt;HINT&gt;The inventor now works for &lt;A HREF="http://www.w3.org"&gt;W3C&lt;/A&gt;
at MIT&lt;/HINT&gt;
</PRE>
</DIV>

<p class=para>
You can specify hints for the
user with the 
<tt>&lt;HINT&gt;</TT>
tag. Notice the embedded hypertext anchor in the <tt>&lt;HINT&gt;</TT>
tag. The only restriction with specifying hints is that they must
all be grouped together in one place within the question.

<div class=screen>
<p>
<pre>
&lt;ANSWER&gt;Tim Berners-Lee&lt;/ANSWER&gt;
</PRE>
</DIV>

<p class=para>
The answer to the question is stored within the 
<tt>&lt;ANSWER&gt;</TT>
and <tt>&lt;/ANSWER&gt;</TT> tags. You can have only one
answer.

<div class=screen>
<p>
<pre>
&lt;RESPONSE Tim Berners-Lee&gt;You got it! You do know the history behind 
the Web.&lt;/RESPONSE&gt;
&lt;RESPONSE Marc Andreessen&gt;Sorry. Marc was the project leader for Mosaic
at NCSA. He currently works for Netscape Communications Corp.&lt;/RESPONSE&gt;
&lt;RESPONSE WRONG&gt;I guess you do not know how the Web got started.&lt;/RESPONSE&gt;
&lt;RESPONSE SKIP&gt;Come on! At least guess!&lt;/RESPONSE&gt;
</PRE>
</DIV>

<p class=para>
The
<tt>&lt;RESPONSE&gt;</TT> tags display messages
depending on the user input. The two defined response types are
"wrong" and "skip." These can be used for wrong answers or skipped
questions, respectively. Like the <tt>&lt;HINT&gt;</TT>
tags, all the <tt>&lt;RESPONSE&gt;</TT> tags have to be
grouped together.

<div class=screen>
<p>
<pre>
&lt;/QUESTION&gt;
</PRE>
</DIV>

<p class=para>
You have to
end each question with the <tt>&lt;/QUESTION&gt;</TT> tag.

<div class=screen>
<p>
<pre>
&lt;QUESTION TYPE="Multiple"&gt;
</PRE>
</DIV>

<p class=para>
The
"
multiple"
keyword specifies a multiple-choice question.

<div class=screen>
<p>
<pre>
&lt;ASK&gt;Which of the following WWW browsers does &lt;B&gt;not&lt;/B&gt; support graphics?&lt;/ASK&gt;
</PRE>
</DIV>

<p class=para>
Notice
the use of the <tt class=literal>HTML</tt>
tag &lt;B&gt; for emphasis.

<div class=screen>
<p>
<pre>
&lt;CHOICE A&gt;&lt;IMG SRC="/images/mosaic.gif"&gt;Mosaic&lt;/CHOICE&gt;
&lt;CHOICE B&gt;&lt;IMG SRC="/images/netscape.gif"&gt;Netscape Navigator&lt;/CHOICE&gt;
&lt;CHOICE C&gt;&lt;IMG SRC="/images/we.gif"&gt;WebExplorer&lt;/CHOICE&gt;
&lt;CHOICE D&gt;&lt;IMG SRC="/images/lynx.gif"&gt;Lynx&lt;/CHOICE&gt;
&lt;CHOICE E&gt;&lt;IMG SRC="/images/arena.gif"&gt;Arena&lt;/CHOICE&gt;
&lt;CHOICE F&gt;&lt;IMG SRC="/images/cello.gif"&gt;Cello&lt;/CHOICE&gt;
&lt;ANSWER&gt;D&lt;/ANSWER&gt;
&lt;HINT&gt;It was developed at the University of Kansas&lt;/HINT&gt;
</PRE>
</DIV>

<p class=para>
With multiple-choice questions, you can use single characters
to represent each choice. The answer can also be specified as a
single character. Notice how the <tt>&lt;IMG&gt;</TT> tags
are used to display inline images within the question. The <tt>&lt;CHOICE&gt;</TT>
tags also have to be grouped together.

<div class=screen>
<p>
<pre>
&lt;RESPONSE A&gt;&lt;A HREF="http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/ NCSAMosaicHome.html"&gt;
Mosaic&lt;/A&gt; was the first graphic browser.&lt;/RESPONSE&gt;
&lt;RESPONSE B&gt;&lt;A HREF="http://www.mcom.com"&gt;Netscape&lt;/A&gt; is the most used browser on the market. It supports:&lt;BR&gt;
&lt;PRE&gt;
         In-Line JPEG Images&lt;BR&gt;
         Client Pull and Server Push Animations&lt;BR&gt;
&lt;/PRE&gt;&lt;/RESPONSE&gt;
&lt;RESPONSE WRONG&gt;I guess you don't surf the Web regularly.&lt;/RESPONSE&gt;
&lt;RESPONSE SKIP&gt;Come on! Are you scared of being wrong?&lt;/RESPONSE&gt;
&lt;/QUESTION&gt;
</PRE>
</DIV>

<p class=para>
As mentioned before, you can embed plain <tt class=literal>HTML</tt>
within any of the new quiz tags.

<div class=screen>
<p>
<pre>
&lt;QUESTION TYPE="Multiple"&gt;
Now, this is an easy question. You have to get this one right!&lt;BR&gt;
&lt;ASK&gt;Which language is preferred for CGI applications?&lt;/ASK&gt;
&lt;CHOICE A&gt;&lt;A HREF="http://gopher.metronet.com:70/1/ perlinfo"&gt;Perl&lt;/A&gt;&lt;/CHOICE&gt;
&lt;CHOICE B&gt;Tcl&lt;/CHOICE&gt;
&lt;CHOICE C&gt;C/C++&lt;/CHOICE&gt;
&lt;CHOICE D&gt;C Shell&lt;/CHOICE&gt;
&lt;CHOICE D&gt;Visual Basic&lt;/CHOICE&gt;
&lt;CHOICE E&gt;AppleScript&lt;/CHOICE&gt;
&lt;ANSWER&gt;A&lt;/ANSWER&gt;
&lt;RESPONSE A&gt;Good! Perl is well suited for CGI applications. In fact,
this program was written in Perl.&lt;/RESPONSE&gt;
&lt;RESPONSE SKIP&gt;I believe you don't know the answer!&lt;/RESPONSE&gt;
&lt;RESPONSE WRONG&gt;What? You don't know the answer to this question!&lt;/RESPONSE&gt;
&lt;/QUESTION&gt;
</PRE>
</DIV>

<p class=para>
Notice the extra text before the <tt>&lt;ASK&gt;</TT>
tag. It will be displayed before the question. There is also a hypertext
anchor in one of the choices. 

<div class=screen>
<p>
<pre>
&lt;/QUIZ&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
You have to end the quiz with <tt>&lt;/QUIZ&gt;</TT>.
Like forms, you can have multiple quizzes in one document, but they
cannot be nested inside one another. This document when converted
to pure <tt class=literal>HTML</tt> will look like <a href="#CGI-CHP-7-FIG-5">Figure 7.5</A>.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-7-FIG-5">Figure 7-5: Quiz form</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0705.gif" alt="[Graphic: Figure 7-5]" width=496 height=368>

</DIV>

<p class=para>
Once the user fills out the quiz, this application
will correct it, as shown in <a href="#CGI-CHP-7-FIG-6">Figure 7.6</A>.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-7-FIG-6">Figure 7-6: Quiz answers</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0706.gif" alt="[Graphic: Figure 7-6]" width=500 height=485>

</DIV>

<p class=para>
Before we go any further, let's look at how
a quiz can be accessed:

<div class=screen>
<p>
<pre>
Welcome to this server. &lt;BR&gt;
If you want to be challenged, take this
&lt;A HREF="/cgi-bin/quiz.pl/quiz.html"&gt;quiz&lt;/A&gt;
</PRE>
</DIV>

<p class=para>
The relative path of the data file has to be passed as extra
path information to the program. In this case, the path to the file
is <i class=emphasis>/quiz.html</I>. Now, let's look at the CGI program
that parses this document, and then corrects the quiz once the user
submits it.

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl
$form = 0;
$this_script = $ENV{'SCRIPT_NAME'};
$webmaster = "Shishir Gundavaram (shishir\@bu\.edu)";
$separator = "\034";
</PRE>
</DIV>

<p class=para>
The environment variable <tt class=literal>SCRIPT_NAME</tt>
returns the relative path to this script, such as "/cgi-bin/quiz.pl".
This relative path is used to set the <tt class=literal>ACTION</tt>
attribute in the quiz form to point to this program. The program
then corrects the quiz and outputs the results.

<div class=screen>
<p>
<pre>
$exclusive_lock = 2;
$unlock = 8;
$document_root = "/usr/local/bin/httpd_1.4.2/public";
$images_dir = "/images";
$quiz_file = $ENV{'PATH_INFO'};
if ($quiz_file) {
    $full_path = $document_root . $quiz_file;
} else {
    &amp;return_error (500, "CGI Quiz File Error", 
                        "A quiz data file has to be specified.");
}
</PRE>
</DIV>

<p class=para>
The
<tt class=literal>PATH_INFO</tt> environment variable contains the relative
path to the quiz data file.

<div class=screen>
<p>
<pre>
open (FILE, "&lt;" . $full_path) || 
		&amp;return_error (500, "CGI Quiz File Error",
                   	   "Cannot open quiz data file [$full_path].");
flock (FILE, $exclusive_lock);
</PRE>
</DIV>

<p class=para>
This is a way to
check the specified data file. First, Perl tries to open the data
file. If not successful, the second part of the expression is evaluated,
and an error is returned. This construct is identical to:

<div class=screen>
<p>
<pre>
if (! open (FILE, "&lt;" . $full_path) ) {
    &amp;return_error (500, "CGI Quiz Data File Error",
                        "Cannot open quiz data file [$full path].");
}
</PRE>
</DIV>

<p class=para>
Now, let's proceed with the program:

<div class=screen>
<p>
<pre>
if ($ENV{'REQUEST_METHOD'} eq "POST") {
    &amp;parse_form_data(*QUIZ);
}
print "Content-type: text/html", "\n\n";
</PRE>
</DIV>

<p class=para>
If any
form data is present, it is retrieved and stored in the <tt class=literal>QUIZ</tt>
associative array. The <i class=emphasis>parse_form_data</I> subroutine
is slightly different from what you have seen before. There will
be no data in the array when the quiz is first displayed with a
<tt class=literal>GET</tt> request. On the other hand, when the quiz
is submitted using <tt class=literal>POST</tt>, the form data has to
be stored.

<p class=para>
Most of the work in this program is performed
by a while loop, which does one of three things: It reads a quiz
as supplied by a user, it displays the <tt class=literal>HTML</tt> version
of a quiz, or it checks answers against those supplied.

<div class=screen>
<p>
<pre>
while (&lt;FILE&gt;) {
    if (/&lt;\s*quiz\s*&gt;/i) {
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>while</I> loop iterates
through the data file, storing a line in the Perl default variable
<i class=emphasis>$_</I> each time through the loop. The <i class=emphasis>if</I>
statement looks for the <tt>&lt;QUIZ&gt;</TT> tag. The "\s*"
string in the regular expression checks for zero or more spaces
before and after the "quiz" string. The "i" at the end of the regular
expression makes the search case insensitive.

<div class=screen>
<p>
<pre>
        $form++;
        $count = 0;
</PRE>
</DIV>

<p class=para>
If a <tt>&lt;QUIZ&gt;</TT> tag was found, the <i class=emphasis>form</I>
variable is incremented, representing the number of quizzes in the
data file. The <i class=emphasis>count</I> variable is initialized
to zero; it is used to keep track of the number of questions within
a quiz.

<div class=screen>
<p>
<pre>
        if ($QUIZ{'cgi_quiz_form'}) {
            $no_correct = $no_wrong = $no_skipped = 0;
            $correct = "Correct! ";
            $wrong = "Wrong! ";
            $skipped = "Skipped! ";
        }
</PRE>
</DIV>

<p class=para>
This conditional will be valid only
when the form is submitted. In this example, you will see something
you have not seen before: a query is attached to the URL in the
"<tt class=literal>ACTION</tt>" attribute of the form. The <i class=emphasis>cgi_quiz_form</I>
variable represents the quiz number that the program should process.

<div class=screen>
<p>
<pre>
        &amp;print_form_header();
</PRE>
</DIV>

<p class=para>
The
<i class=emphasis>print_form_header</I> subroutine outputs the <tt>&lt;FORM&gt;</TT>
tag in the following format:

<div class=screen>
<p>
<pre>
&lt;FORM ACTION="/cgi-bin/quiz.pl/quiz.txt?cgi_quiz_form=1" METHOD="POST"&gt;
</PRE>
</DIV>

<p class=para>
In actuality, the program name
is not "hard coded" into the <tt class=literal>ACTION</tt> attribute;
rather, the value of the environment variable <tt class=literal>SCRIPT_NAME</tt>
is used. The data file is specified as extra path information, and
the quiz that should be corrected is passed as a query through the
"variable" <i class=emphasis>cgi_quiz_form</I>. The long name "<i class=emphasis>cgi_quiz_form</I>"
ensures that this variable will not interfere with the other variables
used in the form.

<div class=screen>
<p>
<pre>
        while (&lt;FILE&gt;) {
            if (($type) = 
			   /&lt;\s*question\s*type\s*=\s*"?([^ "&gt;]+)"?\s*&gt;/i) {
                $count++;
</PRE>
</DIV>

<p class=para>
Here is another loop that iterates through the file. The reason
for this loop is to look for <tt>&lt;QUESTION&gt;</TT> tags
within a <tt>&lt;QUIZ&gt;</TT>. If the tag is specified
correctly, the question type is stored in the variable <i class=emphasis>type</I>
and the count variable is incremented.

<p class=para>
Notice the use
of the "\s*" throughout the regular expression to allow the user
to specify extra whitespace within the tag. Also, the user can omit
quote marks for the <tt class=literal>TYPE</tt> attribute, such as:

<div class=screen>
<p>
<pre>
&lt;QUESTION TYPE=multiple&gt;
</PRE>
</DIV>

<p class=para>
and
the regular expression will still work correctly, due to the "?"
operator, which searches for an optional string. (In Perl 5, you
have to use the {0,1} construct instead.)

<div class=screen>
<p>
<pre>
                while (&lt;FILE&gt;) {
                    if (!/&lt;\s*\/question\s*&gt;/i) {
                        $line = join("", $line, $_);
                    } else {
                        last;
                    }
                }
</PRE>
</DIV>

<p class=para>
This embedded <i class=emphasis>while</I>
loop serves to store all the information within a question block
(i.e., <tt>&lt;QUESTION&gt;</TT> .. <tt>&lt;/QUESTION&gt;</TT>)
in a variable. The loop iterates through the file, and concatenates
each line into the <i class=emphasis>line</I> variable.[2]
If a <tt>&lt;/QUESTION&gt;</TT> tag is found, the loop is
terminated with the <i class=emphasis>last</I> command.

<blockquote class=footnote>
<p class=para>[2] 
In
Perl, there are two ways to perform string concatenation: the "."
operator and the <i class=emphasis>join</I> command. The "." operator
is less efficient because strings have to be copied back and forth.
So you should use the "." operator for simple concatenation only.
</blockquote>
<div class=screen>
<p>
<pre>
                $line =~ s/\n/ /g;
</PRE>
</DIV>

<p class=para>
Once the previous while loop terminates, all of the information
within the question block is contained in the <i class=emphasis>line</I>
variable. In order to treat it as one string for searching purposes,
the newline characters are replaced with spaces.

<div class=screen>
<p>
<pre>
	                ($ask) = ($line =~ /&lt;\s*ask\s*&gt;(.*)&lt;\s*\/ask\s*&gt;/i);
                &amp;print_question($ask);
</PRE>
</DIV>

<p class=para>
The
above expression determines the question title by retrieving the
string in the <tt>&lt;ASK&gt;</TT> .. <tt>&lt;/ASK&gt;</TT>
block. The <i class=emphasis>print_question</I> subroutine displays
the question. When parentheses are used in a regular expression,
the matched string is stored in such variables as $1, $2, and $3.
However, when you use a construct such as this, Perl stores the
specified matched string inside the parentheses in the variable
provided. When using this construct, a common mistake is:

<div class=screen>
<p>
<pre>
$ask = ($line =~ /&lt;\s*ask\s*&gt;(.*)&lt;\s*\/ask\s*&gt;/i);
</PRE>
</DIV>

<p class=para>
If the parentheses around the $ask variable are omitted, the
<i class=emphasis>ask</I> variable will contain the value of "1",
which is definitely not what you expect. Basically, you are evaluating
the <i class=emphasis>ask</I> variable in a scalar context, not in
an array context. In other words, the variable will return the number
of stored strings.

<div class=screen>
<p>
<pre>
                $type =~ tr/A-Z/a-z/;
                $variable = join("-", $count, $type);
</PRE>
</DIV>

<p class=para>
The specified question type is converted into a lowercase
string. In order to identify individual questions in the quiz, an
automatic variable name is given to each one (i.e., "1-text", "2-text",
"3-multiple", etc.) This name is used to specify the name of the
variable in an input field inside a form.

<div class=screen>
<p>
<pre>
                if ($type =~ /^multiple$/i) {
                    &amp;split_multiple("choice", *choices);
                    &amp;print_radio_buttons(*choices);
                } elsif ($type =~ /^text$/i) {
                    &amp;print_text_field();
                }
</PRE>
</DIV>

<p class=para>
If the question is a multiple-choice
question, the <i class=emphasis>split_multiple</I> subroutine is
called to retrieve the information specified by each <tt>&lt;CHOICE&gt;</TT>
tag and store it in the <i class=emphasis>choices</I> array. The
<i class=emphasis>print_radio_buttons</I> subroutine prints the data
stored in the <i class=emphasis>choices</I> array. On the other hand,
if the question is a fill-in-the-blank question, the<i class=emphasis> print_text_field</I>
subroutine is called.

<div class=screen>
<p>
<pre>
                if ($line =~ /&lt;\s*hint\s*&gt;/i) {
                    &amp;split_multiple("hint", *hints);
                    &amp;print_hints(*hints);
                }
</PRE>
</DIV>

<p class=para>
The line is searched for
any <tt>&lt;HINT&gt;</TT> tags. If any hints are found,
they are printed out.

<div class=screen>
<p>
<pre>
                if ($QUIZ{'cgi_quiz_form'} == $form) {
                    local ($answer, %quiz_keys, %quiz_values, 
			           @responses, $user_answer);
</PRE>
</DIV>

<p class=para>
If a query was specified as part of the <tt class=literal>ACTION</tt>
attribute, referring to the quiz to be corrected, and that value
matches the <i class=emphasis>form</I> variable, this loop is executed.
Various variables are defined to keep track of the user's answers.

<div class=screen>
<p>
<pre>
                    &amp;set_browser_graphics();
</PRE>
</DIV>

<p class=para>
This subroutine redefines the correct, wrong, and skipped
variables to point to graphic files if the client browser can support
graphics.

<div class=screen>
<p>
<pre>
                    ($answer) = ($line =~ 
						           /&lt;\s*answer\s*&gt;(.*)&lt;\s*\/answer\s*&gt;/i);
                    &amp;format_string(*answer);
</PRE>
</DIV>

<p class=para>
The
answer specified in the data file is retrieved and stored in the
answer variable. The subroutine <i class=emphasis>format_string</I>
removes leading and trailing spaces, replaces multiple spaces with
a single space, and converts the string to lowercase. This makes
it possible for the user's answer to match the answer specified
in the data file.

<div class=screen>
<p>
<pre>
                    $user_answer = $QUIZ{$variable};
                    &amp;format_string(*user_answer);
</PRE>
</DIV>

<p class=para>
The <tt class=literal>QUIZ</tt> associative array contains the
form data. The key used to access this array is in the form "question
number-question type," such as "1-multiple." Unnecessary spaces
are removed from the user's answer as well.

<div class=screen>
<p>
<pre>
                    &amp;split_multiple("response", *responses);
                    &amp;split_responses(*responses, *quiz_keys, 
									  *quiz_values);
                    print "&lt;HR&gt;&lt;BR&gt;";
</PRE>
</DIV>

<p class=para>
The
response messages to be displayed are read and stored in the <i class=emphasis>responses</I>
array. The <i class=emphasis>split_responses</I> subroutine creates
two associative arrays: <i class=emphasis>quiz_keys</I> and <i class=emphasis>quiz_values</I>.
A typical response tag follows this format:

<div class=screen>
<p>
<pre>
  &lt;RESPONSE key&gt;value&lt;/RESPONSE&gt;
</PRE>
</DIV>

<p class=para>
The array <i class=emphasis>quiz_keys</I>
is indexed by the "key" value specified above, and the value of
the array is also the same "key." The reason for this is to quickly
check to see if there is a response message for a particular answer.
On the other hand, the <i class=emphasis>quiz_values</I> array contains
the "value," indexed by "key."

<div class=screen>
<p>
<pre>
                     if ($user_answer eq $answer) {
                        print $correct;
                        $no_correct++;
</PRE>
</DIV>

<p class=para>
If the
user's answer equals the one stored in the data file, the message
stored in the variable <i class=emphasis>correct</I> is displayed,
and a counter is incremented.

<div class=screen>
<p>
<pre>
                    } elsif ($user_answer eq "") {
                        print $skipped;
                        $no_skipped++;
                        if ($quiz_keys{'skip'}) {
                            print $quiz_values{'skip'}, " ";
                        }
</PRE>
</DIV>

<p class=para>
This conditional
checks to see if the user skipped the question. If there is a <tt>&lt;RESPONSE
SKIP&gt;</TT> tag, the specified message is displayed.

<div class=screen>
<p>
<pre>
                    } else {
                        print $wrong;
                        $no_wrong++;
                        if ($quiz_keys{'wrong'}) {
                            print $quiz_values{'wrong'}, " ";
                        }
                    }
</PRE>
</DIV>

<p class=para>
This checks for a wrong answer. If a <tt>&lt;RESPONSE
WRONG&gt;</TT> tag exists, the appropriate message is displayed.

<div class=screen>
<p>
<pre>
                    if ($user_answer eq $quiz_keys{$user_answer}) {
                        print $quiz_values{$user_answer}, " ";
                    } 
</PRE>
</DIV>

<p class=para>
If
the data file contains a response message for a particular answer,
that message is displayed. It is checked using the <i class=emphasis>quiz_keys</I>
array, and the value stored in <i class=emphasis>quiz_values</I>
is output. An additional space character is displayed after the
message, in the case that there are additional messages.

<div class=screen>
<p>
<pre>
                    print "&lt;BR&gt;&lt;HR&gt;&lt;BR&gt;";
                }
</PRE>
</DIV>

<p class=para>
This concludes the <i class=emphasis>if</I>
statement defined above. Remember, this group of statements is executed
only if the value of the <i class=emphasis>cgi_quiz_form</I> variable
matches the quiz counter, which occurs when the quiz is submitted.

<div class=screen>
<p>
<pre>
                $line = "";
            } elsif (/&lt;\s*\/quiz\s*&gt;/i) {
                last;
            } else {
                print;
            }
        }
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>line</I> variable
contains the information contained within a question block. It is
cleared at the end of the loop. If a <tt>&lt;/QUIZ&gt;</TT>
tag is found, the enclosing while loop is terminated. On the other
hand, if the line from the data file was neither a <tt>&lt;QUESTION&gt;</TT>
nor a <tt>&lt;/QUIZ&gt;</TT> tag, it is assumed to be either
<tt class=literal>HTML</tt> or text, and is printed without any processing.

<div class=screen>
<p>
<pre>
        &amp;print_form_footer();
</PRE>
</DIV>

<p class=para>
The
program jumps to this point if a <tt>&lt;/QUIZ&gt;</TT>
tag is found. The <i class=emphasis>print_form_footer</I> subroutine
ends the quiz by outputting the Submit and Reset buttons, followed
by a <tt>&lt;/FORM&gt;</TT> tag. It will print the buttons
only if the program is in question mode.

<div class=screen>
<p>
<pre>
    } else {
        print;
    }
</PRE>
</DIV>

<p class=para>
This part of the loop will be executed
only if the line is outside the quiz block. It is printed to standard
output verbatim.

<div class=screen>
<p>
<pre>
}
flock (FILE, $unlock);
close (FILE);
exit(0);
</PRE>
</DIV>

<p class=para>
You have to
remember to unlock and close the file after all the operations are
done.

<p class=para>
The print_form_header subroutine outputs the <tt>&lt;FORM&gt;</TT>
tag to start a quiz.

<div class=screen>
<p>
<pre>
sub print_form_header
{
    print &lt;&lt;Form_Header;
&lt;FORM ACTION="${this_script}/${quiz_file}?cgi_quiz_form=${form}" METHOD="POST"&gt;
Form_Header
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>quiz_file</I> variable, which points
to this script, is passed as extra path information. Notice the
query in the <tt class=literal>ACTION</tt> attribute. When the quiz
is submitted, the program will know exactly which quiz it is.

<p class=para>
The parse_form_data subroutine examines the form input and
parses it into the <i class=emphasis>FORM_DATA</I> array.

<div class=screen>
<p>
<pre>
sub parse_form_data
{
    local (*FORM_DATA) = @_;
	
    local ($query_string, @key_value_pairs, $key_value, $key, $value);
	
    read (STDIN, $query_string, $ENV{'CONTENT_LENGTH'});
    if ($ENV{'QUERY_STRING'}) {
            $query_string = join("&amp;", $query_string, 
									   $ENV{'QUERY_STRING'});
    }     
    @key_value_pairs = split (/&amp;/, $query_string);
    foreach $key_value (@key_value_pairs) {
        ($key, $value) = split (/=/, $key_value);
        $value =~ tr/+/ /;
        $value =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;
        if (defined($FORM_DATA{$key})) {
            $FORM_DATA{$key} = join ("\0", $FORM_DATA{$key}, $value);
        } else {
            $FORM_DATA{$key} = $value;
        }
    }
}
</PRE>
</DIV>

<p class=para>
When you glance through
this subroutine, you should notice one difference from the one you
have seen before. The <tt class=literal>POST</tt> request method is
assumed, and the information is read into <i class=emphasis>query_string</I>.
Remember, this subroutine is only called if the <tt class=literal>POST</tt>
request method was used-see the main program. The major difference
in this program is that queries are joined to the <i class=emphasis>query_string</I>
variable, and decoded as one. The only query that is expected is
the one that is passed through the <tt class=literal>ACTION</tt> attribute
of the form.

<p class=para>
The set_browser_graphics subroutine determines
if the browser is graphics capable.

<div class=screen>
<p>
<pre>
sub set_browser_graphics
{
    local ($nongraphic_browsers, $client_browser);
    $nongraphic_browsers = 'Lynx|CERN-LineMode';
    $client_browser = $ENV{'HTTP_USER_AGENT'};
    if ($client_browser !~ /$nongraphic_browsers/) {
        $correct = "&lt;IMG SRC=\"$images_dir/correct.gif\"&gt;";
        $wrong = "&lt;IMG SRC=\"$images_dir/wrong.gif\"&gt;";
        $skipped = "&lt;IMG SRC=\"$images_dir/skipped.gif\"&gt;";
    } 
}
</PRE>
</DIV>

<p class=para>
If the client browser
support graphics, the <i class=emphasis>correct</I>, <i class=emphasis>wrong</I>,
and <i class=emphasis>skipped</I> variables are re-defined to include
a relative path to appropriate images.

<p class=para>
The print_question
subroutine displays the question number, as well as the question
itself, using the global variable $count.

<div class=screen>
<p>
<pre>
sub print_question
{
    local ($question) = @_;
    print &lt;&lt;Question;
&lt;H3&gt;Question $count&lt;/H3&gt;
&lt;EM&gt;$question&lt;/EM&gt;
&lt;P&gt;
Question
}
</PRE>
</DIV>

<p class=para>
The format_string subroutine "formats" the user's answer and
the answer specified in the data file to ensure a greater chance
of matching.

<div class=screen>
<p>
<pre>
sub format_string
{
    local (*string) = @_;
    $string =~ s/^\s*(.*)\b\s*$/$1/;
</PRE>
</DIV>

<p class=para>
All leading and trailing
spaces are removed. This is a very useful regular expression. You
might need to use it frequently when parsing data, as users often
inadvertently insert spaces before or after a string.

<div class=screen>
<p>
<pre>
    $string =~ s/\s+/\s/g;
</PRE>
</DIV>

<p class=para>
Multiple
spaces are replaced by a single space throughout the string.

<div class=screen>
<p>
<pre>
    $string =~ tr/A-Z/a-z/;
}
</PRE>
</DIV>

<p class=para>
Finally, the string is converted to lowercase.

<p class=para>
At
the heart of the program is the split_multiple subroutine. It is
used to split multiple <tt>&lt;CHOICE&gt;</TT>, <tt>&lt;RESPONSE&gt;</TT>,
and <tt>&lt;HINT&gt;</TT> tags to make the processing easier.

<div class=screen>
<p>
<pre>
sub split_multiple
{
    local ($tag, *multiple) = @_;
    local ($info, $first, $loop);
</PRE>
</DIV>

<p class=para>
<tt>&lt;CHOICE&gt;</TT>
and <tt>&lt;RESPONSE&gt;</TT> tags are handled differently
than <tt>&lt;HINT&gt;</TT> tags because they can contain
an extra parameter in the tag. Let's first look at the <tt>&lt;CHOICE&gt;</TT>
and <tt>&lt;RESPONSE&gt;</TT> tags.

<div class=screen>
<p>
<pre>
    if ( ($tag eq "choice") || ($tag eq "response") ) {
        ($first, $info) = ($line =~ /&lt;\s*$tag\s*([^&gt;]+)&gt;(.*)&lt;\s*\/$tag\s*&gt;/i);
        $info =~ s/&lt;\s*$tag\s*([^&gt;]+)&gt;/$1$separator/ig;
        $info = join("$separator", $first, $info);
</PRE>
</DIV>

<p class=para>
Before we discuss the parsing details, let's look at a simple
collection of <tt>&lt;RESPONSE&gt;</TT> tags to illustrate
some points. Everything we discuss will also apply to the <tt>&lt;CHOICE&gt;</TT>
tag as well.

<div class=screen>
<p>
<pre>
&lt;RESPONSE key1&gt;value1&lt;/RESPONSE&gt;
&lt;RESPONSE key2&gt;value2&lt;/RESPONSE&gt;
&lt;RESPONSE key3&gt;value3&lt;/RESPONSE&gt;
</PRE>
</DIV>

<p class=para>
The regular expression parses through the string and stores
the first parameter, or "key1", in the <i class=emphasis>first</I>
variable. And the string starting from "value1" till the last <tt>&lt;/RESPONSE&gt;</TT>
tag is stored in the <i class=emphasis>info</I> variable. This is
why all the <tt>&lt;RESPONSE&gt;</TT> tags have to be grouped
together in the data file. The substitute command replaces each
&lt;<tt class=literal>RESPONSE</tt> key&gt; string with the key value
and the separator (defined to be octal 34). Finally, the string
stored in <i class=emphasis>info</I> is joined to the first key,
and stored again in <i class=emphasis>info</I>. This is very important!
If the first key is not stored, it will be lost, because the regular
expression stores everything in a response block (i.e., &lt;<tt class=literal>RESPONSE</tt>
key1&gt; to the last <tt>&lt;/RESPONSE&gt;</TT>). Now, <i class=emphasis>info</I>
will contain:

<div class=screen>
<p>
<pre>
key1\034value1&lt;/RESPONSE&gt;
key2\034value2&lt;/RESPONSE&gt;
key3\034value3&lt;/RESPONSE&gt;
</PRE>
</DIV>

<p class=para>
The subroutine continues:

<div class=screen>
<p>
<pre>
    } else {
        ($info) = ($line =~ /&lt;\s*$tag\s*&gt;(.*)&lt;\s*\/$tag\s*&gt;/i);
        $info =~ s/&lt;\s*$tag\s*&gt;//ig;
    }
</PRE>
</DIV>

<p class=para>
This <i class=emphasis>else</I> construct will be executed
for <tt>&lt;HINT&gt;</TT> tags. The regular expression works
the same way as the previous one, except that <tt>&lt;HINT&gt;</TT>
tags do not contain extra parameters. As a result, no extra precautions
need to be taken to store those parameters.

<div class=screen>
<p>
<pre>
    @multiple = split(/&lt;\s*\/$tag\s*&gt;/i, $info);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>split</I> command separates the string
in <i class=emphasis>info</I> with the <tt>&lt;/RESPONSE&gt;</TT>
delimiter. After this command, the array would look like this:

<div class=screen>
<p>
<pre>
$multiple[0] = key1\034value1
$multiple[1] = key2\034value2
$multiple[2] = key3\034value3
</PRE>
</DIV>

<p class=para>
Other procedures-<i class=emphasis>print_radio_buttons</I>
and <i class=emphasis>split_responses</I>-split the string on the
"\034" delimiter to access the key and value separately. Since the
<tt>&lt;HINT&gt;</TT> tags do not contain extra parameters,
the array would look like this:

<div class=screen>
<p>
<pre>
$multiple[0] = hint1
$multiple[1] = hint2
$multiple[2] = hint3
</PRE>
</DIV>

<p class=para>
There
is no need to split the values in the array further.

<div class=screen>
<p>
<pre>
    for ($loop=0; $loop &lt;= $#multiple; $loop++) {
        $multiple[$loop] =~ s/^\s*(.*)\b\s*$/$1/;
    }
}
</PRE>
</DIV>

<p class=para>
Finally, leading and
trailing spaces are removed from each element in the array.

<p class=para>
The <i class=emphasis>print_radio_buttons</I> subroutine outputs
form elements to create radio buttons for multiple-choice questions.

<div class=screen>
<p>
<pre>
sub print_radio_buttons
{
    local (*buttons) = @_;
    local ($loop, $letter, $value, $checked, $user_answer);
    if ($QUIZ{'cgi_quiz_form'}) {
        $user_answer = $QUIZ{$variable};
    }
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>user_answer</I>
variable exists only when the quiz is submitted. You might have
noticed that <i class=emphasis>user_answer</I> was defined earlier
in the program. Why is it being defined again? In the main program,
the variable is declared after the <i class=emphasis>print_radio_buttons</I>subroutine is called. As a result, the variable is not
available to this subroutine.

<div class=screen>
<p>
<pre>
    for ($loop=0; $loop &lt;= $#buttons; $loop++) {
        ($letter, $value) = split(/$separator/, $buttons[$loop], 2);
        $letter =~ s/^\s*(.*)\b\s*$/$1/;
        $value =~ s/^\s*(.*)\b\s*$/$1/;
</PRE>
</DIV>

<p class=para>
The
loop iterates through each element of the array, which is stored
in the following format:

<div class=screen>
<p>
<pre>
key1\034value1
</PRE>
</DIV>

<p class=para>
Each element
is split into a separate key and value. Leading and trailing spaces
are removed from the key and value separately. You might wonder
why this has to be done, considering that the <i class=emphasis>split_multiple</I>
subroutine already removed leading and trailing spaces from each
element. The reason is that the key and value, once separated, might
have their own leading and trailing spaces.

<div class=screen>
<p>
<pre>
        if ($user_answer eq $letter) {
            $checked = "CHECKED";
        } else {
            $checked = "";
        }
        print &lt;&lt;Radio_Button;
&lt;INPUT TYPE="radio" NAME="$variable" VALUE="$letter" $checked&gt;
$value&lt;BR&gt;
Radio_Button
    }
}
</PRE>
</DIV>

<p class=para>
When the quiz is submitted,
the program checks the answers, and displays the same quiz with
the user's original answers, along with right/wrong messages. If
the user's answer matches one of the choices, the <tt class=literal>CHECKED</tt>
attribute is specified. As a result, the user-selected radio button-or
multiple choice-is "checked."

<p class=para>
The <i class=emphasis>print_text_field</I>
subroutine displays a text field for fill-in-the-blank questions.
Again, the information that the user typed is displayed if the program
is in correction mode.

<div class=screen>
<p>
<pre>
sub print_text_field
{
    local ($default);
    if ($QUIZ{'cgi_quiz_form'}) {
        $default = $QUIZ{$variable};
    } else {
        $default = "";
    }
    print &lt;&lt;Text_Field;
&lt;INPUT TYPE="text" NAME="$variable" SIZE=50 VALUE="$default"&gt;&lt;BR&gt;
Text_Field
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>print_hints</I> subroutine contains a
loop that iterates through the array, and displays each element
as an unordered list in <tt class=literal>HTML</tt>.

<div class=screen>
<p>
<pre>
sub print_hints
{
    local (*list) = @_;
    local ($loop);
    print "&lt;UL&gt;", "\n";
    for ($loop=0; $loop &lt;= $#list; $loop++) {
        print &lt;&lt;Unordered_List;
&lt;LI&gt;$list[$loop]
Unordered_List
    }
    print "&lt;/UL&gt;", "\n";
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>split_responses</I> subroutine splits
all of the responses stored in the array to create a key and a value.

<div class=screen>
<p>
<pre>
sub split_responses
{
    local (*all, *index, *message) = @_;
    local ($loop, $key, $value);
    for ($loop=0; $loop &lt;= $#all; $loop++) {
        ($key, $value) = split(/$separator/, $all[$loop], 2);
        &amp;format_string(*key);
        $value =~ s/^\s*(.*)\b\s*$/$1/;
		
        $index{$key} = $key;
        $message{$key} = $value;
    }
}
</PRE>
</DIV>

<p class=para>
The
<i class=emphasis>format_string</I> subroutine is called to "format"
the key. Leading and trailing spaces are removed from the value.
Two associative arrays are created: one to store the key and the
other to store the value. Both arrays are indexed by the key.

<p class=para>
The <i class=emphasis>print_form_footer</I> subroutine generates
the end of the form.

<div class=screen>
<p>
<pre>
sub print_form_footer
{
    if (!$QUIZ{'cgi_quiz_form'}) {
        print '&lt;INPUT TYPE="submit" VALUE="Submit Quiz"&gt;';
        print '&lt;INPUT TYPE="reset"  VALUE="Clear Answers"&gt;';
    } else {
	        print &lt;&lt;Status;
Results: $no_correct Correct -- $no_wrong Wrong -- $no_skipped Skipped&lt;BR&gt;
Status
    }
    print "&lt;/FORM&gt;";
}
</PRE>
</DIV>

<p class=para>
If the program is in question mode, the Reset and Submit buttons
are displayed. Otherwise, the results of the quiz are output. The
buttons are not displayed, because you do not want the user to submit
a quiz that has the answers! Finally, the <tt>&lt;/FORM&gt;</TT>
tag is output.

<p class=para>
Believe it or not, we're now finished
with the quiz program. This example truly illustrates the power
of CGI and forms to create an interactive environment.

</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch07_02.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch07_04.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Survey/Poll and Pie Graphs</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Security</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>

</BODY>
</HTML>
