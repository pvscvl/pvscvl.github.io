<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 12] 12.4 Logging and Simulation</TITLE>
<meta name="author" content="Shishir Gundavaram">
<meta name="date" content="Mon Mar 17 13:37:01 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="cgi programming">
<meta name="title" content="CGI Programming on the World Wide Web">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="CGI Programming on the World Wide Web"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch12_03.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 12</b></td>
<td width=172 align=right valign=top><a href="ch12_05.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="CGI-CHP-12-SECT-4">12.4 Logging and Simulation</A></h2>

<p class=para>
At this point, you might be wondering where all
the CGI errors get logged. If you are using the NCSA
server, the log files directory is the place that holds them. You
can manually place debugging messages into the <i class=emphasis>error_log</I>
file by doing the following:

<div class=screen>
<p>
<pre>
print STDERR "Calendar v1.0 - Just about to calculate center", "\n";
$center = ($diameter / 2) + $x_offset;
print STDERR "Calendar v1.0 - Finished calculating. Center = ", $center, "\n";
</PRE>
</DIV>

<p class=para>
After the program is finished, you can look at the log file
to see the various debugging messages. It is a good practice to
insert the name of your program into the message, so you can find
it among all of the different messages logged to the file. Another
trick you can use is to "dupe" (or duplicate) standard error to

standard output:

<div class=screen>
<p>
<pre>
print "Content-type: text/plain", "\n\n";
open (STDERR, "&gt;&amp;" . STDOUT);
print STDERR "About to execute for loop", "\n";
for ($loop=0; $loop &lt;= 10; $loop++) {
    $point[$loop] = ($loop * $center) + $random_number;
    print STDERR "Point number ", $loop, " is ", $point[$loop], "\n";
}
close (STDERR);
</PRE>
</DIV>

<p class=para>
In this case, the errors generated by the CGI program will
go to the browser as well as to the log file.

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-12-SECT-4.1">Client Simulation</A></h3>

<p class=para>
In order to get a good feel for how the
Web works, you should connect to a server and simulate a client's
actions. You can do this by using the 
telnet protocol. Here is an example:

<div class=screen>
<p>
<pre>
% telnet www.ora.com 80
Trying 198.112.208.13 ...
Connected to amber.ora.com.
Escape character is '^]'.
GET / HTTP/1.0
&lt;HTML&gt;&lt;HEAD&gt;
  &lt;TITLE&gt;O'Reilly Home Page&lt;/TITLE&gt;
&lt;/HEAD&gt;&lt;BODY&gt;
&lt;P&gt;&lt;A HREF="http://bin.gnn.com/cgi-bin/imagemap/radio"&gt;
&lt;IMG SRC="/gnn/bus/ora/radio.gif"  ALT="" ISMAP&gt;&lt;/A&gt;
.
. 
.
&lt;/BODY&gt;&lt;/HTML&gt;
Connection closed by foreign host.
</PRE>
</DIV>

<p class=para>
You can enter other HTTP commands as well.
But remember that HTTP is a stateless protocol.
In other words, you can issue only one request, after which the
server terminates the connection. Now let's look at the issues behind
server simulation.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-12-SECT-4.2">Server Simulation</A></h3>

<p class=para>
If you do not have access to a server
on a full-time basis, you can simulate the features of a server
quite easily. Before we look at how this can be accomplished, let's
look briefly at what the server actually does:

<p>
<ul class=itemizedlist>
<li class=listitem>Gets a request from the client to
serve a resource (either a file or a CGI program).

<p>
<li class=listitem>Checks to see if the file is a CGI script.

<p>
<li class=listitem>If it is, passes various environment variables/input
stream to the CGI program, and waits for output.

<p>
<li class=listitem>Sends the output from either a regular file or CGI
to the client.

<p>
</UL>
<p class=para>
In
order to test CGI scripts, all we would have to do is emulate the
third step in this process. Let's look at a typical GET
request. First, we have to create a file to set the environment
variables (e.g., <i class=emphasis>environment.vars</I>). Here is
how you can do it in the C shell:

<div class=screen>
<p>
<pre>
setenv REQUEST_METHOD     'GET'
setenv QUERY_STRING       'name=John%20Surge&amp;company=ABC%20Corporation%21'
setenv HTTP_ACCEPT        'image/gif, image/x-xbitmap, image/jpeg, */*'
setenv SERVER_PROTOCOL    'HTTP/1.0'
setenv REMOTE_ADDR        '198.198.198.198'
setenv DOCUMENT_ROOT      '/usr/local/bin/httpd_1.4.2/public'
setenv GATEWAY_INTERFACE  'CGI/1.1'
setenv REQUEST_METHOD     'GET'
setenv SCRIPT_NAME        '/cgi-bin/abc.pl'
setenv SERVER_SOFTWARE    'NCSA/1.4.2'
setenv REMOTE_HOST        'gateway.cgi.com'
</PRE>
</DIV>

<p class=para>
In a Bourne-compatible
shell (such as Korn shell, bash, or zsh), the previous commands
will not work. Instead, you need the following syntax:

<div class=screen>
<p>
<pre>
export REQUEST_METHOD = 'GET'
export QUERY_STRING =  'name=John%20Surge&amp;company=ABC%20Corporation%21'
.
.
	.
</PRE>
</DIV>

<p class=para>
Then, we have to execute this script with the following command
(assuming the commands are stored in the file <i class=emphasis>environment.vars</I>)
in the C shell:

<div class=screen>
<p>
<pre>
% source environment.vars 
</PRE>
</DIV>

<p class=para>
In a Bourne-compatible shell, you need to do the following:

<div class=screen>
<p>
<pre>
% . environment.vars
</PRE>
</DIV>

<p class=para>
Now,
you can simply run your CGI script, and it should work as though
it was being executed by the server. For POST
requests, the process is slightly different. You first have to create
a file that contains the POST information (e.g.,
<i class=emphasis>post_data.txt</I>):

<div class=screen>
<p>
<pre>
name=John%20Surge&amp;company=ABC%20Corporation%21&amp;sports=Basketball&amp;
exercise=3&amp;runners=no
</PRE>
</DIV>

<p class=para>
Once that is done, you need to determine the content length
(or the size in bytes) of the data. You can do that with the <i class=emphasis>wc</I>
command:

<div class=screen>
<p>
<pre>
% wc -c post_data.txt
   86
</PRE>
</DIV>

<p class=para>
Then you need to add the following two lines to the environment
variable file that we created above (assuming C shell):

<div class=screen>
<p>
<pre>
setenv REQUEST_METHOD     'POST'
setenv CONTENT_LENGTH     '86'
</PRE>
</DIV>

<p class=para>
Now all you have to do is send the data in the file to the
CGI program through a pipe:

<div class=screen>
<p>
<pre>
% /usr/local/bin/httpd_1.4.2/cgi-bin/abc.pl &lt; post_data.txt
</PRE>
</DIV>

<p class=para>
That's all there is to it. The CGI Lint application automates
this procedure, as we will see next.

</DIV>

</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch12_03.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch12_05.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Environment Variables</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>CGI Lint-A Debugging/Testing Tool</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>

</BODY>
</HTML>
