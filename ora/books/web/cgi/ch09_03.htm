<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 9] 9.3 Relational Databases</TITLE>
<meta name="author" content="Shishir Gundavaram">
<meta name="date" content="Mon Mar 17 13:33:46 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="cgi programming">
<meta name="title" content="CGI Programming on the World Wide Web">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="CGI Programming on the World Wide Web"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch09_02.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 9</b></td>
<td width=172 align=right valign=top><a href="ch09_04.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="CGI-CHP-9-SECT-3">9.3 Relational Databases</A></h2>

<p class=para>
So far in this chapter, we
have created pretty simple gateways by piping input to other programs.
As long as we create the proper stream of data, it takes very little
coding on our part to make these work. But the most interesting
uses for gateways involve large, complex sets of data organized
into structured databases. Piping a stream does not work for these;
we need to use a language that the database understands, such as
SQL. This is where we turn in this section.

<p class=para>
By combining the power of relational database management systems
(RDBMS) with the World Wide Web, one can produce
impressive results. Put yourself in the shoes of a doctor who wants
to establish an "interactive, virtual infirmary" on the Web, where
users (patients) can simply enter their symptoms, and the CGI would
return with a diagnosis. The doctor has a large database that contains
extensive data, including three-dimensional graphics and multimedia,
on the various diseases and ailments that affect humans. All that
needs to be done is to write a CGI program that decodes the input,
assembles a query of some sort, sends it to the database, processes
the return data from the database, and creates a hypertext document
(with embedded multimedia) for the user. These types of applications
are possible by combining databases with the Web.

<p class=para>
Before we go any further, let's look at SQL, the query language
used to communicate with various RDBMS systems.

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-9-SECT-3.1">Introduction to SQL</A></h3>

<p class=para>
SQL-pronounced "S Q L" and not
"Sequel"-is a standardized sub-language to access and manipulate
data within a relational database system. The original SQL prototype
defined a "structured" language, thus the term Structured Query
Language, but this is no longer true of the current SQL-92 standard.
SQL was designed specifically to be used in conjunction with a primary
high-level programming language. In fact, most of the basic constructs
that you would find in a high-level language, such as loops and
conditionals, do not exist in SQL.

<p class=para>
Most of the commercial relational database systems in use
today, such as Oracle and Sybase, support SQL. As a result, the
code to access and manipulate a database can be ported easily and
quickly to any platform. Now, let's look at SQL.

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="CGI-CHP-9-SECT-3.1.1">Creating a database</A></h4>

<p class=para>
We will start out
by discussing how a database is created. Suppose you have the following
information:

<div class=informaltable>
<p>
<table class=INFORMALTABLE>
<tr class=row>
<th align="left">

<p class=para>
Player</TH>
<th align="left">

<p class=para>
Years</TH>
<th align="left">

<p class=para>
Points</TH>
<th align="left">

<p class=para>
Rebounds</TH>
<th align="left">

<p class=para>
Assists</TH>
<th align="left">

<p class=para>
Championships</TH>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Larry Bird</TD>
<td align="left">

<p class=para>
12</TD>
<td align="left">

<p class=para>
28</TD>
<td align="left">

<p class=para>
10</TD>
<td align="left">

<p class=para>
7</TD>
<td align="left">

<p class=para>
3</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Michael Jordan</TD>
<td align="left">

<p class=para>
10</TD>
<td align="left">

<p class=para>
33</TD>
<td align="left">

<p class=para>
6</TD>
<td align="left">

<p class=para>
5</TD>
<td align="left">

<p class=para>
3</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Magic Johnson</TD>
<td align="left">

<p class=para>
12</TD>
<td align="left">

<p class=para>
22</TD>
<td align="left">

<p class=para>
7</TD>
<td align="left">

<p class=para>
12</TD>
<td align="left">

<p class=para>
5</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
John Stockton</TD>
<td align="left">

<p class=para>
10</TD>
<td align="left">

<p class=para>
16</TD>
<td align="left">

<p class=para>
3</TD>
<td align="left">

<p class=para>
13</TD>
<td align="left">

<p class=para>
0</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Karl Malone</TD>
<td align="left">

<p class=para>
10</TD>
<td align="left">

<p class=para>
25</TD>
<td align="left">

<p class=para>
11</TD>
<td align="left">

<p class=para>
3</TD>
<td align="left">

<p class=para>
0</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Shaquille O'Neal</TD>
<td align="left">

<p class=para>
2</TD>
<td align="left">

<p class=para>
29</TD>
<td align="left">

<p class=para>
12</TD>
<td align="left">

<p class=para>
3</TD>
<td align="left">

<p class=para>
0</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
The SQL code to create this database is:

<div class=screen>
<p>
<pre>
create table Player_Info
(
    Player            character varying (30) not null,
    Years             integer,
    Points            integer,
    Rebounds          integer,
    Assists           integer,
    Championships     integer
);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>create table</I> command creates a database,
or a table. The <i class=emphasis>Player</I> field is stored as a
non-null varying character string. In other words, if the data in
the field is less than 30 characters, the database will not pad
it with spaces, as it would for a regular character data type. Also,
the database forces the user to enter a value for the <i class=emphasis>Player</I>
field; it cannot be empty.

<p class=para>
The rest of the fields are defined to be integers. Some of
the other valid data types include <i class=emphasis>date</I>, <i class=emphasis>time</I>,
<i class=emphasis>smallint</I>, <i class=emphasis>numeric</I>, and
<i class=emphasis>decimal</I>. The <i class=emphasis>numeric</I> and
<i class=emphasis>decimal</I> data types allow you to specify floating-point
values. For example, if you want a five-digit floating-point number
with a precision to the hundredth place, you can specify <i class=command>decimal
(5, 2)</i>.

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="CGI-CHP-9-SECT-3.1.2">Accessing data</A></h4>

<p class=para>
Let's say you want a list of the entire database. You can
use the following code:

<div class=screen>
<p>
<pre>
select * 
    from Player_Info;
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>select</I> command retrieves specific
information from the database. In this case, all columns are selected
from the <i class=emphasis>Player_Info</I> database. The "*" should
be used with great caution, especially on large databases, as you
might inadvertently extract a lot of information. Notice that we
are dealing only with columns, and not rows. For example, if you
wanted to list all the players in the database, you could do this:

<div class=screen>
<p>
<pre>
select Player
    from Player_Info;
</PRE>
</DIV>

<p class=para>
Now, what if you want to list all the players who scored more
than 25 points? Here is the code needed to accomplish the task:

<div class=screen>
<p>
<pre>
select *
    from Player_Info
    where (Points &gt; 25);
</PRE>
</DIV>

<p class=para>
This would list all the columns for the players who scored
more than 25 points:

<div class=informaltable>
<p>
<table class=INFORMALTABLE>
<tr class=row>
<th align="left">

<p class=para>
Player</TH>
<th align="left">

<p class=para>
Years</TH>
<th align="left">

<p class=para>
Points</TH>
<th align="left">

<p class=para>
Rebounds</TH>
<th align="left">

<p class=para>
Assists</TH>
<th align="left">

<p class=para>
Championships</TH>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Larry Bird</TD>
<td align="left">

<p class=para>
12</TD>
<td align="left">

<p class=para>
28</TD>
<td align="left">

<p class=para>
10</TD>
<td align="left">

<p class=para>
7</TD>
<td align="left">

<p class=para>
3</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Michael Jordan</TD>
<td align="left">

<p class=para>
10</TD>
<td align="left">

<p class=para>
33</TD>
<td align="left">

<p class=para>
6</TD>
<td align="left">

<p class=para>
5</TD>
<td align="left">

<p class=para>
3</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Shaquille O'Neal</TD>
<td align="left">

<p class=para>
2</TD>
<td align="left">

<p class=para>
29</TD>
<td align="left">

<p class=para>
12</TD>
<td align="left">

<p class=para>
3</TD>
<td align="left">

<p class=para>
0</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
But, say you wanted to list just the <i class=emphasis>Player</I>
and <i class=emphasis>Points</I> columns:

<div class=screen>
<p>
<pre>
select Player, Points
    from Player_Info
    where (Points &gt; 25);
</PRE>
</DIV>

<p class=para>
Here is an example that returns all the players who scored
more than 25 points and won a championship:

<div class=screen>
<p>
<pre>
select Player, Points, Championships
    from Player_Info
    where (Points &gt; 25) and
          (Championships &gt; 0);
</PRE>
</DIV>

<p class=para>
The output of this SQL statement would be:

<div class=informaltable>
<p>
<table class=INFORMALTABLE>
<tr class=row>
<th align="left">

<p class=para>
Player</TH>
<th align="left">

<p class=para>
Points</TH>
<th align="left">

<p class=para>
Championships</TH>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Larry Bird</TD>
<td align="left">

<p class=para>
28</TD>
<td align="left">

<p class=para>
3</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Michael Jordan</TD>
<td align="left">

<p class=para>
33</TD>
<td align="left">

<p class=para>
3</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
You could also use wildcards in a select
command. For example, the following will return all the players
that have a last name of "Johnson":

<div class=screen>
<p>
<pre>
select *
    from Player_Info
    where Player LIKE '% Johnson';
</PRE>
</DIV>

<p class=para>
This will match a string ending with "Johnson".

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="CGI-CHP-9-SECT-3.1.3">Updating a database</A></h4>

<p class=para>
Let's suppose that
Shaquille O'Neal won a championship. We need to update our database
to reflect this. This is how it can be done:

<div class=screen>
<p>
<pre>
update Player_Info
    set Championships = 1
    where Player = 'Shaquille O'Neal';
</PRE>
</DIV>

<p class=para>
SQL also has methods to modify entire columns. After every
basketball season, we need to increment the <i class=emphasis>Years</I>
column by one:

<div class=screen>
<p>
<pre>
update Player_Info
    set Years = (Years + 1);
</PRE>
</DIV>

<p class=para>
Now, let's discuss insertion into a table. Say we need to
add another player to the database. We could do it this way:

<div class=screen>
<p>
<pre>
insert into Player_Info
    values
    ('Hakeem Olajuwon', 10, 27, 11, 4, 2);
</PRE>
</DIV>

<p class=para>
As you can see, it is very simple to insert an element into
the table. However, if you have a database with a large number of
columns, and you want to insert a row into the table, you can manually
specify the columns:

<div class=screen>
<p>
<pre>
insert into Player_Info
    (Player, Years, Points, Rebounds, Assists, Championships)
    values
    ('Hakeem Olajuwon', 10, 27, 11, 4, 2);
</PRE>
</DIV>

<p class=para>
When used in this context, the order of the fields does not
necessarily have to match the order in the database, as long as
the fields and the values specified match each other.

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="CGI-CHP-9-SECT-3.1.4">Deleting information</A></h4>

<p class=para>
If you wanted
to delete "John Stockton" from the database, you could do this:

<div class=screen>
<p>
<pre>
delete from Player_Info
    where Player = 'John Stockton';
</PRE>
</DIV>

<p class=para>
SQL also allows you remove entire columns. You should be very
careful when attempting such a move. Instead, it is much safer to
create another database, and copy only the columns you want to the
new database. Here is how you would remove a column:

<div class=screen>
<p>
<pre>
alter table Player_Info
    drop column Championships;
</PRE>
</DIV>

<p class=para>
If you want to delete all the records in the table, the following
statement is used:

<div class=screen>
<p>
<pre>
delete from Player_Info;
</PRE>
</DIV>

<p class=para>
And finally, the <i class=emphasis>drop table</I> command deletes
the entire database:

<div class=screen>
<p>
<pre>
drop table Player_Info;
</PRE>
</DIV>

<p class=para>
(For more information on SQL, see the reference guide on SQL-92
at <a href="../../../../../../../sunsite.doc.ic.ac.uk/packages/perl/db/refinfo/sql2/sql1992.txt">http://sunsite.doc.ic.ac.uk/packages/perl/db/refinfo/sql2/sql1992.txt</A>).

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-9-SECT-3.2">Sprite</A></h3>

<p class=para>
Never heard of 
Sprite?
That is because I developed it for this book. It is a Perl 5 module
that allows you to manipulate text-delimited databases (all data
and delimiters are text) using a small but important subset of SQL-92.
I offer Sprite so you can create your own databases and access them
in CGI scripts, even if you do not have a database product like
Sybase or Oracle. See <a href="appe_01.htm">Appendix E, <i>Applications, Modules, Utilities, and Documentation</i></A> for information on where
you can get Sprite.

<p class=para>
If you do have a commercial product, you can use techniques
like those shown here to issue SQL commands. We will use some Perl
interfaces to Oracle and Sybase later in the chapter. Let's look
at an example.

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="CGI-CHP-9-SECT-3.2.1">Employee database</A></h4>

<p class=para>
Let's assume that you have a text file that contains a list
of your company's employees, as well as some information about them:

<div class=screen>
<p>
<pre>
Last,First,Job_Title,Department,EMail,Phone
Supra,John,System Operator,Systems,jsupra,(617) 555-1578
Painton,Todd,Network Engineer,Systems,tpainton,(617) 555-6530
Martin,Robert,Sales Representative,Sales,martinr,(617) 555-7406
Levine,Julia,Administrative Assistant,Administration,julia,(617) 555-3056
Keenan,Jeff,Manager,Software,jeffk,(617) 555-7769
Nets,Laurie,Group Leader,Development,lnets,(617) 555-9962
</PRE>
</DIV>

<p class=para>
The first line of the file contains the field names (delimited
by commas). This is all you need to use the database. Unlike other
databases that store the data in a unique (and strange) format,
Sprite operates on plain text.

<p class=para>
Here is the form that will act as the front end to the database:

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;CGI Corporation&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Employee Database&lt;/H1&gt;
Welcome to the CGI Corporations's Employee Search Form. You can use
this to find information about one of our employee. 
Enter as much information as possible to narrow down the search. 
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/db_phone.pl" METHOD="POST"&gt;
&lt;PRE&gt;
Last Name:      &lt;INPUT TYPE="text" NAME="Last" SIZE=40&gt;
First Name:     &lt;INPUT TYPE="text" NAME="First" SIZE=40&gt;
Job Title:      &lt;INPUT TYPE="text" NAME="Job_Title" SIZE=40&gt;
Department:     &lt;INPUT TYPE="text" NAME="Department" SIZE=40&gt;
EMail Address:  &lt;INPUT TYPE="text" NAME="EMail" SIZE=40&gt;
Phone Number:   &lt;INPUT TYPE="text" NAME="Phone" SIZE=40&gt;
&lt;/PRE&gt;
&lt;INPUT TYPE="submit" VALUE="Submit the search"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
The form is shown in <a href="#CGI-CHP-9-FIG-5">Figure 9.5</A>.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-5">Figure 9-5: Phone form</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0908.gif" alt="[Graphic: Figure 9-5]" width=410 height=307>

</DIV>

<p class=para>
Now, let's build the CGI application that will decode the
form information, process the user's query, and create a document
displaying the results, as seen in <a href="#CGI-CHP-9-FIG-6">Figure 9.6</A>.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-6">Figure 9-6: CGI gateway to database</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0909.gif" alt="[Graphic: Figure 9-6]" width=428 height=396>

</DIV>

<p class=para>
The program begins:

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl5
use Sprite;
$webmaster = "shishir\@bu\.edu";
$query = undef;
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>use</I>
command instructs Perl to load the module (or extension). You can
load more than one module at a time. For example, if we wanted to
create dynamic GIF images from the data contained in a database,
we would have to load both the <i class=emphasis>GD</I> and the <i class=emphasis>Sprite</I>
modules:

<div class=screen>
<p>
<pre>
use GD;
use Sprite;
</PRE>
</DIV>

<p class=para>
To continue with the program:

<div class=screen>
<p>
<pre>
&amp;parse_form_data(*FORM);
$fields = '(Last|First|Job_Title|Department|EMail|Phone)';
</PRE>
</DIV>

<p class=para>
The form data is decoded. The <i class=emphasis>parse_form_data</I>
subroutine used in this program is the one we've been using throughout
this book. The <i class=emphasis>fields</I> variable contains a list
of all the fields in the form. You might wonder why we would need
to have such a list when then the <i class=emphasis>parse_form_data</I>
subroutine decodes all the fields in the form. The reason for this
is to make sure that only valid fields are processed, as the search
query is dynamically created from the user-specified information.
Remember, forms are very insecure; a cracker can download a form,
edit it, add an extra field, and submit the form to the program.
If the program is not carefully designed, we could have a major
problem!

<div class=screen>
<p>
<pre>
foreach $key (keys %FORM) {
    if ( ($key !~ /\b$fields\b/o) || ($FORM{$key} =~ /[^\w\-\(\) ]/) ) {
        &amp;return_error (500, "CGI Corporation Employee Database Error",
                            "Invalid Information in Form.");
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>foreach</I> construct iterates through
all of the fields stored in the FORM associative array, and checks
for two things, represented by the two expressions separated by
the || operator. First, the field is checked against the list stored
in the <i class=emphasis>fields</I> variable for validity. Second,
it makes sure the information entered by the user is constrained
to the following characters: A-Z, a-z, 0-9, (, ), and the space
character. This ensures that no shell metacharacters are passed.

<div class=screen>
<p>
<pre>
    } else {
        $FORM{$key} =~ s/(\W)/\\$1/g;
        if ($FORM{$key}) {
            $query = join (" and ", $query, "($key =~ /$FORM{$key}/i)");
        }
    }
}
</PRE>
</DIV>

<p class=para>
The conditional is executed if the field is valid. It checks
to see if any information was entered in the field. If there is
information, a query is built by joining each field and value with
"and". You would normally have to escape the "/" character if you
are using the regular expression search in Sprite. In this case,
you don't need to because the user cannot enter "/" in any search
field.

<p class=para>
Once the loop terminates, a query might look something like
the following:

<div class=screen>
<p>
<pre>
and (Last =~ /Martin/i) and (First =~ /Robert/i) and (Department =~ /Sales/i)
</PRE>
</DIV>

<p class=para>
The reason the query has an "and" at the beginning has to
do with the way in which the query was created. If you look back
at the <i class=emphasis>join</I> command, you can see that the information
stored in the <i class=emphasis>query</I> variable is concatenated
to a combination of a key and a value with "and", and is finally
stored in <i class=emphasis>query</I>. Remember, <i class=emphasis>$query</I>
will be undefined the first time through the loop, and thus will
end up with an "and" at the beginning. Let's remove the unwanted
initial string.

<div class=screen>
<p>
<pre>
if ($query) {
    $query =~ s/^ and //;
} else {
    &amp;return_error (500, "CGI Corporation Employee Database Error",
                        "No query was entered.");
}
</PRE>
</DIV>

<p class=para>
If the user failed to enter any information, an error message
is displayed. Otherwise, the "and" at the beginning of the query
is removed to create a normal query:

<div class=screen>
<p>
<pre>
(Last =~ /Martin/i) and (First =~ /Robert/i) and (Department =~ /Sales/i)
</PRE>
</DIV>

<p class=para>
Note that Sprite allows you to use regular expression operators
to search for data. If the user entered "M" in the last name field,
this program instructs the database to return all records that contain
the letter "M" (or "m", as the "i" flag indicates case insensitivity).
There are cases when this is not desirable. In such cases, you would
need to modify the way the query is joined:

<div class=screen>
<p>
<pre>
$FORM{$key} = s/(['"])/\\$1/g;
$query = join (" and ", $query, "($key = '$FORM{$key}')");
</PRE>
</DIV>

<p class=para>
This will return only exact matches. Since the value in the
field is a string, you need to enclose <i class=emphasis>$FORM{$key}</I>
in single quotes and escape all other quotes (or Sprite will return
an error).

<div class=screen>
<p>
<pre>
$rdb = new Sprite ();
$rdb-&gt;set_delimiter ("Read", ",");
</PRE>
</DIV>

<p class=para>
This is some object-oriented Perl syntax that you saw in <a href="ch06_01.htm">Chapter 6, <i>Hypermedia Documents</i></A>. A new database object is
created, and the reference to it is stored in the variable <i class=emphasis>rdb</I>.
The <i class=emphasis>set_delimiter</I> function sets the delimiter
for the data stored in the database. The <i class=emphasis>set_delimiter</I>
function takes two arguments. In the first, we specify that we are
reading from the database. In the second, we specify the comma as
the field delimiter (so we have to know what the data file looks
like).

<div class=screen>
<p>
<pre>
@data = $rdb-&gt;sql (&lt;&lt;End_of_Query);
    select * from phone.db
    where $query
End_of_Query
</PRE>
</DIV>

<p class=para>
The query is passed to Sprite with the sql function. In this case,
a here document is used to pass the query (so it looks readable
to humans). You could just as easily do this:

<div class=screen>
<p>
<pre>
@data = $rdb-&gt;sql ("select * from phone.db where $query");
</PRE>
</DIV>

<p class=para>
Sprite returns the matched records as an array, with all the
fields in each record joined by the null character "\0". However,
the first element of the array is not a record, but a flag indicating
success or failure. For instance, if you passed the following query:

<div class=screen>
<p>
<pre>
select * from phone.db where (Department =~ /Systems/i)
</PRE>
</DIV>

<p class=para>
the array would look like this:

<div class=screen>
<p>
<pre>
$data[0] = 1
$data[1] = Supra\0John\0System Operator\0Systems\0jsupra\0(617) 555-1578
$data[2] = Painton\0Todd\0Network Engineer\0Systems\0tpainton\0(617) 555-6530
</PRE>
</DIV>

<p class=para>
A value of 1 indicates success, while a 0 indicates failure.

<div class=screen>
<p>
<pre>
$status = shift (@data);
$no_elements = scalar (@data);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>shift</I> statement removes the first
element of the array and stores it in the variable <i class=emphasis>status</I>.
Then <i class=emphasis>scalar</I> is used to determine the number
of elements in the array. You can also evaluate the array in a scalar
context, without using the <i class=emphasis>scalar</I> command:

<div class=screen>
<p>
<pre>
$no_elements = @data;
</PRE>
</DIV>

<p class=para>
This is the same as using the <i class=emphasis>scalar</I>
command, but different from:

<div class=screen>
<p>
<pre>
$last_element = $#data;
</PRE>
</DIV>

<p class=para>
This returns the index of the last element of the array (so
in most cases, it would have a value one less than the number of
elements, as arrays are zero-based).

<div class=screen>
<p>
<pre>
if (!$status) {
    &amp;return_error (500, "CGI Corporation Employee Database Error",
                        "Sprite Database Error!");
} elsif (!$no_elements) {
    &amp;return_error (500, "CGI Corporation Employee Database Error",
                        "The record you specified does not exist.");
</PRE>
</DIV>

<p class=para>
Two things are checked: the error status and the number of
records returned by Sprite. If either the status is 0 or no records
were returned, an error is displayed.

<div class=screen>
<p>
<pre>
} else {
    print &lt;&lt;End_of_HTML;
Content-type: text/html
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;CGI Corporation Employee Directory&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;CGI Corporation Employee Directory&lt;/H1&gt;
&lt;HR&gt;&lt;PRE&gt;
End_of_HTML
</PRE>
</DIV>

<p class=para>
This code is executed if valid records were returned by Sprite.
We are now formatting the output for display. One of Perl's original
attractions was the report-generating features it offered; Larry
Wall even said that the "rl" in Perl stood for "Reporting Language."
We will use some of those powerful features here. What we have to
do is create a format and assign it to the <i class=emphasis>$~</I>
variable. Then, whenever we issue a <i class=emphasis>write</I> statement,
Perl will print the data according to the format.

<div class=screen>
<p>
<pre>
    $~ = "HEADING";
    write;
</PRE>
</DIV>

<p class=para>
The "HEADING" format is selected to display header information.

<div class=screen>
<p>
<pre>
    $~ = "EACH_ENTRY";
    foreach (@data) {
         s/([^\w\s\0])/sprintf ("&amp;#%d;", ord ($1))/ge;
        ($last, $first, $job, $department, $email, $phone) =
            split (/\0/, $_, 6);
        write;
    }
    print "&lt;/PRE&gt;", "\n";
    print "&lt;HR&gt;";
		print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";
}
</PRE>
</DIV>

<p class=para>
The "EACH_ENTRY" format is selected to display each record
from the phone database. The <i class=emphasis>foreach</I> loop iterates
through each record, splits it into the different fields, and issues
a <i class=emphasis>write</I> to display the data. Note that no variable
was supplied as part of the <i class=emphasis>foreach</I> loop. Normally,
we would have something like this:

<div class=screen>
<p>
<pre>
foreach $record (@data) {
    .
    .
    .
}
</PRE>
</DIV>

<p class=para>
Since we did not supply a variable, Perl automatically places
it in its default variable: <i class=emphasis>$_</I>.

<div class=screen>
<p>
<pre>
$rdb-&gt;close ();
exit (0);
</PRE>
</DIV>

<p class=para>
Finally, the database is closed, and the script terminates.
Now, let's look at the two format statements:

<div class=screen>
<p>
<pre>
format HEADING = 
Last       First      Job Title      Department   EMail       Phone
----       -----      ---------      ----------   -----       -----
.
</PRE>
</DIV>

<p class=para>
This is a simple one! It is used as a header to display all
of the fields. The period on a line by itself terminates the format.

<div class=screen>
<p>
<pre>
format EACH_ENTRY = 
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$last,     $first,    $job,          $department, $email,     $phone
.
</PRE>
</DIV>

<p class=para>
This one is a little more complex. The "@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"
indicates an eight-character, left-justified field holder. The value
stored in the variable, which is listed below a field holder, is
displayed each time a <i class=emphasis>write</I> is called. This
will allow for a neat and clean display, as shown in <a href="#CGI-CHP-9-FIG-7">Figure 9.7</A>.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-7">Figure 9-7: Phone gateway results</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0910.gif" alt="[Graphic: Figure 9-7]" width=498 height=330>

</DIV>

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="CGI-CHP-9-SECT-3.2.2">Student database</A></h4>

<p class=para>
A CGI program is not limited to just reading information from
a database; it can also manipulate the information. Here is a CGI
program that can read, modify, and delete a database consisting
of student information. Before we go any further, let's look at
the supporting HTML documents:

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Student Database&lt;/H1&gt;
You can use a combination of forms and CGI to access and modify information in
the student database. Please choose one of the following options:
&lt;HR&gt;
&lt;A HREF="/add.html"&gt;Add New Student&lt;/A&gt;&lt;BR&gt;
&lt;A HREF="/modify.html"&gt;Modify Student Information&lt;/A&gt;&lt;BR&gt;
&lt;A HREF="/view.html"&gt;View Student Information&lt;/A&gt;&lt;BR&gt;
&lt;A HREF="/delete.html"&gt;Delete Student&lt;/A&gt;&lt;BR&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
This is the initial document containing links to the various
forms that allow the user to view, add, modify, and delete information
from the student database.

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add New Student&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/student.pl?add" METHOD="POST"&gt;
&lt;PRE&gt;
Student Name:       &lt;INPUT TYPE="text" NAME="Student" SIZE=40&gt;
Year of Graduation: &lt;INPUT TYPE="text" NAME="YOG" SIZE=4 MAXLENGTH=4&gt;
Address (Mailing Information):
&lt;TEXTAREA NAME="Address" ROWS=4 COLS=40&gt;&lt;/TEXTAREA&gt;
&lt;/PRE&gt;
&lt;INPUT TYPE="submit" VALUE="Add New Student"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
This is the form used to add information into the database.
When the user submits this form, a query of "add" is sent to the
CGI program.

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Modify Student Information&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/student.pl?modify_form" METHOD="POST"&gt;
Student Name: &lt;INPUT TYPE="text" NAME="Student" SIZE=40&gt;
&lt;P&gt;
&lt;INPUT TYPE="submit" VALUE="Modify Student Information"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
This form allows the user to modify information for a particular
student. When this form is submitted, the program builds and displays
another form dynamically. Here is the form used to view the results
of a specified query.

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;View Student Information&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/student.pl?view" METHOD="POST"&gt;
Student Name: &lt;INPUT TYPE="text" NAME="Student" SIZE=40&gt;
&lt;P&gt;
Year of Graduation:
&lt;INPUT TYPE="radio" NAME="Sign" VALUE="greater"&gt; Greater Than
&lt;INPUT TYPE="radio" NAME="Sign" VALUE="equal" CHECKED&gt; Equal To
&lt;INPUT TYPE="radio" NAME="Sign" VALUE="less"&gt; Less Than
&lt;INPUT TYPE="text" NAME="YOG" SIZE=4 MAXLENGTH=4&gt;
&lt;P&gt;
Address Information: &lt;INPUT TYPE="text" NAME="Address" SIZE=40&gt;
&lt;P&gt;
&lt;INPUT TYPE="submit" VALUE="View Student Information"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
This form is used to view records that match certain criteria.
The user can select records based on a conditional year of graduation
(either greater than, less than, or equal to a certain year). We
could have just as easily allowed mathematical operators (&gt;, &lt;,
and =) to be entered, but this can be a potential security hole,
as some of them have a special meaning to the shell (i.e., shell
metacharacters). It is far better and safer to use strings like
"equal", "greater", and "less", and let the CGI program convert
them to the appropriate operators when creating a query.

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Delete Student&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/student.pl?delete" METHOD="POST"&gt;
&lt;PRE&gt;
Student Name:       &lt;INPUT TYPE="text" NAME="Student" SIZE=40&gt;
Year of Graduation: &lt;INPUT TYPE="text" NAME="YOG" SIZE=4 MAXLENGTH=4&gt;
&lt;/PRE&gt;
&lt;INPUT TYPE="submit" VALUE="Delete Student"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
A user can use this form to delete information from the database.
In this case, only the student name and year of graduation fields
are presented. Records for an entire class can be deleted by specifying
the year of graduation, and leaving the <i class=emphasis>name</I>
field empty. You should not normally allow such a dangerous option!
However, it is shown here to illustrate the power of databases and
the Web.

<p class=para>
Now, let's look at the CGI program that works with these
forms.

<div class=screen>
<p>
<pre>
#!/usr/local/bin/perl5
use Sprite;
$query_string = $ENV{'QUERY_STRING'};
$script = $ENV{'SCRIPT_NAME'};
$request_method = $ENV{'REQUEST_METHOD'};
$webmaster = "shishir\@bu\.edu";
$database = "/home/shishir/student.db";
$main_form = "/student.html";
$commands = '(add|modify_form|modify|view|delete)';
</PRE>
</DIV>

<p class=para>
The Sprite module
is loaded. The full path to the student database and the relative
path to the main HTML document (the one that
contains links to the other forms) are stored in the <i class=emphasis>database</I>,
and <i class=emphasis>main_form</I> variables, respectively. Finally,
<i class=emphasis>commands</I> contains a list of the valid queries
that forms can pass to this program. If you look carefully at the
list, you will notice that none of the forms listed above passes
the "modify" query. The form that passes this is dynamically created
by this program, as you will later see.

<div class=screen>
<p>
<pre>
$delimiter = "::";
$error = "CGI Student Database Error";
</PRE>
</DIV>

<p class=para>
Fields in the student database are delimited by the "::" characters.

<div class=screen>
<p>
<pre>
if ($query_string =~ /^\b$commands\b$/) {
    &amp;parse_form_data (*DB);
</PRE>
</DIV>

<p class=para>
If the query is valid, the POST form data is decoded and placed
in the <i class=emphasis>DB</I> associative array. (As always, the
<i class=emphasis>parse_form_data</I> subroutine used in this program
is the one we've been using throughout all our examples.)

<div class=screen>
<p>
<pre>
    &amp;check_all_fields ();
    &amp;check_database ();
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>check_all_fields</I> subroutine iterates
through the <i class=emphasis>DB</I> associative array to ensure
that there are no shell metacharacters. The <i class=emphasis>check_database</I>
subroutine checks to see if the student database exists. If not,
a new one is created.

<div class=screen>
<p>
<pre>
    $rdb = new Sprite ();
    $rdb-&gt;set_delimiter ("Read",  $delimiter);
    $rdb-&gt;set_delimiter ("Write", $delimiter);
</PRE>
</DIV>

<p class=para>
A new database object is created. The <i class=emphasis>set_delimiter</I>
function sets the delimiter to be used when reading from and writing
to a database.

<div class=screen>
<p>
<pre>
    $command_status = &amp;$query_string ();
</PRE>
</DIV>

<p class=para>
This is a construct that you may not have seen before. The
subroutine corresponding to the value stored in <i class=emphasis>query_string</I>
is called. It is equivalent to saying:

<div class=screen>
<p>
<pre>
if ($query_string eq "add") {
    $command_status = &amp;add ();
} elsif ($query_string eq "modify_form") {
    $command_status = &amp;modify_form ();
} elsif ($query_string eq "modify") {
    $command_status = &amp;modify ();
} elsif ($query_string eq "view") {
    $command_status = &amp;view ();
} elsif ($query_string eq "delete") {
    $command_status = &amp;delete ();
}
</PRE>
</DIV>

<p class=para>
How convenient! Now, let's continue on with the program.

<div class=screen>
<p>
<pre>
    if ($command_status) {
        $rdb-&gt;close ($database);
        print "Location: ", $main_form, "\n\n";
    } else {
        $rdb-&gt;close ();
    }
</PRE>
</DIV>

<p class=para>
Depending on the status returned from one of the subroutines
above, a server redirect is done with the <i class=command>Location:</i>
header. There is a subtle difference between the two <i class=emphasis>$rdb-&gt;close</I>
subroutines. If you specify a database as part of the <i class=emphasis>close</I>
subroutine, the modifications performed on that database are saved.
Otherwise, the changes are discarded.

<div class=screen>
<p>
<pre>
} else {
    &amp;return_error (500, $error,
                "Invalid command passed through QUERY_STRING.");
}
exit (0);
</PRE>
</DIV>

<p class=para>
If an invalid query was passed to this program, an error is
returned.

<p class=para>
The following subroutine checks to see if the database exists.
If it does not, a new database is created, and a header line containing
the field names, delimited by "::", is output.

<div class=screen>
<p>
<pre>
sub check_database
{
    local ($exclusive_lock, $unlock, $header);
    $exclusive_lock = 2;
    $unlock = 8;
    if (! (-e $database) ) {
        if ( open (DATABASE, "&gt;" . $database) ) {
            flock (DATABASE, $exclusive_lock);
            $header = join ($delimiter, "Student", "YOG", "Address");
            print DATABASE $header, "\n";
            flock (DATABASE, $unlock);
            close (DATABASE);
        } else {
            &amp;return_error (500, $error, "Cannot create new student database.");
        }
    }
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>check_all_fields</I> subroutine makes
sure the form elements do not contain shell meta-characters:

<div class=screen>
<p>
<pre>
sub check_all_fields
{
    local ($key);
    foreach $key (keys %DB) {
        if ($DB{$key} =~ /[`\!;\\\*\\$[amp   ][lt    ][gt    ]]/) {\n              [amp   ]\|return_error (500, $error,
                                  "Invalid characters in the [$key] field.");
        }
    }
}
</PRE>
</DIV>

<p class=para>
The<i class=emphasis> </I>subroutine iterates through the <i class=emphasis>DB</I>
associative array checking to make sure that none of the elements
contains any dangerous shell metacharacters. If any are found, an
error message is displayed.

<div class=screen>
<p>
<pre>
sub build_check_condition
{
    local ($columns) = @_;
    local ($all_fields, $loop, $key, $sign, $sql_condition);
</PRE>
</DIV>

<p class=para>
This is a very useful subroutine that dynamically builds a
query. It expects a string in the following format:

<div class=screen>
<p>
<pre>
"Student,=,Address,=~"
</PRE>
</DIV>

<p class=para>
From this, the following query is constructed (assuming that
the user entered "Ed Surge" in the student field, and "Elm Street"
in the address field):

<div class=screen>
<p>
<pre>
(Student = 'Ed Surge') and (Address =~ 'Elm Street')
</PRE>
</DIV>

<p class=para>
(You might have noticed that the regular expression is not
the usual format ($string =~ /abc/). You are correct! However, Perl
accepts this format as well.)

<div class=screen>
<p>
<pre>
    @all_fields = split (/,/, $columns);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>all_fields</I> array consists of successive
elements of the field name, followed by the operator that should
be used to search that field. In this example, the array would look
like this:

<div class=screen>
<p>
<pre>
$all_fields[0] = "Student";
$all_fields[1] = "=";
$all_fields[2] = "Address";
$all_fields[3] = "=~";
</PRE>
</DIV>

<p class=para>
Now, let's look at the loop that iterates through this array
to build the query.

<div class=screen>
<p>
<pre>
    for ($loop=0; $loop &lt;= $#all_fields; $loop = $loop + 2) {
        $key  = $all_fields[$loop];
        $sign = $all_fields[$loop + 1];
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>key</I> and the <i class=emphasis>sign</I>
variables consist of the field name and the operator, respectively.

<div class=screen>
<p>
<pre>
        if ($DB{$key}) {
            $DB{$key} =~ s/([\W])/\\$1/g;
            $sql_condition = join (" and ", $sql_condition,
                    "( $key $sign '$DB{$key}' )", );
        }
    }
</PRE>
</DIV>

<p class=para>
The query is built in nearly the same manner as in the preceding
example, except that the operator can be different for each field.

<div class=screen>
<p>
<pre>
    if ($sql_condition) {
        $sql_condition =~ s/^ and //;
        return ($sql_condition);
    } else {
        &amp;return_error (500, $error, "No query was entered.");
    }
}
</PRE>
</DIV>

<p class=para>
If the user did not enter any information into the fields,
an error message is displayed. Otherwise, the dynamically created
query is returned (to the subroutine that called).

<p class=para>
This is a very simple subroutine (if you can call it that)
that returns an error.

<div class=screen>
<p>
<pre>
sub database_error
{
    &amp;return_error (500, $error,
        "Sprite database error. Please check the log file.");
}
</PRE>
</DIV>

<p class=para>
The only reason this statement was placed in a subroutine
is for convenience. For example, it is much shorter and quicker
to say:

<div class=screen>
<p>
<pre>
$rdb-&gt;update (&lt;&lt;Update_Command) || &amp;database_error ();
</PRE>
</DIV>

<p class=para>
than to say:

<div class=screen>
<p>
<pre>
$rdb-&gt;update (&lt;&lt;Update_Command) || &amp;return_error (500, $error,
        "Sprite database error. Please check the log file.");
</PRE>
</DIV>

<p class=para>
This is especially true if the same error needs to be returned
for various problems.

<p class=para>
The <i class=emphasis>check_select_command</I> subroutine is
generally used after an SQL "select" statement. It checks the first
element of the returned data, as well as the number of records returned,
and displays an error if either of these values equal 0. Otherwise,
a status of 1 is returned.

<div class=screen>
<p>
<pre>
sub check_select_command
{
    local ($value, $no_elements) = @_;
    if (!$value) {
        &amp;database_error ();
    } elsif (!$no_elements) {
        &amp;return_error (500, $error, 
            "The record you specified does not exist.");
    } else {
        return (1);
    }
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>add</I> subroutine inserts a record into
the database.

<div class=screen>
<p>
<pre>
sub add
{
    $DB{'Address'} =~ s/\n/&lt;BR&gt;/g;
    $DB{'Address'} =~ s/(['"])/\\$1/g;
    $DB{'Student'} =~ s/(['"])/\\$1/g;
    $rdb-&gt;sql (&lt;&lt;End_of_Insert) || &amp;database_error ();
        
insert into $database
    (Student, YOG, Address)
values
    ('$DB{'Student'}', '$DB{'YOG'}', '$DB{'Address'}')
End_of_Insert
    return (1);
}
</PRE>
</DIV>

<p class=para>
All newline characters are converted to "&lt;BR&gt;" and all
single and double quotes are escaped. Remember, all records in a
text-delimited database are delimited by newline characters! This
ensures that the data will be correctly displayed by the browser
when the user decides to view it.

<p class=para>
The format for the "insert" SQL statement is the same as described
in the SQL primer earlier. If the record could not be inserted into
the database, an error is returned. Otherwise, a status of 1 is
returned. This instructs the script to save the database and perform
a server redirect to display the main HTML document.

<p class=para>
Now for the most complicated action-modifying a row.

<div class=screen>
<p>
<pre>
sub modify_form
{
    local (@info, $modify_status, $no_elements, $status);
    $DB{'Student'} =~ s/(['"])/\\$1/g;
    @info = $rdb-&gt;sql (&lt;&lt;End_of_Select);
select * from $database
where (Student = '$DB{'Student'}')
End_of_Select
    $status = shift (@info);
    $no_elements = scalar (@info);
    $modify_status = &amp;check_select_command ($status, $no_elements);
    if ($modify_status) {
        &amp;display_modify_form ($info[0]);
    }
    return (0);
}
</PRE>
</DIV>

<p class=para>
This subroutine performs two actions. First, it uses the student's
name, as specified in the modify form (shown with the other forms
at the beginning of this section), to retrieve the record for that
student. The <i class=emphasis>check_select_command</I> subroutine
ensures that data was returned by the database. Second, <i class=emphasis>display_modify_form</I>
is called (with the first record in the array as an argument) to
display a new form that contains all of the information about the
student. The user can then modify the data in the form and submit
it.

<p class=para>
A status of 0 is returned by this subroutine. As a result,
the database is not saved (which is what we want, since it was not
modified), and no server redirection is performed.

<p class=para>
The <i class=emphasis>display_modify_form</I> subroutine returns
a form for changing a student's record.

<div class=screen>
<p>
<pre>
sub display_modify_form
{
    local ($fields) = @_;
    local ($student, $yog, $address);
    ($student, $yog, $address) = split (/\0/, $fields);
     $address =~ s/&lt;BR&gt;/\n/g;
     $student = &amp;escape_html ($student);
     $yog = &amp;escape_html ($yog);
</PRE>
</DIV>

<p class=para>
The record that is passed to this subroutine by modify_form is split on the
"\0" delimiter, and the "&lt;BR&gt;" characters are converted back
to newlines. In addition, we call the <i class=emphasis>escape_html</I>
subroutine to "escape" characters that have a special significance
to the browser, such as the double quote, "&lt;", "&gt;", and "&amp;".
We perform these steps so that the information is displayed properly.

<div class=screen>
<p>
<pre>
    print &lt;&lt;End_of_Modify_Form;
Content-type: text/html
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Modify Student Information&lt;/H1&gt;
&lt;HR&gt;
&lt;B&gt;Student Name: $student&lt;/B&gt;
&lt;P&gt;
&lt;FORM ACTION="$script?modify" METHOD="POST"&gt;
&lt;INPUT TYPE="hidden" NAME="Student" VALUE="$student"&gt;
Year of Graduation:
&lt;INPUT TYPE="text" NAME="YOG" SIZE=4 MAXLENGTH=4 VALUE="$yog"&gt;
&lt;P&gt;
Address (Mailing Information):
&lt;TEXTAREA NAME="Address" ROWS=4 COLS=40&gt;
$address
&lt;/TEXTAREA&gt;
&lt;P&gt;
&lt;INPUT TYPE="submit" VALUE="Modify Record For: $student"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
End_of_Modify_Form
}
</PRE>
</DIV>

<p class=para>
The form containing the information for the specified student
is output. The user can now modify this form. We use <i class=emphasis>$student</I>
twice: once to remind the user which student was chosen, and once
to pass the name back to this CGI program so it modifies the right
row. The form is shown in <a href="#CGI-CHP-9-FIG-8">Figure 9.8</A>.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-8">Figure 9-8: Modify form</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/cgi0911.gif" alt="[Graphic: Figure 9-8]" width=446 height=368>

</DIV>

<p class=para>
The <i class=emphasis>escape_html</I> subroutine escapes certain
characters so that they are displayed correctly by the browser.

<div class=screen>
<p>
<pre>
sub escape_html
{
    local ($string) = @_;
    local (%html_chars, $html_string);
    
    %html_chars = ('&amp;', '&amp;amp;',
                   '&gt;', '&amp;gt;',
                   '&lt;', '&amp;lt;',
                   '"', '&amp;quot;');
    $html_string = join ("", keys %html_chars);
    $string =~ s/([$html_string])/$html_chars{$1}/go;
    return ($string);
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>view</I> subroutine shows a student's
current record.

<div class=screen>
<p>
<pre>
sub view
{
    local ( $fields, $query, @students, $view_status, $status, $no_elements);
    $fields = 'Student,=,Address,=~';
    if ($DB{'YOG'}) {
        if ($DB{'Sign'} eq 'greater') {
            $DB{'Sign'} = '&gt;';
        } elsif ($DB{'Sign'} eq 'less') {
            $DB{'Sign'} = '&lt;';
        } else {
            $DB{'Sign'} = '=';
        }
        $fields = join (",", $fields, 'YOG', $DB{'Sign'});
    }
    $query = &amp;build_check_condition ($fields);
</PRE>
</DIV>

<p class=para>
If the user entered information into the year of graduation
field, the search operator is determined. This is then appended
to the value stored in the fields
variable. The <i class=emphasis>build_check_condition</I> subroutine
is called to dynamically construct the search query.

<div class=screen>
<p>
<pre>
    @students = $rdb-&gt;sql (&lt;&lt;End_of_Display);
select * from $database
    where $query
End_of_Display
    $status = shift (@students);
    $no_elements = scalar (@students);
    $view_status = &amp;check_select_command ($status, $no_elements);
</PRE>
</DIV>

<p class=para>
The query is passed to the <i class=emphasis>select</I> command.
The information returned by the database is checked for possible
errors. If there are no errors, <i class=emphasis>view_status</I>
contains the value of 1.

<div class=screen>
<p>
<pre>
    if ($view_status) {
        &amp;display_results ("View Students", *students);
    }
    return (0);
}
</PRE>
</DIV>

<p class=para>
If the data returned by the database is valid, the <i class=emphasis>display_results</I>
subroutine is called to display the search results. The two arguments
passed to the subroutine are the header for the HTML
document and the reference to the array that contains the results.

<div class=screen>
<p>
<pre>
sub display_results
{
    local ($title, *data) = @_;
    local ($student, $yog, $address);
    print "Content-type: text/html", "\n";
    print "Pragma: no-cache", "\n\n";
		print "&lt;HTML&gt;", "\n";
    print "&lt;HEAD&gt;&lt;TITLE&gt;CGI Educational Center&lt;/TITLE&gt;&lt;/HEAD&gt;";
		print "&lt;BODY&gt;", "\n";
    print "&lt;H1&gt;", $title, "&lt;/H1&gt;";
    print "&lt;HR&gt;";
</PRE>
</DIV>

<p class=para>
The <i class=command>Content-type:</i> and <i class=command>Pragma:</i>
MIME headers are output. We do not want the browser
to cache the page containing the results. As a result, the displayed
data reflects the true status of the database.

<div class=screen>
<p>
<pre>
    foreach (@data) {
        s/([^\w\s\0])/sprintf ("&amp;#%d;", ord ($1))/ge;
        ($student, $yog, $address) = split ("\0", $_, 3);
        $student = "NULL"                      if (!$student);
        $yog     = "Unknown graduation date"   if (!$yog);
        $address = "No address specified"      if (!$address);
</PRE>
</DIV>

<p class=para>
If any of the fields for a record are null, certain default
values are used, so as not to display empty fields.

<div class=screen>
<p>
<pre>
        $address =~ s/&amp;#60;BR&amp;#62;/&lt;BR&gt;/g;
        print "&lt;BR&gt;", "\n";
        print "&lt;B&gt;", $student, "&lt;/B&gt; ", "($yog)", "&lt;BR&gt;", "\n";
        print $address, "&lt;BR&gt;", "\n";
    }
    print "&lt;HR&gt;", "\n";
		print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>foreach</I> loop iterates through the
matched records, and displays them.

<p class=para>
The <i class=emphasis>delete</I> subroutine removes records
from the database.

<div class=screen>
<p>
<pre>
sub delete
{
    local ($fields, $query);
    $fields = 'Student,=,YOG,=';
    $query = &amp;build_check_condition ($fields);
    $rdb-&gt;sql (&lt;&lt;End_of_Delete) || &amp;database_error ();
delete from $database
    where $query
End_of_Delete
    return (1);
}
</PRE>
</DIV>

<p class=para>
Multiple records can be deleted by leaving the student field
empty, but entering a valid year for the <i class=emphasis>YOG</I>
field. If the specified records cannot be deleted, an error message
is displayed.

<p class=para>
Existing records are modified with the<i class=emphasis> modify </I>subroutine.

<div class=screen>
<p>
<pre>
sub modify
{
    local (@fields, $key);
    @fields = ('YOG', 'Address');
    $DB{'Address'} =~ s/\n/&lt;BR&gt;/g;
    $DB{'YOG'} =~ s/(['"])/\\$1/g;
    $DB{'Student'} =~ s/(['"])/\\$1/g;
    $DB{'Address'} =~ s/(['"])/\\$1/g;
    foreach $key (@fields) {
        $rdb-&gt;sql (&lt;&lt;Update_Database) || &amp;database_error ();
update $database
set $key = ('$DB{$key}') 
where (Student = '$DB{'Student'}');
Update_Database
    }
    return (1);
}
</PRE>
</DIV>

<p class=para>
The current version of Sprite does not support multiple fields
in a <i class=emphasis>update</I> statement. As a result, a loop
is used to update the record multiple times. If the user entered
"1991" in the year of graduation field, and "Elm Street, 02215"
in the address field, the two <i class=emphasis>update</I> statements
are generated:

<div class=screen>
<p>
<pre>
update /home/shishir/student.db
set YOG = ('1991')
where (Student = 'Ed Surge')
update /home/shishir/student.db
set Address = ('Elm Street, 02215')
where (Student = 'Ed Surge')
</PRE>
</DIV>

<p class=para>
That concludes the section on Sprite.

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-9-SECT-3.3">A Gateway to an Oracle Database</A></h3>

<p class=para>
Now, let's
look at CGI gateways to the two most popular commercial databases:
Oracle and Sybase. Each of these is supported by Perl and Tcl extensions
that make our job much easier by letting us submit SQL queries that
the database recognizes. I will use Oracle and Sybase to illustrate
two different ways to display the results of a query. In this section,
I will query an Oracle database and plot the data using <i class=emphasis>gnuplot</I>
(available from <i class=emphasis>ftp://prep.ai.mit.edu/pub/gnu/gnuplot-3.5.tar.gz</I>).
In the next section, I will use Sybase and display the results in
a table using HTML.

<p class=para>
Suppose you have a a database consisting of stock trading
history for various companies over an eleven-year span (from 1980
through 1990). A sample table is shown below:

<div class=informaltable>
<p>
<table class=INFORMALTABLE>
<tr class=row>
<th align="left">

<p class=para>
ID</TH>
<th align="left">

<p class=para>
Company</TH>
<th align="left">

<p class=para>
1980</TH>
<th align="left">

<p class=para>
1981</TH>
<th align="left">

<p class=para>
1982</TH>
<th align="left">

<p class=para>
1983</TH>
<th align="left">

<p class=para>
1984</TH>
<th align="left">

<p class=para>
1985</TH>
<th align="left">

<p class=para>
1986</TH>
<th align="left">

<p class=para>
1987</TH>
<th align="left">

<p class=para>
1988</TH>
<th align="left">

<p class=para>
1989</TH>
<th align="left">

<p class=para>
1990</TH>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Doe</TD>
<td align="left">

<p class=para>
Doe, Inc.</TD>
<td align="left">

<p class=para>
12.1</TD>
<td align="left">

<p class=para>
12.5</TD>
<td align="left">

<p class=para>
13.0</TD>
<td align="left">

<p class=para>
12.7</TD>
<td align="left">

<p class=para>
13.2</TD>
<td align="left">

<p class=para>
14.1</TD>
<td align="left">

<p class=para>
15.7</TD>
<td align="left">

<p class=para>
13.9</TD>
<td align="left">

<p class=para>
14.6</TD>
<td align="left">

<p class=para>
19.3</TD>
<td align="left">

<p class=para>
19.0</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
FaH</TD>
<td align="left">

<p class=para>
Federal Ham.</TD>
<td align="left">

<p class=para>
37.3</TD>
<td align="left">

<p class=para>
40.4</TD>
<td align="left">

<p class=para>
38.2</TD>
<td align="left">

<p class=para>
41.1</TD>
<td align="left">

<p class=para>
42.3</TD>
<td align="left">

<p class=para>
44.4</TD>
<td align="left">

<p class=para>
45.9</TD>
<td align="left">

<p class=para>
45.3</TD>
<td align="left">

<p class=para>
47.9</TD>
<td align="left">

<p class=para>
48.1</TD>
<td align="left">

<p class=para>
50.0</TD>
</TR>
<tr class=row>
<td align="left">

<p class=para>
Max</TD>
<td align="left">

<p class=para>
Max Corp.</TD>
<td align="left">

<p class=para>
73.2</TD>
<td align="left">

<p class=para>
73.9</TD>
<td align="left">

<p class=para>
74.1</TD>
<td align="left">

<p class=para>
74.0</TD>
<td align="left">

<p class=para>
74.7</TD>
<td align="left">

<p class=para>
74.7</TD>
<td align="left">

<p class=para>
76.6</TD>
<td align="left">

<p class=para>
80.3</TD>
<td align="left">

<p class=para>
71.1</TD>
<td align="left">

<p class=para>
59.6</TD>
<td align="left">

<p class=para>
70.3</TD>
</TR>
</TABLE>
<p>
</DIV>

<p class=para>
You would like to present this valuable source of information
as crisp graphs or plots to the general public. How would you go
about doing it? The first step is to create a form where the user
can enter a company's identification:

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Stock Service&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Stock Quotes&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/stocks.pl" METHOD="GET"&gt;
&lt;EM&gt;Please enter the name of the stock that you would like to 
get a quote for:&lt;/EM&gt;
&lt;P&gt;
&lt;INPUT TYPE="text" NAME="Company_ID" SIZE=10 MAXLENGTH=10&gt;
&lt;P&gt;
&lt;INPUT TYPE="submit" VALUE="Look Up This Stock"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
The second step is to write a CGI program that sends the query
to the database, retrieves the results, and utilizes <i class=emphasis>gnuplot</I>
to graph the information. Here is the CGI program that interacts
with the Oracle database using <i class=emphasis>oraperl</I>:

<div class=screen>
<p>
<pre>
#!/usr/local/bin/oraperl
require "oraperl.ph";
</PRE>
</DIV>

<p class=para>
<i class=emphasis>oraperl</I>
is a derivative of Perl that contains functionality to access and
interact with Oracle databases. As of Perl 5, the <i class=emphasis>DBperl</I>
extensions (a.k.a. DBI) supersede most of the Perl 4.0 database
derivatives (such as <i class=emphasis>oraperl</I> and <i class=emphasis>sybperl</I>).
For information on where to get <i class=emphasis>oraperl</I>, <i class=emphasis>syperl</I>,
and <i class=emphasis>DBperl</I>, see <a href="appe_01.htm">Appendix E, <i>Applications, Modules, Utilities, and Documentation</i></A>.

<div class=screen>
<p>
<pre>
$| = 1;
$webmaster = "shishir\@bu\.edu";
$gnuplot = "/usr/local/bin/gnuplot";
$ppmtogif = "/usr/local/bin/pbmplus/ppmtogif";
</PRE>
</DIV>

<p class=para>
Buffering is turned off, and the full path to the <i class=emphasis>gnuplot</I>
and <i class=emphasis>ppmtogif</I> commands is defined. (See <a href="ch06_01.htm">Chapter 6, <i>Hypermedia Documents</i></A> for other examples of how these commands are used.)

<div class=screen>
<p>
<pre>
&amp;parse_form_data (*DB);
($company_id = $DB{'Company_ID'}) =~ s/^\s*(.*)\b\s*$/$1/;
</PRE>
</DIV>

<p class=para>
The form information is decoded. In this case, we are dealing
with only one field (<i class=emphasis>Company_ID</I>). The information
stored in this field is equated to the <i class=emphasis>company_id</I>
variable, and the leading and trailing spaces are removed.

<div class=screen>
<p>
<pre>
if ($company_id =~ /^\w+$/) {
</PRE>
</DIV>

<p class=para>
If the field value is an alphanumeric character (A-Z, a-z,
0-9, _), the program continues. Otherwise, an error message is returned.
We want to make sure that only the characters that we need are allowed!
In this case, shell metacharacters are not allowed to pass through.

<div class=screen>
<p>
<pre>
    $process_id = $$;
    $output_ppm = join ("", "/tmp/", $process_id, ".ppm");
    $data_file =  join ("", "/tmp/", $process_id, ".txt");
</PRE>
</DIV>

<p class=para>
We need two temporary files in this program. To make sure
that each running instance of the program uses unique temporary
files, we borrow a trick from UNIX shell scripting and put our 
process
identification number (PID) into the names. Each time the program
runs, it has to have a unique PID, so we know we will not clobber
our own temporary file. The <i class=emphasis>output_ppm</I> and
<i class=emphasis>data_file</I> variables contain the full file specification
for the temporary files that will be created by this program. The
current process id number ensures unique filenames.

<div class=screen>
<p>
<pre>
    $color_number = 1; 
</PRE>
</DIV>

<p class=para>
The color number of 1 indicates Red. This is the color of
the plot line.

<div class=screen>
<p>
<pre>
    $system_id = "Miscellaneous";
    $username = "shishir";
    $password = "fnjop673e2nB";
</PRE>
</DIV>

<p class=para>
The Oracle 
system identification (SID), the username,
and the password are set. You might wonder if it is safe to hard-code
the database password into this program. The answer to that depends
on how the database is set up. In cases like this, you should create
a generic user, such as "guest," with minimal access rights (read-only),
so that there is no danger to the database.

<div class=screen>
<p>
<pre>
    $lda = &amp;ora_login ($system_id, $username, $password);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>ora_login</I> subroutine is used to log
in to the database. The value returned is the login identifier,
also referred to as the Oracle Login Data Area. This identifier
will be used to execute an SQL command.

<div class=screen>
<p>
<pre>
    $csr = &amp;ora_open ($lda, " select * from Stocks where ID = '$company_id' ");
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>ora_open</I> subroutine executes a specified
SQL command. It requires a login identifier, and returns a statement
identifier or an 
Oracle Cursor.
This statement identifier is needed to retrieve the actual data
(resulting from the SQL command).

<p class=para>
You are not limited to specifying the SQL command on one line;
you can use the block notation:

<div class=screen>
<p>
<pre>
$csr = &amp;ora_open ($lda, &lt;&lt;End_of_Select);
select * from Stocks
where ID = '$company_id'
End_of_Select
</PRE>
</DIV>

<p class=para>
Let's continue with the rest of the program.

<div class=screen>
<p>
<pre>
    if ( open (DATA, "&gt;" . $data_file) ) {
        ($company_id, $company, @stock_prices) = &amp;ora_fetch ($csr);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>ora_fetch</I> subroutine retrieves the
information returned by the SQL <i class=emphasis>select</I> command.
The first two fields (or columns) are stored in <i class=emphasis>company_id</I>
and <i class=emphasis>company</I>, respectively. The rest of the
columns, however, are stored in the <i class=emphasis>stock_prices</I>
array. This consists of the 11 columns representing 11 years, as
shown in the previous table.

<div class=screen>
<p>
<pre>
        &amp;ora_close ($csr);
        &amp;ora_logoff ($lda);
</PRE>
</DIV>

<p class=para>
The statement identifier is released with the <i class=emphasis>ora_close</I>
subroutine, and the database is closed.

<div class=screen>
<p>
<pre>
        if ($company_id) {
</PRE>
</DIV>

<p class=para>
This block of code is executed only if a database record matched
the user's selection. Otherwise, an error message is returned.

<div class=screen>
<p>
<pre>
            $stocks_start = 1980;
            $stocks_end = 1990;
            $stocks_duration = $stocks_end - $stocks_start;
            for ($loop=0; $loop &lt;= $stocks_duration; $loop++) {
                $price = $stock_prices[$loop];
                $year  = $stocks_start + $loop;
                print DATA $year, " ", $price, "\n";
            }
            close (DATA);
</PRE>
</DIV>

<p class=para>
The loop iterates 11 times to create a data file with all
of the year/stock price pairs. For example, here is how the data
file would look like if the user selected "Fah":

<div class=screen>
<p>
<pre>
1980 37.3
1981 40.4
1982 38.2
.
.
.
</PRE>
</DIV>

<p class=para>
When we build our plot, the first column provides data for
the x axis, while the second column provides data for the y axis.

<div class=screen>
<p>
<pre>
            &amp;graph_data ("Stock History for $company", $data_file,
                         "Year", "Price", $color_number, $output_ppm); 
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>graph_data</I> subroutine is called to
create a PBM file (which is later converted to GIF). The arguments
to this subroutine are the title of the graph, the data file to
use, the label for the X axis, the label for the Y axis, the line
color, and the output file.

<div class=screen>
<p>
<pre>
            &amp;create_gif ($output_ppm);
</PRE>
</DIV>

<p class=para>
The final GIF image is created by the <i class=emphasis>create_gif</I>
subroutine, which expects one argument: the name of the PBM file
created by <i class=emphasis>gnuplot</I>.

<div class=screen>
<p>
<pre>
        } else {
            &amp;return_error (500, "Oracle Gateway CGI Error",
                "The specified company could not be found.");
        }
</PRE>
</DIV>

<p class=para>
An error message is displayed if the user selected a non-existent
company name.

<div class=screen>
<p>
<pre>
    } else {
        &amp;return_error (500, "Oracle Gateway CGI Error",
                    "Could not create output file.");
    }
</PRE>
</DIV>

<p class=para>
If the data file could not be created, an error is returned.

<div class=screen>
<p>
<pre>
} else {
    &amp;return_error (500, "Oracle Gateway CGI Error",
                "Invalid characters in company field.");
}
exit (0);
</PRE>
</DIV>

<p class=para>
Finally, if the information in the form field contains any
non-alphanumeric characters, an error message is sent.

<p class=para>
The <i class=emphasis>graph_data</I> subroutine opens a pipe
to the <i class=emphasis>gnuplot</I> numerical analysis program,
and sends a group of format commands through it. The end result
of this is a pbm graphics file, which is later converted to GIF.

<div class=screen>
<p>
<pre>
sub graph_data
{
    local ($title, $file, $x_label, $y_label, $color, $output) = @_;
    open (GNUPLOT, "| $gnuplot");
    print GNUPLOT &lt;&lt;gnuplot_Commands_Done;
    
        set term pbm color small
        set output "$output"
        set title "$title"
        set xlabel "$x_label"
        set ylabel "$y_label"
        set noxzeroaxis
        set noyzeroaxis
        set border
        set nokey
        plot "$file" w lines $color
gnuplot_Commands_Done
    close (GNUPLOT);
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>create_gif</I> subroutine uses the <i class=emphasis>ppmtogif</I>
utility to convert the pbm file to GIF, for display on the Web (see
<a href="#CGI-CHP-9-FIG-9">Figure 9.9</A>).

<div class=screen>
<p>
<pre>
sub create_gif
{
    local ($output) = @_;
    print "Content-type: image/gif", "\n\n";
    system ("$ppmtogif $output 2&gt; /dev/null");
    unlink $output_ppm, $data_file;
}
</PRE>
</DIV>

<p class=para>
Finally, the temporary files are "unlinked," or
 deleted.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-9">Figure 9-9: Stocks graph</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/exp0901.gif" alt="[Graphic: Figure 9-9]" width=502 height=143>

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-9-SECT-3.4">Accessing a Sybase Database</A></h3>

<p class=para>
In this example,
the form input (from the user) is used to access a Sybase database
to look up information on books. Our interface to Sybase is the
<i class=emphasis>sybperl</I> library, which provides Perl subroutines
for giving Sybase queries in the form it can recognize. The data
returned by Sybase is converted to an HTML 3.0
table format. In other words, the output, when displayed on a browser
that recognizes HTML 3.0, resembles a nice table
with solid three-dimensional lines separating the different fields.

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Welcome to CGI Publishing Company&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Book Search&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/books.pl" METHOD="GET"&gt;
&lt;EM&gt;Please enter the name of the book that you would like to look up:&lt;/EM&gt;
&lt;P&gt;
&lt;INPUT TYPE="text" NAME="Book" SIZE=40&gt;
&lt;P&gt;
&lt;INPUT TYPE="submit" VALUE="Look Up This Book"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear the Information"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
Above is the form that is used to retrieve the input from
the user.

<p class=para>
Let's look at the program:

<div class=screen>
<p>
<pre>
#!/usr/local/bin/sybperl
require "sybperl.pl";
$user = "shishir";
$password = "mkhBhd9v2sK";
$server = $ENV{'DSQUERY'} || "Books";
</PRE>
</DIV>

<p class=para>
The user, password, and server name are set. If the environment
variable DSQUERY is defined, the server is set
to the value of that variable. If not, the server is set to "Books".
The following statement:

<div class=screen>
<p>
<pre>
$server = $ENV{'DSQUERY'} || "Books";
</PRE>
</DIV>

<p class=para>
is a simpler of way of doing the following:

<div class=screen>
<p>
<pre>
if ($ENV{'DSQUERY'}) {
    $server = $ENV{'DSQUERY'};
} else {
    $server = "Books";
}
</PRE>
</DIV>

<p class=para>
Next, the <i class=emphasis>dblogin</I> subroutine is used
to log in to the Sybase server.

<div class=screen>
<p>
<pre>
$dbproc = &amp;dblogin ($user, $password, $server);
</PRE>
</DIV>

<p class=para>
<i class=emphasis>dblogin</I> returns the identification for
the newly created database process into the <i class=emphasis>dbproc</I>
variable.

<div class=screen>
<p>
<pre>
@fields = ('Author', 'Book', 'Publisher', 'Year', 'Pages');
$title = "CGI Publishing Company Book Database";
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>fields</I> array holds a list of all
the fields in a record. The <i class=emphasis>title</I> variable
contains the title of the HTML 3.0 table.

<div class=screen>
<p>
<pre>
&amp;parse_form_data (*DB);
($book_name = $DB{'Book'}) =~ s/^\s*(.*)\b\s*$/$1/;
</PRE>
</DIV>

<p class=para>
Leading and trailing spaces are removed from the <i class=emphasis>Book</I>
field.

<div class=screen>
<p>
<pre>
if ($book_name =~ /^[\w\s]+$/) {
</PRE>
</DIV>

<p class=para>
Since we are dealing with book names, the user is allowed
to enter only the following characters: A-Z, a-z, 0-9, _, and whitespace.
If any other characters are entered, an error message is returned.

<p class=para>
To retrieve data from a Sybase database, you attach to the
database, execute a query, and then loop through the returned data
one row at a time. These standard steps are performed in this CGI
application.

<div class=screen>
<p>
<pre>
    &amp;dbcmd ($dbproc, " select * from Catalog where Book = '$book_name' ");
    &amp;dbsqlexec ($dbproc);
    $status = &amp;dbresults ($dbproc);
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>dbcmd</I> subroutine associates the SQL
command with the current database process (dbproc). The dbsqlexec subroutine executes
the SQL command, while the <i class=emphasis>dbresults</I> make the
data available to the program. The <i class=emphasis>dbresults</I>
subroutine returns either "$SUCCEED" or "$FAIL" (these are variables
that are special to <i class=emphasis>sybperl</I>).

<div class=screen>
<p>
<pre>
    if ($status == $SUCCEED) {
        while ( (@books = &amp;dbnextrow ($dbproc)) ) {
            $book_string = join ("\0", @books);
            push (@all_books, $book_string);
        }
</PRE>
</DIV>

<p class=para>
If the user-specified records are found, the <i class=emphasis>dbresults</I>
subroutine returns "$SUCCEED". The <i class=emphasis>while</I>
loop iterates through all of the data by calling the <i class=emphasis>dbnextrow</I>
subroutine each time through the loop, in case there is more than
one book that matches the criteria. The <i class=emphasis>books</I>
array consists of information in the following format (for a sample
book);

<div class=screen>
<p>
<pre>
$books[0] = "Andy Oram and Steve Talbott"
$books[1] = "Managing Projects with make"
$books[2] = "O'Reilly &amp; Associates, Inc."
$books[3] = 1991
$books[4] = 152
</PRE>
</DIV>

<p class=para>
We need to create this intermediate array because that is
the structure of the data returned by <i class=emphasis>dbnextrow</I>.
But what we really want is a single string, because then we could
store all the information on a single book in one element of the
<i class=emphasis>@all_books</I> array. So we use the <i class=emphasis>join</I>
statement to form the following string:

<div class=screen>
<p>
<pre>
$book_string = "Andy Oram and Steve Talbott\0Managing Projects with make\0O'Reilly &amp; Associates, Inc.\01991\0152"
</PRE>
</DIV>

<p class=para>
This string is then pushed into the <i class=emphasis>all_books</I>
array. This process is repeated for all matches.

<div class=screen>
<p>
<pre>
        &amp;dbexit ($dbproc);
        &amp;display_table ($title, *fields, *all_books, "\0");
</PRE>
</DIV>

<p class=para>
The database is closed by calling the <i class=emphasis>dbexit</I>
subroutine. Finally, the table is displayed by calling a generic
subroutine, <i class=emphasis>display_table</I>. The subroutine expects
the following arguments: the title of the table, the array consisting
of the header (or field) names, the array consisting of the strings,
and the delimiter by which these strings are concatenated.

<div class=screen>
<p>
<pre>
    } else {
        &amp;return_error (500, "Sybase Database CGI Error",
            "The book title(s) you specified does not exist.");
    }
} else {
    &amp;return_error (500, "Sybase Database CGI Error",
                "Invalid characters in book name.");
}
exit(0);
</PRE>
</DIV>

<p class=para>
Error messages are returned if either the specified book name
does not exist, or the input contains invalid characters.

<p class=para>
The <i class=emphasis>display_table</I> subroutine prints out
the table.

<div class=screen>
<p>
<pre>
sub display_table
{
    local ($title, *columns, *selected_entries, $delimiter) = @_;
    local ($name, $entry);
    print "Content-type: text/html", "\n\n";
		print "&lt;HTML&gt;", "\n";
    print "&lt;HEAD&gt;&lt;TITLE&gt;", $title, "&lt;/TITLE&gt;&lt;/HEAD&gt;", "\n";
		print "&lt;BODY&gt;", "\n";
    print "&lt;TABLE BORDER=2&gt;", "\n";
    print "&lt;CAPTION&gt;", $title, "&lt;/CAPTION&gt;", "\n";
    print "&lt;TR&gt;", "\n";
</PRE>
</DIV>

<p class=para>
A MIME type of <i class=command>text/html</i>
is output, along with some HTML 3.0 tags to create
a table.

<div class=screen>
<p>
<pre>
    foreach $name (@columns) {
        print "&lt;TH&gt;", $name, "\n";
    }
</PRE>
</DIV>

<p class=para>
This loop iterates through and displays all of the field headers.

<div class=screen>
<p>
<pre>
    foreach $entry (@selected_entries) {
        $entry =~ s/$delimiter/&lt;TD&gt;/go;
        print "&lt;TR&gt;", "&lt;TD&gt;", $entry, "\n";
    }
    print "&lt;/TABLE&gt;", "\n";
		print "&lt;/BODY&gt;&lt;/HTML&gt;", "\n";
}
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>foreach</I> loop iterates through the
matching records, substitutes the delimiter with the 
&lt;TD&gt; tag,
and prints out the HTML needed to create a new
row. There is no delimiter before the first item in <i class=emphasis>$entry</I>,
so the print statement supplies the first &lt;TD&gt; tag. Finally,
the table is closed. <a href="#CGI-CHP-9-FIG-10">Figure 9.10</A> shows what the table looks
 like.

<div class=figure>
<h4 class=figure><a class="TITLE" name="CGI-CHP-9-FIG-10">Figure 9-10: Results of search gateway</A></h4>


<p>
<img aligindex.htmln=middle webstripperattrwas="src" webstripperlinkwas="http://rtfm.vn.ua/prog/perl/orb/books/web/cgi/figs/exp0902.gif" alt="[Graphic: Figure 9-10]" width=502 height=173>

</DIV>

</DIV>

</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch09_02.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch09_04.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Mail Gateway</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Search/Index Gateway</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>

</BODY>
</HTML>
