<!doctype html public "-//ORA//DTD CD HTML 3.2//EN">
<html>
<head>
<title>[Chapter 4] 4.4 Decoding Forms in Other Languages</TITLE>
<meta name="author" content="Shishir Gundavaram">
<meta name="date" content="Mon Mar 17 13:24:19 1997">
<meta name="form" content="html">
<meta name="metadata" content="dublincore.0.1">
<meta name="objecttype" content="book part">
<meta name="otheragent" content="gmat dbtohtml">
<meta name="publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="source" content="SGML">
<meta name="subject" content="cgi programming">
<meta name="title" content="CGI Programming on the World Wide Web">
<!-- JavaScript: pathcont.js -->

</HEAD>
<body bgcolor="#FFFFFF">

<div class=htmlnav>
<h1><img src="gifs/smbanner.gif" alt="CGI Programming on the World Wide Web"></H1>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch04_03.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><b>Chapter 4</b></td>
<td width=172 align=right valign=top><a href="ch05_01.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
</table>
<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
<hr align=left width=515>
</DIV>
<div class=sect1>
<h2 class=sect1><a class="TITLE" name="CGI-CHP-4-SECT-4">4.4 Decoding Forms in Other Languages</A></h2>

<p class=para>
Since Perl contains powerful pattern-matching operators and
string manipulation functions, it is very simple to decode form
information. Unfortunately, this process is not as easy when dealing
with other high-level languages, as most of them lack these kinds
of operators. However, there are various libraries of functions
on the Internet that make the decoding process easier, as well as
the <i class=emphasis>uncgi</I> program (<i class=emphasis>http://www.hyperion.com/~koreth/uncgi.html</I>).

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-4-SECT-4.1">C Shell (csh)</A></h3>

<p class=para>
It
is difficult to decode form information using native C shell commands.
csh was not designed
to perform this type of string manipulation. As a result, you have
to use external programs to achieve the task. The easiest and most
versatile package available for handling form queries is <i class=emphasis>uncgi</I>,
which decodes the form information and stores them in environment
variables that can be accessed not only by <i class=emphasis>csh</I>,
but also by any other language, such as Perl, Tcl, and C/C++. For
example, if the form contains two text fields, named "user" and
"age," <i class=emphasis>uncgi</I> will place the form data in the
variables WWW_user and WWW_age, respectively. Here is a simple form
and a <i class=emphasis>csh</I> CGI script to handle the information:

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Simple C Shell and uncgi Example&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Simple C Shell and uncgi Example&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="/cgi-bin/uncgi/simple.csh" METHOD="POST"&gt;
Enter name: &lt;INPUT TYPE="text" NAME="name" SIZE=40&gt;&lt;BR&gt;
Age: &lt;INPUT TYPE="text" NAME="age" SIZE=3 MAXLENGTH=3&gt;&lt;BR&gt;
What do you like:&lt;BR&gt;
&lt;SELECT NAME="drink" MULTIPLE&gt;
&lt;OPTION&gt;Coffee
&lt;OPTION&gt;Tea
&lt;OPTION&gt;Soft Drink
&lt;OPTION&gt;Alcohol
&lt;OPTION&gt;Milk
&lt;OPTION&gt;Water
&lt;/SELECT&gt;
&lt;P&gt;
&lt;INPUT TYPE="submit" VALUE="Submit the form"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
Notice the URL associated with the ACTION
attribute! It points to the <i class=emphasis>uncgi</I> executable,
with extra path information (your program name). The server executes
<i class=emphasis>uncgi</I>, which then invokes your program based
on the path information. Remember, your program does not necessarily
have to be a csh script;
it can be a program written in any language. Now, let's look at
the program.

<div class=screen>
<p>
<pre>
#!/usr/local/bin/csh
echo "Content-type: text/plain"
echo ""
</PRE>
</DIV>

<p class=para>
The usual header information is printed out.

<div class=screen>
<p>
<pre>
if ($?WWW_name) then
    echo "Hi $WWW_name -- Nice to meet you."
else
    echo "Don't want to tell me your name, huh?"
    echo "I know you are calling in from $REMOTE_HOST."
    echo ""
endif
</PRE>
</DIV>

<p class=para>
<i class=emphasis>uncgi</I> takes the information in the "name"
text entry field and places it in the environment variable WWW_name.

<p class=para>
In <i class=emphasis>csh</I>, environment variables are accessed
by prefixing a "$" to the name (e.g., $REMOTE_HOST).
When checking for the existence of variables, however, you must
use the C shell's $? construct. I use $? in the conditional to check
for the existence of WWW_Name. You cannot check for the existence
of data directly:

<div class=screen>
<p>
<pre>
if ($WWW_name) then
	....
else
	....
endif
</PRE>
</DIV>

<p class=para>
If the user did not enter any data into the "name" text entry
field, <i class=emphasis>uncgi</I> will not set a corresponding environment
variable. If you then try to check for data using the method shown
above, the C shell will give you an error indicating the variable
does not exist.

<p class=para>
The same procedure is applied to the "age" text entry field.

<div class=screen>
<p>
<pre>
if ($?WWW_age) then
    echo "You are $WWW_age years old."
else
    echo "Are you shy about your age?"
endif
echo ""
if ($?WWW_drink) then
    echo "You like: $WWW_drink" | tr '#' ''
else
    echo "I guess you don't like any fluids."
endif
exit(0)
</PRE>
</DIV>

<p class=para>
Here is another important point to remember. Since the form
contains a scrolled list with the multiple selection property, <i class=emphasis>uncgi</I>
will place all the selected values in the variable, separated by
the "
#" symbol. The UNIX
command <i class=emphasis>tr</I> converts the "#" character to the
space character within the variable for viewing purposes.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-4-SECT-4.2">C/C++</A></h3>

<p class=para>
There are a few form decoding
function libraries for C and C++. These include the previously mentioned
<i class=emphasis>uncgi</I>
library, and Enterprise Integration Technologies Corporation's (EIT)
<i class=emphasis>libcgi</I>. Both of them are simple to use.

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="CGI-CHP-4-SECT-4.2.1">C/C++ decoding using uncgi</A></h4>

<p class=para>
Let's look at an example using <i class=emphasis>uncgi</I>
(assuming the HTML form is the same as the one used in the previous
example):

<div class=screen>
<p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</PRE>
</DIV>

<p class=para>
These two
libraries-standard I/O and standard library-are used in the following
program. The <i class=emphasis>getenv</I>
function, used to access environment variables, is declared in <i class=emphasis>stdlib.h</I>.

<div class=screen>
<p>
<pre>
void main (void)
{
    char *name,
         *age,
         *drink,
         *remote_host;
    printf ("Content-type: text/plain\n\n");
	
    uncgi();
</PRE>
</DIV>

<p class=para>
Four variables are declared to store environment variable
data. The <i class=emphasis>uncgi</I> function retrieves the form
information and stores it in environment variables. For example,
a form variable called <i class=emphasis>name</I>, would be stored
in the environment variable WWW_name.

<div class=screen>
<p>
<pre>
    name = getenv ("WWW_name");
    age = getenv ("WWW_age");
    drink = getenv ("WWW_drink");
    remote_host = getenv ("REMOTE_HOST");
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>getenv</I> standard library function
reads the environment variables, and returns a string containing
the appropriate information.

<div class=screen>
<p>
<pre>
    if (name == NULL) {
        printf ("Don't want to tell me your name, huh?\n");
        printf ("I know you are calling in from %s.\n\n", remote_host);
    } else {
        printf ("Hi %s -- Nice to meet you.\n", name);
    }
	
    if (age == NULL) {
        printf ("Are you shy about your age?\n");
    } else {
        printf ("You are %s years old.\n", age);
    }
	
    printf ("\n");
</PRE>
</DIV>

<p class=para>
Depending on the user information in the form, various informational
messages are output.

<div class=screen>
<p>
<pre>
    if (drink == NULL) {
        printf ("I guess you don't like any fluids.\n");
    } else {
        printf ("You like: ");
        
        while (*drink != '\0') {
            if (*drink == '#') {
                printf (" ");
            } else {
                printf ("%c", *drink);
            }
            ++drink;
        }
    
        printf ("\n");
    }
	
    exit(0);
}
</PRE>
</DIV>

<p class=para>
The program checks
each character in order to convert the "#" symbols to spaces. If
the character is a "#" symbol, a space is output. Otherwise, the
character itself is displayed. This process takes up eight lines
of code, and is difficult to implement when compared to Perl. In
Perl, it can be done simply like this:

<div class=screen>
<p>
<pre>
$drink =~ s/#/ /g;
</PRE>
</DIV>

<p class=para>
This example points out one of the major deficiencies of C
for CGI program design: pattern matching.

</DIV>

<div class=sect3>
<h4 class=sect3><a class="TITLE" name="CGI-CHP-4-SECT-4.2.2">C/C++ decoding using libcgi</A></h4>

<p class=para>
Now, let's
look at another example in C. But this time, we will use EIT's <i class=emphasis>libcgi</I>
library, which you can get from <i class=emphasis>http://wsk.eit.com/wsk/dist/doc/libcgi/libcgi.html</I>.

<div class=screen>
<p>
<pre>
#include &lt;stdio.h&gt;
#include "cgi.h"
</PRE>
</DIV>

<p class=para>
The header file <i class=emphasis>cgi.h</I>
contains the prototypes for the functions in the library. Simply
put, the file-like all the other header files-contains a list of
all the functions and their arguments.

<div class=screen>
<p>
<pre>
cgi_main (cgi_info *cgi)
{
    char *name,
         *age,
         *drink,
         *remote_host;
</PRE>
</DIV>

<p class=para>
Notice that there is no main
function in this program. The <i class=emphasis>libcgi</I> library
actually contains the <i class=emphasis>main</I> function, which
fills a struct called <i class=emphasis>cgi_info</I> with environment
variables and data retrieved from the form. It passes this struct
to your <i class=emphasis>cgi_main</I> function. In the function
I've written here, the variable <i class=emphasis>cgi</I> refers
to that struct:

<div class=screen>
<p>
<pre>
    form_entry *form_data;
</PRE>
</DIV>

<p class=para>
The variable type <i class=emphasis>form_entry</I> is a linked
list that is meant to hold key/value pairs, and is defined in the
library. In this program, <i class=emphasis>form_data</I> is declared
to be of type <i class=emphasis>form_entry</I>.

<div class=screen>
<p>
<pre>
    print_mimeheader ("text/plain");
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>print_mimeheader</I> function is used
to output a specific MIME header. Technically,
this function is not any different from doing the following:

<div class=screen>
<p>
<pre>
    print "Content-type: text/plain\n\n";
</PRE>
</DIV>

<p class=para>
However, the function does simplify things a bit, in that
the programmer does not have to worry about accidentally forgetting
to output the two newline characters after the MIME
header.

<div class=screen>
<p>
<pre>
    form_data = get_form_entries (cgi);
    name = parmval (form_data, "name");
    age = parmval (form_data, "age");
    drink = parmval (form_data, "drink");
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>get_form_entries</I> function parses
the <i class=emphasis>cgi</I> struct for form information, and places
it in the variable <i class=emphasis>form_data</I>. The function
takes care of decoding the hexadecimal characters in the input.
The <i class=emphasis>parmval</I> function retrieves the value corresponding
to each form variable (key).

<div class=screen>
<p>
<pre>
    if (name == NULL) {
        printf ("Don't want to tell me your name, huh?\n");
        printf ("I know you are calling in from %s.\n\n", cgi-&gt;remote_host);
    } else {
        printf ("Hi %s -- Nice to meet you.\n", name);
    }
</PRE>
</DIV>

<p class=para>
Notice how the 
REMOTE_HOST
environment variable is accessed. The <i class=emphasis>libcgi</I>
library places all the environment variable information into the
<i class=emphasis>cgi</I> struct.

<p class=para>
Of course, you can still use the <i class=emphasis>getenv</I>
function to retrieve environment information.

<div class=screen>
<p>
<pre>
    if (age == NULL) {
        printf ("Are you shy about your age?\n");
    } else {
        printf ("You are %s years old.\n", age);
    }
	
    printf ("\n");
	
    if (drink == NULL) {
        printf ("I guess you don't like any fluids.\n");
    } else {
        printf ("You like: %s", drink);
        printf ("\n");
    }
	
    free_form_entries (form_data);
    exit(0);
}
</PRE>
</DIV>

<p class=para>
Unfortunately, this library does not handle multiple keys
properly. For example, if the form has multiple checkboxes with
the same variable name, <i class=emphasis>libcgi</I> will return
just one value for a specific key.

<p class=para>
Once the form processing is complete, you should call the
<i class=emphasis>free_form_entries</I> function to remove the linked
list from memory.

<p class=para>
In addition to the functions discussed, libcgi offers numerous other
ones to aid in form processing. One of the functions that you might
find useful is the <i class=emphasis>mcode</I>
function. Here is an example illustrating this function:

<div class=screen>
<p>
<pre>
switch (mcode (cgi)) {
    case MCODE_GET:
        printf("Request Method: GET\n");
        break;
    case MCODE_POST:
        printf("Request Method: POST\n");
        break;
    default:
        printf("Unrecognized method: %s\n", cgi-&gt;request_method);
}                        
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>mcode</I> function reads the REQUEST_METHOD
information from the <i class=emphasis>cgi</I> struct and returns
a code identifying the type of request.

</DIV>

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-4-SECT-4.3">Tcl</A></h3>

<p class=para>
Unlike
C/C++, Tcl does contain semi-efficient pattern matching functions.
These functions can be used to decode form information. However,
according to benchmark test results posted in <i class=emphasis>comp.lang.perl</I>,
the regular expression functions as implemented in Tcl are quite
inefficient, especially when compared to Perl. But you are not limited
to writing form decoding routines in Tcl, because you can still
use <i class=emphasis>uncgi</I>.

<p class=para>
Tcl, like Perl, has been extended to include the <i class=emphasis>
gd</I>
graphics library. In this section, we'll see how Tcl works with
<i class=emphasis>gd</I> graphics, and along the way learn how to
decode input either by invoking <i class=emphasis>uncgi</I> or by
spinning our own Tcl code. We'll write a trivial program to display
color text, just like the Perl program earlier in the chapter.

<div class=screen>
<p>
<pre>
#!/usr/local/bin/gdtcl
puts "Content-type: image/gif\n"
set font_height 16
set font_length 8
set color $env(WWW_color)
</PRE>
</DIV>

<p class=para>
In Tcl, variables are declared with the <i class=emphasis>set</I> command. The font height
and length are set to 16 and 8, respectively. And color is equated
to the environment variable WWW_color-set by <i class=emphasis>uncgi</I>.
The <i class=emphasis>env</I> array is equivalent to Perl's ENV associative
array. The "$" sign instructs Tcl to substitute the value of the
variable. If we did not include the "$" sign, the variable would
be set to the literal string "env(WWW_color)".

<div class=screen>
<p>
<pre>
if {[info exists env(WWW_message)]} {
    set message $env(WWW_message)
} else {
    set message "This is an example of $color text"
}
</PRE>
</DIV>

<p class=para>
This block of code sets the message to be displayed. If the
user submitted a message, the variable message is set to it. Otherwise,
a default message is output.

<p class=para>
For people not familiar with Tcl syntax and commands, the
<i class=emphasis>info</I> command can use some explanation. It has
to appear in square brackets which tell Tcl to execute the command
and pass the return value back to the <i class=emphasis>if</I> command.
<i class=emphasis>info exists</I> checks whether a variable has been
defined, and returns a true or false value.

<div class=screen>
<p>
<pre>
set message_length  [string length $message]
set x  [expr $message_length * $font_length]
set y  $font_height
</PRE>
</DIV>

<p class=para>
Here we determine the width and height of the image, assigning
those values to <i class=emphasis>x</I> and <i class=emphasis>y</I>.
The <i class=emphasis>string
length</I> command determines how many characters are in
the string. This value, temporarily stored in <i class=emphasis>message_length</I>,
must be multiplied by the font length to get the total number of
pixels in the message. To do basic arithmetic, Tcl offers the <i class=emphasis>expr</I>
command.

<div class=screen>
<p>
<pre>
set image  [gd create $x $y]
set white  [gd color new $image 255 255 255]
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>gd
create</I> command requires the user to specify the length
and height of the image. The image is created, and the handle to
it is stored in the variable <i class=emphasis>image</I>. The background
color is set to white. Although the <i class=emphasis>gd</I> commands
in Tcl have a slightly different syntax than those in Perl, their
operation is identical.

<div class=screen>
<p>
<pre>
if {[string compare $color "Red"] == 0} {
    set color_index [list 255 0 0]
} elseif {[string compare $color "Blue"] == 0} {        
    set color_index [list 0 0 255]
} elseif {[string compare $color "Green"] == 0} {
    set color_index [list 0 255 0]
} elseif {[string compare $color "Yellow"] == 0} {
    set color_index [list 255 255 0]
} elseif {[string compare $color "Orange"] == 0} {
    set color_index [list 255 165 0]
} elseif {[string compare $color "Purple"] == 0} {
    set color_index [list 160 32 240]
} elseif {[string compare $color "Brown"] == 0} {
    set color_index [list 165 42 42]
} elseif {[string compare $color "Black"] == 0} {
    set color_index [list 0 0 0]
}
</PRE>
</DIV>

<p class=para>
This is merely a group of if-then-else statements that determine
the RGB color index for the user-selected color. The <i class=emphasis>string
compare</I> function compares its two arguments and returns
either -1, 0, or 1, to indicate that the first argument is greater
than, equal to, or less than the second argument, respectively.

<p class=para>
The color has to be a list of three values, not just a string.
That is the purpose of the <i class=emphasis>list</I> command in
brackets. It creates a list-a construct similar to regular arrays
in Perl-and returns it to the <i class=emphasis>set</I> command,
which assigns the list to the <i class=emphasis>color_index</I> variable.

<div class=screen>
<p>
<pre>
set selected_color  [gd color new $image $color_index]
gd color transparent $image $white
gd text $image $selected_color large 0 0 $env(WWW_message)
gd writeGIF $image stdout   
</PRE>
</DIV>

<p class=para>
The chosen color is selected, and the image background is
made transparent. A message is output at coordinate (0, 0), and
the entire GIF image is sent to standard output.

<div class=screen>
<p>
<pre>
flush stdout
gd destroy $image  
exit 0
</PRE>
</DIV>

<p class=para>
The standard output buffer is flushed before exiting, to ensure
that the entire image is sent to the browser. Finally, the image
handle is destroyed.

<p class=para>
In this program, we've relied on <i class=emphasis>uncgi</I>
to do the hard parsing that Tcl is somewhat weak at. The result
is a simple and fully functional handler for a form. But for people
who want to do everything in Tcl, here is how to decode a form:

<div class=screen>
<p>
<pre>
set webmaster {shishir@bu.edu}
</PRE>
</DIV>

<p class=para>
The variable <i class=emphasis>webmaster</I> is set. Notice
the braces around the expression indicating no variable substitution.

<div class=screen>
<p>
<pre>
proc return_error { status keyword message } {
    global webmaster
    puts "Content-type: text/html"
    puts "Status: $status $keyword\n"
    puts "&lt;title&gt;CGI Program - Unexpected Error&lt;/title&gt;"
    puts "&lt;H1&gt;$keyword&lt;/H1&gt;"
    puts "&lt;HR&gt;$message&lt;/HR&gt;"
    puts "Please contact $webmaster for more information"
}
</PRE>
</DIV>

<p class=para>
The keyword <i class=emphasis>proc</I> is used to define
a procedure. The variables inside the first set of braces represent
the arguments passed by the user. There is a big difference between
Perl subroutines and Tcl procedures. Here are the two ways in which
Tcl is different:

<p>
<ul class=itemizedlist>
<li class=listitem>Global values are not available within
the procedure default. Before referring to a variable from a higher
procedure, you have to declare it with the <i class=emphasis>global</I>
command. You can also affect commands in higher-level procedures
through the <i class=emphasis>upvar</I> command, which we'll look
at in a moment.

<p>
<li class=listitem>All variables declared inside a procedure are considered
local, and are removed after the procedure terminates.

<p>
</UL>
<p class=para>
In this procedure, the global variable <i class=emphasis>webmaster</I>
is used. The procedure puts out an error message that reflects the
arguments passed.

<div class=screen>
<p>
<pre>
proc parse_form_data { form_info } {
    global env
    upvar $form_info FORM_DATA
</PRE>
</DIV>

<p class=para>
The procedure <i class=emphasis>parse_form_data</I> is identical
to its Perl counterpart at the beginning of this chapter. The environment
variable array <i class=emphasis>env</I> is accessed in this procedure
with the <i class=emphasis>global</I> statement. The <i class=emphasis>upvar</I>
keyword allows you to create a local reference to the array passed
to this subroutine. Inside the subroutine, the array referenced
by <i class=emphasis>form_info</I> is accessed through FORM_DATA.

<div class=screen>
<p>
<pre>
    set request_method $env(REQUEST_METHOD)
    if {[string compare $request_method "POST"] == 0} {
        set query_string [read stdin $env(CONTENT_LENGTH)]
    } elseif {[string compare $request_method "GET"] == 0} {
        set query_string $env(QUERY_STRING)
    } else {
        return_error 500 {Server Error} {Server uses unsupported method}
        exit 1
    }
</PRE>
</DIV>

<p class=para>
This process should look familiar. The type of request determines
how form information is loaded into the <i class=emphasis>query_string</I>
variable. If there is an unrecognized method, the procedure <i class=emphasis>return_error</I>
is called with a status of 
500-Server
Error.

<div class=screen>
<p>
<pre>
    set key_value_pairs [split $query_string &amp;]
</PRE>
</DIV>

<p class=para>
The query string is split on the "&amp;" character. If there
are multiple variables-as is the case with most forms-the variable
<i class=emphasis>key_value_pairs</I> will represent a list.

<div class=screen>
<p>
<pre>
    foreach key_value $key_value_pairs {
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>foreach</I> loop structure iterates through
each key-value pair. Notice that there is no "$" sign in front of
the variable <i class=emphasis>key_value</I>. This indicates that
<i class=emphasis>key_value</I> willl be set each time through the
loop. On the other hand, the value of the variable <i class=emphasis>key_value_pairs</I>
will be substituted because of the dollar sign. If there is no dollar
sign in front of <i class=emphasis>key_value_pairs</I>, Tcl will
give you an error indicating that a valid list needs to be specified.
This concept is very important, as many programmers forget the dollar
sign when it is required, and accidentally insert it when it is
not required.

<div class=screen>
<p>
<pre>
        set pair [split $key_value =]
        set key [lindex $pair 0]
        set value [lindex $pair 1]
</PRE>
</DIV>

<p class=para>
The first command divides the key from the value to create
a two-element list. This list is assigned to the variable <i class=emphasis>pair</I>.
Since list indexes start at zero, the key will be in list item zero
and the value in list item 1. We use the <i class=emphasis>lindex</I>
command to extract the key and then the value.

<div class=screen>
<p>
<pre>
        regsub -all {\+} $value { } value
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>regsub</I>
function substitutes characters within a string. This line of code
is equivalent to the following line in Perl:

<div class=screen>
<p>
<pre>
$value =~ s/\+/ /g;
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>-all</I>
switch replaces all occurrences of the pattern within the string.
In this example, Tcl looks for the plus sign (the first argument)
in <i class=emphasis>$value</I> (the second), replaces it with a
space (the third), and writes the information back into the variable
<i class=emphasis>value</I> (the fourth). You may be confused because
the first value has
a dollar sign while the second does not. This is because the first
time around Tcl is dereferencing the variable-taking input data
from it. The second time, it is storing output back into the variable,
an operation that requires you to specify the variable directly
rather than dereference it.

<div class=screen>
<p>
<pre>
        while {[regexp {%[0-9A-Fa-f][0-9A-Fa-f]} $value matched]} {
            scan $matched "%%%x" hex
            set symbol [ctype char $hex]
            regsub -all $matched $value $symbol value
        }
</PRE>
</DIV>

<p class=para>
This <i class=emphasis>while</I> loop decodes the hexadecimal
characters. The <i class=emphasis>regexp</I> command is used to search
<i class=emphasis>value</I> for the pattern "%..", which signifies
a three-character string starting with the "%" character. The matched
string is placed in the variable <i class=emphasis>matched</I>. This
is like using parentheses in a regular expression to isolate and
mark a group of characters, but the syntax is simpler. The first
string that matches %.. gets assigned to <i class=emphasis>matched</I>.
Then, the <i class=emphasis>scan</I> command with the "%%%x" argument
converts the hexadecimal number to a decimal number. The <i class=emphasis>ctype
char</I> command converts the decimal number to its ASCII
equivalent. Finally, <i class=emphasis>regsub</I> replaces the hexadecimal
string with the ASCII character. This process is quite tedious,
especially when we compare it to Perl:

<div class=screen>
<p>
<pre>
$value =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;
</PRE>
</DIV>

<p class=para>
Now, let's look at the final part of the program:

<div class=screen>
<p>
<pre>
        if {[info exists FORM_DATA($key)]} {
            append FORM_DATA($key) "\0" $FORM_DATA($key)
        } else {
            set FORM_DATA($key) $value
        }                
    }
}
</PRE>
</DIV>

<p class=para>
Remember that we started this procedure by assigning FORM_DATA
to whatever variable is passed to the procedure. Now we create an
entry in FORM_DATA for every key, the key being
used as an index into the array. The value becomes the data that
the key points to. By checking for an existing key with an if statement,
we allow form variables to have multiple values, which is necessary
for scrolled lists and multiple checkboxes. As in our Perl version,
we put multiple values into a single array element with a null character
in between.

<p class=para>
Now, how do we call these procedures? Suppose you have two
fields on your form-<i class=emphasis>name</I> and <i class=emphasis>age</I>.
You could access these variables by doing the following:

<div class=screen>
<p>
<pre>
parse_form_data simple_form
puts "Your name is: $simple_form(name) and your age is: $simple_form(age)"
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>parse_form_data</I> procedure takes the
form information and places it in the <i class=emphasis>simple_form</I>
array. You can then look at and manipulate data in <i class=emphasis>simple_form</I>
just like any other array.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-4-SECT-4.4">Visual Basic</A></h3>

<p class=para>
As
we discussed in <a href="ch02_01.htm">Chapter 2, <i>Input to the Common Gateway Interface</i></A>, the WebSite
server for Windows NT and Windows 95-as well as the Windows 3.1
HTTP server-passes form information to the CGI
program through a Windows profile file. The developer, Bob Denny,
designed a library for decoding form information in Visual Basic.
Let's use this library to decode some forms. But first, here is
the HTML code for creating the form:

<div class=screen>
<p>
<pre>
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Health/Exercise Survey&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Health/Exercise Survey&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM ACTION="\cgi-win\exercise.exe" METHOD="POST"&gt;
&lt;EM&gt;What is your name?&lt;/EM&gt;&lt;BR&gt;
&lt;INPUT TYPE="text" NAME="name" SIZE=40&gt;&lt;BR&gt;
&lt;P&gt;
&lt;EM&gt;Do you exercise regularly?&lt;/EM&gt;&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="regular" VALUE="Yes"&gt;Yes&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="regular" VALUE="No"&gt;No&lt;BR&gt;
&lt;P&gt;
&lt;EM&gt;Why do you exercise?&lt;/EM&gt;&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="why" VALUE="health"&gt;Health Benefits&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="why" VALUE="athlete"&gt;Athletic Training&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="why" VALUE="forced"&gt;Forced upon you&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="why" VALUE="enjoy"&gt;Enjoyment&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="why" VALUE="other"&gt;Other reasons&lt;BR&gt;
&lt;P&gt;
&lt;EM&gt;What sport do you &lt;B&gt;primarily&lt;/B&gt; participate in?&lt;/EM&gt;&lt;BR&gt;
&lt;SELECT NAME="sports" SIZE=1&gt;
&lt;OPTION&gt;Tennis
&lt;OPTION&gt;Swimming
&lt;OPTION&gt;Basketball
&lt;OPTION&gt;Running/Walking
&lt;OPTION&gt;Cycling
&lt;OPTION&gt;Skating/Rollerblading
&lt;OPTION&gt;Skiing
&lt;OPTION&gt;Climbing Stairs
&lt;OPTION&gt;Jumping Rope
&lt;OPTION&gt;Other
&lt;/SELECT&gt;
&lt;P&gt;
&lt;EM&gt;How often do you exercise?&lt;/EM&gt;&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="interval" VALUE="0"&gt;Not at all&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="interval" VALUE="1"&gt;Once a week&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="interval" VALUE="3"&gt;Three times a week&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="interval" VALUE="5"&gt;Five times a week&lt;BR&gt;
&lt;INPUT TYPE="radio" NAME="interval" VALUE="7"&gt;Every day of the week&lt;BR&gt;
&lt;P&gt;
&lt;INPUT TYPE="submit" VALUE="Submit the form"&gt;
&lt;INPUT TYPE="reset"  VALUE="Clear all fields"&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</DIV>

<p class=para>
Now let's build a Visual Basic CGI program to decode the form
information and store the results in a data file. The program needs
to be compiled before it can be used.

<div class=screen>
<p>
<pre>
Public Sub CGI_Main()
</PRE>
</DIV>

<p class=para>
This program uses the <i class=emphasis>CGI.BAS</I>
library to decode the form information. The function <i class=emphasis>Main()</I>, which
in turn calls the <i class=emphasis>CGI_Main()</I>,
is defined in the library.

<div class=screen>
<p>
<pre>
    Dim intCtr As Integer
    Dim intFN As String
    Dim message As String
</PRE>
</DIV>

<p class=para>
We define three variables that we will use later in the program:
<i class=emphasis>intCtr</I>, <i class=emphasis>intFN</I>, and <i class=emphasis>message</I>.

<div class=screen>
<p>
<pre>
    intFN = FreeFile
    Open "survey.dat" for APPEND as #intFN
</PRE>
</DIV>

<p class=para>
The variable <i class=emphasis>intFN</I> holds an unused file handle,
thanks to the <i class=emphasis>FreeFile</I> function. We then proceed
to use this handle to open the file "survey.dat" in append mode;
if the file does not exist, it is created.

<div class=screen>
<p>
<pre>
    Print #intFN, "Results from " &amp; CGI_RemoteHost
    Print #intFN, "-----&lt; Start of Data &gt;-----"
</PRE>
</DIV>

<p class=para>
Information is output to the file by specifying the file handle
with the Print statement. Visual Basic is a case-insensitive language-unlike
most of the languages we have discussed so far. The variable <i class=emphasis>CGI_RemoteHost</I>
represents the environment variable REMOTE_HOST.

<div class=screen>
<p>
<pre>
    For intCtr = 0 To CGI_NumFormTuples - 1
       Select Case CGI_FormTuples(intCtr).key
          Case "name"
             message = "Subject name: "
          Case "regular"
             message = "Regular exercise: "
          Case "why"
             message = "Reason for exercise: "
          Case "sports"
             message = "Primarily participates in: "
          Case "interval"
             message = "Exercise frequency: "
       End Select
       Print #intFN, message &amp; CGI_FormTuples(intCtr).value
    Next  
</PRE>
</DIV>

<p class=para>
Unlike Perl or Tcl, Visual Basic does not have support for
arrays with string indexes. As a result, you cannot have an "array(key)
= value" construct. Instead, the form values are placed in a simple
struct, such that the key and the value share the same numerical
index.

<p class=para>
In this case, the integer variable <i class=emphasis>CGI_NumFormTuples</I>
represents the number of key-value pairs. The loop iterates through
each pair and outputs a message based on the value of the key. The
key and value are stored in <i class=emphasis>CGI_FormTuples(index).key</I>
and <i class=emphasis>CGI_FormTuples(index)</I>.value, respectively.

<div class=screen>
<p>
<pre>
    Print #intFN, "-----&lt; End of Data &gt;-----"
    Close #intFN
</PRE>
</DIV>

<p class=para>
The end-of-data message is output to the file, and the file
is closed.

<div class=screen>
<p>
<pre>
    Send ("Content-type: text/html")
    Send ("")
    Send ("&lt;TITLE&gt;Thanks for filling out the survey!&lt;/TITLE&gt;")
    Send ("&lt;H1&gt;Thank You!&lt;/H1&gt;")
    Send ("&lt;HR&gt;")
    Send ("Thanks for taking the time to fill out the form.")
    Send ("We really appreciate it!")
End Sub
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>Send</I> function is used to output text
to the server. It prints the message you specify to the file handle
represented by the server.

</DIV>

<div class=sect2>
<h3 class=sect2><a class="TITLE" name="CGI-CHP-4-SECT-4.5">AppleScript</A></h3>

<p class=para>
On
the Macintosh, you can use either AppleScript or MacPerl to write
CGI applications. Since we've looked at enough Perl examples, let's
write an example in AppleScript. There are two main reasons for
using AppleScript for CGI applications. First, it is quite easy
to use, and the syntax looks like plain English. And second, many
libraries have been designed to aid in CGI application development.
Now, here is an AppleScript program that accomplishes the same task
as the Visual Basic example presented earlier.

<div class=screen>
<p>
<pre>
set survey_file to "Macintosh HD:survey.dat"
</PRE>
</DIV>

<p class=para>
The variable <i class=emphasis>survey_file</I> contains the
path to the data file. This syntax is equal to:

<div class=screen>
<p>
<pre>
survey_file = "Macintosh HD:survey.dat"
</PRE>
</DIV>

<p class=para>
The "
:"
character is the directory separator on the Mac, just as UNIX
uses a slash and Windows uses a backslash.

<div class=screen>
<p>
<pre>
set crlf to (ASCII character 13) &amp; (ASCII character 10)
set http_header to 	"HTTP/1.0 200 OK" &amp; crlf &amp; -
                    "Server: WebSTAR/1.0 ID/ACGI" &amp; crlf &amp; -
                    "MIME-Version: 1.0" &amp; crlf &amp; -
				       "Content-type: text/html" &amp; -
                    crlf &amp; crlf
</PRE>
</DIV>

<p class=para>
The HTTP header that we will send to the
server is defined. Notice that this is a complete response. The

WebSTAR server requires that
all CGI applications send a complete response. You might also be
wondering why the regular newline character (\n) is not used to
separate individual lines. The official HTTP
specification requires that servers send "\r\n", but most UNIX
browsers accept "\n", while WebSTAR does not.

<div class=screen>
<p>
<pre>
on `event WWWsdoc' path_args -
    given `class post':post_args, `class add':client_address
</PRE>
</DIV>

<p class=para>
As explained in <a href="ch02_01.htm">Chapter 2, <i>Input to the Common Gateway Interface</i></A>, this
construct is used to check for an AppleEvent from WebSTAR, and to
set the appropriate variables. Not all the information sent with
the AppleEvent is stored in variables, however, as this program
does not require most of the information. The only data that we
need is the form data-passed as "POST"-and the
remote address of the client.

<div class=screen>
<p>
<pre>
    set post_args_without_plus to dePlus post_args
    set decoded_post_args to Decode URL post_args_without_plus
</PRE>
</DIV>

<p class=para>
All the "+" signs in the form data are converted to spaces
using the dePlus 
osax (Open Scripting Architecture eXtension)-which
is an external program written in a high-level language, such as
C. Technically, you can also accomplish the task in AppleScript,
but using an osax is more efficient. Also, the form data is decoded
using the Decode URL osax, and stored in <i class=emphasis>decoded_post_args</I>.

<div class=screen>
<p>
<pre>
    set name 	   to findNamedArgument(decoded_post_args, "name")
    set regular  to findNamedArgument(decoded_post_args, "regular")
    set why 	    to findNamedArgument(decoded_post_args, "why")
    set sports 	 to findNamedArgument(decoded_post_args, "sports")
    set interval to findNamedArgument(decoded_post_args, "interval")
</PRE>
</DIV>

<p class=para>
The <i class=emphasis>findNamedArgument</I> function retrieves
the form information for a specific field. All of the fields that
comprise the form are separated and stored.

<div class=screen>
<p>
<pre>
    try
        set survey_file_handle to open file alias survey_file
        position file survey_file at (get file length survey_file)
    on error
        create file survey_file owner "ttxt"
        set survey_file_handle to open file alias survey_file
    end try
</PRE>
</DIV>

<p class=para>
These statements set up an error handler. AppleScript will
try to execute the commands in the first block, but if an error
occurs, the commands in the next block will be executed. Initially,
the program tries to open the data file and store the file handle
in <i class=emphasis>survey_file_handle</I>. If it is successful,
the <i class=emphasis>position</I> command places the pointer at
the end of the file. On the other hand, if there is an error, a
new file is created and opened. The owner of the new file is set
to 
TeachText
("ttxt")-a simple Macintosh file editor-so that it can be read by
any text editor.

<div class=screen>
<p>
<pre>
    set survey_output to "Results from " &amp; client_address &amp; crlf &amp; -
                         "-----&lt; Start of Data &gt;-----" &amp; crlf &amp; -
                         "Subject name: " &amp; name &amp; crlf &amp; -
                         "Regular exercise: " &amp; regular &amp; crlf &amp; -
                         "Reason for exercise: " &amp; why &amp; crlf &amp; -
                         "Primarily participates in: " &amp; -
						   sports &amp; crlf &amp; -
                         "Exercise frequency: " &amp; interval &amp; crlf &amp; -
                         "-----&lt; End of Data &gt;-----" &amp; crlf
</PRE>
</DIV>

<p class=para>
The information that will be written to the data file is built,
and stored in <i class=emphasis>survey_output</I>.

<div class=screen>
<p>
<pre>
    write file survey_file_handle text survey_output
    close file survey_file_handle
</PRE>
</DIV>

<p class=para>
The information is written to the file as text, and the file
is closed.

<div class=screen>
<p>
<pre>
    set thank_you to http_header &amp; -
                "&lt;TITLE&gt;Thanks for filling out the survey!&lt;/TITLE&gt;" &amp; -
                "&lt;H1&gt;Thank You!&lt;/H1&gt;" &amp; "&lt;HR&gt;" &amp; -
                "Thanks for taking the time to fill out the form." &amp; -
                "We really appreciate it!"
    return thank_you
end `event WWWsdoc'
</PRE>
</DIV>

<p class=para>
Finally, the return statement sends the thank-you message
back to the client.

<div class=screen>
<p>
<pre>
on findNamedArgument(theText, theArg)
    try
        set oldDelims to AppleScript's text item delimiters
        set AppleScript's text item delimiters to "&amp;"
        set numItems to (count of text items in theText)
        
        repeat with textCount from 1 to numItems
            set thisItem to text item textCount of theText
            try
                set AppleScript's text item delimiters to "="
				            set argName to (first text item of thisItem)
				            if argName = theArg then
                    set resItem to (second text item of thisItem)
                    exit repeat
				            else
					                set resItem to ""
				            end if
				            set AppleScript's text item delimiters to "&amp;"
            on error
				            set AppleScript's text item delimiters to "&amp;"
            end try
        end repeat
		
        set AppleScript's text item delimiters to oldDelims
    on error
        set AppleScript's text item delimiters to oldDelims
        set resItem to ""
    end try
    return resItem
end findNamedArgument
</PRE>
</DIV>

<p class=para>
This function iterates through the form information and returns
the value for a specified key. It was written by Maggie 
Burke (mburke@umassd.edu)
from the Integrated Math Tools Project. Do not worry about how this
works at this moment. Doesn't it look like English?

<p class=para>
In reality, splitting a key-value pair using this function
is not the most efficient way to accomplish the task; every time
you call the function, it has to iterate through the information
until it finds the specified key.

</DIV>

</DIV>


<div class=htmlnav>

<p>
<hr align=left width=515>
<table width=515 border=0 cellpadding=0 cellspacing=0>
<tr>
<td width=172 align=left valign=top><a href="ch04_03.htm"><img src="gifs/txtpreva.gif" alt="Previous" border=0></A></td>
<td width=171 align=center valign=top><a href="index.htm"><img src="gifs/txthome.gif" alt="Home" border=0></a></td>
<td width=172 align=right valign=top><a href="ch05_01.htm"><img src="gifs/txtnexta.gif" alt="Next" border=0></A></td>
</tr>
<tr>
<td width=172 align=left valign=top>Designing Applications Using Forms in Perl</td>
<td width=171 align=center valign=top><a href="index/idx_0.htm">Book Index</a></td>
<td width=172 align=right valign=top>Server Side Includes</td>
</tr>
</table>

<!-- JavaScript: prev.js -->
&nbsp;
<!-- JavaScript: next.js -->
</DIV>

</BODY>
</HTML>
