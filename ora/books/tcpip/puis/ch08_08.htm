<html><head>
<title>[Chapter 8] 8.8 Administrative Techniques for Conventional Passwords</TITLE>
<meta name="DC.title" content="Practical UNIX &amp; Internet Security"><meta name="DC.creator" content="Simson Garfinkel &amp; Gene Spafford"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T00:06:21Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-148-8" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch08_01.htm" title="8. Defending  Your Accounts"><link rel="prev" href="ch08_07.htm#PUIS-CHP-8-SECT-7.3" title="8.7 One-Time Passwords"><link rel="next" href="ch09_01.htm" title="9. Integrity Management"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Practical UNIX &amp; Internet Security" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Practical UNIX &amp; Internet Security"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch08_07.htm#PUIS-CHP-8-SECT-7.3" title="8.7 One-Time Passwords"><img src="../gifs/txtpreva.gif" alt="Previous: 8.7 One-Time Passwords" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 8<br>Defending  Your Accounts</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="CHAPTER" href="ch09_01.htm" title="9. Integrity Management"><img src="../gifs/txtnexta.gif" alt="Next: 9. Integrity Management" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PUIS-CHP-8-SECT-8">8.8 Administrative Techniques for Conventional Passwords</A
></H2
><p class="para">If you're a <a class="indexterm" name="AUTOID-11421"></A
><a class="indexterm" name="AUTOID-11424"></A
>
system
administrator and you are stuck using conventional <span class="acronym">UNIX</SPAN
>
passwords, then you will find this section helpful. It describes
a number of techniques that you can use to limit the danger of conventional
passwords on your computer.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.1">8.8.1 Assigning Passwords to Users</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11431"></A
><a class="indexterm" name="AUTOID-11434"></A
>Getting users to pick good passwords can be
very difficult. You can tell users horror stories and you can threaten
them, but some users will always pick easy-to-guess passwords. Because
a single user with a bad password can compromise the security of
the entire system, some <span class="acronym">UNIX</SPAN
> administrators assign
passwords to users directly rather than letting users choose their
own.</P
><p class="para">To prevent users from changing their own passwords, all that
you have to do is to change the permissions on the <i class="filename">/bin/passwd</I
>
program that changes people's passwords.[14] Making
the program executable only by people in the staff group, for example,
will still allow staff members to change their own passwords, but
will prevent other people from doing so:</P
><blockquote class="footnote"><p class="para">[14] This
technique requires changing permissions on any other password-changing
software, such as yppasswd and nispasswd.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen"># chgrp staff /bin/passwd
# chmod 4750 /bin/passwd&#13;</PRE
></BLOCKQUOTE
><p class="para">Use this approach only if staff members are available 24 hours
a day. Otherwise, if a user discovers that someone has been using
her account, or if she accidentally discloses her password, the
user is powerless to safeguard the account until she has contacted
someone on staff.</P
><p class="para">Some versions of <span class="acronym">UNIX</SPAN
> may have an administrator
command that will allow you to prevent selected users from changing
their passwords.[15]
Thus, you do not need to change the permissions on the passwd program.
You only need to disable the capability for those users who cannot
be trusted to set good passwords on their own.</P
><blockquote class="footnote"><p class="para">[15] On AIX, the root user can prevent
ordinary users from changing their passwords by running the following:
pwdadm -f ADMIN user or by editing /etc/security/passwd.</P
></BLOCKQUOTE
><p class="para">For example, in <span class="acronym">SVR4</SPAN
> <span class="acronym">UNIX</SPAN
>,
you can prevent a user from changing her password by setting the
aging parameters appropriately (we discuss <i class="firstterm">password aging</I
>
in a few more pages). For example, to prevent Kevin from changing
his password, you might use the command:</P
><blockquote class="screen"><pre class="screen"># <kbd class="command">passwd -n 60 -x 50 kevin</KBD
></PRE
></BLOCKQUOTE
><p class="para">Note, however, that Kevin's password will expire
in 50 days and will need to be reset by someone with superuser access.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.2">8.8.2 Constraining Passwords</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11458"></A
><a class="indexterm" name="AUTOID-11461"></A
>You
can easily strengthen the <kbd class="command">passwd</KBD
> program to disallow users from
picking easy-to-guess passwords&nbsp;- such as those based on
the user's own name, other accounts on the system, or on
a word in the <span class="acronym">UNIX</SPAN
> dictionary. So far, however,
many <span class="acronym">UNIX</SPAN
> vendors have not made the necessary
modifications to their software. There are some freeware packages
available on the net, including <a class="indexterm" name="AUTOID-11466"></A
><a class="indexterm" name="AUTOID-11468"></A
><a class="indexterm" name="AUTOID-11470"></A
>
<kbd class="command">npasswd</KBD
> and <kbd class="command">passwd+</KBD
>,
which can be used for this purpose; both are available at popular
<span class="acronym">FTP</SPAN
> archives, including <i class="systemitem">coast.cs.purdue.edu</I
>. Another
popular system is anlpasswd, which has some advantages over npasswd
and passwd+, and can be found at info.mcs.anl.gov.</P
><p class="para">Some versions of <span class="acronym">UNIX</SPAN
>, most notably the
Linux operating system, come supplied with <kbd class="command">npasswd</KBD
>. Other vendors
would do well to follow this example.</P
><p class="para">An approach that is present in many versions of <span class="acronym">UNIX</SPAN
>
involves putting constraints on the passwords that users can select.
Normally, this approach is controlled by some parameters accessed
through the system administration interface. These settings allow
the administrator to set the minimum password length, the number
of nonalphabetic characters allowed, and so on. You might even be
able to specify these settings per user, as well as per system.</P
><p class="para">One <span class="acronym">UNIX</SPAN
> system that combines all these
features in addition to password aging is <span class="acronym">AIX</SPAN
>.
By editing the security profile via the <a class="indexterm" name="AUTOID-11484"></A
>
smit
management tool, the administrator can set any or all of the following
for all users or individually for each user (<span class="acronym">IBM</SPAN
>'s
recommended settings are given for each):</P
><ul class="itemizedlist"><li class="listitem"><p class="para">The minimum and maximum age of passwords,
in weeks (0, 12)</P
></LI
><li class="listitem"><p class="para">The number of days of warning to give before expiring
a password (14)</P
></LI
><li class="listitem"><p class="para">The minimum length of the new password (6)</P
></LI
><li class="listitem"><p class="para">The minimum number of alphabetic and non-alphabetic
characters that must be present in the new password (1, 1)</P
></LI
><li class="listitem"><p class="para">The maximum number of repeated characters allowed
in the new password (3)</P
></LI
><li class="listitem"><p class="para">The minimum number of characters that must be different
from those in the previous password (3)</P
></LI
><li class="listitem"><p class="para">The number of weeks before a password can be used
again (26)</P
></LI
><li class="listitem"><p class="para">The number of new passwords that must be selected
and used before an old password can be used again (8)</P
></LI
><li class="listitem"><p class="para">The name of a file of prohibited words that cannot
be selected as passwords</P
></LI
><li class="listitem"><p class="para">A list of programs that can be run to check the
password choice for acceptability</P
></LI
></UL
><p class="para">This list is the most comprehensive group of &quot;settable&quot;
password constraints that we have seen. If you are using traditional
passwords, having (and properly using!) options such as these can
significantly improve the security of your passwords.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.3">8.8.3 Cracking Your Own Passwords</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11512"></A
><a class="indexterm" name="AUTOID-11515"></A
>A
less drastic approach than preventing users from picking their own
passwords is to run a program periodically to scan the <i class="filename">/etc/passwd</I
>
file for users with passwords that are easy to guess. Such programs,
called <i class="firstterm">password cracke</I
>rs, are (unfortunately?)
identical to the programs that bad guys use to break into systems.
The best of these crackers is a program called <a class="indexterm" name="AUTOID-11520"></A
>
Crack. (We tell you in <a class="xref" href="appe_01.htm" title="Electronic Resources">Appendix E</A
>, where to get it.) If you don't
(or can't) use shadow password files, you definitely want
to get and use the Crack program on your password file...because
one of your users or an attacker will most certainly do so.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> Before you run a password cracker on your system, be
sure that you are authorized to do so. You may wish to get the authorization
in writing. Running a password cracker may give the impression that
you are attempting to break into a particular computer. Unless you
have proof that you were authorized to run the program, you may
find yourself facing unpleasant administrative actions or possibly
even prosecution for computer crime.</P
></BLOCKQUOTE
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-8-SECT-8.3.1">8.8.3.1 Joetest: a simple password cracker</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-11528"></A
><a class="indexterm" name="AUTOID-11531"></A
><a class="indexterm" name="AUTOID-11533"></A
><a class="indexterm" name="AUTOID-11536"></A
>To understand how a password-cracking program works,
consider this program, which simply scans for accounts that have
the same password as their username. From <a class="xref" href="ch03_01.htm" title="Users and Passwords">Chapter 3</A
>, remember
that such accounts are known as &quot;Joes.&quot; The program
must be run as root if you have shadow password files installed
on your system:</P
><div class="example"><h4 class="example"><a class="title" name="PUIS-CHP-8-EX-1">Example 8.1: Single Password Cracker</A
></H4
><pre class="programlisting">/*
* joetest.c:
*
* Scan for &quot;joe&quot; accounts -- accounts with the same username
*and password.
*/

#include &lt;stdio.h&gt;
#include &lt;pwd.h&gt;
int   main(int argc,char **argv)
{
    struct     passwd *pw;

    while(pw=getpwent() ){
        char     *crypt();
        char     *result;

        result = crypt(pw-&gt;pw_name,pw-&gt;pw_passwd);
        if(!strcmp(result,pw-&gt;pw_passwd)){
            printf(&quot;%s is a joe\n&quot;,pw-&gt;pw_name);
        }
    }
    exit(0);
}</PRE
></DIV
><p class="para">To show you the advantages of the Perl programming language,
we have rewritten this program:</P
><blockquote class="screen"><pre class="screen">#!/usr/local/bin/perl
#
# joetest
#
while (($name,$passwd) = getpwent) {
		print &quot;$name is a joe\n&quot; if (crypt($name,$passwd) eq $passwd);
}</PRE
></BLOCKQUOTE
><p class="para">To further demonstrate the power of Perl, consider the following
script, which only runs under Perl5:</P
><blockquote class="screen"><pre class="screen">#!/usr/local/bin/perl
#
# super joetest
#
while (($name,$passwd) = getpwent) {
		print &quot;$name has no password\n&quot; if !$passwd;
		print &quot;$name is a joe\n&quot; if (crypt($name,$passwd) eq $passwd);
		print &quot;$name is a JOE\n&quot; if (crypt(uc($name), $passwd) eq $passwd);
		print &quot;$name is a Joe\n&quot; if (crypt(ucfirst($name), $passwd) 
			eq $passwd);
		print &quot;$name is a eoj\n&quot; if (crypt(scalar reverse $name, $passwd)
			eq $passwd);
}</PRE
></BLOCKQUOTE
><p class="para">If you have the time, type in the above program and run it.
You might be surprised to find a Joe or two on your system. Or simply
get Crack, which will scan for these possibilities, and a whole
lot more.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-8-SECT-8.3.2">8.8.3.2 The dilemma of password crackers</A
></H4
><p class="para">Because password crackers are used both by legitimate system
administrators and computer criminals, they present an interesting
problem: if you run the program, a criminal might find its results
and use them to break into your system! And, if the program you're
running is particularly efficient, it may be stolen and used against
you. Furthermore, the program you're using could always
have more bugs or have been modified so that it doesn't
report some bad passwords that may be present: instead, such passwords
might be silently sent by electronic mail to an anonymous repository
in Finland.</P
><p class="para">Instead of running a password cracker, you should prevent
users from picking bad passwords in the first place. Nevertheless,
this goal is not always reachable. For this reason, many system
administrators run password crackers on a regular basis. If you
run a program like Crack and find a bad password, you should disable
the account immediately, because an attacker could also find it.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> If you run a password cracker and don't find
any weak passwords, you shouldn't assume that there are
none to find! You might not have as extensive a set of dictionaries
as the people working against you: while your program reports no
weak passwords found, outsiders might still be busy logging in using
cracked passwords found with their Inuit, Basque, and Middle Druid
dictionaries. Or an attacker may have booby-trapped your copy of
Crack, so that discovered passwords are not reported but are sent
to a computer in New Zealand for archiving. For these reasons, use
password cracking in conjunction with user education, rather than
as an alternative to it.<a class="indexterm" name="AUTOID-11554"></A
><a class="indexterm" name="AUTOID-11557"></A
></P
></BLOCKQUOTE
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.4">8.8.4 Password Generators</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11563"></A
><a class="indexterm" name="AUTOID-11566"></A
><a class="indexterm" name="AUTOID-11569"></A
>Under many newer versions of <span class="acronym">UNIX</SPAN
>,
you can prevent users from choosing their own passwords altogether.
Instead, the <i class="filename">passwd</I
> program runs a password
generator that produces pronounceable passwords. To force users
to use the password generator under some versions of System V <span class="acronym">UNIX</SPAN
>,
you select the &quot;Accounts<img src="../chars/rarr.gif" alt="-&gt;">Defaults<img src="../chars/rarr.gif" alt="-&gt;">Passwords&quot;
menu from within the sysadmsh administrative program.</P
><p class="para">Most users don't like passwords that are generated
by password generators: despite claims of the program's
authors, the passwords really aren't that easy to remember.
Besides, most users would much rather pick a password that is personally
significant to them. Unfortunately, these passwords are also the
ones that are easiest to guess.</P
><p class="para">Two more problems with generated passwords are that users
frequently write them down to remember them, and that the password
generator programs themselves can be maliciously modified to generate
&quot;known&quot; passwords.</P
><p class="para">There are several freely available password generators that
you can download and install on your system. The <em class="emphasis"><a class="indexterm" name="AUTOID-11579"></A
>mkpasswd</EM
> program by Don Libes is one
such program, and it can be found in most of the online archives
mentioned in <a class="xref" href="appe_01.htm" title="Electronic Resources">Appendix E</A
>.</P
><p class="para">Instead of using password generators, you may want to install
password &quot;advisors&quot;&nbsp;- programs that examine
user choices for passwords and inform the users if the passwords
are weak. There are commercial programs that do this procedure,
such as <a class="indexterm" name="AUTOID-11583"></A
>
password coach by Baseline
Software, and various freeware and shareware filters such as <a class="indexterm" name="AUTOID-11585"></A
>
passwd+. In general, these products
may do comparisons against dictionaries and heuristics to determine
if the candidate password is weak. However, note that these products
suffer from the same set of drawbacks as password crackers&nbsp;- they
can be modified to secretly record the passwords, and their knowledge
base may be smaller than that used by potential adversaries. If
you use an &quot;advisor,&quot; don't be complacent!</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.5">8.8.5 Shadow Password Files</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11590"></A
><a class="indexterm" name="AUTOID-11592"></A
>When
the <span class="acronym">UNIX</SPAN
> password system was devised, the simple
security provided by the salt was enough. Computers were slow (by
present standards), and hard disks were small. At the rate of one
password encryption per second, the system would have taken three
years and three months to encrypt the entire 25,000-word <span class="acronym">UNIX</SPAN
>
spelling dictionary with every one of the 4096 different salts.
Simply holding the database would require more than 10 gigabytes
of storage&nbsp;- well beyond the capacity of typical <span class="acronym">UNIX</SPAN
>
platforms.</P
><p class="para">The advantage to a computer criminal of such a database, however,
would be immense. Such a database would reduce the time to do an
exhaustive key search for a password from seven hours to a few seconds.
Finding accounts on a computer that had weak passwords would suddenly
become a simple matter.</P
><p class="para">Today, many of the original assumptions about the difficulty
of encrypting passwords have broken down. For starters, the time
necessary to calculate an encrypted password has shrunk dramatically.
Modern workstations can perform up to several thousand password
encryptions per second. Versions of <kbd class="command">crypt</KBD
> developed
for supercomputers can encrypt tens of thousands of passwords in
the same amount of time. Now you can even store a database of every
word in the <span class="acronym">UNIX</SPAN
> spelling dictionary encrypted
with every possible salt on a single 10 gigabyte hard disk drive,
or on a few high-density <span class="acronym">CD-ROM</SPAN
>s.</P
><p class="para">Because of these developments, placing even encrypted passwords
in the world-readable /etc/passwd file is no longer
secure.[16]
There is still no danger that an attacker can decrypt
the passwords actually stored&nbsp;- the danger is simply that
an attacker could copy your password file and then systematically
search it for weak passwords. As a result, numerous vendors have
introduced<i class="firstterm"> shadow password files.</I
>[17] <span class="acronym">UNIX</SPAN
> systems
that offer at least so-called C2-level security features have shadow
password files, or the capability to install them.</P
><blockquote class="footnote"><p class="para">[16] The<i class="filename"> /etc/passwd</I
> file must be world
readable, because many, many programs need to consult it for UID
to account name mappings, home directories, and username information.
Changing the permissions breaks quite a few essential and convenient
services.</P
><p class="para">[17] Shadow password files have been a standard part of AT&amp;T
<span class="acronym">UNIX</SPAN
> since the introduction of SVR4. A number
of add-on shadow password systems are available for other versions
of UNIX; installing them requires having the source code to your
UNIX system.</P
></BLOCKQUOTE
><p class="para">Shadow password files hold the same encrypted passwords as
the regular <span class="acronym">UNIX</SPAN
> password file: they simply prevent
users from reading each other's encrypted passwords. Shadow
files are protected so that they cannot be read by regular users;
they can be read, however, by the setuid programs that legitimately
need access. (For instance, <span class="acronym">SVR4</SPAN
> uses the file
<i class="filename"><a class="indexterm" name="AUTOID-11616"></A
><a class="indexterm" name="AUTOID-11618"></A
><a class="indexterm" name="AUTOID-11621"></A
><a class="indexterm" name="AUTOID-11623"></A
>/etc/shadow, </I
>with protected mode 400,
and owned by <i class="systemitem">root; </I
>SunOS
uses the file <i class="filename">/etc/security/passwd.adjunct</I
>,
where <i class="filename">/etc/security</I
>
is mode 700.) The regular <i class="filename">/etc/passwd</I
> file
has special placeholders in the password field instead of the regular
encrypted values. Some systems substitute a special flag value,
while others have random character strings that look like regular
encrypted passwords: would-be crackers can then burn a lot of <span class="acronym">CPU</SPAN
>
cycles trying dictionary attacks on random strings.</P
><p class="para">If your system does not have shadow passwords, then you should
take extra precautions to ensure that the <i class="filename">/etc/passwd</I
>
file cannot be read anonymously, either over the network or with
the <span class="acronym">UUCP</SPAN
> system. (How to do this is described
in <a class="xref" href="ch15_01.htm" title="UUCP">Chapter 15, <cite class="chapter">UUCP</CITE
></A
>, and <a class="xref" href="ch17_01.htm" title="TCP/IP Services">Chapter 17</A
>.)</P
><p class="para">If you use shadow password files, you should be sure that
there are no backup copies of the shadow password file that are
publicly readable elsewhere on your system. Copies of <i class="filename">passwd</I
>
are sometimes left (often in <i class="filename">/tmp</I
> or <i class="filename">/usr/tmp</I
>)
as editor backup files and by programs that install new system software.
A good way to avoid leaving copies of your password files on your
system is to avoid editing them with a text editor, or to exercise
special care when doing so.<a class="indexterm" name="AUTOID-11640"></A
><a class="indexterm" name="AUTOID-11642"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.6">8.8.6 Password Aging and Expiration</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11648"></A
><a class="indexterm" name="AUTOID-11651"></A
><a class="indexterm" name="AUTOID-11654"></A
>Some <span class="acronym">UNIX</SPAN
> systems allow
the system administrator to set a &quot;lifetime&quot; for
passwords.[18]
With these systems, users whose passwords are older than the time
allowed are forced to change their passwords the next time they
log in. If a user's password is exceptionally old, the
system may prevent the user from logging in altogether.</P
><blockquote class="footnote"><p class="para">[18] Different systems use different procedures
for password aging. For a description of how to set password lifetimes
on your system, consult your system documentation.</P
></BLOCKQUOTE
><p class="para">Password aging can improve security. Even if a password is
learned by an attacker and the account is surreptitiously used,
that password will eventually be changed. Password aging can also
help you discover when people have access to passwords and accounts
that aren't properly registered. In one case we know about,
when a computer center started password aging, four users suddenly
discovered that they were all using the same account&nbsp;- without
each other's knowledge! The account's password
had simply not been changed for years, and the users had all been
working in different subdirectories.</P
><p class="para">Users sometimes defeat password aging systems by changing
an expired password to a new password and then back to the old password.
A few password aging systems check for this type of abuse by keeping
track of old and invalid passwords. Others prevent it by setting
a minimum lifetime on the new password. Thus, if the password is
changed, the user is forced to use it for at least a week or two
before it can be changed again&nbsp;- presumably back to the old
standby.[19]
If you use password aging, you should explain to your users why
it is important for them to avoid reusing old passwords.</P
><blockquote class="footnote"><p class="para">[19] This is a bad idea, even though it is common
on many SVR4 systems. It prevents the user from changing a password
if it has been compromised, and it will not prevent a user from
cycling between two favorite passwords again and again.</P
></BLOCKQUOTE
><p class="para">Under <span class="acronym">SVR4</SPAN
>, you can set password aging
using the -n (minimum days before the password can be change) and
-x (maximum number of days) options (e.g., <i class="filename"><a class="indexterm" name="AUTOID-11667"></A
><a class="indexterm" name="AUTOID-11670"></A
>passwd -n
7 -x 42 sally</I
>). Setting the aging value to -1 disables
aging.</P
><div class="sidebar"><h4 class="sidebar"><a class="title" name="AUTOID-11673">Old-Style Password Aging</A
></H4
><p class="para">Older versions of <span class="acronym">UNIX</SPAN
> had a form of password
aging available, but it was usually not documented well, if it was
documented at all. We describe it here for the sake of completeness.</P
><p class="para">To enable the old-style password aging, you would append a
comma and two base-64 digits to the end of the password field in
the <i class="filename">/etc/passwd</I
> file for each user. The comma
was not valid as part of an encoded password, and signalled that
password aging was to be enabled for that user. The two digits encoded
the aging parameters that are now set with the <kbd class="command">-x</KBD
>
and <kbd class="command">-n</KBD
> options of the <span class="acronym">SVR4</SPAN
>
passwd command, as described previously. The base-64 encoding is
the same as that used for encoding passwords, and is described in
the section called <a class="xref" href="ch08_06.htm#PUIS-CHP-8-SECT-6.1" title="The crypt() Algorithm">Section 8.6.1, "The crypt()
Algorithm</A
>.&quot;</P
><p class="para">The first digit after the comma represented the number of
weeks until the password expired (from the beginning of the current
week). The second digit represented the minimum number of weeks
that the password had to be kept before it could be changed again.
These values would be calculated by the system administrator and
then edited into the appropriate locations in the <i class="filename">passwd</I
>
file. After being set, the user would be prompted to choose a new
password the next time he or she logged in. Then two more digits
would be appended to the field in the file; these two digits would
also be updated each time the passwd command was run successfully.
These two digits encoded, in base-64, the time of the most recent
password change, expressed as a number of weeks since the beginning
of 1970. These digits were usually expressed in reverse order, as
if base-64 wasn't obscure enough!</P
><p class="para">Putting simply a &quot;,.&quot; at the end of a password
field would require the password to be changed at the very next
login. Most systems would then remove these characters, although
we have heard tell that on some dimly remembered system, the characters
would get changed into &quot;,.z&quot; (allow changes anytime,
expire this one in 64 weeks).</P
><p class="para">Few systems were shipped with software to ease the task of
calculating and setting these values manually. As another drawback,
the users were given no warning before a password expired&nbsp;- the
user logged in and was forced to change the password right then
and there. Everyone we know who experienced the mechanism hated
it and we do not believe it was widely used. The <span class="acronym">SVR4</SPAN
>
mechanism is a great improvement, although still not ideal.</P
></DIV
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> Do not use the <kbd class="command">-n</KBD
> option with the password aging command!
Configuring your system so that users are prevented from changing
their password is stupid. Users can accidently disclose their passwords
to others&nbsp;- for example, they might say their new password
out loud when they are typing it in for the first time. If users
are required to wait a minimum time before changing their passwords
again, then their accounts will be vulnerable.</P
></BLOCKQUOTE
><p class="para">Password aging should not be taken to extremes. Forcing users
to change their passwords more often than once every few months
is probably not helpful. If users change their passwords so often
that they find it difficult to remember what their current passwords
are, they'll probably write these passwords down. Imagine
a system that requires users to change their passwords every day.
Expiration times that are too short may make the security worse,
rather than better. Furthermore, it engenders discontent&nbsp;- feelings
that the security mechanisms are annoying rather than reasonable.
You may have good passwords, but having users who are constantly
angry about the security measures in place probably negates any
benefits gained.</P
><p class="para">On the other hand, if you want your users to change their
passwords every minute, or every time that they log in, then you
probably want to be using a one-time password system, such as those
described in <a class="xref" href="ch08_07.htm#PUIS-CHP-8-SECT-7.3" title="Integrating One-time Passwords with UNIX">Section 8.7.1, "Integrating One-time Passwords with UNIX</A
>earlier in this chapter.<a class="indexterm" name="AUTOID-11694"></A
><a class="indexterm" name="AUTOID-11697"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.7">8.8.7 Algorithm and Library Changes</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11703"></A
>If you have
the source code to your system, you can alter the <kbd class="command">crypt()</KBD
>
library function to dramatically improve the resistance of your
computer to password cracking. Here are some techniques you might
employ:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Change the number of encryption rounds
from 25 to something over 200. This change will make the encryption
routine operate more slowly, which is good. More importantly, it
will make encrypted passwords generated on your computer different
from passwords generated on other systems. This foils an attacker
who obtains a copy of your <i class="filename">/etc/passwd</I
> file
and tries to crack it on a remote computer using standard software.</P
></LI
><li class="listitem"><p class="para">Add a counter to the <kbd class="command">crypt()</KBD
>
library call that keeps track of how many times it has been called
within a single process. If a user's program calls it more
than 5 or 10 times, log that fact with syslog, being sure to report
the user's login name, tty and other pertinent information.
Then start returning the wrong values![20]</P
><blockquote class="footnote"><p class="para">[20] Many sites
feel uncomfortable with this advice to modify a system library to
return wrong values. However, in our experience, few (if any) programs
need to run <kbd class="command">crypt()</KBD
> more than a few
times in a single process unless those processes are attempting
to crack passwords. On the other hand, when we have worked with
sites that have had problems with password cracking, those problems
have stopped immediately when the <kbd class="command">crypt()</KBD
>
routine was modified to behave in this manner. If you feel uncomfortable
having some programs silently fail, you may wish to end their silence,
and have them send email to the system administrator or log a <i class="filename">syslog</I
>message when the <kbd class="command">crypt()</KBD
>
routine is run more than a few times.</P
></BLOCKQUOTE
></LI
></OL
><p class="para">If you decide to implement this approach, there are some issues
to be aware of:</P
><ol class="orderedlist"><li class="listitem"><p class="para">If your system uses shared libraries,
be sure to update the <kbd class="command">crypt()</KBD
> in the shared
library; otherwise, some commands may not work properly.</P
></LI
><li class="listitem"><p class="para">If your system does not use shared libraries, be
sure to update the <kbd class="command">crypt()</KBD
> function in your
file <i class="filename">libc.a</I
>, so that people who write programs
that use <kbd class="command">crypt()</KBD
> will get the modified version.</P
></LI
><li class="listitem"><p class="para">Be sure to re-link every program that uses <kbd class="command">crypt()</KBD
>
so that they all get the new version of the routine. On most <span class="acronym">UNIX</SPAN
>
systems, that means generating new versions of (at least) the following
programs:</P
></LI
></OL
><table class="informaltable"><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">/bin/login</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">/usr/sbin/in.rexecd</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">/bin/su</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">/usr/sbin/in.rlogind</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">/bin/passwd</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">/usr/sbin/in.rshd</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">/usr/sbin/in.ftpd</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para"></P
></TD
></TR
></TBODY
></TABLE
><ol class="orderedlist"><li class="listitem"><p class="para">Some programs legitimately need to
call the <kbd class="command">crypt()</KBD
> routine more than 10 times
in a single process. For example, the server of a multiuser game
program, which uses passwords to protect user characters, would
need to call <kbd class="command">crypt()</KBD
> if it stored the passwords
in an encrypted form (another good idea). For programs like these,
you will need to provide a means for them to run with a version
of the <kbd class="command">crypt()</KBD
> function that allows the function
to be run an unlimited number of times.</P
></LI
></OL
><p class="para"><a class="indexterm" name="AUTOID-11763"></A
><a class="indexterm" name="AUTOID-11765"></A
>Do these
techniques work? Absolutely. A few years ago, there was a computer
at <span class="acronym">MIT</SPAN
> on which guest accounts were routinely
given away to members of the local community. Every now and then,
somebody would use one of those guest accounts to grab a copy of
the password file, crack it, and then trash other people's
files. (This system didn't have shadow passwords either.)
The day after the above modifications were installed in the system's
<kbd class="command">crypt()</KBD
> library,
the break-ins stopped and the system's administrators were
able to figure out who was the source of the mischief. Eventually,
though, the system administrators gave up on modifications and went
back to the standard <kbd class="command">crypt()</KBD
> function.
That's because changing your <kbd class="command">crypt()</KBD
>
has some serious drawbacks:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">The passwords in your <i class="filename">/etc/passwd</I
>
file will no longer be compatible with an unaltered system,[21] and you won't
be able to trade <i class="filename">/etc/passwd</I
> entries with other
computers.</P
><blockquote class="footnote"><p class="para">[21] This may be an advantage under certain circumstances. Being
unable to trade encrypted passwords means being unable to have &quot;bad&quot;
passwords on a computer that were generated on another machine.
This is especially an issue if you modify your passwd program to
reject bad passwords. On a recent sweep of numerous computers at
AT&amp;T, one set of machines was found to have uncrackable
passwords, except for the passwords of two accounts that had been
copied from other machines.</P
></BLOCKQUOTE
></LI
><li class="listitem"><p class="para">If your site transfers <i class="filename">/etc/passwd</I
>
entries between machines as ways of transferring accounts, then
you will need to have the same <kbd class="command">crypt()</KBD
> modifications
on each machine.</P
></LI
><li class="listitem"><p class="para">If you use <span class="acronym">NIS</SPAN
> or <span class="acronym">NIS</SPAN
>+,
then you must use the same <kbd class="command">crypt()</KBD
> algorithm
on all of the <span class="acronym">UNIX</SPAN
> machines on your network.</P
></LI
><li class="listitem"><p class="para">You'll need to install your changes every
time the software is updated, and if you cease to have access to
the source, all of your users will have to set new passwords to
access the system.</P
></LI
><li class="listitem"><p class="para">This method depends on attackers not knowing the
exact number of rounds used in the encryption. If they discover
that you're using 26 rounds instead of 25, for example,
they can modify their own password-breaking software and attack
your system as before. (However, this scenario is unlikely to happen
in most environments; the cracker is more likely to try to break
into another computer&nbsp;- hardly a drawback at all!)</P
></LI
><li class="listitem"><p class="para">If an insider knows both his cleartext password
and the encrypted version, he can also determine experimentally
how the algorithm was changed.</P
></LI
></UL
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> While increasing the number of rounds that the encryption
algorithm performs is a relatively safe operation, don't
alter the algorithm used in the actual password mechanism unless
you are very, very confident that you know what you are doing. It
is very easy to make a change you think is adding complexity, only
to make things much simpler for an attacker who understands the
algorithm better than you do.<a class="indexterm" name="AUTOID-11796"></A
></P
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.8">8.8.8 Disabling an Account by Changing Its Password</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11801"></A
><a class="indexterm" name="AUTOID-11804"></A
><a class="indexterm" name="AUTOID-11807"></A
>If a user is going
away for a few weeks or longer, you may wish to prevent direct logins
to that user's account so the account won't be
used by someone else.</P
><p class="para">As mentioned earlier, one easy way to prevent logins is to
insert an asterisk (*) before the first character of the
user's password in the <i class="filename">/etc/passwd</I
>
file or shadow password file.[22] The asterisk will prevent
the user from logging in, because the user's password will
no longer encrypt to match the password stored in <i class="filename">/etc/passwd</I
>,
and the user won't know what's wrong. To re-enable
the account with the same password, simply remove the asterisk.</P
><blockquote class="footnote"><p class="para">[22] This method
of changing a user's password is not sufficient if the
user has a <i class="filename">.rhosts</I
> file or can rlogin from
a computer in your computer's <i class="filename">/etc/hosts.equiv</I
>
file. It also will not stop the execution of programs run by the
cron or at commands.</P
></BLOCKQUOTE
><p class="para">For example, here is the /etc/passwd entry
for a regular account:</P
><blockquote class="screen"><pre class="screen">omega:eH5/.mj7NB3dx:315:1966:Omega Agemo:/u/omega:/bin/csh</PRE
></BLOCKQUOTE
><p class="para">Here is the same account, with direct logins prevented:</P
><blockquote class="screen"><pre class="screen">omega:*eH5/.mj7NB3dx:315:1966:Omega Agemo:/u/omega:/bin/csh</PRE
></BLOCKQUOTE
><p class="para">Under <span class="acronym">SVR4</SPAN
>, you can accomplish the same
thing by using the <a class="indexterm" name="AUTOID-11823"></A
>
-l
option to the <i class="filename">passwd </I
>command, (e.g., passwd
-l omega).</P
><p class="para">You should be sure to check for at and cron jobs that are
run by the user whose account you are disabling.</P
><p class="para">Note that the superuser can still su to the account. The section
<a class="xref" href="ch08_05.htm#PUIS-CHP-8-SECT-5.3.2" title="Protecting the root Account">Section 8.5, "Protecting the root Account</A
>
explains the details of protecting accounts in a variety of other
ways. Briefly, we'd also suggest that you set the login
shell equal to <i class="filename">/bin/false</I
>, or to some program
that logs attempts to use it. You should also consider changing
the permissions on the user's home directory to mode 000
and changing the ownership to user <i class="systemitem">root</I
>.</P
><p class="para">As the administrator, you may also want to set expiration
and inactivity time-outs on accounts. This step means that accounts
cease to be valid after a certain date unless renewed, or they cease
to be usable unless a valid login occurs every so often. This last
case is especially important in environments where you have a dynamic
user population (as in a university) and it is difficult to monitor
all of the accounts. We discussed this in greater detail earlier
in this chapter.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-8-SECT-8.9">8.8.9 Account Names Revisited: Using Aliases  for Increased
Security</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-11836"></A
><a class="indexterm" name="AUTOID-11838"></A
><a class="indexterm" name="AUTOID-11841"></A
>As we described earlier in this chapter, you can
give accounts almost any name you want. The choice of account names
will usually be guided by a mixture of administrative convenience
and user preference. You might prefer to call the accounts something
mnemonic, so that users will be able to remember other usernames
for electronic mail and other communications. This method is especially
useful if you give your users access to Usenet and they intend to
post news. A properly chosen username, such as <i class="systemitem">paula</I
>, is more likely remembered
by correspondents than is <i class="systemitem">AC00045</I
>.</P
><p class="para">At the same time, you can achieve slightly better security
by having nonobvious usernames. This method is a form of <a class="indexterm" name="AUTOID-11847"></A
>
security through obscurity. If an attacker
does not know a valid username at your site, she will have greater
difficulty breaking in. If your users' account names are
not known outside your site and are nonobvious, potential intruders
have to guess the account names as well as the password. This strategy
adds some additional complexity to the task of breaking in, especially
if some of your users have weak passwords.</P
><p class="para">If you use obscure account names, you need a way to protect
those account names from outsiders while still allowing your users
to access electronic mail and participate in Usenet discussions.
The way to do this is with aliasing.</P
><p class="para">If you configure one machine to be your central mail and news
site, you can set your software to change all outgoing mail and
news to contain an alias instead of the real account name. This
is probably what you wish to do if you decide to install a <a class="indexterm" name="AUTOID-11852"></A
>
firewall
between your site and the outside network (see <a class="xref" href="ch21_01.htm" title="Firewalls">Chapter 21, <cite class="chapter">Firewalls</CITE
></A
>).</P
><p class="para">For example, your mailer could rewrite the From: line of outgoing
messages to change a line that looks like this:</P
><blockquote class="screen"><pre class="screen">From: paula@home.acs.com</PRE
></BLOCKQUOTE
><p class="para">to look like this:</P
><blockquote class="screen"><pre class="screen">From: Paula.Harris@ACS.COM</PRE
></BLOCKQUOTE
><p class="para">This address is also the electronic mail address Paula would
put on her business cards and correspondence. Incoming mail to those
addresses would go through some form of alias resolution and be
delivered to her account. You would also make similar configuration
changes to the Usenet software. There is an additional advantage
to aliasing&nbsp;- if an outsider knows the names of his correspondents
but not their account names (or machine names), he can still get
mail to them.</P
><p class="para">If you take this approach, other network services, such as
finger and who, must similarly be modified or disabled.[23]</P
><blockquote class="footnote"><p class="para">[23] Discussing
all of the various mailers and news agents that are available and
how to modify them to provide aliasing is beyond the scope of this
book. We suggest that you consult the O'Reilly &amp;
Associates books on electronic mail and news to get this information.</P
></BLOCKQUOTE
><p class="para">Many large organizations use some form of aliasing. For example,
mail to people at AT&amp;T Bell Laboratories that's
addressed to <a class="email" href="mailto:First.Last@att.com">First.Last@att.com</A
>
will usually be delivered to the right person. <a class="indexterm" name="AUTOID-11865"></A
><a class="indexterm" name="AUTOID-11868"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch08_07.htm#PUIS-CHP-8-SECT-7.3" title="8.7 One-Time Passwords"><img src="../gifs/txtpreva.gif" alt="Previous: 8.7 One-Time Passwords" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Practical UNIX &amp; Internet Security"><img src="../gifs/txthome.gif" alt="Practical UNIX &amp; Internet Security" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="CHAPTER" href="ch09_01.htm" title="9. Integrity Management"><img src="../gifs/txtnexta.gif" alt="Next: 9. Integrity Management" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">8.7 One-Time Passwords</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">9. Integrity Management</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
