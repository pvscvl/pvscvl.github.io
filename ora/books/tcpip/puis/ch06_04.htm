<html><head>
<title>[Chapter 6] 6.4 Common Cryptographic Algorithms</TITLE>
<meta name="DC.title" content="Practical UNIX &amp; Internet Security"><meta name="DC.creator" content="Simson Garfinkel &amp; Gene Spafford"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T00:02:34Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-148-8" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch06_01.htm" title="6. Cryptography"><link rel="prev" href="ch06_03.htm" title="6.3 The Enigma Encryption System"><link rel="next" href="ch06_05.htm#PUIS-CHP-6-SECT-5.3" title="6.5 Message Digests and Digital Signatures"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Practical UNIX &amp; Internet Security" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Practical UNIX &amp; Internet Security"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch06_03.htm" title="6.3 The Enigma Encryption System"><img src="../gifs/txtpreva.gif" alt="Previous: 6.3 The Enigma Encryption System" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 6<br>Cryptography</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch06_05.htm#PUIS-CHP-6-SECT-5.3" title="6.5 Message Digests and Digital Signatures"><img src="../gifs/txtnexta.gif" alt="Next: 6.5 Message Digests and Digital Signatures" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PUIS-CHP-6-SECT-4">6.4 Common Cryptographic Algorithms</A
></H2
><p class="para"><a class="indexterm" name="AUTOID-6762"></A
><a class="indexterm" name="AUTOID-6764"></A
><a class="indexterm" name="AUTOID-6767"></A
><a class="indexterm" name="AUTOID-6769"></A
><a class="indexterm" name="AUTOID-6772"></A
>There are two basic kinds of
encryption algorithms in use today:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Private key cryptography, which uses
the same key to encrypt and decrypt the message. This type is also
known as <i class="firstterm">symmetric</I
> <i class="firstterm">key</I
>
cryptography.</P
></LI
><li class="listitem"><p class="para">Public key cryptography, which uses a <i class="firstterm">public
key </I
>to encrypt the message and a <i class="firstterm">private
key </I
>to decrypt it. The name public key comes from the
fact that you can make the encryption key public without compromising
the secrecy of the message or the decryption key. Public key systems
are also known as <a class="indexterm" name="AUTOID-6784"></A
>
asymmetric
key cryptography.</P
></LI
></UL
><p class="para">Private key cryptography is most often used for protecting
information stored on a computer's hard disk, or for encrypting
information carried by a communications link between two different
machines. Public key cryptography is most often used for creating
<i class="firstterm"><a class="indexterm" name="AUTOID-6788"></A
>digital signatures</I
>
on data, such as electronic mail, to certify the data's
origin and integrity.</P
><p class="para">This analysis gives rise to a third kind of system:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Hybrid public/private cryptosystems.
In these systems, slower public key cryptography is used to exchange
a random <i class="firstterm"><a class="indexterm" name="AUTOID-6795"></A
>session key</I
>,
which is then used as the basis of a private key algorithm. (A session
key is used only for a single encryption session and is then discarded.)
Nearly all practical public key cryptography implementations are
actually hybrid systems.</P
></LI
></UL
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-6-SECT-4.1">6.4.1 Summary of Private Key Systems</A
></H3
><p class="para">The following list summarizes the private key systems in common
use today.</P
><dl class="variablelist"><dt class="term">ROT13 </DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6806"></A
>A simple cryptography
algorithm which is used, among other things, to obscure the content
of risqu&eacute; jokes on various Usenet groups. The <span class="acronym">ROT13</SPAN
>
encryption algorithm has no key, and it is not secure.</P
></DD
><dt class="term">crypt </DT
><dd class="listitem"><p class="para">The original <span class="acronym">UNIX</SPAN
><a class="indexterm" name="AUTOID-6814"></A
>
encryption program which is modeled on the German Enigma encryption
machine. <kbd class="command">crypt</KBD
> uses a variable-length key. Some
programs can automatically decrypt <i class="filename">crypt</I
>-encrypted files without
prior knowledge of the key or the plaintext. <kbd class="command">crypt</KBD
> is not secure.
(This program should not be confused with the secure one-way <i class="filename">crypt</I
>
program that <span class="acronym">UNIX </SPAN
>uses for encrypting passwords.)</P
></DD
><dt class="term">DES </DT
><dd class="listitem"><p class="para">The <a class="indexterm" name="AUTOID-6825"></A
><a class="indexterm" name="AUTOID-6827"></A
><a class="indexterm" name="AUTOID-6830"></A
>
Data Encryption Standard (<span class="acronym">DES</SPAN
>),
an encryption algorithm developed in the 1970s by the National Bureau
of Standards and Technology (since renamed the National Institute
of Standards and Technology, or <span class="acronym">NIST</SPAN
>) and <span class="acronym">IBM</SPAN
>.
<span class="acronym">DES</SPAN
> uses a 56-bit key.[8]</P
><blockquote class="footnote"><p class="para">[8] Technically,
we should refer to it as the DEA: Data Encryption Algorithm. Standard-conforming
implementations are certified by NIST, and usually require a hardware
implementation. However, nearly everyone refers to it as the DES,
so we will too.</P
></BLOCKQUOTE
></DD
><dt class="term">RC2 </DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6843"></A
><a class="indexterm" name="AUTOID-6845"></A
><a class="indexterm" name="AUTOID-6847"></A
>A block
cipher originally developed by Ronald Rivest and kept as a trade
secret by <span class="acronym">RSA</SPAN
> Data Security. This algorithm was
revealed by an anonymous Usenet posting in 1996 and appears to be
reasonably strong (although there are some particular keys that
are weak). RC2 is sold with an implementation that allows keys between
1 and 2048 bits. The RC2mail key length is often limited to 40 bits
in software that is sold for export.[9]</P
><blockquote class="footnote"><p class="para">[9] Unfortunately,
a 40-bit key is vulnerable to a brute force attack.</P
></BLOCKQUOTE
></DD
><dt class="term">RC4</DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6858"></A
><a class="indexterm" name="AUTOID-6860"></A
><a class="indexterm" name="AUTOID-6862"></A
>A stream cipher
originally developed by Ronald Rivest and kept as a trade secret
by <span class="acronym">RSA</SPAN
> Data Security. This algorithm was revealed
by an anonymous Usenet posting in 1994 and appears to be reasonably
strong (although there are some particular keys that are weak).
RC4 is sold with an implementation that allows keys between 1 and
2048 bits. The RC4 key length is often limited to 40 bits in software
that is sold for export.[10]</P
><blockquote class="footnote"><p class="para">[10] Unfortunately, a 40-bit
key is vulnerable to a brute force attack.</P
></BLOCKQUOTE
></DD
><dt class="term">RC5</DT
><dd class="listitem"><p class="para">A block cipher developed by Ronald Rivest and published
in 1994. RC5 allows a user-defined key length, data block size,
and number of encryption rounds.</P
></DD
><dt class="term">IDEA</DT
><dd class="listitem"><p class="para">The <a class="indexterm" name="AUTOID-6876"></A
><a class="indexterm" name="AUTOID-6878"></A
><a class="indexterm" name="AUTOID-6880"></A
>
International
Data Encryption Algorithm (<span class="acronym">IDEA</SPAN
>), developed in
Zurich, Switzerland by James L. Massey and Xuejia <a class="indexterm" name="AUTOID-6885"></A
><a class="indexterm" name="AUTOID-6887"></A
>
Lai and published in 1990. <span class="acronym">IDEA</SPAN
>
uses a 128-bit key, and is believed to be quite strong. <span class="acronym">IDEA</SPAN
>
is used by the popular program <span class="acronym">PGP</SPAN
> (described
later in this chapter) to encrypt files and electronic mail. Unfortunately,[11] wider use
of <span class="acronym">IDEA</SPAN
> may be hampered by a series of software
patents on the algorithm which is currently held by Ascom-Tech AG,
in Solothurn, Switzerland. Ascom-Tech supposedly will allow <span class="acronym">IDEA</SPAN
>
to be used royalty free in implementations of <span class="acronym">PGP</SPAN
>
outside the U.S., but concerned users should verify the terms with
Ascom-Tech or their licensees directly.</P
><blockquote class="footnote"><p class="para">[11] Although we are generally in favor of intellectual property
protection, we are opposed to the concept of software patents, in
part because they hinder the development and use of innovative software
by individuals and small companies.</P
></BLOCKQUOTE
></DD
><dt class="term"><a class="indexterm" name="AUTOID-6899"></A
><a class="indexterm" name="AUTOID-6901"></A
><a class="indexterm" name="AUTOID-6904"></A
>Skipjack </DT
><dd class="listitem"><p class="para">A classified (<span class="acronym">SECRET</SPAN
>) algorithm
developed by the National Security Agency (<span class="acronym">NSA</SPAN
>).
Reportedly, a Top Secret security clearance is required to see the
algorithm's source code and design specifications. Skipjack
is the algorithm used by the Clipper encryption chip. It uses an
80-bit key.<a class="indexterm" name="AUTOID-6911"></A
><a class="indexterm" name="AUTOID-6914"></A
></P
></DD
></DL
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-6-SECT-4.2">6.4.2 Summary of Public Key Systems</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-6919"></A
><a class="indexterm" name="AUTOID-6921"></A
><a class="indexterm" name="AUTOID-6925"></A
><a class="indexterm" name="AUTOID-6927"></A
>The following list
summarizes the public key systems in common use today:</P
><dl class="variablelist"><dt class="term">Diffie-Hellman</DT
><dd class="listitem"><p class="para">A system for exchanging cryptographic keys between
active parties. Diffie-Hellman is not actually a method of encryption
and decryption, but a method of developing and exchanging a shared
private key over a public communications channel. In effect, the
two parties agree to some common numerical values, and then each
party creates a key. Mathematical transformations of the keys are
exchanged. Each party can then calculate a third session key that
cannot easily be derived by an attacker who knows both exchanged
values.</P
><p class="para">Several versions of this protocol exist, involving
a differing number of parties and different transformations. Particular
care must be exercised in the choice of some of the numbers and
calculations used or the exchange can be easily compromised. If
you are interested, consult the references for all the gory details.</P
><p class="para">The Diffie-Hellman algorithm is frequently used
as the basis for exchanging cryptographic keys for encrypting a
communications link. The key may be any length, depending on the
particular implementation used. Longer keys are generally more secure.</P
></DD
><dt class="term">RSA</DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-6941"></A
><a class="indexterm" name="AUTOID-6943"></A
><a class="indexterm" name="AUTOID-6945"></A
>The
well-known public key cryptography system developed by (then) <span class="acronym">MIT</SPAN
>
professors Ronald Rivest and Adi Shamir, and by <span class="acronym">USC</SPAN
>
professor Leonard <a class="indexterm" name="AUTOID-6951"></A
><a class="indexterm" name="AUTOID-6953"></A
><a class="indexterm" name="AUTOID-6955"></A
>
Adleman. <span class="acronym">RSA</SPAN
> can be used both
for encrypting information and as the basis of a digital signature
system. Digital signatures can be used to prove the authorship and
authenticity of digital information. The key may be any length,
depending on the particular implementation used. Longer keys are
generally considered to be more secure.</P
></DD
><dt class="term">ElGamal </DT
><dd class="listitem"><p class="para">Another algorithm based on exponentiation and modular
arithmetic. <a class="indexterm" name="AUTOID-6962"></A
><a class="indexterm" name="AUTOID-6964"></A
>
ElGamal
may be used for encryption and digital signatures in a manner similar
to the <span class="acronym">RSA</SPAN
> algorithm. Longer keys are generally
considered to be more secure.</P
></DD
><dt class="term">DSA</DT
><dd class="listitem"><p class="para">The <a class="indexterm" name="AUTOID-6973"></A
><a class="indexterm" name="AUTOID-6975"></A
><a class="indexterm" name="AUTOID-6979"></A
>
Digital
Signature Algorithm, developed by <span class="acronym">NSA</SPAN
> and adopted
as a <a class="indexterm" name="AUTOID-6983"></A
><a class="indexterm" name="AUTOID-6985"></A
>
Federal Information
Processing Standard (<span class="acronym">FIPS</SPAN
>) by <span class="acronym">NIST</SPAN
>.
Although the <span class="acronym">DSA</SPAN
> key may be any length, only
keys between 512 and 1024 bits are permitted under the <span class="acronym">FIPS</SPAN
>.
As specified, <span class="acronym">DSA</SPAN
> can only be used for digital
signatures, although it is possible to use <span class="acronym">DSA</SPAN
>
implementations for encryption as well. The <span class="acronym">DSA</SPAN
>
is sometimes referred to as the <span class="acronym">DSS</SPAN
>, in the same
manner as the <span class="acronym">DEA</SPAN
> is usually referred to as the
<span class="acronym">DES</SPAN
>.</P
></DD
></DL
><p class="para"><a class="xref" href="#PUIS-CHP-6-TAB-1" title="Commonly Used Private and Public Key Cryptography Algorithms">Table 6.1</A
> lists all of the private and
public key algorithms we've discussed</P
><table class="table"><caption class="table"><a class="title" name="PUIS-CHP-6-TAB-1">Table 6.1: Commonly Used
Private and Public Key Cryptography Algorithms</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Algorithm</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Description</P
></TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="2"><p class="para">Private Key Algorithms:</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><span class="acronym">ROT13</SPAN
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Keyless text scrambler; very weak.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><i class="filename">crypt</I
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Variable key length stream cipher; very
weak.[12]</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><span class="acronym">DES</SPAN
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">56-bit block cipher; patented, but freely
usable (but not exportable).</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">RC2</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Variable key length block cipher; proprietary.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">RC4</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Variable key length stream cipher; proprietary.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">RC5</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Variable key length block cipher; proprietary.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><span class="acronym">IDEA</SPAN
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">128-bit block cipher; patented.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Skipjack</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">80-bit stream cipher; classified.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="2"><p class="para">Public Key Algorithms:</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Diffie-Hellman</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Key exchange protocol; patented.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><span class="acronym">RSA</SPAN
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Public key encryption and digital signatures;
patented</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">ElGamal</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Public key encryption and digital signatures;
patented.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><span class="acronym">DSA</SPAN
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Digital signatures only; patented.</P
></TD
></TR
></TBODY
></TABLE
><blockquote class="footnote"><p class="para">[12] Actually, crypt is a fair cipher for files
of length less than 1024 bytes. Its recurrence properties only surface
when used on longer inputs, thus providing more information for
decrypting.</P
></BLOCKQUOTE
><p class="para">.</P
><p class="para">The following sections provide some technical information
about a few of the algorithms mentioned above. If you are only interested
in using encryption, you can skip ahead to the section called &quot;Encryption
Programs Available for UNIX&quot; later in this chapter.<a class="indexterm" name="AUTOID-7088"></A
><a class="indexterm" name="AUTOID-7090"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-6-SECT-4.3">6.4.3 ROT13: Great for Encoding Offensive Jokes</A
></H3
><p class="para"><span class="acronym">ROT13</SPAN
><a class="indexterm" name="AUTOID-7097"></A
><a class="indexterm" name="AUTOID-7099"></A
><a class="indexterm" name="AUTOID-7103"></A
><a class="indexterm" name="AUTOID-7106"></A
>
is a simple substitution
cipher[13]
that is traditionally used for distributing potentially objectionable
material on the Usenet, a worldwide bulletin board system. It is
a variation on the <a class="indexterm" name="AUTOID-7112"></A
>
Caesar Cipher&nbsp;- an
encryption method used by Caesar's troops thousands of
years ago. In the <span class="acronym">ROT13</SPAN
> cipher, each letter of
the alphabet is replaced with a letter that is 13 letters further
along in the alphabet (with A following Z). Letters encrypt as follows:</P
><blockquote class="footnote"><p class="para">[13] Technically, it is an encoding scheme&nbsp;- the &quot;rotation&quot;
is fixed, and it does a constant encoding from a fixed alphabet.</P
></BLOCKQUOTE
><table class="informaltable"><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Plaintext</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Ciphertext</P
></TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">A</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">N</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">B</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">O</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">. . .</P
></TD
><td class="entry" rowspan="1" colspan="1"></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">M</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Z</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">N</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">A</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">. . .</P
></TD
><td class="entry" rowspan="1" colspan="1"></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Z</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">M</P
></TD
></TR
></TBODY
></TABLE
><p class="para"><span class="acronym">ROT13</SPAN
> used to be the most widely used encryption
system in the <span class="acronym">UNIX</SPAN
> world. However, it is not
secure at all. Many news and mail-reading programs automatically
decrypt <span class="acronym">ROT13</SPAN
>-encoded text with a single keystroke.
Some people are known to be able to read <span class="acronym">ROT13</SPAN
>
text without any machine assistance whatsoever.</P
><p class="para">For example, here is a <span class="acronym">ROT13</SPAN
> message:</P
><blockquote class="screen"><pre class="screen">Jung tbrf nebhaq, pbzrf nebhaq.</PRE
></BLOCKQUOTE
><p class="para">And here is how the message decrypts:</P
><blockquote class="screen"><pre class="screen">What goes around, comes around.</PRE
></BLOCKQUOTE
><p class="para">If you are not blessed with the ability to read <span class="acronym">ROT13</SPAN
>
files without computer assistance, you can use the following command
to either encrypt or decrypt files with the <span class="acronym">ROT13</SPAN
>
algorithm:[14]</P
><blockquote class="footnote"><p class="para">[14] On some versions of UNIX, you will need
to remove the &quot;[ ]&quot; symbols.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">% tr &quot;[a-z][A-Z]&quot; &quot;[n-z][a-m][N-Z][A-M]&quot; &lt; <i class="filename">filename</I
></PRE
></BLOCKQUOTE
><p class="para">Needless to say, do not use <span class="acronym">ROT13</SPAN
> as a
means of protecting your files! The only real use for this &quot;encryption&quot;
method is the one to which it is put on the Usenet: to keep someone
who does not want to be exposed to material (such as the answer
to a riddle, a movie spoiler in a review, or an offensive joke)
from reading it inadvertently.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-6-SECT-4.4">6.4.4 DES</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-7179"></A
><a class="indexterm" name="AUTOID-7181"></A
><a class="indexterm" name="AUTOID-7183"></A
>One
of the most widely used encryption systems today is the Data Encryption
Standard (<span class="acronym">DES</SPAN
>), developed in the 1970s and patented
by researchers at <span class="acronym">IBM</SPAN
>. The <span class="acronym">DES</SPAN
>
was an outgrowth of another <span class="acronym">IBM</SPAN
> cipher known
as <a class="indexterm" name="AUTOID-7190"></A
>
Lucifer. <span class="acronym">IBM</SPAN
>
made the <span class="acronym">DES</SPAN
> available for public use, and the
federal government issued Federal Information Processing Standard
Publication (<span class="acronym">FIPS</SPAN
> <span class="acronym">PUB</SPAN
>) Number
46 in 1977 describing the system. Since that time, the <span class="acronym">DES</SPAN
>
has been periodically reviewed and reaffirmed (most recently in
December 30, 1993), until 1998 as <span class="acronym">FIPS</SPAN
> <span class="acronym">PUB</SPAN
>
46-2. It has also been adopted as an American National Standard
(X3.92-1981/R1987).</P
><p class="para">The <span class="acronym">DES</SPAN
> performs a series of bit permutation,
substitution, and recombination operations on blocks containing
64 bits of data and 56 bits of key (eight 7-bit characters). The
64 bits of input are permuted initially, and are then input to a
function using static tables of permutations and substitutions (called
S-boxes). The bits are permuted in combination with 48 bits of the
key in each round. This process is iterated 16 times (rounds), each
time with a different set of tables and different bits from the
key. The algorithm then performs a final permutation, and 64 bits
of output are provided. The algorithm is structured in such a way
that changing any bit in the input has a major effect on almost
all of the output bits. Indeed, the output of the <span class="acronym">DES</SPAN
>
function appears so unrelated to its input that the function is
sometimes used as a random number generator.</P
><p class="para">Although there is no standard <span class="acronym">UNIX</SPAN
> program
that performs encryption using the <span class="acronym">DES</SPAN
>, some
vendors' versions of <span class="acronym">UNIX</SPAN
> include a
program called <kbd class="command"><a class="indexterm" name="AUTOID-7207"></A
>des</KBD
>
which performs <span class="acronym">DES</SPAN
> encryption. (This command
may not be present in international versions of the operating system,
as described in the next section.)</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-6-SECT-4.4.1">6.4.4.1 Use and export of DES</A
></H4
><p class="para">The <span class="acronym">DES</SPAN
> <a class="indexterm" name="AUTOID-7214"></A
><a class="indexterm" name="AUTOID-7217"></A
><a class="indexterm" name="AUTOID-7219"></A
>
was mandated as the encryption
method to be used by all federal agencies in protecting sensitive
but not classified information.[15]
The <span class="acronym">DES</SPAN
> is heavily used in many financial and
communication exchanges. Many vendors make <span class="acronym">DES</SPAN
>
chips that can encode or decode information fast enough to be used
in data-encrypting modems or network interfaces. Note that the <span class="acronym">DES</SPAN
>
is not (and has never been) certified as an encryption method that
can be used with U.S. Department of Defense classified material.</P
><blockquote class="footnote"><p class="para">[15] Other algorithms
developed by the NSA are designed for use with classified information.</P
></BLOCKQUOTE
><p class="para">Export control rules restrict the export of hardware or software
implementations of the <span class="acronym">DES</SPAN
>, even though the algorithm
has been widely published and implemented many times outside the
United States. If you have the international version of <span class="acronym">UNIX</SPAN
>,
you may find that your system lacks a <kbd class="command">des</KBD
> command.
If you find yourself in this position, don't worry; good
implementations of the <span class="acronym">DES</SPAN
> can be obtained via
anonymous <span class="acronym">FTP</SPAN
> from almost any archive service,
including the Usenet <i class="filename">comp.sources</I
> archives.</P
><p class="para">For more information about export of cryptography, see &quot;Encryption
and U.S. Law,&quot; later in this chapter.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-6-SECT-4.4.2">6.4.4.2 DES modes</A
></H4
><p class="para"><span class="acronym">FIPS</SPAN
> <span class="acronym">PUB</SPAN
> 81 explains
how the <span class="acronym">DES</SPAN
> algorithm can be used in four modes:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Electronic Code Book (<span class="acronym">ECB</SPAN
>)</P
></LI
><li class="listitem"><p class="para">Cipher Block Chaining (<span class="acronym">CBC</SPAN
>)</P
></LI
><li class="listitem"><p class="para">Cipher Feedback (<span class="acronym">CFB</SPAN
>)</P
></LI
><li class="listitem"><p class="para">Output Feedback (<span class="acronym">OFB</SPAN
>)</P
></LI
></UL
><p class="para">Each mode has particular advantages in some circumstances,
such as when transmitting text over a noisy channel, or when it
is necessary to decrypt only a portion of a file. The following
provides a brief discussion of these four methods; consult <span class="acronym">FIPS</SPAN
>
<span class="acronym">PUB</SPAN
> 81 or a good textbook on cryptography for
details.</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><span class="acronym">ECB</SPAN
><a class="indexterm" name="AUTOID-7261"></A
><a class="indexterm" name="AUTOID-7263"></A
>
Mode.
In electronic code book (<span class="acronym">ECB</SPAN
>) mode, each block
of the input is encrypted using the same key, and the output is
written as a block. This method performs simple encryption of a
message, a block at a time. This method may not indicate when portions
of a message have been inserted or removed. It works well with noisy
transmission channels&nbsp;- alteration of a few bits will corrupt
only a single 64-bit block.</P
></LI
><li class="listitem"><p class="para"><span class="acronym">CBC</SPAN
> Mode. In <a class="indexterm" name="AUTOID-7270"></A
><a class="indexterm" name="AUTOID-7273"></A
>
cipher block
chaining (<span class="acronym">CBC</SPAN
>) mode, the plaintext is first <span class="acronym">XOR</SPAN
>'ed
with the encrypted value of the previous block. Some known value
(usually referred to as the <i class="firstterm"><a class="indexterm" name="AUTOID-7278"></A
>initialization vector</I
>, or IV)
is used for the first block. The result is then encrypted using
the key. Unlike <span class="acronym">ECB</SPAN
> mode, long runs of repeated
characters in the plaintext will be masked in the output. <span class="acronym">CBC</SPAN
>
mode is the default mode for Sun Microsystems' des program.</P
></LI
><li class="listitem"><p class="para"><span class="acronym">CFB</SPAN
> Mode. In <a class="indexterm" name="AUTOID-7285"></A
><a class="indexterm" name="AUTOID-7288"></A
>
cipher feedback (<span class="acronym">CFB</SPAN
>)
mode, the output is fed back into the mechanism. After each block
is encrypted, part of it is shifted into a shift register. The contents
of this shift register are encrypted with the user's key
value using (effectively) <span class="acronym">ECB</SPAN
> mode, and this
output is <span class="acronym">XOR</SPAN
>'d with the data stream
to produce the encrypted result. This method is self synchronizing,
and enables the user to decrypt only a portion of a large database
by starting a fixed distance before the start of the desired data.</P
></LI
><li class="listitem"><p class="para"><span class="acronym">OFB</SPAN
> Mode. In <a class="indexterm" name="AUTOID-7296"></A
><a class="indexterm" name="AUTOID-7298"></A
>
output feedback
(<span class="acronym">OFB</SPAN
>) mode, the output is also fed back into
the mechanism. A register is initialized with some known value (again,
the IV). This register is then encrypted with (effectively) <span class="acronym">ECB</SPAN
>
mode using the user's key. The result of this is used as
the key to encrypt the data block (using an <span class="acronym">XOR</SPAN
>
operation), and it is also stored back into the register for use
on the next block. The algorithm effectively generates a long stream
of key bits that can be used to encrypt/decrypt communication
streams, with good tolerance for small bit errors in the transmission.
This mode is almost never used in <span class="acronym">UNIX</SPAN
>-based
systems.</P
></LI
></UL
><p class="para">All of these modes require that byte and block boundaries
remain synchronized between the sender and recipient. If information
is inserted or removed from the encrypted data stream, it is likely
that all of the following data from the point of modification can
be rendered unintelligible.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-6-SECT-4.4.3">6.4.4.3 DES strength</A
></H4
><p class="para">Ever <a class="indexterm" name="AUTOID-7308"></A
>
since <span class="acronym">DES</SPAN
> was first proposed
as a national standard, some people have been suspicious of the
algorithm. <span class="acronym">DES</SPAN
> was based on a proprietary encryption
algorithm developed by <span class="acronym">IBM</SPAN
> called <a class="indexterm" name="AUTOID-7314"></A
>
Lucifer, which <span class="acronym">IBM</SPAN
> had submitted
to the National Bureau of Standards (<span class="acronym">NBS</SPAN
>)[16]
for consideration as a national cryptographic standard. But whereas
Lucifer had a key that was 112 bits long, the <span class="acronym">DES</SPAN
>
key was shortened to 56 bits at the request of the National Security
Agency. The <span class="acronym">NSA</SPAN
> also requested that certain changes
be made in the algorithm's S-boxes. Many people suspected
that <span class="acronym">NSA</SPAN
> had intentionally weakened the Lucifer
algorithm, so the final standard adopted by <span class="acronym">NBS</SPAN
>
would not pose a threat to the <span class="acronym">NSA</SPAN
>'s
ongoing intelligence collection activities. But nobody had any proof.</P
><blockquote class="footnote"><p class="para">[16] NBS later became the National Institute of Standards and Technology.</P
></BLOCKQUOTE
><p class="para">Today the <span class="acronym">DES</SPAN
> is more than 20 years old,
and the algorithm is definitely showing its age. Recently <a class="indexterm" name="AUTOID-7327"></A
>
Michael Weiner, a researcher at Bell Northern
Research, published a paper detailing how to build a machine capable
of decrypting messages encrypted with the <span class="acronym">DES</SPAN
>
by conducting an exhaustive key search. Such a machine could be
built for a few million dollars, and could break any <span class="acronym">DES</SPAN
>-encrypted
message in about a day. We can reasonably assume that such machines
have been built by both governments and private industry.</P
><p class="para">In June 1994, <span class="acronym">IBM</SPAN
> published a paper describing
the design criteria of the <span class="acronym">DES</SPAN
>. The paper claims
that the choices of the <span class="acronym">DES</SPAN
> key size, S-boxes,
and number of rounds were a direct result of the conflicting goals
of making the <span class="acronym">DES</SPAN
> simple enough to fit onto a
single chip with 1972 chip-making technology, and the desire to
make it resistant to differential cryptanalysis.</P
><p class="para">These two papers, coupled with many previously published analyses,
appear to have finally settled a long-running controversy as to
whether or not <span class="acronym">NSA</SPAN
> had intentionally built in
weaknesses to the <span class="acronym">DES</SPAN
>. The <span class="acronym">NSA</SPAN
>
didn't build a back door into <span class="acronym">DES</SPAN
> that
would have allowed it to forcibly decrypt any <span class="acronym">DES</SPAN
>-encrypted
transmission: it didn't need to. Messages encrypted with
<span class="acronym">DES</SPAN
> can be forcibly decrypted simply by trying
every possible key, given the appropriate hardware.</P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-6-SECT-4.5">6.4.5 Improving the Security of DES</A
></H3
><p class="para">You <a class="indexterm" name="AUTOID-7346"></A
><a class="indexterm" name="AUTOID-7348"></A
><a class="indexterm" name="AUTOID-7350"></A
><a class="indexterm" name="AUTOID-7353"></A
><a class="indexterm" name="AUTOID-7355"></A
><a class="indexterm" name="AUTOID-7358"></A
>
can improve the security of <span class="acronym">DES</SPAN
>
by performing multiple encryptions, known as <i class="firstterm">superencryption</I
>.
The two most common ways of doing this are with double encryption
(<i class="firstterm">Double </I
><span class="acronym">DES</SPAN
><i class="firstterm">)</I
>
and with triple encryption (<i class="firstterm">Triple </I
><span class="acronym">DES</SPAN
>).</P
><p class="para">While double <span class="acronym">DES</SPAN
> appears to add significant
security, research has found some points of attack, and therefore
experts recommend Triple <span class="acronym">DES</SPAN
> for applications
where single <span class="acronym">DES</SPAN
> is not adequate.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-6-SECT-4.5.1">6.4.5.1 Double DES</A
></H4
><p class="para">In Double <span class="acronym">DES</SPAN
>, each 64-bit block of data
is encrypted twice with the <span class="acronym">DES</SPAN
> algorithm, first
with one key, then with another, as follows:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Encrypt with (key 1).</P
></LI
><li class="listitem"><p class="para">Encrypt with (key 2).</P
></LI
></OL
><p class="para">Plaintext <img src="../chars/rarr.gif" alt="-&gt;"> (key1) <img src="../chars/rarr.gif" alt="-&gt;"> (key2) <img src="../chars/rarr.gif" alt="-&gt;"> ciphertext</P
><p class="para">Double <span class="acronym">DES</SPAN
> is not significantly more secure
than single <span class="acronym">DES</SPAN
>. In 1981, Ralph Merkle and Martin
Hellman published an article[17] in which they outlined
a so-called &quot;meet-in-the-middle attack.&quot;</P
><blockquote class="footnote"><p class="para">[17] R. C. Merkle and M.
Hellman, &quot;On the Security of Multiple Encryption,&quot;
<em class="emphasis">Communications of the ACM</EM
>, Volume 24, Number
7, July 1981, pp. 465-467.</P
></BLOCKQUOTE
><p class="para">The <a class="indexterm" name="AUTOID-7390"></A
><a class="indexterm" name="AUTOID-7392"></A
><a class="indexterm" name="AUTOID-7395"></A
><a class="indexterm" name="AUTOID-7397"></A
>
meet-in-the-middle
attack is a <i class="firstterm">known plaintext attack</I
> which
requires that an attacker have both a known piece of plaintext and
a block of that same text that has been encrypted. (These pieces
are surprisingly easily to get.) The attack requires storing 2<sup class="superscript">56</SUP
>
intermediate results when trying to crack a message that has been
encrypted with <span class="acronym">DES</SPAN
> (a total of 2<sup class="superscript">59</SUP
> bytes), but
it reduces the number of different keys you need to check from 2<sup class="superscript">112</SUP
>
to 2<sup class="superscript">57</SUP
>. &quot;This is still considerably more memory storage
than one could comfortably comprehend, but it's enough
to convince the most paranoid of cryptographers that double encryption
is not worth anything,&quot; writes Bruce Schneier in his landmark
volume, <em class="emphasis">Applied Cryptography.</EM
></P
><p class="para">In other words, because a message encrypted with <span class="acronym">DES</SPAN
>
can be forcibly decrypted by an attacker performing an exhaustive
key search today, an attacker might also be able to forcibly decrypt
a message encrypted with Double <span class="acronym">DES</SPAN
> using a meet-in-the-middle
attack at some point in the future.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-6-SECT-4.5.2">6.4.5.2 Triple DES</A
></H4
><p class="para">The dangers of the Merkle-Hellman meet-in-the-middle attack
can be circumvented by performing three block encryption operations.
This method is called Triple <span class="acronym">DES</SPAN
>.</P
><p class="para">In practice, the most common way to perform Triple <span class="acronym">DES</SPAN
>
is:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Encrypt with (key1).</P
></LI
><li class="listitem"><p class="para">Decrypt with (key2).</P
></LI
><li class="listitem"><p class="para">Encrypt with (key3).</P
></LI
></OL
><p class="para">The advantage of this technique is that it can be backward
compatible with single <span class="acronym">DES</SPAN
>, simply by setting
all three keys to be the same value.</P
><p class="para">To decrypt, reverse the steps:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Decrypt with (key3).</P
></LI
><li class="listitem"><p class="para">Encrypt with (key2).</P
></LI
><li class="listitem"><p class="para">Decrypt with (key1).</P
></LI
></OL
><p class="para">For many applications, you can use the same key for both key1
and key3 without creating a significant vulnerability.</P
><p class="para">Triple <span class="acronym">DES</SPAN
> appears to be roughly as secure
as single <span class="acronym">DES</SPAN
> would be if it had a 112-bit key.
How secure is this really? Suppose you had an integrated circuit
which could perform one million Triple <span class="acronym">DES</SPAN
> encryptions
per second, and you built a massive computer containing one million
of these chips to forcibly try all Triple <span class="acronym">DES</SPAN
>
keys. This computer, capable of testing 10<sup class="superscript">12</SUP
> encryptions per second,
would require:</P
><blockquote class="screen"><pre class="screen">2<sup class="superscript">112</SUP
> = 5.19 x 10<sup class="superscript">33</SUP
> encryption operations 

5.19 x 10<sup class="superscript">33</SUP
> encryption operations / 10<sup class="superscript">12</SUP
> operations/sec = 5.19 x 10<sup class="superscript">21</SUP
> sec

= 1.65 x 10<sup class="superscript">14</SUP
> years.</PRE
></BLOCKQUOTE
><p class="para">This is more than 16,453 times older than the currently estimated
age of the universe (approximately 10<sup class="superscript">10</SUP
> years).</P
><p class="para">Apparently, barring new discoveries uncovering fundamental
flaws or weaknesses with the <span class="acronym">DES</SPAN
> algorithm, or
new breakthroughs in the field of cryptanalysis, Triple <span class="acronym">DES</SPAN
>
is the most secure private key encryption algorithm that humanity
will ever need (although niche opportunities may exist for faster
algorithms).<a class="indexterm" name="AUTOID-7451"></A
><a class="indexterm" name="AUTOID-7453"></A
><a class="indexterm" name="AUTOID-7456"></A
><a class="indexterm" name="AUTOID-7459"></A
><a class="indexterm" name="AUTOID-7461"></A
><a class="indexterm" name="AUTOID-7464"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-6-SECT-4.6">6.4.6 RSA and Public Key Cryptography</A
></H3
><p class="para"><span class="acronym">RSA</SPAN
><a class="indexterm" name="AUTOID-7471"></A
><a class="indexterm" name="AUTOID-7473"></A
><a class="indexterm" name="AUTOID-7475"></A
><a class="indexterm" name="AUTOID-7479"></A
><a class="indexterm" name="AUTOID-7481"></A
>
is
the most widely known algorithm for performing public key cryptography.
The algorithm is named after its inventors, Ronald Rivest, Adi Shamir,
and Leonard <a class="indexterm" name="AUTOID-7484"></A
><a class="indexterm" name="AUTOID-7486"></A
><a class="indexterm" name="AUTOID-7488"></A
>
Adleman,
who made their discovery in the spring of 1977.</P
><p class="para">Unlike <span class="acronym">DES</SPAN
>, which uses a single key, <span class="acronym">RSA</SPAN
>
uses two cryptographic keys: a public key and a <a class="indexterm" name="AUTOID-7493"></A
>
secret key. The public key is used to encrypt a
message and the secret key is used to decrypt it. (The system can
also be run in reverse, using the secret key to encrypt data that
can be decrypted with the public key.)</P
><p class="para">The <span class="acronym">RSA</SPAN
> <a class="indexterm" name="AUTOID-7497"></A
>
algorithm
is covered by U.S. Patent 4,405,829 (&quot;Cryptographic Communications
System and Method&quot;), which was filed for on December 14,
1977; issued on September 20, 1983; and expires on September 20,
2000. Because a description of the algorithm was published before
the patent application was filed, <span class="acronym">RSA</SPAN
> can be
used without royalty everywhere in the world except the United States
(international patent laws have different coverage of prior disclosure
and patent applicability).[18] Not surprisingly, <span class="acronym">RSA</SPAN
>
is significantly more popular in Europe and Japan than in the United
States, although its popularity in the U.S. is increasing.</P
><blockquote class="footnote"><p class="para">[18] Ongoing controversy exists
over whether this, or any other patent granted on what amounts to
a series of mathematical transformations, can properly be patented.
Some difference of opinion also exists about the scope of the patent
protection. We anticipate that the courts will need a lot of time
to sort out these issues.</P
></BLOCKQUOTE
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-6-SECT-4.6.1">6.4.6.1 How RSA works</A
></H4
><p class="para">The strength of <span class="acronym">RSA</SPAN
> is based on the difficulty
of factoring a very large number. The following brief treatment
does not fully explain the mathematical subtleties of the algorithm.
If you are interested in more detail, you can consult the original
paper[19] or a text such as those listed
in <a class="xref" href="appd_01.htm" title="Paper Sources">Appendix D</A
>.</P
><blockquote class="footnote"><p class="para">[19] Rivest, R., Shamir, A., Adleman, L., &quot;A
Method for Obtaining Digital Signatures and Public Key Cryptosystems,&quot;
<em class="emphasis">Communications of the ACM</EM
>, Volume 21, Number
2, February 1978.</P
></BLOCKQUOTE
><p class="para"><span class="acronym">RSA</SPAN
> is based on well-known, number-theoretic
properties of modular arithmetic and integers. One property makes
use of the <a class="indexterm" name="AUTOID-7514"></A
><a class="indexterm" name="AUTOID-7516"></A
>
Euler
Totient Function, <i class="filename"><img src="../chars/phi.gif" alt="[phi]">(n)</I
>. The Totient function of a number is defined
as the count of integers less than that number that are relatively
prime to that number. (Two numbers are relatively prime if they
have no common factors; for example, 9 and 8 are relatively prime.)
The Totient function for a prime number is one less than the prime
number itself: every positive integer less than the number is relatively
prime to it.</P
><p class="para">The property used by <span class="acronym">RSA</SPAN
> was discovered
by Euler and is this: any integer <i class="filename">i</I
> relatively prime to <i class="filename">n</I
> raised
to the power of <i class="filename"><img src="../chars/phi.gif" alt="[phi]">(n)</I
> and taken <i class="filename">mod n </I
>is equal
to&nbsp;1. That is:</P
><p class="para">equation goes here</P
><p class="para">Suppose <em class="emphasis">e</EM
> and <em class="emphasis">d</EM
> are random integers that are inverses modulo
<img src="../chars/phi.gif" alt="[phi]"><em class="emphasis">(n)</EM
>, that is:</P
><p class="para">equation goes here</P
><p class="para">A related property used in <span class="acronym">RSA</SPAN
> was also
discovered by Euler. His theorem says that if <em class="emphasis">M </EM
>is any number relatively
prime to <em class="emphasis">n</EM
>, then:</P
><p class="para">and equation goes here</P
><p class="para">Cryptographically speaking, if <em class="emphasis">M</EM
> is part of a message, we
have a simple means for encoding it with one function:</P
><p class="para">equation goes here</P
><p class="para">and decoding it with another function:</P
><p class="para">equation goes here</P
><p class="para">So how do we get appropriate values for <i class="filename">n</I
>, <i class="filename">e</I
>, and <i class="filename">d</I
>?
First, two large prime numbers <i class="filename">p</I
> and <kbd class="command">q</KBD
>, of approximately the same
size, are chosen, using some appropriate method. These numbers should
be large&nbsp;- on the order of several hundred digits&nbsp;- and
they should be kept secret.</P
><p class="para">Next, the Euler Totient function <img src="../chars/phi.gif" alt="[phi]">(<i class="filename">pq</I
>) is calculated. In the
case of <kbd class="command">n</KBD
> being the product of two primes, <img src="../chars/phi.gif" alt="[phi]">( <i class="filename">p q</I
> ) = (
<i class="filename">p - 1</I
> ) ( <i class="filename">q - 1</I
> ) = <img src="../chars/phi.gif" alt="[phi]">(<i class="filename">n</I
>).</P
><p class="para">Next, we pick a value e that is relatively prime to <img src="../chars/phi.gif" alt="[phi]">(<i class="filename">n</I
>).
A good choice would be to pick something in the interval max ( <i class="filename">p
+ 1, q + 1</I
> ) &lt; <i class="filename">e</I
> &lt;; <img src="../chars/phi.gif" alt="[phi]"> (<i class="filename">n</I
>). Then
we calculate a corresponding <i class="filename">d</I
>, such that <i class="filename">e d mod <img src="../chars/phi.gif" alt="[phi]">(n)  1</I
>. That
is, we find the modular inverse of <i class="filename">e mod <img src="../chars/phi.gif" alt="[phi]">(n)</I
>. If <i class="filename">d</I
> should happen
to be too small (i.e., less than about <i class="filename">log2(n))</I
>, we pick another
<i class="filename">e</I
> and <i class="filename">d</I
>.</P
><p class="para">Now we have our keys. To encrypt a message m, we split m into
fixed-size integers M less than n. Then we find the value (M<sup class="superscript">e</SUP
>) mod
n = s for each portion of the message. This calculation
can be done quickly with hardware, or with software using special
algorithms. These values are concatenated to form the encrypted
message. To decrypt the message, it is split into the blocks, and
each block is decrypted as <em class="emphasis">(s<sup class="superscript">d</SUP
></EM
>) mod&nbsp;<em class="emphasis">n</EM
> =<em class="emphasis">M</EM
>.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-6-SECT-4.6.2">6.4.6.2 An RSA example</A
></H4
><p class="para">For this example, assume we pick two prime numbers <em class="emphasis">p</EM
> and <em class="emphasis">q</EM
>:</P
><blockquote class="screen"><pre class="screen">p = 251 
q = 269 </PRE
></BLOCKQUOTE
><p class="para">The number <em class="emphasis">n</EM
> is therefore:</P
><blockquote class="screen"><pre class="screen">n = 251 * 269 = 67519</PRE
></BLOCKQUOTE
><p class="para">The Euler Totient function for this value is:</P
><blockquote class="screen"><pre class="screen"><img src="../chars/phi.gif" alt="[phi]"><em class="emphasis">(n)</EM
> = (251-1) (269-1) = 67000</PRE
></BLOCKQUOTE
><p class="para">Let's arbitrarily pick <em class="emphasis">e</EM
> as 50253. <em class="emphasis">d</EM
> is then:</P
><blockquote class="screen"><pre class="screen">d = e<sup class="superscript">-1</SUP
> mod 67000 = 27917</PRE
></BLOCKQUOTE
><p class="para">because:</P
><blockquote class="screen"><pre class="screen">50253 * 27917 = 1402913001 = 20939 * 67000 + 1 = 1 ( mod 67000 )</PRE
></BLOCKQUOTE
><p class="para">Using <em class="emphasis">n</EM
> = 67519 allows us to encode any message <em class="emphasis">M</EM
>
that is between 0 and 67518. We can therefore use this system to
encode a text message two characters at a time. (Two characters
have 16 bits, or 65536 possibilities.)</P
><p class="para">Using <em class="emphasis">e</EM
> as our key, let's encode the message &quot;<span class="acronym">RSA</SPAN
>
works!&quot; The sequence of <span class="acronym">ASCII</SPAN
> characters
encoding &quot;<span class="acronym">RSA</SPAN
> works!&quot; is shown
in the following table</P
><table class="table"><caption class="table"><a class="title" name="PUIS-CHP-6-TAB-2">Table 6.2: RSA Encoding Example</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para"><span class="acronym">ASCII</SPAN
></P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Decimal Value</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Encoded Value</P
></TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">&quot;RS&quot;</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">21075</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">48467</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">&quot;A&quot;</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">16672</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">14579</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">&quot;wo&quot;</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">30575</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">26195</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">&quot;rk&quot;</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">29291</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">58004</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">&quot;s!&quot;</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">29473</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">30141</P
></TD
></TR
></TBODY
></TABLE
><p class="para">.</P
><p class="para">As you can see, the encoded values do not resemble the original
message.</P
><p class="para">To decrypt, we raise each of these numbers to the power of
d and take the remainder mod n. After translating to <span class="acronym">ASCII</SPAN
>,
we get back the original message.</P
><p class="para">When <span class="acronym">RSA</SPAN
> is used for practical applications,
it is used with numbers that are hundreds of digits long. Because
doing math with hundred-digit-long strings is time consuming, modern
public key applications are designed to minimize the number of <span class="acronym">RSA</SPAN
>
calculations that need to be performed. Instead of using <span class="acronym">RSA</SPAN
>
to encrypt the entire message, <span class="acronym">RSA</SPAN
> is used to
encrypt a session key, which itself is used to encrypt the message
using a high-speed, private key algorithm such as <span class="acronym">DES</SPAN
>
or <span class="acronym">IDEA</SPAN
>.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-6-SECT-4.6.3">6.4.6.3 Strength of RSA</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-7664"></A
>The
numbers <em class="emphasis">n</EM
> and either <em class="emphasis">e</EM
> or <em class="emphasis">d</EM
> can be disclosed without seriously compromising
the strength of an <span class="acronym">RSA</SPAN
> cipher. For an attacker
to be able to break the encryption, he or she would have to find
<img src="../chars/phi.gif" alt="[phi]">(<em class="emphasis">n</EM
>), which, to the best of anyone's knowledge, requires
factoring <em class="emphasis">n</EM
>.</P
><p class="para">Factoring large numbers is very difficult&nbsp;- no known
method exists to do it efficiently. The time required to factor
a number can be several hundred years or several billion years with
the fastest computers, depending on how large the number <em class="emphasis">n</EM
> is. If
<em class="emphasis">n</EM
> is large enough, it is, for all intents and purposes, unfactorable.
The <span class="acronym">RSA</SPAN
> encryption system is therefore quite
strong, provided that appropriate values of <em class="emphasis">n</EM
>, <em class="emphasis">e</EM
>, and <em class="emphasis">d</EM
> are chosen,
and that they are kept secret.</P
><p class="para">To see how difficult factoring a large number is, let's
do a little rough calculation of how long factoring a 200 decimal-digit
number would take; this number is more than 70 digits longer than
the largest number ever factored, as of the time this book went
to press.</P
><p class="para">All 200-digit values can be represented in at most 665 binary
bits.</P
><ol class="orderedlist"><li class="listitem"><p class="para">has  digits.equation goes here</P
></LI
></OL
><p class="para">(In general, to factor a 665-bit number using one of the fastest-known
factoring algorithms would require approximately 1.2 x 10<sup class="superscript">23</SUP
> operations.)</P
><p class="para">Let's assume you have a machine that will do 10 billion
(10<sup class="superscript">10</SUP
>) operations per second. (Somewhat faster than today's
fastest parallel computers.) To perform 1.2 x 10<sup class="superscript">23</SUP
> operations would
require 1.2 x 10<sup class="superscript">13</SUP
> seconds, or 380,267 years worth of computer time.
If you feel uneasy about having your number factored in 380,267
years, simply double the size of your prime number: a 400-digit
number would require a mere 8.6 x 10<sup class="superscript">15</SUP
> years to factor. This is
probably long enough; according to Stephen Hawking's 
<em class="emphasis">A Brief History of Time</EM
>, the universe itself is 
only about 2 x 10<sup class="superscript">10</SUP
>
years old.</P
><p class="para">To give you another perspective on the size of these numbers,
assume that you (somehow) could precalculate the factors of all
200 decimal digit numbers. Simply to store the unfactored numbers
themselves would require approximately (9 x 10<sup class="superscript">200</SUP
>) x 665 bits of
storage (not including any overhead or indexing). Assume that you
can store these on special media that hold 100GB (100 x 1024<sup class="superscript">4</SUP
> or
approximately 1.1 x 10<sup class="superscript">14</SUP
>) of storage. You would need about 6.12
x 10 <sup class="superscript">189</SUP
> of these disks.</P
><p class="para">Now assume that each of those disks is only one millionth
<em class="emphasis">A Brief History of Time</EM
>, the universe itself is only about 2 x 1010
of a gram in weight (1 pound is 453.59 grams). The weight of all
your storage would come to over 6.75 x 10<sup class="superscript">177</SUP
> tons of disk. The planet
Earth weighs only 6.588 x 10<sup class="superscript">21</SUP
> tons. The Chandrasekhar limit, the
amount of mass at which a star will collapse into a black hole,
is about 1.5 times the mass of our Sun, or approximately 3.29 x
10<sup class="superscript">27</SUP
> tons. Thus, your storage, left to itself, would collapse into
a black hole from which your factoring could not escape! We are
not sure how much mass is in our local galaxy, but we suspect it
might be less than the amount you'd need for this project.</P
><p class="para">Again, it looks fairly certain that without a major breakthrough
in number theory, the <span class="acronym">RSA</SPAN
> mechanism (and similar
methods) are almost assuredly safe from brute-force attacks, provided
that you are careful in selecting appropriately prime numbers to
create<a class="indexterm" name="AUTOID-7706"></A
><a class="indexterm" name="AUTOID-7708"></A
><a class="indexterm" name="AUTOID-7712"></A
><a class="indexterm" name="AUTOID-7714"></A
>
 your key.</P
><div class="sidebar"><h4 class="sidebar"><a class="title" name="AUTOID-7717">Factor This!</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-7720"></A
>Not a year goes by
without someone claiming to have made a revolutionary breakthrough
in the field of factoring &nbsp;-  some new discovery which &quot;breaks&quot;
<span class="acronym">RSA</SPAN
> and leaves any program based upon it vulnerable
to decoding.</P
><p class="para">To help weed out the frauds from the real findings, <span class="acronym">RSA</SPAN
>
Data Security has created a challenge list of numbers. Each number
on the list is the product of two large prime numbers. When the
folks at <span class="acronym">RSA</SPAN
> are contacted by somebody who claims
a factoring breakthrough (and usually promises to keep the breakthrough
a secret in exchange for some cash), they give the person a copy
of the <span class="acronym">RSA</SPAN
> challenge numbers.</P
><p class="para">The first <span class="acronym">RSA</SPAN
> challenge number was published
in the August 1977 issue of Scientific American. The number was
129 digits long, and $100 was offered for finding its factors.
The <span class="acronym">RSA</SPAN
>-129 number was solved in the fall of
1994 by an international team of more than 600 volunteers.</P
><p class="para">A month later, a researcher at the <span class="acronym">MIT</SPAN
>
AI Laboratory contacted one of the authors of this chapter, claiming
a new factoring breakthrough. But there was a catch: to prove that
he had solved the factoring problem, the researcher had factored
that same <span class="acronym">RSA</SPAN
>-129 number.</P
><p class="para">Nice try. That one has already been solved. If you are interested
in the fame and fortune that comes from finding new factoring functions,
try factoring this:</P
><blockquote class="screen"><pre class="screen">RSA-140 =
2129024631825875754749788201627151749780670396327721627823338321538194
9984056495911366573853021918316783107387995317230889569230873441936471 </PRE
></BLOCKQUOTE
><p class="para">If you factor this number, you'll
get more than fame: you'll get cash. <span class="acronym">RSA</SPAN
>
Data Security keeps a &quot;jackpot&quot; for factoring
winners. The pot grows by $1750 every quarter. The first
quarter of 1995, it was approximately $15,000.</P
><p class="para">You
can get a complete list of all the <span class="acronym">RSA</SPAN
> challenge
numbers by sending an electronic mail message to <em class="emphasis">challenge-rsa-list@rsa.com</EM
>.</P
></DIV
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-6-SECT-4.7">6.4.7 An Unbreakable Encryption Algorithm</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-7743"></A
><a class="indexterm" name="AUTOID-7745"></A
>One type of encryption system is truly
unbreakable: the so-called <em class="emphasis">one-time pad mechanism</EM
>. A one-time pad
is illustrated in <a class="xref" href="#PUIS-CHP-6-FIG-4" title="A one-time pad">Figure 6.4</A
>.</P
><p class="para">The one-time pad often makes use of the mathematical function
known as <a class="indexterm" name="AUTOID-7751"></A
><a class="indexterm" name="AUTOID-7753"></A
>
exclusive
OR (<span class="acronym">XOR</SPAN
>,<img src="../chars/oplus.gif" alt="(+)">). If you <span class="acronym">XOR</SPAN
> a number
with any value <em class="emphasis">V</EM
>, then you get a second, encrypted
number. <span class="acronym">XOR</SPAN
> the encrypted number with value V
a second time, and you'll get your starting number back.
That is:</P
><p class="para">message = M</P
><p class="para">ciphertext = M<img src="../chars/oplus.gif" alt="(+)">V</P
><p class="para">plaintext = ciphertext<img src="../chars/oplus.gif" alt="(+)">V = ((M<img src="../chars/oplus.gif" alt="(+)">V)<img src="../chars/oplus.gif" alt="(+)">V)</P
><p class="para">A system based on one-time pads is mathematically unbreakable
(provided that the key itself is truly random) because you can't
do a key search: if you try every possible key, you will get every
possible message of the same length back. How do you tell which
one is correct?</P
><p class="para">Unfortunately, there is a catch: to use this system, you need
to have a stream of values&nbsp;- a key, if you will&nbsp;- that
is at least as long as the message you wish to encrypt. Each character
of your message is <span class="acronym">XOR</SPAN
>'ed, bit by bit,
with each successive character of the stream.</P
><h4 class="figure"><a class="title" name="PUIS-CHP-6-FIG-4">Figure 6.4: A one-time pad</A
></H4
><img class="graphic" src="figs/puis_0604.gif" alt="Figure 6.4"><p class="para">One-time pads have two important vulnerabilities:</P
><ol class="orderedlist"><li class="listitem"><p class="para">The stream of random values must be
truly random. If there is any regularity or order, that order can
be measured and exploited to decode the message.</P
></LI
><li class="listitem"><p class="para">The stream must never be repeated. If it is, a sophisticated
cryptanalyst can find the repeats and use them to decode all messages
that have been encoded with the no-longer one-time pad.</P
></LI
></OL
><p class="para">Most one-time pads are generated with machines based on nuclear
radioactive decay, a process that is believed to be unpredictable,
if not truly random. Almost every &quot;random number generator&quot;
you will find on any standard computer system will not generate
truly random numbers: the sequence will eventually repeat.</P
><p class="para">To see how this encryption mechanism works in practice, imagine
the following one-time pad:</P
><blockquote class="screen"><pre class="screen">23 43 11 45 23 43 98 43 52 86 43 87 43 92 34</PRE
></BLOCKQUOTE
><p class="para">With this sequence, the message:</P
><blockquote class="screen"><pre class="screen"><span class="acronym">UNIX</SPAN
> is secure.</PRE
></BLOCKQUOTE
><p class="para">Might encrypt as follows:</P
><blockquote class="screen"><pre class="screen">:\:\:s*:3:\rEs[drNERwe.</PRE
></BLOCKQUOTE
><p class="para">Which is really a printed representation of the following
string of values:</P
><blockquote class="screen"><pre class="screen">69 98 85 55 66 17 11 71 51 72 34 89 57 12</PRE
></BLOCKQUOTE
><p class="para">To use a one-time pad system, you need two copies of the pad:
one to encrypt the message, and the other to decrypt the message.
Each copy must be destroyed after use; after all, if an attacker
should ever obtain a copy of the pad, then any messages sent with
it would be compromised.</P
><p class="para">One of the main uses of one-time pads has been for sensitive
diplomatic communications that are subject to heavy monitoring and
intensive code breaking attempts&nbsp;- such as the communication
lines between the U.S. Embassy in Moscow and the State Department
in Washington, D.C. However, the general use of one-time pads is
limited because generating the sequence of random bits is difficult,
and distributing it securely to both the sender and the recipient
of the message is expensive.</P
><p class="para">Because of the problems associated with one-time pads, other
kinds of algorithms are normally employed for computer encryption.
These tend to be compact, mathematically based functions. The mathematical
functions are frequently used to generate a pseudorandom sequence
of numbers that are <span class="acronym">XOR</SPAN
>'ed with the
original message&nbsp;- which is similar to the way the one-time
pad works. (For example, Jim Bidzos, president of <span class="acronym">RSA</SPAN
>
Data Security, likes to call its RC4 stream cipher a &quot;one-time
pad generator,&quot; although the cipher is clearly not such
a thing.) The difference between the two techniques is that, with
mathematical functions, you can always&nbsp;- in principle, at
least&nbsp;- translate any message encrypted with these methods
back into the original message without knowing the key. <a class="indexterm" name="AUTOID-7789"></A
><a class="indexterm" name="AUTOID-7791"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-6-SECT-4.8">6.4.8 Proprietary Encryption Systems</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-7797"></A
><a class="indexterm" name="AUTOID-7799"></A
><a class="indexterm" name="AUTOID-7802"></A
>The
RC4 algorithm mentioned in the previous section is an example of
a so-called proprietary encryption algorithm: an encryption algorithm
developed by an individual or company which is not made publicly
available.</P
><p class="para">There are many proprietary algorithms in use today. Usually,
the algorithms are private key algorithms that are used in place
of algorithms such as <span class="acronym">DES</SPAN
> or <span class="acronym">IDEA</SPAN
>.[20] Although
some proprietary systems are relatively secure, the vast majority
are not. To make matters worse, you can rarely tell which are safe
and which are not&nbsp;- especially if the company selling the
encryption program refuses to publish the details of the algorithm.</P
><blockquote class="footnote"><p class="para">[20] While creating a public key encryption system is difficult,
creating a private key system is comparatively easy. Making a private
key system that is <em class="emphasis">secure</EM
>, on the other hand,
is a considerably more difficult endeavor.</P
></BLOCKQUOTE
><p class="para">A standard tenet in data encryption is that the security of
the system should depend completely on the security of the encryption
key. When choosing an encryption system, rely on formal mathematical
proofs of security, rather than on secret proprietary systems. If
the vendor of an encryption algorithm or technology will not disclose
the algorithm and show how it has been analyzed to show its strength,
you are probably better off avoiding it.</P
><p class="para">The RC4 algorithm is no exception to this tenet. In 1994,
an unknown person or persons published source code that claimed
to be RC4 on the Internet. By early 1996, a number of groups around
the world had started to find minor flaws in the algorithm, most
of them having to do with weak keys. Although RC4 appears to be
secure for most applications at this time, the clock may be ticking.</P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch06_03.htm" title="6.3 The Enigma Encryption System"><img src="../gifs/txtpreva.gif" alt="Previous: 6.3 The Enigma Encryption System" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Practical UNIX &amp; Internet Security"><img src="../gifs/txthome.gif" alt="Practical UNIX &amp; Internet Security" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch06_05.htm#PUIS-CHP-6-SECT-5.3" title="6.5 Message Digests and Digital Signatures"><img src="../gifs/txtnexta.gif" alt="Next: 6.5 Message Digests and Digital Signatures" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">6.3 The Enigma Encryption System</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">6.5 Message Digests and Digital Signatures</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
