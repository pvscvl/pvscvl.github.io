<html><head>
<title>[Chapter 5] 5.5 SUID</TITLE>
<meta name="DC.title" content="Practical UNIX &amp; Internet Security"><meta name="DC.creator" content="Simson Garfinkel &amp; Gene Spafford"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T00:01:54Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-148-8" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch05_01.htm" title="5. The UNIX Filesystem"><link rel="prev" href="ch05_04.htm" title="5.4 Using Directory Permissions"><link rel="next" href="ch05_06.htm" title="5.6 Device Files"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Practical UNIX &amp; Internet Security" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Practical UNIX &amp; Internet Security"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_04.htm" title="5.4 Using Directory Permissions"><img src="../gifs/txtpreva.gif" alt="Previous: 5.4 Using Directory Permissions" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 5<br>The UNIX Filesystem</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch05_06.htm" title="5.6 Device Files"><img src="../gifs/txtnexta.gif" alt="Next: 5.6 Device Files" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PUIS-CHP-5-SECT-5">5.5 SUID</A
></H2
><p class="para"><a class="indexterm" name="AUTOID-5428"></A
><a class="indexterm" name="AUTOID-5430"></A
><a class="indexterm" name="AUTOID-5433"></A
><a class="indexterm" name="AUTOID-5436"></A
>Sometimes, unprivileged
users must be able to accomplish tasks that require privileges.
An example is the <kbd class="command">passwd</KBD
> <a class="indexterm" name="AUTOID-5440"></A
>
program, which
allows you to change your password. Changing a user's password
requires modifying the password field in the <i class="filename">/etc/passwd</I
>
file. However, you should not give a user access to change this
file directly&nbsp;- the user could change everybody else's
password as well! Likewise, the <kbd class="command">mail</KBD
> program requires that you be
able to insert a message into the mailbox of another user, yet you
should not to give one user unrestricted access to another's
mailbox.</P
><p class="para">To get around these problems, <span class="acronym">UNIX</SPAN
> allows
programs to be endowed with privilege. Processes executing these
programs can assume another <span class="acronym">UID</SPAN
> or <span class="acronym">GID</SPAN
>
when they're running. A program that changes its <span class="acronym">UID</SPAN
>
is called a <span class="acronym">SUID</SPAN
> program (<em class="emphasis">set-UID</EM
>);
a program that changes its <span class="acronym">GID</SPAN
> is called a <span class="acronym">SGID</SPAN
>
program (<em class="emphasis">set-GID)</EM
>. A program can be both SUID
and SGID at the same time.</P
><p class="para">When a SUID program is run, its <a class="indexterm" name="AUTOID-5456"></A
>
effective
UID[22]

becomes that of the
owner of the file, rather than of the user who is running it. This
concept is so clever that <span class="acronym">AT&T</SPAN
> patented it.[23]</P
><blockquote class="footnote"><p class="para">[22] We explained effective UID in &quot;Real and Effective
UIDs&quot; in <a class="xref" href="ch04_01.htm" title="Users, Groups, and the Superuser">Chapter 4, <cite class="chapter">Users, Groups, and the Superuser</CITE
></A
>.</P
><p class="para">[23] However, the patent has since been released into the public
domain, as should all software patents, if software patents should
be allowed at all.</P
></BLOCKQUOTE
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-5-SECT-5.1">5.5.1 SUID, SGID, and Sticky Bits</A
></H3
><p class="para">If a <a class="indexterm" name="AUTOID-5467"></A
><a class="indexterm" name="AUTOID-5469"></A
><a class="indexterm" name="AUTOID-5472"></A
>
program is SUID or SGID, the output of the <kbd class="command">ls -l</KBD
> command will have the <em class="emphasis">x</EM
> in the display changed to an 
<em class="emphasis">s</EM
>.
If the program is sticky, the last <em class="emphasis">x</EM
> changes to a t as shown
in <a class="xref" href="#PUIS-CHP-5-TAB-13" title="SUID, SGID, and Sticky Bits">Table 5.13</A
> and <a class="xref" href="#PUIS-CHP-5-FIG-3" title="Additional file permissions">Figure 5.3</A
>.</P
><h4 class="figure"><a class="title" name="PUIS-CHP-5-FIG-3">Figure 5.3: Additional file permissions</A
></H4
><img class="graphic" src="figs/puis_0503.gif" alt="Figure 5.3"><table class="table"><caption class="table"><a class="title" name="PUIS-CHP-5-TAB-13">Table 5.13: SUID, SGID, and
Sticky Bits</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Contents</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Permission</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Meaning</P
></TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">---s------</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">SUID</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">A process that execs a SUID program has
its effective UID set to be the UID of the program's owner.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">------s---</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">SGID</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">A process that execs a SGID program has
its effective GID changed to the program's GID. Files created
by the process can have their primary group set to this GID as well,
depending on the permissions of the directory in which the files
are created. Under Berkeley-derived UNIX, a process that execs an
SGID program also has the program's GID temporarily added
to the process's list of GIDs.
Solaris and other System V-derived versions of UNIX use the SGID bit on data
files to enable mandatory file locking.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">---------t</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">sticky</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">This is obsolete with files, but is used
for directories. See &quot;The Origin of `Sticky'
&quot; sidebar later in this chapter.</P
></TD
></TR
></TBODY
></TABLE
><div class="sidebar"><h4 class="sidebar"><a class="title" name="AUTOID-5519">The Origin of &quot;Sticky&quot;</A
></H4
><p class="para">A very long time ago, <span class="acronym">UNIX</SPAN
> ran on machines
with much less memory than today: 64 kilobytes, for instance. This
amount of memory was expected to contain a copy of the operating
system, I/O buffers, and running programs. This memory
often wasn't sufficient when there were several large programs
running at the same time.</P
><p class="para">To make the most of the limited memory, <span class="acronym">UNIX</SPAN
>
<i class="firstterm"><a class="indexterm" name="AUTOID-5526"></A
><a class="indexterm" name="AUTOID-5528"></A
>swapped</I
> processes
to and from secondary storage as their turns at the CPU ended. When
a program was started, <span class="acronym">UNIX</SPAN
> would determine the
amount of storage that might ultimately be needed for the program,
its stack, and all its data. It then allocated a set of blocks on
the swap partition of the disk or drum attached to the system. (Many
systems still have a <i class="filename">/dev/swap</I
>, or a <kbd class="command">swapper</KBD
>
process that is a holdover from these times.)</P
><p class="para">Each time the process got a turn from the scheduler, <span class="acronym">UNIX</SPAN
>
would <i class="firstterm">swap in</I
> the program and data, if needed, execute for a while,
and then <i class="firstterm">swap out</I
> the memory copy if the space was needed for the
next process. When the process exited or <i class="filename">exec</I
>'d
another program, the swap space was reclaimed for use elsewhere.
If there was not enough swap space to hold the process's
memory image, the user got a &quot;No memory error &quot;
(still possible on many versions of <span class="acronym">UNIX</SPAN
> if a
large stack or heap is involved.)</P
><p class="para">Obviously, this is a great deal of I/O traffic that
could slow computation. So, one of the eventual steps was development
of compiler technology that constructed executable files with two
parts: <i class="firstterm">pure</I
> code that would not change, and everything else. These
were indicated with a special <i class="firstterm">magic number</I
> in the header inside
the file. When the program was first executed, the program and data
were copied to their swap space on disk first, then brought into
memory to execute. However, when the time comes to <em class="emphasis">swap</EM
> out, the
code portions were not written to disk &nbsp;-  they would not
have changed from what was already on disk! This change was a big
savings.</P
><p class="para">The next obvious step was to stop some of that extra disk-to-disk
copying at start-up time. Programs that were run frequently&nbsp;- such
as <kbd class="command">cc</KBD
>, <kbd class="command">ed</KBD
>, and <kbd class="command">rogue</KBD
>&nbsp;- could share the same program pages.
Furthermore, even if no copy was currently running, we could expect
another one to be run soon. Therefore, keeping the pages in memory
and on the swap partition, even while we weren't using
them, made sense. The &quot;sticky bit&quot; was added to
mark those programs as worth saving.</P
><p class="para">Since those times, larger memories and better memory management
methods have largely removed the original need for the sticky bit.
<a class="indexterm" name="AUTOID-5549"></A
></P
></DIV
><p class="para">In each of the cases above, the designator letter is capitalized
if the bit is set, and the corresponding execute bit is not set.
Thus, a file that has its sticky and <span class="acronym">SGID</SPAN
> bits
set, and is otherwise mode 444, would appear in an ls listing as</P
><blockquote class="screen"><pre class="screen">% <b class="emphasis.bold">ls -l /tmp/example</B
> 
-r--r-Sr-T 1 root    user    12324 Mar 26 1995 /tmp/example </PRE
></BLOCKQUOTE
><p class="para">An example of a <span class="acronym">SUID</SPAN
> program is the <kbd class="command">su</KBD
> command, introduced in <a class="xref" href="ch04_01.htm" title="Users, Groups, and the Superuser">Chapter 4</A
>:</P
><blockquote class="screen"><pre class="screen">% <b class="emphasis.bold">ls -l /bin/su </B
>
-rwsr-xr-x 1 root    user    16384 Sep 3 1989 /bin/su
%</PRE
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-5-SECT-5.2">5.5.2 Problems with SUID</A
></H3
><p class="para">Any program can be <span class="acronym">SUID</SPAN
>, <span class="acronym">SGID</SPAN
>,
or both <span class="acronym">SUID</SPAN
> and <span class="acronym">SGID</SPAN
>. Because
this feature is so general, <span class="acronym">SUID/SGID</SPAN
> can open
up some interesting security problems.</P
><p class="para">For example, any user can become the superuser simply by running
a <span class="acronym">SUID</SPAN
> copy of <a class="indexterm" name="AUTOID-5571"></A
><a class="indexterm" name="AUTOID-5573"></A
>
<kbd class="command">csh</KBD
> that is owned by <i class="systemitem.username">root</I
>.
Fortunately, you must be <i class="systemitem.username">root</I
>
already to create a <span class="acronym">SUID</SPAN
> version of <kbd class="command">csh</KBD
> that
is owned by <i class="systemitem.username">root</I
>. Thus,
an important objective in running a secure <span class="acronym">UNIX</SPAN
>
computer is to ensure that somebody who has superuser privileges
will not leave a <span class="acronym">SUID</SPAN
> <kbd class="command">csh</KBD
> on the system, directly
or indirectly.</P
><p class="para">If <a class="indexterm" name="AUTOID-5585"></A
>
you leave your terminal
unattended, an unscrupulous passerby can destroy the security of
your account simply by typing the commands:</P
><blockquote class="screen"><pre class="screen">% <b class="emphasis.bold">cp /bin/sh /tmp/break-acct </B
>
%<b class="emphasis.bold"> chmod 4755 /tmp/break-acct</B
>
%</PRE
></BLOCKQUOTE
><p class="para">These commands create a <span class="acronym">SUID</SPAN
> version of
the <a class="indexterm" name="AUTOID-5592"></A
>
<kbd class="command">sh</KBD
> program. Whenever
the attacker runs this program, the attacker becomes you&nbsp;- with
full access to all of your files and privileges. The attacker might
even copy this <span class="acronym">SUID</SPAN
> program into a hidden directory
so that it would only be found if the superuser scanned the entire
disk for <span class="acronym">SUID</SPAN
> programs. Not all system administrators
do such scanning on any regular basis.</P
><p class="para">Note that the program copied need not be a shell. Someone
with malicious intent can cause you misery by creating a <span class="acronym">SUID</SPAN
>
version of other programs. For instance, consider a <span class="acronym">SUID</SPAN
>
version of the editor program. With it, not only can he read or
change any of your files, but he can also spawn a shell running
under your <span class="acronym">UID</SPAN
>.</P
><p class="para">Most <span class="acronym">SUID</SPAN
> system programs are <span class="acronym">SUID</SPAN
>
<i class="systemitem.username">root</I
>; that is, they
become the superuser when they're executing. In theory,
this aspect is not a security hole, because a compiled program can
perform only the function or functions that were compiled into it.
(That is, you can change your password with the <kbd class="command">passwd</KBD
> program,
but you cannot alter the program to change somebody else's
password.) But many security holes have been discovered by people
who figured out ways of making a <span class="acronym">SUID</SPAN
> program
do something that it was not designed to do. In many circumstances,
programs that are <span class="acronym">SUID</SPAN
> <i class="systemitem.username">root</I
>
could easily have been designed to be <span class="acronym">SUID</SPAN
> something
else (such as <i class="systemitem.username">daemon</I
>, or some <span class="acronym">UID</SPAN
> created especially
for the purpose). Too often, <span class="acronym">SUID</SPAN
> <i class="systemitem.username">root</I
> is used when something
with less privilege would be sufficient.</P
><p class="para">In <a class="xref" href="ch23_01.htm" title="Writing Secure SUID and Network Programs">Chapter 23, <cite class="chapter">Writing Secure SUID and Network Programs</CITE
></A
>, we provide some suggestions on how
to write more secure programs in <span class="acronym">UNIX</SPAN
>. If you
absolutely must write a <span class="acronym">SUID</SPAN
> or <span class="acronym">SGID</SPAN
>
program (and we advise you not to), then consult that chapter first.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-5-SECT-5.3">5.5.3 SUID Shell Scripts</A
></H3
><p class="para">Under <a class="indexterm" name="AUTOID-5623"></A
><a class="indexterm" name="AUTOID-5626"></A
>
most versions of <span class="acronym">UNIX</SPAN
>,
you can create shell scripts[24] that are <span class="acronym">SUID</SPAN
> or <span class="acronym">SGID</SPAN
>.
That is, you can create a shell script and, by setting the shell
script's owner to be <i class="systemitem.username">root</I
>
and setting its <span class="acronym">SUID</SPAN
> bit, you can force the shell
script to execute with superuser privileges.</P
><blockquote class="footnote"><p class="para">[24] Actually, any interpreted
scripts.</P
></BLOCKQUOTE
><p class="para">You should never write <span class="acronym">SUID</SPAN
> shell scripts.</P
><p class="para">Because of a fundamental flaw with the <span class="acronym">UNIX</SPAN
>
implementation of shell scripts and <span class="acronym">SUID</SPAN
>, you
cannot execute <span class="acronym">SUID</SPAN
> shell scripts in a completely
secure manner on systems that do not support the <i class="filename">/dev/fd</I
>
device. This flaw arises because executing a shell script under
<span class="acronym">UNIX</SPAN
> involves a two-step process: when the <a class="indexterm" name="AUTOID-5643"></A
>
kernel
determines that a shell script is about to be run, it first starts
up a <span class="acronym">SUID</SPAN
> copy of the shell interpreter, then
the shell interpreter begins executing the shell script. Because
these two operations are performed in two discrete steps, you can
interrupt the kernel after the first step and switch the file that
the shell interpreter is about to execute. In this fashion, an attacker
could get the computer to execute any shell script of his or her
choosing, which essentially gives the attacker superuser privileges.
Although this flaw is somewhat mitigated by the<i class="filename"> /dev/fd</I
>
device, even on systems that do support a /dev/fd
device, <span class="acronym">SUID</SPAN
> shell scripts are very dangerous
and should be avoided.</P
><p class="para">Some modern <span class="acronym">UNIX</SPAN
> systems ignore the <span class="acronym">SUID</SPAN
>
and <span class="acronym">SGID</SPAN
> bits on shell scripts for this reason.
Unfortunately, many do not. Instead of writing <span class="acronym">SUID</SPAN
>
shell scripts, we suggest that you use the <a class="indexterm" name="AUTOID-5653"></A
><a class="indexterm" name="AUTOID-5655"></A
>
Perl programming language for these
kinds of tasks. A version of Perl called<i class="filename"> taintperl</I
>
[25]

will force you to write <span class="acronym">SUID</SPAN
> scripts that check
their <span class="acronym">PATH</SPAN
> environment variable and that do not
use values supplied by users for parameters such as filenames unless
they have been explicitly &quot;untainted.&quot; Perl has
many other advantages for system administration work as well. We
describe some of them in <a class="xref" href="ch23_01.htm" title="Writing Secure SUID and Network Programs">Chapter 23</A
>.
You can also learn more about Perl from the excellent O'Reilly
book, <em class="emphasis">Programming Perl, </EM
>by Larry Wall and Randal
L. Schwartz.</P
><blockquote class="footnote"><p class="para">[25] In
release 5 of Perl, this option is replaced by the -T option to Perl.</P
></BLOCKQUOTE
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-5-SECT-5.3.1">5.5.3.1 write: Example of a possible SUID/SGID security
hole</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-5667"></A
><a class="indexterm" name="AUTOID-5669"></A
>The
authors of <span class="acronym">SUID</SPAN
> and <span class="acronym">SGID</SPAN
> programs
try to ensure that their software won't create security
holes. Sometimes, however, a <span class="acronym">SUID</SPAN
> or <span class="acronym">SGID</SPAN
>
program can create a security hole if the program isn't
installed in the way the program author planned.</P
><p class="para">For example, the <kbd class="command">write</KBD
> program, which prints a message on
another user's terminal, is <span class="acronym">SGID</SPAN
> <i class="systemitem.username">tty</I
>.
For security reasons, <span class="acronym">UNIX</SPAN
> doesn't normally
let users read or <kbd class="command">write</KBD
> information to another's terminal;
if it did, you could <kbd class="command">write</KBD
> a program to read another user's
keystrokes, capturing any password that she might type. To let the
write program function, every user's terminal is also set
to be writable by the tty group. Because <kbd class="command">write</KBD
> is <span class="acronym">SGID</SPAN
>
<i class="systemitem.username">tty</I
>, the <kbd class="command">write</KBD
> program lets one user <kbd class="command">write</KBD
> onto another user's
terminal. It first prints a message that tells the recipient the
name of the user who is writing onto her terminal.</P
><p class="para">But <kbd class="command">write</KBD
> has a potential security hole&nbsp;- its shell
escape. By beginning a line with an exclamation mark, the person
using the <kbd class="command">write</KBD
> program can cause arbitrary programs to be run by
the shell. (The shell escape is left over from the days before <span class="acronym">UNIX</SPAN
>
had job control. The shell escape made it possible to run another
command while you were engaged in a conversation with a person on
the computer using write.) Thus, <kbd class="command">write</KBD
> must give up its special
privileges before it invokes a shell; otherwise, the shell (and
any program the user might run) would inherit those privileges as
well.</P
><p class="para">The part of the <kbd class="command">write</KBD
> program that specifically takes away
the <i class="systemitem.username">tty</I
> group permission before the program starts up the shell
looks like this:</P
><blockquote class="screen"><pre class="screen">setgid(getgid()); /* Give up effective group privs */ 
execl(getenv(&quot;SHELL&quot;),&quot;sh&quot;,&quot;-c&quot;,arg,0);</PRE
></BLOCKQUOTE
><p class="para">Notice that <kbd class="command">write</KBD
> changes only its <span class="acronym">GID</SPAN
>,
not its effective <span class="acronym">UID</SPAN
>. If <kbd class="command">write</KBD
> is installed
<span class="acronym">SUID</SPAN
> <i class="systemitem.username">root</I
> instead of <span class="acronym">SGID</SPAN
>
<i class="systemitem.username">tty</I
>, the program will appear to run properly but any program that
the user runs with the shell escape will actually be run as the
superuser! An attacker who has broken the security on your system
once might change the file permissions of the <kbd class="command">write</KBD
> program, leaving
a hole that he or she could exploit in the future. The program,
of course, will still function as before.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-5-SECT-5.3.2">5.5.3.2 Another SUID example: IFS and the /usr/lib/preserve
hole</A
></H4
><p class="para">Sometimes, an interaction between a <span class="acronym">SUID</SPAN
>
program and a system program or library creates a security hole
that's unknown to the author of the program. For this reason,
it can be extremely difficult to know if a <span class="acronym">SUID</SPAN
>
program contains a security hole or not.</P
><p class="para">One <a class="indexterm" name="AUTOID-5713"></A
><a class="indexterm" name="AUTOID-5716"></A
><a class="indexterm" name="AUTOID-5718"></A
><a class="indexterm" name="AUTOID-5721"></A
><a class="indexterm" name="AUTOID-5723"></A
><a class="indexterm" name="AUTOID-5725"></A
><a class="indexterm" name="AUTOID-5728"></A
>
of the most famous examples
of a security hole of this type existed for years in the program
called <i class="filename">/usr/lib/preserve</I
> (which is now
given names similar to <i class="filename">/usr/lib/ex3.5preserve</I
>).
This program, which is used by the <kbd class="command">vi</KBD
> and <kbd class="command">ex</KBD
> editors, automatically
makes a backup of the file being edited if the user is unexpectedly
disconnected from the system before writing out changes to the file.
The <kbd class="command">preserve</KBD
> program writes the changes to a temporary file in a
special directory, then uses the /bin/mail program
to send the user a notification that the file has been saved.</P
><p class="para">Because people might be editing a file that was private or
confidential, the directory used by the older version of the <kbd class="command">preserve</KBD
>
program was not accessible by most users on the system. Therefore,
to let the <kbd class="command">preserve</KBD
> program write into this directory, and let the
<kbd class="command">recover</KBD
> program read from it, these programs were made <span class="acronym">SUID</SPAN
>
<i class="systemitem.username">root</I
>.</P
><p class="para">Three details of the <i class="filename">/usr/lib/preserve</I
>
implementation worked together to allow knowledgeable system crackers
to use the program to gain <i class="systemitem.username">root</I
> privileges:</P
><ol class="orderedlist"><li class="listitem"><p class="para"><kbd class="command">preserve</KBD
> was installed <span class="acronym">SUID</SPAN
>
root.</P
></LI
><li class="listitem"><p class="para"><kbd class="command">preserve</KBD
> ran <i class="filename">/bin/mail</I
> as the
<i class="filename">root</I
> user to alert users that their files had been preserved.</P
></LI
><li class="listitem"><p class="para"><kbd class="command">preserve</KBD
> executed the <kbd class="command">mail</KBD
> program with the <a class="indexterm" name="AUTOID-5759"></A
>
<kbd class="command">system()</KBD
> function call.</P
></LI
></OL
><p class="para"><a class="indexterm" name="AUTOID-5763"></A
><a class="indexterm" name="AUTOID-5765"></A
>The problem
was that the <kbd class="command">system</KBD
> function uses <i class="filename">sh</I
> to parse
the string that it executes. There is a little-known shell variable
called <span class="acronym">IFS</SPAN
>, the internal field separator, which
<kbd class="command">sh</KBD
> uses to figure out where the breaks are between words on each
line that it parses. Normally, <span class="acronym">IFS</SPAN
> is set to
the white space characters: space, tab, and newline. But by setting
<span class="acronym">IFS</SPAN
> to the slash character (/) then
running <kbd class="command">vi</KBD
>, and then issuing the <i class="filename">preserve</I
> command,
it was possible to get <i class="filename">/usr/lib/preserve</I
>
to execute a program in the current directory called <kbd class="command">bin</KBD
>. This program
was executed as root. (<kbd class="command">/bin/mail</KBD
> got parsed as
<kbd class="command">bin</KBD
> with the argument <kbd class="command">mail</KBD
>.)</P
><p class="para">If a user can convince the operating system to run a command
as <i class="filename">root</I
>, that user can become <i class="filename">root</I
>. To see why this is so, imagine
a simple shell script which might be called <kbd class="command">bin</KBD
>, and run through
the hole described earlier:[26]</P
><blockquote class="footnote"><p class="para">[26] There is actually a small
bug in this shell script; can you find it?</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen"># 
# Shell script to make an SUID-root shell 
# 
cd /homes/mydir/bin 
cp /bin/sh ./sh 
# Now do the damage! 
chown root sh 
chmod 4755 sh </PRE
></BLOCKQUOTE
><p class="para">This shell script would get a copy of the Bourne shell program
into the user's <kbd class="command">bin</KBD
> directory, and then make it <span class="acronym">SUID</SPAN
>
<i class="filename">root</I
>. Indeed, this is the very way that the problem with <i class="filename">/usr/lib/preserve</I
>
was exploited by system crackers.</P
><p class="para">The preserve program had more privilege than it needed&nbsp;- it
violated a basic security principle called <a class="indexterm" name="AUTOID-5793"></A
>
<i class="firstterm">least
privilege</I
>. Least privilege states that a program should have only
the privileges it needs to perform the particular function it's
supposed to perform, and no others. In this case, instead of being
<span class="acronym">SUID</SPAN
> <i class="filename">root</I
>, <i class="filename">/usr/lib/preserve</I
>
should have been <span class="acronym">SGID</SPAN
> <kbd class="command">preserve</KBD
>, where <kbd class="command">preserve</KBD
>
would have been a specially created group for this purpose. Although
this restriction would not have completely eliminated the security
hole, it would have made its presence considerably less dangerous.
Breaking into the <i class="filename">preserve </I
>group would have
only let the attacker view files that had been preserved.</P
><p class="para">Although the <kbd class="command">preserve</KBD
> security hole was a part of <span class="acronym">UNIX</SPAN
>
since the addition of <kbd class="command">preserve</KBD
> to the <kbd class="command">vi</KBD
> editor, it wasn't
widely known until 1986. For a variety of reasons, it wasn't
fixed until a year after it was widely publicized.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> If you are using an older version of <span class="acronym">UNIX</SPAN
>
that can't be upgraded, remove the <span class="acronym">SUID</SPAN
>
permission from <i class="filename">/usr/lib/preserve</I
> to patch
this security hole.</P
></BLOCKQUOTE
><p class="para">Newer editions of <span class="acronym">UNIX</SPAN
> <kbd class="command">sh</KBD
> ignore <span class="acronym">IFS</SPAN
>
if the shell is running as <i class="filename">root</I
> or if the effective user ID differs
from the real user ID. Many other shells have similarly been enhanced,
but not all have. The idea that there are still programs being shipped
by vendors in 1995 with this same <span class="acronym">IFS</SPAN
> vulnerability
inside is interesting and very depressing. The general problem has
been known for over 10 years, and people are still making the same
(dumb) <a class="indexterm" name="AUTOID-5819"></A
><a class="indexterm" name="AUTOID-5822"></A
>
mistakes. <a class="indexterm" name="AUTOID-5824"></A
><a class="indexterm" name="AUTOID-5827"></A
><a class="indexterm" name="AUTOID-5829"></A
><a class="indexterm" name="AUTOID-5832"></A
><a class="indexterm" name="AUTOID-5834"></A
><a class="indexterm" name="AUTOID-5836"></A
><a class="indexterm" name="AUTOID-5839"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-5-SECT-5.4">5.5.4 Finding All of the SUID and SGID Files</A
></H3
><p class="para">You <a class="indexterm" name="AUTOID-5845"></A
><a class="indexterm" name="AUTOID-5848"></A
>
should know the names of all
<span class="acronym">SUID</SPAN
> and <span class="acronym">SGID</SPAN
> files on your
system. If you discover new <span class="acronym">SUID</SPAN
> or <span class="acronym">SGID</SPAN
>
files, somebody might have created a trap door that they can use
at some future time to gain superuser access. You can list all of
the <span class="acronym">SUID</SPAN
> and <span class="acronym">SGID</SPAN
> files on
your system with the command:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">find / \(-perm -004000
-o -perm -002000 \) -type f -print</B
></PRE
></BLOCKQUOTE
><p class="para">This <a class="indexterm" name="AUTOID-5860"></A
><a class="indexterm" name="AUTOID-5862"></A
><a class="indexterm" name="AUTOID-5865"></A
>
<kbd class="command">find</KBD
>
command starts in the root directory (<i class="filename">/</I
>) and
looks for all files that match mode 002000 (<span class="acronym">SGID</SPAN
>)
or mode 004000 (<span class="acronym">SUID</SPAN
>). The <kbd class="command">-type f</KBD
> option
causes the search to be restricted to files. The <kbd class="command">-print</KBD
>
option causes the name of every matching file to be printed.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> If you are using <a class="indexterm" name="AUTOID-5876"></A
>
<span class="acronym">NFS</SPAN
>, you should execute
<i class="filename">find</I
> commands only on your file servers. You
should further restrict the <kbd class="command">find</KBD
> command so that it does not try
to search networked disks. Otherwise, use of this command may cause
an excessive amount of <span class="acronym">NFS</SPAN
> traffic on your network.
To restrict your <i class="filename">find </I
>command, use the following:</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen"><b class="emphasis.bold"># find / \( -local -o -prune \)
 		\( -perm -004000 -o -perm -002000 \)  		-type f -print</B
> &#13;</PRE
></BLOCKQUOTE
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> Alternatively, if your <a class="indexterm" name="AUTOID-5888"></A
>
<kbd class="command">find</KBD
> command has the
<kbd class="command">-xdev</KBD
> option, you can use it to prevent <kbd class="command">find</KBD
> from crossing
filesystem boundaries. To search the entire filesystem using this
option means running the command multiple times, once for each mounted
partition.</P
></BLOCKQUOTE
><p class="para">Be sure that you are the superuser when you run <kbd class="command">find</KBD
>, or you
may miss <span class="acronym">SUID</SPAN
> files hidden in protected directories.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-5-SECT-5.4.1">5.5.4.1 The ncheck command</A
></H4
><p class="para">The <a class="indexterm" name="AUTOID-5900"></A
><a class="indexterm" name="AUTOID-5902"></A
>
<kbd class="command">ncheck</KBD
>
command is an old <span class="acronym">UNIX</SPAN
> command that prints a
list of each file on your system and its corresponding inode number.
When used with the <kbd class="command">-s</KBD
> option, <kbd class="command">ncheck</KBD
> restricts itself to
listing all of the &quot;special&quot; inodes on your system&nbsp;- such
as the devices and <span class="acronym">SUID</SPAN
> files.</P
><p class="para">The <kbd class="command">ncheck</KBD
> command runs on a filesystem-by-filesystem basis.
For example:</P
><blockquote class="screen"><pre class="screen"># ncheck -s | cat -ve -
/dev/dsk/c0t3d0s0:
125     /dev/fd/0
513     /dev/fd/1
514     /dev/fd/2

		...

533     /dev/fd/21
534     /dev/fd/22
535     /dev/fd/23
3849    /sbin/su
3850    /sbin/sulogin</PRE
></BLOCKQUOTE
><p class="para">(The <a class="indexterm" name="AUTOID-5914"></A
>
<kbd class="command">cat -ve</KBD
>
command is present in the above to print control characters so that
they will be noticed, and to indicate the end of line for filenames
that end in spaces.)</P
><p class="para">The <kbd class="command">ncheck</KBD
> command is very old, and has largely been superseded
by other commands. It may not be present on all versions of <span class="acronym">UNIX</SPAN
>,
although it is present in <span class="acronym">SVR4</SPAN
>. If you run it,
you may discover that it is substantially faster than the 
<kbd class="command">find</KBD
> command, because <kbd class="command">ncheck</KBD
> reads the inodes directly, rather
than searching through files in the filesystem. However, <kbd class="command">ncheck</KBD
>
still needs to read some directory information to obtain pathnames,
so it may not be that much faster.</P
><p class="para">Unlike <kbd class="command">find</KBD
>, <kbd class="command">ncheck</KBD
> will locate <span class="acronym">SUID</SPAN
> files
that are hidden beneath directories that are used as mount-point.
In this respect, <kbd class="command">ncheck</KBD
> is superior to <kbd class="command">find</KBD
>, because <kbd class="command">find</KBD
> can't
find such files because they do not have complete pathnames as long
as the mounts are mounted.</P
><p class="para">You must be superuser to run <kbd class="command">ncheck</KBD
>. <a class="indexterm" name="AUTOID-5934"></A
><a class="indexterm" name="AUTOID-5937"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-5-SECT-5.5">5.5.5 Turning Off SUID and SGID in Mounted Filesystems</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5943"></A
><a class="indexterm" name="AUTOID-5946"></A
><a class="indexterm" name="AUTOID-5948"></A
><a class="indexterm" name="AUTOID-5951"></A
><a class="indexterm" name="AUTOID-5954"></A
>If you mount remote network filesystems on
your computer, or if you allow users to mount their own floppy disks
or<span class="acronym"> CD-ROMS</SPAN
>, you usually do not want programs
that are <span class="acronym">SUID</SPAN
> on these filesystems to be <span class="acronym">SUID</SPAN
>
on your computer as well. In a network environment, honoring <span class="acronym">SUID</SPAN
>
files means that if an attacker manages to take over the remote
computer that houses the filesystem, he can also take over your
computer, simply by creating a <span class="acronym">SUID</SPAN
> program on
the remote filesystem and running the program on your machine. Likewise,
if you allow users to mount floppy disks containing <span class="acronym">SUID</SPAN
>
files on your computer, they can simply create a floppy disk with
a <span class="acronym">SUID</SPAN
> <kbd class="command">ksh</KBD
> on another computer, mount the floppy
disk on your computer, and run the program&nbsp;- making themselves
<i class="filename">root</I
>.</P
><p class="para">You can turn off the <span class="acronym">SUID</SPAN
> and <span class="acronym">SGID</SPAN
>
bits on mounted filesystems by specifying the <a class="indexterm" name="AUTOID-5968"></A
>
<kbd class="command">nosuid</KBD
> option with the <kbd class="command">mount</KBD
> command. You should
always specify this option when you mount a foreign filesystem unless
there is an overriding reason to import <span class="acronym">SUID</SPAN
>
or <span class="acronym">SGID</SPAN
> files from the filesystem you are mounting.
Likewise, if you write a program to mount floppy disks for a user,
that program should specify the <kbd class="command">nosuid</KBD
> option (because the user
can easily take his or her floppy disk to another computer and create
a <span class="acronym">SUID</SPAN
> file).</P
><p class="para">For example, to mount the filesystem <i class="filename">athena</I
> in the <i class="filename">/usr/athena</I
>
directory from the machine <i class="filename">zeus</I
> with the <kbd class="command">nosuid</KBD
> option, type the
command:</P
><blockquote class="screen"><pre class="screen"># /etc/mount -o nosuid zeus:/athena /usr/athena</PRE
></BLOCKQUOTE
><p class="para">Some systems also support a <a class="indexterm" name="AUTOID-5984"></A
>
<kbd class="command">-nodev</KBD
> option that causes the system to ignore
device files that may be present on the mounted partition. If your
system supports this option, you should use it, too. If your user
creates a floppy with a mode 777 <i class="filename">kmem</I
>, for
instance, he can subvert the system with little difficulty if he
is able to mount the floppy disk. This is because <span class="acronym">UNIX</SPAN
>
treats the <i class="filename">/dev/kmem </I
>on the floppy disk the
same way that it treats the <i class="filename">/dev/kmem </I
>on your
main system disk&nbsp;- it is a device that maps to your system's
kernel memory.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-5-SECT-5.6">5.5.6 SGID and Sticky Bits on Directories</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5995"></A
><a class="indexterm" name="AUTOID-5998"></A
><a class="indexterm" name="AUTOID-6001"></A
><a class="indexterm" name="AUTOID-6004"></A
>Although
the <span class="acronym">SGID</SPAN
> and sticky bits were originally intended
for use only with programs, Berkeley <span class="acronym">UNIX</SPAN
>, SunOS,
Solaris and other operating systems also use these bits to change
the behavior of directories, as shown in <a class="xref" href="#PUIS-CHP-5-TAB-14" title="Behavior of SGID and Sticky Bits with Directories">Table 5.14</A
>.</P
><table class="table"><caption class="table"><a class="title" name="PUIS-CHP-5-TAB-14">Table 5.14: Behavior of SGID and Sticky Bits with Directories</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Bit</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Effect</P
></TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">SGID bit</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">The SGID bit on a directory controls
the way that groups are assigned for files created in the directory.
If the SGID bit is set, files created in the directory have the
same group as the directory if the process creating the file also
is in that group. Otherwise, if the SGID bit is not set, or if the
process is not in the same group, files created inside the directory
have the same group as the user's effective group ID (usually
the primary group ID).</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Sticky bit</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">If the sticky bit is set on a directory,
files inside the directory may be renamed or removed only by the
owner of the file, the owner of the directory, or the superuser
(even if the modes of the directory would otherwise allow such an
operation); on some systems, any user who can write to a file can
also delete it. This feature was added to keep an ordinary user
from deleting another's files in the <i class="filename">/tmp</I
> directory.</P
></TD
></TR
></TBODY
></TABLE
><p class="para">For example, to set the mode of the <i class="filename">/tmp</I
> directory
on a system so any user can create or delete her own files but can't
delete another's files, type the command:</P
><blockquote class="screen"><pre class="screen"># chmod 1777 /tmp</PRE
></BLOCKQUOTE
><p class="para">Many older versions of <span class="acronym">UNIX</SPAN
> (System V prior
to Release 4, for instance) do not exhibit either of these behaviors.
On those systems, the <span class="acronym">SGID</SPAN
> and sticky bits on
directories are ignored by the system. However, on a few of these
older systems (including <span class="acronym">SVR3</SPAN
>), setting the <span class="acronym">SGID</SPAN
>
bit<em class="emphasis"> </EM
>on the directory resulted in &quot;sticky&quot;
behavior.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-5-SECT-5.7">5.5.7 SGID Bit on Files (System V UNIX Only): Mandatory
Record Locking</A
></H3
><p class="para">If <a class="indexterm" name="AUTOID-6045"></A
><a class="indexterm" name="AUTOID-6048"></A
><a class="indexterm" name="AUTOID-6051"></A
><a class="indexterm" name="AUTOID-6054"></A
>
the <span class="acronym">SGID</SPAN
>
bit is set on a nonexecutable file, <span class="acronym">AT&T</SPAN
>
System V <span class="acronym">UNIX</SPAN
> implements mandatory record locking
for the file. Normal <span class="acronym">UNIX</SPAN
> record locking is discretionary;
processes can modify a locked file simply by ignoring the record-lock
status. On System V <span class="acronym">UNIX</SPAN
>, the kernel blocks a
process which tries to access a file (or the portion of the file)
that is protected with mandatory record locking until the process
that has locked the file unlocks it. Mandatory locking is enabled
only if <em class="emphasis">none </EM
>of the execute permission bits
are turned on.</P
><p class="para">Mandatory record locking shows up in an <i class="filename">ls</I
>
listing in the <span class="acronym">SGID</SPAN
> position as a capital &quot;S&quot;
instead of a small &quot;s&quot;:</P
><blockquote class="screen"><pre class="screen">% <b class="emphasis.bold">ls -F data*</B
> 
-rw-rwS--- 1 fred         2048 Dec 3 1994 database 
-r-x--s--x 2 bin         16384 Apr 2 1993 datamaint* <a class="indexterm" name="AUTOID-6068"></A
><a class="indexterm" name="AUTOID-6070"></A
>
 </PRE
></BLOCKQUOTE
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_04.htm" title="5.4 Using Directory Permissions"><img src="../gifs/txtpreva.gif" alt="Previous: 5.4 Using Directory Permissions" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Practical UNIX &amp; Internet Security"><img src="../gifs/txthome.gif" alt="Practical UNIX &amp; Internet Security" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch05_06.htm" title="5.6 Device Files"><img src="../gifs/txtnexta.gif" alt="Next: 5.6 Device Files" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">5.4 Using Directory Permissions</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">5.6 Device Files</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
