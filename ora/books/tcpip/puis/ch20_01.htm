<html><head>
<title>[Chapter 20] NFS</TITLE>
<meta name="DC.title" content="Practical UNIX &amp; Internet Security"><meta name="DC.creator" content="Simson Garfinkel &amp; Gene Spafford"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T00:15:49Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-148-8" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="part04.htm" title="IV. Network and Internet Security"><link rel="prev" href="ch19_07.htm#PUIS-CHP-19-SECT-7.1" title="19.7 Other Network Authentication Systems"><link rel="next" href="ch20_02.htm#PUIS-CHP-20-SECT-2.1.1" title="20.2 Server-Side NFS Security"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Practical UNIX &amp; Internet Security" usemap="#srchmap" border="0"></H1
><map name="srchmap"index.html><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Practical UNIX &amp; Internet Security"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch19_07.htm#PUIS-CHP-19-SECT-7.1" title="19.7 Other Network Authentication Systems"><img src="../gifs/txtpreva.gif" alt="Previous: 19.7 Other Network Authentication Systems" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 20</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch20_02.htm#PUIS-CHP-20-SECT-2.1.1" title="20.2 Server-Side NFS Security"><img src="../gifs/txtnexta.gif" alt="Next: 20.2 Server-Side NFS Security" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="CHAPTER"><h1 class="chapter"><a class="title" name="PUIS-CHP-20">20. NFS</A
></H1
><div class="htmltoc"><p><b>Contents:</B
><br><a class="SECT1" href="#PUIS-CHP-20-SECT-1" title="20.1 Understanding NFS">Understanding NFS</A
><br><a class="SECT1" href="ch20_02.htm#PUIS-CHP-20-SECT-2.1.1" title="20.2 Server-Side NFS Security">Server-Side NFS Security</A
><br><a class="SECT1" href="ch20_03.htm" title="20.3 Client-Side NFS Security">Client-Side NFS Security</A
><br><a class="SECT1" href="ch20_04.htm#PUIS-CHP-20-SECT-4.8" title="20.4 Improving NFS Security">Improving NFS Security</A
><br><a class="SECT1" href="ch20_05.htm" title="20.5 Some Last Comments">Some Last Comments</A
></P
><p></P
></DIV
><p class="para">In many environments, we want to share files and programs
among many workstations in a local area network. Doing so requires
programs that let us share the files, create new files, do file
locking, and manage ownership correctly. Over the last dozen years
there have been a number of network-capable filesystems developed
by commercial firms and research groups. These have included Apollo
Domain, the Andrew Filesystem (<span class="acronym">AFS</SPAN
>), the AT&amp;T
Remote Filesystem (<span class="acronym">RFS</SPAN
>), and Sun Microsystems'
Network Filesystem (<span class="acronym">NFS</SPAN
>). Each of these has had
beneficial features and limiting drawbacks.</P
><p class="para">Of all the network filesystems, <span class="acronym">NFS</SPAN
> is
probably the most widely used. <span class="acronym">NFS</SPAN
> is available
on almost all versions of <span class="acronym">UNIX</SPAN
>, as well as on
Apple Macintosh systems, MS-<span class="acronym">DOS</SPAN
>, Windows, <span class="acronym">OS/2</SPAN
>,
and <span class="acronym">VMS</SPAN
>. <span class="acronym">NFS</SPAN
> has continued
to mature, and we expect that Version 3 of <span class="acronym">NFS</SPAN
>
will help to perpetuate and expand its reach. For this reason, we
will focus in this book on the security implications of running
<span class="acronym">NFS</SPAN
> on your <span class="acronym">UNIX</SPAN
> systems.
If you use one of the other forms of network filesystems, there
are associated security considerations, many of which are similar
to the ones we present here: be sure to consult your vendor documentation.</P
><div class="sect1"><h2 class="sect1"><a class="title" name="PUIS-CHP-20-SECT-1">20.1 Understanding NFS</A
></H2
><p class="para">Using <span class="acronym">NFS</SPAN
>, clients can mount partitions
of a server as if they were physically connected to the client.
In addition to simply allowing remote access to files over the network,
<span class="acronym">NFS</SPAN
> allows many (relatively) low-cost computer
systems to share the same high-capacity disk drive at the same time.
<span class="acronym">NFS</SPAN
> server programs have been written for many
different operating systems, which let users on <span class="acronym">UNIX</SPAN
>
workstations have remote access to files stored on a variety of
different platforms. <span class="acronym">NFS</SPAN
> clients have been written
for microcomputers such as the <span class="acronym">IBM/PC</SPAN
> and Apple
Macintosh, giving PC users much of the same flexibility enjoyed
by their <span class="acronym">UNIX</SPAN
> coworkers, as well as a relatively
easy method of data interchange.</P
><p class="para"><span class="acronym">NFS</SPAN
> is nearly transparent. In practice,
a workstation user simply logs into the workstation and begins working,
accessing it as if the files were locally stored. In many environments,
workstations are set up to mount the disks on the server automatically
at boot time or when files on the disk are first referenced. <span class="acronym">NFS</SPAN
>
also has a network mounting program that can be configured to mount
the <span class="acronym">NFS</SPAN
> disk automatically when an attempt is
made to access files stored on remote disks.</P
><p class="para">There are several basic security problems with <span class="acronym">NFS</SPAN
>:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><span class="acronym">NFS</SPAN
> is built on
top of Sun's <span class="acronym">RPC</SPAN
> (Remote Procedure Call),
and in most cases uses <span class="acronym">RPC</SPAN
> for user authentication.
Unless a secure form of <span class="acronym">RPC</SPAN
> is used, <span class="acronym">NFS</SPAN
>
can be easily spoofed.</P
></LI
><li class="listitem"><p class="para">Even when Secure <span class="acronym">RPC</SPAN
> is used,
information sent by <span class="acronym">NFS</SPAN
> over the network is not
encrypted, and is thus subject to monitoring and eavesdropping.
As we mention elsewhere, the data can be intercepted and replaced
(thereby corrupting or Trojaning files being imported via <span class="acronym">NFS</SPAN
>).</P
></LI
><li class="listitem"><p class="para"><span class="acronym">NFS</SPAN
> uses the standard <span class="acronym">UNIX</SPAN
>
filesystem for access control, opening the networked filesystem
to many of the same problems as a local filesystem.</P
></LI
></UL
><p class="para">One of the key design features behind <span class="acronym">NFS</SPAN
>
is the concept of <i class="firstterm">server</I
> <i class="filename">statelessness</I
>.
Unlike several other systems, there is no &quot;state&quot;
kept on a server to indicate that a client is performing a remote
file operation. Thus, if the client crashes and is rebooted, there
is no state in the server that needs to be recovered. Alternatively,
if the server crashes and is rebooted, the client can continue operating
on the remote file as if nothing really happened&nbsp;- there
is no server-side state to recreate.[1] We'll discuss this concept further
in later sections.</P
><blockquote class="footnote"><p class="para">[1] Actual implementations
are not completely stateless, however, as we will see later in this
chapter.</P
></BLOCKQUOTE
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-20-SECT-1.1">20.1.1 NFS History</A
></H3
><p class="para"><span class="acronym">NFS</SPAN
> was developed inside Sun Microsystems
in the early 1980s. Since that time, <span class="acronym">NFS</SPAN
> has
undergone three major revisions:</P
><dl class="variablelist"><dt class="term">NFS Version 1</DT
><dd class="listitem"><p class="para"><span class="acronym">NFS</SPAN
> Version 1 was Sun's
prototype network filesystem. This version was never released to
the outside world.</P
></DD
><dt class="term">NFS Version 2</DT
><dd class="listitem"><p class="para"><span class="acronym">NFS</SPAN
> Version 2 was first distributed
with Sun's SunOS 2 operating system in 1985. Version 2
was widely licensed to numerous <span class="acronym">UNIX</SPAN
> workstation
vendors. A freely distributable, compatible version was developed
in the late 1980s at the University of California at Berkeley.</P
><p class="para">During its 10-year life, many subtle, undocumented
changes were made to the <span class="acronym">NFS</SPAN
> version 2 specification.
Some vendors allowed <span class="acronym">NFS</SPAN
> version 2 to read or
write more than 4K bytes at a time; others increased the number
of groups provided as part of the <span class="acronym">RPC</SPAN
> authentication
from 8 to 16. Although these minor changes created occasional incompatibilities
between different <span class="acronym">NFS</SPAN
> implementations, <span class="acronym">NFS</SPAN
>
version 2 provided a remarkable degree of compatibility between
systems made by different vendors.</P
></DD
><dt class="term">NFS Version 3</DT
><dd class="listitem"><p class="para">The <span class="acronym">NFS</SPAN
> Version 3 specification
was developed during a series of meetings in Boston in July, 1992.[2]
Working code for <span class="acronym">NFS</SPAN
> Version 3 was introduced
by some vendors in 1995, and is expected to be widely available
in 1996. Version 3 incorporates many performance improvements over
Version 2, but does not significantly change the way that <span class="acronym">NFS</SPAN
>
works or the security model used by the network filesystem.</P
><blockquote class="footnote"><p class="para">[2] Pawlowski, Juszczak, Staubach, Smith, Lebel and Hitz, &quot;NFS
Version 3 Design and Implementation,&quot; USENIX Summer 1994
conference. The standard was later codified as RFC 1813. A copy
of the NFS Version 3 paper can be obtained from <a class="systemitem.url" href="../../../../../../../www.netapp.com/Docs/TechnicalDocs/nfs_version_3.html">http://www.netapp.com/Docs/TechnicalDocs/nfs_version_3.html</A
>.
The RFC can be downloaded from <a class="systemitem.url" href="../../../../../../../ds.internic.net/rfc/rfc1813.txt">http://ds.internic.net/rfc/rfc1813.txt</A
>.</P
></BLOCKQUOTE
></DD
></DL
><p class="para"><span class="acronym">NFS</SPAN
><a class="indexterm" name="AUTOID-28045"></A
>
is based on two similar but distinct
protocols: <span class="acronym">MOUNT</SPAN
> <a class="indexterm" name="AUTOID-28049"></A
>
and
<span class="acronym">NFS</SPAN
>. Both make use of a data object known as
a <i class="firstterm">file handle</I
>. There is also a distributed
protocol for file locking, which is not technically part of <span class="acronym">NFS</SPAN
>,
and which does not have any obvious security ramifications (other
than those related to potential denial of service attacks for its
users), so we won't describe the file locking protocol
here.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-20-SECT-1.2">20.1.2 <a class="indexterm" name="AUTOID-28057"></A
>File Handles</A
></H3
><p class="para">Each object on the <span class="acronym">NFS</SPAN
>-mounted filesystem
is referenced by a unique object called a<i class="firstterm"> file handle</I
>.
A file handle is viewed by the client as being <i class="firstterm">opaque</I
>&nbsp;- the
client cannot interpret the contents. However, to the server, the
contents have considerable meaning. The file handles uniquely identify
every file and directory on the server computer.</P
><p class="para">Under <span class="acronym">UNIX</SPAN
>, a file handle consists of at
least three important elements: the <em class="emphasis">filesystem identifier</EM
>,
the <em class="emphasis">file identifier</EM
>, and a <i class="firstterm">generation
count</I
>. The file identifier can be something as simple
as an inode number to refer to a particular item on a partition.
The filesystem identifier refers to the partition containing the
file (inode numbers are unique per partition, but not per system).
The file handle doesn't include a pathname; a pathname
is not necessary and is in fact subject to change while a file is
being accessed.</P
><p class="para">The generation count is a number that is incremented each
time a file is unlinked and recreated. The generation count ensures
that when a client references a file on the server, that file is
in fact the same file that the server thinks it is. Without a generation
count, two clients accessing the same file on the server could produce
erroneous results if one client deleted the file and created a new
file with the same inode number. The generation count prevents such
situations from occurring: when the file is recreated, the generation
number is incremented, and the second client gets an error message
when it attempts to access the older, now nonexistent, file.</P
><div class="sidebar"><h4 class="sidebar"><a class="title" name="AUTOID-28069">Which Is Better: Stale Handles or Stale Love?</A
></H4
><p class="para">To better understand the role of the generation
count, imagine a situation in which you are writing a steamy love
letter to a colleague with whom you are having a clandestine affair.
You start by opening a new editor file on your workstation. Unbeknownst
to you, your editor puts the file in the <i class="filename">/tmp</I
>
directory, which happens to be on the <span class="acronym">NFS</SPAN
> server.
The server allocates an inode from the free list on that partition,
constructs a file handle for the new file, and sends the file handle
to your workstation (the client). You begin editing the file. &quot;My
darling chickadee, I remember last Thursday in your office,&quot;
you start to write, only to be interrupted by a long phone call.</P
><p class="para">You
aren't aware of it, but as you are talking on the phone,
there is a power flicker in the main computer room, and the server
crashes and reboots. As part of the reboot, the temporary file for
your mailer is deleted along with everything else in the <i class="filename">/tmp</I
>
directory, and its inode is added back to the free list on the server.
While you are still talking on the phone, your manager starts to
compose a letter to the president of the company, recommending a
raise and promotion for you. He also opens a file in the <i class="filename">/tmp</I
>
directory, and his diskless workstation is allocated a file handle
for the same inode that you were using (it is free now, after all)!</P
><p class="para">You finally finish your call and return to your letter.
Of course, you notice nothing out of the ordinary because of the
stateless nature of <span class="acronym">NFS</SPAN
>. You put the finishing
touches on your letter, &quot;... and I can't
wait until this weekend; my wife suspects nothing!&quot; and
save it. Your manager finishes his letter at the same moment: &quot;...
as a reward for his hard work and serious attitude, I recommend
a 50% raise.&quot; Your manager and you hit the &quot;send&quot;
key simultaneously.</P
><p class="para">Without a generation count, the
results might be less than amusing. The object of your affection
could get a letter about you deserving a raise. Or, your manager's
boss could get a letter concerning a midday dalliance on the desktop.
Or, both recipients might get a mixture of the two versions, with
each version containing one file record from one file and one from
another. The problem is that the system can't distinguish
the two files because the file handles are the same.</P
><p class="para">This
sort of thing occasionally happened before Sun got the generation-count
code working properly and consistently. With the generation-count
software working as it should, you would instead get an error message
stating &quot;Stale <span class="acronym">NFS</SPAN
> File Handle&quot;
when you try to access the (now deleted) file. That's because
the server increments the generation count value in the inode when
the inode is returned to the free list. Later, whenever the server
receives a request from a client that has a valid file handle <em class="emphasis">except
for the generation count</EM
>, the server rejects the operation
and returns an error.</P
></DIV
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> Some <span class="acronym">NFS</SPAN
> servers ignore the generation
count in the file handle. These versions of <span class="acronym">NFS</SPAN
>
are considerably less secure, as they enable an attacker to easily
create valid file handles for directories on the server.</P
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-20-SECT-1.3">20.1.3 MOUNT Protocol</A
></H3
><p class="para">The <span class="acronym">MOUNT</SPAN
> protocol is used for the initial
negotiation between the <span class="acronym">NFS</SPAN
> client and the <span class="acronym">NFS</SPAN
>
server. Using <span class="acronym">MOUNT</SPAN
>, a client can determine which
filesystems are available for mounting and can obtain a token (the
file handle) which is used to access the root directory of a particular
filesystem. After that file handle is returned, it can thereafter
be used to retrieve file handles for other directories and files
on the server.</P
><p class="para">Another benefit of the <span class="acronym">MOUNT</SPAN
> protocol is
that you can export only a portion of a local partition to a remote
client. By specifying that the root is a directory on the partition,
the <span class="acronym">MOUNT</SPAN
> service will return its file handle
to the client. To the client, this file handle behaves exactly as
one for the root of a partition: reads, writes, and directory lookups
all behave the same way.</P
><p class="para"><span class="acronym">MOUNT</SPAN
> is an <span class="acronym">RPC</SPAN
> service.
The service is provided by the <kbd class="command">mountd</KBD
> or <kbd class="command">rpc.mountd</KBD
>
daemon, which is started automatically at boot. (On Solaris 2.x
systems, for example, <kbd class="command">mountd</KBD
> is located in <i class="firstterm">/usr/lib/nfs/</I
><i class="filename">mountd,</I
>
and is started by the startup script <i class="filename">/etc/rc3.d/S15nfs.server</I
>.)
<span class="acronym">MOUNT</SPAN
> is often given the <span class="acronym">RPC</SPAN
>
program number 100,005. The standard mountd can respond to seven
different requests:</P
><table class="informaltable"><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">NULL</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Does nothing.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">MNT</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns a file handle for a filesystem.
Advises the <kbd class="command">mount</KBD
> daemon that a client has mounted the filesystem.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">DUMP</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns the list of mounted filesystems.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">UMNT</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Removes the <kbd class="command">mount</KBD
> entry for this client
for a particular filesystem.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">UMNTALL</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Removes all <kbd class="command">mount</KBD
> entries for this client.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">EXPORT</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns the server's export
list to the client.</P
></TD
></TR
></TBODY
></TABLE
><p class="para">Although the <span class="acronym">MOUNT</SPAN
> protocol provides useful
information within an organization, the information that it provides
could be used by those outside an organization to launch an attack.
For this reason, you should prevent people outside your organization
from accessing your computer's <kbd class="command">mount</KBD
> daemon. Two ways of
providing this protection are via the <kbd class="command">portmapper</KBD
> wrapper, and via
an organizational firewall. See Chapter 22, <em class="emphasis">Wrappers and Proxies,</EM
>
and <a class="xref" href="ch21_01.htm" title="Firewalls">Chapter 21, <cite class="chapter">Firewalls</CITE
></A
>, for
further information.</P
><p class="para">The <span class="acronym">MOUNT</SPAN
> protocol is based on Sun Microsystem's
Remote Procedure Call (<span class="acronym">RPC</SPAN
>) and External Data
Representation (<span class="acronym">XDR</SPAN
>) protocols. For a complete
description of the <span class="acronym">MOUNT</SPAN
> protocol see <span class="acronym">RFC</SPAN
>
1094.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-20-SECT-1.4">20.1.4 NFS Protocol</A
></H3
><p class="para">The <span class="acronym">NFS</SPAN
> protocol takes over where the <span class="acronym">MOUNT</SPAN
>
protocol leaves off. With the <span class="acronym">NFS</SPAN
> protocol, a
client can list the contents of an exported filesystem's
directories; obtain file handles for other directories and files;
and even create, read, or modify files (as permitted by <span class="acronym">UNIX</SPAN
>
permissions.)</P
><p class="para">Here is a list of the <span class="acronym">RPC</SPAN
> functions that
perform operations on directories:</P
><table class="informaltable"><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">CREATE</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Creates (or truncates) a file in the
directory</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">LINK</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Creates a hard link</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">LOOKUP</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Looks up a file in the directory</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">MKDIR</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Makes a directory</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">READADDR</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Reads the contents of a directory</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">REMOVE</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Removes a file in the directory</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">RENAME</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Renames a file in the directory</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">RMDIR</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Removes a directory</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">SYMLINK</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Creates a symbolic link</P
></TD
></TR
></TBODY
></TABLE
><p class="para">These <span class="acronym">RPC</SPAN
> functions can be used with files:</P
><table class="informaltable"><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">GETATTR</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Gets a file's attributes (owner,
length, etc.)</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">SETATTR</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Sets some of a file's attributes</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">READLINK</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Reads a symbolic link's path</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">READ</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Reads from a file.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">WRITE</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Writes to a file.</P
></TD
></TR
></TBODY
></TABLE
><p class="para"><span class="acronym">NFS</SPAN
> version 3 adds a number of additional
<span class="acronym">RPC</SPAN
> functions. With the exception of <span class="acronym">MKNOD3</SPAN
>,
these new functions simply allow improved performance:</P
><table class="informaltable"><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">ACCESS</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Determines if a user has the permission
to access a particular file or directory.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">FSINFO</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns static information about a filesystem.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">FSSTAT</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns dynamic information about a filesystem.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><i class="function">MKNOD</I
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Creates a device or special file on the
remote filesystem.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><i class="function">READDIRPLUS</I
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Reads a directory and returns the file
attributes for each entry in the directory.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><i class="function">PATHCONF</I
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Returns the attributes of a file specified
by pathname.</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para"><i class="function">COMMIT</I
></P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">Commits the NFS write cache to disk.</P
></TD
></TR
></TBODY
></TABLE
><p class="para">All communication between the <span class="acronym">NFS</SPAN
> client
and the <span class="acronym">NFS</SPAN
> server is based upon Sun's
<span class="acronym">RPC</SPAN
> system, which lets programs running on one
computer call subroutines that are executed on another. <span class="acronym">RPC</SPAN
>
uses Sun's <span class="acronym">XDR</SPAN
> system to allow the exchange
of information between different kinds of computers. For speed and
simplicity, Sun built <span class="acronym">NFS</SPAN
> upon the Internet User
Datagram Protocol (<span class="acronym">UDP</SPAN
>); however, <span class="acronym">NFS</SPAN
>
version 3 allows the use of <span class="acronym">TCP</SPAN
>, which actually
improves performance over low-bandwidth, high-latency links such
as modem-based <span class="acronym">PPP</SPAN
> connections.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-20-SECT-1.4.1">20.1.4.1 How NFS creates a reliable filesystem from a best-effort
protocol</A
></H4
><p class="para"><span class="acronym">UDP</SPAN
> is fast but only best-effort: &quot;Best
effort&quot; means that the protocol does not guarantee that
<span class="acronym">UDP</SPAN
> packets transmitted will ever be delivered,
or that they will be delivered in order. <span class="acronym">NFS</SPAN
>
works around this problem by requiring the <span class="acronym">NFS</SPAN
>
server to acknowledge every <span class="acronym">RPC</SPAN
> command with
a result code that indicates whether the command was successfully
completed or not. If the <span class="acronym">NFS</SPAN
> client does not
get an acknowledgment within a certain amount of time, it retransmits
the original command.</P
><p class="para">If the <span class="acronym">NFS</SPAN
> client does not receive an acknowledgment,
then <span class="acronym">UDP</SPAN
> lost either the original <span class="acronym">RPC</SPAN
>
command or the <span class="acronym">RPC</SPAN
> acknowledgment. If the original
<span class="acronym">RPC</SPAN
> command was lost, there is no problem&nbsp;- the
server sees it for the first time when it is retransmitted. But
if the acknowledgment was lost, the server will actually get the
same <span class="acronym">NFS</SPAN
> command twice.</P
><p class="para">For most <span class="acronym">NFS</SPAN
> commands, this duplication
of requests presents no problem. With <span class="acronym">READ</SPAN
>, for
example, the same block of data can be read once or a dozen times,
without consequence. Even with the <span class="acronym">WRITE</SPAN
> command,
the same block of data can be written twice to the same point in
the file, without consequence.[3]</P
><blockquote class="footnote"><p class="para">[3] This is precisely
the reason that NFS does not have an atomic command for appending
information to the end of a file.</P
></BLOCKQUOTE
><p class="para">Other commands, however, cannot be executed twice in a row.
<span class="acronym">MKDIR</SPAN
>, for example, will fail the second time
that it is executed because the requested directory will already
exist. For commands that cannot be repeated, some <span class="acronym">NFS</SPAN
>
servers maintain a cache of the last few commands that were executed.
When the server receives a <span class="acronym">MKDIR</SPAN
> request, it
first checks the cache to see if it has already received the <span class="acronym">MKDIR</SPAN
>
request. If so, the server merely retransmits the acknowledgment
(which must have been lost).</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-20-SECT-1.4.2">20.1.4.2 Hard, soft, and spongy mounts</A
></H4
><p class="para">If the <span class="acronym">NFS</SPAN
> client still receives no acknowledgment,
it will retransmit the request again and again, each time doubling
the time that it waits between retries. If the network filesystem
was mounted with the <kbd class="command">soft</KBD
> option, the request will eventually time
out. If the network filesystem is mounted with the <kbd class="command">hard</KBD
> option,
the client continues sending the request until the client is rebooted
or gets an acknowledgment. <span class="acronym">BSDI</SPAN
> and <span class="acronym">OSF</SPAN
>/1
also have a spongy option that is similar to <kbd class="command">hard</KBD
>, except that the
<kbd class="command">stat, lookup, fsstat, readlink,</KBD
> and <kbd class="command">readdir</KBD
> operations behave like
a <kbd class="command">soft</KBD
> <span class="acronym">MOUNT</SPAN
>.</P
><h4 class="figure"><a class="title" name="PUIS-CHP-20-FIG-1">Figure 20.1: NFS protocol stack</A
></H4
><img class="graphic" src="figs/puis_2001.gif" alt="Figure 20.1"><p class="para"><span class="acronym">NFS</SPAN
> uses the <kbd class="command">mount</KBD
> command
to specify if a filesystem is mounted with the <kbd class="command">hard</KBD
> or <kbd class="command">soft</KBD
> option.
To mount a filesystem soft, specify the soft option. For example:</P
><blockquote class="screen"><pre class="screen">/etc/mount -o soft zeus:/big /zbig</PRE
></BLOCKQUOTE
><p class="para">This command mounts the directory <i class="filename">/big</I
> stored on
the server called zeus locally in the directory <i class="filename">/zbig.</I
>
The option <kbd class="command">-o</KBD
> soft tells the <kbd class="command">mount</KBD
> program that you wish
the filesystem mounted soft.</P
><p class="para">To mount a filesystem hard, do not specify the <kbd class="command">soft</KBD
> option:</P
><blockquote class="screen"><pre class="screen">/etc/mount zeus:/big /zbig</PRE
></BLOCKQUOTE
><p class="para">Deciding whether to mount a filesystem hard or soft can be
difficult, because there are advantages and disadvantages to each
option. Diskless workstations often hard-mount the directories that
they use to keep system programs; if a server crashes, the workstations
wait until the server is rebooted, then continue file access with
no problem. Filesystems containing home directories are usually
hard mounted, so that all disk writes to those filesystems will
be correctly performed.</P
><p class="para">On the other hand, if you mount many filesystems with the
hard option, you will discover that your workstation may stop working
every time any server crashes until it reboots. If there are many
libraries and archives that you keep mounted on your system, but
which are not critical, you may wish to mount them soft. You may
also wish to specify the <kbd class="command">intr</KBD
> option, which is like the <kbd class="command">hard</KBD
> option
except that the user can interrupt it by typing the kill character
(usually control-C).</P
><p class="para">As a general rule of thumb, read-only filesystems can be mounted
soft without any chance of accidental loss of data. But you will
have problems if you try to run programs off partitions that are
soft-mounted, because when you get errors, the program that you
are running will crash.</P
><p class="para">An alternative to using soft mounts is to mount everything
hard (or <kbd class="command">spongy</KBD
>, when available), but to avoid mounting your nonessential
<span class="acronym">NFS</SPAN
> partitions directly in the <i class="filename">root</I
> directory.
This practice will prevent the <span class="acronym">UNIX</SPAN
> 
<kbd class="command">getpwd()</KBD
>
function from hanging when a server is down.[4]</P
><blockquote class="footnote"><p class="para">[4] Hal
Stern, in Managing NFS and NIS, says that any filesystem that is
read-write or on which you are mounting executables should be mounted
hard to avoid corruption. His analogy with a dodgy NFS server is
that hard mount behaves like a slow drive, while soft mount behaves
like a broken drive!</P
></BLOCKQUOTE
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-20-SECT-1.4.3">20.1.4.3 Connectionless and stateless</A
></H4
><p class="para">As we've mentioned, <span class="acronym">NFS</SPAN
> servers
are <i class="firstterm">stateless</I
> by design. <a class="indexterm" name="AUTOID-28375"></A
>
Stateless
means that all of the information that the client needs to mount
a remote filesystem is kept on the client, instead of having additional
information with the mount stored on the server. After a file handle
is issued for a file, that file handle will remain good even if
the server is shut down and rebooted, as long as the file continues
to exist and as long as no major changes are made to the configuration
of the server that would change the values (e.g., a file system
rebuild or restore from tape).</P
><p class="para">Early <span class="acronym">NFS</SPAN
> servers were also <i class="firstterm">connectionless</I
>.
Connectionless means that the server program does not keep track
of every client that has remotely mounted the filesystem.[5]
When offering <span class="acronym">NFS</SPAN
> over a <span class="acronym">TCP</SPAN
>
connection, however, <span class="acronym">NFS</SPAN
> is not connectionless:
there is one <span class="acronym">TCP</SPAN
> connection for each mounted
filesystem.</P
><blockquote class="footnote"><p class="para">[5] An NFS server computer does keep track of clients that mount
their filesystems remotely. The <i class="filename">/usr/etc/rpc.</I
>mountd
program maintains this database; however, a computer that is not
in this database can still access the server's filesystem
even if it is not registered in the rpc.mountd database.</P
></BLOCKQUOTE
><p class="para">The advantage of a stateless, connectionless system is that
such systems are easier to write and debug. The programmer does
not need to write any code for reestablishing connections after
the network server crashes and restarts, because there is no connection
that must be reestablished. If a client should crash (or if the
network should become disconnected), valuable resources are not
tied up on the server maintaining a connection and state for that
client.</P
><p class="para">A second advantage of this approach is that it scales. That
is, a connectionless, stateless <span class="acronym">NFS</SPAN
> server works
equally well if ten clients are using a filesystem or if ten thousand
are using it. Although system performance suffers under extremely
heavy use, every file request made by a client using <span class="acronym">NFS</SPAN
>
will eventually be satisfied, and there is absolutely no performance
penalty if a client mounts a filesystem but never uses it.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-20-SECT-1.4.4">20.1.4.4 NFS and root</A
></H4
><p class="para">Because the superuser can do so much damage on the typical
<span class="acronym">UNIX</SPAN
> system, <span class="acronym">NFS</SPAN
> takes special
precautions in the way that it handles the superuser running on
client computers.</P
><p class="para">Instead of giving the client superuser unlimited privileges
on the <span class="acronym">NFS</SPAN
> server, <span class="acronym">NFS</SPAN
> gives
the superuser on the clients virtually no privileges: the superuser
gets mapped to the <span class="acronym">UID</SPAN
> of the <i class="filename">nobody</I
> user&nbsp;- usually
a <span class="acronym">UID</SPAN
> of 32767 or 60001 (although occasionally
-1 or -2 on pre-<span class="acronym">POSIX</SPAN
> systems).[6] Some versions of <span class="acronym">NFS</SPAN
>
allow you to specify the <span class="acronym">UID</SPAN
> to which to map
<i class="filename">root</I
>'s accesses, with the <span class="acronym">UID</SPAN
> of the
nobody user as the default.</P
><blockquote class="footnote"><p class="para">[6] The
UNIX kernel maps accesses from client superusers to the kernel variable
<i class="filename">nobody</I
>, which is set to different values on different systems. Historically,
the value of <i class="filename">nobody</I
> was -1, although Solaris defines <i class="filename">nobody</I
> to be
60001. You can change this value to 0 through the use of <kbd class="command">adb</KBD
>,
making all superuser requests automatically be treated as superuser
on the NFS server. In the immortal words of Ian D. Horswill, &quot;The
Sun kernel has a user-patchable cosmology. It contains a polytheism
bit called `nobody.'...The default corresponds
to a basically Greek pantheon in which there are many Gods and they're
all trying to screw each other (both literally and figuratively
in the Greek case). However, by using <kbd class="command">adb</KBD
> to
set the kernel variable <i class="filename">nobody</I
> to 0 in the divine boot image, you
can move to a Ba'hai cosmology in which all Gods are really
manifestations of the One Root God, Zero, thus inventing monotheism.&quot;
(<em class="emphasis">The UNIX-Haters Handbook</EM
>, Garfinkel et al.
IDG Books, 1994. p. 291)</P
></BLOCKQUOTE
><p class="para">Thus, superusers on <span class="acronym">NFS</SPAN
> client machines
actually have fewer privileges (with respect to the <span class="acronym">NFS</SPAN
>
server) than ordinary users. However, this lack of privilege isn't
usually much of a problem for would-be attackers who have <i class="filename">root</I
> access,
because the superuser can simply <kbd class="command">su</KBD
> to a different <span class="acronym">UID</SPAN
>
such as <i class="filename">bin</I
> or <i class="filename">sys</I
>. On the other hand, treating the superuser in
this way can protect other files on the <span class="acronym">NFS</SPAN
> server.</P
><p class="para"><span class="acronym">NFS</SPAN
> does no remapping of any other <span class="acronym">UID</SPAN
>,
nor does it do any remapping of any <span class="acronym">GID</SPAN
> values.
Thus, if a server exports any file or directory with access permissions
for some user or group, the superuser on a client machine can take
on an identity to access that information. This rule implies that
the exported file can be read or copied by someone remote, or worse,
modified without authorization.</P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-20-SECT-1.5">20.1.5 NFS Version 3</A
></H3
><p class="para">During the ten years of the life of <span class="acronym">NFS</SPAN
>
Version 2, a number of problems were discovered with it. These problems
included:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><span class="acronym">NFS</SPAN
> was originally
based on <span class="acronym">AUTH_UNIX</SPAN
> <span class="acronym">RPC</SPAN
> security.
As such, it provided almost no protection against spoofing. <span class="acronym">AUTH_UNIX</SPAN
>
simply used the stated <span class="acronym">UID</SPAN
> and <span class="acronym">GID</SPAN
>
of the client user to determine access.</P
></LI
><li class="listitem"><p class="para">The packets transmitted by <span class="acronym">NFS</SPAN
>
were not encrypted, and were thus open to eavesdropping, alteration,
or forging on a network.</P
></LI
><li class="listitem"><p class="para"><span class="acronym">NFS</SPAN
> had no provisions for files
larger than 4GB. This was not a problem in 1985, but many <span class="acronym">UNIX</SPAN
>
users now have bigger disks and bigger files.</P
></LI
><li class="listitem"><p class="para"><span class="acronym">NFS</SPAN
> suffered serious performance
problems on high-speed networks because of the maximum 8K data-size
limitation on <span class="acronym">READ</SPAN
> and <span class="acronym">WRITE</SPAN
>
procedures, and because of the need to separately request the file
attributes on each file when a directory was read.</P
></LI
></UL
><p class="para"><span class="acronym">NFS</SPAN
> 3 is the first major revision to <span class="acronym">NFS</SPAN
>
since the protocol was commercially released. As such, <span class="acronym">NFS</SPAN
>
3 was designed to correct many of the problems that had been experienced
with <span class="acronym">NFS</SPAN
>. But <span class="acronym">NFS</SPAN
> 3 is not
a total rewrite. According to Pawlowski et al., there were three
guiding principles in designing <span class="acronym">NFS</SPAN
> 3:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Keep it simple.</P
></LI
><li class="listitem"><p class="para">Get it done in a year.</P
></LI
><li class="listitem"><p class="para">Avoid anything controversial.</P
></LI
></OL
><p class="para">Thus, while <span class="acronym">NFS</SPAN
> 3 allows for improved performance
and access to files larger than 4GB, it does not make any fundamental
changes to the overall <span class="acronym">NFS</SPAN
> architecture.</P
><p class="para">As a result of the design criteria, there are relatively few
changes between the <span class="acronym">NFS</SPAN
> 2 and 3 protocols:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">File-handle size has been increased
from a fixed-length 32-byte block of data to a variable-length array
with a maximum length of 64 bytes.</P
></LI
><li class="listitem"><p class="para">The maximum size of data that can be transferred
using <span class="acronym">READ</SPAN
> and <span class="acronym">WRITE</SPAN
> procedures
is now determined dynamically by the values returned by the <span class="acronym">FSINFO</SPAN
>
function. The maximum lengths for filenames and pathnames are now
similarly specified.</P
></LI
><li class="listitem"><p class="para">File lengths and offsets have been extended from
four bytes to eight bytes.[7]</P
><blockquote class="footnote"><p class="para">[7] Future versions of NFS&nbsp;- or
any other filesystem&nbsp;- will not likely need to use more than
eight bytes to represent the size of a file: eight bytes can represent
more than 1.7 x 1013MB of storage.</P
></BLOCKQUOTE
></LI
><li class="listitem"><p class="para"><span class="acronym">RPC</SPAN
> errors can now return data
(such as file attributes) in addition to return codes.</P
></LI
><li class="listitem"><p class="para">Additional file types are now supported for character-
and block-device files, sockets, and <span class="acronym">FIFOS</SPAN
>.</P
></LI
><li class="listitem"><p class="para">An <span class="acronym">ACCESS</SPAN
> procedure has been
added to allow an <span class="acronym">NFS</SPAN
> client to explicitly check
to see if a particular user can or cannot access a file.</P
></LI
></UL
><p class="para">Because <span class="acronym">RPC</SPAN
> allows a server to respond
to more than one version of a protocol at the same time, <span class="acronym">NFS</SPAN
>
3 servers will be able to support the <span class="acronym">NFS</SPAN
> 2 and
3 protocols simultaneously, so that they can serve older <span class="acronym">NFS</SPAN
>
2 clients while allowing easy upgradability to <span class="acronym">NFS</SPAN
>
3. Likewise, most <span class="acronym">NFS</SPAN
> 3 clients will continue
to support the <span class="acronym">NFS</SPAN
> 2 protocol as well, so that
they can speak with old servers and new ones.</P
><p class="para">This need for backward compatibility effectively prevented
the <span class="acronym">NFS</SPAN
> 3 designers from adding new security
features to the protocols. If <span class="acronym">NFS</SPAN
> 3 had more
security features, an attacker could avoid them by resorting to
<span class="acronym">NFS</SPAN
> 2. On the other hand, by changing a site
from unsecure <span class="acronym">RPC</SPAN
> to secure <span class="acronym">RPC</SPAN
>,
a site can achieve secure <span class="acronym">NFS</SPAN
> for all of its
<span class="acronym">NFS</SPAN
> clients and servers, whether they are running
<span class="acronym">NFS</SPAN
> 2 or <span class="acronym">NFS</SPAN
> 3.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> If and when your system supports <span class="acronym">NFS</SPAN
>
over <span class="acronym">TCP</SPAN
> links, you should configure it to use
<span class="acronym">TCP</SPAN
> and not <span class="acronym">UDP</SPAN
> unless there
are significant performance reasons for not doing so. <span class="acronym">TCP</SPAN
>-based
service is more immune to denial of service problems, spoofed requests,
and several other potential problems inherent in the current use
of <span class="acronym">UDP</SPAN
> packets.</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch19_07.htm#PUIS-CHP-19-SECT-7.1" title="19.7 Other Network Authentication Systems"><img src="../gifs/txtpreva.gif" alt="Previous: 19.7 Other Network Authentication Systems" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Practical UNIX &amp; Internet Security"><img src="../gifs/txthome.gif" alt="Practical UNIX &amp; Internet Security" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch20_02.htm#PUIS-CHP-20-SECT-2.1.1" title="20.2 Server-Side NFS Security"><img src="../gifs/txtnexta.gif" alt="Next: 20.2 Server-Side NFS Security" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">19.7 Other Network Authentication Systems</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">20.2 Server-Side NFS Security</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
