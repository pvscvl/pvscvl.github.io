<html><head>
<title>[Chapter 25] 25.2 Overload Attacks</TITLE>
<meta name="DC.title" content="Practical UNIX &amp; Internet Security"><meta name="DC.creator" content="Simson Garfinkel &amp; Gene Spafford"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T00:19:34Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-148-8" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch25_01.htm" title="25. Denial of Service Attacks and Solutions"><link rel="prev" href="ch25_01.htm" title="25.1 Destructive Attacks"><link rel="next" href="ch25_03.htm#PUIS-CHP-25-SECT-3.3" title="25.3 Network Denial of Service Attacks"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Practical UNIX &amp; Internet Security" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Practical UNIX &amp; Internet Security"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch25_01.htm" title="25.1 Destructive Attacks"><img src="../gifs/txtpreva.gif" alt="Previous: 25.1 Destructive Attacks" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 25<br>Denial of Service Attacks and Solutions</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch25_03.htm#PUIS-CHP-25-SECT-3.3" title="25.3 Network Denial of Service Attacks"><img src="../gifs/txtnexta.gif" alt="Next: 25.3 Network Denial of Service Attacks" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PUIS-CHP-25-SECT-2">25.2 Overload Attacks</A
></H2
><p class="para"><a class="indexterm" name="AUTOID-34238"></A
><a class="indexterm" name="AUTOID-34240"></A
>In an overload attack, a shared
resource or service is overloaded with requests to such a point
that it's unable to satisfy requests from other users.
For example, if one user spawns enough processes, other users won't
be able to run processes of their own. If one user fills up the
disks, other users won't be able to create new files. You
can partially protect against overload attacks by partitioning your
computer's resources, and limiting each user to one partition.
Alternatively, you can establish quotas to limit each user. Finally,
you can set up systems for automatically detecting overloads and
restarting your computer.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-25-SECT-2.1">25.2.1 Process-Overload Problems</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-34247"></A
><a class="indexterm" name="AUTOID-34250"></A
>One
of the simplest denial of service attacks is a process attack. In
a process attack, one user makes a computer unusable for others
who happen to be using the computer at the same time. Process attacks
are generally of concern only with shared computers: the fact that
a user incapacitates his or her own workstation is of no interest
if nobody else is using the machine.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.1.1">25.2.1.1 Too many processes</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-34256"></A
>The following program will
paralyze or crash many older versions of <span class="acronym">UNIX</SPAN
>:</P
><blockquote class="screen"><pre class="screen">main() 
{ 		
while (1) 			
fork(); 	
}</PRE
></BLOCKQUOTE
><p class="para">When this program is run, the process executes the <kbd class="command">fork()</KBD
>
instruction, creating a second process identical to the first. Both
processes then execute the <kbd class="command">fork()</KBD
>
instruction, creating four processes. The growth continues until
the system can no longer support any new processes. This is a total
attack, because all of the child processes are waiting for new processes
to be established. Even if you were somehow able to kill one process,
another would come along to take its place.</P
><p class="para">This attack will not disable most current versions of <span class="acronym">UNIX</SPAN
>,
because of limits on the number of processes that can be run under
any <span class="acronym">UID</SPAN
> (except for <i class="filename">root</I
>). This limit, called
<span class="acronym">MAXUPROC</SPAN
>, is usually configured into the kernel
when the system is built. Some <span class="acronym">UNIX</SPAN
> systems allow
this value to be set at boot time; for instance, <a class="indexterm" name="AUTOID-34269"></A
>
Solaris allows you to put the following in your
<i class="filename">/etc/system</I
> file:</P
><blockquote class="screen"><pre class="screen">set maxuproc=100</PRE
></BLOCKQUOTE
><p class="para">A user employing this attack will use up his quota of processes,
but no more. As superuser, you will then be able to use the <a class="indexterm" name="AUTOID-34275"></A
><a class="indexterm" name="AUTOID-34278"></A
>
<kbd class="command">ps</KBD
>
command to determine the process numbers of the offending processes
and use the <kbd class="command">kill</KBD
> command to kill them. You cannot kill the processes
one by one, because the remaining processes will simply create more.
A better approach is to use the <kbd class="command">kill</KBD
> command to first stop each
process, then kill them all at once:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">kill -STOP 1009 1110 1921 </B
>
# <b class="emphasis.bold">kill -STOP 3219 3220 </B
>
<b class="emphasis.bold">. 
. 
. </B
>
# <b class="emphasis.bold">kill -KILL 1009 1110 1921 3219 3220... </B
></PRE
></BLOCKQUOTE
><p class="para">Because the stopped processes still come out of the user's
<span class="acronym">NPROC</SPAN
><a class="indexterm" name="AUTOID-34291"></A
>
quota,
the forking program will be able to spawn no more. You can then
deal with the author.</P
><p class="para">Alternatively, you can kill all the processes in a process
group at the same time; in many cases of a user spawning too many
processes, the processes will all be in the same process group.
To discover the process group, run the <kbd class="command">ps</KBD
> command with the <kbd class="command">-j</KBD
>
option. Identify the process group, and then kill all processes
with one fell swoop:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">kill -9 -1009</B
></PRE
></BLOCKQUOTE
><p class="para">Note that many older, AT&amp;T-derived systems do not
support either process groups or the enhanced version of the <i class="filename">kill</I
> command, but it is present in <span class="acronym">SVR4</SPAN
>.
This enhanced version of<i class="filename"> kill </I
>interprets the
second argument as indicating a process group if it is preceded
by a &quot;-&quot;, and the absolute value of the
argument is used as the process group; the indicated signal is sent
to every process in the group.</P
><p class="para">Under modern versions of <span class="acronym">UNIX</SPAN
>, the <i class="filename">root</I
>
user can still halt the system with a process attack because there
is no limit to the number of processes that the superuser can spawn.
However, the superuser can also shut down the machine or perform
almost any other act, so this is not a major concern&nbsp;- <em class="emphasis">except</EM
>
when <i class="filename">root</I
> is running a program that is buggy (or booby-trapped).
In these cases, it's possible to encounter a situation
in which the machine is overwhelmed to the point where no one else
can get a free process even to do a login.</P
><p class="para">There is also a possibility that your system may reach the
total number of allowable processes because so many users are logged
on, even though none of them has reached her individual limit.</P
><p class="para">One other possibility is that your system has been configured
incorrectly. Your per-user process limit may be equal to or greater
than the limit for all processes on the system. In this case, a
single user can swamp the machine.</P
><p class="para">If you are ever presented with an error message from the shell
that says &quot;No more processes,&quot; then either you've
created too many child processes or there are simply too many processes
running on the system; the system won't allow you to create
any more processes.</P
><p class="para">For example:</P
><blockquote class="screen"><pre class="screen">% <b class="emphasis.bold">ps -efj </B
>
No more processes %</PRE
></BLOCKQUOTE
><p class="para">If you run out of processes, wait a moment and try again.
The situation may have been temporary. If the process problem does
not correct itself, you have an interesting situation on your hands.</P
><p class="para">Having too many processes that are running can be very difficult
to correct without rebooting the computer; there are two reasons
why:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">You cannot run the <kbd class="command">ps</KBD
> command to determine
the process numbers of the processes to kill.</P
></LI
><li class="listitem"><p class="para">If you are not currently the superuser, you cannot
use the <kbd class="command">su</KBD
> or <i class="filename">login </I
>command, because both of
these functions require the creation of a new process.</P
></LI
></UL
><p class="para"><a class="indexterm" name="AUTOID-34324"></A
>One way around the
second problem is to use the shell's <kbd class="command">exec</KBD
>[1] built-in command
to run the <kbd class="command">su</KBD
> command without creating a new process:</P
><blockquote class="footnote"><p class="para">[1] The
shell's <em class="emphasis">exec</EM
> function causes a program
to be run (with the <kbd class="command">exec()</KBD
> system call) without a <kbd class="command">fork()</KBD
> system
call being executed first; the user-visible result is that the shell
runs the program and then exits.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">% exec /bin/su 
password: <i class="systemitem.password">foobar</I
>
#</PRE
></BLOCKQUOTE
><p class="para">Be careful, however, that you do not mistype your password
or <kbd class="command">exec</KBD
> the <kbd class="command">ps</KBD
> program: the program will execute, but you will then
be automatically logged out of your computer!</P
><p class="para">If you have a problem with too many processes saturating the
system, you may be forced to reboot the system. The simplest way
might seem to be to power-cycle the machine. However, this may damage
blocks on disk, because it will probably not flush active buffers
to disk &nbsp;-  few systems are designed to undergo an orderly
shutdown when powered off suddenly. It's better to use
the <kbd class="command">kill</KBD
> command to kill the errant processes or to bring the system
to single-user mode. (See <a class="xref" href="appc_01.htm" title="UNIX Processes">Appendix C, <cite class="appendix">UNIX Processes</CITE
></A
> for information about <kbd class="command">kill</KBD
>, <kbd class="command">ps</KBD
>, <span class="acronym">UNIX</SPAN
>
processes, and signals.)</P
><p class="para">On most modern versions of <span class="acronym">UNIX</SPAN
>, the superuser
can send a <span class="acronym">SIGTERM</SPAN
><a class="indexterm" name="AUTOID-34347"></A
>
signal to all processes except system processes and your own process
by typing:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">kill -TERM -1</B
> 
#</PRE
></BLOCKQUOTE
><p class="para">If your <span class="acronym">UNIX</SPAN
> system does not have this
feature, you can execute the command:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">kill -TERM 1</B
>
#</PRE
></BLOCKQUOTE
><p class="para">to send a <span class="acronym">SIGTERM </SPAN
>to the <kbd class="command">init</KBD
> process.
<span class="acronym">UNIX</SPAN
> automatically kills all processes and goes
to single-user mode when <kbd class="command">init</KBD
> dies. You can then execute the <kbd class="command">sync</KBD
>
command from the console and reboot the operating system.</P
><p class="para">If you get the error &quot;No more processes&quot;
when you attempt to execute the <kbd class="command">kill</KBD
> command, exec a version of
the <kbd class="command">ksh</KBD
> or <kbd class="command">csh</KBD
>&nbsp;- they have the <kbd class="command">kill</KBD
> command built into them
and therefore don't need to spawn an extra process to run
the command.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.1.2">25.2.1.2 System overload attacks</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-34369"></A
><a class="indexterm" name="AUTOID-34372"></A
>Another common process-based denial
of service occurs when a user spawns many processes that consume
large amounts of <span class="acronym">CPU</SPAN
>. As most <span class="acronym">UNIX</SPAN
>
systems use a form of simple round-robin scheduling, these overloads
reduce the total amount of <span class="acronym">CPU</SPAN
> processing time
available for all other users. For example, someone who dispatches
ten <kbd class="command">find</KBD
> commands with <kbd class="command">grep</KBD
> components throughout your Usenet directories,
or spawns a dozen large <kbd class="command">troff</KBD
> jobs can slow the system to a crawl.[2]</P
><blockquote class="footnote"><p class="para">[2] We resist using the phrase commonly found on the net of &quot;bringing
the system to its knees.&quot; UNIX systems have many interesting
features, but knees are not among them. How the systems manage to
crawl, then, is left as an exercise to the reader.</P
></BLOCKQUOTE
><p class="para">The best way to deal with these problems is to educate your
users about how to share the system fairly. Encourage them to use
the <a class="indexterm" name="AUTOID-34385"></A
>
<kbd class="command">nice</KBD
> command to reduce the
priority of their background tasks, and to do them a few at a time.
They can also use the <kbd class="command">at</KBD
> or <i class="filename"><a class="indexterm" name="AUTOID-34390"></A
><a class="indexterm" name="AUTOID-34392"></A
>batch</I
> command to defer execution of
lengthy tasks to a time when the system is less crowded. You'll
need to be more forceful with users who intentionally or repeatedly
abuse the system.</P
><p class="para">If your system is exceptionally loaded, log in as <i class="filename">root</I
> and
set your own priority as high as you can right away with the <a class="indexterm" name="AUTOID-34396"></A
>
<kbd class="command">renice</KBD
> command, if it is available on your system:[3]</P
><blockquote class="footnote"><p class="para">[3] In this case, your login may require a lot of time; renice
is described in more detail in <a class="xref" href="appc_01.htm" title="UNIX Processes">Appendix C</A
>.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">renice -19 $$$</B
>
#</PRE
></BLOCKQUOTE
><p class="para">Then, use the <i class="filename">ps </I
>command to see what's
running, followed by the <kbd class="command">kill</KBD
> command to remove the processes monopolizing
the system, or the <kbd class="command">renice</KBD
> command to slow down these <a class="indexterm" name="AUTOID-34408"></A
><a class="indexterm" name="AUTOID-34411"></A
>
processes.
<a class="indexterm" name="AUTOID-34414"></A
><a class="indexterm" name="AUTOID-34417"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-25-SECT-2.2">25.2.2 Disk Attacks</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-34423"></A
><a class="indexterm" name="AUTOID-34425"></A
><a class="indexterm" name="AUTOID-34429"></A
>Another way of overwhelming a system is
to fill a disk partition. If one user fills up the disk, other users
won't be able to create files or do other useful work.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.2.1">25.2.2.1 Disk-full attacks</A
></H4
><p class="para">A disk can store only a certain amount of information. If
your disk is full, you must delete some information before more
can be stored.</P
><p class="para">Sometimes disks fill up suddenly when an application program
or a user erroneously creates too many files (or a few files that
are too large). Other times, disks fill up because many users are
slowly increasing their disk usage.</P
><p class="para">The <a class="indexterm" name="AUTOID-34436"></A
>
<kbd class="command">du</KBD
> command lets you find
the directories on your system that contain the most data. <kbd class="command">du</KBD
> searches
recursively through a tree of directories and lists how many blocks
are used by each one. For example, to check the entire <i class="filename">/usr</I
>
partition, you could type:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">du /usr </B
>
29		/usr/dict/papers 
3875		/usr/dict 
8		/usr/pub 
4032		/usr ... 
#</PRE
></BLOCKQUOTE
><p class="para">By finding the larger directories, you can decide where to
focus your cleanup efforts.</P
><p class="para">You can also search for and list only the names of the larger
files by using the <kbd class="command">find</KBD
> command. You can also use the <a class="indexterm" name="AUTOID-34446"></A
><a class="indexterm" name="AUTOID-34449"></A
><a class="indexterm" name="AUTOID-34452"></A
>
<kbd class="command">find</KBD
> command with the <kbd class="command">-size</KBD
> option
to list only the files larger than a certain size. Additionally,
you can use the options called <kbd class="command">-xdev</KBD
> or <kbd class="command">-local</KBD
> to avoid searching
<span class="acronym">NFS</SPAN
>-mounted directories (although you will want
to run find on each <span class="acronym">NFS</SPAN
> server.) This method
is about as fast as doing a <kbd class="command">du</KBD
> and can be even more useful when
trying to find a few large files that are taking up space. For example:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">find /usr -size +1000 -exec ls -l {} \;</B
>
-rw-r--r-- 1 root 1819832 Jan  9 10:45 /usr/lib/libtext.a
-rw-r--r-- 1 root 2486813 Aug 10  1985 /usr/dict/web2
-rw-r--r-- 1 root 1012730 Aug 10  1985 /usr/dict/web2a
-rwxr-xr-x 1 root  589824 Oct 22 21:27 /usr/bin/emacs
-rw-r--r-- 1 root 7323231 Oct 31  1990 /usr/tex/TeXdist.tar.Z
-rw-rw-rw- 1 root  772092 Mar 10 22:12 /var/spool/mqueue/syslog
-rw-r--r-- 1 uucp 1084519 Mar 10 22:12 /var/spool/uucp/LOGFILE
-r--r--r-- 1 root  703420 Nov 21 15:49 /usr/tftpboot/mach
... 
#</PRE
></BLOCKQUOTE
><p class="para">In this example, the file <i class="filename">/usr/tex/TeXdist.tar.Z</I
>
is probably a candidate for deletion&nbsp;- especially if you
have already unpacked the TeX distribution. The files <i class="filename">/var/spool/mqueue/syslog</I
>
and <i class="filename">/var/spool/uucp/LOGFILE</I
>
are also good candidates to delete, after saving them to tape or
another disk.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.2.2">25.2.2.2 quot command</A
></H4
><p class="para">The <a class="indexterm" name="AUTOID-34471"></A
><a class="indexterm" name="AUTOID-34473"></A
><a class="indexterm" name="AUTOID-34476"></A
>
<kbd class="command">quot</KBD
> command lets
you summarize filesystem usage by user; this program is available
on some System V and on most Berkeley-derived systems. With the
<i class="filename">-f </I
>option, <kbd class="command">quot</KBD
> prints the number of files
and the number of blocks used by each user:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">quot -f /dev/sd0a</B
>
/dev/sd0a (/):
53698  4434 root
 4487   294 bin
  681   155 hilda
  319   121 daemon
  123    25 uucp
   24     1 audit
   16     1 mailcmd
   16     1 news
    6     7 operator
#</PRE
></BLOCKQUOTE
><p class="para">You do not need to have disk quotas enabled to run the <kbd class="command">quot</KBD
>
<kbd class="command">-f</KBD
> command.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> The <i class="filename">quot -f</I
> command may lock the device while it is
running. All other programs that need to access the device will
be blocked until the <i class="filename">quot -f</I
> command completes.</P
></BLOCKQUOTE
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.2.3">25.2.2.3 Inode problems</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-34494"></A
><a class="indexterm" name="AUTOID-34497"></A
>The
<span class="acronym">UNIX</SPAN
> filesystem uses inodes to store information
about files. One way to make the disk unusable is to consume all
of the free inodes on a disk, so no new files can be created. A
person might inadvertently do this by creating thousands of empty
files. This can be a perplexing problem to diagnose if you're
not aware of the potential because the <kbd class="command">df</KBD
> command
might show lots of available space, but attempts to create a file
will result in a &quot;no space&quot; error. In general,
each new file, directory, pipe, <span class="acronym">FIFO</SPAN
>, or socket
requires an inode on disk to describe it. If the supply of available
inodes is exhausted, the system can't allocate a new file
even if disk space is available.</P
><p class="para">You can tell how many inodes are free on a disk by issuing
the <a class="indexterm" name="AUTOID-34504"></A
>
<kbd class="command">df</KBD
> command with the <i class="filename">-i</I
>
option:</P
><blockquote class="screen"><pre class="screen">% <b class="emphasis.bold">df -o i /usr</B
>           <em class="emphasis">&gt;may be <i class="filename">df -i</I
> on some systems</EM
>
Filesystem             iused   ifree  %iused  Mounted on
/dev/dsk/c0t3d0s5      20100   89404    18%   /usr
%</PRE
></BLOCKQUOTE
><p class="para">The output shows that this disk has lots of inodes available
for new files.</P
><p class="para">The number of inodes in a filesystem is usually fixed at the
time you initially format the disk for use. The default created
for the partition is usually appropriate for normal use, but you
can override it to provide more or fewer inodes, as you wish. You
may wish to increase this number for partitions in which you have
many small files&nbsp;- for example, a partition to hold Usenet
files (e.g., <i class="filename">/var/spool/news</I
>). If you run out
of inodes on a filesystem, about the only recourse is to save the
disk to tape, reformat with more inodes, and then restore the contents.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.2.4">25.2.2.4 Using partitions to protect your users</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-34518"></A
>You can protect your system
from disk attacks by dividing your hard disk into several smaller
partitions. Place different users' home directories on
different partitions. In this manner, if one user fills up one partition,
users on other partitions won't be affected. (Drawbacks
of this approach include needing to move directories to different
partitions if they require more space, and an inability to hard-link
files between some user directories.)</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.2.5">25.2.2.5 Using quotas</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-34523"></A
><a class="indexterm" name="AUTOID-34525"></A
><a class="indexterm" name="AUTOID-34528"></A
>A
more effective way to protect your system from disk attacks is to
use the quota system that is available on most modern versions of
<span class="acronym">UNIX</SPAN
>. (Quotas are usually available as a build-time
or run-time option on <span class="acronym">POSIX</SPAN
> systems.)</P
><p class="para">With disk quotas, each user can be assigned a limit for how
many inodes and how many disk blocks that user can use. There are
two basic kinds of quotas:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-34536"></A
><a class="indexterm" name="AUTOID-34539"></A
><i class="firstterm">Hard quotas</I
> are absolute limits on how many
inodes and how much space the user may consume.</P
></LI
><li class="listitem"><p class="para"><i class="firstterm">Soft quotas</I
> are advisory. Users are allowed to exceed
soft quotas for a grace period of several days. During this time,
the user is issued a warning whenever he or she logs into the system.
After the final day, the user is not allowed to create any more
files (or use any more space) without first reducing current usage.</P
></LI
></UL
><p class="para">A few systems also support a <i class="firstterm"><a class="indexterm" name="AUTOID-34547"></A
>group quota</I
>, which allows you to set a limit on
the total space used by a whole group of users. This can result
in cases where one user can deny another the ability to store a
file if they are in the same group, so it is an option you may not
wish to use.</P
><p class="para">To enable quotas on your system, you first need to create
the quota summary file. This is usually named <i class="filename">quotas</I
>,
and is located in the top-level directory of the disk. Thus, to
set quotas on the <i class="filename">/home</I
> partition, you would
issue the following commands:[4]</P
><blockquote class="footnote"><p class="para">[4] If your system supports
group quotas, the file will be named something else, such as <i class="filename">quotas.user</I
>
or <i class="filename">quotas.group.</I
></P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">cp /dev/null /home/quotas</B
>
# <b class="emphasis.bold">chmod 600 /home/quotas</B
>
# <b class="emphasis.bold">chown root /home/quotas</B
></PRE
></BLOCKQUOTE
><p class="para">You also need to mark the partition as having quotas enabled.
You do this by changing the filesystem file in your <i class="filename">/etc</I
>
directory: depending on the system, this may be <i class="filename">/etc/fstab,</I
>
<i class="filename">/etc/vfstab, /etc/checklist,</I
>
or <i class="filename">/etc/filesystems</I
>. If the option field is currently
<kbd class="command">rw</KBD
> you will change it to <kbd class="command">rq</KBD
>; otherwise, you probably add the options
parameter.[5] Then,
you need to build the options tables on every disk. This process
is done with the <a class="indexterm" name="AUTOID-34569"></A
>
<kbd class="command">quotacheck</KBD
>
<kbd class="command">-a</KBD
> command. (If your version of <i class="filename">quotacheck</I
>
takes the <kbd class="command">-p</KBD
> option, you may wish to use it to make the checks faster.)
Note that if there are any active users on the system, this check
may result in improper values. Thus, we advise that you reboot;
the quotacheck command should run as part of the standard boot sequence
and will check all the filesystems you enabled.</P
><blockquote class="footnote"><p class="para">[5] This is yet another example of how non-standard
UNIX has become, and why we have not given more examples of how
to set up each and every system for each option we have explained.
It is also a good illustration of why you should consult your vendor
documentation to see how to interpret our suggestions appropriately
for your release of the operating system.</P
></BLOCKQUOTE
><p class="para">Last of all, you can edit an individual user's quotas
with the <a class="indexterm" name="AUTOID-34576"></A
>
<kbd class="command">edquota</KBD
> command:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">edquota spaf</B
></PRE
></BLOCKQUOTE
><p class="para">If you want to &quot;clone&quot; the same set of quotas
to multiple users and your version of the command supports the -p
option, you may do so by using one user's quotas as a &quot;prototype&quot;:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">edquota -p spaf simsong beth kathy</B
></PRE
></BLOCKQUOTE
><p class="para">You and your users can view quotas with the quota command;
see your documentation for particular details.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.2.6">25.2.2.6 Reserved space</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-34588"></A
><a class="indexterm" name="AUTOID-34591"></A
>Versions
of <span class="acronym">UNIX</SPAN
> that use a filesystem derived from the
<a class="indexterm" name="AUTOID-34594"></A
><a class="indexterm" name="AUTOID-34596"></A
><a class="indexterm" name="AUTOID-34598"></A
><a class="indexterm" name="AUTOID-34601"></A
><a class="indexterm" name="AUTOID-34605"></A
>
<span class="acronym">BSD</SPAN
> Fast Filesystem (<span class="acronym">FFS</SPAN
>)
have an additional protection against filling up the disk: the filesystem
reserves approximately 10% of the disk and makes it unusable
by regular users. The reason for reserving this space is performance:
the <span class="acronym">BSD</SPAN
> Fast Filesystem does not perform as well
if less than 10% of the disk is free. However, this restriction
also prevents ordinary users from overwhelming the disk. The restriction
does not apply to processes running with superuser privileges.</P
><p class="para">This &quot;minfree&quot; value (10%) can
be set to other values when the partition is created. It can also
be changed afterwards using the <a class="indexterm" name="AUTOID-34612"></A
>
<kbd class="command">tunefs</KBD
>
command, but setting it to less than 10% is probably not
a good idea.</P
><p class="para">The <a class="indexterm" name="AUTOID-34616"></A
><a class="indexterm" name="AUTOID-34619"></A
>
Linux ext2 filesystem also allows
you to reserve space on your filesystem. The amount of space that
is reserved, 10% by default, can be changed with the <i class="filename">tune2fs</I
>
command.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.2.7">25.2.2.7 Hidden space</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-34625"></A
><a class="indexterm" name="AUTOID-34628"></A
><a class="indexterm" name="AUTOID-34631"></A
><a class="indexterm" name="AUTOID-34634"></A
><a class="indexterm" name="AUTOID-34637"></A
>Open files that
are unlinked continue to take up space until they are closed. The
space that these files take up will not appear with the du or find
commands, because they are not in the directory tree; however, they
will nevertheless take up space, because they are in the filesystem.</P
><p class="para">For example:</P
><blockquote class="screen"><pre class="screen">main()
{
		int ifd;
		char buf[8192];
		ifd = open(&quot;./attack&quot;, O_WRITE|O_CREAT, 0777);
		unlink(&quot;./attack&quot;);
		while (1)
			write (ifd, buf, sizeof(buf));
}</PRE
></BLOCKQUOTE
><p class="para">Files created in this way can't be found with the
<kbd class="command">ls</KBD
> or <kbd class="command">du</KBD
> commands because the files have no directory entries.</P
><p class="para">To recover from this situation and reclaim the space, you
must kill the process that is holding the file open. You may have
to take the system into single-user mode and kill <em class="emphasis">all</EM
> processes if you cannot determine which process is to
blame. After you've done this, run the filesystem consistency
checker (e.g., fsck) to verify that the free list was not damaged
during the shutdown operation.</P
><p class="para">You can more easily identify the program at fault by downloading
a copy of the freeware <a class="indexterm" name="AUTOID-34647"></A
>
<kbd class="command">lsof</KBD
> program
from the net. This program will identify the processes that have
open files, and the file position of each open file.[6]
By identifying a process with an open file that has a huge current
offset, you can terminate that single process to regain the disk
space. After the process dies and the file is closed, all the storage
it occupied is reclaimed.</P
><blockquote class="footnote"><p class="para">[6] Actually,
you should consider getting a copy of <kbd class="command">lsof</KBD
> for other reasons, too.
It has an incredible number of other uses, such as determining which
processes have open network connections and which processes have
their current directories on a particular disk.</P
></BLOCKQUOTE
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-25-SECT-2.2.8">25.2.2.8 Tree-structure attacks</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-34656"></A
><a class="indexterm" name="AUTOID-34658"></A
><a class="indexterm" name="AUTOID-34661"></A
><a class="indexterm" name="AUTOID-34664"></A
><a class="indexterm" name="AUTOID-34667"></A
><a class="indexterm" name="AUTOID-34669"></A
>It is also
possible to attack a system by building a tree structure that is
made too deep to be deleted with the <a class="indexterm" name="AUTOID-34672"></A
><a class="indexterm" name="AUTOID-34675"></A
><a class="indexterm" name="AUTOID-34677"></A
>
<kbd class="command">rm</KBD
> command.
Such an attack could be caused by something like the following shell
file:</P
><blockquote class="screen"><pre class="screen">$!/bin/ksh 
$ 
$ 
Don't try this at home!
while mkdir anotherdir
do
		cd ./anotherdir
		cp /bin/cc fillitup
done</PRE
></BLOCKQUOTE
><p class="para">On some systems, <kbd class="command">rm -r</KBD
> cannot delete this tree structure
because the directory tree overflows either the buffer limits used
inside the <kbd class="command">rm</KBD
> program to represent filenames or the number of open
directories allowed at one time.</P
><p class="para">You can almost always delete a very deep set of directories
by manually using the <a class="indexterm" name="AUTOID-34686"></A
>
<kbd class="command">chdir</KBD
>
command from the shell and going to the bottom of the tree, then
deleting the files and directories one at a time. This process can
be very tedious. Unfortunately, some <span class="acronym">UNIX</SPAN
> systems
do not let you <kbd class="command">chdir</KBD
> to a directory described by a path that contains
more than a certain number of characters.</P
><p class="para">Another approach is to use a script similar to the one in
Example 25-1:</P
><div class="example"><h4 class="example"><a class="title" name="AUTOID-34692">Example 25.1: Removing Nested Directories</A
></H4
><blockquote class="screen"><pre class="screen">#!/bin/ksh 

if (( $# != 1 ))
then
    print -u2 &quot;usage: $0 &lt;dir&gt;&quot;
    exit 1
fi

typeset -i index=1 dindex=0
typeset t_prefix=&quot;unlikely_fname_prefix&quot; fname=$(basename $1)

cd $(dirname &quot;$1&quot;)         # go to the directory containing the problem

while (( dindex &lt; index ))
do
    for entry in $(ls -1a &quot;$fname&quot;)
    do
      [[ &quot;$entry&quot; == @(.|..) ]] &amp;&amp; continue
      if [[ -d &quot;$fname/$entry&quot; ]]
      then
          rmdir - &quot;$fname/$entry&quot; 2&gt;/dev/null &amp;&amp; continue
          mv &quot;$fname/$entry&quot; ./$t_prefix.$index
          let index+=1
      else
          rm -f - &quot;$fname/$entry&quot;
      fi
    done
    rmdir &quot;$fname&quot;
    let dindex+=1
    fname=&quot;$t_prefix.$dindex&quot;
done</PRE
></BLOCKQUOTE
></DIV
><p class="para">What this method does is delete the nested directories starting
at the top. It deletes any files at the top level, and moves any
nested directories up one level to a temporary name. It then deletes
the (now empty) top-level directory and begins anew with one of
the former descendent directories. This process is slow, but it
will work on almost any version of <span class="acronym">UNIX</SPAN
>.</P
><p class="para">The only other way to delete such a directory on one of these
systems is to remove the inode for the top-level directory manually,
and then use the <a class="indexterm" name="AUTOID-34698"></A
>
fsck command
to erase the remaining directories. To delete these kinds of troubling
directory structures this way, follow these steps:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Take the system to single-user mode.</P
></LI
><li class="listitem"><p class="para">Find the inode number of the <i class="filename">root</I
> of the offending
directory.</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">ls -i anotherdir </B
>
1491 anotherdir 
# </PRE
></BLOCKQUOTE
></LI
><li class="listitem"><p class="para">Use the <kbd class="command">df</KBD
> command to determine the device of the
offending directory:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">/usr/bin/df anotherdir </B
>
/g17            (/dev/dsk/c0t2d0s2 ):  377822 blocks   722559 files 
# </PRE
></BLOCKQUOTE
></LI
><li class="listitem"><p class="para">Clear the inode associated with that directory using
the <kbd class="command">clri</KBD
> program:[7]</P
><blockquote class="footnote"><p class="para">[7] The <kbd class="command">clri</KBD
> command can be found in
<i class="filename">/usr/sbin/clri</I
> on Solaris systems. If
you are using SunOS, use the unlink command instead.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">clri /dev/dsk/c0t2d0s2 1491 </B
>
#</PRE
></BLOCKQUOTE
><p class="para">(Remember to replace <i class="filename">/dev/dsk/c0t2d0s2</I
>
with the name of the actual device reported by the <kbd class="command">df</KBD
> command.)</P
></LI
><li class="listitem"><p class="para">Run your filesystem consistency checker (for example,
<kbd class="command">fsck</KBD
> <i class="filename">/dev/dsk/cot2dos2)</I
> until it reports
no errors. When the program tells you that there is an unconnected
directory with inode number 1491 and asks you if you want to reconnect
it, answer &quot;no.&quot; The <kbd class="command">fsck</KBD
> program will reclaim
all the disk blocks and inodes used by the directory tree.</P
></LI
></OL
><p class="para">If you are using the Linux ext2 filesystem, you can delete
an inode using the <a class="indexterm" name="AUTOID-34731"></A
>
debugfs
command. It is important that the filesystem be unmounted before
using the debugfs <a class="indexterm" name="AUTOID-34733"></A
><a class="indexterm" name="AUTOID-34735"></A
><a class="indexterm" name="AUTOID-34738"></A
><a class="indexterm" name="AUTOID-34741"></A
><a class="indexterm" name="AUTOID-34744"></A
><a class="indexterm" name="AUTOID-34746"></A
>
command.<a class="indexterm" name="AUTOID-34749"></A
><a class="indexterm" name="AUTOID-34751"></A
><a class="indexterm" name="AUTOID-34755"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-25-SECT-2.3">25.2.3 Swap Space Problems</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-34760"></A
><a class="indexterm" name="AUTOID-34762"></A
>Most <span class="acronym">UNIX</SPAN
>
systems are configured with some disk space for holding process
memory images when they are paged or swapped out of main memory.[8] If your system
is not configured with enough swap space, then new processes, especially
large ones, will not be run because there is no swap space for them.
This failure often results in the error message &quot;No space&quot;
when you attempt to execute a command.</P
><blockquote class="footnote"><p class="para">[8] Swapping and paging are technically two different activities.
Older systems swapped entire process memory images out to secondary
storage; paging removes only portions of programs at a time. The
use of the word &quot;swap&quot; has become so commonplace
that most UNIX users use the word &quot;swap&quot; for both
swapping and paging, so we will too.</P
></BLOCKQUOTE
><p class="para">If you run out of swap space because processes have accidentally
filled up the available space, you can increase the space you've
allocated to backing store. On <span class="acronym">SVR4</SPAN
> or the SunOS
system, this increase is relatively simple to do, although you must
give up some of your user filesystem. First, find a partition with
some spare storage:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">/bin/df -ltk</B
>
Filesystem            kbytes      used   avail capacity  Mounted on
/dev/dsk/c0t3d0s0        95359     82089    8505     91%     /                  
/proc                      0         0       0      0%     /proc              
/dev/dsk/c0t1d0s2     963249    280376  634713    31%    /user2      
/dev/dsk/c0t2d0s0    1964982   1048379  720113    59%    /user3      
/dev/dsk/c0t2d0s6    1446222    162515 1139087    12%    /user4      
#</PRE
></BLOCKQUOTE
><p class="para">In this case, partition <i class="filename">/user4</I
> appears to have lots
of spare room. You can create an additional 50 Mb of swap space
on this partition with this command sequence on Solaris systems:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">mkfile 50m /user4/junkfile</B
>
# <b class="emphasis.bold">swap -a /user4/junkfile</B
></PRE
></BLOCKQUOTE
><p class="para">On SunOS systems, type:</P
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">mkfile 50m /user4/junkfile</B
>
# <b class="emphasis.bold">swapon /user4/junkfile</B
></PRE
></BLOCKQUOTE
><p class="para">You can add this to the <kbd class="command">vfstab</KBD
> if you want the swap space
to be available across reboots. Otherwise, remove the sequence as
a swap device (<kbd class="command">swap -d /user4/junkfile)</KBD
> and then
delete the file.</P
><p class="para">Correcting a shortage of swap space on systems that do not
support swapping to files (such as most older versions of <span class="acronym">UNIX</SPAN
>)
usually involves shutting down your computer and repartitioning
your hard disk.</P
><p class="para">If a malicious user has filled up your swap space, a short-term
approach is to identify the offending process or processes and kill
them. The ps command shows you the size of every executing process
and helps you determine the cause of the problem. The <kbd class="command">vmstat</KBD
> command,
if you have it, can also provide valuable process state information.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-25-SECT-2.4">25.2.4 /tmp Problems</A
></H3
><p class="para">Most <span class="acronym">UNIX</SPAN
> systems are configured so that
any user can create files of any size in the <i class="filename"><a class="indexterm" name="AUTOID-34793"></A
><a class="indexterm" name="AUTOID-34795"></A
><a class="indexterm" name="AUTOID-34798"></A
>/tmp</I
>
directory. Normally, there is no quota checking enabled in the <i class="filename">/tmp</I
>
directory. Consequently, a single user can fill up the partition
on which the <i class="filename">/tmp</I
> directory is mounted, so that it will
be impossible for other users (and possibly the superuser) to create
new files.</P
><p class="para">Unfortunately, many programs require the ability to store
files in the <i class="filename">/tmp</I
> directory to function properly.
For example, the <kbd class="command">vi</KBD
> and <kbd class="command">mail</KBD
> programs both store temporary files
in <i class="filename">/tmp</I
>. These programs will unexpectedly fail
if they cannot create their temporary files. Many locally written
system administration scripts rely on the ability to create files
in the <i class="filename">/tmp</I
> directory, and do not check to make sure that
sufficient space is available.</P
><p class="para">Problems with the <i class="filename">/tmp</I
> directory are almost always
accidental. A user will copy a number of large files there, and
then forget them. Perhaps many users will do this.</P
><p class="para">In the early days of <span class="acronym">UNIX</SPAN
>, filling up the
<i class="filename">/tmp</I
> directory was not a problem. The <i class="filename">/tmp</I
>
directory is automatically cleared when the system boots, and early
<span class="acronym">UNIX</SPAN
> computers crashed a lot. These days, <span class="acronym">UNIX</SPAN
>
systems stay up much longer, and the /tmp directory often
does not get cleaned out for days, weeks, or months.</P
><p class="para">There are a number of ways to minimize the danger of <i class="filename">/tmp</I
>
attacks:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Enable <a class="indexterm" name="AUTOID-34822"></A
>
quota checking on <i class="filename">/tmp</I
>, so that no
single user can fill it up. A good quota is to allow each user to
take up 40% of the space in <i class="filename">/tmp</I
>. Thus, filling
up <i class="filename">/tmp</I
> will, under the best circumstances, require collusion
between more than two users.</P
></LI
><li class="listitem"><p class="para">Have a process that monitors the <i class="filename">/tmp</I
> directory
on a regular basis and alerts the system administrator if it is
nearly filled.</P
></LI
></UL
><p class="para">As the superuser, you might also want to sweep through the
<i class="filename">/tmp</I
> directory on a periodic basis and delete
any files that are more than three or five days old:[9]</P
><blockquote class="footnote"><p class="para">[9] Beware
that this command may be vulnerable to the filename attacks described
in <a class="xref" href="ch11_01.htm" title="Protecting Against Programmed Threats">Chapter 11</A
>.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen"># <b class="emphasis.bold">find /tmp -mtime +5 -print | xargs rm -rf</B
></PRE
></BLOCKQUOTE
><p class="para">This line is a simple addition to your <a class="indexterm" name="AUTOID-34839"></A
><a class="indexterm" name="AUTOID-34842"></A
>
<kbd class="command">crontab</KBD
>
for nightly execution.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-25-SECT-2.5">25.2.5 Soft Process Limits: Preventing Accidental  Denial
of Service</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-34849"></A
><a class="indexterm" name="AUTOID-34852"></A
>Most modern versions of <span class="acronym">UNIX</SPAN
>
allow you to set limits on the maximum amount of memory or <span class="acronym">CPU</SPAN
>
time a process can consume, as well as the maximum file size it
can create. These limits are handy if you are developing a new program
and do not want to accidentally make the machine very slow or unusable
for other people with whom you're sharing.</P
><p class="para">The Korn shell <kbd class="command">ulimit</KBD
> and C shell <a class="indexterm" name="AUTOID-34860"></A
><a class="indexterm" name="AUTOID-34862"></A
>
<kbd class="command">limit</KBD
> commands display the current process limits:</P
><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">ulimit -Sa</B
>           -H for hard limits, -S for soft limits
time(seconds) 							unlimited
file(blocks) 						unlimited
data(kbytes) 						2097148 kbytes
stack(kbytes) 						8192 kbytes
coredump(blocks) 						unlimited
nofiles(descriptors) 	64
vmemory(kbytes) 						unlimited
$ </PRE
></BLOCKQUOTE
><p class="para">These limits have the following meanings:</P
><dl class="variablelist"><dt class="term"><i class="firstterm">time</I
></DT
><dd class="listitem"><p class="para">Maximum number of <span class="acronym">CPU</SPAN
> seconds
your process can consume.</P
></DD
><dt class="term"><i class="firstterm">file</I
></DT
><dd class="listitem"><p class="para">Maximum file size that your process can create,
reported in 512-byte blocks.</P
></DD
><dt class="term"><i class="firstterm">data</I
></DT
><dd class="listitem"><p class="para">Maximum amount of memory for data space that your
process can reference.</P
></DD
><dt class="term"><i class="firstterm">stack</I
></DT
><dd class="listitem"><p class="para">Maximum stack your process can consume.</P
></DD
><dt class="term"><i class="firstterm">coredump</I
></DT
><dd class="listitem"><p class="para">Maximum size of a core file that your process will
write; setting this value to 0 prevents you from writing core files.</P
></DD
><dt class="term"><i class="firstterm">nofiles</I
></DT
><dd class="listitem"><p class="para">Number of file descriptors (open files) that your
process can have.</P
></DD
><dt class="term"><i class="firstterm">vmemory</I
></DT
><dd class="listitem"><p class="para">Total amount of virtual memory your process can
consume.</P
></DD
></DL
><p class="para">You can also use the <kbd class="command">ulimit</KBD
> command to change a limit. For
example, to prevent any future process you create from writing a
data file longer than 5000 Kilobytes, execute the following command:</P
><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">ulimit -Sf 10000 </B
>
$ <b class="emphasis.bold">ulimit -Sa </B
>
time(seconds) 				unlimited
file(blocks) 			10000
data(kbytes) 			2097148 kbytes
stack(kbytes) 			8192 kbytes
coredump(blocks) 			unlimited
nofiles(descriptors) 	64
vmemory(kbytes) 			unlimited
$ </PRE
></BLOCKQUOTE
><p class="para">To reset the limit, execute this command:</P
><blockquote class="screen"><pre class="screen">$ <b class="emphasis.bold">ulimit -Sf unlimited</B
>
$ <b class="emphasis.bold">ulimit -Sa </B
>
ctime(seconds) 				unlimited
file(blocks) 			unlimited
data(kbytes) 			2097148 kbytes
stack(kbytes) 			8192 kbytes
coredump(blocks) 			unlimited
nofiles(descriptors) 	64
vmemory(kbytes) 			unlimited
$</PRE
></BLOCKQUOTE
><p class="para">Note that if you set the hard limit, you cannot increase it
again unless you are currently the superuser. This limit may be
handy to use in a system-wide profile to limit all your users.<a class="indexterm" name="AUTOID-34915"></A
><a class="indexterm" name="AUTOID-34917"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch25_01.htm" title="25.1 Destructive Attacks"><img src="../gifs/txtpreva.gif" alt="Previous: 25.1 Destructive Attacks" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Practical UNIX &amp; Internet Security"><img src="../gifs/txthome.gif" alt="Practical UNIX &amp; Internet Security" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch25_03.htm#PUIS-CHP-25-SECT-3.3" title="25.3 Network Denial of Service Attacks"><img src="../gifs/txtnexta.gif" alt="Next: 25.3 Network Denial of Service Attacks" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">25.1 Destructive Attacks</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">25.3 Network Denial of Service Attacks</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
