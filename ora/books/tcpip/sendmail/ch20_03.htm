<html><head>
<title>[Chapter 20] 20.3 Alphabetized V8.8 Subroutines</TITLE>
<meta name="DC.title" content="sendmail"><meta name="DC.creator" content="Bryan Costales &amp; Eric Allman"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-01-06T19:25:21Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-222-0" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch20_01.htm" title="20. The checkcompat() Cookbook"><link rel="prev" href="ch20_02.htm#SML2-CH-20-SECT-2-2" title="20.2 The Cookbook"><link rel="next" href="part03.htm" title="III. Administration"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="sendmail" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="sendmail"><area shape="RECT" coords="467,0,514,18" href="../search/ssrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch20_02.htm#SML2-CH-20-SECT-2-2" title="20.2 The Cookbook"><img src="../gifs/txtpreva.gif" alt="Previous: 20.2 The Cookbook" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 20<br>The checkcompat() Cookbook</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="PART" href="part03.htm" title="III. Administration"><img src="../gifs/txtnexta.gif" alt="Next: III. Administration" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="SML2-CH-20-SECT-3">20.3 Alphabetized V8.8 Subroutines</A
></H2
><p class="para"><a class="indexterm" name="SML2-CH-20-IX-CHECKCOMPAT-ROUTINE-SUBROUTINES-FOR"></A
>Many subroutines inside <em class="emphasis">sendmail</EM
> can be very useful in
writing your own <em class="emphasis">checkcompat</EM
>() routine. Always try to use
<em class="emphasis">sendmail</EM
>'s internal routines rather than redesigning your own.
Those supplied with <em class="emphasis">sendmail</EM
> have already been screened and tested by
a large body of skilled programmers.</P
><p class="para">In this section we list the ones that we consider most useful and describe
how best to use them (see
<a class="xref" href="#SML2-CH-20-TAB-2" title="Handy Subroutines for Use with checkcompat()">Table 20.3</A
>).</P
><table class="table"><caption class="table"><a class="title" name="SML2-CH-20-TAB-2">Table 20.3: Handy Subroutines for Use with checkcompat()</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1">Subroutine</TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1">Description</TH
></TR
></THEAD
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">addheader</TD
><td class="entry" rowspan="1" colspan="1"><a class="xref" href="#SML2-CH-20-SECT-3-1" title="">Section 20.3.1, addheader()</A
></TD
><td class="entry" rowspan="1" colspan="1">Add a new header to the list of headers</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">define</TD
><td class="entry" rowspan="1" colspan="1"><a class="xref" href="#SML2-CH-20-SECT-3-2" title="">Section 20.3.2, define()</A
></TD
><td class="entry" rowspan="1" colspan="1">Define a macro</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"></TD
><td class="entry" rowspan="1" colspan="1"><a class="xref" href="#SML2-CH-20-SECT-3-3" title="">Section 20.3.3</A
></TD
><td class="entry" rowspan="1" colspan="1">How to remove a header</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">hvalue</TD
><td class="entry" rowspan="1" colspan="1"><a class="xref" href="#SML2-CH-20-SECT-3-4" title="">Section 20.3.4, hvalue()</A
></TD
><td class="entry" rowspan="1" colspan="1">Look up a header's field by name</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">macid</TD
><td class="entry" rowspan="1" colspan="1"><a class="xref" href="#SML2-CH-20-SECT-3-5" title="">Section 20.3.5, macid()</A
></TD
><td class="entry" rowspan="1" colspan="1">Convert a text string macro name into an integer</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">macvalue</TD
><td class="entry" rowspan="1" colspan="1"><a class="xref" href="#SML2-CH-20-SECT-3-6" title="">Section 20.3.6, macvalue()</A
></TD
><td class="entry" rowspan="1" colspan="1">Fetch a macro's value</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">-&gt;map_lookup</TD
><td class="entry" rowspan="1" colspan="1"><a class="xref" href="#SML2-CH-20-SECT-3-7" title="">Section 20.3.7, -&gt;map-lookup()</A
></TD
><td class="entry" rowspan="1" colspan="1">Look up a key in an external database</TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1">wordinclass</TD
><td class="entry" rowspan="1" colspan="1"><a class="xref" href="#SML2-CH-20-SECT-3-8" title="">Section 20.3.8</A
></TD
><td class="entry" rowspan="1" colspan="1">Look up a word in a class</TD
></TR
></TBODY
></TABLE
><p class="para">Be aware that these subroutines are documented for V8.8 <em class="emphasis">sendmail</EM
>.
If you are using a different version of <em class="emphasis">sendmail</EM
>, you must familiarize
yourself with the source before attempting to use them.
Mismatched parameters can cause errors that are difficult to diagnose.</P
><div class="refentry"><div class="refnamediv"><h3 class="refname"><a class="refname" name="SML2-CH-20-SECT-3-1">20.3.1 addheader()</A
></H3
><p class="refpurpose">Add a new header to the list of headers</P
></DIV
><blockquote><div class="refsect1"><p class="para"><a class="indexterm" name="AUTOID-16730"></A
><a class="indexterm" name="AUTOID-16732"></A
><a class="indexterm" name="AUTOID-16735"></A
>The <em class="emphasis">addheader</EM
>() routine is used to add a new header to
the existing list of headers. Note that since it does not check for duplicates,
you should screen for the existence of a header before
adding it (unless it is okay for multiple headers to exist):</P
><p class="para"><blockquote class="screen"><pre class="screen">char value[MAXLINE];

(void)sprintf(value, &quot;Screened by checkcompat() for %s&quot;, q_user);
(void)addheader(<code class="userinput"><b>&quot;x-screened&quot;</B
></CODE
>, value, e-&gt;e_header);</PRE
></BLOCKQUOTE
></P
><p class="para">Memory for the name of the new header and its value are allocated
internally by <em class="emphasis">addheader</EM
>(), so automatic variables can
be safely passed. Note that the first argument to <em class="emphasis">addheader</EM
>() (line <em class="emphasis">4</EM
>)
is the name of the header.
If you accidentally include a colon in that argument,
the name will be stored with that colon included, and
later the header name will be incorrectly emitted with two colons.</P
><p class="para">Note that <em class="emphasis">addheader</EM
> does not check for the validity of its
arguments. If you pass it NULL or an illegal address, you
may cause <em class="emphasis">sendmail</EM
> to core-dump and fail. You are dealing
with <em class="emphasis">sendmail</EM
> internals here, so be very careful.</P
></DIV
></BLOCKQUOTE
></DIV
><div class="refentry"><div class="refnamediv"><h3 class="refname"><a class="refname" name="SML2-CH-20-SECT-3-2">20.3.2 define()</A
></H3
><p class="refpurpose">Define a macro</P
></DIV
><blockquote><div class="refsect1"><p class="para"><a class="indexterm" name="AUTOID-16758"></A
><a class="indexterm" name="AUTOID-16760"></A
><a class="indexterm" name="AUTOID-16763"></A
>Macros can be defined and redefined inside <em class="emphasis">checkcompat</EM
>()
using the <em class="emphasis">define</EM
>() routine. It is called like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">define( <code class="replaceable"><i>macid</I
></CODE
>, <code class="replaceable"><i>value</I
></CODE
>, <code class="replaceable"><i>envel</I
></CODE
>);</PRE
></BLOCKQUOTE
></P
><p class="para">Here, <code class="replaceable"><i>macid</I
></CODE
> is the literal character in the case
of a single-character macro name (such as <code class="literal">'A'</CODE
>) or the
identifying value for a multicharacter name (this latter
being derived from a call to <em class="emphasis">macid</EM
>().
The <code class="replaceable"><i>value</I
></CODE
> is the value to be assigned to the macro. (Note that if
the macro already has a value, that prior value is overwritten.)
The <code class="replaceable"><i>envel</I
></CODE
> is a pointer to the envelope (in the case
of <em class="emphasis">checkcompat</EM
>() it is <code class="literal">e</CODE
>).</P
><p class="para">To illustrate, consider the following code fragment that assigns
a new value to the macros <code class="literal">$A</CODE
> and <code class="literal">${foo}</CODE
>:</P
><p class="para"><blockquote class="screen"><pre class="screen">int mid;

/*
* A single-character name is given a value that is the address
* of a character constant.
*/
define( 'A', &quot;some text as a value&quot;, e);

/*
* A multi-character name is given a value that is in malloc()d
* memory space.
*/
mid = macid(<code class="userinput"><b>&quot;{foo}&quot;</B
></CODE
>, NULL);
define(mid, <code class="userinput"><b>newstr</B
></CODE
>(to-&gt;qpaddr), e);</PRE
></BLOCKQUOTE
></P
><p class="para">In both cases the <code class="replaceable"><i>value</I
></CODE
> stored is in permanent memory. You
must not pass a pointer to automatic or volatile memory, because
<em class="emphasis">define</EM
>() just stores the pointer, it does not copy the value.
[5]
In the second example (line <em class="emphasis">18</EM
>), memory is allocated for the string with
<em class="emphasis">newstr</EM
>(), another internal routine that allocates room
for the string and the string's terminating zero, copies the string
into that allocated space, and returns a pointer to the newly
allocated string. But be careful to keep track of what you are
doing. You can easily create a serious memory leak if you are
careless with <em class="emphasis">newstr</EM
>().</P
><blockquote class="footnote"><p class="para">[5] Technically, you should not use a string constant because
string constants are stored in read-only program space and
often may not be changed at runtime, for example, when a macro's value needs to
be later modified in place.</P
></BLOCKQUOTE
><p class="para">The first argument to <em class="emphasis">wordinclass</EM
>() (line <em class="emphasis">17</EM
>) is a string that contains
the macro's literal name without a <code class="literal">$</CODE
> prefix. For multicharacter
names, the enclosing curly braces are mandatory
(see <a class="xref" href="ch31_04.htm" title="Multicharacter Names">Section 31.4.2, "Multicharacter Names"</A
>).</P
><p class="para">See the <code class="literal">-d35</CODE
> debugging switch (<a class="xref" href="ch37_05.htm" title="">Section 37.5.120, -d35.9</A
>)
for a way to watch macros being defined and redefined. Also see
<em class="emphasis">munchstring</EM
>() in <em class="emphasis">readcf.c</EM
> if you need to parse a macro's
literal name from among other text.</P
></DIV
></BLOCKQUOTE
></DIV
><div class="refentry"><div class="refnamediv"><h3 class="refname"><a class="refname" name="SML2-CH-20-SECT-3-3">20.3.3 </A
></H3
><p class="refpurpose">How to remove a header</P
></DIV
><blockquote><div class="refsect1"><p class="para"><a class="indexterm" name="AUTOID-16814"></A
><a class="indexterm" name="AUTOID-16817"></A
><a class="indexterm" name="AUTOID-16819"></A
>The <em class="emphasis">sendmail</EM
> program's internal routines cannot be used to
remove a header from the linked list of headers,
but you can prevent
one from being emitted into the delivered message by massaging
its flags.</P
><p class="para">Consider the need to suppress custom <code class="literal">X-Accounting:</CODE
> headers:</P
><p class="para"><blockquote class="screen"><pre class="screen">HDR *h;

<code class="userinput"><b>for (h = e-&gt;e_header; h != NULL; h = h-&gt;h_link)</B
></CODE
>
{
<code class="userinput"><b>       if (strcasecmp(h-&gt;h_field, &quot;x-accounting&quot;) != 0)</B
></CODE
>
               continue;
<code class="userinput"><b>       clrbitmap(h-&gt;h_mflags);</B
></CODE
>
<code class="userinput"><b>       h-&gt;h_flags |= H_ACHECK;</B
></CODE
>
}</PRE
></BLOCKQUOTE
></P
><p class="para">Here, we have to manually scan the linked list of headers (line <em class="emphasis">3</EM
>).
When the one that is being sought is found
(note that the check is not case sensitive, line <em class="emphasis">5</EM
>)
we delete it. This is done
by first zeroing all the <code class="literal">?</CODE
><code class="replaceable"><i>flags</I
></CODE
><code class="literal">?</CODE
> for the
header (line <em class="emphasis">7</EM
>). Then we add the H_ACHECK
flag (line <em class="emphasis">8</EM
>) to ensure that the header will be skipped on delivery.
See <a class="xref" href="ch35_05.htm#SML2-CH-35-SECT-5-6" title="Replacing Headers with H_ACHECK">Section 35.5.16, "Replacing Headers with H_ACHECK"</A
> for a discussion of the effect of
the H_ACHECK flag.</P
></DIV
></BLOCKQUOTE
></DIV
><div class="refentry"><div class="refnamediv"><h3 class="refname"><a class="refname" name="SML2-CH-20-SECT-3-4">20.3.4 hvalue()</A
></H3
><p class="refpurpose">Look up a header's field by name</P
></DIV
><blockquote><div class="refsect1"><p class="para"><a class="indexterm" name="AUTOID-16847"></A
><a class="indexterm" name="AUTOID-16849"></A
>The <em class="emphasis">hvalue</EM
>() routine can be used to look up a header and
optionally change it, or insert it if it is missing. It is used
like this:</P
><p class="para"><blockquote class="screen"><pre class="screen">char *field;

<code class="userinput"><b>field = hvalue(&quot;message-id&quot;, e-&gt;e_header)</B
></CODE
>
if (field == NULL)
{
        /* No Message-ID: in the message, so insert one */
}</PRE
></BLOCKQUOTE
></P
><p class="para">&#13;Note that the first argument to <em class="emphasis">hvalue</EM
>() is the name of the
header being looked up (line <em class="emphasis">3</EM
>), without a trailing colon. If you accidentally
include the colon, the lookup will always fail.</P
><p class="para">The <em class="emphasis">hvalue</EM
>() routine returns a string that is the field
of the header that is looked up (see <a class="xref" href="ch35_03.htm#SML2-CH-35-SECT-3-2" title="Header Field Contents">Section 35.3, "Header Field Contents"</A
>).
If a particular header name can exist multiple times (such as
<code class="literal">Received:</CODE
>), <em class="emphasis">hvalue</EM
>() will return the first instance.
If you need to process all such headers, you will need to scan for them manually.</P
></DIV
></BLOCKQUOTE
></DIV
><div class="refentry"><div class="refnamediv"><h3 class="refname"><a class="refname" name="SML2-CH-20-SECT-3-5">20.3.5 macid()</A
></H3
><p class="refpurpose">Convert a text string macro name into an integer</P
>(int)</DIV
><blockquote><div class="refsect1"><p class="para"><a class="indexterm" name="AUTOID-16872"></A
><a class="indexterm" name="AUTOID-16874"></A
><a class="indexterm" name="AUTOID-16877"></A
><a class="indexterm" name="AUTOID-16880"></A
>Macros, class names, and rule-set names  can be single-character or
multicharacter in form. The <em class="emphasis">macid</EM
>() routine converts
a macro's name from a text string form (literal form) into
an integer. The resulting integer can later be used by
other routines such as <em class="emphasis">macvalue</EM
>()
and <em class="emphasis">wordinclass</EM
>().</P
><p class="para">To illustrate, consider the names <code class="literal">A</CODE
> and <code class="literal">{foo}</CODE
>:</P
><p class="para"><blockquote class="screen"><pre class="screen">int mid;

mid = macid(&quot;<code class="userinput"><b>A</B
></CODE
>&quot;, NULL);

mid = macid(&quot;<code class="userinput"><b>{foo}</B
></CODE
>&quot;, NULL);</PRE
></BLOCKQUOTE
></P
><p class="para">The first argument to <em class="emphasis">macid</EM
>() must be a string that contains the name to be
converted. For a single-character name (line <em class="emphasis">3</EM
>) the name
is converted to the character-constant value of the first letter
(<code class="literal">&quot;A&quot;</CODE
> becomes <code class="literal">'A'</CODE
>). For a multicharacter name
(line <em class="emphasis">5</EM
>) the name must be enclosed in curly braces. The name
is converted to a unique integer value that is either new or
one that was previously assigned by an earlier call to <em class="emphasis">macid</EM
>().</P
><p class="para">The second argument to <em class="emphasis">macid</EM
> is NULL in our examples
because the string in the first argument contained only a name.
When other text might appear in the string you may pass a nonnull
second argument:</P
><p class="para"><blockquote class="screen"><pre class="screen"><code class="userinput"><b>char *str = &quot;localhost is ${lhost}, so there.&quot;;</B
></CODE
>
char *cp, *ep;
int mid;

if ((cp = strchr(str, '$')) != NULL)
{
        mid = macid( cp+1, <code class="userinput"><b>&amp;ep</B
></CODE
> );
}</PRE
></BLOCKQUOTE
></P
><p class="para">The second argument (line <em class="emphasis">7</EM
>) is the address of a character pointer.
After the call to <em class="emphasis">macid</EM
>() that character pointer (<code class="literal">ep</CODE
>)
contains the address of the first character following the name&nbsp;- the
comma in <code class="literal">str</CODE
> (line <em class="emphasis">1</EM
>).</P
></DIV
></BLOCKQUOTE
></DIV
><div class="refentry"><div class="refnamediv"><h3 class="refname"><a class="refname" name="SML2-CH-20-SECT-3-6">20.3.6 macvalue()</A
></H3
><p class="refpurpose">Fetch a macro's value</P
></DIV
><blockquote><div class="refsect1"><p class="para"><a class="indexterm" name="AUTOID-16921"></A
><a class="indexterm" name="AUTOID-16923"></A
>The value stored in a macro can be fetched with the <em class="emphasis">macvalue</EM
>()
routine. For example,</P
><p class="para"><blockquote class="screen"><pre class="screen">char *val;
int mid;

val = macvalue( '<code class="userinput"><b>A</B
></CODE
>', e);

mid = macid( &quot;<code class="userinput"><b>{foo}</B
></CODE
>&quot;, NULL);
<code class="userinput"><b>val</B
></CODE
> = macvalue( <code class="userinput"><b>mid</B
></CODE
>, e);</PRE
></BLOCKQUOTE
></P
><p class="para">The first example (line <em class="emphasis">4</EM
>) shows <em class="emphasis">macvalue</EM
>() being used to fetch the
value stored in a single-character macro name (<code class="literal">A</CODE
>). The
second (line <em class="emphasis">6</EM
>) shows a technique that is useful for multicharacter names and
for times when you must process an arbitrary name in a string.
The <em class="emphasis">macid</EM
>() routine converts a macro's literal name into
an identifying integer. That integer is then looked up with
<em class="emphasis">macvalue</EM
>() to return its value (line <em class="emphasis">7</EM
>).</P
><p class="para">If the looked up macro is not defined, <em class="emphasis">macvalue</EM
>() returns
NULL.</P
></DIV
></BLOCKQUOTE
></DIV
><div class="refentry"><div class="refnamediv"><h3 class="refname"><a class="refname" name="SML2-CH-20-SECT-3-7">20.3.7 -&gt;map-lookup()</A
></H3
><p class="refpurpose">Look up a key in an external database</P
></DIV
><blockquote><div class="refsect1"><p class="para"><a class="indexterm" name="AUTOID-16951"></A
><a class="indexterm" name="AUTOID-16953"></A
><a class="indexterm" name="AUTOID-16956"></A
><a class="indexterm" name="AUTOID-16959"></A
>Arbitrary keys can be looked up in external databases by using the
routines that are indirectly set up when a database is declared.
For example, consider a <em class="emphasis">dbm</EM
> database that will store
login names as the keys and the words <code class="literal">ok</CODE
> or <code class="literal">drop</CODE
>
as the values. You would first create a source text file with
the <em class="emphasis">makemap</EM
> program (see <a class="xref" href="ch33_02.htm#SML2-CH-33-SECT-2-1-1" title="Create Files with makemap">Section 33.2</A
>). Next you
would declare that database in the configuration file:</P
><p class="para"><blockquote class="screen"><pre class="screen">Kbouncelist dbm -o /etc/bouncelist</PRE
></BLOCKQUOTE
></P
><p class="para"><a class="indexterm" name="AUTOID-16969"></A
>This <code class="literal">K</CODE
> configuration command (see <a class="xref" href="ch33_03.htm#SML2-CH-33-SECT-3-4-2" title="The K Configuration Command">Section 33.3</A
>)
gives the internal symbolic name <code class="literal">bouncelist</CODE
> to the database.</P
><p class="para">Values can now be looked up using the following code fragment:</P
><p class="para"><blockquote class="screen"><pre class="screen">STAB *map;
char *p;
int  r = 0;

map = stab(&quot;bouncelist&quot;, ST_MAP, ST_FIND);
if (map == (STAB *)NULL)
        return (EX_OK);
p = (*map-&gt;s_map.map_class<code class="userinput"><b>-&gt;map_lookup</B
></CODE
>)(&amp;map-&gt;s_map, to-&gt;q_ruser, NULL, &amp;r);
if (p == NULL)
        return (EX_OK);

if (strcasecmp(p, &quot;drop&quot;) == 0)
        /* drop the message on the floor */</PRE
></BLOCKQUOTE
></P
><p class="para">The lookup is performed by calling the addresses stored in
<code class="literal">map_lookup</CODE
> (line <em class="emphasis">8</EM
>). The second argument is the key that is being looked up
(here, we use <code class="literal">to-&gt;q_ruser</CODE
>, the login name of the recipient
as the key).</P
><p class="para">Errors are returned in <code class="literal">r</CODE
>. We ignore those errors here,
but you can use them if you wish. They correspond to
the error values listed in <em class="emphasis">&lt;sysexits.h&gt;</EM
>. But note that
not all lookups change <code class="literal">r</CODE
> (see <em class="emphasis">map.c</EM
> for
specific details).</P
></DIV
></BLOCKQUOTE
></DIV
><div class="refentry"><div class="refnamediv"><h3 class="refname"><a class="refname" name="SML2-CH-20-SECT-3-8">20.3.8 wordinclass()</A
></H3
><p class="refpurpose">Look up a word in a class</P
>(bool)</DIV
><blockquote><div class="refsect1"><p class="para"><a class="indexterm" name="AUTOID-16995"></A
><a class="indexterm" name="AUTOID-16997"></A
>The words that form a class (see <a class="xref" href="ch32_01.htm" title="The C Class Command">Section 32.1.1, "The C Class Command"</A
>) are stored as symbols
in the symbol table (see <a class="xref" href="ch32_02.htm#SML2-CH-32-SECT-2-1" title="Class Name Hashing Algorithm">Section 32.2.4, "Class Name Hashing Algorithm"</A
>). The check to see
whether a string of text was included in a given class is done with the
<em class="emphasis">wordinclass</EM
>() routine. Single-character class names and
multicharacter class names can be searched:</P
><p class="para"><blockquote class="screen"><pre class="screen">int mid;

if (wordinclass( &quot;localhost&quot;, <code class="userinput"><b>'w'</B
></CODE
>) == TRUE)
        /* yes, it was found */

mid = macid(&quot;{foo}&quot;, NULL);
if (wordinclass( &quot;localhost&quot;, <code class="userinput"><b>mid</B
></CODE
>) == FALSE)
        /* no, not found */</PRE
></BLOCKQUOTE
></P
><p class="para">The first argument to <em class="emphasis">macid</EM
> is a string that contains
the word being looked up. Care must be taken to ensure that
the first argument is a legal address and not NULL
because <em class="emphasis">wordinclass</EM
>() does not check.</P
><p class="para">The second argument is either an integer character-constant (such as
the <code class="literal">'w'</CODE
>, line <em class="emphasis">3</EM
>), or an integer identifier returned by <em class="emphasis">macid</EM
>()
(line <em class="emphasis">7</EM
>).<a class="indexterm" name="AUTOID-17015"></A
><a class="indexterm" name="AUTOID-17016"></A
></P
></DIV
></BLOCKQUOTE
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch20_02.htm#SML2-CH-20-SECT-2-2" title="20.2 The Cookbook"><img src="../gifs/txtpreva.gif" alt="Previous: 20.2 The Cookbook" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="sendmail"><img src="../gifs/txthome.gif" alt="sendmail" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="PART" href="part03.htm" title="III. Administration"><img src="../gifs/txtnexta.gif" alt="Next: III. Administration" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">20.2 The Cookbook</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">III. Administration</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="../puis/index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
