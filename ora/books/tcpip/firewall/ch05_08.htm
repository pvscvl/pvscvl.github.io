<html><head>
<title>[Chapter 5] 5.8 Building a Bastion Host</TITLE>
<meta name="DC.title" content="Building Internet Firewalls"><meta name="DC.creator" content="D. Brent Chapman &amp; Elizabeth D. Zwicky"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T00:14:32Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-124-0" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch05_01.htm" title="5. Bastion Hosts"><link rel="prev" href="ch05_07.htm" title="5.7 Don't Allow User Accounts on the Bastion Host"><link rel="next" href="ch05_09.htm" title="5.9 Operating the Bastion Host "></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Building Internet Firewalls" usemap="#srchmap" border="0"></H1
><map name="srchmindex.htmlap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Building Internet Firewalls"><area shape="RECT" coords="467,0,514,18" href="../search/fsrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_07.htm" title="5.7 Don't Allow User Accounts on the Bastion Host"><img src="../gifs/txtpreva.gif" alt="Previous: 5.7 Don't Allow User Accounts on the Bastion Host" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 5<br>Bastion Hosts</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch05_09.htm" title="5.9 Operating the Bastion Host "><img src="../gifs/txtnexta.gif" alt="Next: 5.9 Operating the Bastion Host " border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="AUTOID-2865">5.8 Building a Bastion Host</A
></H2
><p class="para"><a class="indexterm" name="AUTOID-2868"></A
><a class="indexterm" name="AUTOID-2870"></A
>Now that you've figured out what you want your bastion host to do,
you need to actually build the bastion host. In order to do that,
follow these steps:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Secure the machine.</P
></LI
><li class="listitem"><p class="para">Disable all nonrequired services.</P
></LI
><li class="listitem"><p class="para">Install or modify the services you want to provide.</P
></LI
><li class="listitem"><p class="para">Reconfigure the machine from a configuration suitable for development
into its final running state.</P
></LI
><li class="listitem"><p class="para">Run a security audit to establish a baseline.</P
></LI
><li class="listitem"><p class="para">Connect the machine to the network it will be used on.</P
></LI
></OL
><p class="para"><a class="indexterm" name="AUTOID-2887"></A
><a class="indexterm" name="AUTOID-2890"></A
><a class="indexterm" name="AUTOID-2893"></A
>You should be very careful to make sure the machine is not accessible
from the Internet until the last step. If your site isn't yet connected
to the Internet, you can simply avoid turning on the Internet connection
until the bastion host is fully configured. If you are adding a firewall
to a site that's already connected to the Internet, you need to
configure the bastion host as a standalone machine, unconnected to your
network. </P
><p class="para">If the bastion host is vulnerable to the Internet while it is being
built, it may become an attack mechanism instead of a defense
mechanism. An intruder who gets in before you've run the baseline audit
will be difficult to detect and will be well-positioned to read all of
your traffic to and from the Internet. Cases have been reported where
machines have been broken into within minutes of
first being connected to the Internet; while rare, it can happen.</P
><p class="para">The following sections describe each of the main steps involved in
building a bastion host. They also touch briefly on ongoing maintenance
and protection of the bastion host; note, though, that maintenance
issues are discussed primarily in <a class="xref" href="ch12_01.htm" title="Maintaining Firewalls">Chapter 12, <cite class="chapter">Maintaining Firewalls</CITE
></A
>.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-2899">5.8.1 Securing the Machine</A
></H3
><p class="para"><a class="indexterm" name="CH05MACHSEC"></A
><a class="indexterm" name="CH05SECMACH"></A
>To start with, build a machine with a standard operating system,
secured as much as possible. Start with a clean operating system and
follow the procedures we describe in this section.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-2908">5.8.1.1 Start with a minimal clean operating system
installation</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-2911"></A
><a class="indexterm" name="AUTOID-2914"></A
>Start with a clean operating system installation, straight from vendor
distribution media. If you do this, you will know exactly what you're
working with. You won't need to retrofit something that may already
have problems. Using such a system will also make later work
easier. Most vendor security patches you later obtain, as well as the
vendor configuration instructions and other documentation, assume
you're starting from an unmodified installation.</P
><p class="para">While you're installing the operating system, install as little as you
can get away with. It's much easier to avoid installing items than it
is to delete them completely later on. For that matter, once your
operating system is minimally functional, it's not hard to add
components if you discover you need them. Don't install any optional
subsystems unless you know you will need them.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-2918">5.8.1.2 Fix all known system bugs</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-2921"></A
><a class="indexterm" name="AUTOID-2924"></A
><a class="indexterm" name="AUTOID-2927"></A
><a class="indexterm" name="AUTOID-2931"></A
><a class="indexterm" name="AUTOID-2934"></A
>Get a list of known security patches and advisories for your operating
system; work through them to determine which are relevant for your own
particular system, and correct all of the problems described in the
patches and advisories. You get this information from your vendor
sales or technical support contacts, or from the user groups,
newsgroups, or electronic mailing lists devoted to your particular
platform.</P
><p class="para">A helpful list of contacts is available via anonymous
<span class="acronym">FTP</SPAN
> at the Firewalls mailing list archive:</P
><blockquote class="literallayout"><p class="literallayout"><a class="systemitem.url" href="../../../WebStripper/protected.html#link=ftp://ftp.greatcircle.com/pub/firewalls/vendor_security_contacts">ftp://ftp.greatcircle.com/pub/firewalls/vendor_security_contacts</A
></P
></BLOCKQUOTE
><p class="para">In addition, be sure to get from the Computer Emergency Response Team
Coordination Center (<span class="acronym">CERT-CC</SPAN
>) any advisories
relevant to your platform, and work through them. (For information on
how to contact <span class="acronym">CERT-CC</SPAN
> and retrieve its
information, see the list of resources in <a class="xref" href="appa_01.htm" title="Resources">Appendix A, <cite class="appendix">Resources</CITE
></A
>.)</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-2945">5.8.1.3 Use a checklist</A
></H4
><p class="para">To be sure you don't overlook anything in securing your bastion
host, use a security checklist. There are several excellent
checklists around. Be sure to use one that corresponds to your own
platform and operating system version.</P
><p class="para">Appendix A of <em class="emphasis">Practical <span class="acronym">UNIX</SPAN
>
Security</EM
>, referenced earlier, contains an extensive
checklist that covers most <span class="acronym">UNIX</SPAN
> platforms. More
specific checklists for particular operating system releases are often
available through the formal or informal support channels for those
platforms; check with your vendor support contacts, or the user
groups, newsgroups, or mailing lists that are devoted to the platform.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-2952">5.8.1.4 Safeguard the system logs</A
></H4
><p class="para"><a class="indexterm" name="CH05LOGS"></A
><a class="indexterm" name="AUTOID-2957"></A
>As a security-critical host, the bastion host requires considerable
logging. The next step in building the bastion host is to make sure
that you have a way of safeguarding the system logs for the bastion
host.  The system logs on the bastion host are important for two
reasons:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">They're one of the best methods of determining if your bastion
host is performing as it should be. If everything the bastion host
does is logged (and it should be), you should be able to examine the
logs to determine exactly what it's doing and decide if that's what
it's supposed to be doing. <a class="xref" href="ch12_01.htm" title="Maintaining Firewalls">Chapter 12</A
> describes the
use of system logs in maintaining your firewall.</P
></LI
><li class="listitem"><p class="para">When (not if!) someday someone does successfully break in to
the bastion host, the system logs are one of the primary mechanisms
that determine exactly what happened. By examining the logs and
figuring out what went wrong, you should be able to keep such a
break-in from happening again.</P
></LI
></UL
><p class="para">Where should you put the system logs? On the one hand, you want the
system logs to be somewhere convenient; you want them to be where they
can be easily examined to determine what the bastion host is doing. On
the other hand, you want the system logs to be somewhere safe; this
will keep them from any possible tampering in case you need to use
them to reconstruct an incident.</P
><p class="para">The solution to these seemingly contradictory requirements is to keep
two copies of the system logs&nbsp;- one for convenience, the other for
catastrophes.</P
>System logs for convenience<p class="para">The first copy of the system logs is the one you'll use on a regular
basis to monitor the ongoing activity of the machine. These are the logs
against which you run your daily and weekly automated analysis reports.
You can keep these logs either on the bastion host itself or on some
internal host. </P
><p class="para">The advantage of keeping them on the bastion host is simplicity: you
don't have to set up logging to go to some other system, nor do you have
to configure the packet filters to allow this. The advantage to keeping
them on an internal host is ease of access: you don't have to go to
the bastion host, which doesn't have any tools anyway, to examine the
logs. Avoid logging in to the bastion host, in any case.</P
>System logs for catastrophes<p class="para"><a class="indexterm" name="CH05CATASTROPHE"></A
>The second copy of the system logs is the one you'll use after a
catastrophe. You can't use your convenience logs at a time like this. 
Either the convenience logs won't be available, or you won't be sure of
their integrity any longer. </P
><p class="para">One of the simplest ways to create catastrophe logs is to attach a
line printer to one of the bastion host's serial ports, and simply log
a copy of everything to that port. There are some problems with this
approach, though. First, you have to keep the printer full of paper,
unjammed, and with a fresh ribbon. Second, once the logs are printed,
there's not much you can do with them except look at them. Because
they aren't in electronic form, you have no way to search or analyze
them in an automated fashion.</P
><p class="para">A more effective way to create catastrophe logs is to connect a
dedicated personal computer to a serial port on the bastion host, as a
<em class="emphasis">dropsafe</EM
> logging device. Configure the PC in such
a way that it boots up into a terminal program in &quot;record&quot;
mode, and that every so often (every 100,000 bytes, for example), the
log files are rotated and pruned so the system never runs out of disk
space.  In this way, anything the bastion host spits out to that
serial port will be recorded on the personal computer's disk. Unless
someone has physical access to the <span class="acronym">PC</SPAN
> (the
<span class="acronym">PC</SPAN
> should <em class="emphasis">not</EM
> be connected to
a network), the logs will remain safely out of reach. The advantage of
this approach over the first method is
that the data remains in electronic form. If you have to do searches
and analyses on the data (after an incident, for example), you can
retrieve it from the dropsafe machine.</P
><p class="para">If you have a write-once device available to you, use that device;
doing so is probably technically easier, especially if your write-once
device can emulate a filesystem. Be sure you can trust the write-once
feature. Some magneto-optical drives are capable of both
multiple-write and write-once operations, and keep track of the mode
they're in via software. If the system is compromised, it may be
possible to rewrite supposedly write-once media.</P
><p class="para">Some operating systems (notably <span class="acronym">BSD</SPAN
> 4.4-Lite and
systems derived from it, such as current releases of
<span class="acronym">BSDI</SPAN
>, Free<span class="acronym">BSD</SPAN
>, and
Net<span class="acronym">BSD</SPAN
>) support append-only files. These are not an
advisable alternative to write-once media or a dropsafe machine. Even
if you can trust the implementation of append-only files, the disk
that they're on is itself writable, and there may be ways to access
it outside of the filesystem, particularly for an intruder who wants
to destroy the logs.</P
><p class="para"><a class="xref" href="#FIRE-05-FIG-2" title="Use a PC attached by a serial line to create catastrophe logs">Figure 5.2</A
> shows how you can connect a personal
computer to your system to do logging.</P
><h4 class="figure"><a class="title" name="FIRE-05-FIG-2">Figure 5.2: Use a <span class="acronym">PC</SPAN
> attached by a serial line to create
catastrophe logs</A
></H4
><img class="graphic" src="figs/fire0502.gif" alt="Figure 5.2"><a class="indexterm" name="AUTOID-2996"></A
>Setting up system logs<p class="para"><a class="indexterm" name="CH05SYSLOG"></A
>On a <span class="acronym">UNIX</SPAN
> system, logging is handled through
<em class="emphasis">syslog</EM
>. The <em class="emphasis">syslog</EM
> daemon
records log messages from various local and remote clients (programs
with messages they want logged). Each message is tagged with facility
and priority codes: the facility code tells
<em class="emphasis">syslog</EM
> what general subsystem this message is
from (for example, the mail system, the kernel, the printing system,
the Usenet news system, etc.), and the priority code tells
<em class="emphasis">syslog</EM
> how important the message is (ranging from
debugging information and routine informational messages through
several levels up to emergency information). The
<em class="emphasis">/etc/syslog.conf</EM
> file controls what
<em class="emphasis">syslog</EM
> does with messages, based on their
facility and priority. A given message might be ignored, logged to one
or more files, forwarded to the <em class="emphasis">syslog</EM
> daemon on
another system, flashed onto the screens of certain or all users who
are currently logged in, or any combination.</P
><p class="para">When you configure <em class="emphasis">syslog</EM
> to record messages to
files, you could configure it to send all messages to a single file,
or to split messages up to multiple files by facility and priority
codes.  If you split messages by facility and priority codes, each log
file will be more coherent, but you'll have to monitor multiple files;
you may have an easier time finding messages from a particular
service. If you direct everything to a single file, on the other hand,
you'll only have a single file to check for all messages, but that
file will be much larger.</P
><p class="para">Many non-<span class="acronym">UNIX</SPAN
> systems, particularly network devices
such as routers, can be configured to log messages via
<em class="emphasis">syslog</EM
>. If your systems have that capability,
configuring them to so they all log to your bastion host provides a
convenient way to collect all their messages in a single place.</P
><p class="para">Be aware that remote logging via <em class="emphasis">syslog</EM
> (e.g.,
from a router to your bastion host, or from your bastion host to some
internal host) is not 100% reliable. For one thing,
<em class="emphasis">syslog</EM
> is a <span class="acronym">UDP</SPAN
>-based service,
and the sender of a <span class="acronym">UDP</SPAN
> packet has no way of
knowing whether or not the receiver got the packet unless the receiver
tells the sender (<em class="emphasis">syslog</EM
> daemons don't confirm
receipt to their senders). For another thing, even if
<em class="emphasis">syslog</EM
> were <span class="acronym">TCP</SPAN
>-based, you
still couldn't absolutely depend on it not to lose messages; what if
the receiving system was down or otherwise unavailable? This is one
reason that it's important to have a locally attached dropsafe machine
to reliably capture all <em class="emphasis">syslog</EM
> messages.</P
><p class="para">Despite its weaknesses, though, <em class="emphasis">syslog</EM
> is a
useful service; you should make extensive use of it.<a class="indexterm" name="AUTOID-3026"></A
><a class="indexterm" name="AUTOID-3027"></A
><a class="indexterm" name="AUTOID-3028"></A
><a class="indexterm" name="AUTOID-3029"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-3030">5.8.2 Disabling Nonrequired Services</A
></H3
><p class="para"><a class="indexterm" name="CH05SERVINTDIS"></A
><a class="indexterm" name="CH05DISABLING"></A
>Once you've completed the basic process of securing your bastion host,
go on to the next step: disabling any services that aren't absolutely
necessary for the bastion host to provide. </P
><p class="para">Any service provided by the bastion host might have bugs or
configuration problems that could lead to security problems.
Obviously, you'll have to provide some services that users need, as
long as your site's security policy allows them. But, if the service
isn't absolutely necessary, don't borrow trouble by providing it. If
a service isn't provided by the bastion host, you won't have to worry
about possible bugs or configuration problems.</P
><p class="para">If you can live without a service, it should be turned off. It's worth
suffering some inconvenience. This means that you're going to need to
think very carefully about services. You'll be disabling not just
services you never heard of and never used, but also services you've
purposefully enabled on other machines. Look at every 
service and ask yourself &quot;How could I avoid enabling this? What do
I lose if I turn it off?&quot;</P
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3040">5.8.2.1 How are services managed?</A
></H4
><p class="para">On <span class="acronym">UNIX</SPAN
> machines, most services are managed in one
of two ways:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">By controlling when they start and who can use them</P
></LI
><li class="listitem"><p class="para">By service-specific configuration files</P
></LI
></UL
><p class="para">There are two ways services get started on <span class="acronym">UNIX</SPAN
> systems:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">At boot time from a machine's <em class="emphasis">/etc/rc</EM
> files</P
></LI
><li class="listitem"><p class="para">On demand by the <em class="emphasis">inetd</EM
> daemon (which is
itself started at boot time) </P
></LI
></UL
><p class="para">A few services&nbsp;- for example, Sendmail&nbsp;- can be configured to run
under either or both mechanisms. </P
>Services started by /etc/rc files<p class="para"><a class="indexterm" name="AUTOID-3062"></A
><a class="indexterm" name="AUTOID-3064"></A
><a class="indexterm" name="AUTOID-3067"></A
><a class="indexterm" name="AUTOID-3069"></A
>Services in the first category are designed to run indefinitely. They
are started once (when the machine boots), and they are never supposed
to exit. (Of course, sometimes they do exit, either because they're
killed by a system administrator, or because they trip over a bug or
some other error.) Servers are written in this way if they need to
handle small transactions quickly, or if they need to &quot;remember&quot;
information. Writing them in this way avoids the delays associated
with starting a new copy of the server to handle each request made to
it.</P
><p class="para">Servers of this kind are started from a <span class="acronym">UNIX</SPAN
>
system's <em class="emphasis">/etc/rc</EM
> files, which are shell scripts
executed when the machine boots. Examples of servers typically started
from <em class="emphasis">/etc/rc</EM
> files are those that handle
<span class="acronym">NFS</SPAN
>, <span class="acronym">SMTP</SPAN
>, and
<span class="acronym">DNS</SPAN
>. In <span class="acronym">BSD</SPAN
>-based versions of
<span class="acronym">UNIX</SPAN
>, there are customarily a few files in
<em class="emphasis">/etc</EM
> with names that start with &quot;rc.&quot;
(for example <em class="emphasis">/etc/rc.boot</EM
>). In System V-based
versions of <span class="acronym">UNIX</SPAN
>, there are customarily directories
in <em class="emphasis">/etc</EM
> instead of files (for instance,
<em class="emphasis">/etc/rc.0.d</EM
>); the directories contain the various
startup commands, each in its own little file.</P
><p class="para">In either case, you need to be careful to look at all of the startup
scripts and all of the scripts they call, recursively. Usually more
than one script is run in the process of bringing a system all the way
up. On modern <span class="acronym">UNIX</SPAN
> systems, those scripts often
call others, sometimes through multiple levels of indirection. For
example, you may find that a startup script calls another script to
start up networking, and that one calls yet another script to start up
file service. You may also find that startup scripts use mystical
options to familiar commands (e.g., they often run
<em class="emphasis">ifconfig</EM
> with little-used options that cause
<em class="emphasis">ifconfig</EM
> to pick up configuration information
from obscure places). Be sure you understand these options and that
you replace any that tell the machine to pick up information about
itself from the network (or from services it normally provides but
that you are going to turn off).</P
><p class="para">Some versions of <span class="acronym">UNIX</SPAN
> also have an additional
process started from these files that is designed to restart other
servers if they fail. If such a program exists on a system, it will
try to start the other servers if they are removed from the startup
files but not from its configuration file. Either turn off this
program or be sure to remove from the program's configuration file any
servers removed from the startup files. You'll notice the program when
you work through the startup files.</P
>Services started by inetd<p class="para"><a class="indexterm" name="AUTOID-3094"></A
>Some servers are designed to be started &quot;on demand,&quot; and to exit after
they provide the requested service. Such servers are typically used
for services that are requested infrequently; for services that aren't
sensitive to delays in starting a new server from scratch; and for
services that require a new server process to deal with each request
(for example, Telnet or <span class="acronym">FTP</SPAN
> sessions, where a
separate server is used for each active session).</P
><p class="para">Servers of this kind are usually run from the
<em class="emphasis">inetd</EM
> server. (The <em class="emphasis">inetd</EM
>
server itself, because it runs indefinitely, is started from the
<em class="emphasis">/etc/rc</EM
> files, as described in the previous
section.) The <em class="emphasis">inetd</EM
> server listens for requests
for services specified in the <em class="emphasis">/etc/inetd.conf</EM
>
configuration file. When it hears such a request, it starts the right
server to process the request.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3103">5.8.2.2 How to disable services</A
></H4
><p class="para">If you disable a critical service, you must first make certain 
you have a way to boot the machine. This could be a second hard disk
with a full root partition on it or a <span class="acronym">CD-ROM</SPAN
> drive
with the operating system install disk. You need to be ruthless; if
you delete the wrong thing and can't reboot, at best you're going to
be over-cautious about deleting things, and at worst you're going to
end up with an unusable computer.</P
><p class="para">Second, you must save a clean copy of every file before you modify it.
Even when you're just commenting things out, every so often your
fingers slip, and you delete something you didn't mean to, or you
change a critical character.</P
><p class="para"><a class="indexterm" name="AUTOID-3109"></A
>Once you've taken these precautions, walk through the startup files
for your system, line by line, making sure you know exactly what each
line does&nbsp;- including the command line options&nbsp;- and commenting out or
deleting the lines that start services you don't need. In a perfect
world, you would comment out every line, and then uncomment or rewrite
the ones you need. Unfortunately, if you do this and the machine
crashes in the middle, it will not reboot. It's rather a lot of
trouble for a small increase in security over merely commenting out
with a very free hand.</P
><p class="para">You will frequently see services that are started after a check for some
configuration file. If you don't want the service to run, comment out
the entire code block. Don't leave the code active simply because the
configuration file doesn't <em class="emphasis">currently</EM
> exist and the
service won't <em class="emphasis">currently</EM
> be started. Someone or
something might create the configuration file some time in the future.
Commenting out the entire thing is more secure and less risky.</P
><p class="para">Commenting out lines is preferable to removing them, because it leaves
evidence of your intent. When you comment something out, add a comment
about why you have commented it out. If you delete something, replace it
with a comment about why you have deleted it. Make sure that the next
person to look at the files knows that you got rid of things on purpose
and doesn't helpfully &quot;fix&quot; it for you. If you comment out a
call to another script, add a comment in that script indicating that
it's not supposed to be started, and why. Renaming it or commenting out
its contents are also good ways to help ensure that it won't
accidentally reappear. </P
><p class="para">For every service that you leave enabled, apply the same line-by-line
procedure to the service's configuration files. Obviously, you want to
pay particular attention to <em class="emphasis">inetd</EM
>'s configuration
file. On most systems, this file is called
<em class="emphasis">/etc/inetd.conf</EM
>. (On other systems, this file
might be called <em class="emphasis">/etc/servers</EM
> or something else;
check your manual pages for <em class="emphasis">inetd</EM
>). If you have a
daemon-watcher and have decided to leave it on, its configuration files
are also particularly important. </P
><p class="para">In general, you'll need to reboot your machine after you have changed
the configuration files. The changes won't take effect until you
do so.</P
><p class="para">After you have rebooted and tested the machine, and you are comfortable
that the machine works without the disabled services, you may want to
remove the executables for those services. If the executables are lying
around, they may be started by somebody&nbsp;- if not you, some other system
administrator, or an intruder. A few services may even be executable by
nonroot users if they use nonstandard ports. </P
><p class="para"><a class="indexterm" name="AUTOID-3123"></A
><a class="indexterm" name="AUTOID-3125"></A
><a class="indexterm" name="AUTOID-3127"></A
>If you feel uncertain about removing executables, consider encrypting
them instead. Do not use the standard <span class="acronym">UNIX</SPAN
>
<em class="emphasis">crypt</EM
> program; the encryption algorithm it uses
is little more than a toy and can be trivially broken. Instead, use a
more secure encryption program like <em class="emphasis">snuffle</EM
> or
something that uses the <span class="acronym">DES</SPAN
> or
<span class="acronym">IDEA</SPAN
> algorithm. Choose a secure key; if you forget
the key, you're no worse off than if you'd deleted the files, but if
an intruder gets the key, you're considerably worse off.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3135">5.8.2.3 Which services should you leave enabled?</A
></H4
><p class="para">Certain services are essential to the operation of the machine, and
you'll probably need to leave these enabled, no matter what else the
machine is configured to do. On a <span class="acronym">UNIX</SPAN
> system, these processes include:</P
><dl class="variablelist"><dt class="term"><em class="emphasis">init</EM
>, <em class="emphasis">swap</EM
>, and
<em class="emphasis">page</EM
></DT
><dd class="listitem"><p class="para">The three kernel pseudo-processes used to manage all other
processes</P
></DD
><dt class="term"><em class="emphasis">cron</EM
></DT
><dd class="listitem"><p class="para">Runs other jobs at fixed times, for housekeeping and so on</P
></DD
><dt class="term"><em class="emphasis">syslogd</EM
></DT
><dd class="listitem"><p class="para">Collects and records log messages from the kernel and other daemons</P
></DD
><dt class="term"><em class="emphasis">inetd</EM
></DT
><dd class="listitem"><p class="para">Starts network servers (such as <em class="emphasis">telnetd</EM
> and
<em class="emphasis">ftpd</EM
>) when such services are requested by other
machines</P
></DD
></DL
><p class="para">In addition, you'll obviously need server processes for the services
that you've decided to provide on your bastion host, e.g., real or
proxy Telnet, <span class="acronym">FTP</SPAN
>, <span class="acronym">SMTP</SPAN
>, and
<span class="acronym">DNS</SPAN
> servers.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3168">5.8.2.4 Which services should you disable?</A
></H4
><p class="para">You will want to disable all services except the ones you have decided
to provide, and the supporting services necessary for those to run, as
described above. You may not always know which services are the
required support services, particularly because
<span class="acronym">UNIX</SPAN
> names tend to be cryptic and uninformative.</P
><p class="para">How do you know which services to disable?</P
><p class="para">There are three simple rules to apply:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">If you don't need it, turn it off. </P
></LI
><li class="listitem"><p class="para">If you don't know what it does, turn it off (you probably didn't
need it anyway). </P
></LI
><li class="listitem"><p class="para">If turning it off causes problems, you now know what it does,
and you can either turn it back on again (if it's really necessary) or
figure out how to do without it.</P
></LI
></UL
><span class="acronym">NFS</SPAN
> and related services<p class="para"><a class="indexterm" name="AUTOID-3185"></A
><a class="indexterm" name="AUTOID-3188"></A
>Start with <span class="acronym">NFS</SPAN
> and related network services. You
aren't going to need these. No internal machine should trust your
bastion host enough to let the bastion host mount the internal
machine's disks via <span class="acronym">NFS</SPAN
>. Besides that, there
probably won't be anything on the bastion host that you'll want to
export via <span class="acronym">NFS</SPAN
>. <span class="acronym">NFS</SPAN
> is very
convenient, but it's incredibly insecure.</P
><p class="para"><span class="acronym">NFS</SPAN
> services are provided by a whole set of
servers; the specific set of servers, and the names of the individual
servers, varies slightly from one version of <span class="acronym">UNIX</SPAN
>
to the next. Look for these names or names like them:

<ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">nfsd</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">biod</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">mountd</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">statd</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">lockd</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">automount</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">keyserv</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">rquotad </EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">amd</EM
></P
></LI
></UL
><a class="indexterm" name="AUTOID-3226"></A
></P
><p class="para">Most of these services are started at boot time from the
<em class="emphasis">/etc/rc</EM
> files, although some are started on
demand by <em class="emphasis">inetd</EM
>. <em class="emphasis">mountd</EM
> is
somewhat peculiar in that it is often started at boot time <em class="emphasis">and</EM
> is listed in the <em class="emphasis">inetd</EM
>
configuration file, apparently so that it will be restarted if for
some reason the copy that was started at boot time crashes.</P
>Other <span class="acronym">RPC</SPAN
> services<p class="para"><a class="indexterm" name="AUTOID-3238"></A
><a class="indexterm" name="AUTOID-3241"></A
><a class="indexterm" name="AUTOID-3244"></A
><a class="indexterm" name="AUTOID-3247"></A
>You should also disable other services based on the Remote Procedure
Call (<span class="acronym">RPC</SPAN
>) system. The most critical of these is
<span class="acronym">NIS/YP</SPAN
>, a service which is provided by the
following servers:

<ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">ypserv</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">ypbind</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">ypupdated</EM
></P
></LI
></UL
></P
><p class="para">These servers are generally started at boot time from the
<em class="emphasis">/etc/rc</EM
> files. </P
><p class="para">Also disable these <span class="acronym">RPC</SPAN
>-based services:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">rexd</EM
> (the remote execution service, started by
<em class="emphasis">inetd</EM
>)</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">walld</EM
> (the &quot;write all&quot;, or
<em class="emphasis">wall</EM
> daemon, started by
<em class="emphasis">inetd</EM
>)</P
></LI
></UL
><p class="para"><a class="indexterm" name="AUTOID-3276"></A
><a class="indexterm" name="AUTOID-3278"></A
>All <span class="acronym">RPC</SPAN
>-based services depend on a single service
usually called <em class="emphasis">portmap </EM
>(on some machines
it is known as <em class="emphasis">rpcbind</EM
>). If you've disabled all
of the <span class="acronym">RPC</SPAN
>-based services, you can (and should)
also disable the <em class="emphasis">portmap</EM
> service. How can you
tell if you've disabled all the <span class="acronym">RPC</SPAN
>-based services?
Before disabling <em class="emphasis">portmap</EM
>, but after disabling
what you think are the rest of the <span class="acronym">RPC</SPAN
>-based
services, reboot the machine and then issue a <em class="emphasis">rpcinfo
-p</EM
> command. If the output of that command shows only
entries for <em class="emphasis">portmap</EM
> itself, this means that no
other <span class="acronym">RPC</SPAN
> services are running. On the other hand,
if the output shows that other <span class="acronym">RPC</SPAN
> services are
still running, you will need to investigate further to determine what
and why. If you decide to provide any <span class="acronym">RPC</SPAN
>-based
services, you must also provide the <em class="emphasis">portmap</EM
>
service. In that case, consider using Wietse Venema's replacement
<em class="emphasis">portmap</EM
>, which is more secure than the versions
shipped with most <span class="acronym">UNIX</SPAN
> systems (see <a class="xref" href="appb_01.htm" title="Tools">Appendix B</A
> for information on where to find it).</P
>Booting services<p class="para"><a class="indexterm" name="AUTOID-3300"></A
><a class="indexterm" name="AUTOID-3302"></A
>Your bastion host should probably not provide booting services; nothing
should trust the host enough to be willing to boot from it. This means
that, in most cases, you should disable these services:
<ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">tftpd</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">bootd</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">bootpd</EM
></P
></LI
></UL
></P
>BSD &#8216;r&#8217; command services<p class="para"><a class="indexterm" name="AUTOID-3318"></A
><a class="indexterm" name="AUTOID-3321"></A
><a class="indexterm" name="AUTOID-3323"></A
>These should all be disabled. The servers for these services are
typically named <em class="emphasis">rshd</EM
>,
<em class="emphasis">rlogind,</EM
> and <em class="emphasis">rexecd</EM
>, and are
typically started by <em class="emphasis">inetd</EM
>. The remaining
&quot;r&quot; services are based on these and will not run without
them.</P
>routed<p class="para"><a class="indexterm" name="AUTOID-3333"></A
><a class="indexterm" name="AUTOID-3335"></A
>Another server that your bastion host probably doesn't need is 
<em class="emphasis">routed</EM
>. This server is started at boot time
from the <em class="emphasis">/etc/rc</EM
> files, listens to routing
information broadcasts, and updates the kernel routing table based on
what it hears. </P
><p class="para">You probably don't need <em class="emphasis">routed</EM
> on your bastion
host, because your bastion host is probably located on the perimeter
of your network, where routing should be fairly simple. A more secure
approach is to create static routes pointing to your internal
networks and a default route pointing to your Internet gateway
router. You do this at boot time by adding appropriate &quot;route add&quot;
commands to the <em class="emphasis">/etc/rc</EM
> files.</P
><p class="para"><a class="indexterm" name="AUTOID-3344"></A
>If you must do dynamic routing on your bastion host, obtain and use
<em class="emphasis">gated</EM
> (see <a class="xref" href="appb_01.htm" title="Tools">Appendix B</A
> for
information on how to get it) rather than <em class="emphasis">routed</EM
>.
<em class="emphasis">gated</EM
> understands the same routing protocols as
<em class="emphasis">routed</EM
> (plus several more), but
<em class="emphasis">gated</EM
> can be specifically told who to accept
routing information from, while <em class="emphasis">routed</EM
> will
accept information from anyone. Be sure that you set up the
configuration files for <em class="emphasis">gated </EM
> to limit which
hosts it listens to.</P
>fingerd<p class="para"><a class="indexterm" name="CH05FINGERD"></A
>The <em class="emphasis">finger</EM
> server supplies information
about existing accounts and accounts on <span class="acronym">UNIX</SPAN
>
systems. This server is started on demand by
<em class="emphasis">inetd</EM
>. The information provided by
<em class="emphasis">fingerd </EM
>can be valuable to crackers; it tells
them information about potential targets, such as:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Which accounts exist. This tells them which accounts they should
try to guess passwords for.</P
></LI
><li class="listitem"><p class="para">Personal information about the people with accounts. This tells
them what passwords to start guessing with.</P
></LI
><li class="listitem"><p class="para">Which accounts are in use. This tells them which accounts should
be avoided, at least until they're not in use.</P
></LI
><li class="listitem"><p class="para">Which accounts haven't been used lately. This tells them which
accounts are good targets for attack, because the owners probably won't
notice that the accounts are being used.</P
></LI
></UL
><p class="para"><a class="indexterm" name="AUTOID-3373"></A
>On the other hand, Internet users often use <em class="emphasis">finger</EM
>
(the program that talks to your <em class="emphasis">fingerd</EM
> daemon)
quite legitimately. <em class="emphasis">finger </EM
>is helpful in locating
email addresses and telephone numbers. Instead of simply disabling
<em class="emphasis">fingerd</EM
>, you might want to replace it with a
program that obtains information from a more basic source of contact
information for your site; the information might include:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Your main phone number</P
></LI
><li class="listitem"><p class="para">Who to contact if they have questions about your site's products
or services</P
></LI
><li class="listitem"><p class="para">Sample email addresses if standardized aliases such as
<em class="emphasis">Firstname_Lastname</EM
> are maintained for users at your
site</P
></LI
><li class="listitem"><p class="para">Who to contact in case of network or security problems involving
your site</P
></LI
></UL
><p class="para">You can provide this kind of generic information to anybody who uses
<em class="emphasis">finger</EM
> to check on your site, regardless of what
specific information they've requested. The easiest way to accomplish
this is to put the information in a file (for example,
<em class="emphasis">/etc/finger_info</EM
>) and then replace the part of
the <em class="emphasis">/etc/inetd.conf</EM
> entry for
<em class="emphasis">fingerd</EM
> that specifies the program to run with
something like <em class="emphasis">/bin/cat /etc/finger_info</EM
>. Doing
this causes the contents of the <em class="emphasis">/etc/finger_info</EM
>
file to be returned to anyone contacting your
<em class="emphasis">fingerd</EM
> server.</P
><p class="para">For example, here is the old <em class="emphasis">/etc/inetd.conf</EM
> line
from Great Circle Associate's system:</P
><blockquote class="screen"><pre class="screen">finger stream tcp nowait nobody /usr/libexec/fingerd fingerd</PRE
></BLOCKQUOTE
><p class="para">and here is the new <em class="emphasis">/etc/inetd.conf</EM
> line:</P
><blockquote class="screen"><pre class="screen">finger stream tcp nowait nobody /bin/cat cat /etc/finger_info</PRE
></BLOCKQUOTE
><p class="para">and here are the contents of the <em class="emphasis">/etc/finger_info</EM
>
file:</P
><blockquote class="screen"><pre class="screen">Great Circle Associates
Phone: +1 415 962 0841
Email: Info@GreatCircle.COM

For more information, or to report system problems, please 
send email or call.</PRE
></BLOCKQUOTE
><a class="indexterm" name="AUTOID-3406"></A
>ftpd<p class="para"><a class="indexterm" name="AUTOID-3410"></A
><a class="indexterm" name="AUTOID-3412"></A
><a class="indexterm" name="AUTOID-3414"></A
>If you're going to provide anonymous <span class="acronym">FTP</SPAN
> service on
your bastion host, you need to reconfigure the <span class="acronym">FTP</SPAN
>
server appropriately. You should replace the <em class="emphasis">ftpd</EM
>
program with one more suited to providing anonymous
<span class="acronym">FTP</SPAN
> service than the standard
<em class="emphasis">ftpd</EM
> programs shipped by most
<span class="acronym">UNIX</SPAN
> vendors. (See <a class="xref" href="ch08_01.htm" title="Configuring Internet Services">Chapter 8</A
> for
information about providing anonymous <span class="acronym">FTP</SPAN
> service.)</P
><p class="para">If you're <em class="emphasis">not</EM
> going to provide anonymous
<span class="acronym">FTP</SPAN
>, you can probably disable your
<span class="acronym">FTP</SPAN
> server entirely; it's started on demand by
<em class="emphasis">inetd</EM
>.</P
><p class="para">Even if you've disabled the <span class="acronym">FTP</SPAN
> server on your
bastion host, you can still use the <span class="acronym">FTP</SPAN
> client
program (typically called simply <em class="emphasis">ftp</EM
>) on the
bastion host to transfer files to and from other systems. You'll just
have to do the work from the bastion host, instead of from the other
systems.</P
>Other services<p class="para">There are lots of other services you probably don't need and should
disable. Although the specific list depends on your own site's security
policy and needs, and on the platform you're using, it should probably
include the following:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">uucpd</EM
> (<span class="acronym">UUCP</SPAN
> over
<span class="acronym">TCP/IP</SPAN
>)</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">rwhod</EM
> (sort of like <em class="emphasis">fingerd</EM
>,
in that it tells you who's currently logged in on the system)</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">lpd</EM
> (the printer daemon)</P
></LI
></UL
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3449">5.8.2.5 Turning off routing</A
></H4
><p class="para"><a class="indexterm" name="CH05ROUTDIS"></A
><a class="indexterm" name="AUTOID-3455"></A
>If you have a dual-homed host that is not supposed to be a router, you
will need to specifically disable routing. In order to act as an
<span class="acronym">IP</SPAN
> router, a dual-homed host needs to accept
packets that are addressed to other
machines' <span class="acronym">IP</SPAN
> addresses, and send them on
appropriately. This is known as <em class="emphasis">IP forwarding</EM
>,
and it's usually implemented at a low level in the operating system
kernel. An <span class="acronym">IP</SPAN
>-capable host with multiple interfaces
normally does this automatically, without any special configuration.</P
><p class="para">Other machines have to know that the dual-homed host is a router in
order to use it as such. Sometimes this is done simply by configuring
those machines to always route packets for certain networks to the
dual-homed host (this is called <em class="emphasis">static
routing</EM
>). More often, however, the dual-homed host is
configured to broadcast its routing capabilities via a routing
protocol such as Routing Information Protocol
(<span class="acronym">RIP</SPAN
>). Other machines hear these routing broadcasts
and adjust their own routing tables accordingly (this is called
<em class="emphasis">dynamic routing</EM
>). This broadcast of routing
information by the dual-homed host is usually done by an additional
program (for example, <em class="emphasis">routed</EM
> or
<em class="emphasis">gated</EM
> on a <span class="acronym">UNIX</SPAN
> system), which
often has to be turned on explicitly.</P
><p class="para"><a class="indexterm" name="AUTOID-3470"></A
><a class="indexterm" name="AUTOID-3473"></A
><a class="indexterm" name="AUTOID-3476"></A
>To use a dual-homed host as a firewall, you need to convert it to a
nonrouting dual-homed host; you take a machine that has two network
interfaces, and you configure it so it <em class="emphasis">can't</EM
> act
as a router between those two interfaces. This is a two-step process:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Turn off any program that might be advertising it as a router; this is
usually relatively straightforward.</P
></LI
><li class="listitem"><p class="para">Disable <span class="acronym">IP</SPAN
> forwarding; this is considerably more
difficult, and may require modifying the operating system kernel.</P
></LI
></OL
><p class="para">Fortunately, these days a number of <span class="acronym">UNIX</SPAN
> vendors
provide supported parameters for turning off <span class="acronym">IP</SPAN
>
forwarding. Even for vendors that don't, it's about as easy as kernel
patches get on most machines: turning off <span class="acronym">IP</SPAN
>
forwarding necessitates only a change in the value of a single kernel
variable. You need to consult your vendor to find out how to turn off
<span class="acronym">IP</SPAN
> forwarding on your machines.</P
><p class="para">Unfortunately, it's not always that easy to turn off all routing,
particularly on <span class="acronym">BSD</SPAN
>-based systems, such as
Sun<span class="acronym">OS</SPAN
> and Ultrix. On such systems, you can patch
the kernel to turn off <span class="acronym">IP</SPAN
> forwarding, but the
<span class="acronym">IP</SPAN
> source-routing option usually remains a security
hole.</P
><p class="para"><a class="indexterm" name="AUTOID-3496"></A
><a class="indexterm" name="AUTOID-3498"></A
><a class="indexterm" name="AUTOID-3501"></A
>What is <em class="emphasis">source routing</EM
>? Normal
<span class="acronym">IP</SPAN
> packets have only source and destination
addresses in their headers, with no information about the route the
packet should take from the source to the destination. It's the job of
the routers in between the source and the destination to determine the
most efficient route. However, source-routed <span class="acronym">IP</SPAN
>
packets contain additional information in the <span class="acronym">IP</SPAN
>
header that specifies the route the packet should take. This
additional routing information is specified by the source host; thus
the term source-routed.</P
><p class="para">When a router receives a source-routed packet, it follows the route
specified in the packet, instead of determining the most efficient
route from source to destination. The source-routing specification
overrides the ordinary routing. Because of the way the routing code is
implemented in most <span class="acronym">UNIX</SPAN
> kernels, turning off
<span class="acronym">IP</SPAN
> forwarding does <em class="emphasis">not</EM
> disable
forwarding of source-routed packets. It's implemented completely
separately. Unlike <span class="acronym">IP</SPAN
> forwarding, source routing is
not generally an easily patchable option. It is possible to disable it
(you can disable anything with persistence and/or source code), but
it's much more difficult.</P
><p class="para">Source-routed packets can easily be generated by modern applications
like the Telnet client that's freely available on the Internet as part
of the <span class="acronym">BSD</SPAN
> 4.4 release. Unless you block
source-routed packets somewhere else, such as in a router between the
dual-homed host and the Internet, source-routed packets can blow right
past your dual-homed host and into your internal network.</P
><p class="para">Worse still, source routing goes both ways. Once source-routed packets
make their way to an internal system, the system is supposed to reply
with source-routed packets that use the inverse of the original route. 
The reply from your internal system back to the attacker will also blow
right through your dual-homed host, allowing two-way connection through
a firewall that was supposed to block all communications across it.</P
><p class="para">If you are not going to screen your dual-homed host, you will need to
patch your operating system so that it rejects source-routed packets.
Consult your vendor, and/or appropriate security mailing lists
(discussed in <a class="xref" href="appa_01.htm" title="Resources">Appendix A</A
>) for information on how to
do this on your platform. This is not the sort of thing most
vendors' customer support structures deal with rapidly and painlessly;
expect to have to dig to find what you need to know.<a class="indexterm" name="AUTOID-3518"></A
><a class="indexterm" name="AUTOID-3519"></A
><a class="indexterm" name="AUTOID-3520"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-3521">5.8.3 Installing and Modifying Services</A
></H3
><p class="para"><a class="indexterm" name="CH05SERVINTINST"></A
><a class="indexterm" name="CH05INSTINTSERV"></A
><a class="indexterm" name="CH05MODINTSERV"></A
>Some of the services you want to provide may not be provided with your
operating system (for example, <span class="acronym">WWW</SPAN
> generally is
not). Others may be provided but are inappropriate for use in a secure
environment or are missing features you probably want (for example,
stock <em class="emphasis">fingerd</EM
> and
<em class="emphasis">ftpd</EM
>). Even those few remaining services that are
provided, secure, and up-to-date in your vendor's operating system
release should be protected with the <span class="acronym">TCP</SPAN
> Wrapper
package or the <em class="emphasis">netacl</EM
> program from the
<span class="acronym">TIS FWTK</SPAN
> to improve security and
provide logging.  (Although <span class="acronym">TCP</SPAN
> Wrapper and
<em class="emphasis">netacl</EM
> will increase security, they're not
perfect; they rely on the source <span class="acronym">IP</SPAN
> address to
identify hosts, and <span class="acronym">IP</SPAN
> addresses can be forged.)</P
><p class="para">For detailed information about individual services, including advice on
selecting <span class="acronym">WWW</SPAN
>, <span class="acronym">NNTP</SPAN
>, and
<span class="acronym">FTP</SPAN
> servers, see <a class="xref" href="ch08_01.htm" title="Configuring Internet Services">Chapter 8</A
>.</P
><p class="para">Whatever services you do leave enabled should also be protected to the
extent possible by the <span class="acronym">TCP</SPAN
> Wrapper package or the
<em class="emphasis">netacl</EM
> program, as we describe in the following
sections. For example, you might want to set up your bastion host so
that it only accepts Telnet connections from one specific machine, such
as the workstation you normally use.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3550">5.8.3.1 Using the TCP Wrapper package to protect services</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-3553"></A
><a class="indexterm" name="AUTOID-3555"></A
><a class="indexterm" name="AUTOID-3558"></A
>The <span class="acronym">TCP</SPAN
> Wrapper package, written by Wietse Venema,
monitors incoming network traffic and controls network activity. It is
a simple but very effective piece of publicly available software set
up to run whenever certain ports (corresponding to certain services)
are connected. <span class="acronym">TCP</SPAN
> Wrapper provides simple access
control list protection, as well as improved logging, for services
that are started by <em class="emphasis">inetd</EM
>.</P
><p class="para">Using the <span class="acronym">TCP</SPAN
> Wrapper package is easy. Here's what you do:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Install the package and set up a pair of simple access control files
that define which hosts and networks are allowed to access which
services.</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3571"></A
>Reconfigure your <em class="emphasis">inetd</EM
> to run the main
<span class="acronym">TCP</SPAN
> Wrapper program (called
<em class="emphasis">tcpd</EM
>) instead of the &quot;real&quot; server.</P
></LI
><li class="listitem"><p class="para">When a request for a service comes in, <em class="emphasis">inetd</EM
>
starts <em class="emphasis">tcpd</EM
>, which evaluates the request against
the <span class="acronym">TCP</SPAN
> Wrapper configuration files. This program
decides whether or not to log the request, and whether or not to carry
out the request.</P
></LI
><li class="listitem"><p class="para">If <em class="emphasis">tcpd</EM
> decides that the request is acceptable,
it starts the &quot;real&quot; server to process the request. </P
></LI
></OL
><p class="para">For example, if you want to allow Telnet connections from a specific
host (172.16.1.2) to your machine, but deny Telnet connections from
all other hosts, you would change the line for
<em class="emphasis">telnetd</EM
> in your
<em class="emphasis">/etc/inetd.conf</EM
> file to say something like:</P
><blockquote class="screen"><pre class="screen">telnet stream tcp nowait root /usr/local/libexec/tcpd telnetd</PRE
></BLOCKQUOTE
><p class="para">You would also need to create an <em class="emphasis">/etc/hosts.allow</EM
>
file that tells the <span class="acronym">TCP</SPAN
> Wrapper package (the
<em class="emphasis">tcpd</EM
> program) which host to allow connections
from:</P
><blockquote class="screen"><pre class="screen">telnetd : 172.16.1.2</PRE
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="AUTOID-3594"></A
>And finally, you'd need to create an
<em class="emphasis">/etc/hosts.deny</EM
> file to tell the
<span class="acronym">TCP</SPAN
> Wrapper package to deny all connections from
all hosts by default, and to send email to root about
each probe:</P
><blockquote class="screen"><pre class="screen">ALL : ALL : (/usr/local/etc/safe_finger -l @%h | \
    /usr/ucb/Mail -s &quot;PROBE %d from %c&quot; root)&amp;</PRE
></BLOCKQUOTE
><p class="para">Note that the <em class="emphasis">/etc/hosts.deny</EM
> file only applies
to services protected by the <span class="acronym">TCP</SPAN
> Wrapper package
(that is, services for which you've configured
<em class="emphasis">inetd</EM
> to run <em class="emphasis">tcpd</EM
> instead of
the real server). If you don't tell <em class="emphasis">inetd</EM
> to run
the <span class="acronym">TCP</SPAN
> Wrapper package (the
<em class="emphasis">tcpd</EM
> program) for a given service, then the
<span class="acronym">TCP</SPAN
> Wrapper package won't do anything regarding
that service.</P
><p class="para">Despite its name, the <span class="acronym">TCP</SPAN
> Wrapper package supports
<span class="acronym">UDP</SPAN
>-based services in addition to
<span class="acronym">TCP</SPAN
>-based services. Beware, however, that the
<span class="acronym">TCP</SPAN
> Wrapper package can only control when to
<em class="emphasis">start</EM
> <span class="acronym">UDP</SPAN
>-based servers; it
cannot control access to those servers once they're started, and many
<span class="acronym">UDP</SPAN
>-based servers will hang around and continue to
process requests for some period of time beyond the initial start-up
request. Many eventually time out and exit, but once they've been
started through a legitimate request, they're vulnerable to
illegitimate requests.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3616">5.8.3.2 Using netacl to protect services</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-3619"></A
><a class="indexterm" name="AUTOID-3622"></A
>The <em class="emphasis">netacl</EM
> component of the <span class="acronym">TIS FWTK</SPAN
> (described in some detail in <a class="xref" href="ch07_01.htm" title="Proxy Systems">Chapter 7, <cite class="chapter">Proxy Systems</CITE
></A
>) provides much the same capability as the
<span class="acronym">TCP</SPAN
> Wrapper package. To implement the same example
as above (except for the ability to trace probes from unauthorized
systems) using <em class="emphasis">netacl</EM
>, you would change the line
for <em class="emphasis">telnetd</EM
> in your
<em class="emphasis">/etc/inetd.conf</EM
> file to:</P
><blockquote class="screen"><pre class="screen">telnet stream tcp nowait root /usr/local/lib/netacl telnetd</PRE
></BLOCKQUOTE
><p class="para">Then, you would add the following lines to your
<span class="acronym">FWTK</SPAN
> <em class="emphasis">netperm</EM
> configuration
file (wherever that is on your system):</P
><blockquote class="screen"><pre class="screen">netacl-telnetd: permit-hosts 172.16.1.2 -exec /usr/libexec/telnetd</PRE
></BLOCKQUOTE
><a class="indexterm" name="AUTOID-3636"></A
><a class="indexterm" name="AUTOID-3637"></A
><a class="indexterm" name="AUTOID-3638"></A
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-3639">5.8.4 Reconfiguring for Production</A
></H3
><p class="para"><a class="indexterm" name="CH05CONFMACH"></A
><a class="indexterm" name="CH05MACHCONF"></A
><a class="indexterm" name="CH05INSTSOFT"></A
><a class="indexterm" name="CH05SOFTINST"></A
>Now it's time to move the machine from the configuration that was useful
to you when you were building it to the best configuration for running
it. You'll need to do several things:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Reconfigure and rebuild the kernel.</P
></LI
><li class="listitem"><p class="para">Remove all unnecessary programs.</P
></LI
><li class="listitem"><p class="para">Mount as many filesystems as possible to read-only.</P
></LI
></UL
><p class="para">Once you've deleted all the services that aren't used on a day-to-day
basis, you'll find that it is very difficult to work on the bastion
host, e.g., when you need to install new software packages or upgrade
existing ones. Here are some suggestions for what to do when you find
it necessary to do extensive work on the bastion host:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Write all the tools to a tape before deleting them, and then restore
them from tape when needed. Don't forget to delete them each time
after you're done.</P
></LI
><li class="listitem"><p class="para">Set up a small, external, alternate boot disk with all the tools on
it. Then, plug the disk in and boot from it when you need the
tools. Don't leave the disk connected during routine operations,
however; you don't want an attacker to be able to mount the disk and
use the tools against you.</P
></LI
></UL
><p class="para">You don't want an intruder to attack the machine while you're
working on it. To keep that from happening, follow these steps:</P
><ol class="orderedlist"><li class="listitem"><p class="para">Either disconnect the bastion host from the network or disconnect your
network from the Internet before you begin. </P
></LI
><li class="listitem"><p class="para">Give the bastion host back the tools you'll need to use (as we've
described above). </P
></LI
><li class="listitem"><p class="para">After you've finished your work on the machine, return it to its
normal (stripped down) operating condition.</P
></LI
><li class="listitem"><p class="para">Reconnect the bastion host to the network or your network to the
Internet.</P
></LI
></OL
><p class="para">You may find it easier to simply remove the bastion host's disk and
attach it to an internal host as a nonsystem disk; you can then use the
internal host's tools without fear of having them remain available when
the bastion host is returned to service. This procedure also guarantees
that the bastion host is not vulnerable to compromise from the outside
while you are doing the work, since it is entirely nonfunctional while
its disk is removed and not susceptible to accidental reconnection.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3678">5.8.4.1 Reconfigure and rebuild the kernel</A
></H4
><p class="para"><a class="indexterm" name="CH05INSTKERN"></A
><a class="indexterm" name="CH05KERNREC"></A
><a class="indexterm" name="CH05CONFIGKERN"></A
>The first step in this phase of building your bastion host is to
rebuild the operating system kernel to remove kernel capabilities 
you don't need. This may sound intimidating, but it's generally a
relatively straightforward operation; it needs to be, because you'll
be using the same capabilities you'd use to install a new type of
device on your system. Every <span class="acronym">UNIX</SPAN
> system, as
shipped, contains some form of configuration support (they range
considerably in how kernel reconfiguration is supported and in what
you can do). Besides reducing the size of your kernel (and thereby
making more memory available for other purposes), rebuilding the
kernel denies to attackers the chance to exploit these capabilities.</P
><p class="para">Some capabilities are particularly dangerous. In particular, you should
probably remove the following capabilities or device drivers:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><span class="acronym">NFS</SPAN
> and related capabilities</P
></LI
><li class="listitem"><p class="para">Anything that enables network sniffing, e.g., Network Interface Tap
(<span class="acronym">NIT</SPAN
>) or Berkeley Packet Filter
(<span class="acronym">BPF</SPAN
>)</P
></LI
></UL
><p class="para">Although <span class="acronym">NIT</SPAN
> and <span class="acronym">BPF</SPAN
> are
provided for testing and debugging purposes, they are frequently used
by attackers. <span class="acronym">NIT</SPAN
> and <span class="acronym">BPF</SPAN
> are
dangerous because they let the machine grab all packets off the
Ethernet it's attached to, instead of only the packets addressed to
it. Disabling these capabilities may prevent you from using the
machine as a packet filtering system, so you may not be able to delete
them in all architectures.</P
><p class="para">If your bastion host is a dual-homed host, this is the time to disable
<span class="acronym">IP</SPAN
> forwarding.</P
><p class="para">You have to be more careful when you disable kernel capabilities than
when you disable services started by <em class="emphasis">inetd</EM
> or at
boot time from the <em class="emphasis">/etc/rc</EM
> files (as described
earlier). There are a lot of interdependencies between kernel
capabilities. For this reason, it's sometimes hard to determine
exactly what a given capability is used for. The consequences of
disabling a capability that is actually needed can be severe, e.g.,
the new kernel might not boot.</P
><p class="para">Make sure you follow your vendor's instructions for building and
installing new kernels. Always keep a backup copy of your old kernel.
If you have a backup, you can boot from it if you find out that
something is wrong with the new kernel. Be sure you know how to boot a
backup kernel and look up the procedure before you try to boot onto
the new kernel. Be sure the backup kernel is in the root partition;
you can't boot from a kernel that isn't on the root partition.</P
><p class="para">When you can reboot the machine, go through the kernel configuration
files the same way you went through the startup files, checking every
single line to make certain that it's something you want. Again, watch
for places where one configuration file contains another, and check
your documentation to be sure that you've looked at all the
configuration files that are consulted. Often there is one file for
including device drivers and one or more for parameters;
<span class="acronym">IP</SPAN
> forwarding will be in the latter.</P
><p class="para">Once you've got a working kernel, you'll probably want to delete or
encrypt your old &quot;full function&quot; kernel. Replace it with a
backup copy of the working minimal kernel. Doing so will keep a
cracker who somehow manages to break into your machine from simply
using that old kernel to reboot, and thereby restore all of the
services you so carefully disabled. For similar reasons, you'll
probably also want to delete the files and programs needed to build a
new kernel.</P
><p class="para">If your kernel uses loadable modules, it may be difficult to determine
when they're used. You will want to delete or encrypt all the ones
that you don't want used, but because they're not always explicitly
loaded, you may not know which those are. Keeping an alternate boot
medium handy, try moving them out of the directory for loadable
modules. Run the machine through its paces before you finally remove
or encrypt them.</P
><p class="para">Beware! Your vendor may have provided copies of &quot;generic&quot;
kernels (which typically have every possible capability enabled) in
unexpected locations for use during the installation of the machine
and its (nonexistent) client machines. SunOS 4.x, for example, has
such kernels in the <em class="emphasis">/usr/stand</EM
> directory. Poke
around in all the directories where installation files are kept and
all the directories for clients. The documentation generally tells
you where client kernels are, but rarely tells you about the internals
of the install process. Check the documentation for disaster recovery
advice, which may helpfully tell you where to locate spare kernel
images.<a class="indexterm" name="AUTOID-3716"></A
><a class="indexterm" name="AUTOID-3717"></A
><a class="indexterm" name="AUTOID-3718"></A
></P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3719">5.8.4.2 Remove nonessential programs</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-3722"></A
>The next step is to remove all of the programs that aren't essential
for day-to-day operation. If a program isn't there, an attacker can't
exploit any bugs that it might contain. This is especially true for
<em class="emphasis">setuid/setgid</EM
> programs, which are a very tempting
target for an attacker. You should remove programs you normally think
of as being essential. Remember that the bastion host is purely
providing Internet services; it does not need to be a comfortable
environment to work in.</P
><p class="para">Window systems and compilers are examples of major programs you can
get rid of. Attackers find these programs very useful: window systems
are fertile ground for security problems, and compilers can be used to
build the attacker's own tools.</P
><p class="para">Before deleting programs like compilers, make sure you've finished
using them yourself; make sure you've built, installed, and tested
everything you're going to need on this machine, such as the tools for
auditing the system (discussed later in this chapter).</P
><p class="para">Instead of simply deleting key tools you'd expect an attacker to use,
such as the compiler, you might want to replace them with programs
that raise an alarm (for example, sending email or tripping your
pager) when someone tries to run them. You might even want to have the
programs halt the system after raising the alarm, if you believe it's
better for the machine to be down than under attack.  This is a prime
way to humiliate yourself, however; you yourself are probably the one
person most likely to forget where you are to try to run a forbidden
command. It's also a good way to set yourself up for denial of service
attacks.</P
><p class="para">You'll want to do two scans looking for things to delete:

<ol class="orderedlist"><li class="listitem"><p class="para">Walk through all the standard directories for binaries on your system
(everything that's in root's path or in the default user path). If
you're unsure whether a program is needed, turn off execute permission
on it for a while (a few days) before you remove or encrypt it and see
what happens. You may also want to run the machine for a while before
you do the scan and check the access times on files to see if they've
been used.</P
></LI
><li class="listitem"><p class="para">Use <em class="emphasis">find</EM
> to look for every file on the system
that has the <em class="emphasis">setuid</EM
> or
<em class="emphasis">setgid</EM
> bit turned on. The arguments to
<em class="emphasis">find</EM
> differ radically from system to system, but
you will probably want something like this:

<blockquote class="screen"><pre class="screen">find / -type f \( -perm -04000 -o -perm -02000 \) -ls</PRE
></BLOCKQUOTE
>&#13;</P
></LI
><li class="listitem"><p class="para">Some versions of <em class="emphasis">find</EM
> provide special primitives
for identifying <em class="emphasis">setuid</EM
> and
<em class="emphasis">setgid</EM
> files.</P
></LI
></OL
></P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3744">5.8.4.3 Mount filesystems as read-only</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-3747"></A
><a class="indexterm" name="AUTOID-3749"></A
><a class="indexterm" name="AUTOID-3752"></A
><a class="indexterm" name="AUTOID-3754"></A
>Once you've got the bastion host configured, you don't want anybody
(particularly an attacker) to be able to change the configuration. To
guard against this happening, mount the filesystems on the bastion
host as read-only if possible (particularly the filesystems that
contain program binaries) to protect against tampering.</P
><p class="para">It's much better if you can use hardware write-protect; an attacker
may be able to remount disks with write permission without getting
physical access to the machine, but it's not going to do any good if
the hardware write-protect on the disk is on. Most
<span class="acronym">IPI</SPAN
> and <span class="acronym">SMD</SPAN
> disks have switches
for this on their front panels. Many <span class="acronym">SCSI</SPAN
> disks
have a &quot;write-disable&quot; jumper you can set. If you find
powering the disk down and removing it from the case unacceptable as a
way to get write access, you could wire this jumper to an external
switch on the drive enclosure.</P
><p class="para">You can't write-protect everything, of course.  You have to provide a
certain amount of writable filesystem space for things like scratch
space, system logs, and the mail spool. You might be able to use a
<span class="acronym">RAM</SPAN
> disk for this; however, you'll have to be sure
that your operating system supports this, that you have enough
<span class="acronym">RAM</SPAN
>, and that you think you can afford to lose the
contents of the <span class="acronym">RAM</SPAN
> disk (for example, electronic
mail in transit between internal hosts and the Internet) whenever your
machine reboots.</P
><p class="para">With most versions of <span class="acronym">UNIX</SPAN
>, you'll also have to
either provide writable disk space for memory swapping or turn off
swapping. Many versions of <span class="acronym">UNIX</SPAN
> do not allow you to
turn off swapping; however, they will usually allow you to use a
separate disk for swap space, and that disk can safely be left
writable. Using a <span class="acronym">RAM</SPAN
> disk will increase your
memory usage to the point where you will probably need swap space.</P
><p class="para"><a class="indexterm" name="AUTOID-3770"></A
>Systems based on <span class="acronym">BSD</SPAN
> 4.4-Lite (for instance,
current releases of Net<span class="acronym">BSD</SPAN
>, FreeBSD, and the
<span class="acronym">BSDI</SPAN
> product) have a new immutable attribute that
can be set on a per-file basis. If a file is marked
&quot;immutable,&quot; the file cannot be changed, not even by root,
unless the system is running in single-user mode. If your operating
system provides this capability, use it to protect your programs and
configuration files from tampering by an attacker. (We recommend that
approach only if you cannot use hardware write protection, or an
additional layer of security to use with hardware write
protection. Because it's implemented in software, it is more likely to
be compromisable.)<a class="indexterm" name="AUTOID-3775"></A
><a class="indexterm" name="AUTOID-3776"></A
><a class="indexterm" name="AUTOID-3777"></A
><a class="indexterm" name="AUTOID-3778"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-3779">5.8.5 Running a Security Audit</A
></H3
><p class="para"><a class="indexterm" name="CH05SECAUDIT"></A
><a class="indexterm" name="CH05AUDITSEC"></A
>Once you've got the bastion host reconfigured, the next step is to run a
security audit. There are two reasons for doing this. First, it gives
you a way to ensure you haven't overlooked anything during system
setup. Second, it establishes a &quot;baseline,&quot; or a basis for
comparison, against which you can compare future audits. In this way,
you'll be able to detect any tampering with the machine.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3787">5.8.5.1 Auditing packages</A
></H4
><p class="para"><a class="indexterm" name="CH05PACKAUDIT"></A
><a class="indexterm" name="CH05AUDITPACK"></A
>Most auditing packages have two basic purposes:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Checking for well-known security holes. These are holes that have been
uncovered by system administrators, exploited by attackers in system
break-ins, or documented in computer security books and papers.</P
></LI
><li class="listitem"><p class="para">Establishing a database of checksums of all files on a system; doing
this allows a system administrator to recognize future changes to
files&nbsp;- particularly unauthorized changes.</P
></LI
></UL
><p class="para">There are several very good automated auditing packages freely
available on the Internet. The three most commonly used are these:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3804"></A
><em class="emphasis">COPS</EM
>&nbsp;- The Computer Oracle and Password
System, developed by Dan Farmer and Gene Spafford</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3810"></A
><em class="emphasis">Tiger</EM
>&nbsp;- Developed as part of the <span class="acronym">TAMU</SPAN
>
package by Texas A&amp;M University</P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-3816"></A
><a class="indexterm" name="AUTOID-3818"></A
><em class="emphasis">Tripwire</EM
>&nbsp;- Developed by Gene H. Kim and
Gene Spafford </P
></LI
></UL
><p class="para"><span class="acronym">COPS</SPAN
> and Tiger both check for well-known security
holes. There is significant overlap in what <span class="acronym">COPS</SPAN
>
and Tiger check; however, they're both free, so it's a good idea to
obtain and run both of them to get the best possible
coverage. Tripwire is a filesystem integrity checker. It is strictly
a tool for dealing with checksum databases; it is much better at this
than either <span class="acronym">COPS</SPAN
> or Tiger (which both have basic
checksum database capabilities), but has no ability to check for
well-known security holes. These packages are independent of each
other; there's nothing to prevent you from using all three of them in
combination on your bastion host, and that would probably be a good
idea. <a class="xref" href="appb_01.htm" title="Tools">Appendix B</A
> gives you information on how to get
all three packages.</P
><p class="para">Because the well-known security holes tend to be somewhat operating
system-specific, the effectiveness of the packages that check for these
security holes is very dependent on which operating system you have, and
which version of the operating system it is. If it's an operating
system and version the package knows about, that's great. If it
isn't, then the package has to grope around blindly, trying to guess
what holes might exist. (Fortunately, attackers will usually have the
same problem, if not to the same extent.)</P
><p class="para">Commercial packages that perform similar functions are starting to
become available, but none yet have the complete capabilities and
widespread acceptance of <span class="acronym">COPS</SPAN
>, Tiger, and Tripwire.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3830">5.8.5.2 Use the auditing packages</A
></H4
><p class="para">How do you use the various auditing packages to audit your system? The
details of what you do depend upon which package you're using. (See the
documentation provided with the packages for detailed instructions.) 
This section provides some general tips.</P
><p class="para"><a class="indexterm" name="AUTOID-3834"></A
><a class="indexterm" name="AUTOID-3837"></A
>You will need to do some configuration. Don't just install the
program, run it, and expect you'll get reasonable results. Expect to
go through several iterations of running the auditing package, getting
warnings, and reconfiguring your machine or the auditing package to
get rid of warnings. When you get warnings, you have to decide whether
the auditing package is wrong, or you are. There will be some cases
where the right thing to do is to turn off checks, but it shouldn't be
your automatic response.</P
><p class="para">Once you've used the tools described in the previous section to create
your initial baseline, store a copy of the tools and these initial
audit results somewhere safe. Under no circumstances should you store
the only copy of the baseline or the tools on the bastion
host. Prepare for the worst: if someone were to break into the bastion
host and tamper with the only copy of the baseline audit, this would
compromise your ability to use the audit later on to detect illicit
changes on the system. If intruders can change the auditing software,
it doesn't matter whether they can change the baseline; they could
simply set up the auditing software to reproduce the baseline. Keeping
a copy of the baseline audit on a floppy disk or magnetic tape that's
locked up someplace safe is a good way to protect against such a
compromise. Preferably, you don't want an intruder to even read the
audit results; why tell them what you expect the system to look like
and what files you aren't watching?</P
><p class="para">Periodically, e.g., daily or weekly, depending on your own
site's needs and capabilities, audit the machine once again and
compare the new audit to the baseline. Make sure you can account for
any differences you find. Ideally, you should automate this periodic
re-audit so it happens regularly and reliably. Unfortunately, this is
easier said than done. Arranging for automatic audits that can't be
defeated by &quot;replay&quot; attacks can be a neat trick.  In a
replay attack, an attacker who has compromised your auditing system
simply sends you a recording of a prior good audit whenever your
system invokes the automatic auditing capability. The most practical
defense against this is to run your automated auditing system often
enough that it's unlikely an attacker could break in, discover the
auditing system, and subvert it (covering his tracks) before the next
audit runs. This suggests that you should run an audit at least daily.<a class="indexterm" name="AUTOID-3843"></A
><a class="indexterm" name="AUTOID-3844"></A
></P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-3845">5.8.5.3 About checksums for auditing</A
></H4
><p class="para"><a class="indexterm" name="CH05AUDSECCHECK"></A
><a class="indexterm" name="CH05CHECK"></A
>Checksums are very helpful in auditing. An intruder who changes a
program or configuration file will almost certainly correct the
modification dates afterwards, so you can't use these dates as a
reliable index. Comparing every file to a baseline copy avoids that
problem, but takes a lot of time and requires that you store a copy of
every single file, effectively doubling your storage requirements.
Checksums are probably your best bet.</P
><p class="para">A checksum is a number calculated from the contents of the file that
will change if the file is changed. Checksum calculation is
time-consuming, but not as time-consuming as reading everything twice
to do a bit-by-bit compare. In addition, storing the checksums takes
up much less space than storing the entire file. Checksums are not
full representations of the file, however, and every checksum
algorithm has cases where it will give the same checksum for two
different files. The better the checksum algorithm, the less likely it
is that files with the same checksum resemble each other in any other
way.</P
><p class="para"><a class="indexterm" name="AUTOID-3855"></A
>For example, the common <span class="acronym">UNIX</SPAN
>
<em class="emphasis">spell</EM
> command uses a hashing algorithm that
shares this property with checksums.  <em class="emphasis">spell </EM
>will
relatively reliably detect misspelled English words, but will often
happily accept complete garbage, because random character strings may
happen to have the same hashes as good words. This represents a
problem only if you are likely to type &quot;qzx&quot; when you meant to type
&quot;the&quot;. Similarly, a good checksum algorithm may come up with the same
number for <em class="emphasis">/bin/login</EM
> and a document containing
the text of &quot;Jabberwocky,&quot; but it won't come up with the
same number for <em class="emphasis">/bin/login</EM
> and any other
executable capable of logging people in (especially a modified copy of
<em class="emphasis">/bin/login</EM
>).</P
><p class="para"><a class="indexterm" name="AUTOID-3864"></A
><a class="indexterm" name="AUTOID-3867"></A
><a class="indexterm" name="AUTOID-3869"></A
>However, the standard <span class="acronym">UNIX</SPAN
> checksum programs
(<em class="emphasis">/bin/sum</EM
>, for example) don't have this property.
Those checksum programs use simple cyclic redundancy counter
(<span class="acronym">CRC</SPAN
>) algorithms designed to catch bit errors
during data transfers.  They can't keep up with the latest tools
crackers use to subvert traditional checksum programs. Crackers now
have programs that manipulate the unused bytes in a file (particularly
an executable binary file) to make the checksum for that file come out
to whatever they want it to be. They can make a modified copy of
<em class="emphasis">/bin/login</EM
> that produces the same checksum, and
<em class="emphasis">sum</EM
> will not be able to detect any difference</P
><p class="para"><a class="indexterm" name="AUTOID-3877"></A
>For real security, you need to use a &quot;cryptographic&quot;
checksum algorithm like MD5 or Snefru; these algorithms produce larger
and less predictable checksums that are much more difficult to spoof.
The <span class="acronym">COPS</SPAN
>, Tiger, and Tripwire auditing packages
described above all include and use such algorithms in place of the
normal <span class="acronym">UNIX</SPAN
> checksum programs.<a class="indexterm" name="AUTOID-3881"></A
><a class="indexterm" name="AUTOID-3882"></A
><a class="indexterm" name="AUTOID-3883"></A
><a class="indexterm" name="AUTOID-3884"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-3885">5.8.6 Connecting the Machine</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-3888"></A
>Now that you have the machine fully secured, you can finally connect it
to its destination network and run it. You want to do this when you're
going to be around to see what happens; don't make it the last thing you
do before that long overdue vacation.</P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_07.htm" title="5.7 Don't Allow User Accounts on the Bastion Host"><img src="../gifs/txtpreva.gif" alt="Previous: 5.7 Don't Allow User Accounts on the Bastion Host" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Building Internet Firewalls"><img src="../gifs/txthome.gif" alt="Building Internet Firewalls" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch05_09.htm" title="5.9 Operating the Bastion Host "><img src="../gifs/txtnexta.gif" alt="Next: 5.9 Operating the Bastion Host " border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">5.7 Don't Allow User Accounts on the Bastion Host</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_a.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">5.9 Operating the Bastion Host </TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="../puis/index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
