<html><head>
<title>[Chapter 6] 6.3 What Does a Packet Look Like?</TITLE>
<meta name="DC.title" content="Building Internet Firewalls"><meta name="DC.creator" content="D. Brent Chapman &amp; Elizabeth D. Zwicky"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T00:16:21Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-124-0" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch06_01.htm" title="6. Packet Filtering"><link rel="prev" href="ch06_02.htm" title="6.2 Configuring a Packet Filtering Router"><link rel="next" href="ch06_04.htm#FIRE-06-S2-14" title="6.4 What Does the Router Do with Packets?"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="Building Internet Firewalls" usemap="#srchmap" border="0"></H1
><map name="sindex.htmlrchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="Building Internet Firewalls"><area shape="RECT" coords="467,0,514,18" href="../search/fsrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch06_02.htm" title="6.2 Configuring a Packet Filtering Router"><img src="../gifs/txtpreva.gif" alt="Previous: 6.2 Configuring a Packet Filtering Router" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 6<br>Packet Filtering</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch06_04.htm#FIRE-06-S2-14" title="6.4 What Does the Router Do with Packets?"><img src="../gifs/txtnexta.gif" alt="Next: 6.4 What Does the Router Do with Packets?" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="FIRE-06-S1-3">6.3 What Does a Packet Look Like?</A
></H2
><p class="para"><a class="indexterm" name="CH06PACKSTRUCT"></A
>To understand packet filtering, you first have to understand packets
and how they are handled at each layer of the
<span class="acronym">TCP/IP</SPAN
> protocol stack:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">Application layer (e.g., <span class="acronym">FTP</SPAN
>, Telnet,
<span class="acronym">HTTP</SPAN
>)</P
></LI
><li class="listitem"><p class="para">Transport layer (<span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
>)</P
></LI
><li class="listitem"><p class="para">Internet layer (<span class="acronym">IP</SPAN
>)</P
></LI
><li class="listitem"><p class="para">Network access layer (e.g., Ethernet, <span class="acronym">FDDI</SPAN
>,
<span class="acronym">ATM</SPAN
>)</P
></LI
></UL
><p class="para">Packets are constructed in such a way that layers for each protocol
used for a particular connection are wrapped around the packets, like
the layers of skin on an onion.</P
><p class="para"><a class="indexterm" name="AUTOID-4282"></A
><a class="indexterm" name="AUTOID-4284"></A
>At each layer, a packet has two parts: the header and the body. The
header contains protocol information relevant to that layer, while the
body contains the data for that layer which often consists of a whole
packet from the next layer in the stack. Each layer treats the
information it gets from the layer above it as data, and applies its
own header to this data. At each layer, the packet contains all of the
information passed from the higher layer; nothing is lost. This
process of preserving the data while attaching a new header is known
as<em class="emphasis"> encapsulation</EM
>.<a class="indexterm" name="AUTOID-4288"></A
></P
><p class="para">At the application layer, the packet consists simply of the data to be
transferred (for example, part of a file being transferred during an
<span class="acronym">FTP</SPAN
> session). As it moves to the transport layer,
the Transmission Control Protocol (<span class="acronym">TCP</SPAN
>) or the User
Datagram Protocol (<span class="acronym">UDP</SPAN
>) preserves the data from the
previous layer and attaches a header to it. At the next layer,
<span class="acronym">IP</SPAN
> considers the entire packet (consisting now of
the <span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
> header and the
data) to be data, and now attaches its own <span class="acronym">IP</SPAN
>
header. Finally, at the network access layer, Ethernet or another
network protocol considers the entire <span class="acronym">IP</SPAN
> packet
passed to it to be data, and attaches its own header. <a class="xref" href="#FIRE-06-FIG-2" title="Data encapsulation">Figure 6.2</A
> shows how this works.</P
><h4 class="figure"><a class="title" name="FIRE-06-FIG-2">Figure 6.2: Data encapsulation</A
></H4
><img class="graphic" src="figs/fire0602.gif" alt="Figure 6.2"><p class="para">At the other side of the connection, this process is reversed. As the
data is passed up from one layer to the next higher layer, each header
(each skin of the onion) is stripped off by its respective layer. For
example, the Internet layer removes the <span class="acronym">IP</SPAN
> header
before passing the encapsulated data up to the transport layer
(<span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
>).</P
><p class="para">In trying to understand packet filtering, the most important
information from our point of view is in the headers of the various
layers. The sections below look at several examples of different types
of packets and show the contents of each of the headers that packet
filtering routers will be examining. We assume a certain knowledge of
<span class="acronym">TCP</SPAN
>/<span class="acronym">IP</SPAN
> fundamentals, and
concentrate on discussing the particular issues related to packet
filtering. For a detailed introduction to <span class="acronym">TCP/IP</SPAN
>,
see <a class="xref" href="appc_01.htm" title="TCP/IP Fundamentals">Appendix C</A
>.</P
><p class="para">In the discussion below, we start with a simple example demonstrating
<span class="acronym">TCP/IP</SPAN
> over Ethernet. From there, we go on to
discuss <span class="acronym">IP</SPAN
>'s packet filtering characteristics, then
protocols above <span class="acronym">IP</SPAN
> (such as <span class="acronym">TCP</SPAN
>,
<span class="acronym">UDP</SPAN
>, <span class="acronym">ICMP</SPAN
>, and
<span class="acronym">RPC</SPAN
>), protocols below <span class="acronym">IP</SPAN
> (such
as Ethernet), and finally non-<span class="acronym">IP</SPAN
> protocols (such as
AppleTalk or <span class="acronym">IPX</SPAN
>).</P
><div class="sect2"><h3 class="sect2"><a class="title" name="FIRE-06-S2-6">6.3.1 <span class="acronym">TCP/IP</SPAN
>/Ethernet
Example</A
></H3
><p class="para"><a class="indexterm" name="CH06TCPIPPACKET"></A
>Let's consider an example of a <span class="acronym">TCP/IP</SPAN
> packet (for
example, one that is part of a Telnet connection) on an
Ethernet. There are four layers that we're interested in here: the
Ethernet layer, the <span class="acronym">IP</SPAN
> layer, the
<span class="acronym">TCP</SPAN
> layer, and the data layer. In this section,
we'll consider them from bottom to top and look at the contents of the
headers that the packet filtering routers will be examining.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-1">6.3.1.1 Ethernet layer</A
></H4
><a class="indexterm" name="AUTOID-4335"></A
><p class="para">At the Ethernet layer, the packet consists of two parts: the Ethernet
header and the Ethernet body. In general, you won't be able to do
packet filtering based on information in the Ethernet header. 
Basically, the header tells you:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">What kind of packet this is</EM
>&nbsp;- we'll assume in this
example that it is an <span class="acronym">IP</SPAN
> packet, as opposed to an
AppleTalk packet, a Novell packet, a <span class="acronym">DECNET</SPAN
> packet,
or some other kind of packet.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">The Ethernet address of the machine that put the packet onto
this particular Ethernet network segment</EM
>&nbsp;- the original
source machine, if it's attached to this segment; otherwise, the last
router in the path from the source machine to here.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">The Ethernet address of the packet's destination on this
particular Ethernet network segment</EM
>&nbsp;- perhaps the
destination machine, if it's attached to this segment; otherwise, the
next router in the path from here to the destination machine.</P
></LI
></UL
><p class="para">Because we are considering <span class="acronym">IP</SPAN
> packets in this
example, we know that the Ethernet body contains an
<span class="acronym">IP</SPAN
> packet.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-2">6.3.1.2 <span class="acronym">IP</SPAN
> layer</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-4357"></A
>At the <span class="acronym">IP</SPAN
> layer, the <span class="acronym">IP</SPAN
> packet
is made up of two parts: the <span class="acronym">IP</SPAN
> header and the
<span class="acronym">IP</SPAN
> body, as shown in <a class="xref" href="#FIRE-06-FIG-3" title="IP header and body">Figure 6.3</A
>.
From a packet filtering point of view, the
<span class="acronym">IP</SPAN
> header contains four interesting pieces of
information:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">The <span class="acronym">IP</SPAN
> source address</EM
>&nbsp;- four
bytes long, and typically written as something like
172.16.244.34.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">The <span class="acronym">IP</SPAN
> destination
address</EM
>&nbsp;- just like the <span class="acronym">IP</SPAN
> source
address.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">The <span class="acronym">IP</SPAN
> protocol
type</EM
>&nbsp;- identifies the <span class="acronym">IP</SPAN
> body as a
<span class="acronym">TCP</SPAN
> packet, as opposed to a <span class="acronym">UDP</SPAN
>
packet, an Internet Control Message Protocol (<span class="acronym">ICMP</SPAN
>)
packet, or some other type of packet.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">The <span class="acronym">IP</SPAN
> options field</EM
>&nbsp;- which is
almost always empty, but which is where options like the
<span class="acronym">IP</SPAN
> source route and the <span class="acronym">IP</SPAN
>
security options would be specified if they were used for a given
packet. (See the discussion in &quot;<span class="acronym">IP</SPAN
>
options&quot; below.)</P
></LI
></UL
><p class="para"><a class="indexterm" name="AUTOID-4392"></A
><a class="indexterm" name="AUTOID-4395"></A
><span class="acronym">IP</SPAN
> may divide up a packet that is too large to
cross a given network into a series of smaller packets called
<em class="emphasis">fragments</EM
>. Fragmenting a packet doesn't change
its structure at the <span class="acronym">IP</SPAN
> layer (the
<span class="acronym">IP</SPAN
> headers are duplicated into each fragment), but
it may mean that the body contains only a part of a packet at the next
layer. (See the discussion in &quot;<span class="acronym">IP</SPAN
>
fragmentation&quot; below.)</P
><h4 class="figure"><a class="title" name="FIRE-06-FIG-3">Figure 6.3: <span class="acronym">IP</SPAN
> header and body</A
></H4
><img class="graphic" src="figs/fire0603.gif" alt="Figure 6.3"><p class="para">The <span class="acronym">IP</SPAN
> body in this example contains an
unfragmented <span class="acronym">TCP</SPAN
> packet, although it could just as
well contain the first fragment of a fragmented <span class="acronym">TCP</SPAN
>
packet.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-3">6.3.1.3 <span class="acronym">TCP</SPAN
> layer</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-4414"></A
>At the <span class="acronym">TCP</SPAN
> layer, the packet again contains two
parts: the <span class="acronym">TCP</SPAN
> header and the
<span class="acronym">TCP</SPAN
> body. (<a class="xref" href="appc_06.htm#FIRE-C-S2-7" title="TCP segment format">Figure 13.12</A
> in Appendix C shows
the format of the <span class="acronym">TCP</SPAN
> header and body.)
From a packet filtering point of view, the <span class="acronym">TCP</SPAN
>
header contains three interesting pieces of information:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">The <span class="acronym">TCP</SPAN
> source port</EM
>&nbsp;- a
two-byte number, which specifies what client or server process the
packet is coming from on the source machine</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">The <span class="acronym">TCP</SPAN
> destination port</EM
>&nbsp;- just
like the <span class="acronym">TCP</SPAN
> source port</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">The <span class="acronym">TCP</SPAN
> flags field</EM
></P
></LI
></UL
><p class="para"><a class="indexterm" name="AUTOID-4438"></A
>The <span class="acronym">TCP</SPAN
> flags field contains one bit of interest
for packet filtering: the <span class="acronym">ACK</SPAN
> bit. By examining the
<span class="acronym">ACK</SPAN
> bit, a packet filtering router can determine
whether a given packet is the first packet initiating a
<span class="acronym">TCP</SPAN
> connection (if the <span class="acronym">ACK</SPAN
> bit
is not set) or is a subsequent packet (if the <span class="acronym">ACK</SPAN
>
bit is set). The <span class="acronym">ACK</SPAN
> bit is part of the
<span class="acronym">TCP</SPAN
> mechanism that guarantees delivery of the
data. The <span class="acronym">ACK</SPAN
> bit is set whenever one side of a
connection has received data from the other side (it acknowledges the
received data). Therefore, the <span class="acronym">ACK</SPAN
> bit is set on
all packets going in either direction except the very first packet
from the client to the server.</P
><p class="para">The <span class="acronym">TCP</SPAN
> body contains the actual &quot;data&quot;
being transmitted&nbsp;- e.g., for Telnet the keystrokes or screen
displays that are part of a Telnet session, or for
<span class="acronym">FTP</SPAN
> the data being transferred or commands being
issued as part of an <span class="acronym">FTP</SPAN
> session.<a class="indexterm" name="AUTOID-4454"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="FIRE-06-S2-7">6.3.2 <span class="acronym">IP</SPAN
></A
></H3
><p class="para"><a class="indexterm" name="CH06IP"></A
><span class="acronym">IP</SPAN
> serves as a common middle ground for the
Internet. It can have many different layers below it, such as
Ethernet, token ring, <span class="acronym">FDDI</SPAN
>, <span class="acronym">PPP</SPAN
>,
or carrier pigeon.[2] <span class="acronym">IP</SPAN
> can have many other protocols
layered on top of it, with <span class="acronym">TCP</SPAN
>,
<span class="acronym">UDP</SPAN
>, and <span class="acronym">ICMP</SPAN
> being by far the
most common, at least outside of research environments. In this
section, we discuss the special characteristics of
<span class="acronym">IP</SPAN
> relevant to packet filtering.</P
><blockquote class="footnote"><p class="para">[2] See RFC1149, dated 1 April 1990, which defines the Avian Transport
Protocol; <span class="acronym">RFC</SPAN
>s dated 1 April are usually worth
reading.</P
></BLOCKQUOTE
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-4">6.3.2.1 <span class="acronym">IP</SPAN
> options</A
></H4
><p class="para">As we saw in the discussion of the <span class="acronym">IP</SPAN
> layer above,
<span class="acronym">IP</SPAN
> headers include an options field,
which is usually empty. In its design, the <span class="acronym">IP</SPAN
>
options field was intended as a place for special information or
handling instructions that didn't have a specific field of their own
in the header. However, <span class="acronym">TCP/IP</SPAN
>'s designers did such
a good job of providing fields for everything necessary that the
options field is almost always empty. In practice,
<span class="acronym">IP</SPAN
> options are very seldom used except for break-in
attempts and (very rarely) for network debugging.</P
><p class="para"><a class="indexterm" name="AUTOID-4482"></A
><a class="indexterm" name="AUTOID-4485"></A
>The most common <span class="acronym">IP</SPAN
> option a firewall would be
confronted with is the <span class="acronym">IP</SPAN
> source
route option. Source routing lets the source of a packet
specify the route the packet is supposed to take to its destination,
rather than letting each router along the way use its routing tables
to decide where to send the packet next. Source routing is supposed
to override the instructions in the routing tables. In theory, the
source routing option is useful for working around routers with broken
or incorrect routing tables; if you know the route that the packet
should take, but the routing tables are broken, you can override the
bad information in the routing tables by specifying appropriate
<span class="acronym">IP</SPAN
> source route options on all your packets. In
practice though, source routing is commonly used only by attackers who
are attempting to circumvent security measures by causing packets to
follow unexpected paths.</P
><p class="para">Many packet filtering systems take the approach of dropping any packet
that has any <span class="acronym">IP</SPAN
> option set, without even trying to
figure out what the option is or what it means; in general, this seems
to work well, without causing any special problems.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-5">6.3.2.2 <span class="acronym">IP</SPAN
> fragmentation</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-4496"></A
><a class="indexterm" name="AUTOID-4499"></A
><a class="indexterm" name="AUTOID-4501"></A
>Another <span class="acronym">IP</SPAN
>-level consideration for packet filtering
is fragmentation. One of the features of <span class="acronym">IP</SPAN
> is its
ability to divide a large packet that otherwise couldn't traverse some
network link (because of limitations on packet size along that link)
into smaller packets, called <em class="emphasis">fragments</EM
>, which can
traverse that link. The fragments are then reassembled into the full
packet by the destination machine (not by the machine at the other end
of the limited link; once a packet is fragmented, it stays fragmented
until it reaches its destination).</P
><p class="para"><span class="acronym">IP</SPAN
> fragmentation is illustrated in <a class="xref" href="#FIRE-06-FIG-4" title="Data fragmentation">Figure 6.4</A
>.</P
><h4 class="figure"><a class="title" name="FIRE-06-FIG-4">Figure 6.4: Data fragmentation</A
></H4
><img class="graphic" src="figs/fire0604.gif" alt="Figure 6.4"><p class="para">From a packet filtering point of view, the problem with fragmentation
is that only the first fragment will contain the header information
from higher-level protocols, like <span class="acronym">TCP</SPAN
>, that the packet
filtering system needs in order to decide whether or not to allow the
full packet. The common packet filtering approach to dealing with
fragmentation is to allow any nonfirst fragments through, and to do
packet filtering only on the first fragment of a packet. This is safe
because, if the packet filtering decides to drop the first fragment,
the destination system will not be able to reassemble the rest of the
fragments into the original packet, regardless of how many of the rest
of the fragments it receives. If it can't reconstruct the original
packet, the partially reassembled packet will not be accepted.</P
><p class="para">The destination host will hold the fragments in memory for a while,
waiting to see if it gets the missing piece; this makes it possible
for attackers to use fragmented packets in a denial of service
attack. When the destination host gives up on reassembling the packet,
it will send an <span class="acronym">ICMP</SPAN
> &quot;packet reassembly time
expired&quot; message back to the source host, which will tell an
attacker that the host exists, and why the connection didn't
succeed. There is nothing to be done about such denial of
service attacks, but you can filter out the <span class="acronym">ICMP</SPAN
>
messages.</P
><p class="para">Outbound fragments could conceivably contain data you don't want to
release to the world. For example, an outbound <span class="acronym">NFS</SPAN
>
packet would almost certainly be fragmented, and if the file was
confidential, that information would be released. If this happens by
accident, it's unlikely to be a problem; people do not generally hang
around looking at the data in random packets going by just in case
there's something interesting in them. You could wait a very long time
for somebody to accidentally send a fragment out with interesting data
in it.</P
><p class="para">If somebody inside intentionally uses fragmentation to transmit data,
you have hostile users within the firewall, and no firewall can deal
successfully with this problem. (They probably aren't very clever
hostile users, though, because there are easier ways to get data out.)</P
><p class="para">The only situation in which you need to worry about outbound fragments
is the one in which you allow a request in but block the outbound
reply. In this situation, nonfirst fragments of the reply will get
out, and the attacker has reason to expect them and look for them. You
can deal with this by being careful to filter out requests and by not
relying on filtering out the replies.<a class="indexterm" name="AUTOID-4522"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="FIRE-06-S2-8">6.3.3 Protocols Above
<span class="acronym">IP</SPAN
></A
></H3
><p class="para"><a class="indexterm" name="CH06PROTOIP"></A
><span class="acronym">IP</SPAN
> serves as the base for a number of different
protocols; by far the most common are <span class="acronym">TCP</SPAN
>,
<span class="acronym">UDP</SPAN
>, and <span class="acronym">ICMP</SPAN
>. These are, in
fact, the only <span class="acronym">IP</SPAN
>-based protocols that you're
likely to see outside a research environment.</P
><p class="para">We discuss Remote Procedure Calls (<span class="acronym">RPC</SPAN
>s) as well in
this section, although <span class="acronym">RPC</SPAN
> is, strictly speaking,
based on either <span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
>, not
on <span class="acronym">IP</SPAN
> itself. It makes sense to discuss it here,
however, because, like <span class="acronym">TCP</SPAN
> and
<span class="acronym">UDP</SPAN
>, <span class="acronym">RPC</SPAN
> is intended to operate
as a general-purpose session protocol on which application protocols
can be layered.</P
><p class="para">In addition, we briefly discuss <span class="acronym">IP</SPAN
> over
<span class="acronym">IP</SPAN
> (i.e., an <span class="acronym">IP</SPAN
> packet
encapsulated within another <span class="acronym">IP</SPAN
> packet), which is
used primarily for tunneling multicast <span class="acronym">IP</SPAN
> packets
over nonmulticast <span class="acronym">IP</SPAN
> networks.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-6">6.3.3.1 <span class="acronym">TCP</SPAN
></A
></H4
><p class="para"><a class="indexterm" name="CH06TCP"></A
><a class="indexterm" name="CH06PACKTCP"></A
><a class="indexterm" name="CH06DATATRANSVIATCP"></A
><span class="acronym">TCP</SPAN
> is the protocol most commonly used for services
on the Internet. For example, Telnet, <span class="acronym">FTP</SPAN
>,
<span class="acronym">SMTP</SPAN
>, <span class="acronym">NNTP</SPAN
>, and
<span class="acronym">HTTP</SPAN
> are all <span class="acronym">TCP</SPAN
>-based
services. <span class="acronym">TCP</SPAN
> provides a reliable, bidirectional
connection between two endpoints. Opening a <span class="acronym">TCP</SPAN
>
connection is like making a phone call: you dial the number, and after
a short setup period, a fairly reliable connection is established
between you and whomever you're calling.</P
><p class="para"><span class="acronym">TCP</SPAN
> is <em class="emphasis">reliable</EM
> in that it
makes three guarantees to the application layer:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">The destination will receive the application data in the order it was
sent.</P
></LI
><li class="listitem"><p class="para">The destination will receive all the application data.</P
></LI
><li class="listitem"><p class="para">The destination will not receive duplicates of any of the
application data.</P
></LI
></UL
><p class="para"><a class="indexterm" name="AUTOID-4583"></A
><span class="acronym">TCP</SPAN
> will kill a connection rather than violate one
of these guarantees. For example, if <span class="acronym">TCP</SPAN
> packets
from the middle of a session are lost in transit to the destination,
the <span class="acronym">TCP</SPAN
> layer will arrange for those packets to be
retransmitted before handing the data up to the application layer. It
won't hand up the data following the missing data until it has the
missing data. If some of the data cannot be recovered, despite
repeated attempts, the <span class="acronym">TCP</SPAN
> layer will kill the
connection and report this to the application layer, rather than hand
up the data to the application layer with a gap in it.</P
><p class="para">These guarantees incur certain costs in both setup time (the two sides
of a connection have to exchange startup information before
they can actually begin moving data) and ongoing performance (the two
sides of a connection have to keep track of the status of the
connection, to determine what data needs to be resent to the other
side to fill in gaps in the conversation).</P
><p class="para"><span class="acronym">TCP</SPAN
> is bidirectional in that once a connection is
established, a server can reply to a client over the same
connection. You don't have to establish one connection from a client
to a server for queries or commands and another from the server back
to the client for answers.</P
><p class="para">If you're trying to block a <span class="acronym">TCP</SPAN
> connection, it is
sufficient to simply block the first packet of the connection. Without
that first packet (and, more importantly, the connection startup
information it contains), any further packets in that connection won't
be reassembled into a data stream by the receiver, and the connection
will never be made. That first packet is recognizable because the<a class="indexterm" name="AUTOID-4595"></A
>
<span class="acronym">ACK</SPAN
> bit in its <span class="acronym">TCP</SPAN
> header is not
set; every other packet in the connection, regardless of which
direction it's going, will have the <span class="acronym">ACK</SPAN
> bit set.</P
><p class="para">Recognizing these &quot;start-of-connection&quot;
<span class="acronym">TCP</SPAN
> packets allows you to enforce a policy that
allows internal clients to connect to external servers, but prevents
external clients from connecting to internal servers. You do this by
allowing start-of-connection <span class="acronym">TCP</SPAN
> packets (those
without the <span class="acronym">ACK</SPAN
> bit set) only outbound and not
inbound. Start of connection packets would be allowed out from
internal clients to external servers, but would not be allowed in from
external clients to internal servers. Attackers cannot subvert this
approach simply by turning on the <span class="acronym">ACK</SPAN
> bit in their
start-of-connection packets, because the absence of the
<span class="acronym">ACK</SPAN
> bit is what identifies these packets as start
of connection packets.</P
><p class="para">Packet filtering implementations vary in how they treat and let you
handle the <span class="acronym">ACK</SPAN
> bit. Some packet filtering
implementations give direct access to the <span class="acronym">ACK</SPAN
>
bit&nbsp;- for example, by letting you include &quot;ack&quot; as a keyword in a
packet filtering rule. Some other implementations give indirect access
to the <span class="acronym">ACK</SPAN
> bit. For example, the Cisco
&quot;established&quot; keyword works by examining this bit
(established is &quot;true&quot; if the <span class="acronym">ACK</SPAN
> bit
is set, and &quot;false&quot; if the <span class="acronym">ACK</SPAN
> bit is
not set). Finally, some implementations don't let you examine the
<span class="acronym">ACK</SPAN
> bit at all.</P
><p class="para"><a class="xref" href="#FIRE-06-FIG-5" title="ACK bits on TCP packets">Figure 6.5</A
> shows what
<span class="acronym">ACK</SPAN
> is set to on packets that are part of a 
<span class="acronym">TCP</SPAN
> connection.</P
><h4 class="figure"><a class="title" name="FIRE-06-FIG-5">Figure 6.5: <span class="acronym">ACK</SPAN
> bits on <span class="acronym">TCP</SPAN
> packets</A
></H4
><img class="graphic" src="figs/fire0605.gif" alt="Figure 6.5"><a class="indexterm" name="AUTOID-4623"></A
><a class="indexterm" name="AUTOID-4624"></A
><a class="indexterm" name="AUTOID-4625"></A
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-7">6.3.3.2 <span class="acronym">UDP</SPAN
></A
></H4
><p class="para"><a class="indexterm" name="AUTOID-4630"></A
><a class="indexterm" name="AUTOID-4632"></A
><a class="indexterm" name="AUTOID-4635"></A
>The body of an <span class="acronym">IP</SPAN
> packet might contain a
<span class="acronym">UDP</SPAN
> packet instead of a <span class="acronym">TCP</SPAN
>
packet. <span class="acronym">UDP</SPAN
> is a low-overhead alternative to
<span class="acronym">TCP</SPAN
>.</P
><p class="para"><span class="acronym">UDP</SPAN
> is <em class="emphasis">low overhead</EM
> in that it
doesn't make any of the reliability guarantees (delivery, ordering,
and nonduplication) that <span class="acronym">TCP</SPAN
> does, and, therefore,
it doesn't need the mechanism to make those guarantees. Every
<span class="acronym">UDP</SPAN
> packet is independent; <span class="acronym">UDP</SPAN
>
packets aren't part of a &quot;virtual circuit&quot; as
<span class="acronym">TCP</SPAN
> packets are. Sending <span class="acronym">UDP</SPAN
>
packets is like dropping postcards in the mail: if you drop 100
postcards in the mail, even if they're all addressed to the same
place, you can't be absolutely sure that they're all going to get
there, and those that do get there probably won't be in exactly the
same order they were in when you sent them.</P
><p class="para">Unlike postcards, <span class="acronym">UDP</SPAN
> packets can actually arrive
more than once (without being ripped to shreds, which is normally the
only way the same postcard gets delivered multiple times). Multiple
copies are possible because the packet might be duplicated by the
underlying network. For example, on an Ethernet, a packet would be
duplicated if a router thought that it might have been the victim of
an Ethernet collision. If the router was wrong, and the original
packet had not been the victim of a collision, both the original and
the duplicate would eventually arrive at the destination. (A confused
application may also decide to send the same data twice, perhaps
because it didn't get an expected response to the first one.)</P
><p class="para">All of these things can happen to <span class="acronym">TCP</SPAN
> packets,
too, but they will be corrected before the data is passed to the
application. With <span class="acronym">UDP</SPAN
>, the application is
responsible for dealing with the packets, not corrected data.</P
><p class="para"><span class="acronym">UDP</SPAN
> packets are very similar to
<span class="acronym">TCP</SPAN
> packets in structure. A <span class="acronym">UDP</SPAN
>
header contains <span class="acronym">UDP</SPAN
> source and destination port
numbers, just like the <span class="acronym">TCP</SPAN
> source and destination
port numbers. However, a <span class="acronym">UDP</SPAN
> header does not
contain anything resembling an <span class="acronym">ACK</SPAN
> bit. The
<span class="acronym">ACK</SPAN
> bit is part of <span class="acronym">TCP</SPAN
>'s
mechanism for guaranteeing reliable delivery of data. Because
<span class="acronym">UDP</SPAN
> makes no such guarantees, it has no need for an
<span class="acronym">ACK</SPAN
> bit. There is no way for a packet filtering
router to determine, simply by examining the header of an incoming
<span class="acronym">UDP</SPAN
> packet, whether that packet is a first packet
from an external client to an internal server, or a response from an
external server back to an internal client.</P
><p class="para">Some packet filtering implementations, such as CheckPoint's FireWall-1
product, Janus; Morning Star's SecureConnect Router; and the
KarlBridge/KarlBrouter, have the capability of
&quot;remembering&quot; outgoing <span class="acronym">UDP</SPAN
> packets that
they've seen. They can then allow only the corresponding response
packets back in through the filtering mechanism. In order to be
counted as a response, the incoming packet has to be from the host and
port that the outbound packet was sent to, and has to be directed to
the host and port that sent the outbound packet. This capability is<a class="indexterm" name="AUTOID-4671"></A
><a class="indexterm" name="AUTOID-4673"></A
>
often referred to as <em class="emphasis">dynamic packet filtering</EM
>,
because the router is essentially modifying the filtering rules on the
fly to accommodate these returning packets. The rules created to allow
the responses are time-limited; they time out after a few seconds or
minutes. Dynamic packet filtering may also be used for any situation
in which the packet filtering rules change without somebody explictly
changing the configuration; different products support different
capabilities.</P
><p class="para"><a class="xref" href="#FIRE-06-FIG-6" title="Dynamic packet filtering at the UDP layer">Figure 6.6</A
> illustrates dynamic packet filtering at
the <span class="acronym">UDP</SPAN
> layer.</P
><h4 class="figure"><a class="title" name="FIRE-06-FIG-6">Figure 6.6: Dynamic packet filtering at the <span class="acronym">UDP</SPAN
> layer</A
></H4
><img class="graphic" src="figs/fire0606.gif" alt="Figure 6.6"></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-8">6.3.3.3 <span class="acronym">ICMP</SPAN
></A
></H4
><p class="para"><a class="indexterm" name="AUTOID-4688"></A
><a class="indexterm" name="AUTOID-4690"></A
><a class="indexterm" name="AUTOID-4694"></A
><a class="indexterm" name="AUTOID-4697"></A
><span class="acronym">ICMP</SPAN
> is used for <span class="acronym">IP</SPAN
> status and
control messages. <span class="acronym">ICMP</SPAN
> packets are carried in the
body of <span class="acronym">IP</SPAN
> packets, just as <span class="acronym">TCP</SPAN
>
and <span class="acronym">UDP</SPAN
> packets are. Examples of
<span class="acronym">ICMP</SPAN
> messages include:</P
><ul class="itemizedlist"><li class="listitem"><p class="para"><em class="emphasis">Echo request</EM
>&nbsp;- what a host sends when you run
<em class="emphasis">ping</EM
>.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">Echo response</EM
>&nbsp;- what a host responds to an
&quot;echo request&quot; with.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">Time exceeded</EM
>&nbsp;- what a router returns when it
determines that a packet appears to be looping; a more intuitive name
might be <em class="emphasis">maximum hopcount exceeded.</EM
></P
></LI
><li class="listitem"><p class="para"><em class="emphasis">Destination unreachable</EM
>&nbsp;- what a router returns
when the destination of a packet can't be reached for some reason
(e.g., because a network link is down).</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">Redirect</EM
>&nbsp;- what a router sends a host in response
to a packet the host should have sent to a different router; the router
handles the original packet anyway (forwarding it to the router it
should have gone to in the first place), and the redirect tells the host
about the more efficient path for next time.</P
></LI
></UL
><p class="para">Unlike <span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
>,
<span class="acronym">ICMP</SPAN
> has no source or destination ports, and no
other protocols layered on top of it. Instead, there is a set of
defined <span class="acronym">ICMP</SPAN
> message type codes; the particular
code used dictates the interpretation of the rest of the
<span class="acronym">ICMP</SPAN
> packet.</P
><p class="para">Many packet filtering systems let you filter <span class="acronym">ICMP</SPAN
>
packets based on the <span class="acronym">ICMP</SPAN
> message type field, much
as they allow you to filter <span class="acronym">TCP</SPAN
> or
<span class="acronym">UDP</SPAN
> packets based on the <span class="acronym">TCP</SPAN
> or
<span class="acronym">UDP</SPAN
> source and destination port fields.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-9">6.3.3.4 <span class="acronym">RPC</SPAN
></A
></H4
><p class="para"><a class="indexterm" name="CH06RPC"></A
><a class="indexterm" name="AUTOID-4745"></A
><a class="indexterm" name="AUTOID-4748"></A
>There are multiple remote procedure call
protocols known as <span class="acronym">RPC</SPAN
>s. 
The most popular is sometimes called &quot;Sun
<span class="acronym">RPC</SPAN
>&quot; because it was originally developed at
Sun Microsystems. This is the protocol we'll be discussing, and it is
the protocol most frequently referred to as simply
&quot;<span class="acronym">RPC</SPAN
>&quot;. Other remote procedure call
mechanisms are specific to particular <span class="acronym">UNIX</SPAN
>
implementations or implementation families. (For example, <span class="acronym">OSF DCE</SPAN
> has its own remote procedure call protocol.) These
mechanisms differ in detail from <span class="acronym">RPC</SPAN
>, but tend to
have similar problems.</P
><p class="para">Strictly speaking, the <span class="acronym">RPC</SPAN
> mechanism is not built
on top of <span class="acronym">IP</SPAN
>, but rather on top of
<span class="acronym">UDP</SPAN
> and <span class="acronym">TCP</SPAN
>. However, like
<span class="acronym">TCP</SPAN
> and <span class="acronym">UDP</SPAN
>, RPC is used as a
general-purpose transport protocol by a variety of application
protocols (such as <span class="acronym">NFS</SPAN
> and
<span class="acronym">NIS/YP</SPAN
>, as we discuss in <a class="xref" href="ch08_01.htm" title="Configuring Internet Services">Chapter 8</A
>), so it makes sense to describe it here.
<span class="acronym">NFS</SPAN
> and <span class="acronym">NIS/YP</SPAN
> are vulnerable
services from a network security point of view. An attacker with
access to your <span class="acronym">NFS</SPAN
> server can probably read any
file on your system. An attacker with access to your
<span class="acronym">NIS/YP</SPAN
> server can probably obtain your password
file, on which he can run a password-cracking attack against your
system.</P
><p class="para"><a class="indexterm" name="AUTOID-4772"></A
>In the <span class="acronym">TCP</SPAN
> and <span class="acronym">UDP</SPAN
> protocols,
port numbers are two-byte fields. This means that there are only
65,536 possible port numbers for <span class="acronym">TCP</SPAN
> and
<span class="acronym">UDP</SPAN
> services. There aren't enough ports to be able
to assign a unique well-known port number to every possible service
and application that might want one. Among other things,
<span class="acronym">RPC</SPAN
> addresses this limitation. Each
<span class="acronym">RPC</SPAN
>-based service is assigned a unique four-byte
&quot;<span class="acronym">RPC</SPAN
> service number.&quot; This allows for
4,294,967,296 different services, each with a unique number. That's
more than enough to assign a unique number to every possible service
and application you'd need.</P
><p class="para"><span class="acronym">RPC</SPAN
> is built on top of <span class="acronym">TCP</SPAN
> and
<span class="acronym">UDP</SPAN
> so there needs to be some way of mapping the
<span class="acronym">RPC</SPAN
> service numbers of the
<span class="acronym">RPC</SPAN
>-based servers in use on a machine to the
particular <span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
> ports
those servers are using. This is where the
<em class="emphasis">portmapper</EM
> server comes in.</P
><p class="para"><a class="indexterm" name="CH06RPCPORT"></A
><a class="indexterm" name="CH06PORTMAP"></A
>The <em class="emphasis">portmapper</EM
> is the only
<span class="acronym">RPC</SPAN
>-related server that is guaranteed to run on a
particular <span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
> port
number (it is at port number 111 on both). When an
<span class="acronym">RPC</SPAN
>-based server such as an <span class="acronym">NFS</SPAN
>
or <span class="acronym">NIS/YP</SPAN
> server starts, it allocates a random
<span class="acronym">TCP</SPAN
> and/or <span class="acronym">UDP</SPAN
> (some use one,
some the other, some both) port for itself.[3]

Then, it contacts the <em class="emphasis">portmapper</EM
> server on the
same machine to &quot;register&quot; its unique
<span class="acronym">RPC</SPAN
> service number and the particular port(s)
it is using at the moment.</P
><blockquote class="footnote"><p class="para">[3] Actually, most <span class="acronym">NFS</SPAN
> implementations that we've seen
always use port 2049; however, we're not willing to assume that
<span class="acronym">NFS</SPAN
> always will use that port, in every
implementation. In fact, <span class="acronym">RFC</SPAN
> 1094, the
<span class="acronym">NFS</SPAN
> protocol specification, says &quot;The
<span class="acronym">NFS</SPAN
> protocol currently uses the
<span class="acronym">UDP</SPAN
> port number 2049. This is not an officially
assigned port, so later versions of the protocol use the
`Portmapping' facility of <span class="acronym">RPC</SPAN
>.&quot;</P
></BLOCKQUOTE
><p class="para">An <span class="acronym">RPC</SPAN
>-based client program that wishes to contact
a particular <span class="acronym">RPC</SPAN
>-based server on a machine first
contacts the <em class="emphasis">portmapper</EM
> server on that machine
(which, remember, always runs on both <span class="acronym">TCP</SPAN
> and
<span class="acronym">UDP</SPAN
> port 111). The client tells
<em class="emphasis">portmapper</EM
> the unique <span class="acronym">RPC</SPAN
>
service number for the server it wishes to access, and
<em class="emphasis">portmapper</EM
> responds with a message saying, in
effect, either &quot;I'm sorry, but that service isn't available on
this machine at the moment,&quot; or &quot;That service is currently
running on <span class="acronym">TCP</SPAN
> (or <span class="acronym">UDP</SPAN
>) port
<em class="emphasis">N</EM
> on this machine at the moment.&quot; At that
point, the client contacts the server on the port number it got from
the <em class="emphasis">portmapper</EM
>, and continues its conversation
directly with the server, without further involvement from the
<em class="emphasis">portmapper</EM
>. (<a class="xref" href="#FIRE-06-FIG-7" title="RPC and the portmapper">Figure 6.7</A
>
shows this process.)</P
><h4 class="figure"><a class="title" name="FIRE-06-FIG-7">Figure 6.7: <span class="acronym">RPC</SPAN
> and the portmapper</A
></H4
><img class="graphic" src="figs/fire0607.gif" alt="Figure 6.7"><p class="para">It's very difficult to use packet filtering to control
<span class="acronym">RPC</SPAN
>-based services, because you don't know what
port the service will be using on a particular machine&nbsp;- and chances
are that the port used will change every time the machine is
rebooted. Blocking access to the <em class="emphasis">portmapper</EM
> isn't
sufficient. An attacker can bypass the step of talking to the
<em class="emphasis">portmapper</EM
>, and simply try all
<span class="acronym">TCP</SPAN
> and/or <span class="acronym">UDP</SPAN
> ports (the 65,536
possible ports can all be checked on a particular machine in a matter
of minutes), looking for the response expected from a particular
<span class="acronym">RPC</SPAN
>-based server like <span class="acronym">NFS</SPAN
> or
<span class="acronym">NIS/YP</SPAN
>.</P
><p class="para">Some newer packet filtering products can talk to
<em class="emphasis">portmapper</EM
> to determine what services are where
and filter on that basis. Note that this has to be verified on a
per-packet basis for <span class="acronym">UDP</SPAN
>-based services. The packet
filter will have to contact <em class="emphasis">portmapper</EM
> 
every time it receives a
packet, because if the machine has rebooted, the service may have
moved. Because <span class="acronym">TCP</SPAN
> is connection-oriented, the port
number only has to be verified on a per-connection basis. Using this
mechanism to allow <span class="acronym">UDP</SPAN
>-based services is going to
result in high overhead and is probably not wise for data-intense
applications like <span class="acronym">NFS</SPAN
>.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> Even though it is not sufficient, you should still block access to the
<em class="emphasis">portmapper</EM
>, because some versions of
<em class="emphasis">portmapper</EM
> are capable of being used as proxies
for an attacker's clients.<a class="indexterm" name="AUTOID-4856"></A
><a class="indexterm" name="AUTOID-4857"></A
></P
></BLOCKQUOTE
><p class="para">So, what do you do to guard <span class="acronym">RPC</SPAN
>-based services? A
couple of observations: First, it turns out that most of the
&quot;dangerous&quot; <span class="acronym">RPC</SPAN
>-based services
(particularly <span class="acronym">NIS/YP</SPAN
> and <span class="acronym">NFS</SPAN
>)
are offered only over <span class="acronym">UDP</SPAN
>. Second, most services
you'd want to access through a packet filter are
<span class="acronym">TCP</SPAN
>-based, <em class="emphasis">not</EM
>
<span class="acronym">UDP</SPAN
>-based; the notable exceptions are
<span class="acronym">DNS</SPAN
>, <span class="acronym">NTP</SPAN
>,
<em class="emphasis">syslog</EM
>, and Archie. These twin observations lead
to the common approach many sites take in dealing with
<span class="acronym">RPC</SPAN
> using packet filtering: block
<span class="acronym">UDP</SPAN
> altogether, except for specific and tightly
controlled &quot;peepholes&quot; for <span class="acronym">DNS</SPAN
>,
<span class="acronym">NTP</SPAN
>, syslog and Archie. (See the discussion of
these services in <a class="xref" href="ch08_01.htm" title="Configuring Internet Services">Chapter 8</A
>.)</P
><p class="para">With this approach, if you wish to allow any <span class="acronym">TCP</SPAN
>-based
<span class="acronym">RPC</SPAN
> service, you'll need to allow them
all. <span class="acronym">TCP</SPAN
>-based <span class="acronym">NFS</SPAN
> servers,
while available, are not yet widely used; if you're using them,
however, you'll need to modify this approach accordingly.<a class="indexterm" name="AUTOID-4880"></A
></P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="FIRE-06-S3-10">6.3.3.5 <span class="acronym">IP</SPAN
> over <span class="acronym">IP</SPAN
></A
></H4
><p class="para"><a class="indexterm" name="AUTOID-4886"></A
><a class="indexterm" name="AUTOID-4889"></A
><a class="indexterm" name="AUTOID-4893"></A
><a class="indexterm" name="AUTOID-4895"></A
>In some circumstances, <span class="acronym">IP</SPAN
> packets are encapsulated
within other <span class="acronym">IP</SPAN
> packets for transmission, yielding
so-called &quot;<span class="acronym">IP</SPAN
> over
<span class="acronym">IP.</SPAN
>&quot; The most common use of
<span class="acronym">IP</SPAN
> over <span class="acronym">IP</SPAN
> is to carry multicast
<span class="acronym">IP</SPAN
> packets (that is, packets with multicast
destination addresses) between networks that do support multicasting<a class="indexterm" name="AUTOID-4904"></A
><a class="indexterm" name="AUTOID-4907"></A
>
over intermediate networks that don't. To cross these intermediate
networks, a special multicast router (or <em class="emphasis">mrouter</EM
>) on
each multicast network encapsulates the multicast
<span class="acronym">IP</SPAN
> packets that it wants to send into nonmulticast
(i.e., normal) <span class="acronym">IP</SPAN
> packets addressed to other
<em class="emphasis">mrouter</EM
>s. The other <em class="emphasis">mrouter</EM
>s, 
upon receiving these encapsulated
multicast packets, strip off the outer (nonmulticast) packet and then
handle the inner (multicast) packet.</P
><p class="para">Multicast <span class="acronym">IP</SPAN
> is becoming more and more popular on
the Internet, primarily because of the conferencing and other services
offered through the <span class="acronym">MBONE</SPAN
>. We discuss the <span class="acronym">MBONE</SPAN
>, and multicast
services in general, in more detail in <a class="xref" href="ch02_01.htm" title="Internet Services">Chapter 2, <cite class="chapter">Internet Services</CITE
></A
>
and <a class="xref" href="ch08_01.htm" title="Configuring Internet Services">Chapter 8</A
>.<a class="indexterm" name="AUTOID-4920"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="FIRE-06-S2-9">6.3.4 Protocols Below <span class="acronym">IP</SPAN
></A
></H3
><p class="para">It's theoretically possible to filter on information from below the
<span class="acronym">IP</SPAN
> level&nbsp;- for example, the Ethernet hardware
address. However, doing so is very rarely useful because in most
cases, all packets from the outside are coming from the same hardware
address (the address of the router that handles your Internet
connection). Furthermore, many routers have multiple connections with
different lower-level protocols. As a result, doing filtering at
lower levels would require configuring different interfaces with
different kinds of rules for the different lower-level protocols. You
couldn't write one rule to apply to all interfaces on a router that
had two Ethernet connections and an <span class="acronym">FDDI</SPAN
>
connection, because the headers of Ethernet and
<span class="acronym">FDDI</SPAN
> packets, while similar, are not identical. In
practice, <span class="acronym">IP</SPAN
> is the lowest level protocol at which
people choose to do packet filtering.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="FIRE-06-S2-10">6.3.5 Application Layer Protocols</A
></H3
><p class="para">In most cases, there is a further protocol on top of
<span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
>, specific to the
application. These protocols differ widely in their specificity, and
there are hundreds, if not thousands, of them (almost as many as there
are network-based applications). Some newer packet filtering
applications provide the ability to filter on application-layer
protocols for particular well-known applications. For example, they
may be able to recognize particular information in an
<span class="acronym">FTP</SPAN
> transaction in order to set up dynamic filters,
or they may be able to compare the information in a packet to the
application that it's supposed to be going to, to be sure that packets
addressed to a <span class="acronym">DNS</SPAN
> port are actually DNS packets.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="FIRE-06-S2-11">6.3.6 <span class="acronym">IP</SPAN
> Version 6</A
></H3
><p class="para"><a class="indexterm" name="CH06IPV6"></A
>The current version of
<span class="acronym">IP</SPAN
> (at the time this book was written)
is officially known as <span class="acronym">IP</SPAN
>
Version 4; throughout this book, whenever we talk about
<span class="acronym">IP</SPAN
> with no further qualification, that's what we're
talking about. There is, however, a new version of
<span class="acronym">IP</SPAN
> in the works right now, known as
<span class="acronym">IP</SPAN
> Version 6 (<span class="acronym">IP</SPAN
>v6 for
short). Why do we need a new version of <span class="acronym">IP</SPAN
>, and how
will <span class="acronym">IP</SPAN
>v6 affect you?</P
><p class="para"><a class="indexterm" name="AUTOID-4952"></A
>As we mentioned in the section called &quot;What the Future
Holds&quot; in <a class="xref" href="ch04_01.htm" title="Firewall Design">Chapter 4, <cite class="chapter">Firewall Design</CITE
></A
>, the impetus to create
<span class="acronym">IP</SPAN
>v6 was one simple problem: the Internet is
running out of <span class="acronym">IP</SPAN
> addresses. The Internet has
become so popular that there just won't be enough
<span class="acronym">IP</SPAN
> network numbers (particularly Class B network
numbers, which have proven to be what most sites need) to go around;
by some estimates, if nothing had been done, the Internet would have
run out of addresses in 1995 or 1996. Fortunately, the problem was
recognized, and something was done. Two things, actually&nbsp;- first, the
implementation of a set of temporary measures and guidelines to make
best possible use of the remaining unassigned addresses, and second,
the design and implementation of a new version of
<span class="acronym">IP</SPAN
> that would permanently deal with the
address-exhaustion issue.</P
><p class="para"><a class="indexterm" name="AUTOID-4961"></A
>If you're going to create a new version of <span class="acronym">IP</SPAN
> in
order to deal with address-space exhaustion, you might as well take
advantage of the opportunity to deal with a whole raft of other
problems or limitations in <span class="acronym">IP</SPAN
> as well, such as
encryption, authentication, source routing, and dynamic
configuration. According to Steve Bellovin of
<span class="acronym">AT&T</SPAN
> Bell Laboratories, a well-known firewalls
expert on the Internet and a participant in the
<span class="acronym">IP</SPAN
>v6 design process:[4]</P
><blockquote class="footnote"><p class="para">[4] Steve Bellovin, posting to the Firewalls mailing list, December 31, 1994.</P
></BLOCKQUOTE
><blockquote class="blockquote"><p class="para"><a class="indexterm" name="AUTOID-4972"></A
><span class="acronym">IP</SPAN
>v6 is based on the concept of nested
headers. That's how encryption and authentication are done; the
&quot;next protocol&quot; field after the <span class="acronym">IP</SPAN
>v6
header specifies an encryption or an authentication header. In turn,
their next protocol fields would generally indicate either
<span class="acronym">IP</SPAN
>v6 or one of the usual transport protocols, such
as <span class="acronym">TCP</SPAN
> or <span class="acronym">UDP</SPAN
>.</P
><p class="para">Nested <span class="acronym">IP</SPAN
> over <span class="acronym">IP</SPAN
> can be done
even without encryption or authentication; that can be used as a form
of source routing. A more efficient way is to use the source routing
header&nbsp;- which is more useful than the corresponding
<span class="acronym">IP</SPAN
>v4 option, and is likely to be used much more,
especially for mobile <span class="acronym">IP</SPAN
>.</P
><p class="para">Some of the implications for firewalls are already apparent. A packet
filter must follow down the full chain of headers, understanding and
processing each one in turn. (And yes, this can make looking at port
numbers more expensive.) A suitably cautious stance dictates that a
packet with an unknown header be bounced, whether inbound or outbound.
Also, the ease and prevalence of source routing means that cryptographic
authentication is absolutely necessary. On the other hand, it is
intended that such authentication be a standard, mandatory feature. 
Encrypted packets are opaque, and hence can't be examined; this is true
today, of course, but there aren't very many encryptors in use now. 
That will change. Also note that encryption can be done host-to-host,
host-to-gateway, or gateway-to-gateway, complicating the analysis still
more. </P
><p class="para">Address-based filtering will also be affected, to some extent, by the new
autoconfiguration mechanisms. It's vital that any host whose address is
mentioned in a filter receive the same address each time. While this is
the intent of the standard mechanisms, one needs to be careful about
proprietary schemes, dial-up servers, etc. Also, high-order address
bits can change, to accommodate the combination of provider-based
addressing and easy switching among carriers. </P
><p class="para"><a class="indexterm" name="AUTOID-4988"></A
>Finally, <span class="acronym">IP</SPAN
>v6 incorporates
&quot;flows.&quot; Flows are essentially virtual circuits at the
<span class="acronym">IP</SPAN
> level; they're intended to be used for things
like video, intermediate-hop <span class="acronym">ATM</SPAN
> circuit selection,
etc. But they can also be used for firewalls, given appropriate
authentication: the <span class="acronym">UDP</SPAN
> reply problem might go away
if the query had a flow id that was referenced by the response. This,
by the way, is a vague idea of mine; there are no standards for how
this should be done. The regular flow setup protocol won't work; it's
too expensive. But a firewall traversal header might do the job.</P
></BLOCKQUOTE
><p class="para">As you can see, <span class="acronym">IP</SPAN
>v6 could have a major impact on
firewalls, especially with respect to packet filtering. As this book
is being written, though, it's still too soon to tell just what those
effects will be, and when we'll start to feel them.</P
><p class="para">Keep in mind that <span class="acronym">IP</SPAN
>v6 won't be deployed
overnight. <span class="acronym">IP</SPAN
>v4 will be around for a long time, and
many sites will continue to run it through the foreseeable future. The
<span class="acronym">IP</SPAN
>v6 designers are very sensitive to the transition
issues, and a lot of attention is being paid to that area, and to
various migration strategies sites might employ.<a class="indexterm" name="AUTOID-5000"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="FIRE-06-S2-12">6.3.7 Non-<span class="acronym">IP</SPAN
> Protocols</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-5005"></A
>Other protocols at the same level as <span class="acronym">IP</SPAN
>, e.g.,
AppleTalk and <span class="acronym">IPX</SPAN
>, provide similar kinds of
information as <span class="acronym">IP</SPAN
>, although the headers and
operations for these protocols, and, therefore their packet filtering
characteristics, vary radically. Most packet filtering implementations
support <span class="acronym">IP</SPAN
> filtering only, and simply drop
non-<span class="acronym">IP</SPAN
> packets. Some packages provide limited
packet filtering support for non-<span class="acronym">IP</SPAN
> protocols, but
this support is usually far less flexible and capable than the
router's <span class="acronym">IP</SPAN
> filtering capability.</P
><p class="para">At this time, packet filtering as a tool isn't as popular and well
developed for non-<span class="acronym">IP</SPAN
> protocols, presumably because
these protocols are rarely used to communicate outside a single
organization over the Internet. (The Internet is, by definition, a
network of <span class="acronym">IP</SPAN
> networks). Non-<span class="acronym">IP</SPAN
>
protocols are more of an issue for firewalls that are internal to an
organization, and for this application, you would want to choose one
of the packages that supports non-<span class="acronym">IP</SPAN
> filtering.</P
><p class="para">Across the Internet, non-<span class="acronym">IP</SPAN
> protocols are handled
by encapsulating them within <span class="acronym">IP</SPAN
> protocols. In most
cases, you will be limited to permitting or denying encapsulated
protocols in their entirety; you can accept all
Appletalk-in-<span class="acronym">UDP</SPAN
> connections, or reject them at
all. A few packages that support non-<span class="acronym">IP</SPAN
> protocols
can recognize these connections when encapsulated and filter on fields
in them.</P
><div class="sidebar"><h4 class="sidebar"><a class="title" name="AUTOID-5025">Filtering by Interface</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-5028"></A
><a class="indexterm" name="AUTOID-5031"></A
>There is one key piece of information that would be useful when you
are making a packet filtering decision, that can't be found in the
headers of the packet; this is the interface on which the packet came
into the router or is going out of the router. This is important
information because it allows the router to detect forged packets.</P
><p class="para">If the sole router between your internal net and the external world
receives a packet with an internal source address from the internal
interface, there is no problem; all packets coming from the inside
will have internal source addresses. If, however, the router receives
a packet with an internal source address from the external interface,
it means either that someone is forging the packet (probably in an
attempt to circumvent security), or that there is something seriously
wrong with your network configuration. </P
><p class="para">You can get these packets without forgery. For example, someone might
have set up a second connection between your net and the outside
world, such as a dial-up <span class="acronym">PPP</SPAN
> link from a user's
desk, probably with little or no thought to security. As a result, the
traffic that should be staying internal to your net is
&quot;leaking&quot; out through this second connection, going across
the Internet, and trying to come back in through your &quot;front
door&quot;). There's little you can do to detect such illicit
&quot;back door&quot; connections except by detecting internal
packets arriving from the outside; about the best you can do is have a
strong and well-publicized policy against them, and provide as many as
possible of the services your users desire through the front door (the
firewall), so that they don't feel a compelling need to create their
own back door.</P
><p class="para">These packets should be logged and treated as urgent issues. If
someone is forging them, that person is attacking you with some
seriousness. If the packets are leaked from a back door, you have a
security problem because of the extra Internet connection. You may
also have a routing problem: a host that claims to be internal and
advertises routes for itself is in danger of getting all of your
internal network's traffic. This is bad if it's a
<span class="acronym">PPP</SPAN
> link, which is probably not going to handle the
load. It's much worse if it's not connected to your network at all,
because some or all of your network's traffic is going to disappear.</P
></DIV
><a class="indexterm" name="AUTOID-5038"></A
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch06_02.htm" title="6.2 Configuring a Packet Filtering Router"><img src="../gifs/txtpreva.gif" alt="Previous: 6.2 Configuring a Packet Filtering Router" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="Building Internet Firewalls"><img src="../gifs/txthome.gif" alt="Building Internet Firewalls" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch06_04.htm#FIRE-06-S2-14" title="6.4 What Does the Router Do with Packets?"><img src="../gifs/txtnexta.gif" alt="Next: 6.4 What Does the Router Do with Packets?" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">6.2 Configuring a Packet Filtering Router</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_a.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">6.4 What Does the Router Do with Packets?</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="../puis/index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
