<html><head>
<title>[Chapter 6] Configuring Hosts</TITLE>
<meta name="DC.title" content="DNS &amp; BIND"><meta name="DC.creator" content="Cricket Liu &amp; Paul Albitz"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-01-06T18:28:32Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-512-2" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="index.htm" title="DNS &amp; BIND"><link rel="prev" href="ch05_03.htm" title="5.3 The MX Algorithm"><link rel="next" href="ch06_02.htm#AUTOID-5044" title="6.2 Sample Resolver Configurations"></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="DNS &amp; BIND" usemap="#srchmap" border="0"></H1
><map name="srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="DNS &amp; BIND"><area shape="RECT" coords="467,0,514,18" href="../search/dsrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_03.htm" title="5.3 The MX Algorithm"><img src="../gifs/txtpreva.gif" alt="Previous: 5.3 The MX Algorithm" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 6</FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch06_02.htm#AUTOID-5044" title="6.2 Sample Resolver Configurations"><img src="../gifs/txtnexta.gif" alt="Next: 6.2 Sample Resolver Configurations" border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="CHAPTER"><h1 class="chapter"><a class="title" name="DNS3-CHP-6">6. Configuring Hosts</A
></H1
><div class="htmltoc"><p><b>Contents:</B
><br><a class="sect1" href="#AUTOID-4427" title="6.1 The Resolver">The Resolver</A
><br><a class="sect1" href="ch06_02.htm#AUTOID-5044" title="6.2 Sample Resolver Configurations">Sample Resolver Configurations</A
><br><a class="sect1" href="ch06_03.htm#AUTOID-5173" title="6.3 Minimizing Pain and Suffering">Minimizing Pain and Suffering</A
><br><a class="sect1" href="ch06_04.htm#AUTOID-5833" title="6.4 Vendor-Specific Options">Vendor-Specific Options</A
></P
><p></P
></DIV
><div class="epigraph"><p class="para" align="right"><i>They were indeed a queer-looking party that assembled on the
bank&nbsp;- the birds with draggled feathers, the animals with their
fur clinging close to them, and all dripping wet, cross, and
uncomfortable.</I
></P
></DIV
><p class="para"><a class="indexterm" name="DNS3-IDX-6-HOSTS-CONFIGURING-TO-USE-DNS"></A
><a class="indexterm" name="DNS3-IDX-6-CONFIGURING-HOSTS-TO-USE-DNS"></A
><a class="indexterm" name="DNS3-IDX-6-DNS-DOMAIN-NAME-SYSTEM-CONFIGURING-HOSTS-FOR"></A
>Now that you or someone else in your organization has set up name
servers for your zones, you'll want to configure the hosts on your
network to use them. That involves configuring those hosts'
resolvers. You should also check files like
<i class="filename">hosts.equiv</I
> and <i class="filename">.rhosts</I
> and
make any changes dictated by using <span class="acronym">DNS</SPAN
>; you may
need to convert some of the host names in these files to domain
names. And you may also want to add aliases, both for your users'
convenience and to minimize the shock of the conversion to
<span class="acronym">DNS</SPAN
>.</P
><p class="para">This chapter covers these topics, and also describes configuring
the resolver in many common versions of <span class="acronym">UNIX</SPAN
> and
in Microsoft's Windows 95 and Windows <span class="acronym">NT</SPAN
>.</P
><div class="sect1"><h2 class="sect1"><a class="title" name="AUTOID-4427">6.1 The Resolver</A
></H2
><p class="para"><a class="indexterm" name="DNS3-IDX-6-RESOLVERS"></A
>We introduced resolvers way back in <a class="xref" href="ch02_01.htm" title="How Does DNS Work?">Chapter 2, <cite class="chapter">How Does <span class="acronym">DNS</SPAN
> Work?</CITE
></A
>, but
we didn't say much more about them. The resolver, you'll remember, is
the client half of the Domain Name System. It's responsible for
translating a program's request for host information into a query to a
name server and for translating the response into an answer for the
program.</P
><p class="para">We haven't done any resolver configuration yet, because the
occasion for it hasn't arisen. When we set up our name servers in
<a class="xref" href="ch04_01.htm" title="Setting Up BIND">Chapter 4, <cite class="chapter">Setting Up <span class="acronym">BIND</SPAN
></CITE
></A
>, the resolver's default behavior worked
just fine for our purposes. But if we'd needed the resolver to do more
than what it does by default, or to behave differently from the
default, we would have had to configure the resolver.</P
><p class="para">There's one thing we should mention up front: what we'll
describe in the next few sections is the behavior of the vanilla
<span class="acronym">DNS</SPAN
> 8.1.2 resolver in the absence of other naming
services. Not all resolvers behave quite this way; some vendors still
ship resolvers based on earlier versions of the <span class="acronym">DNS</SPAN
>
code, and some have implemented special resolver functionality that
lets you modify the resolver algorithm.  Whenever we think it's
important, we'll point out differences between the behavior of the
8.1.2 <span class="acronym">DNS</SPAN
> resolver and that of earlier resolvers,
particularly the 4.8.3 resolver, which is what many vendors were
shipping when we last updated this book. We'll cover various vendors'
extensions later in this chapter.</P
><p class="para">So what exactly does the resolver allow you to configure? Most
resolvers let you configure at least three aspects of the resolver's
behavior: the default domain, the search list, and the name server(s)
that the resolver queries.  Many <span class="acronym">UNIX</SPAN
> vendors allow
you to configure other resolver behavior, too, through nonstandard
extensions to <span class="acronym">DNS</SPAN
>. Sometimes these extensions are
necessary to cope with other software, like Sun's Network Information
Service (<span class="acronym">NIS</SPAN
>); sometimes they're simply value added
by the vendor.[1]</P
><blockquote class="footnote"><p class="para">[1] <span class="acronym">NIS</SPAN
> used to be called <span class="quote">"Yellow
Pages,"</SPAN
> or <span class="quote">"<span class="acronym">YP</SPAN
>,"</SPAN
> but was
changed to <span class="acronym">NIS</SPAN
> because the British phone company
had a copyright on the name Yellow Pages.</P
></BLOCKQUOTE
><p class="para">Almost all resolver configuration is done in the file<a class="indexterm" name="AUTOID-4451"></A
><a class="indexterm" name="AUTOID-4453"></A
><a class="indexterm" name="AUTOID-4456"></A
><a class="indexterm" name="AUTOID-4459"></A
>
<i class="filename">/etc/resolv.conf</I
> (this may be
<i class="filename">/usr/etc/resolv.conf</I
> or something similar on your
host&nbsp;- check the <kbd class="command">resolver</KBD
> manual page, usually
in section 4 or 5, to make sure). There are five main
<i class="firstterm">directives</I
> you can use in
<i class="filename">resolv.conf</I
>: the
<i class="structfield">domain</I
> directive, the
<i class="structfield">search</I
> directive, the
<i class="structfield">nameserver</I
> directive, the
<i class="structfield">sortlist</I
> directive, and the
<i class="structfield">options</I
> directive.  These directives
control the behavior of the resolver. There are other, vendor-specific
directives available on some versions of
<span class="acronym">UNIX</SPAN
>&nbsp;- we'll discuss them at the end of this
chapter.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-4473">6.1.1 The Default Domain</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-4476"></A
><a class="indexterm" name="AUTOID-4478"></A
><a class="indexterm" name="AUTOID-4481"></A
>The default domain is the domain considered <span class="quote">"local"</SPAN
> to
the host. For example, when you add an entry like:</P
><blockquote class="screen"><pre class="screen">relay mark</PRE
></BLOCKQUOTE
><p class="para">to your <i class="filename">.rhosts</I
> file, the name <i class="systemitem.sitename">relay</I
> is assumed to be in your default
domain.  This makes a lot more sense than allowing access to every
host on the Internet whose domain name starts with <i class="systemitem.sitename">relay</I
>.  Other authorization files like
<i class="filename">hosts.equiv</I
> and <i class="filename">hosts.lpd</I
>
work the same way.</P
><p class="para"><a class="indexterm" name="AUTOID-4493"></A
><a class="indexterm" name="AUTOID-4496"></A
>Normally, the default domain is determined from the host's
<kbd class="command">hostname</KBD
>; the default domain is everything
after the first <span class="quote">"."</SPAN
> in the name. If the name doesn't
contain a <span class="quote">"."</SPAN
>, the default domain is assumed to be the
root domain. So the <kbd class="command">hostname</KBD
> <i class="systemitem.sitename">asylum.sf.ca.us</I
> implies a default domain of
<i class="systemitem.sitename">sf.ca.us</I
>, while the
<kbd class="command">hostname</KBD
> <i class="systemitem.sitename">dogbert</I
> implies a root default
domain&nbsp;- which probably isn't correct, given that there are no
hosts immediately under the root domain.</P
><p class="para">You can also set the default domain with the<a class="indexterm" name="AUTOID-4508"></A
>
<i class="structfield">domain</I
> directive in
<i class="filename">resolv.conf</I
>.  If the
<i class="structfield">domain</I
> directive is specified, it overrides
the domain in the <kbd class="command">hostname</KBD
>.</P
><p class="para">The domain directive has a very simple syntax, but you've got to
get it right, since the resolver doesn't report errors. The keyword
<i class="structfield">domain</I
> starts the line in column one,
followed by whitespace (one or more blanks or tabs), then the name of
the default domain. The default domain should be written without a
trailing dot, like this:</P
><blockquote class="screen"><pre class="screen">domain colospgs.co.us</PRE
></BLOCKQUOTE
><p class="para">In older versions of the <span class="acronym">DNS</SPAN
> resolver (those
before <span class="acronym">DNS</SPAN
> 4.9.3), trailing spaces <em class="emphasis">are
not allowed</EM
> on the line, and will cause your default domain
to be set to a name ending with one or more spaces, which is almost
certainly not what you want. And there's yet another way to set the
default domain&nbsp;- via the<a class="indexterm" name="AUTOID-4521"></A
>
<i class="envar">LOCALDOMAIN</I
> environment
variable. <i class="envar">LOCALDOMAIN</I
> is handy because you can set it
on a per-user basis. For example, you might have a big, massively
parallel box in your corporate computing center to which employees
from all over the world log in. Each may do most of his work in a
different company subdomain. With <i class="envar">LOCALDOMAIN</I
>, each
employee can set his default domain to the appropriate domain in his
shell startup file.</P
><p class="para">Which method should you use&nbsp;- <kbd class="command">hostname</KBD
>,
the <i class="structfield">domain</I
> directive, or
<i class="envar">LOCALDOMAIN</I
>? We prefer using
<kbd class="command">hostname</KBD
>, but primarily because that's the way
Berkeley does it, and it seems <span class="quote">"cleaner"</SPAN
> in that it
requires less explicit configuration. Also, some Berkeley software,
particularly software that uses the
<i class="function">ruserok()</I
> library call to authenticate
users, allows short host names in files like
<i class="filename">hosts.equiv</I
> only if <kbd class="command">hostname</KBD
>
is set to the full domain name.</P
><p class="para">If you run software that can't tolerate long
<kbd class="command">hostnames</KBD
>, though, you can use the
<i class="structfield">domain</I
> directive. The
<kbd class="command">hostname</KBD
> command will continue to return a short
name, and the resolver will fill in the domain from
<i class="filename">resolv.conf</I
>. You may even find occasion to use
<i class="envar">LOCALDOMAIN</I
> on a host with lots of users.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-4542">6.1.2 The Search List</A
></H3
><p class="para"><a class="indexterm" name="DNS3-IDX-6-SEARCH-LIST"></A
><a class="indexterm" name="DNS3-IDX-6-DEFAULT-SEARCH-LIST"></A
>The default domain, whether derived from <kbd class="command">hostname</KBD
>
or <i class="filename">resolv.conf</I
>, also determines the default
<i class="firstterm">search list</I
>. The search list was designed to
make users' lives a little easier by saving them some typing. The idea
is to search one or more domains for names typed at the command line
that might be incomplete&nbsp;- that is, that might not be fully
qualified domain names.<a class="indexterm" name="AUTOID-4552"></A
><a class="indexterm" name="AUTOID-4554"></A
></P
><p class="para">Most <span class="acronym">UNIX</SPAN
> networking commands that take a
domain name as an argument, like <kbd class="command">telnet</KBD
>,
<kbd class="command">ftp</KBD
>, <kbd class="command">rlogin</KBD
>, and
<kbd class="command">rsh</KBD
>, apply the search list to those
arguments.</P
><p class="para">Both the way the default search list is derived and the way the
search list is applied changed from <span class="acronym">DNS</SPAN
> 4.8.3 to
<span class="acronym">DNS</SPAN
> 4.9.  If your resolver is an older make, you'll
still see the 4.8.3 behavior, but if you've got a newer model,
including <span class="acronym">DNS</SPAN
> 8.1.2,[2] you'll see the improvements in the 4.9 resolver.</P
><blockquote class="footnote"><p class="para">[2] Though the <span class="acronym">ISC</SPAN
> added lots of new server
functionality in <span class="acronym">DNS</SPAN
> 8, the resolver is nearly
identical to the <span class="acronym">DNS</SPAN
> 4.9 resolver.</P
></BLOCKQUOTE
><p class="para">With any <span class="acronym">DNS</SPAN
> resolver, a user can indicate
that a domain name is fully qualified by adding a trailing dot to
it.[3] For example, the trailing dot in the command:</P
><blockquote class="footnote"><p class="para">[3] Note that we said that the resolver can handle a trailing
dot. Some programs, particularly <span class="acronym">UNIX</SPAN
> mail user
agents, don't deal correctly with a trailing dot in email
addresses. They cough even before they hand the domain name in the
address to the resolver.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>telnet ftp.ora.com.</B
></CODE
></PRE
></BLOCKQUOTE
><p class="para">means <span class="quote">"don't bother searching any other domains; this
domain name is fully qualified."</SPAN
> This is analogous to the
leading slash in full pathnames in the <span class="acronym">UNIX</SPAN
> and
<span class="acronym">MS-DOS</SPAN
> filesystems. Pathnames without a leading
slash are interpreted as relative to the current working directory,
while pathnames with a leading slash are absolute, anchored at the
root.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-4583">6.1.2.1 The <span class="acronym">DNS</SPAN
> 4.8.3 search list</A
></H4
><p class="para">With <span class="acronym">DNS</SPAN
> 4.8.3 resolvers, the default search
list includes the default domain and each of its parent domains with
two or more labels. Therefore, on a host running a 4.8.3 resolver and
configured with:</P
><blockquote class="screen"><pre class="screen">domain cv.hp.com</PRE
></BLOCKQUOTE
><p class="para">the default search list would contain first <i class="systemitem.sitename">cv.hp.com</I
>, the default domain, then
<i class="systemitem.sitename">hp.com</I
>, the default domain's
parent, but not <i class="systemitem.sitename">com</I
>, as it only
has one label.[4] The name is looked up as is, after the resolver appends
each element of the search list, and only if the name typed contains
at least one dot.  Thus, a user typing:</P
><blockquote class="footnote"><p class="para">[4] One reason older <span class="acronym">DNS</SPAN
> resolvers didn't append
just the top-level domain is that there were&nbsp;- and still
are&nbsp;- very few hosts at the second level of the Internet's name
space, so tacking on just <i class="systemitem.sitename">com</I
>
or <i class="systemitem.sitename">edu</I
> to <i class="systemitem.sitename">foo</I
> is unlikely to result in the domain
name of a real host. Also, looking up the address of a <i class="systemitem.sitename">foo.com</I
> or <i class="systemitem.sitename">foo.edu</I
> might well require sending a query
to a root name server, which taxes the roots and can be
time-consuming.</P
></BLOCKQUOTE
><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>telnet pronto.cv.hp.com</B
></CODE
></PRE
></BLOCKQUOTE
><p class="para">will cause lookups of <i class="systemitem.sitename">pronto.cv.hp.com.cv.hp.com</I
> and <i class="systemitem.sitename">pronto.cv.hp.com.hp.com</I
> before the resolver
looks up <i class="systemitem.sitename">pronto.cv.hp.com</I
> by
itself.  A user typing:</P
><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>telnet asap</B
></CODE
></PRE
></BLOCKQUOTE
><p class="para">on the same host would cause the resolver to look up <i class="systemitem.sitename">asap.cv.hp.com</I
> and <i class="systemitem.sitename">asap.hp.com</I
>, but not just <i class="systemitem.sitename">asap</I
>, since the name typed
(<span class="quote">"<i class="systemitem.sitename">asap</I
>"</SPAN
>)
contains no dots.</P
><p class="para">Note that application of the search list stops as soon as a
prospective domain name turns up the data being looked up. In the
<i class="systemitem.sitename">asap</I
> example, the search list
would never get around to appending <i class="systemitem.sitename">hp.com</I
> if <i class="systemitem.sitename">asap.cv.hp.com</I
> resolved to an
address.</P
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-4619">6.1.2.2 The <span class="acronym">DNS</SPAN
> 4.9 and later search list</A
></H4
><p class="para">With <span class="acronym">DNS</SPAN
> 4.9, the default search list
includes just the default domain.  So, if you configure a host
with:</P
><blockquote class="screen"><pre class="screen">domain cv.hp.com</PRE
></BLOCKQUOTE
><p class="para">the default search list would contain just <i class="systemitem.sitename">cv.hp.com</I
>.  Also, in a change from earlier
resolvers, the search list is usually applied
<em class="emphasis">after</EM
> the name is tried as is. As long as the
argument you type has at least one dot in it, it's looked up exactly
as you typed it <em class="emphasis">before</EM
> any element of the search
list is appended. If that lookup fails, the search list is
applied. Even if the argument has no dots in it (that is, it's a
single label name), it's tried as-is, after the resolver appends the
elements of the search list.</P
><p class="para">Why is it better to try the argument
<i class="foreignphrase">literatim</I
> first? From experience, the
designers of <span class="acronym">DNS</SPAN
> found that, more often than not,
if a user bothered to type in a name with even a single dot in it, he
was probably typing in a fully qualified domain name without the
trailing dot. With older search list behavior, the resolver would send
several fruitless queries before ever trying the name as typed.</P
><p class="para">Therefore, with a 4.9 resolver, a user typing:</P
><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>telnet pronto.cv.hp.com</B
></CODE
></PRE
></BLOCKQUOTE
><p class="para">would have <i class="systemitem.sitename">pronto.cv.hp.com</I
> looked up first (there are
three dots in the argument). If that query failed, the resolver would
try <i class="systemitem.sitename">pronto.cv.hp.com.cv.hp.com</I
>.
A user typing:</P
><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>telnet asap</B
></CODE
></PRE
></BLOCKQUOTE
><p class="para">on the same host would cause the resolver to look up <i class="systemitem.sitename">asap.cv.hp.com</I
> first, since the name
doesn't contain a dot, and then just <i class="systemitem.sitename">asap</I
>.<a class="indexterm" name="AUTOID-4643"></A
><a class="indexterm" name="AUTOID-4644"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-4645">6.1.3 The search Directive</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-4648"></A
>What if you don't like the default search list you get when you set
your default domain? In <span class="acronym">DNS</SPAN
> 4.8.3 and all newer
resolvers, you can set the search list explicitly, domain by domain,
in the order you want the domains searched. You do this with the
<i class="structfield">search</I
> directive.</P
><p class="para">The syntax of the <i class="structfield">search</I
> directive is
very similar to that of the <i class="structfield">domain</I
>
directive, except that it can take multiple domain names as
arguments. The keyword <i class="structfield">search</I
> starts the
line in column one, followed by from one to six domain names, in the
order you want them searched. The first domain in the list is
interpreted as the default domain, so the
<i class="structfield">search</I
> and
<i class="structfield">domain</I
> directives are mutually
exclusive. If you use both in <i class="filename">resolv.conf</I
>, the
one that appears last will override the other.</P
><p class="para">The directive:</P
><blockquote class="screen"><pre class="screen">search corp.hp.com paloalto.hp.com hp.com</PRE
></BLOCKQUOTE
><p class="para">for example, would instruct the resolver to search the
<i class="systemitem.sitename">corp.hp.com</I
> domain first, then
<i class="systemitem.sitename">paloalto.hp.com</I
>, and then both
domains' parent, <i class="systemitem.sitename">hp.com</I
>.</P
><p class="para">This directive might be useful on a host whose users access
hosts in both <i class="systemitem.sitename">corp.hp.com</I
> and
<i class="systemitem.sitename">paloalto.hp.com</I
> frequently.  On
the other hand, on a <span class="acronym">DNS</SPAN
> 4.8.3 resolver, the
directive:</P
><blockquote class="screen"><pre class="screen">search corp.hp.com</PRE
></BLOCKQUOTE
><p class="para">would have the resolver skip searching the default domain's
parent domain when the search list is applied. (On a 4.9 resolver, the
parent domain isn't in the search list, so this is no different from
the default behavior.) This might be useful if the host's users only
access hosts in the local domain, or if connectivity to the parent
name servers isn't good (because it minimizes unnecessary queries to
the parent name servers).</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> If you use the<a class="indexterm" name="AUTOID-4673"></A
>
<i class="structfield">domain</I
> directive and update your resolver
to <span class="acronym">DNS</SPAN
> version 4.9 or later, users who relied on
your default domain's parent being in the search list may believe the
resolver has suddenly broken. You can restore the old behavior by
using the <i class="structfield">search</I
> directive to configure
your resolver to use the same search list that it would have built
before. For example, under <span class="acronym">DNS</SPAN
> 4.9 or
<span class="acronym">DNS</SPAN
> 8, you can replace <em class="emphasis">domain
nsr.hp.com</EM
> with <em class="emphasis">search nsr.hp.com
hp.com</EM
> and get the same functionality.</P
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-4682">6.1.4 The nameserver Directive</A
></H3
><p class="para"><a class="indexterm" name="DNS3-IDX-6-NAMESERVER-DIRECTIVE"></A
><a class="indexterm" name="DNS3-IDX-6-NAME-SERVERS-SELECTING-FOR-RESOLVER"></A
>Back in <a class="xref" href="ch04_01.htm" title="Setting Up BIND">Chapter 4</A
>, we talked about two types of name
servers: primary master name servers and slave name servers. But what
if you don't want to run a name server on a host, yet still want to
use <span class="acronym">DNS</SPAN
>?  Or, for that matter, what if you
<em class="emphasis">can't</EM
> run a name server on a host (because the
operating system doesn't support it, for example)? Surely you don't
have to run a name server on <em class="emphasis">every</EM
> host,
right?</P
><p class="para">No, of course you don't. By default, the resolver looks for a
name server running on the local host&nbsp;- which is why we could use
<kbd class="command">nslookup</KBD
> on <i class="systemitem.sitename">terminator</I
> and <i class="systemitem.sitename">wormhole</I
> right after we configured their
name servers. You can, however, instruct the resolver to look to
another host for name service. This configuration is called a<a class="indexterm" name="AUTOID-4698"></A
>
<i class="firstterm"><span class="acronym">DNS</SPAN
> client</I
> in the
<cite class="citetitle"><span class="acronym">BIND</SPAN
> Operations Guide</CITE
>.</P
><p class="para">The <i class="structfield">nameserver</I
> directive (yep, all
one word) tells the resolver the <span class="acronym">IP</SPAN
> address of a
name server to query. For example, the line:</P
><blockquote class="screen"><pre class="screen">nameserver 15.32.17.2</PRE
></BLOCKQUOTE
><p class="para">instructs the resolver to send queries to the name server
running at <span class="acronym">IP</SPAN
> address 15.32.17.2, instead of to the
local host. This means that on hosts that don't run name servers, you
can use the <i class="structfield">nameserver</I
> directive to point
them at a remote name server. Typically, you would configure the
resolvers on your hosts to query your own name servers.</P
><p class="para">However, since name servers before <span class="acronym">DNS</SPAN
> 4.9
don't have any notion of access control, you can configure your
resolver to query almost anyone's name server. Of course, configuring
your host to use someone else's name server without first asking
permission is presumptuous, if not downright rude, and using one of
your own will usually give you better performance, so we'll consider
this only an emergency option.</P
><p class="para"><a class="indexterm" name="AUTOID-4715"></A
><a class="indexterm" name="AUTOID-4718"></A
>You can also configure the resolver to query the host's local name
server, by using either the local host's <span class="acronym">IP</SPAN
> address
or the zero address.  The zero address, 0.0.0.0, is interpreted by
most <span class="acronym">TCP</SPAN
>/<span class="acronym">IP</SPAN
> implementations to
mean <span class="quote">"this host."</SPAN
> The host's real <span class="acronym">IP</SPAN
>
address, of course, also means <span class="quote">"this host."</SPAN
> On hosts that
don't understand the zero address, you can use the loopback address,
127.0.0.1.</P
><p class="para"><a class="indexterm" name="AUTOID-4727"></A
><a class="indexterm" name="AUTOID-4730"></A
>Now what if the name server your resolver queries is down? Isn't there
any way to specify a backup? Do you just fall back to using the host
table?</P
><p class="para">The resolver will also allow you to specify up to three (count
'em, three) name servers using multiple
<i class="structfield">nameserver</I
> directives. The resolver will
query those name servers, in the order listed, until it receives an
answer or times out. The number of name servers you configure dictates
other aspects of the resolver's behavior, too.</P
><blockquote class="note"><p class="para"><strong>NOTE:</STRONG
> If you use multiple <i class="structfield">nameserver</I
>
directives, <em class="emphasis">don't</EM
> use the<a class="indexterm" name="AUTOID-4739"></A
><a class="indexterm" name="AUTOID-4741"></A
><a class="indexterm" name="AUTOID-4744"></A
>
loopback address! There's a bug in some Berkeley-derived
<span class="acronym">TCP</SPAN
>/<span class="acronym">IP</SPAN
> implementations that can
cause problems with <span class="acronym">DNS</SPAN
> if the local name server is
down.  The resolver's connected datagram socket won't rebind to a new
local address if the local name server isn't running, and consequently
the resolver will send query packets to the fallback remote name
servers with a source address of 127.0.0.1. When the remote name
servers try to reply, they'll end up sending the reply packets to
themselves.</P
></BLOCKQUOTE
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-4750">6.1.4.1 One name server configured</A
></H4
><p class="para"><a class="indexterm" name="AUTOID-4753"></A
><a class="indexterm" name="AUTOID-4756"></A
>If there's only one name server configured, the resolver queries that
name server with a timeout of five seconds.  The timeout is the length
of time the resolver will wait for a response from the name server
before sending another query. If the resolver encounters an<a class="indexterm" name="AUTOID-4759"></A
>
error that indicates the name server is really down or unreachable, or
if it times out, it will double the timeout and query the name server
again. The errors that would cause this include:[5]</P
><blockquote class="footnote"><p class="para">[5] When we say <span class="quote">"one name server configured,"</SPAN
> that
means either one <i class="structfield">nameserver</I
> directive in
<i class="filename">resolv.conf</I
> or no
<i class="structfield">nameserver</I
> directive with a name server
running locally.</P
></BLOCKQUOTE
><ul class="itemizedlist"><li class="listitem"><p class="para">Receipt of an
<span class="acronym">ICMP</SPAN
><a class="indexterm" name="AUTOID-4772"></A
><a class="indexterm" name="AUTOID-4774"></A
><a class="indexterm" name="AUTOID-4776"></A
>
<tt class="computeroutput">port unreachable</TT
> message, which means
that no name server is listening on the name server port</P
></LI
><li class="listitem"><p class="para">Receipt of an <span class="acronym">ICMP</SPAN
> <tt class="computeroutput">host
unreachable</TT
> or <tt class="computeroutput">network
unreachable</TT
> message, which means that queries can't
be sent to the destination <span class="acronym">IP</SPAN
> address</P
></LI
></UL
><p class="para">If the domain name or data don't exist, the resolver doesn't
retry the query. Theoretically, at least, each name server should have
an equivalent <span class="quote">"view"</SPAN
> of the name space; there's no reason
to believe one and not another. So if one name server tells you that a
given domain name doesn't exist, or that the type of data you're
looking for doesn't exist for the domain name you specified, any other
name server should give you the same answer.[6] If the resolver receives a network error
<em class="emphasis">each</EM
> time it sends a query (for a total of four
errors), it falls back to using the host table. Note that these are
<em class="emphasis">errors</EM
>, not timeouts. If it times out on even one
query, the resolver returns a null answer and does not fall back to
<i class="filename">/etc/hosts</I
>.</P
><blockquote class="footnote"><p class="para">[6] The built-in latency of <span class="acronym">DNS</SPAN
> makes this a
small fib&nbsp;- a primary can have authority for a zone and have
different data from a slave that also has authority for the zone. The
primary may have just loaded new zone data from disk, while the slave
may not have had time to transfer the new zone data from the
primary. Both name servers return authoritative answers for the zone,
but the primary may know about a brand-new host that the slave doesn't
yet know about.</P
></BLOCKQUOTE
></DIV
><div class="sect3"><h4 class="sect3"><a class="title" name="AUTOID-4793">6.1.4.2 More than one name server configured</A
></H4
><p class="para">With more than one name server configured, the behavior is a
little different.  Here's what happens: the resolver starts by
querying the first name server in the list, with a timeout of five
seconds, just as in the single name server case. If the resolver times
out or receives a network error, it will fall back to the next name
server, waiting the same five seconds for that name
server. Unfortunately, the resolver won't receive many of the possible
errors; the socket the resolver uses is <span class="quote">"unconnected,"</SPAN
>
since it must be able to receive responses from any of the name
servers it queries, and unconnected sockets don't receive
<span class="acronym">ICMP</SPAN
> error messages. If the resolver queries all
the configured name servers, to no avail, it updates the timeouts and
cycles through them again.</P
><p class="para">The resolver timeout for the next round of queries is based on
the number of name servers configured in
<i class="filename">resolv.conf</I
>.  The timeout for the second round of
queries is ten seconds divided by the number of name servers
configured, rounded down. Each successive round's timeout is double
the previous timeout. After three sets of retransmissions (a total of
four timeouts for every name server configured), the resolver gives up
trying to query name servers.</P
><p class="para">For you mathophobes, <a class="xref" href="#DNS3-CHP-6-TAB-1" title="Resolver Timeouts">Table 6.1</A
> shows
what the timeouts look like when you have one, two, or three name
servers configured.</P
><table class="table"><caption class="table"><a class="title" name="DNS3-CHP-6-TAB-1">Table 6.1: Resolver Timeouts</A
></CAPTION
><thead class="thead"><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para"></P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Name Servers Configured</P
></TH
></TR
><tr class="row" valign="TOP"><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">Retry</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">1</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">2</P
></TH
><th class="entry" align="LEFT" rowspan="1" colspan="1"><p class="para">3</P
></TH
></TR
></THEAD
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">Total</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">75s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">80s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">81s</P
></TD
></TR
><tbody class="tbody"><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">0</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">5s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">(2x) 5s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">(3x) 5s</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">1</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">10s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">(2x) 5s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">(3x) 3s</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">2</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">20s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">(2x) 10s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">(3x) 6s</P
></TD
></TR
><tr class="row" valign="TOP"><td class="entry" rowspan="1" colspan="1"><p class="para">3</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">40s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">(2x) 20s</P
></TD
><td class="entry" rowspan="1" colspan="1"><p class="para">(3x) 13s</P
></TD
></TR
></TBODY
></TABLE
><p class="para">(Note that this is how <span class="acronym">DNS</SPAN
> versions 4.9 and
later behave. The behavior of older versions of <span class="acronym">DNS</SPAN
>
is similar, but not necessarily identical.)</P
><p class="para">So if you configure three servers, the resolver queries the
first server, with a timeout period of five seconds. If that query
times out, the resolver queries the second server with the same
timeout, and similarly for the third.  If the resolver cycles through
all three servers, it doubles the timeout period and divides by three
(to three seconds, 10/3 rounded down) and queries the first server
again.</P
><p class="para">Do these times seem awfully long? Remember, this describes a
worst-case scenario. With properly-functioning name servers running on
tolerably fast hosts, your resolvers should get their answers back in
well under a second.  Only if all the configured servers are really
busy or they or your network is down will the resolver ever make it
all the way through the retransmission cycle and give up.</P
><p class="para">What does the resolver do after it gives up? It times out and
returns an error. Typically this results in an error like:</P
><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>telnet tootsie</B
></CODE
>
tootsie: Host name lookup failure</PRE
></BLOCKQUOTE
><p class="para">Of course, it'll take at least 75 seconds of waiting to see this
message, so be patient.<a class="indexterm" name="AUTOID-4880"></A
><a class="indexterm" name="AUTOID-4881"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-4882">6.1.5 The sortlist Directive</A
></H3
><p class="para">The<a class="indexterm" name="AUTOID-4885"></A
><a class="indexterm" name="AUTOID-4887"></A
><a class="indexterm" name="AUTOID-4889"></A
>
<i class="structfield">sortlist</I
> directive is a mechanism in
<span class="acronym">DNS</SPAN
> 4.9 and later resolvers that lets you specify
subnets and networks for the resolver to prefer if it receives
multiple addresses as the result of a query. In some cases, you'll
have reason to want your host to use a particular network to get to
certain destinations.  For example, say your workstation and your
<span class="acronym">NFS</SPAN
> server have two network interfaces each: one on
an Ethernet, subnet 128.32.1; and one on an <span class="acronym">FDDI</SPAN
>
ring, subnet 128.32.42. If you leave your workstation's resolver to
its own devices, it's anybody's guess which of the
<span class="acronym">NFS</SPAN
> server's <span class="acronym">IP</SPAN
> addresses you'll
use for a mount&nbsp;- presumably, the first one in a reply packet from
the name server. To make sure you try the interface on the
<span class="acronym">FDDI</SPAN
> ring first, you can add a
<i class="structfield">sortlist</I
> directive to
<i class="filename">resolv.conf</I
> that sorts the address on 128.32.42
to the preferred position in the structure passed back to
programs:</P
><blockquote class="screen"><pre class="screen">sortlist 128.32.42.0/255.255.255.0</PRE
></BLOCKQUOTE
><p class="para">The argument after the slash is the subnet mask for the subnet
in question. To prefer an entire network, you can omit the slash and
the subnet mask:</P
><blockquote class="screen"><pre class="screen">sortlist 128.32.0.0</PRE
></BLOCKQUOTE
><p class="para">The resolver will assume you mean the entire class B network
128.32. (The resolver derives the default unsubnetted net mask for the
network from the first few bits of the <span class="acronym">IP</SPAN
>
address.)</P
><p class="para">And, of course, you can specify several subnets and networks to
prefer over others:</P
><blockquote class="screen"><pre class="screen">sortlist 128.32.42.0/255.255.255.0 15.0.0.0</PRE
></BLOCKQUOTE
><p class="para">The resolver sorts any addresses in a reply that match these
arguments into the order in which they appear in the directive, and
appends addresses that don't match to the end.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-4909">6.1.6 The options Directive</A
></H3
><p class="para">The<a class="indexterm" name="AUTOID-4912"></A
><a class="indexterm" name="AUTOID-4914"></A
><a class="indexterm" name="AUTOID-4916"></A
>
<i class="structfield">options</I
> directive was introduced with
<span class="acronym">DNS</SPAN
> 4.9. <i class="structfield">options</I
> will
let you tweak two internal resolver settings. The first is the debug
flag, <i class="envar">RES_DEBUG</I
>. The directive:</P
><blockquote class="screen"><pre class="screen">options debug<a class="indexterm" name="AUTOID-4924"></A
><a class="indexterm" name="AUTOID-4926"></A
></PRE
></BLOCKQUOTE
><p class="para">sets <i class="envar">RES_DEBUG</I
>, producing lots of exciting
debugging information on standard output, assuming your resolver was
configured with <i class="envar">DEBUG</I
> defined. (Actually, that may not
be a good assumption, since most vendors compile their stock resolvers
without <i class="envar">DEBUG</I
> defined.)  This is very useful if you're
attempting to diagnose a problem with your resolver or with name
service in general, but very annoying otherwise.</P
><p class="para"><a class="indexterm" name="AUTOID-4934"></A
>The second setting you can modify is<a class="indexterm" name="AUTOID-4937"></A
><a class="indexterm" name="AUTOID-4939"></A
><a class="indexterm" name="AUTOID-4942"></A
>
<i class="structfield">ndots</I
>, which sets the minimum number of
dots a domain name argument must have so that the resolver will look
it up <em class="emphasis">before</EM
> applying the search list. By
default, one or more dots will do; this is equivalent to
<em class="emphasis">ndots:1</EM
>. The resolver will try the domain name as
typed first as long as the name has any dots in it. You can raise the
threshold if you believe your users are more likely to type partial
domain names that will need the search list applied. For example, if
your default domain is <i class="systemitem.sitename">mit.edu</I
>
and your users are accustomed to typing:</P
><blockquote class="screen"><pre class="screen">% <code class="userinput"><b>ftp prep.ai</B
></CODE
></PRE
></BLOCKQUOTE
><p class="para">and having <i class="systemitem.sitename">mit.edu</I
>
automatically appended to produce <i class="systemitem.sitename">prep.ai.mit.edu</I
>, then you may want to raise
<i class="structfield">ndots</I
> to two so that your users won't
unwittingly cause lookups to the root name servers for names in the
top-level <i class="systemitem.sitename">ai</I
> domain. You could
do this with:</P
><blockquote class="screen"><pre class="screen">options ndots:2</PRE
></BLOCKQUOTE
><p class="para">You can combine both option settings on the same line in
<i class="filename">resolv.conf</I
>, like so:</P
><blockquote class="screen"><pre class="screen">options debug ndots:2</PRE
></BLOCKQUOTE
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-4960">6.1.7 Comments</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-4963"></A
><a class="indexterm" name="AUTOID-4966"></A
><a class="indexterm" name="AUTOID-4968"></A
>Also introduced with <span class="acronym">DNS</SPAN
> 4.9 resolvers, and about
time, if you ask us, is the ability to put comments in the
<i class="filename">resolv.conf</I
> file.<a class="indexterm" name="AUTOID-4972"></A
><a class="indexterm" name="AUTOID-4974"></A
>
Lines that begin with a pound sign or semi-colon in the first column
are interpreted as comments and ignored by the resolver.</P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="AUTOID-4976">6.1.8 A Note on the 4.9 Resolver Directives</A
></H3
><p class="para"><a class="indexterm" name="AUTOID-4979"></A
><a class="indexterm" name="AUTOID-4982"></A
><a class="indexterm" name="AUTOID-4985"></A
>If you're just moving to a <span class="acronym">DNS</SPAN
> 4.9.3 or 4.9.4
resolver, be careful when using the new directives. You may still have
older resolver code statically linked into programs on your
host. Often, this isn't a problem because <span class="acronym">UNIX</SPAN
>
resolvers ignore directives they don't understand. But don't count on
all programs on your host obeying the new directive.</P
><p class="para">If you're running on a host with programs that include really
old resolver code, before 4.8.3, and you'd still like to use the
<i class="structfield">search</I
> directive with programs that can
take advantage of it, here's a trick: use both a
<i class="structfield">domain</I
> directive and a
<i class="structfield">search</I
> directive in
<i class="filename">resolv.conf</I
>, with the
<i class="structfield">domain</I
> directive first. Old resolvers will
read the <i class="structfield">domain</I
> directive and ignore the
<i class="structfield">search</I
> directive, because they won't
recognize it. New resolvers will read the
<i class="structfield">domain</I
> directive, but the following
<i class="structfield">search</I
> directive will override its
behavior.<a class="indexterm" name="AUTOID-5000"></A
></P
></DIV
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch05_03.htm" title="5.3 The MX Algorithm"><img src="../gifs/txtpreva.gif" alt="Previous: 5.3 The MX Algorithm" border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="DNS &amp; BIND"><img src="../gifs/txthome.gif" alt="DNS &amp; BIND" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch06_02.htm#AUTOID-5044" title="6.2 Sample Resolver Configurations"><img src="../gifs/txtnexta.gif" alt="Next: 6.2 Sample Resolver Configurations" border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">5.3 The MX Algorithm</TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">6.2 Sample Resolver Configurations</TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="../tcpip/index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="../puis/index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
