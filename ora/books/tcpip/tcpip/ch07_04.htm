<html><head>
<title>[Chapter 7] 7.4 Interior Routing Protocols </TITLE>
<meta name="DC.title" content="TCP/IP Network Administration"><meta name="DC.creator" content="Craig Hunt"><meta name="DC.publisher" content="O'Reilly &amp; Associates, Inc."><meta name="DC.date" content="1999-02-04T01:35:37Z"><meta name="DC.type" content="Text.Monograph"><meta name="DC.format" content="text/html" scheme="MIME"><meta name="DC.source" content="1-56592-322-7" scheme="ISBN"><meta name="DC.language" content="en-US"><meta name="generator" content="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><link rev="made" href="mailto:online-books@oreilly.com" title="Online Books Comments"><link rel="up" href="ch07_01.htm" title="7. Configuring Routing "><link rel="prev" href="ch07_03.htm" title="7.3 Building a Static Routing Table "><link rel="next" href="ch07_05.htm#TCP2-CH-7-SECT-5.1" title="7.5 Exterior Routing Protocols "></HEAD
><body bgcolor="#FFFFFF" text="#000000"><div class="htmlnav"><h1><img src="gifs/smbanner.gif" alt="TCP/IP Network Administration" usemap="#srchmap" border="0"></H1
><map name=index.html"srchmap"><area shape="RECT" coords="0,0,466,65" href="index.htm" alt="TCP/IP Network Administration"><area shape="RECT" coords="467,0,514,18" href="../search/tsrch.htm" alt="Search this book"></MAP
><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch07_03.htm" title="7.3 Building a Static Routing Table "><img src="../gifs/txtpreva.gif" alt="Previous: 7.3 Building a Static Routing Table " border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><b><font face="ARIEL,HELVETICA,HELV,SANSERIF" size="-1">Chapter 7<br>Configuring Routing </FONT
></B
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch07_05.htm#TCP2-CH-7-SECT-5.1" title="7.5 Exterior Routing Protocols "><img src="../gifs/txtnexta.gif" alt="Next: 7.5 Exterior Routing Protocols " border="0"></A
></TD
></TR
></TABLE
>&nbsp;<hr align="LEFT" width="515" title="footer"></DIV
><div class="SECT1"><h2 class="sect1"><a class="title" name="TCP2-CH-7-SECT-4">7.4 Interior Routing Protocols </A
></H2
><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-ROUTING-PROTOCOLS-INTERIOR"></A
>Routing protocols are divided into two general groups: <em class="emphasis">interior</EM
>
and <em class="emphasis">exterior</EM
> protocols. An interior protocol is a routing
protocol used inside&nbsp;- interior to&nbsp;- an independent network system. In
TCP/IP terminology, these independent network systems are called
autonomous systems.
[9]
Within an autonomous system (AS), routing information is exchanged<a class="indexterm" name="AUTOID-7970"></A
>
using an interior protocol chosen by the autonomous system's
administration.</P
><blockquote class="footnote"><p class="para">[9] Autonomous systems are described in <a class="xref" href="ch02_01.htm" title="Delivering the Data">Chapter 2, <cite class="chapter">Delivering the Data</CITE
></A
>.</P
></BLOCKQUOTE
><p class="para">All interior routing protocols perform the same basic functions. They
determine the &quot;best&quot; route to each destination, and they distribute
routing information among the systems on a network. How they perform
these functions, in particular, how they decide which routes are best,
is what makes routing protocols different from each other. There are
several interior protocols:</P
><ul class="itemizedlist"><li class="listitem"><p class="para">The <em class="emphasis">Routing Information Protocol</EM
> (RIP) is the interior protocol
most commonly used on UNIX systems. RIP is included as part of the UNIX
software delivered with most systems. It is adequate for local area
networks and is simple to configure.

RIP selects the route with the lowest &quot;hop count&quot; (<em class="emphasis">metric</EM
>) as the
best route. The RIP hop count represents the number of gateways through
which data must pass to reach its destination. RIP assumes that the
best route is the one that uses the fewest gateways. This approach to
route choice is called a <em class="emphasis">distance-vector algorithm</EM
>.<a class="indexterm" name="AUTOID-7979"></A
></P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-7984"></A
><em class="emphasis">Hello</EM
> is a protocol that uses delay as the deciding factor when
choosing the best route. <em class="emphasis">Delay</EM
> is the length of time it takes a
datagram to make the round trip between its source and destination. A
Hello packet contains a time stamp indicating when it was sent. When the
packet arrives at its destination, the receiving system subtracts the
time stamp from the current time, to estimate how long it took the packet
to arrive. Hello is not widely used. It was the interior protocol of
the original 56 kbps NSFNET backbone and has had very little use otherwise.<a class="indexterm" name="AUTOID-7989"></A
></P
></LI
><li class="listitem"><p class="para"><a class="indexterm" name="AUTOID-7994"></A
><em class="emphasis">Intermediate System to Intermediate System</EM
> (IS-IS) is an interior
routing protocol from the OSI protocol suite. It is a <em class="emphasis">Shortest
Path First</EM
> (SPF) <em class="emphasis">link-state</EM
> protocol. It was the interior<a class="indexterm" name="AUTOID-7999"></A
><a class="indexterm" name="AUTOID-8001"></A
>
routing protocol used on the T1 NSFNET backbone, and it is still used by
some large service providers.</P
></LI
><li class="listitem"><p class="para"><em class="emphasis">Open Shortest Path First</EM
> (OSPF) is another link-state protocol
developed for TCP/IP. It is suitable for very large networks and
provides several advantages over RIP.</P
></LI
></UL
><p class="para">Of these protocols, we will discuss RIP and OSPF in detail. OSPF
is widely used on routers. RIP is widely used on UNIX systems. We
will start the discussion with RIP.</P
><div class="sect2"><h3 class="sect2"><a class="title" name="TCP2-CH-7-SECT-4.1">7.4.1 Routing Information Protocol </A
></H3
><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-ROUTING-INFORMATION-PROTOCOL-RIP"></A
>As delivered with most UNIX systems, Routing Information Protocol<a class="indexterm" name="AUTOID-8013"></A
>
(RIP) is run by the routing daemon <b class="emphasis.bold">routed</B
> (pronounced &quot;route&quot;
&quot;d&quot;). When <b class="emphasis.bold">routed</B
> starts, it issues a request for<a class="indexterm" name="AUTOID-8018"></A
>
routing updates and then listens for responses to its request. When a
system configured to supply RIP information hears the request, it
responds with an update packet based on the information in its routing<a class="indexterm" name="AUTOID-8020"></A
>
table. The update packet contains the destination addresses from the
routing table and the routing metric associated with each destination.
Update packets are issued in response to requests, as well as
periodically to keep routing information accurate.</P
><p class="para">To build the routing table, <b class="emphasis.bold">routed</B
> uses the information in the update packets. If the routing update contains a route to a destination
that does not exist in the local routing table, the new route is added.
If the update describes a route whose destination is already in the
local table, the new route is used only if it has a lower cost. The
cost of a route is determined by adding the cost of reaching the
gateway that sent the update to the metric contained in the RIP update
packet. If the total metric is less than the metric of the current
route, the new route is used.</P
><p class="para">RIP also deletes routes from the routing table. It accomplishes this in
two ways. First, if the gateway to a destination says the cost of
the route is greater than 15, the route is deleted. Second, RIP
assumes that a gateway that doesn't send updates is dead. All routes
through a gateway are deleted if no updates are received from that
gateway for a specified time period. In general, RIP issues routing updates
every 30 seconds. In many implementations, if a gateway does not
issue routing updates for 180 seconds, all routes through that gateway
are deleted from the routing table.</P
><div class="sect3"><h4 class="sect3"><a class="title" name="TCP2-CH-7-SECT-4.1.1">7.4.1.1 Running RIP with routed </A
></H4
><p class="para"><a class="indexterm" name="AUTOID-8029"></A
>To run RIP using the routing daemon (<b class="emphasis.bold">routed</B
>),
[10]
enter the following command:</P
><blockquote class="footnote"><p class="para">[10] On some systems the routing daemon is <b class="emphasis.bold">in.routed</B
>.</P
></BLOCKQUOTE
><p class="para"><blockquote class="screen"><pre class="screen"># <code class="userinput"><b>routed</B
></CODE
></PRE
></BLOCKQUOTE
></P
><p class="para">The <b class="emphasis.bold">routed</B
> statement is often used without any command-line
arguments, but you may want to use the <b class="emphasis.bold">-q</B
> option. The <b class="emphasis.bold">-q</B
>
option prevents <b class="emphasis.bold">routed</B
> from advertising routes. It just listens
to the routes advertised by other systems. If your computer is not a
gateway, you should probably use the <b class="emphasis.bold">-q</B
> option.</P
><p class="para">In the section on static routing we commented out the <b class="emphasis.bold">routed</B
>
statement found in a startup file. If that statement is in your
startup file, no other action is required to run RIP; just boot your system
and RIP will run. Otherwise, add the <b class="emphasis.bold">routed</B
> command to your
startup.</P
><p class="para"><b class="emphasis.bold">routed</B
> reads <em class="emphasis">/etc/gateways</EM
> at startup and adds its<a class="indexterm" name="AUTOID-8051"></A
><a class="indexterm" name="AUTOID-8055"></A
>
information to the routing table. <b class="emphasis.bold">routed</B
> can build a functioning
routing table simply by using the RIP updates received from the RIP
suppliers. However, it is sometimes useful to supplement this
information with, for example, an initial default route or information
about a gateway that does not announce its routes. The
<em class="emphasis">/etc/gateways</EM
> file stores this additional routing information.</P
><p class="para">The most common use of the <em class="emphasis">/etc/gateways</EM
> file is to define an<a class="indexterm" name="AUTOID-8062"></A
>
active default route, so we'll use that as an example. This one
example is sufficient because all entries in the <em class="emphasis">/etc/gateways</EM
>
file have the same basic format. On <em class="emphasis">peanut</EM
>, the following entry
specifies <em class="emphasis">almond</EM
> as the default gateway:</P
><p class="para"><blockquote class="screen"><pre class="screen">net 0.0.0.0 gateway 172.16.12.1 metric 1 active</PRE
></BLOCKQUOTE
></P
><p class="para">The entry starts with the keyword <code class="literal">net</CODE
>. All entries start with
the keyword <code class="literal">net</CODE
> or the keyword <code class="literal">host</CODE
> to indicate whether the
address that follows is a network address or a host address. The
destination address 0.0.0.0 is the address used for the default route.
In the <b class="emphasis.bold">route</B
> command we used the keyword <code class="literal">default</CODE
> to
indicate this route, but in <em class="emphasis">/etc/gateways</EM
> the default route is
indicated by network address 0.0.0.0.</P
><p class="para">Next is the keyword <code class="literal">gateway</CODE
> followed by the gateway's IP
address. In this case it is the address of <em class="emphasis">almond</EM
>
(172.16.12.1).</P
><p class="para">Then comes the keyword <code class="literal">metric</CODE
> followed by a numeric metric value.
The value, which is called the metric, is the cost of the route.
The metric was almost meaningless when used with static routing. Now
that we are running RIP, the metric is actually used to make routing
decisions. The RIP metric represents the number of gateways through
which data must pass to reach its final destination. But as we saw with
<b class="emphasis.bold">ifconfig</B
>, the metric is really an arbitrary value used by the<a class="indexterm" name="AUTOID-8084"></A
>
administrator to prefer one route over another. (The system
administrator is free to assign any metric value.) However, it is
useful to vary the metric only if you have more than one route to the same
destination. With only one gateway to the Internet, the correct metric
to use for <em class="emphasis">almond</EM
> is 1.</P
><p class="para">All <em class="emphasis">/etc/gateways</EM
> entries end with either the keyword
<code class="literal">passive</CODE
> or the keyword <code class="literal">active</CODE
>. &quot;Passive&quot; means the gateway<a class="indexterm" name="AUTOID-8092"></A
>
listed in the entry is not required to provide RIP updates. Use <code class="literal">passive</CODE
>
to prevent RIP from deleting the route if no updates are expected from
the gateway. A passive route is placed in the routing table and kept
there as long as the system is up. In effect, it becomes a permanent
static route.</P
><p class="para">The keyword <code class="literal">active</CODE
>, on the other hand, creates a route that can
be updated by RIP. An active gateway is expected to supply routing<a class="indexterm" name="AUTOID-8098"></A
>
information and will be removed from the routing table if, over a
period of time, it does not provide routing updates. Active routes are
used to &quot;prime the pump&quot; during the RIP startup phase, with the
expectation that the routes will be updated by RIP when the protocol is
up and running.</P
><p class="para">Our sample entry ends with the keyword <code class="literal">active</CODE
>, which means that
this default route will be deleted if no routing updates are received
from <em class="emphasis">almond</EM
>. Default routes are convenient; this is especially
true when you use static routing. But when you use dynamic routing,
default routes should be used with caution, especially if you have 
multiple gateways that can reach the same destination. A passive
default route prevents the routing protocol from dynamically updating
the route to reflect changing network conditions. Use an active default
route that can be updated by the routing protocol.</P
><p class="para">RIP is easy to implement and simple to configure. Perfect! Well, not
quite. RIP has three serious shortcomings:</P
><dl class="variablelist"><dt class="term"><em class="emphasis">Limited network diameter</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-ROUTING-INFORMATION-PROTOCOL-RIP-SHORTCOMINGS-OF"></A
><a class="indexterm" name="AUTOID-8114"></A
>The longest RIP route is 15 hops. A RIP router cannot maintain a
complete routing table for a network that has destinations more than
15 hops away. The hop count cannot be increased because of the second<a class="indexterm" name="AUTOID-8118"></A
>
shortcoming.</P
></DD
><dt class="term"><em class="emphasis">Slow convergence</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-8126"></A
>Deleting a bad route sometimes requires the exchange of multiple
routing update packets until the route's cost reaches 16. This is
called &quot;counting to infinity,&quot; because RIP keeps incrementing the
route's cost until it becomes greater than the largest valid RIP
metric. (In this case, 16 is infinity.) Additionally, RIP may wait 180
seconds before deleting the invalid routes.
In network-speak, we say that these conditions delay the
&quot;convergence of routing&quot;; i.e., it takes a long time for the routing<a class="indexterm" name="AUTOID-8128"></A
>
table to reflect the current state of the network.</P
></DD
><dt class="term"><em class="emphasis">Classful routing</EM
></DT
><dd class="listitem"><p class="para">RIP interprets all addresses using the class rules described in<a class="indexterm" name="AUTOID-8135"></A
>
<a class="xref" href="ch02_01.htm" title="Delivering the Data">Chapter 2</A
>. For RIP all addresses are class A, B, or C, which makes
RIP incompatible with CIDR supernets and incapable of supporting
variable-length subnets.</P
></DD
></DL
><p class="para">Nothing can be done to change the limited network diameter. A small metric
is essential to reduce the impact of counting to infinity. However,
limited network size is the least important of RIP's shortcomings. The real
work of improving RIP concentrates on the other two problems, slow convergence
and classful routing.</P
><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-COUNT-TO-INFINITY-PROBLEM"></A
>Features have been added to RIP to address slow convergence. Before
discussing them we must understand how the &quot;count-to-infinity&quot; problem
occurs. 
<a class="xref" href="#TCP2-CH-7-FIG-1" title="Sample network">Figure 7.2</A
>
illustrates a network where a counting-to-infinity
problem might happen.</P
><h4 class="figure"><a class="title" name="TCP2-CH-7-FIG-1">Figure 7.2: Sample network</A
></H4
><img class="graphic" src="figs/tcp2_0702.gif" alt="Figure 7.2"><p class="para"><a class="xref" href="#TCP2-CH-7-FIG-1" title="Sample network">Figure 7.2</A
>
shows that <em class="emphasis">almond</EM
> reaches subnet 3 through <em class="emphasis">pecan</EM
>
and then through <em class="emphasis">filbert</EM
>. Subnet 3 is 2 hops away from
<em class="emphasis">almond</EM
> and 1 hop away from <em class="emphasis">pecan</EM
>. Therefore <em class="emphasis">pecan</EM
>
advertises a cost of 1 for subnet 3 and <em class="emphasis">almond</EM
> advertises a
cost of 2, and traffic continues to be routed through
<em class="emphasis">pecan</EM
>. That is, until something goes wrong. If <em class="emphasis">filbert</EM
>
crashes, <em class="emphasis">pecan</EM
> waits for an update from <em class="emphasis">filbert</EM
> for 180
seconds. While waiting, <em class="emphasis">pecan</EM
> continues to send updates to
<em class="emphasis">almond</EM
> that keep the route to subnet 3 in <em class="emphasis">almond</EM
>'s routing
table. When <em class="emphasis">pecan</EM
>'s timer finally expires, it removes all routes
through <em class="emphasis">filbert</EM
> from its routing table, including the route to
subnet 3. It then receives an update from <em class="emphasis">almond</EM
> advertising
that <em class="emphasis">almond</EM
> is 2 hops away from subnet 3. <em class="emphasis">pecan</EM
> installs
this route and announces that it is 3 hops away from subnet 3.
<em class="emphasis">almond</EM
> receives this update, installs the route, and announces
that it is 4 hops away from subnet 3. Things continue on in this
manner until the cost of the route to subnet 3 reaches 16 in both
routing tables. If the update interval is 30 seconds, this could take
a long time!</P
><p class="para"><em class="emphasis">Split horizon</EM
> and <em class="emphasis">poison reverse</EM
> are two features that
attempt to avoid counting to infinity. Here's how:</P
><dl class="variablelist"><dt class="term"><em class="emphasis">Split horizon</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-8179"></A
>With this feature, a router does not advertise routes on the link from
which those routes were obtained. This would solve the
count-to-infinity problem described above. Using the split horizon rule,
<em class="emphasis">almond</EM
> would not announce the route to subnet 3 on subnet 12
because it learned that route from the updates it received from
<em class="emphasis">pecan</EM
> on subnet 12. While this feature works for the example
described above, it does not work for all count-to-infinity
configurations. (More on this later.)</P
></DD
><dt class="term"><em class="emphasis">Poison reverse</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-8188"></A
>This feature is an enhancement of split horizon. It uses the same
idea: &quot;Don't advertise routes on the link from which those routes were
obtained.&quot;  But it adds a positive action to that essentially negative rule.
Poison reverse says that a router should advertise an
infinite distance for routes on this link. With poison reverse,
<em class="emphasis">almond</EM
> would advertise subnet 3 with a cost of 16 to all
systems on subnet 12. The cost of 16 means that subnet 3 cannot
be reached through <em class="emphasis">almond</EM
>.</P
></DD
></DL
><p class="para">Split horizon and poison reverse solve the problem described above.
But what happens if <em class="emphasis">almond</EM
> crashes? Refer to 
<a class="xref" href="#TCP2-CH-7-FIG-1" title="Sample network">Figure 7.2</A
>
With split horizon, <em class="emphasis">salted</EM
> and <em class="emphasis">roasted</EM
> do not advertise to
<em class="emphasis">almond</EM
> the route to subnet 12 because they learned the route from
<em class="emphasis">almond</EM
>. They do, however, advertise the route to subnet 12 to
each other. When <em class="emphasis">almond</EM
> goes down, <em class="emphasis">salted</EM
> and <em class="emphasis">roasted</EM
>
perform their own count to infinity before they remove the route to
subnet 12. <em class="emphasis">Triggered updates</EM
> address this problem.</P
><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-TRIGGERED-UPDATES"></A
>Triggered updates are a big help. Instead of waiting the normal
30-second update interval, a triggered update is sent immediately.
Therefore, when an upstream router crashes or a local link goes down,
immediately after the router updates its local routing table, it sends
the changes to its neighbors. Without triggered updates, counting to
infinity can take almost 8 minutes! With triggered updates, neighbors
are informed in a few seconds. Triggered updates also use network<a class="indexterm" name="AUTOID-8206"></A
>
bandwidth efficiently. They don't include the full routing table; they
include only the routes that have changed.</P
><p class="para">Triggered updates take positive action to eliminate bad routes. Using
triggered updates, a router advertises the routes deleted from its
routing table with a infinite cost to force downstream routers to also
remove them. Again, look at 
<a class="xref" href="#TCP2-CH-7-FIG-1" title="Sample network">Figure 7.2</A
>
If <em class="emphasis">almond</EM
> crashes, <em class="emphasis">roasted</EM
> and <em class="emphasis">salted</EM
> wait 180
seconds and remove the routes to subnets 1, 3, and 12 from their
routing tables. They then send each other triggered updates with a
metric of 16 for subnets 1, 3, and 12.  Thus they tell each other that
they cannot reach these networks and no count to infinity
occurs. Split horizon, poison reverse, and triggered updates go a long
way to eliminating counting to infinity.<a class="indexterm" name="AUTOID-8214"></A
><a class="indexterm" name="AUTOID-8215"></A
></P
><p class="para">It is the final shortcoming&nbsp;- the fact that RIP is incompatible with
CIDR supernets and variable-length subnets&nbsp;- that caused the RIP
protocol to be moved to &quot;historical&quot; status in 1996. RIP is not
compatible with current and future plans for the TCP/IP protocol
stack. A new version of RIP had to be created to address this final
problem.<a class="indexterm" name="AUTOID-8217"></A
><a class="indexterm" name="AUTOID-8218"></A
></P
></DIV
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="TCP2-CH-7-SECT-4.2">7.4.2 RIP Version 2 </A
></H3
><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-RIP-VERSION-2-RIP-2"></A
>RIP Version 2 (RIP-2), defined in RFC 1723, is a new version of RIP.
It is not a completely new protocol. It simply defines extensions to
the RIP packet format. RIP-2 adds a network mask and a next hop address<a class="indexterm" name="AUTOID-8224"></A
><a class="indexterm" name="AUTOID-8228"></A
>
to the destination address and metric found in the original RIP
packet.</P
><p class="para">The network mask frees the RIP-2 router from the limitation of interpreting
addresses based on strict address class rules. The mask is applied to the
destination address to determine how the address should be interpreted.
Using the mask, RIP-2 routers support variable-length subnets and CIDR
supernets.</P
><p class="para">The next hop address is the IP address of the gateway that handles
the route. If the address is 0.0.0.0, the source of the update packet is
the gateway for the route. The next hop route permits a RIP-2 supplier
to provide routing information about gateways that do not speak RIP-2.
Its function is similar to an ICMP Redirect, pointing to the best gateway
for a route and eliminating extra routing hops.</P
><p class="para">RIP-2 adds other new features to RIP. It transmits updates via
the multicast address 224.0.0.9 to reduce the load on systems that are<a class="indexterm" name="AUTOID-8235"></A
>
not capable of processing a RIP-2 packet. RIP-2 also introduces a packet
authentication scheme to reduce the possibility of accepting erroneous<a class="indexterm" name="AUTOID-8238"></A
>
updates from misconfigured systems.</P
><p class="para">Despite these changes, RIP-2 is compatible with RIP. The original RIP
specification allowed for future versions of RIP. RIP has a version
number in the packet header, and it had several empty fields for extending
the packet. The new values used by RIP-2 did not require any changes
to the structure of the packet. The new values are simply placed in
the empty fields that the original protocol reserved for future use.
Properly implemented RIP routers can receive RIP-2 packets and extract
the data that they need from the packet without becoming confused by
the new data.</P
><p class="para">Split horizon, poison reverse, triggered updates, and RIP-2 eliminate
most of the problems with the original RIP protocol. But RIP-2 is
still a distance vector protocol. There are other, newer routing
technologies that are considered superior for large networks.  In
particular, <em class="emphasis">link-state</EM
> routing protocols are favored because<a class="indexterm" name="AUTOID-8244"></A
>
they provide rapid routing convergence and reduce the possibility of
routing loops.<a class="indexterm" name="AUTOID-8247"></A
></P
></DIV
><div class="sect2"><h3 class="sect2"><a class="title" name="TCP2-CH-7-SECT-4.3">7.4.3 Open Shortest Path First </A
></H3
><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-OPEN-SHORTEST-PATH-FIRST-OSPF-PROTOCOL"></A
><em class="emphasis">Open Shortest Path First</EM
> (OSPF), defined by RFC 2178, is a
<em class="emphasis">link-state</EM
> protocol. As such, it is very different from RIP.
A router running RIP shares information about the entire network with
its neighbors. Conversely, a router running OSPF shares information about its
neighbors with the entire network. The &quot;entire network&quot; means,
at most, a single autonomous system. RIP doesn't try to learn about
the entire Internet, and OSPF doesn't try to advertise to the entire
Internet. That's not their job. These are interior routing protocols;
and so their job is to construct the routing inside of an autonomous system.
OSPF further refines this task by defining a hierarchy of routing areas<a class="indexterm" name="AUTOID-8255"></A
>
within an autonomous system:</P
><dl class="variablelist"><dt class="term"><em class="emphasis">Areas</EM
></DT
><dd class="listitem"><p class="para">An <em class="emphasis">area</EM
> is an arbitrary collection of interconnected networks, hosts
and routers. Areas exchange routing information with other areas within
the autonomous system through <em class="emphasis">area border routers</EM
>.<a class="indexterm" name="AUTOID-8266"></A
></P
></DD
><dt class="term"><em class="emphasis">Backbone</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-8273"></A
>A <em class="emphasis">backbone</EM
> is a special area that interconnects all of the other 
areas within an autonomous system. Every area must connect to the backbone, 
because the backbone is responsible for distributing routing information 
between the areas.</P
></DD
><dt class="term"><em class="emphasis">Stub area</EM
></DT
><dd class="listitem"><p class="para"><a class="indexterm" name="AUTOID-8281"></A
>A <em class="emphasis">stub area</EM
> has only one area border 
router, which means that there is only one route out of the area. In this 
case, the area border router does not need to advertise external routes 
to the other routers within the stub area. It can simply advertise 
itself as the default route.</P
></DD
></DL
><p class="para">Only a large autonomous system needs to be subdivided into areas.
The sample network shown in 
<a class="xref" href="#TCP2-CH-7-FIG-1" title="Sample network">Figure 7.2</A
>
is small and would not need to
be divided. We can, however, use it as an example to illustrate the
different areas. We could divide this autonomous system into any areas
we wish. Assume we divide it into three areas: area 1 contains subnet
3; area 2 contains subnet 1 and subnet 12; and area 3 contains subnet
25, subnet 36, and the
PPP links. Furthermore, we could define area 1 as a stub area because
<em class="emphasis">filbert</EM
> is that area's only area border router. We also could
define area 2 as the backbone area because it interconnects the other
two areas and all routing information between areas 1 and 3 must
be distributed by area 2. Area 2 contains two area border routers,
<em class="emphasis">almond</EM
> and <em class="emphasis">filbert</EM
>, and one interior router, <em class="emphasis">pecan</EM
>.
Area 3 contains three routers: <em class="emphasis">almond</EM
>, <em class="emphasis">roasted</EM
>, and
<em class="emphasis">salted</EM
>.</P
><p class="para">Clearly OSPF provides lots of flexibility for subdividing an autonomous<a class="indexterm" name="AUTOID-8294"></A
>
system. But why is it necessary? One problem for a link-state protocol
is the large quantity of data that can be collected in the <em class="emphasis">link-state<a class="indexterm" name="AUTOID-8298"></A
>
database</EM
> and the amount of time it can take to calculate the routes
from that data. A look at the protocol shows why this is true.</P
><p class="para">Every OSPF router builds a <em class="emphasis">directed graph</EM
> of the entire network<a class="indexterm" name="AUTOID-8303"></A
>
using the Dijkstra Shortest Path First (SPF) algorithm. A directed<a class="indexterm" name="AUTOID-8305"></A
><a class="indexterm" name="AUTOID-8307"></A
><a class="indexterm" name="AUTOID-8310"></A
>
graph is a map of the network from the perspective of the router,
that is, the root of the graph is the router. The graph is built from the
link-state database, which includes information about every router on
the network and all the neighbors of every router. The link-state
database for the autonomous system in 
<a class="xref" href="#TCP2-CH-7-FIG-1" title="Sample network">Figure 7.2</A
>
contains 5 routers and
10 neighbors: <em class="emphasis">filbert</EM
> has 1 neighbor, <em class="emphasis">pecan</EM
>; <em class="emphasis">pecan</EM
>
has 2 neighbors, <em class="emphasis">filbert</EM
> and <em class="emphasis">almond</EM
>; <em class="emphasis">almond</EM
> has 3
neighbors, <em class="emphasis">pecan</EM
>, <em class="emphasis">salted</EM
>, and <em class="emphasis">roasted</EM
>; <em class="emphasis">salted</EM
> has
2 neighbors, <em class="emphasis">almond</EM
> and <em class="emphasis">roasted</EM
>; and <em class="emphasis">roasted</EM
> has 2
neighbors, <em class="emphasis">salted</EM
> and <em class="emphasis">almond</EM
>. 
<a class="xref" href="#TCP2-CH-7-FIG-2" title="A network graph">Figure 7.3</A
>
shows the graph
of this autonomous system from the perspective of <em class="emphasis">filbert</EM
>.
The Dijkstra algorithm builds the map in this manner:</P
><h4 class="figure"><a class="title" name="TCP2-CH-7-FIG-2">Figure 7.3: A network graph</A
></H4
><img class="graphic" src="figs/tcp2_0703.gif" alt="Figure 7.3"><a class="indexterm" name="AUTOID-8333"></A
><ol class="orderedlist"><li class="listitem"><p class="para">Install the local system as the root of the map with a cost of 0.</P
></LI
><li class="listitem"><p class="para">Locate the neighbors of the system just installed and add them to the
map. The cost of reaching the neighbors is calculated as the sum of
the cost to reach the system just installed plus the cost it advertises
for reaching each neighbor. For example: assume that <em class="emphasis">almond</EM
>
advertises a cost of 20 for <em class="emphasis">salted</EM
> and that the cost of reaching
<em class="emphasis">almond</EM
> is 15. Then the cost for <em class="emphasis">salted</EM
> in <em class="emphasis">filbert</EM
>'s
map is 35.</P
></LI
><li class="listitem"><p class="para">Walk through the map and select the lowest-cost path for each destination.<a class="indexterm" name="AUTOID-8348"></A
>
For example, when <em class="emphasis">salted</EM
> is added to the map, its neighbors
include <em class="emphasis">roasted</EM
>. The path to <em class="emphasis">roasted</EM
> through <em class="emphasis">salted</EM
>
is temporarily added to the map. In this third phase of the algorithm,
the cost of reaching <em class="emphasis">roasted</EM
> through <em class="emphasis">almond</EM
> is compared to
the cost of reaching it through <em class="emphasis">salted</EM
>. The lowest-cost path
is selected. 
<a class="xref" href="#TCP2-CH-7-FIG-2" title="A network graph">Figure 7.3</A
>
shows the deleted paths in dotted lines.
Steps 2 and 3 of the algorithm are repeated for every
system in the link-state database.</P
></LI
></OL
><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-HELLO-PACKETS"></A
>The information in the link-state database is gathered and distributed
in a simple and efficient manner. An OSPF router discovers its neighbors
through the use of Hello packets.
[11]
It sends Hello packets and listens for
Hello packets from adjacent routers. The Hello packet identifies the
local router and lists the adjacent routers from which it has received
packets. When a router receives a Hello packet that lists it as an
adjacent router, it knows it has found a neighbor. It knows this because
it can hear packets from that neighbor and, because the neighbor lists it
as an adjacent router, the neighbor must be able to hear packets from it.
The newly discovered neighbor is added to the local system's neighbor list.</P
><blockquote class="footnote"><p class="para">[11] Don't confuse Hello packets with the Hello protocol. These are OSPF
Hello packets.</P
></BLOCKQUOTE
><p class="para"><a class="indexterm" name="TCP2-CH-7-IX-LINK-STATE-ADVERTISEMENTS-LSAS"></A
>The OSPF router then advertises all of its neighbors. It does this by
<em class="emphasis">flooding</EM
> a Link-State Advertisement (LSA) to the entire network.<a class="indexterm" name="AUTOID-8368"></A
>
The LSA contains the address of every neighbor and the cost of reaching
that neighbor from the local system. Flooding means that the router
sends the LSA out of every interface and that every router that
receives the LSA sends it out of every interface except the one from
which it was received. To avoid flooding duplicate LSAs, the routers
store a copy of the LSAs they receive and discard duplicates.</P
><p class="para"><a class="xref" href="#TCP2-CH-7-FIG-1" title="Sample network">Figure 7.2</A
>
provides an example. When OSPF starts on <em class="emphasis">pecan</EM
> it
sends a Hello packet on subnet 1 and one on subnet 12. <em class="emphasis">filbert</EM
>
and <em class="emphasis">almond</EM
> hear the Hello and respond with Hello packets that
list <em class="emphasis">pecan</EM
> as an adjacent router. <em class="emphasis">pecan</EM
> hears their Hello
packets and adds them to its neighbor list. <em class="emphasis">pecan</EM
> then creates an LSA
that lists <em class="emphasis">filbert</EM
> and <em class="emphasis">almond</EM
> as neighbors with appropriate
cost assigned to each. For instance, <em class="emphasis">pecan</EM
> might assign a cost
of 5 to <em class="emphasis">filbert</EM
> and a cost of 10 to <em class="emphasis">almond</EM
>. <em class="emphasis">pecan</EM
>
then floods the LSA on subnet 1 and subnet 12. <em class="emphasis">filbert</EM
> hears the
LSA and floods it on subnet 3. <em class="emphasis">almond</EM
> receives the LSA and
floods it on both of its PPP links. <em class="emphasis">salted</EM
> floods the LSA on the
link toward <em class="emphasis">roasted</EM
>, and <em class="emphasis">roasted</EM
> floods it on the same link
to <em class="emphasis">salted</EM
>. When <em class="emphasis">salted</EM
> and <em class="emphasis">roasted</EM
> received the
second copy of the LSA, they discarded it, because it duplicated one that
they have already received from <em class="emphasis">almond</EM
>. In this manner, every
router in the entire network receives every other router's link-state
advertisement.</P
><p class="para">OSPF routers track the state of their neighbors by listening for Hello
packets. Hello packets are issued by all routers on a periodic basis.
When a router stops issuing packets, it or the link it is attached to
is assumed to be down. Its neighbors update their LSA and flood them
through the network. The new LSAs are included into the link-state
database on every router on the network and every router recalculates
their network map based on this new information. Clearly, limiting the
number of routers by limiting the size of the network reduces the
burden of recalculating the map. For many networks the entire
autonomous system is small enough. For others, dividing the autonomous system
into areas improves efficiency.<a class="indexterm" name="AUTOID-8394"></A
><a class="indexterm" name="AUTOID-8395"></A
></P
><p class="para">Another feature of OSPF that improves efficiency is the <em class="emphasis">designated<a class="indexterm" name="AUTOID-8398"></A
>
router</EM
>. The designated router is one router on the network that
treats all other routers on the network as its neighbors, while all
other routers treat only the designated router as their neighbor. This
helps reduce the size of the link-state database and thus improves the
speed of the shortest-path-first calculation. Assume a broadcast<a class="indexterm" name="AUTOID-8400"></A
>
network with 5 routers. Five routers each with 4 neighbors
produce a link-state database with 20 entries. But if one of those
routers is the designated router, then that router has 4 neighbors
and all other routers have only 1 neighbor, for a total of 10
link-state database entries. While there is no need for a designated
router on such a small network, the larger the network, the more
dramatic the gains. For example, a broadcast network with 25 routers
has a link-state database of 50 entries when a designated router is
used, versus a database of 600 entries without one.</P
><p class="para">OSPF provides the router with an end-to-end view of the route between<a class="indexterm" name="AUTOID-8404"></A
>
two systems instead of the limited next-hop view provided by RIP.<a class="indexterm" name="AUTOID-8407"></A
>
Flooding quickly disseminates routing information throughout the
network. Limiting the size of the link-state database

through areas and designated routers speeds the SPF calculation.
Taken altogether, OSPF is an efficient link-state routing protocol.</P
><p class="para">OSPF also offers additional features. It provides password authentication to<a class="indexterm" name="AUTOID-8410"></A
>
ensure that the update comes from a valid router. Currently OSPF uses
an eight-character, clear-text password. Work is underway to add a
Message Digest 5 (MD5) crypto-checksum for stronger authentication.<a class="indexterm" name="AUTOID-8412"></A
><a class="indexterm" name="AUTOID-8414"></A
></P
><p class="para">OSPF also supports <em class="emphasis">equal-cost multi-path routing</EM
>. This mouthful<a class="indexterm" name="AUTOID-8418"></A
><a class="indexterm" name="AUTOID-8421"></A
>
means that OSPF routers can maintain more than one path to a single
destination. Given the proper conditions, this feature can be used for
load balancing across multiple network links. However, most systems<a class="indexterm" name="AUTOID-8423"></A
>
are not designed to take advantage of this feature. Refer to your
router's documentation to see if it supports load balancing across
equal-cost OSPF routes.</P
><p class="para">With all of these features, OSPF is the preferred TCP/IP interior
routing protocol for dedicated routers.<a class="indexterm" name="AUTOID-8426"></A
><a class="indexterm" name="AUTOID-8427"></A
></P
></DIV
></DIV
><div class="htmlnav"><p></P
><hr align="LEFT" width="515" title="footer"><table width="515" border="0" cellspacing="0" cellpadding="0"><tr><td align="LEFT" valign="TOP" width="172"><a class="SECT1" href="ch07_03.htm" title="7.3 Building a Static Routing Table "><img src="../gifs/txtpreva.gif" alt="Previous: 7.3 Building a Static Routing Table " border="0"></A
></TD
><td align="CENTER" valign="TOP" width="171"><a class="book" href="index.htm" title="TCP/IP Network Administration"><img src="../gifs/txthome.gif" alt="TCP/IP Network Administration" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172"><a class="SECT1" href="ch07_05.htm#TCP2-CH-7-SECT-5.1" title="7.5 Exterior Routing Protocols "><img src="../gifs/txtnexta.gif" alt="Next: 7.5 Exterior Routing Protocols " border="0"></A
></TD
></TR
><tr><td align="LEFT" valign="TOP" width="172">7.3 Building a Static Routing Table </TD
><td align="CENTER" valign="TOP" width="171"><a class="index" href="index/idx_0.htm" title="Book Index"><img src="../gifs/index.gif" alt="Book Index" border="0"></A
></TD
><td align="RIGHT" valign="TOP" width="172">7.5 Exterior Routing Protocols </TD
></TR
></TABLE
><hr align="LEFT" width="515" title="footer"><p class="nav"><font size="-1">[ <a href="../index.htm" title="The Networking CD Bookshelf">Library Home</A
> | <a href="../dnsbind/index.htm" title="DNS &amp; BIND">DNS &amp; BIND</A
> | <a href="index.htm" title="TCP/IP Network Administration">TCP/IP</A
> | <a href="../sendmail/index.htm" title="sendmail">sendmail</A
> | <a href="../smdref/index.htm" title="sendmail Desktop Reference">sendmail Reference</A
> | <a href="../firewall/index.htm" title="Building Internet Firewalls">Firewalls</A
> | <a href="../puis/index.htm" title="Practical UNIX &amp; Internet Security">Practical Security</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
