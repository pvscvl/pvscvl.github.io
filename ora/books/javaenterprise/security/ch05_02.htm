<html>
<head>
<title>Permissions (Java Security)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Scott Oaks">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-403-7E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Permissions">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm" alt="Java Security"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch05_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch05_01.htm">Chapter 5: The Access Controller</a></td><td align="right" valign="top" width="172"><a href="ch05_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch05_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">5.2. Permissions</h2>

<p>
<a name="INDEX-518"></a><a name="INDEX-519"></a><a name="INDEX-520"></a><a name="INDEX-521"></a><a name="INDEX-522"></a>The basic entity
that the access controller operates on is a permission
object--an instance of the <tt class="literal">Permission</tt> class
(<tt class="literal">java.security.Permission</tt>). The
<tt class="literal">Permission</tt> class itself is an abstract class
that represents a particular operation. The nomenclature here is a
little misleading, because a permission object can reflect two
things. When it is associated with a class (through a code source and
a protection domain), a permission object represents an actual
permission that has been granted to that class. Otherwise, a
permission object allows us to ask if we have a specific permission.
</p>

<p>For example, if we construct a permission object that represents
access to a file, possession of that object does not mean that we
have permission to access the file. Rather, possession of the object
allows us to ask if we have permission to access the file.
</p>

<p>An instance of the <tt class="literal">Permission</tt> class represents
one specific permission. A set of permissions--e.g., all the
permissions that are given to classes signed by a particular
individual--is represented by an instance of the
<tt class="literal">Permissions</tt> class
(<tt class="literal">java.security.Permissions</tt>). As developers and
administrators, we'll make extensive use of these classes, so
we'll need to investigate them in depth.
</p>

<a name="SEC-CH-5-SECT-2.1"></a>
<h3 class="sect2">5.2.1. The Permission Class</h3>

<p>Permissions have three properties:</p>

<dl>
<dt>
<b>A type</b>
</dt>
<dd>
<p>
<a name="INDEX-523"></a><a name="INDEX-524"></a>All
permissions carry a basic type that identifies what the permission
pertains to. A permission object to access a file will have a type of
<tt class="literal">FilePermission</tt>; an object to create a window
will have a type of <tt class="literal">AWTPermission</tt>; permission to
use the XYZ company payroll application would have a type of
<tt class="literal">XYZPayrollPermission</tt>.
</p>
</dd>

<dt>
<b>A name</b>
</dt>
<dd>
<p>
<a name="INDEX-525"></a><a name="INDEX-526"></a>All permissions have a name that
identifies the specific object that a permission relates to. A
<tt class="literal">FilePermission</tt> has a name that is the name of
the file to be accessed; an <tt class="literal">AWTPermission</tt> to
create a window has a name of
<tt class="literal">showWindowWithoutWarningBanner</tt>; permission to
access a particular employee's payroll record would have the
name of that employee. Names are often based on
<a name="INDEX-527"></a>
wildcards, so that a single file permission object may represent
permission to access several files, and so on.
</p>

<p>The name of a permission is fairly arbitrary. In the case of file
permissions, the name is obviously the file. But the name of the
<tt class="literal">showWindowWithoutWarningBanner</tt> permission (among
many others) is chosen by convention, and it is up to all Java
programs to adhere to that convention. This is only a concern to
programmers when dealing with your own permission classes; as a
developer you rarely need to create permission objects for the types
of permissions defined in the Java API.
</p>

<p>On the other hand, this naming convention is of concern to end users
and administrators, who must know the name of the permission they
want to grant to the programs they are going to run. These names must
go into the policy file (which we'll discuss in just a bit).
</p>
</dd>

<dt>
<b>Actions</b>
</dt>
<dd>
<p>
<a name="INDEX-528"></a><a name="INDEX-529"></a>Some
permissions carry with them one or more actions. The presence of
these actions is dependent upon the semantics of the specific type of
permission. A file permission object has a list of actions that could
include read, write, and delete; an XYZ payroll permission object
could have a list of actions that includes view and update. On the
other hand, a window permission does not have an action: you either
have permission to create the window, or you don't. Actions can
also be specified by wildcards.<a name="INDEX-530"></a>The terms used to specify a list of
actions are also arbitrary and handled by convention.
</p>
</dd>

</dl>

<p>Permissions can serve two roles. They allow the Java API to negotiate
access to several resources (files, sockets, and so on). Those
permissions are defined by convention within the Java API, and their
naming conventions are wholly within the domain of the Java API
itself. Hence, you can create an object that represents permission to
read a particular file, but you cannot create an object that
represents permission to copy a particular file, since the copy
action is not known within the file permission class.
</p>

<p>On the other hand, you can create arbitrary permissions for use
within your own programs and completely define both the names of
those permissions as well as the actions (if any) that should apply.
If you are writing a payroll program, for example, you could create
your own permission class that uses the convention that the name of
the permission is the employee upon whose payroll information you
want to act; you could use the convention that the permissible
actions on the payroll permission are view and update. Then you can
use that permission in conjunction with the access controller to
allow employees to view their own payroll data and to allow managers
to change the payroll data for their employees.
</p>

<p>We'll look at both of these cases, starting with the classes
that are provided within the Java API itself. These classes are used
by the Java API (and in particular, by the security manager) to
protect access to certain resources in ways that are fairly
intuitive, given our knowledge of the security manager (but
we'll examine that interaction in detail later).<a name="INDEX-531"></a><a name="INDEX-532"></a>
</p>


<a name="SEC-CH-5-SECT-2.2"></a>
<h3 class="sect2">5.2.2. Permissions of the Java API</h3>

<p>
<a name="INDEX-533"></a><a name="INDEX-534"></a>There are 11 standard permissions in the
Java API, each of which is implemented as a class:
</p>

<ol>
<li>
<p>The <tt class="literal">FilePermission</tt><a name="INDEX-535"></a><a name="INDEX-536"></a> class
(<tt class="literal">java.io.FilePermission</tt>)
</p>

<p>This class represents permissions for files. This class implements
two wildcard patterns for filenames: an asterisk matches all files in
a given directory, and a hyphen matches all files that reside in an
entire directory hierarchy. Valid actions for file permissions are
read, write, delete, and execute.
</p>

<p>File permissions must be constructed with their platform-specific
name. Hence, <em class="emphasis">/myclasses/xyz</em> is a valid name for
a file permission on a Unix system, but not on a Macintosh (where an
equivalent name might be <em class="emphasis">System
Disk:myclasses:xyz</em>). When these strings are specified
programmatically, they are not too difficult to construct (using the
file separator property); when these strings need to be specified in
an external file, an appropriate syntax must be used.
</p>

<p>Keep in mind the difference between an asterisk and a hyphen: an
asterisk only traverses a single directory, while a hyphen traverses
an entire filesystem. Hence <em class="filename">/myclasses/*</em> will
not include <em class="emphasis">/myclasses/xyz/HRApplet.class</em>,
but <em class="emphasis">/my-classes/-</em> will. A single asterisk will
access all files in the current directory, and a single hyphen will
access all files in the current directory and its subdirectories.
</p>

<p>
If you want to access all files on a particular machine, you specify
the special token <tt class="literal">&lt;&lt;ALL FILES&gt;&gt;</tt>.
<a name="INDEX-537"></a>
</p>

<p>A <tt class="literal">FilePermission</tt> object is constructed by
providing the name of the file and a list of actions on that file:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">FilePermission p1 = new FilePermission("-", "execute");
FilePermission p2 = new FilePermission("/myclasses/*", "read, write");
FilePermission p3 = new FilePermission("&lt;&lt;ALL FILES&gt;&gt;", "read");</pre>
</blockquote>

<p>Here, <tt class="literal">p1</tt> represents permission to execute all
files that are in the filesystem hierarchy under the current
directory, <tt class="literal">p2</tt> represents permission to read and
write all files that exist in the directory
<em class="emphasis">/myclasses</em>, and <tt class="literal">p3</tt>
represents permission to read all the files on the
machine.<a name="INDEX-538"></a><a name="INDEX-539"></a>
</p>
</li>

<li>
<p>The <tt class="literal">SocketPermission</tt> class
(<tt class="literal">java.net.SocketPermission</tt>)<a name="INDEX-540"></a><a name="INDEX-541"></a><a name="INDEX-542"></a><a name="INDEX-543"></a>
</p>

<p>This class represents permissions to interact with network sockets.
The name of a socket permission is hostname:port, where each
component of the name may be specified by a wildcard. In particular,
the hostname may be given as a hostname (possibly DNS qualified) or
an IP address. The leftmost position of the hostname may be specified
as an asterisk, such that the host
<em class="emphasis">piccolo.East.Sun.COM</em> would be matched by each of
these strings:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">piccolo
piccolo.East.Sun.COM
*.Sun.COM
*
129.151.119.8</pre>
</blockquote>

<p>The <a name="INDEX-544"></a><a name="INDEX-545"></a>port component of the name can be
specified as a single port number or as a range of port numbers
(e.g., 1-1024). When a range is specified, either side of the range
may be excluded:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">1024 (port 1024)
1024- (all ports greater than or equal to 1024)
-1024 (all ports less than or equal to 1024)
1-1024 (all ports between 1 and 1024, inclusive)</pre>
</blockquote>

<p>Valid actions for a socket permission are accept, connect, listen,
and resolve. These map into the socket API: accept is used by the
<tt class="literal">ServerSocket</tt> class to see if it can accept an
incoming connection from a particular host; connect is used by the
<tt class="literal">Socket</tt> class to see if it can make a connection
to a particular host, listen is used by the
<tt class="literal">ServerSocket</tt> class to see if a server socket can
be created at all, and resolve is used by the
<tt class="literal">Socket</tt> class to see if the IP address for a
particular host can be obtained.
</p>

<p>Constructing a socket permission, then, is simply a matter of putting
together the desired strings in the correct format:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">SocketPermission s1 = new SocketPermission("piccolo:6000", "connect");
SocketPermission s2 = new SocketPermission("piccolo:1024-",
					 "accept, listen");</pre>
</blockquote>

<p>Here <tt class="literal">s1</tt> represents permission to connect to the
X server (port 6000) on machine <em class="emphasis">piccolo</em>, and
<tt class="literal">s2</tt> represents permission for
<em class="emphasis">piccolo</em> to start a server on any nonprivileged
port.<a name="INDEX-546"></a><a name="INDEX-547"></a><a name="INDEX-548"></a><a name="INDEX-549"></a>
</p>
</li>

<li>
<p>The
<tt class="literal">PropertyPermission</tt><a name="INDEX-550"></a><a name="INDEX-551"></a><a name="INDEX-552"></a><a name="INDEX-553"></a><a name="INDEX-554"></a> class
(<tt class="literal">java.util.PropertyPermission</tt>)
</p>

<p>This class represents permissions for Java properties. Property
permission names are specified as dot-separated names (just as they
are in a Java property file); in addition, the last element can be a
wildcard asterisk: *, a.*, a.b.*, and so on.
</p>

<p>The valid actions for this class are read and write. Hence, to
construct a property permission, you would do something like:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">PropertyPermission p1 = new PropertyPermission("java.version", "read");
PropertyPermission p2 = new PropertyPermission("xyz.*", "read,write");</pre>
</blockquote>

<p>Here, <tt class="literal">p1</tt> represents permission to read the
version of the virtual machine that's in use, and
<tt class="literal">p2</tt> represents permission to read or write all
properties that begin with the token <tt class="literal">xyz</tt>.
</p>
</li>

<li>
<p>The
<tt class="literal">RuntimePermission</tt><a name="INDEX-555"></a><a name="INDEX-556"></a><a name="INDEX-557"></a> class
(<tt class="literal">java.lang.RuntimePermission</tt>)
</p>

<p>This class represents permissions for the Java
runtime--essentially, permissions to perform any of the
operations encapsulated by the <tt class="literal">Runtime</tt> class,
including most thread operations. The names recognized by this class
are dot-separated names and are subject to the same wildcard asterisk
matching as the property permission class.
</p>

<p>Runtime permissions have no associated actions--you either have
permission to perform those operations, or you don't. Hence, a
runtime permission is constructed as:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">RuntimePermission r1 = new RuntimePermission("exitVM");
RuntimePermission r2 = new 
	RuntimePermission("accessClassInPackage.java");</pre>
</blockquote>

<p>Here, <tt class="literal">r1</tt> represents permission to exit the
virtual machine, and <tt class="literal">r2</tt> represents permission to
access classes in the java package.
</p>
</li>

<li>
<p>The
<tt class="literal">AWTPermission</tt><a name="INDEX-558"></a><a name="INDEX-559"></a><a name="INDEX-560"></a><a name="INDEX-561"></a><a name="INDEX-562"></a>
class (<tt class="literal">java.awt.AWTPermission</tt>)
</p>

<p>This class represents permissions to access certain windowing
resources. In particular, as we might assume from the corresponding
methods in the security manager, there are three conventional names
in this class: <tt class="literal">showWindowWithoutWarningBanner</tt>,
<tt class="literal">accessClipboard</tt>, and
<tt class="literal">accessEventQueue</tt>.
</p>

<p>There are no actions associated with this class. In addition, this
class technically supports wildcard matching, but since none of the
conventional names are in dot-separated format, that facility is
unused. Hence, an AWT permission is constructed like this:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">AWTPermission a = new AWTPermission("showWindowWithoutWarningBanner");</pre>
</blockquote>
</li>
<li>
<p>The <tt class="literal">NetPermission</tt> class
(<tt class="literal">java.net.NetPermission</tt>)
</p>
</li>
<li>
<p>The
<tt class="literal">NetPermission</tt><a name="INDEX-563"></a><a name="INDEX-564"></a><a name="INDEX-565"></a><a name="INDEX-566"></a><a name="INDEX-567"></a><a name="INDEX-568"></a><a name="INDEX-569"></a>
class (<tt class="literal">java.net.NetPermission</tt>)
</p>

<p>This class represents permissions to interact with two different
classes. The first is the
<tt class="literal">Authenticator</tt><a name="INDEX-570"></a> class: there are no
concrete implementations of the <tt class="literal">Authenticator</tt>
class within the JDK, but implementations of that class provide HTTP
authentication for password-protected web pages. The valid names
associated with this class are <tt class="literal">setDefaultAuthenticator
</tt>and<tt class="literal"> requestPasswordAuthentication</tt>.
Wildcard asterisk matching applies to these names.
</p>

<p>In addition, this class encapsulates various URL-related permissions.
Permission to specify a stream handler in the URL class is named
<tt class="literal">specifyStreamHandler</tt>.
</p>

<p>There are no associated actions with a net permission, so they are
constructed as follows:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">NetPermission n1 = new NetPermission("requestPasswordAuthentication");</pre>
</blockquote>
</li>

<li>
<p>The
<tt class="literal">SecurityPermission</tt><a name="INDEX-571"></a><a name="INDEX-572"></a><a name="INDEX-573"></a> class
(<tt class="literal">java.security.SecurityPermission</tt>)
</p>

<p>This class represents permission to use the security package. Names
passed to this class are subject to wildcard asterisk matching, and
there are no actions associated with this class. The valid names to
this class include all the valid strings that can be passed to the
<tt class="literal">checkSecurityAccess()</tt> method of the security
manager; as we discuss the security API in the last half of this
book, we'll list these names for each class.
</p>
</li>

<li>
<p>The<tt class="literal">SerializablePermission</tt><a name="INDEX-574"></a><a name="INDEX-575"></a><a name="INDEX-576"></a><a name="INDEX-577"></a> class<tt class="literal">
(java.io.SerializablePermission)</tt>
</p>

<p>This class represents various permissions relating to the
serialization and deserialization of an object. No wildcards or
actions are accepted by this class. This permission has two valid
names: <tt class="literal">enableSubstitution</tt> and
<tt class="literal">enableSubclassImplementation</tt>. The first of these
permissions allows the <tt class="literal">enableResolveObject()</tt>
method of the <tt class="literal">ObjectInputStream</tt> and the
<tt class="literal">enableReplaceObject()</tt> method of the
<tt class="literal">ObjectOutputStream</tt> classes to function. The
latter permission allows the <tt class="literal">ObjectInputStream</tt>
and <tt class="literal">ObjectOutputStream</tt> classes to be subclassed,
which would potentially override the
<tt class="literal">readObject()</tt> and
<tt class="literal">writeObject()</tt> methods.
<a name="INDEX-578"></a><a name="INDEX-579"></a><a name="INDEX-580"></a><a name="INDEX-581"></a>
</p>
</li>
<li>
<p>The
<tt class="literal">ReflectPermission</tt><a name="INDEX-582"></a><a name="INDEX-583"></a><a name="INDEX-584"></a><a name="INDEX-585"></a> class
(<tt class="literal">java.lang.reflect.ReflectPermission)</tt>
</p>

<p>This permission represents the ability to set the
<tt class="literal">accessible</tt> flag on objects that are to be used
with the reflection API. This class has a single name
(<tt class="literal">suppressAccessChecks</tt>) and no actions.
</p>
</li>
<li>
<p>The
<tt class="literal">UnresolvedPermission</tt><a name="INDEX-586"></a><a name="INDEX-587"></a><a name="INDEX-588"></a> class
(<tt class="literal">java.security.UnresolvedPermission</tt>)
</p>

<p>This class is used internally in the Java API to represent external
permissions (i.e., permissions that are implemented by third-party
APIs) before the class that defines that permission is found. This
permission is only needed if you are writing an implementation of the
<tt class="literal">Policy</tt> class.
</p>
</li>
<li>
<p>The
<tt class="literal">AllPermission</tt><a name="INDEX-589"></a><a name="INDEX-590"></a><a name="INDEX-591"></a><a name="INDEX-592"></a> class
(<tt class="literal">java.security.AllPermission</tt>)
</p>

<p>This class represents permission to perform any
operation--including file, socket, and other operations that
have their own permission classes. Granting this type of permission
is obviously somewhat dangerous; this permission is usually given
only to classes within the Java API and to classes in Java
extensions. This class has no name or actions; it is constructed as
follows:
<a name="INDEX-593"></a><a name="INDEX-594"></a>
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">AllPermission ap = new AllPermission();</pre>
</blockquote>
</li>
</ol>


<a name="SEC-CH-5-SECT-2.3"></a>
<h3 class="sect2">5.2.3. Using the Permission Class</h3>

<p>
<a name="INDEX-595"></a><a name="INDEX-596"></a>We'll now look into the classes
upon which all these permissions are based: the
<tt class="literal">Permission</tt> class. This class abstracts the
notion of a permission and a name. From a programmatic standpoint,
the <tt class="literal">Permission</tt> class is really used only to
create your own types of permissions. It has some interesting
methods, but the operations that are implemented on a permission
object are not generally used in code that we write--they are
used instead by the access controller. Hence, we'll examine
this class primarily with an eye towards understanding how it can be
used to implement our own permissions.
</p>

<p>
<tt class="literal">Permission</tt> is an abstract class that contains
these public methods:
</p>

<dl>
<dt>
<b>public <a name="INDEX-597"></a>
Permission(String name) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Construct a permission object that represents the desired permission.</p>
</dd>

<dt>
<b>public abstract boolean equals(Object o) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Subclasses of the <tt class="literal">Permission</tt> class are required
to implement their own test for equality. Often this is simply done
by comparing the name (and actions, if applicable) of the permission.
</p>
</dd>

<dt>
<b>public abstract int hashCode() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Subclasses of the <tt class="literal">Permission</tt> class are required
to implement their own hash code. In order for the access controller
to function correctly, the hash code for a given permission object
must never change during execution of the virtual machine. In
addition, permissions that compare as equal must return the same hash
code from this method.
</p>
</dd>

<dt>
<b>public final String getName() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the name that was used to construct this permission.</p>
</dd>

<dt>
<b>public abstract String <a name="INDEX-598"></a>
getActions() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the canonical form of the actions (if any) that were used to
construct this permission.
</p>
</dd>

<dt>
<b>public String <a name="INDEX-599"></a>
toString() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>The convention for
<a name="INDEX-600"></a>
printing a permission is to print in parentheses the class name, the
name of the permission, and the actions. For example, a file
permission might return:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">("java.io.FilePermission","/myclasses/xyz/HRApplet.class","read")</pre>
</blockquote>
</dd>


<dt>
<b>public abstract boolean <a name="INDEX-601"></a>
implies(Permission p) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>This method is one of the keys of the <tt class="literal">Permission</tt>
class: it is responsible for determining whether or not a class that
is granted one permission is granted another. This method is normally
responsible for performing wildcard matching, so that, for example,
the file permission <em class="emphasis">/myclasses/-</em> implies the
file permission <em class="emphasis">/myclasses/xyz/HRApplet.class</em>.
But this method need not rely on wildcards; permission to write a
particular object in a database would probably imply permission to
read that object as well.
</p>
</dd>

<dt>
<b>public PermissionCollection <a name="INDEX-602"></a>
newPermissionCollection() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return a permission collection suitable for holding instances of this
type of permission. We'll discuss the topic of permission
collections in the next section. This method returns
<tt class="literal">null</tt> by default.
</p>
</dd>

<dt>
<b>public void <a name="INDEX-603"></a>
checkGuard(Object o) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Call the security manager to see if the permission (i.e., the
<tt class="literal">this</tt> variable) has been granted, generating a
<tt class="literal">SecurityException</tt> if the permission has not been
granted. The object parameter of this method is unused. We'll
give more details about this method later in this chapter.
</p>
</dd>

</dl>

<p>Implementing your own permission means providing a class with
concrete implementations of these abstract methods. Note that the
notions of wildcard matching and actions are not generally present in
this class--if you want your class to support either of these
features, you're responsible for implementing all of the
necessary logic to do so (although the
<tt class="literal">BasicPermission</tt> class that we'll look at
next can help us with that).
</p>

<p>Say that you are implementing a program to administer payroll
information. You'll want to create permissions to allow users
to view their payment history. You'll also want to allow the HR
department to update the pay rate for employees. So we'll need
to implement a permission class to encapsulate all of that:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">public class XYZPayrollPermission extends Permission {

	protected int mask;
	static private int VIEW = 0x01;
	static private int UPDATE = 0x02;

	public XYZPayrollPermission(String name) {
		this(name, "view");
	}

	public XYZPayrollPermission(String name, String action) {
		super(name);
		parse(action);
	}

	private void parse(String action) {
		StringTokenizer st = new StringTokenizer(action, ",\t ");

		mask = 0;
		while (st.hasMoreTokens()) {
			String tok = st.nextToken();
			if (tok.equals("view"))
				mask |= VIEW;
			else if (tok.equals("update"))
				mask |= UPDATE;
			else throw new IllegalArgumentException(
									"Unknown action " + tok);
		}
	}

	public boolean implies(Permission permission) {
		if (!(permission instanceof XYZPayrollPermission))
			return false;
		
		XYZPayrollPermission p = (XYZPayrollPermission) permission;
		String name = getName();
		if (!name.equals("*") &amp;&amp; !name.equals(p.getName()))
			return false;
		if ((mask &amp; p.mask) != p.mask)
			return false;
		return true;
	}

	public boolean equals(Object o) {
		if (!(o instanceof XYZPayrollPermission))
			return false;
		
		XYZPayrollPermission p = (XYZPayrollPermission) o;
		return ((p.getName().equals(getName())) &amp;&amp; (p.mask == mask));
	}

	public int hashCode() {
		return getName().hashCode() ^ mask;
	}

	public String getActions() {
		if (mask == 0)
			return "";
		else if (mask == VIEW)
			return "view";
		else if (mask == UPDATE)
			return "update";
		else if (mask == (VIEW | UPDATE))
			return "view, update";
		else throw new IllegalArgumentException("Unknown mask");
	}

	public PermissionCollection newPermissionsCollection() {
		return new XYZPayrollPermissionCollection();
	}
}</pre>
</blockquote>

<p>The instance variables in this class are required to hold the
information about the actions--even though our superclass makes
references to actions, it doesn't provide a manner in which to
store them or process them, so we have to provide that logic. That
logic is provided in the <tt class="literal">parse()</tt> method;
we've chosen the common convention of having the action string
treated as a list of actions that are separated by commas and
whitespace. Note also that we've stored the actual actions as
bits in a single integer--this simplifies some of the later
logic.
</p>

<p>As required, we've implemented the
<tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt>
methods--and we've done so rather simply. We consider
objects equal if their names are equal and their masks (that is,
their actions) are equal, and construct a hash code accordingly.
</p>

<p>Our implementation of the
<tt class="literal">getActions()</tt><a name="INDEX-604"></a> method is typical: we're
required to return the same action string for a permission object
that was constructed with an action list of "<tt class="literal">view,
update</tt>" as for one that was constructed with an
action list of "<tt class="literal">update,</tt><tt class="literal">view</tt>". This requirement is one of the
prime reasons why the actions are stored as a mask--because it
allows us to construct this action string in the proper format.
</p>

<p>Finally, the
<tt class="literal">implies()</tt><a name="INDEX-605"></a> method is responsible for determining
how wildcard and other implied permissions are handled. If the name
passed to construct our object is an asterisk, then we match any
other name; hence, an object to represent the permissions of the HR
department might be constructed as:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">new XYZPayrollPermission("*", "view, update")</pre>
</blockquote>

<p>When the <tt class="literal">implies()</tt> method is called on this
wildcard object, the name will always match, and because the action
mask has the complete list of actions, the mask comparison will
always yield the mask that we're testing against. If the
<tt class="literal">implies()</tt> method is called with a different
object, however, it will only return <tt class="literal">true</tt> if the
names are equal and the object's mask is a subset of the target
mask.
</p>

<p>Note that we also might have implemented the logic in such a way that
permission to perform an update implies permission to perform a view
simply by changing the logic of testing the mask--you're
not limited only to wildcard matching in the
<tt class="literal">implies()</tt> method.<a name="INDEX-606"></a><a name="INDEX-607"></a>
</p>


<a name="SEC-CH-5-SECT-2.4"></a>
<h3 class="sect2">5.2.4. The BasicPermission Class</h3>

<p>If you need to implement your own permission class, the
<tt class="literal">BasicPermission</tt><a name="INDEX-608"></a><a name="INDEX-609"></a><a name="INDEX-610"></a> class
(<tt class="literal">java.security.BasicPermission</tt>) provides some
useful semantics. This class implements a <a name="INDEX-611"></a>basic permission--that is, a
permission that doesn't have actions. Basic permissions can be
thought of as binary permission--you either have them, or you
don't. However, this restriction does not prevent you from
implementing actions in your subclasses of the
<tt class="literal">BasicPermission</tt> class (as the
<tt class="literal">PropertyPermission</tt> class does).
</p>

<p>
<a name="INDEX-612"></a>
The prime benefit of this class is the manner in which it implements
wildcards. Names in basic permissions are considered to be
hierarchical, following a dot-separated convention. For example, if
the XYZ corporation wanted to create a set of basic permissions, they
might use the convention that the first word of the permission always
be <tt class="literal">xyz</tt>: <tt class="literal">xyz.readDatabase</tt>,
<tt class="literal">xyz.writeDatabase</tt>,
<tt class="literal">xyz.runPayrollProgram</tt>,
<tt class="literal">xyz.HRDepartment.accessCheck</tt>, and so on. These
permissions can then be specified by their full name, or they can be
specified with an asterisk wildcard:
<tt class="literal">xyz</tt>.<tt class="literal">*</tt> would match each of
these (no matter what depth), and <tt class="literal">*</tt> would match
every possible basic permission.
</p>

<p>The wildcard matching of this class does not match partial names:
<tt class="literal">xyz.read*</tt> would not match any of the permissions
we just listed. Further, the wildcard must be in the rightmost
position: <tt class="literal">*.readDatabase</tt> would not match any
basic permission.
</p>

<p>The <tt class="literal">BasicPermission</tt> class is abstract, although
it does not contain any abstract methods, and it completely
implements all the abstract methods of the
<tt class="literal">Permission</tt> class. Hence, a concrete
implementation of the <tt class="literal">BasicPermission</tt> need only
contain a constructor to call the correct constructor of the
superclass (since there is no default constructor in the
<tt class="literal">BasicPermission</tt> class). Subclasses must call one
of these constructors:
</p>

<dl>
<dt>
<b>public BasicPermission(String name) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Construct a permission with the given name. This is the usual
constructor for this class, as basic permissions do not normally have
actions.
</p>
</dd>

<dt>
<b>public BasicPermission(String name, String action) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Construct a permission with the given name and action. Even though
basic permissions do not usually have actions associated with them,
you must provide a constructor with this signature in all
implementations of the <tt class="literal">BasicPermission</tt> class due
to the mechanism that is used to construct permission objects from
the policy file (which we will see later in this
chapter).<a name="INDEX-613"></a><a name="INDEX-614"></a><a name="INDEX-615"></a><a name="INDEX-616"></a>
</p>
</dd>

</dl>


<a name="SEC-CH-5-SECT-2.5"></a>
<h3 class="sect2">5.2.5. Permission Collections</h3>

<p>
<a name="INDEX-617"></a><a name="INDEX-618"></a>The access controller depends upon
the ability to aggregate permissions so that it can easily call the
<tt class="literal">implies()</tt> method on all of them. For example, a
particular user might be given permission to read several
directories: perhaps the user's home directory
(<em class="emphasis">/home/sdo/-</em>) and the system's temporary
directory (<em class="emphasis">/tmp/-</em>). When the access controller
needs to see if the user can access a particular file, it must test
both of these permissions to see if either one matches. This can be
done easily by aggregating all the file permissions into a single
permission collection.
</p>

<p>Every permission class is required to implement a permission
collection, then, which is a mechanism where objects of the same
permission class may be grouped together and operated upon as a
single unit. This requirement is enforced by the
<tt class="literal">newPermissionCollection()</tt><a name="INDEX-619"></a>
method of the <tt class="literal">Permission</tt> class.
</p>

<p>The <tt class="literal">PermissionCollection</tt><a name="INDEX-620"></a><a name="INDEX-621"></a> class
(<tt class="literal">java.security.PermissionCollection</tt>) is defined
as follows:
</p>

<dl>
<dt>
<b>public abstract class PermissionCollection</b>
</dt>
<dd>
<p>Implement an aggregate set of permissions. While permission
collections can handle heterogeneous sets of permissions, a
permission collection typically should be used to group together a
homogeneous group of permissions (e.g., all file permissions or all
socket permissions, etc.).
</p>
</dd>

</dl>

<p>There are three basic operations that you can perform on a permission
collection:
</p>

<dl>
<dt>
<b>public abstract void <a name="INDEX-622"></a>
add(Permission p) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Add the given permission to the permission collection.</p>
</dd>

<dt>
<b>public abstract boolean <a name="INDEX-623"></a>
implies(Permission p) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Check to see if any permission in the collection implies the given
permission. This can be done by enumerating all the permission
objects that have been added to the collection and calling the
<tt class="literal">implies()</tt> method on each of those objects in
turn, but it is typically implemented in a more efficient manner.
</p>
</dd>

<dt>
<b>public abstract Enumeration <a name="INDEX-624"></a>
elements() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return an enumeration of all the permissions in the collection.</p>
</dd>

</dl>

<p>The <em class="emphasis">javadoc</em> documentation of this class claims that a permission
collection is a collection of heterogeneous permission objects.
Forget that idea; introducing that notion into permission collections
vastly complicates matters, and the issue of a heterogeneous
collection of permission objects is better handled elsewhere
(we'll see how a little bit later). As far as we're
concerned, the purpose of a permission collection is to aggregate
only permission objects of a particular type.
</p>

<p>Permission collections are typically implemented as inner classes, or
at least as classes that are private to the package in which they are
defined. There is, for example, a corresponding permission collection
class for the <tt class="literal">FilePermission</tt> class, one for the
<tt class="literal">SocketPermission</tt> class, and so on.
</p>

<p>None of these collections is available as a public class that we can
use in our own program. Hence, in order to support the
<tt class="literal">newPermissionCollection()</tt> method in our
<tt class="literal">XYZPayrollPermission</tt> class, we'd need to
do something like this:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">public class XYZPayrollPermissionCollection extends 
										PermissionCollection {
	private Hashtable permissions;
	private boolean addedAdmin;
	private int adminMask;

	XYZPayrollPermissionCollection() {
		permissions = new Hashtable();
		addedAdmin = false;
	}

	public void add(Permission p) {
		if (!(p instanceof XYZPayrollPermission))
			throw new IllegalArgumentException(
									"Wrong permission type");
		XYZPayrollPermission xyz = (XYZPayrollPermission) p;
		String name = xyz.getName();
		XYZPayrollPermission other =
						(XYZPayrollPermission) permissions.get(name);
		if (other != null)
			xyz = merge(xyz, other);
		if (name.equals("*")) {
			addedAdmin = true;
			adminMask = xyz.mask;
		}
		permissions.put(name, xyz);
	}

	public Enumeration elements() {
		return permissions.elements();
	}

	public boolean implies(Permission p) {
		if (!(p instanceof XYZPayrollPermission))
			return false;
		XYZPayrollPermission xyz = (XYZPayrollPermission) p;
		if (addedAdmin &amp;&amp; (adminMask &amp; xyz.mask) == xyz.mask)
			return true;
		Permission inTable = (Permission)
								permissions.get(xyz.getName());
		if (inTable == null)
			return false;
		return inTable.implies(xyz);
	}

	private XYZPayrollPermission
				merge(XYZPayrollPermission a, XYZPayrollPermission b) {
		String aAction = a.getActions();
		if (aAction.equals(""))
			return b;
		String bAction = b.getActions();
		if (bAction.equals(""))
			return a;
		return new XYZPayrollPermission(a.getName(),
									aAction + "," + bAction);
	}
}</pre>
</blockquote>

<p>Note the logic within the <tt class="literal">implies()</tt>
method--it's the important part of this example. The
<tt class="literal">implies()</tt> method must test each permission in
the hashtable (or whatever other container you've used to store
the added permissions), but it should do so efficiently. We could
always call the <tt class="literal">implies()</tt> method of each entry
in the hashtable, but that would clearly not be
efficient--it's better to call only the
<tt class="literal">implies()</tt> method on a permission in the table
that has a matching name.<a name="INDEX-625"></a>
</p>

<p>The only trick is that we won't find a matching name if
we're doing wildcard pattern matching--if we've
added the name "*" to the table, we'll always want
to return <tt class="literal">true</tt>, even though looking up the name
"John Smith" in the table will not return the
administrative entry. Implementing this wildcard pattern matching
efficiently is the key to writing a good permission collection.
</p>

<p>When you use (or subclass) one of the concrete permission classes
that we listed earlier, there is no need to provide a permission
collection class--all concrete implementations provide their own
collection. In addition, there are two other cases when you do not
need to implement a permission collection:
</p>

<ul>
<li>
<p>When you extend the <tt class="literal">Permission</tt> class, but do not
do wildcard pattern matching.
</p>

<p>Hidden internally within the Java API is a
<tt class="literal">PermissionsHash</tt> class, which is the default
permission collection class for permission objects. The
<tt class="literal">Permissions-Hash</tt> class stores the aggregated
permissions in a hashtable, so the implementations of its
<tt class="literal">add()</tt> and <tt class="literal">elements()</tt>
methods are straightforward. The implementation of its
<tt class="literal">implies()</tt> method is based on looking up the name
of the permission parameter in the hashtable collection: if an entry
is found, then the <tt class="literal">implies()</tt> method is called on
that entry.
</p>
</li>
<li>
<p>When you extend the <tt class="literal">BasicPermission</tt> class and do
not provide support for actions.
</p>

<p>The <tt class="literal">newPermissionClass()</tt> method of the
<tt class="literal">BasicPermission</tt> class will provide a permission
collection that handles wildcard pattern matching correctly (and
<a name="INDEX-626"></a><a name="INDEX-627"></a> efficiently).
</p>
</li>
</ul>
<p>If you implement your own <tt class="literal">PermissionCollection</tt>
class, you must keep track of whether it has been marked as
read-only. There are two methods invlolved in this:
</p>

<dl>
<dt>
<b>public boolean isReadOnly() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return an indication of whether the collection has been marked as
read-only.
</p>
</dd>

<dt>
<b>public void setReadOnly() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Set the collection to be read-only. Once the read-only flag has been
set, it cannot be unset: the collection will remain read-only
forever.
</p>
</dd>

</dl>

<p>A permission collection is expected to throw a security exception
from its <tt class="literal">add()</tt> method if it has been marked as
read-only. Note that the read-only instance variable is private to
the <tt class="literal">PermissionCollection</tt> class, so subclasses
will have to rely on the <tt class="literal">isReadOnly()</tt> method to
test its value.
</p>


<a name="SEC-CH-5-SECT-2.6"></a>
<h3 class="sect2">5.2.6. The Permissions Class</h3>

<p>
<a name="INDEX-628"></a><a name="INDEX-629"></a>So far,
we've spoken about permission collections as homogeneous
collections: all permissions in the
<tt class="literal">XYZPayrollPermissionCollection</tt> class are
instances of the <tt class="literal">XYZPayrollPermission</tt> class; a
similar property holds for other permission collections. This idea
simplifies the <tt class="literal">implies()</tt> method that we showed
above. But to be truly useful, a permission collection needs to be
heterogeneous, so it can represent all the permissions a program
should have. A permission collection really needs to be able to
contain file permissions, socket permissions, and other types of
permissions.
</p>

<p>This idea is present within the
<tt class="literal">PermissionCollection</tt> class; conceptually,
however, it is best to think of heterogeneous collections of
permissions as encapsulated by the <tt class="literal">Permissions</tt>
class (<tt class="literal">java.security.Permissions</tt>):
</p>

<dl>
<dt>
<b>public final class Permissions extends PermissionCollection</b>
</dt>
<dd>
<p>Implement the <tt class="literal">PermissionCollection</tt> class. This
class allows you to create a heterogeneous collection of permissions:
the permission objects that are added to this collection need not
have the same type.
</p>
</dd>

</dl>

<p>This class contains a concrete implementation of a permission
collection that organizes the aggregated permissions in terms of
their individual, homogenous permission collections. You can think of
a permissions object as containing an aggregation of permission
collections, each of which contains an aggregation of individual
permissions.
</p>

<p>For example, let's consider an empty permissions object. When a
file permission is added to this object, the permissions object will
call the <tt class="literal">newPermissionCollection()</tt> method on the
file permission to get a homogeneous file permission collection
object. The file permission is then stored within this file
permission collection. When another file permission is added to the
permissions object, the permissions object will place that file
permission into the already existing file permission collection
object. When a payroll permission object is added to the permissions
object, a new payroll permission collection will be obtained, the
payroll permission added to it, and the collection added to the
permissions object. This process will continue, and the permissions
object will build up a set of permission collections.
</p>

<p>When the <tt class="literal">implies()</tt> method of the permissions
object is called, it will search its set of permission collections
for a collection that can hold the given permission. It can then call
the <tt class="literal">implies()</tt> method on that (homogenous)
collection to obtain the correct answer.
</p>

<p>The <tt class="literal">Permissions</tt> class thus supports any
arbitrary grouping of permissions. There is no need to develop your
own permission collection to handle heterogeneous groups.
</p>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch05_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch05_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch05_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">5.1. The CodeSource Class</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">5.3. The Policy Class</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
