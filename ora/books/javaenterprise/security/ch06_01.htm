<html>
<head>
<title>Implementing Security Policies (Java Security)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Scott Oaks">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-403-7E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Implementing Security Policies">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm" alt="Java Security"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_07.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch05_07.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm">Java Security</a></td><td align="right" valign="top" width="172"><a href="ch06_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch06_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->

<h1 class="chapter">Chapter 6.  Implementing Security Policies</h1>
<div class="htmltoc">
<h4 class="tochead">Contents:</h4>
<p>
<a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch06_01.htm">Protected Methods of the Security Manager</a>
<br>
<a href="ch06_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch06_02.htm">Security Managers and the Class Loader</a>
<br>
<a href="ch06_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch06_03.htm">Implementation Techniques</a>
<br>
<a href="ch06_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch06_04.htm">Running Secure Applications</a>
<br>
<a href="ch06_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch06_05.htm">Summary</a>
<br>
</p>
</div>


<p>In <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch04_01.htm">Chapter 4, "The Security Manager Class"</a>, we examined the security manager in
the context of existing implementations of the security manager for
use in Java-enabled browsers; we followed that with a discussion of
the access control mechanism and Java's ability to define
access policies.
</p>

<p>In this chapter, we'll put that information together and look
at how the security manager is actually implemented, and how you can
implement your own security manager. <a name="INDEX-719"></a><a name="INDEX-720"></a>There are three times when
it's important to write your own security manager:
</p>

<dl>
<dt>
<b>In an RMI server</b>
</dt>
<dd>
<p>RMI wants you to provide a security manager for all RMI servers; for
RMI servers that load client classes, a security manager is required.
There is a default RMI security manager that you may use for this
purpose, or you may write your own.
</p>
</dd>

<dt>
<b>In a customized browser</b>
</dt>
<dd>
<p>If you're writing your own Java-enabled browser, you'll
want to provide a security manager. In addition, if you're
using an existing browser, you may want to use a different security
manager in that browser. Some browsers already allow the user to
specify a different security manager via a property; other browsers
can be licensed for this type of customization.
</p>
</dd>

<dt>
<b>In a Java application</b>
</dt>
<dd>
<p>If you download, install, and run Java applications on your machine,
you may want to provide a security manager to protect your system
against those applications the same way that it is protected against
Java applets. In Java 1.1 and earlier releases, this requires you to
write a security manager. In Java 1.2,<a href="#FOOTNOTE-1">[1]</a> you can use the access control mechanism
instead of writing a complete security manager. However, even in Java
1.2 you may need to write your own security manager in certain
circumstances. There are methods (like the
<tt class="literal">getThreadGroup()</tt> method) of the security manager
that are outside the scope of the access controller, and there are
certain types of permissions (like those typically given to the
<tt class="literal">checkConnect()</tt> method) that cannot be specified
in a <em class="filename">java.policy</em><a name="INDEX-721"></a><a name="INDEX-722"></a> file.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-1"></a>
<p>[1]1.2 is now
Java 2.</p> </blockquote>
</dd>

</dl>

<div class="sidebar">

<h4 class="objtitle">Access Control and the Security Manager</h4>
<p>When the access controller was introduced into Java 1.2, it made a
big difference to the role of the security manager. Previously, the
security manager was paramount in allowing or rejecting operations on
files and sockets and other system resources. In Java 1.2, the
security manager began to defer permission checking to the access
controller.
</p>

<p>However, the security manager remains an important interface to
system security . The <a name="INDEX-723"></a>
Java API still calls the methods of the security manager to enforce
system security--and now most of these methods call the access
controller. This allows for upward compatibility--if you wrote a
1.1-based security manager that implements your desired security
policy, you can still use that security manager with Java 1.2; your
program will run exactly the same as it used to. In this case, you
needn't worry about policy files and code sources and secure
class loaders--the security model that you've already
encapsulated into your security manager will be respected.
</p>
</div>



<h2 class="sect1">6.1. Protected Methods of the Security Manager</h2>

<p>
<a name="INDEX-724"></a><a name="INDEX-725"></a>We've often said that the
distinction between trusted and untrusted code has its roots in
information that the security manager must obtain from the class
loader. There are two ways in which this happens: through a set of
generic methods of the <tt class="literal">SecurityManager</tt> class
that inform the security manager about the state of the class loader,
and through an agreed-upon interface between the security manager and
the class loader. We'll look at the first of these mechanisms
in this section, and we'll discuss the second mechanism later
when we actually develop a security manager.
</p>

<p>The use of these protected methods is vital in Java 1.1 and previous
releases. In Java 1.2, they are much less important--some of
them have even been deprecated. This is not surprising, since the
access controller now gives us much of the information that initially
could only be obtained from the class loader. We'll give a
complete overview of these methods here, although it is information
that you'll only need to complete a 1.1-based security manager.
</p>

<p>The methods of the security manager that provide us with generic
information about the class loader are all protected methods of the
security manager class; they are summarized in <a href="#SEC-CH-6-TABLE-6">Table 6-1</a>.
</p>

<a name="SEC-CH-6-TABLE-6"></a>
<h4 class="objtitle">Table 6-1. Protected Methods of the Security Manager Class</h4>
<table border="1">



<tr>
<th>
<p>Method</p>
</th>
<th>
<p>Purpose</p>
</th>
</tr>

<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">getClassContext()</pre>
</blockquote>
</td>
<td>
<p>Return all the classes on the stack to see who has called us</p>
</td>
</tr>
<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">currentClassLoader()</pre>
</blockquote>
</td>
<td>
<p>Return the most recent class loader</p>
</td>
</tr>
<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">currentLoadedClass()</pre>
</blockquote>
</td>
<td>
<p>Return the class that was most recently loaded with a class loader</p>
</td>
</tr>
<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">classLoaderDepth()</pre>
</blockquote>
</td>
<td>
<p>Return the depth in the call stack where the most recent class loader
was found
</p>
</td>
</tr>
<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">classDepth()</pre>
</blockquote>
</td>
<td>
<p>Return the depth in the call stack of the given class</p>
</td>
</tr>
<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">inClass()</pre>
</blockquote>
</td>
<td>
<p>Return <tt class="literal">true</tt> if the given class is on the stack</p>
</td>
</tr>
<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">inClassLoader()</pre>
</blockquote>
</td>
<td>
<p>Return <tt class="literal">true</tt> if any class on the stack came from
a class loader
</p>
</td>
</tr>

</table>

<dl>
<dt>
<b>protected native Class[] <a name="INDEX-726"></a>
getClassContext()</b>
</dt>
<dd>
<p>Return an array of all classes on the stack of the currently
executing thread.
</p>
</dd>

</dl>

<p>
<a name="INDEX-727"></a><a name="INDEX-728"></a>The first such method
we'll discuss lets us retrieve all the classes involved in
making the current call to the security manager. This method itself
is rarely used in a security manager, but it is the basis for many of
the methods we'll discuss in this section.
</p>

<p>The <tt class="literal">getClassContext()</tt> method returns an array of
<tt class="literal">Class</tt> objects in the order of the call stack for
the current method. The first element of the array is always the
<tt class="literal">Class</tt> object for the security manager class, the
second element is the <tt class="literal">Class</tt> object for the
method that called the security manager, and so on.
</p>

<p>Accessing all the classes in this array is one way to determine
whether the call originally came from code that is in the Java API or
whether it came from other code. For example, we could put the
following method into our custom security manager:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">public class MySecurityManager extends SecurityManager {
    public void checkRead(String s) {
        Class c[] = getClassContext();
        for (int i = 0; i &lt; c.length; i++) {
            String name = c.getName();
            System.out.println(name);
        }
    }   
}</pre>
</blockquote>

<p>If we then try to create a <tt class="literal">FileReader</tt> object:</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">public class Test {
	public static void main(String args[]) {
		FileReader f = new FileReader("/etc/passwd");
    }
}</pre>
</blockquote>

<p>we see the following output from the <tt class="literal">checkRead()</tt>
method:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">MySecurityManager
java.io.FileInputStream
java.io.FileReader
Test</pre>
</blockquote>

<p>In other words, a method in the <tt class="literal">Test</tt> class
invoked a method in the <tt class="literal">FileReader</tt> class, which
invoked a method in the <tt class="literal">File InputStream</tt> class,
which invoked a method (the <tt class="literal">checkRead()</tt> method,
in fact) in the <tt class="literal">MySecurityManager</tt> class.
</p>

<p>The policies you want to enforce determine how you use the
information about these classes--just keep in mind that the
first class you see is always your security manager class and the
second class you see is normally some class of the Java API. This
last case is not an absolute--it's perfectly legal, though
rare, for any arbitrary class to call the security manager. And as we
saw in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch04_01.htm">Chapter 4, "The Security Manager Class"</a>, some methods are called by
platform-specific classes that implement particular interfaces of the
Java API (such as methods that implement the
<tt class="literal">Toolkit</tt> class).
</p>

<p>Also keep in mind that there may be several classes from the Java API
returned in the class array--for example, when you construct a
new thread, the <tt class="literal">Thread</tt> class calls the
<tt class="literal">checkAccess()</tt> method; the classes returned from
the <tt class="literal">getClassContext() </tt>method in that case are:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">MySecurityManager
java.lang.Thread
java.lang.Thread
java.lang.Thread
java.lang.Thread
Test
Test</pre>
</blockquote>

<p>We get this output because the <tt class="literal">Thread</tt> class
constructor calls three other internal methods before it calls the
security manager. Our <tt class="literal">Test</tt> class has created a
thread in an internal method as well, so the
<tt class="literal">Test</tt> class also appears twice in the class
array.<a name="INDEX-729"></a><a name="INDEX-730"></a><a name="INDEX-731"></a>
</p>

<dl>
<dt>
<b>protected native ClassLoader <a name="INDEX-732"></a>
currentClassLoader()</b>
</dt>
<dd>
<p>Search the array of classes returned from the
<tt class="literal">getClassContext()</tt> method for the most recently
called class that was loaded via a program-defined class loader, and
return that class loader.
</p>
</dd>

</dl>

<p>
<a name="INDEX-733"></a>The objects in the
class array returned from the <tt class="literal">getClassContext()</tt>
method are generally used to inspect the class loader for each
class--that's how the security manager can make a policy
decision about classes that were loaded from disk versus classes that
were loaded from the network (or elsewhere). The simplest test that
we can make is to see if any of the classes involved in the current
method invocation are loaded from the network, in which case we can
deny the attempted operation. This is the method we use to do that.
</p>

<p>To understand <tt class="literal">currentClassLoader()</tt>, we need to
recall how the class loader works. The class loader first calls the
<tt class="literal">findSystemClass()</tt><a name="INDEX-734"></a> method, which attempts to
find the class in the user's <tt class="literal">CLASSPATH</tt> (or
system classpath in 1.2). If that call is unsuccessful, the class
loader loads the class in a different manner (e.g., by loading the
class over the network). As far as the Java virtual machine is
concerned, the class loader associated with a class that was loaded
via the <tt class="literal">findSystemClass()</tt> method is
<tt class="literal">null</tt>. If an instance of the
<tt class="literal">ClassLoader</tt> class defined the class (by calling
the <tt class="literal">defineClass()</tt> method), then (and only then)
does Java make an association between the class and the class loader.
This association is made by storing a reference to the class loader
within the class object itself; the
<tt class="literal">getClassLoader()</tt> method of the
<tt class="literal">Class</tt> object can be used to retrieve that
reference.
</p>

<p>Hence, the <tt class="literal">currentClassLoader()</tt> method is
equivalent to:<a href="#FOOTNOTE-2">[2]</a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-2"></a>
<p>[2]The truth is that the
<tt class="literal">currentClassLoader()</tt> method is written in native
code, so we don't know how it actually is implemented, but it
is functionally equivalent to the code shown. This is true about most
of the methods of this section, which for efficiency reasons are
written in native code.</p> </blockquote>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">protected ClassLoader currentClassLoader () {
    Class c[] = getClassContext();
    for (int i = 1; i &lt; c.length; i++)
        if (c[i].getClassLoader () !=null)
            return c[i].getClassLoader ();
    return null;
}</pre>
</blockquote>

<p>We can use this method to disallow writing to a file by any class
that was loaded via a class loader:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">public void checkWrite(String s) {
    if (currentClassLoader() !=null)
        throw new SecurityException("checkWrite");
    }
}</pre>
</blockquote>

<p>With this version of <tt class="literal">checkWrite()</tt>, only the Java
virtual machine can open a file for writing. When the Java virtual
machine initializes, for example, it may create a thread for playing
audio files. This thread will attempt to open the audio device on the
machine by instantiating one of the standard Java API file classes.
When the instance of this class is created, it (as expected) calls
the <tt class="literal">checkWrite()</tt> method, but there is no class
loader on the stack. The only methods that are involved in the thread
opening the audio device are methods that were loaded by the Java
virtual machine itself and hence have no class loader. Later,
however, if an applet class tries to open up a file on the
user's machine, the <tt class="literal">checkWrite()</tt> method is
called again, and this time there is a class loader on the stack: the
class loader that was used to load in the applet making the call to
open the file. This second case will generate the security <a name="INDEX-735"></a>
exception.<a name="INDEX-736"></a>
</p>

<p>A number of convenience methods of the security manager class also
relate to the current class loader:
</p>

<dl>
<dt>
<b>protected boolean <a name="INDEX-737"></a>
inClassLoader() <img alt="figure" src="gifs/wstar.gif" webstripperlinkwas="gifs/wstar.gif"></b>
</dt>
<dd>
<p>Test to see if there is a class loader on the stack:</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">protected boolean inClassLoader() {
	return currentClassLoader() != null;
}
</pre>
</blockquote>
</dd>


<dt>
<b>protected Class <a name="INDEX-738"></a>
currentLoadedClass() <img alt="figure" src="gifs/wstar.gif" webstripperlinkwas="gifs/wstar.gif"></b>
</dt>
<dd>
<p>Return the class on the stack that is associated with the current
class loader:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">protected Class currentLoadedClass() {
	Class c[] = getClassContext();
	for (int i = 0; i &lt; c.length; i++)	
	if (c[i].getClassLoader() != null)
			return c[i];
	return null;
}
</pre>
</blockquote>
</dd>


<dt>
<b>protected native int <a name="INDEX-739"></a>
classDepth(String name) <img alt="figure" src="gifs/wstar.gif" webstripperlinkwas="gifs/wstar.gif"></b>
</dt>
<dd>
<p>Return the index of the class array from the
<tt class="literal">getClassContext()</tt> method where the named class
is found:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">protected int classDepth(String name) {
    Class c[] = getClassContext();
    for (int i = 0; i &lt; c.length; i++)
        if (c[i].getName().equals(name))
            return i;
    return -1;
}</pre>
</blockquote>
</dd>


<dt>
<b>protected boolean <a name="INDEX-740"></a>
inClass(String name) <img alt="figure" src="gifs/wstar.gif" webstripperlinkwas="gifs/wstar.gif"></b>
</dt>
<dd>
<p>Indicate whether the named class is anywhere on the stack:</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">protected boolean inClass (String name) {
    return classDepth (name) &gt;= 0;
}
</pre>
</blockquote>
</dd>

</dl>

<p>
<a name="INDEX-741"></a><a name="INDEX-742"></a><a name="INDEX-743"></a>Many of these convenience methods
revolve around the idea that an untrusted class may have called a
method of a trusted class and that the trusted class should not be
allowed to perform an operation that the untrusted class could not
have performed directly. These methods allow you to write a Java
application made up of trusted classes that itself downloads and runs
untrusted classes. The HotJava browser is the best-known example of
this sort of program. For example, the security manager of the
HotJava browser does not allow an arbitrary applet to initiate a
print job, but HotJava itself can.
</p>

<p>HotJava initiates a print job when the user selects the
"Print" item from one of the standard menus. Since the
request comes from a class belonging to the HotJava application
itself (that is, the callback method of the menu item), the browser
is initiating the request (at least as far as the security manager is
concerned). An applet initiates the request when it tries to create a
print job.
</p>

<p>In both cases, the <tt class="literal">getPrintJob()</tt> method of the
<tt class="literal">Toolkit</tt> class calls the
<tt class="literal">checkPrintJobAccess()</tt> method of the security
manager. The security manager must then look at the classes on the
stack and determine if the operation should succeed. If there is an
untrusted (applet) class anywhere on the stack, the print request
started with that class and should be rejected; otherwise, the print
request originated from the HotJava classes and is allowed to
proceed.
</p>

<p>Note the similarity between this technique and the manner in which
the access controller works. In Java 1.2, the HotJava classes belong
to the system domain, so they are allowed to do anything; the classes
that make up the applet, however, are prohibited from initiating the
print job (unless, of course, an entry that enables printing for that
applet's code source is in the policy file). This is why these
methods have been deprecated in 1.2, where the access controller is
the desired mechanism to provide this functionality.
</p>

<a name="SEC-CH-6-SECT-1.1"></a>
<h3 class="sect2">6.1.1. The Class Loader Depth</h3>

<p>
<a name="INDEX-744"></a><a name="INDEX-745"></a><a name="INDEX-746"></a>The example that we just gave is
typical of the majority of security checks the security manager
makes. You can often make a decision on whether or not an operation
should be allowed simply by knowing whether or not there is a class
loader on the stack, since the presence of a class loader means that
an untrusted class has initiated the operation in question.
</p>

<p>There's a group of tricky exceptions to this rule, however, and
those exceptions mean that you sometimes have to know the exact depth
at which the class loader was found. Before we dive into those
exceptions, we must emphasize: the use of the class loader depth is
not pretty. Fortunately, beginning with Java 1.2, this method has
been deprecated, and we need no longer concern ourselves with it. If
you need to write a 1.1-compatible security manager, however, you
need to use the information in this section.
</p>

<p>The depth at which the class loader was found in the class context
array can be determined by this method:
</p>

<dl>
<dt>
<b>protected native int <a name="INDEX-747"></a>
classLoaderDepth() <img alt="figure" src="gifs/wstar.gif" webstripperlinkwas="gifs/wstar.gif"></b>
</dt>
<dd>
<p>Return the index of the class array from the
<tt class="literal">getClassContext()</tt> method where the current class
loader is found:
</p>


<h3>Class Definition</h3><blockquote>
<pre class="programlisting">protected int classLoaderDepth() {	
Class c[] = getClassContext();	
	for (int i = 0; i &lt; c.length; i++) {
			if (c[i].getClassLoader() != null)
				return i;	
	}
	return -1;
}</pre>
</blockquote>
</dd>

</dl>
<p>Let's look at this method in the context of the following
applet:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">public class DepthTest extends Applet {
	native void evilInterface();
	
	public void init() {
		doMath();
		infiltrate();
	}
	
	public void infiltrate() {
		try {
			System.loadLibrary("evilLibrary");
			evilInterface();
		} catch (Exception e) {}
	}
	
	public void doMath() {
		BigInteger bi = new BigInteger("100");
		bi = bi.add(new BigInteger("100"));
		System.out.println("answer is " + bi);
	}
}</pre>
</blockquote>

<p>Under normal circumstances, we would expect the
<tt class="literal">doMath()</tt> method to inform us (rather
inefficiently) that 100 plus 100 is 200. We would further expect the
call to the <tt class="literal">infiltrate()</tt> method to generate a
security exception, since an untrusted class is not normally allowed
to link in a native library.
</p>

<p>The security exception in this case is generated by the
<tt class="literal">checkLink()</tt> method of the security manager. When
the <tt class="literal">infiltrate()</tt> method calls the
<tt class="literal">System.loadLibrary()</tt> method, the
<tt class="literal">loadLibrary()</tt> method in turn calls the
<tt class="literal">checkLink()</tt> method. If we were to retrieve the
array of classes (via the <tt class="literal">getClassContext()</tt>
method) that led to the call to the <tt class="literal">checkLink()</tt>
method, we'd see the following classes on the stack:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">MySecurityManager (the checkLink() method)
java.lang.Runtime (the loadLibrary() method)
java.lang.System  (the loadLibrary() method)
DepthTest         (the infiltrate() method)
DepthTest         (the init() method)
... other classes from the browser ...</pre>
</blockquote>

<p>Because the untrusted class <tt class="literal">DepthTest</tt> appears on
the stack, we are tempted to reject the operation and throw a
security exception.
</p>

<p>Life is not quite that simple in this case. As it turns out, the
<tt class="literal">BigInteger</tt> class contains its own native methods
and hence depends on a platform-specific library to perform many of
its operations. When the <tt class="literal">BigInteger</tt> class is
loaded, its static initializer attempts to load the math library (by
calling the <tt class="literal">System.loadLibrary()</tt> method), which
is the library that contains the code to perform these native
methods.
</p>

<p>Because of the way in which Java loads classes, the
<tt class="literal">BigInteger</tt> class is not loaded until it is
actually needed--that is, until the
<tt class="literal">doMath()</tt> method of the
<tt class="literal">DepthTest</tt> class is called. If you recall our
discussion from <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch03_01.htm">Chapter 3, "Java Class Loaders"</a> regarding how the class
loader works, you'll remember that when the
<tt class="literal">doMath()</tt> method is called and needs access to
the <tt class="literal">BigInteger</tt> class, the class loader that
created the <tt class="literal">DepthTest</tt> class is asked to find
that class (even though the <tt class="literal">BigInteger</tt> class is
part of the Java API itself). Hence, the applet class loader (that
is, the class loader that loaded the <tt class="literal">DepthTest</tt>
class) is used to find the <tt class="literal">BigInteger</tt> class,
which it does by calling the <tt class="literal">findSystemClass()
</tt>method. When the <tt class="literal">findSystemClass()</tt>
method loads the <tt class="literal">BigInteger</tt> class from disk, it
runs the static initializers for that class, which call the
<tt class="literal">System.loadLibrary()</tt> method to load in the math
library.
</p>

<p>The upshot of all this is that the
<tt class="literal">System.loadLibrary()</tt> method calls the security
manager to see if the program in question is allowed to link in the
math library. This time, when the <tt class="literal">checkLink()</tt>
method is called, the class array from the
<tt class="literal">getClassContext()</tt> method looks like this:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">MySecurityManager        (the checkLink() method)
java.lang.Runtime        (the loadLibrary() method)
java.lang.System         (the loadLibrary() method)
java.math.BigInteger     (the static intializer)
java.lang.ClassLoader    (the findSystemClass() method)
AppletLoader             (the loadClass() method)
java.lang.ClassLoader    (the loadClassInternal() method)
DepthTest                (the doMath() method)
DepthTest                (the init() method)
... various browser classes ...</pre>
</blockquote>

<p>As we would expect, the first three elements of this list are the
same as the first three elements of the previous list--but after
that, we see a radical difference in the list of classes on the
stack. In both cases, the untrusted class
(<tt class="literal">DepthTest</tt>) is on the stack, but in this second
case, it is much further down the stack than it was in the first
case. In this second case, the untrusted class indirectly caused the
native library to be loaded; in the first case the untrusted class
directly requested the native library to be loaded. That distinction
is what drives the use of the <tt class="literal">classLoaderDepth()</tt>
method.
</p>

<p>So in this example, we need the <tt class="literal">checkLink()</tt>
method to obtain the depth of the class loader (that is, the depth of
the first untrusted class on the stack) and behave appropriately. If
that depth is 3, the <tt class="literal">checkLink()</tt> method should
throw an exception, but if that depth is 7, the
<tt class="literal">checkLink()</tt> method should not throw an
exception. There is nothing magical about a class depth of 7,
however--that just happens to be the depth returned by the
<tt class="literal">classLoaderDepth()</tt> method in our second example.
A different example might well have produced a different number,
depending on the classes<a name="INDEX-748"></a> involved.
</p>

<div class="sidebar">

<h4 class="objtitle">Testing the Security Manager</h4>

<p>
<a name="INDEX-749"></a><a name="INDEX-750"></a>
If you want to know whether or not the security manager will permit a
certain operation, you might be tempted to ask the security manager
directly. If you want to know, for example, if you can change the
state of a particular thread, you might be tempted to write this
code:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">SecurityManager sm = System.getSecurityManager();
boolean canModify = true;
if (sm != null) {
    try {
        sm.checkAccess(myThread);
    } catch (SecurityException se) {
        canModify = false;
    }
}</pre>
</blockquote>

<p>Sometimes this procedure works, and sometimes it doesn't. The
methods of the security manager that depend on the depth of the class
loader usually test for a specific value. In the code fragment above,
the depth of the class loader is 1--which is a depth that most
security managers will not complain about, so the
<tt class="literal">canModify</tt> variable is set to
<tt class="literal">true</tt>. When an actual operation on the thread is
attempted, however, the depth of the class loader will be different,
and the security manager will reacts differently.
</p>

<p>Hence, the only certain way to know if the security manager will
prohibit an operation is to attempt that operation and see if a
security exception is thrown.
</p>
</div>

<p>There is, however, something special about a class depth of 3 in this
example: a class depth of 3 always means that the untrusted class
called the <tt class="literal">System.loadLibrary()</tt> method, which
called the <tt class="literal">Runtime.loadLibrary()</tt> method, which
called the security manager's <tt class="literal">checkLink()</tt>
method.<a href="#FOOTNOTE-3">[3]</a> Hence, when there
is a class depth of 3, it means that the untrusted class has directly
attempted to load the library. When the class depth is greater than
3, the untrusted class has indirectly caused the library to be
loaded. When the class depth is 2, the untrusted class has directly
called the <tt class="literal">Runtime.loadLibrary()</tt>
method--which is to say again that the untrusted class has
directly attempted to load the library. When there is a class depth
of 1, the untrusted class has directly called the
<tt class="literal">checkLink()</tt> method--which is possible, but
that is a meaningless operation. So in this case, a class depth that
is 3 or less (but greater than -1, which means that no untrusted
class is on the stack) indicates that the call came directly from an
untrusted class and should be handled appropriately (usually meaning
that a security exception should be thrown).
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-3"></a>
<p>[3]Theoretically, it could also mean that an
untrusted class has called a trusted class that has called the
<tt class="literal">Runtime.loadLibrary()</tt> method directly. However,
the Java API never bypasses the
<tt class="literal">System.loadLibrary()</tt> method, so that will not
happen in practice. If you expect trusted classes in your Java
application to work under the scenario we're discussing here,
you must also follow that rule.</p> </blockquote>

<p>But while 3 is a magic number for the
<tt class="literal">checkLink()</tt> method, it is not necessarily a
magic number for all other methods. In general, for most methods the
magic number that indicates that an untrusted class directly
attempted an operation is 2: the untrusted class calls the Java API,
which calls the security manager. Other classes have other
constraints on them that change what their target number should be.
</p>

<p>The class depth is therefore a tricky thing: there is no general rule
about the allowable class depth for an untrusted class. Worse,
there's no assurance that the allowable class depth may not
change between releases of the JDK--the JDK could conceivably
change its internal algorithm for a particular operation to add
another method call, which would increase the allowable class depth
by 1. This is one reason why the class depth is such a bad idea: it
requires an intimate knowledge of all the trusted classes in the API
in order to pick an appropriate class depth. Worse, a developer may
introduce a new method into a call stack and completely change the
class depth for a sensitive operation without realizing the effect
this will have on the security manager.
</p>

<p>Nonetheless, in order for certain classes of the Java API to work
correctly, you need to put the correct information into your
1.1-based security manager (such as in the
<tt class="literal">checkLink()</tt> method that we just examined). The
methods that need such treatment are summarized in <a href="#SEC-CH-6-TABLE-10">Table 6-2</a>.
</p>

<a name="SEC-CH-6-TABLE-10"></a>
<h4 class="objtitle">Table 6-2. Methods of the SecurityManager Class Affected by the Depth of the Class Loader</h4>
<table border="1">




<tr>
<th>
<p>Method</p>
</th>
<th>
<p>Depth to Avoid</p>
</th>
<th>
<p>Remarks</p>
</th>
</tr>

<tr>
<td>
<a name="INDEX-751"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkCreateClassLoader()</pre>
</blockquote>
</td>
<td>
<p>2</p>
</td>
<td>
<p>Java beans create a</p>

<p>
<tt class="literal">SystemClassLoader</tt>
</p>
</td>
</tr>
<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkPropertiesAccess()</pre>
</blockquote>
</td>
<td>
<p>2</p>
</td>
<td>
<p>Java API calls </p>

<p>
<tt class="literal">System.getProperties()</tt>
</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-752"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkPropertyAccess()</pre>
</blockquote>
</td>
<td>
<p>2</p>
</td>
<td>
<p>Java API gets many properties</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-753"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkAccess(Thread t)</pre>
</blockquote>
</td>
<td>
<p>3</p>
</td>
<td>
<p>Java API manipulates its own threads</p>
</td>
</tr>
<tr>
<td>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkAccess(ThreadGroup tg)</pre>
</blockquote>
</td>
<td>
<p>(sometimes 4)</p>
</td>
<td>
<p>Java API manipulates its own thread groups</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-754"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkLink()</pre>
</blockquote>
</td>
<td>
<p>2 or 3</p>
</td>
<td>
<p>Java API loads many libraries</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-755"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkMemberAccess()</pre>
</blockquote>
</td>
<td>
<p>3</p>
</td>
<td>
<p>Java API uses method reflection</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-756"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkExec()</pre>
</blockquote>
</td>
<td>
<p>2</p>
</td>
<td>
<p>Toolkit implementations of <tt class="literal">getPrintJob()</tt> may
execute a print command
</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-757"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkExit()</pre>
</blockquote>
</td>
<td>
<p>2</p>
</td>
<td>
<p>The application may call<tt class="literal"> exit</tt>
</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-758"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkWrite()</pre>
</blockquote>
</td>
<td>
<p>2</p>
</td>
<td>
<p>Toolkit implementations may create temporary files; the Java API
needs to write to audio and other device files
</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-759"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkDelete()</pre>
</blockquote>
</td>
<td>
<p>2</p>
</td>
<td>
<p>Toolkit implementations may need to delete temporary files</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-760"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkRead()</pre>
</blockquote>
</td>
<td>
<p>2</p>
</td>
<td>
<p>Java API needs to read property files</p>
</td>
</tr>
<tr>
<td>
<a name="INDEX-761"></a>
<h3>Class Definition</h3><blockquote>
<pre class="programlisting">checkTopLevelWindow()</pre>
</blockquote>
</td>
<td>
<p>3</p>
</td>
<td>
<p>Trusted classes may need pop-up windows</p>
</td>
</tr>

</table>

<p>In all cases in <a href="#SEC-CH-6-TABLE-10">Table 6-2</a>, the Java API depends on
being allowed to perform an operation that would normally be rejected
if an untrusted class performed it directly. The JavaBeans classes,
for example, create a class loader (an instance of
<tt class="literal">SystemClassLoader</tt>) in order to abstract the
primordial class loader. So if an untrusted class creates a Java
bean, that Java bean must in turn be allowed to create a class
loader, or the bean itself won't work.
</p>

<p>Note that not every target depth in this table is 2. In the case of
the <tt class="literal">Thread</tt> and <tt class="literal">ThreadGroup</tt>
classes, operations that affect the state of the thread call the
<tt class="literal">checkAccess()</tt> method of the
<tt class="literal">Thread</tt> or <tt class="literal">ThreadGroup</tt> class
itself, which in turn calls the <tt class="literal">checkAccess()</tt>
method of the <tt class="literal">SecurityManager</tt> class. This extra
method call results in an extra method on the stack and effectively
increases the target depth by 1. Similarly, the
<tt class="literal">checkTopLevelWindow()</tt> method is called from the
constructor of the <tt class="literal">Window</tt> class, which in turn
is called from the constructor of the <tt class="literal">Frame</tt>
class, resulting in a target depth of 3.
</p>

<p>Remember that this table only summarizes the methods of the security
manager where the actual depth of the class loader matters to the
core Java API. If you're writing your own application, you need
to consider whether or not your application classes want to perform
certain operations. If you want classes in your application to be
able to initiate a print job, for example, and you don't want
untrusted classes that your application loads to initiate a print
job, you'll want to put a depth check of 2 into the
<tt class="literal">checkPrintJobAccess()</tt> method. In general, for
methods that aren't listed in the above table, a depth of 2 is
appropriate if you want your application classes (i.e., classes from
the <tt class="literal">CLASSPATH</tt>) to be able to perform those
operations.
</p>

<p>There is once again a nice similarity between these ideas and the
access controller. When you call the
<tt class="literal">doPrivileged()</tt><a name="INDEX-762"></a>
method of the access controller, you're achieving the same
thing a security manager achieves by testing the class depth. The
point to remember about the class depth is that it allows the
security manager to grant more permissions to a class than it would
normally have--just like the <tt class="literal">doPrivileged()</tt>
method grants its permissions to all protection domains that have
previously been pushed onto the stack. Of course, the access
controller is a much smarter way to go about this, since it
doesn't depend upon someone getting the class depth right; it
only depends upon the actual characteristics of the stack during
execution of the program.<a name="INDEX-763"></a><a name="INDEX-764"></a><a name="INDEX-765"></a>
</p>


<a name="SEC-CH-6-SECT-1.2"></a>
<h3 class="sect2">6.1.2. Protected Instance Variables in the Security Manager</h3>

<p>
<a name="INDEX-766"></a><a name="INDEX-767"></a>There is a single protected instance
variable in the security manager class, and that is the
<tt class="literal">inCheck</tt><a name="INDEX-768"></a> instance variable:
</p>

<dl>
<dt>
<b>protected boolean inCheck <img alt="figure" src="gifs/wstar.gif" webstripperlinkwas="gifs/wstar.gif"></b>
</dt>
<dd>
<p>
<a name="INDEX-769"></a>Indicate whether a check by the
security manager is in progress.
</p>
</dd>

</dl>

<p>The value of this variable can be obtained from the following method:</p>

<dl>
<dt>
<b>public boolean <a name="INDEX-770"></a>
getInCheck() <img alt="figure" src="gifs/wstar.gif" webstripperlinkwas="gifs/wstar.gif"></b>
</dt>
<dd>
<p>Return the value of the <tt class="literal">inCheck</tt> instance
variable.
</p>
</dd>

</dl>

<p>Since there is no corresponding public method to set this variable,
it is up to the security manager itself to set
<tt class="literal">inCheck</tt> appropriately.<a href="#FOOTNOTE-4">[4]</a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-4"></a>
<p>[4]Don't
get all excited and think that your untrusted class can use this
method to see when the security manager is working. As we'll
see, it's only set by the security manager in a rare case, and
even if it were set consistently, there's no practical way for
your untrusted class to examine the variable during the short period
of time it is set.</p> </blockquote>

<p>This variable has a single use: it must be set by the security
manager before the security manager calls most methods of the
<tt class="literal">InetAddress</tt><a name="INDEX-771"></a> class. The reason for this is to prevent
an infinite recursion between the security manager and the
<tt class="literal">InetAddress</tt> class. This recursion is possible
under the following circumstances.
</p>

<ol>
<li>
<p>An <a name="INDEX-772"></a>untrusted class
attempts to open a socket to a particular host (e.g.,
<em class="filename">sun.com</em>). The expectation is that if the
untrusted class was loaded from <em class="filename">sun.com</em> that the
operation will succeed; otherwise, the operation will fail.
</p>
</li>
<li>
<p>Opening the socket results in a call to the
<tt class="literal">checkConnect()</tt><a name="INDEX-773"></a> method, which must determine if
the two hosts in question are the same. In the case of a class loaded
from <em class="filename">sun.com</em> that is attempting to connect to
<em class="filename">sun.com</em>, a simple string comparison is
sufficient. If the names are the same, the
<tt class="literal">checkConnect()</tt> method can simply return
immediately. In fact, this is the only logic performed by some
browsers--if the names do not literally match, the operation is
denied immediately.
</p>
</li>
<li>
<p>A complication arises if the two names do not match directly, but may
still be the same host. My machine has a fully qualified name of
<em class="filename">piccolo.East.Sun.COM</em>; browsers on my local area
network can access my machine's web server as
<em class="filename">piccolo</em>, <em class="filename">piccolo.East</em>, or
<em class="filename">piccolo.East.Sun.COM</em>. If the untrusted class is
loaded from a URL that contained only the string
<em class="filename">piccolo,</em> and the class attempts to open a socket
to <em class="filename">piccolo.East</em>, we may want that operation to
succeed even though the names of the hosts are not equal.
</p>

<p>Hence, the <tt class="literal">checkConnect()</tt> method must retrieve
the IP address for both names, and compare those IP addresses.
</p>
</li>
<li>
<p>To retrieve the IP address for a particular host, the
<tt class="literal">checkConnect()</tt> method must call the
<tt class="literal">InetAddress.getByName()</tt> method, which converts a
string to an IP address.
</p>
</li>
<li>
<p>The <tt class="literal">getByName()</tt><a name="INDEX-774"></a> method will not blithely
convert a hostname to an IP address--it will only do so if the
program in question is normally allowed to make a socket connection
to that host. Otherwise, an untrusted class could be downloaded into
your corporate network and determine all the IP addresses that are
available on the network behind your firewall. So the
<tt class="literal">getByName()</tt> method needs to call the
<tt class="literal">checkConnect()</tt> method in order to ensure that
the program is allowed to retrieve the information that is being
requested.
</p>
</li>
</ol>

<p>We see the problem here: the <tt class="literal">getByName()</tt> method
keeps calling the <tt class="literal">checkConnect()</tt> method, which
in turn keeps calling the <tt class="literal">getByName()</tt> method. In
order to prevent this recursion, the
<tt class="literal">checkConnect()</tt> method is responsible for setting
the <tt class="literal">inCheck</tt> instance variable to
<tt class="literal">true</tt> before it starts and then setting it to
<tt class="literal">false</tt> when it is finished. Similarly, the
<tt class="literal">getByName()</tt> method is responsible for examining
this variable (via the return from the
<tt class="literal">getInCheck()</tt> method); it does not call the
<tt class="literal">checkConnect()</tt> method if a security check is
already in progress.
</p>

<p>There may be other variations in this cooperation between the
security manager and the <tt class="literal">InetAddress</tt>
class--other methods of the <tt class="literal">InetAddress</tt>
class also use the information from the
<tt class="literal">getInCheck()</tt> method to determine whether or not
to call the <tt class="literal">checkConnect()</tt> method. But this is
the only class where this information is used directly. You can set
the <tt class="literal">inCheck</tt> method within other methods of your
security manager, but there is no point in doing so.
</p>

<p>In 1.2, this variable and method are deprecated. The correct
operation to perform in a 1.2-based security manager is to place the
calls to the <tt class="literal">InetAddress</tt> in a class that can be
used by the <tt class="literal">doPrivileged()</tt> method. In addition,
the <tt class="literal">InetAddress</tt> class in 1.2 no longer calls the
<tt class="literal">getInCheck()</tt> method.
</p>

<p>If you implement a <tt class="literal">checkConnect()</tt> method that
calls the <tt class="literal">InetAddress</tt> class and sets the
<tt class="literal">inCheck</tt> variable, you must make the
<tt class="literal">checkConnect()</tt> method and the
<tt class="literal">getInCheck()</tt> methods synchronized. This prevents
another thread from directly looking up an IP address at the same
time that the security manager has told the
<tt class="literal">InetAddress</tt> class not to call the
<tt class="literal">checkConnect()</tt><a name="INDEX-775"></a><a name="INDEX-776"></a><a name="INDEX-777"></a><a name="INDEX-778"></a> method.<a name="INDEX-779"></a><a name="INDEX-780"></a>
</p>













<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_07.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch05_07.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch06_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch06_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">5.7. Summary</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">6.2. Security Managers and the Class Loader</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
