<html>
<head>
<title>Certificates (Java Security)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Scott Oaks">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-403-7E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Certificates">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm" alt="Java Security"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch10_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch10_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch10_01.htm">Chapter 10: Keys and Certificates</a></td><td align="right" valign="top" width="172"><a href="ch10_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch10_05.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">10.4. Certificates</h2>

<p>
<a name="INDEX-1258"></a><a name="INDEX-1259"></a><a name="INDEX-1260"></a><a name="INDEX-1261"></a>
When you are given a public and private key, you often need to
provide other people with your public key. If you sign a digital
document (using your private key), the recipient of that document
will need your public key in order to verify your digital signature.
</p>

<p>
<a name="INDEX-1262"></a><a name="INDEX-1263"></a>
The inherent problem with a key is that it does not provide any
information about the identity to which it belongs; a key is really
just a sequence of seemingly arbitrary numbers. If I want you to
accept a document that I digitally signed, I could mail you my public
key, but you normally have no assurance that the key (and the
original email) came from me at all. I could, of course, digitally
sign the e-mail so that you knew that it came from me, but
there's a circular chain here--without my public key, you
cannot verify the digital signature. You would need my public key in
order to authenticate the public key I've just sent you.
</p>

<p>Certificates solve this problem by having a well-known entity (called
a certificate <a name="INDEX-1264"></a><a name="INDEX-1265"></a>authority, or CA) verify the
public key that is being sent to you. A certificate can give you the
assurance that the public key in the certificate does indeed belong
to the entity that the certificate authority says it does. However,
the certificate only validates the public key it contains: just
because Fred sends you his public key in a valid certificate does not
mean that Fred is to be trusted; it only means that the public key in
question does in fact belong to Fred.
</p>

<p>In practice, the key may not belong to Fred at all; certificate
authorities have different levels at which they assess the identity
of the entity named in the certificate. Some of these levels are very
stringent and require the CA to do an extensive verification that
Fred is who he says he is. Other levels are not stringent at all, and
if Fred can produce a few dollars and a credit card, he is assumed to
be Fred. Hence, one of the steps in the process of deciding whether
or not to trust the entity named in the certificate includes the
level at which the certificate authority generated the certificate.
Each certificate authority varies in its approach to validating
identities, and each publishes its approach to help you understand
the potential risks involved in accepting such a certificate.
</p>

<p>A certificate contains three pieces of information (as shown in <a href="#SEC-CH-10-FIG-3">Figure 10-2</a>):
</p>

<ul>
<li>
<p>The name of the entity for whom the certificate has been issued. This
entity is referred to as the subject of the certificate.
</p>
</li>
<li>
<p>The public key associated with the subject.</p>
</li>
<li>
<p>A digital signature that verifies the information of the certificate.
The certificate is signed by the issuer of the certificate.
</p>
</li>
</ul>
<a name="SEC-CH-10-FIG-3"></a>
<div class="figure">
<img alt="figure" src="figs/JSEC_1002.gif" webstripperlinkwas="figs/JSEC_1002.gif"></div>
<h4 class="objtitle">Figure 10-2. Logical representation of a certificate </h4>

<p>Because the certificate carries a digital signature of the
certificate authority, we can verify that digital signature--and
if the verification succeeds, we can be assured that the public key
in the certificate does in fact belong to the entity the certificate
claims (subject to the level at which the CA verified the subject).
</p>

<p>We still have a bootstrapping problem here--how do we obtain the
public key of the certificate authority? We could have a certificate
that contains the public key of the certificate authority, but who is
going to authenticate <em class="emphasis">that</em> certificate?
</p>

<p>This bootstrapping problem is one reason why key management (see
<a href="ch11_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch11_01.htm">Chapter 11, "Key Management"</a>) is such a hard topic. Most Java-enabled
browsers solve this problem by providing the public keys for certain
well-known certificate authorities along with the browser. This has
worked well in practice, though it clearly is not an airtight
solution (especially when the browser is downloaded from some site on
the Internet--theoretically, the certificates that come with the
browser could be tampered with as they are in transit). Although
there are various proposals to strengthen this model, for now we will
assume that the certificate of at least one well-known certificate
authority is delivered along with the Java application. This
situation allows me to mail you a certificate containing my public
key; if the certificate is signed by a certificate authority you know
about, you are assured that the public key actually belongs to me.
</p>

<p>There are many well-known certificate authorities--and therein
lies another problem. I may send you a certificate that is signed by
the United States Post Office, but that certificate authority may not
be one of the certificate authorities you recognize. Simply sending a
public key in a certificate does not mean that the recipient of the
public key will accept it. A more important implication of this is
that a key management system needs to be prepared to assign multiple
certificates to a particular individual, potentially one from each of
several certificate authorities.
</p>

<p>Another implication of this profusion of certificate authorities is
that certificates are often supplied as a chain. Let's say that
you have the certificate of the U.S. Post Office certificate
authority, and I want to send you my certificate that has been
generated by the Acme Certificate company. In order for you to accept
this certificate, I must send you a chain of certificates: my
certificate (certified by the Acme Certificate company), and a
certificate for the Acme Certificate company (certified by the U.S.
Post Office). This chain of certificates may be arbitrarily
long.<a name="INDEX-1266"></a><a name="INDEX-1267"></a>
</p>

<p>The last certificate in this chain--that is, the public key for
a certificate authority--is generally stored in a certificate
that is self-signed: the certificate authority has signed the
certificate that contains its own public key. Self-signed
certificates tend to crop up frequently in the Java world as well,
since the tools that come with the JDK will create self-signed
certificates. The certificates are intended to be submitted to a
certificate authority, who will then return a CA-signed certificate.
But there's no reason why the certificate itself can't be
used as a valid certificate. Whether or not you want to accept a
self-signed certificate is up to you, but it obviously carries
certain risks.
</p>

<p>
<a name="INDEX-1268"></a>Finally, for all this talk of
certificates, you have to consider whether or not they are actually
necessary to support your application. If you'll generally be
receiving signed items from people you do not know (e.g., a signed
JAR file from a web site), then they are absolutely necessary. On the
other hand, large-scale computer installations often consider using
certificates to authenticate and validate their employees; this
results in a computer system that has much better internal security
than one that relies solely on passwords. But it is not the
certificate that generates the security advantage, it is the use of
public key cryptography. The computer installation can achieve the
same level of security without using a certificate infrastructure.
</p>

<p>Consider the security necessary to support XYZ Corporation's
payroll application. When an employee wants to view her payroll
statements, she must submit a digitally signed request to do so.
Hence, XYZ should distribute to each employee a private key to be
used to create the digital signature. XYZ can also store the
employee's public keys in a database; when a request comes that
claims to be from a particular employee, the payroll server can
simply examine the database to obtain that employee's public
key and verify the signature. No certificate is required in this
case--and in general, no certificate is required when the
recipient of the digital signature is already known to have the
public key of the entity that signed the data. For applications
within a corporation, this is almost always the case.
</p>

<p>We issue this caveat about certificates being necessary because
certificate support in Java (even in Java 1.2) is not fully
complete--while it is possible to set up your own certificate
authority to distribute the certificates for your company, it's
very hard to write the necessary code to do that in Java (at
present). Hence, we'll focus our discussion of the certificate
API on accepting (i.e., validating) existing certificates.
</p>

<div class="sidebar">
<h4 class="objtitle">Certificate: Class or Interface</h4>

<p>
<a name="INDEX-1269"></a><a name="INDEX-1270"></a>There's an unfortunate
ambiguity in Java's use of the term "certificate."
In Java 1.1, an interface called
<tt class="literal">java.security.Certificate</tt> was introduced and
used by the <tt class="literal">javakey</tt> utility and by the
<tt class="literal">appletviewer</tt> when they used signed classes. The
<tt class="literal">Certificate</tt> interface was implemented by
platform-specific classes.
</p>

<p>
<a name="INDEX-1271"></a><a name="INDEX-1272"></a>In Java 1.2, there is a new class
called <tt class="literal">java.security.cert.Certificate</tt>. This
class is the preferred class for all interactions with certificates,
and is used by the utilities provided with the 1.2 JDK. The
<tt class="literal">java.security.Certificate</tt> interface has been
deprecated starting with Java 1.2.
</p>

<p>One problem where this manifests itself is with
<tt class="literal">import</tt> statements. If you import the following
packages:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">import java.security.*;
import java.security.cert.*;</pre>
</blockquote>

<p>the compiler will be unable to reconcile the definition of
<tt class="literal">Certificate</tt>. When dealing with certificates,
you'll either need to refer to them by their fully qualified
name or only import those classes in the security package that you
explicitly need.
</p>

<p>In the main text of this book, whenever we talk about a certificate
object, we mean an instance of the
<tt class="literal">java.security.cert.Certificate</tt> class (or one of
its subclasses). Except for some examples in <a href="appb_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/appb_01.htm">Appendix B, "Identity-Based Key Management"</a>, we will not show usage of the
<tt class="literal">Certificate</tt> interface.
</p>
</div>

<a name="SEC-CH-10-SECT-4.1"></a>
<h3 class="sect2">10.4.1. The Certificate Class</h3>

<p>There are many formats that a certificate can take (depending on the
cryptographic algorithms used to produce the certificate). Hence, the
Java API abstracts the generic notion of a certificate with the
<tt class="literal">Certificate</tt> class
(<tt class="literal">java.security.cert.Certificate</tt>):
</p>

<dl>
<dt>
<b>public abstract class Certificate <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Provide the necessary (and very basic) operations to support a
certificate.
</p>
</dd>

</dl>

<p>Like many classes in the Java security package, the
<tt class="literal">Certificate</tt> class is abstract; it relies upon
application-specific classes to provide its implementation. In the
case of the JDK, there are classes in the <tt class="literal">sun</tt>
package that implement certain certificate formats (but more about
that in just a bit).
</p>

<p>There are three essential operations that you can perform upon a
certificate:
</p>

<dl>
<dt>
<b>public abstract byte[] getEncoded() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return a byte array of the certificate. All certificates must have a
format in which they may be transmitted as a series of bytes, but the
details of this encoding format are specific to the type of the
certificate. If the encoding cannot be generated, a
<tt class="literal">CertificateEncodingException</tt> is thrown.
</p>
</dd>

<dt>
<b>public abstract void verify(PublicKey pk) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dt>
<b>public abstract void verify(PublicKey pk, String provider) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Verify that the certificate is valid. In order to verify a
certificate, you must have the public key of the certificate
authority that issued it; a valid certificate is one in which the
signature of the certificate authority is valid. A valid certificate
does not imply anything about the trustworthiness of the certificate
authority or the subject to which the certificate belongs; it merely
means that the signature in the certificate is valid for the supplied
public key. If the certificate is invalid, this method throws a
<tt class="literal">CertificateException</tt>.
</p>

<p>The signature is verified according to the digital signature details
we'll examine in <a href="ch12_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch12_01.htm">Chapter 12, "Digital Signatures"</a>. The process of
creating an object to verify the digital signature as well as the
actual verification of the signature may thrown a
<tt class="literal">NoSuchProviderException</tt>, a
<tt class="literal">NoSuchAlgorithmException</tt>, an
<tt class="literal">InvalidKeyException</tt>, or a
<tt class="literal">SignatureException</tt>.
</p>
</dd>

<dt>
<b> public abstract PublicKey getPublicKey() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Extract the public key from the certificate--that is, the key
that belongs to the subject the certificate vouches for.
</p>
</dd>

</dl>

<p>These are the basic operations that are valid for any certificate.
Notice that while we can encode a certificate into a byte array in
order to transmit the certificate, there is nothing in the basic API
that allows us to create a certificate from such a byte array. In
fact, there's no practical way to instantiate a certificate
object at all; the <tt class="literal">Certificate</tt> class is usually
used as a base class from which individual certificate types are
derived. Fortunately, the next class allows us to import
certificates.
</p>


<a name="SEC-CH-10-SECT-4.2"></a>
<h3 class="sect2">10.4.2. The CertificateFactory Class</h3>

<p>If you need to import a certificate into a program, you do so by
using the <tt class="literal">CertificateFactory</tt> class
(<tt class="literal">java.security.cert.CertificateFactory</tt>). That
class is an engine class, and it has the following interface:
</p>

<dl>
<dt>
<b>public static CertificateFactory getInstance(String type)<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dt>
<b>
<a name="INDEX-1273"></a>
<a name="INDEX-1274"></a>
public static CertificateFactory getInstance(String type, String provider)<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return a certificate factory that may be used to import certificates
of the specified type (optionally implemented by the given provider).
A <tt class="literal">CertificateException</tt> will be thrown if the given
factory cannot be found or created; if the given provider is not
found, a <tt class="literal">NoSuchProviderException</tt> will be thrown.
The default Sun security provider has one certificate factory that
works with certificates of type X509.
</p>
</dd>

<dt>
<b>public String getProvider()<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the provider that implemented this factory.</p>
</dd>

<dt>
<b>public String getType()<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the type of certificates that this factory can import.</p>
</dd>

<dt>
<b>public final Certificate generateCertificate(InputStream is)<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return a certificate that has been read in from the specified input
stream. For the default Sun security provider, the input stream must
be an X509 certificate in RFC 1421 format (that is, a DER-encoded
certificate that has been translated into 7-bit ASCII characters);
this is the most common format for transmission of X509 certificates.
</p>
</dd>

<dt>
<b>public final Collection generateCertificates(InputStream is)<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return a collection of certificates that have been defined in the
given input stream. For the default Sun provider, the input stream in
this case may have a single RFC 1421 formatted certificate, or it may
contain a certificate chain in PKCS#7 format.
</p>
</dd>

<dt>
<b>public final CRL generateCRL(InputStream is)<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Define a certificate revocation list from the data in the input
stream.
</p>
</dd>

<dt>
<b>public final Collection generateCRLs(InputStream is)<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Define a collection of CRLs from the data in the input stream.</p>
</dd>

</dl>

<p>Note that the <tt class="literal">CertificateFactory</tt> class cannot
generate a new certificate--it may only import a certificate
from an input stream. This is one reason why it's hard to
provide a certificate authority based solely on the standard Java
API. In the next section, we'll see an example of reading a
certificate through this interface.
</p>

<p>The <tt class="literal">CertificateFactory</tt> is an engine class, so it
has a companion SPI class--the
<tt class="literal">CertificateFactorySpi</tt> class--that can be used
if you want to implement your own certificate factory. Implementing
such a class follows the familiar rules of engine classes: you must
define a constructor that takes the type name as a parameter and
then, for each of the public methods listed above, you must implement
a corresponding engine method with the same parameters. Certificates
are complicated things, and parsing their encoding is a complicated
procedure, so we won't bother showing an example of the engine
class.
</p>


<a name="SEC-CH-10-SECT-4.3"></a>
<h3 class="sect2">10.4.3. The X509Certificate Class</h3>

<p>
<a name="INDEX-1275"></a><a name="INDEX-1276"></a><a name="INDEX-1277"></a><a name="INDEX-1278"></a>As we mentioned, there are many
certificate formats that could be in use by a key management system;
one of the most common of these is the X509 format. X509 has gone
through a few revisions; the version supported by the Java API is
version 3. This format is an ANSI standard for certificates, and
while there are PGP and other certificate formats in the world, the
X509 format is dominant. This is the only format of certificate for
which Java provides a standard API; if you want to support another
certificate format, you must implement your own subclass of
<tt class="literal">Certificate</tt>.
</p>

<p>The <tt class="literal">X509Certificate</tt> class
(<tt class="literal">java.security.cert.X509Certificate</tt>) is defined
as follows:
</p>

<dl>
<dt>
<b>public abstract class X509Certificate extends Certificate implements X509Extension <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Provide an infrastructure to support X509 version 3 formatted
certificates.
</p>
</dd>

</dl>

<p>An X509 certificate has a number of properties that are not shared by
its base class:
</p>

<ul>
<li>
<p>A start and end date: An X509 certificate is valid only for a certain
period of time, as specified by these dates.
</p>
</li>
<li>
<p>A version: Various versions of the X509 standard exist; the default
implementation of this class supports version 3 of the standard.
</p>
</li>
<li>
<p>A serial number: Each certificate that is issued by a certificate
authority must have a unique serial number. The serial number is only
unique for a particular authority, so that the combination of serial
number and certificate authority guarantee a unique certificate.
</p>
</li>
<li>
<p>The distinguished name<a href="#FOOTNOTE-4">[4]</a> of the certificate authority.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-4"></a>
<p>[4]See <a href="ch11_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch11_01.htm">the sidebar "What's in a Name?"</a> in <a href="ch11_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch11_01.htm">Chapter 11, "Key Management"</a> for an explanation of distinguished
names.</p> </blockquote>
</li>
<li>
<p>The distinguished name of the subject represented by the certificate.</p>
</li>
</ul>

<p>These properties can be retrieved with the following set of methods:</p>

<dl>
<dt>
<b>public abstract void checkValidity() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dt>
<b>public abstract void checkValidity(Date d) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Check that the specified date (or today if no date is specified) is
within the start and end dates for which the certificate is valid. If
the specified date is before the start date of the certificate, a
<tt class="literal">CertificateNotYetValidException</tt> is thrown; if it
is after the end date of the certificate, a
<tt class="literal">CertificateExpiredException</tt> is thrown.
</p>
</dd>

<dt>
<b>public abstract int getVersion() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the version of the X509 specification that this certificate
was created with. For the Sun implementation, this will be version 3.
</p>
</dd>

<dt>
<b>public abstract BigInteger getSerialNumber() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the serial number of the certificate.</p>
</dd>

<dt>
<b>public abstract Principal getIssuerDN() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Extract the distinguished name of the certificate authority from the
certificate and use that name to instantiate a principal object.
</p>
</dd>

<dt>
<b>public abstract Principal getSubjectDN() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Extract the distinguished name of the subject entity in the
certificate and use that name to instantiate a principal object.
</p>
</dd>

<dt>
<b>public abstract Date getNotBefore() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the first date on which the certificate is valid.</p>
</dd>

<dt>
<b>public abstract Date getNotAfter() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the date after which the certificate is invalid.</p>
</dd>

</dl>

<p>From a programmatic view, these are the most useful of the attributes
of a certificate. If your X509 certificate is contained in the file
<em class="filename">sdo.cer</em>, you could import and print out
information about the certificate as follows:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">public class PrintCert {
	public static void main(String args[]) {
		try {
			FileInputStream fr = new FileInputStream("sdo.cer");
			CertificateFactory cf = 						
					   CertificateFactory.getInstance("X509");
			X509Certificate c = (X509Certificate) 
								cf.generateCertificate(fr);
		System.out.println("Read in the following certificate:");
			System.out.println("\tCertificate for: " +
									 c.getSubjectDN());
			System.out.println("\tCertificate issued by: " +
									 c.getIssuerDN());
			System.out.println("\tThe certificate is valid from " +
						c.getNotBefore() + " to " + c.getNotAfter());
			System.out.println("\tCertificate SN# " +
									 c.getSerialNumber());
			System.out.println("\tGenerated with " +
									 c.getSigAlgName());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}</pre>
</blockquote>

<p>Running this program would produce the following output:</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">Read in the following certificate:
	Certificate for:
		CN=Scott Oaks, OU=SMCC, O=Sun Microsystems, L=NY, S=NY, C=US
	Certificate issued by:
		CN=Scott Oaks, OU=SMCC, O=Sun Microsystems, L=NY, S=NY, C=US
	The certificate is valid from Sun Oct 19 11:40:24 EDT 1997 to
		Sat Jan 17 10:40:24 EST 1998
	Certificate SN# 3895020084
	Generated with SHA1withDSA</pre>
</blockquote>


<a name="INDEX-1279"></a>

<a name="SEC-CH-10-SECT-4.4"></a>
<h3 class="sect2">10.4.4. Advanced X509Certificate Methods</h3>

<p>
<a name="INDEX-1280"></a>There are a number of other methods of
the <tt class="literal">X509Certificate</tt> class. For the purposes of
this book, these methods are not generally useful; they enable you to
perform more introspection on the certificate itself. We'll
list these methods here simply as a matter of record.
</p>

<dl>
<dt>
<b>public abstract byte[] getTBSCertificate() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1281"></a>
<a name="INDEX-1282"></a>
<a name="INDEX-1283"></a>
</b>
</dt>
<dd>
<p>Get the DER-encoded TBS certificate. The TBS certificate is the body
of the actual certificate; it contains all the naming and key
information held in the certificate. The only information in the
actual certificate that is not held in the TBS certificate is the
name of the algorithm used to sign the certificate and the signature
itself.
</p>

<p>The TBS certificate is used as the input data to the signature
algorithm when the certificate is signed or verified.
</p>
</dd>

<dt>
<b>public abstract byte[] getSignature() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Get the raw signature bytes of the certificate. These bytes could be
used to verify the signature explicitly (e.g., using the methods
we'll describe in <a href="ch12_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch12_01.htm">Chapter 12, "Digital Signatures"</a>) instead of
relying upon the <tt class="literal">verify()</tt> method to do so.
</p>
</dd>

<dt>
<b>public abstract String getSigAlgName() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the name of the algorithm that was used to sign the
certificate. For the Sun implementation, this will always be
<tt class="literal">SHA1withDSA</tt>.
</p>
</dd>

<dt>
<b>public String getSigAlgOID() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the OID of the signature algorithm used to produce the
certificate.
</p>
</dd>

<dt>
<b>public abstract byte[] getSigAlgParams() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the DER-encoded parameters that were used to generate the
signature. In general, this will return <tt class="literal">null</tt>,
since the parameters are usually specified by the certificate
authority's public key.
</p>
</dd>

<dt>
<b>public abstract byte[] getIssuerUniqueID() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the unique identifier for the issuer of the certificate. The
presence of a unique identifier for each issuer allows the names to
be reused, although in general it is recommended that certificates
not make use of the unique identifier.
</p>
</dd>

<dt>
<b>public abstract byte[] getSubjectUniqueID() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the unique identifier for the subject of the certificate
(again, this is unused in general).
</p>
</dd>

<dt>
<b>public abstract BitSet getKeyUsage() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the <a name="INDEX-1284"></a>key usage extension, which defines
the purpose of the key: the key may be used for digital signing,
nonrepudiation, key encipherment, data encipherment, key agreement,
certificate signing, and more. The key usage is an extension to the
X509 specification and need not be present in all X509 certificates.
</p>
</dd>

<dt>
<b>public abstract int getBasicConstraints() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>An X509 certificate may contain an optional extension that identifies
whether the subject of the certificate is a certificate authority. If
the subject is a CA, this extension returns the number of
certificates that may follow this certificate in a certification
chain.<a name="INDEX-1285"></a><a name="INDEX-1286"></a><a name="INDEX-1287"></a><a name="INDEX-1288"></a>
</p>
</dd>

</dl>


<a name="SEC-CH-10-SECT-4.5"></a>
<h3 class="sect2">10.4.5. Revoked Certificates</h3>

<p>
<a name="INDEX-1289"></a><a name="INDEX-1290"></a><a name="INDEX-1291"></a><a name="INDEX-1292"></a><a name="INDEX-1293"></a>Occasionally, a
certificate authority needs to revoke a certificate it has
issued--perhaps the certificate was issued under false
pretenses, or maybe the user of the certificate has engaged in
illegal conduct using the certificate. Under circumstances such as
these, the expiration date attached to the certificate is
insufficient protection; the certificate must be immediately
invalidated.
</p>

<p>This invalidation occurs as the result of a <a name="INDEX-1294"></a>CRL--a
certificate revocation list. Certificate authorities are responsible
for issuing certificate revocation lists that contain (predictably) a
list of certificates the authority has revoked. Validators of
certificates are required to consult this list before accepting the
validity of a certificate.
</p>

<p>Unfortunately, the means by which an authority issues a CRL is one of
those areas that is in flux, and while the interfaces to support
revoked certificates have been established, they are not completely
integrated into most certificate systems. In particular, the
<tt class="literal">validate()</tt><a name="INDEX-1295"></a> method of the
<tt class="literal">Certificate</tt> class does not automatically consult
any CRL. The CRL itself is typically obtained in an out-of-band
fashion (just as the certificates of the authority were obtained);
once you have a CRL, you can check to see if a particular certificate
in which you are interested is on the list.
</p>

<p>While the notion of revoked certificates in not necessarily specific
to an X509 certificate, the Java implementation is. Revoked
certificates themselves are represented by the
<tt class="literal">X509CRLEntry</tt> class
(<tt class="literal">java.security.cert.X509CRLEntry</tt>):
</p>

<blockquote class="simplelist">
<p>public abstract class X509CRLEntry implements X509Extension<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></p>
</blockquote>

<p>The methods of this class are simple and are based upon the fields
present in a revoked X509 certificate:
</p>
<dl>
<dt>
<b>public abstract BigInteger getSerialNumber() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the serial number of the revoked certificate.</p>
</dd>

<dt>
<b>public abstract Date getRevocationDate() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the date on which the certificate was revoked.</p>
</dd>

<dt>
<b>public abstract boolean hasExtensions() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Indicate whether the implementation of the class has any X509
extensions.
</p>
</dd>

</dl>

<p>Revoked certificates are modeled by the
<tt class="literal">X509CRL</tt><a name="INDEX-1296"></a><a name="INDEX-1297"></a><a name="INDEX-1298"></a> class
(<tt class="literal">java.security.cert.X509CRL</tt>):
</p>

<dl>
<dt>
<b>public abstract class X509CRL implements X509Extension <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Provide the support for an X509-based certificate revocation list.</p>
</dd>

</dl>

<p>Instances of the <tt class="literal">X509CRLEntry</tt> class are obtained
by the <tt class="literal">getInstance()</tt> method of the
<tt class="literal">CertificateFactory</tt>. Once the class has been
instantiated, you may operate upon it with these methods. As you can
see, there is a strong synergy between the methods that are used to
operate upon an X509 certificate and those used to operate upon a
CRL:
</p>

<dl>
<dt>
<b>public abstract void verify(PublicKey pk) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1299"></a>
</b>
</dt>
<dt>
<b>public abstract void verify(PublicKey pk, String sigProvider) <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Verify that the signature that accompanied the CRL is valid (based on
the standard signature verification we'll look at in <a href="ch12_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch12_01.htm">Chapter 12, "Digital Signatures"</a>). The public key should be the public key of
the certificate authority that issued the CRL.
</p>

<p>An error in the underlying signature object may generate a
<tt class="literal">NoSuchAlgorithmException</tt>, a
<tt class="literal">NoSuchProviderException</tt>, an
<tt class="literal">InvalidKeyException</tt>, or a
<tt class="literal">SignatureException</tt>.
</p>
</dd>

<dt>
<b>public abstract int getVersion() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1300"></a>
</b>
</dt>
<dd>
<p>Return the version of the CRL. The present version of the X509 CRL
specification is 2.
</p>
</dd>

<dt>
<b>public abstract Principal getIssuerDN() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1301"></a>
</b>
</dt>
<dd>
<p>Extract the distinguished name of the issuer of the CRL and return a
principal object that contains that name.
</p>
</dd>

<dt>
<b>public abstract Date getThisUpdate() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1302"></a>
</b>
</dt>
<dd>
<p>Extract and return the date when the authority issued this CRL.</p>
</dd>

<dt>
<b>public abstract Date getNextUpdate() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1303"></a>
</b>
</dt>
<dd>
<p>Extract and return the date when the authority expects to issue its
next CRL. This value may not be present in the CRL, in which case
<tt class="literal">null</tt> is returned.
</p>
</dd>

<dt>
<b>public abstract X509CRLEntry getRevokedCertificate(BigInteger bn)<em class="emphasis"></em><img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1304"></a>
</b>
</dt>
<dd>
<p>Instantiate and return a revoked certificate object based on the
given serial number. If the serial number is invalid, a
<tt class="literal">CRLException</tt> is thrown.
</p>
</dd>

<dt>
<b>public abstract Set getRevokedCertificates() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1305"></a>
</b>
</dt>
<dd>
<p>Instantiate a revoked certificate object for each certificate in the
CRL and return the set of those objects. This method may throw a
<tt class="literal">CRLException</tt>.
</p>
</dd>

<dt>
<b>public abstract byte[] getEncoded() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1306"></a>
</b>
</dt>
<dd>
<p>Return the DER-encoded CRL itself. This method may throw a
<tt class="literal">CRLException</tt>.
</p>
</dd>

<dt>
<b>public abstract byte[] getTBSCertList() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1307"></a>
</b>
</dt>
<dd>
<p>Return the DER-encoded <a name="INDEX-1308"></a><a name="INDEX-1309"></a>TBS certificate list--that
is, all the data that came with the CRL aside from the name of the
algorithm used to sign the CRL and the digital signature itself. This
data can be used to verify the signature directly. Parsing of the
underlying data may throw a <tt class="literal">CRLException</tt> or an
<tt class="literal">X509ExtensionException</tt>.
</p>
</dd>

<dt>
<b>public abstract byte[] getSignature <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1310"></a>
</b>
</dt>
<dd>
<p>Return the actual bytes of the signature.</p>
</dd>

<dt>
<b>public abstract String getSigAlgName() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1311"></a>
</b>
</dt>
<dd>
<p>Return the name of the signature algorithm that was used to sign the
CRL.
</p>
</dd>

<dt>
<b>public abstract String getSigAlgOID() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Return the OID string of the signature algorithm that was used to
sign the CRL.
</p>
</dd>

<dt>
<b>public abstract byte[] getSigAlgParams() <img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"><a name="INDEX-1312"></a>
</b>
</dt>
<dd>
<p>Return the DER-encoded algorithms used in the signature generation.
This generally returns <tt class="literal">null</tt>, as those parameters
(if any) usually accompany the authority's public
key.<a name="INDEX-1313"></a><a name="INDEX-1314"></a><a name="INDEX-1315"></a>
</p>
</dd>

</dl>

<p>There is one more method of the <tt class="literal">X509CRL</tt> class,
which it inherits from its superclass, the <tt class="literal">CRL</tt>
class (<tt class="literal">java.security.cert.CRL</tt>):
</p>

<dl>
<dt>
<b>public abstract boolean isRevoked(Certificate c)<img alt="figure" src="gifs/bstar.gif" webstripperlinkwas="gifs/bstar.gif"></b>
</dt>
<dd>
<p>Indicate whether or not the given certificate has been revoked by
this CRL.
</p>
</dd>

</dl>

<p>When all is said and done, the point of the <tt class="literal">CRL</tt>
class (and the revoked certificate class) is to provide you with the
tools necessary to see if a particular certificate has been
invalidated. This checking is up to your application to perform; you
might choose to implement it as follows:
</p>

<h3>Class Definition</h3><blockquote>
<pre class="programlisting">public Certificate importCertificate(byte data[])
									throws CertificateException {
	X509Certificate c = null;
	try {
		CertificateFactory cf = CertificateFactory.getInstance("X509");
		ByteArrayInputStream bais = new ByteArrayInputStream(data);
		c = (X509Certificate) cf.generateCertificate(bais);
		Principal p = c.getIssuerDN();
		PublicKey pk = getPublicKey(p);
		c.verify(pk);
		InputStream crlFile = lookupCRLFile(p);
		cf = CertificateFactory.getInstance("X509CRL");
		X509CRL crl = (X509CRL) cf.generateCRL(crlFile);
		if (crl.isRevoked(c))
			throw new CertificateException("Certificate revoked");
	} catch (NoSuchAlgorithmException nsae) {
		throw new CertificateException("Can't verify certificate");
	} catch (NoSuchProviderException nspe) {
		throw new CertificateException("Can't verify certificate");
	} catch (SignatureException se) {
		throw new CertificateException("Can't verify certificate");
	} catch (InvalidKeyException ike) {
		throw new CertificateException("Can't verify certificate");
	} catch (CRLException ce) {
		// treat as no crl
	}
	return c;
}</pre>
</blockquote>

<p>This method encapsulates importing a certificate and checking its
validity. It is passed the DER-encoded data of the certificate to
check (this data must have been read from a file or other input
stream, as we showed earlier). Then we consult the certificate to
find out who issued it, obtain the public key of the issuer, and
validate the certificate. Before we return, however, we obtain the
latest CRL of the issuing authority and ensure that the certificate
we're checking has not been revoked; if it has been, we throw a
<tt class="literal">CertificateException</tt>.
</p>

<p>We've glossed over two details in this method: how we obtain
the public key of the authority that issued the certificate, and how
we get the CRL list associated with that authority. Implementing
these methods is the crux of a key/certificate management system, and
we'll show some ideas on how to implement the key lookup in
<a href="ch11_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch11_01.htm">Chapter 11, "Key Management"</a>. Obtaining the CRL is slightly more
problematic, since you must have access to a source for the CRL data.
Once you have that data, however, it's trivial to create the
CRL via the <tt class="literal">generateCRL()</tt><a name="INDEX-1316"></a><a name="INDEX-1317"></a><a name="INDEX-1318"></a><a name="INDEX-1319"></a><a name="INDEX-1320"></a><a name="INDEX-1321"></a> method.<a name="INDEX-1322"></a>
</p>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch10_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch10_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch10_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/ch10_05.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">10.3. The KeyFactory Class</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">10.5. Keys, Certificates, and Object Serialization</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
