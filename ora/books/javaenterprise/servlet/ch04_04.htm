<html>
<head>
<title>The Request (Java Servlet Programming)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Jason Hunter and William Crawford">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-391-XE" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="The Request">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm" alt="Java Servlet Programming"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch04_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch04_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch04_01.htm">Chapter 4: Retrieving Information</a></td><td align="right" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch05_01.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">4.4. The Request</h2>

<p>We've seen how the servlet finds out about the server and about
the client. Now it's time to move on to the really important
stuff: how a servlet finds out what the client wants.
</p>

<a name="ch04-10-fm2xml"></a>
<h3 class="sect2">4.4.1. Request Parameters</h3>

<p>Each access to a servlet can have any number of request parameters
associated with it. These <a name="INDEX-704"></a><a name="INDEX-705"></a>
parameters are typically name/value pairs that tell the servlet any
extra information it needs to handle the request. Please don't
confuse these request parameters with init parameters, which are
associated with the servlet itself.
</p>

<p>
<a name="INDEX-706"></a><a name="INDEX-707"></a><a name="INDEX-708"></a><a name="INDEX-709"></a>
An HTTP servlet gets its request parameters as part of its query
string (for GET requests) or as encoded post data (for POST
requests). A servlet used as a server-side include has its parameters
supplied by <tt class="literal">&lt;PARAM&gt;</tt> tags. Other types of
servlets can receive their parameters in other ways.
</p>

<p>Fortunately, even though a servlet can receive parameters in a number
of different ways, every servlet retrieves its parameters the same
way, using <tt class="literal">getParameter()</tt><a name="INDEX-710"></a><a name="INDEX-711"></a>
and <tt class="literal">getParameterValues()</tt><a name="INDEX-712"></a><a name="INDEX-713"></a>
:
</p>

<blockquote>
<pre class="programlisting">public String ServletRequest.getParameter(String name)
public String[] ServletRequest.getParameterValues(String name)</pre>
</blockquote>

<p>
<tt class="literal">getParameter()</tt> returns the value of the named
parameter as a <tt class="literal">String</tt> or <tt class="literal">null</tt>
if the parameter was not specified.<a href="#FOOTNOTE-3">[3]</a> The value is guaranteed to be in its
normal, decoded form. If the parameter has multiple values, the value
returned is server-dependent. If there's any chance a parameter
could have more than one value, you should use the
<tt class="literal">getParameterValues()</tt> method instead. This method
returns all the values of the named parameter as an array of
<tt class="literal">String</tt> objects or <tt class="literal">null</tt> if the
parameter was not specified. A single value is returned in an array
of length 1.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-3"></a>
<p>[3] The
<tt class="literal">getParameter()</tt> method was deprecated in the Java
Web Server 1.1 in favor of <tt class="literal">getParameterValues()</tt>.
However, after quite a lot of public protest, Sun took
<tt class="literal">getParameter()</tt> off the deprecation list in the
final release of Servlet API 2.0. It was the first Java method to be
undeprecated!</p> </blockquote>

<p>One word of warning: if the parameter information came in as encoded
POST data, it may not be available if the POST data has already been
read manually using the <tt class="literal">getReader()</tt> or
<tt class="literal">getInputStream()</tt> method of
<tt class="literal">ServletRequest</tt> (because POST data can be read only
once).
</p>

<p>The possible uses for request parameters are unlimited. They are a
general-purpose way to tell a servlet what to do, how to do it, or
both. For a simple example, let's look at how a
<a name="INDEX-714"></a><a name="INDEX-715"></a>dictionary servlet might use
<tt class="literal">getParameter()</tt> to find out the word it needs to
look up.
</p>

<p>An HTML file could contain this form asking the user for a word to
look up:
</p>

<blockquote>
<pre class="programlisting">&lt;FORM METHOD=GET ACTION="/servlet/Dictionary"&gt;
Word to look up: &lt;INPUT TYPE=TEXT NAME="word"&gt;&lt;P&gt;
Another word? &lt;INPUT TYPE=TEXT NAME="word"&gt;&lt;P&gt;
&lt;INPUT TYPE=SUBMIT&gt;&lt;P&gt;
&lt;/FORM&gt;</pre>
</blockquote>

<p>Or the HTML file could contain this server-side include:</p>

<blockquote>
<pre class="programlisting">&lt;SERVLET CODE=Dictionary&gt;
&lt;PARAM NAME=word VALUE=obfuscate&gt;
&lt;PARAM NAME=word VALUE=onomatopoeia&gt;
&lt;/SERVLET&gt;</pre>
</blockquote>

<p>No matter what the HTML looks like or whether the servlet handles GET
requests, POST requests, or server-side include requests or is part
of a filter chain, you can use code like the following to retrieve
the servlet's parameters:<a name="INDEX-716"></a><a name="INDEX-717"></a>
</p>

<blockquote>
<pre class="programlisting">String word = req.getParameter("word");
String definition = getDefinition(word);
out.println(word + ": " + definition);</pre>
</blockquote>

<p>While this code works fine, it can handle only one word per request.
To handle multiple values for <tt class="literal">word</tt>, the servlet
can use the <tt class="literal">getParameterValues()</tt> method instead:
</p>

<blockquote>
<pre class="programlisting">String[] words = req.getParameterValues("word");
if (words != null) {
  for (int i = 0; i &lt; words.length; i++) {
    String definition = getDefinition(words[i]);
    out.println(words[i] + ": " + definition);
    out.println("&lt;HR&gt;");
  }
}</pre>
</blockquote>

<p>In addition to getting parameter values, a servlet can access
parameter names using
<tt class="literal">getParameterNames()</tt><a name="INDEX-718"></a><a name="INDEX-719"></a>
:
</p>

<blockquote>
<pre class="programlisting">public Enumeration ServletRequest.getParameterNames()</pre>
</blockquote>

<p>This method returns all the parameter names as an
<tt class="literal">Enumeration</tt> of <tt class="literal">String</tt> object or
an empty <tt class="literal">Enumeration</tt> if the servlet has no
parameters. The method is most often used for debugging.
</p>

<p>Finally, a servlet can retrieve the raw query string of the request
with <tt class="literal">getQueryString()</tt>:
</p>

<blockquote>
<pre class="programlisting">public String ServletRequest.getQueryString()</pre>
</blockquote>

<p>This method returns the raw query string (encoded GET parameter
information) of the request or <tt class="literal">null</tt> if there was
no query string. This low-level information is rarely useful for
handling form data. It's best for handling a single unnamed
value, as in <tt class="literal">"/servlet/Sqrt?576"</tt>, where the
returned query string is <tt class="literal">"576"</tt>.
</p>

<p>
<a href="#ch04-13643">Example 4-7</a><a name="INDEX-720"></a>shows the use of these methods with a
servlet that prints its query string, then prints the name and value
for all its <a name="INDEX-721"></a><a name="INDEX-722"></a> parameters.
<a name="INDEX-723"></a><a name="INDEX-724"></a>
</p>

<a name="ch04-13643"></a>
<div class="example">
<h4 class="objtitle">Example 4-7. Snooping parameters </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class ParameterSnoop extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res)
                               throws ServletException, IOException {
    res.setContentType("text/plain");
    PrintWriter out = res.getWriter();

    out.println("Query String:");
    out.println(req.getQueryString());
    out.println();

    out.println("Request Parameters:");
    Enumeration enum = req.getParameterNames();
    while (enum.hasMoreElements()) {
      String name = (String) enum.nextElement();
      String values[] = req.getParameterValues(name);
      if (values != null) {
        for (int i = 0; i &lt; values.length; i++) {
          out.println(name + " (" + i + "): " + values[i]);
        }
      }
    }
  }
} </pre>
</blockquote>
</div>

<p>This servlet's output is shown in <a href="#ch04-12419">Figure 4-2</a>.</p>

<a name="ch04-12419"></a>
<div class="figure">
<img alt="figure" src="figs/jsp_0402.gif" webstripperlinkwas="figs/jsp_0402.gif"></div>
<h4 class="objtitle">Figure 4-2. The snooped parameters</h4>


<a name="ch04-11-fm2xml"></a>
<h3 class="sect2">4.4.2. Generating a License Key</h3>

<p>Now we're ready to write a servlet that generates a
<tt class="literal">KeyedServerLock</tt> license key for any given host and
port number. A key from this servlet can be used to unlock the
<tt class="literal">KeyedServerLock</tt> servlet. So, how will this servlet
know the host and port number of the servlet it needs to unlock? Why,
with request parameters, of course. <a href="#ch04-37284">Example 4-8</a><a name="INDEX-725"></a><a name="INDEX-726"></a>shows the code.
</p>

<a name="ch04-37284"></a>
<div class="example">
<h4 class="objtitle">Example 4-8. Unlocking KeyedServerLock </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.net.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class KeyedServerUnlock extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res) 
                               throws ServletException, IOException {
    PrintWriter out = res.getWriter();

    // Get the host and port
    String host = req.getParameter("host");
    String port = req.getParameter("port");

    // Convert the port to an integer
    int numericPort;
    try {
      numericPort = Integer.parseInt(port);
    }
    catch (NumberFormatException e) {
      numericPort = 80;  // default
    }

    // Generate and print the key
    // Any KeyGenerationException is caught and displayed
    try {
      long key = generateKey(host, numericPort);
      out.println(host + ":" + numericPort + " has the key " + key);
    }
    catch (KeyGenerationException e) {
      out.println("Could not generate key: " + e.getMessage());
    }
  }

  // This method contains the algorithm used to match a key with
  // a server host and port. This example implementation is extremely
  // weak and should not be used by commercial sites.
  //
  // Throws a KeyGenerationException because anything more specific
  // would be tied to the chosen algorithm.
  //
  private long generateKey(String host, int port) throws KeyGenerationException {

    // The key must be a 64-bit number equal to the logical not (~) 
    // of the 32-bit IP address concatenated by the 32-bit port number.

    byte hostIP[];
    try {
      hostIP = InetAddress.getByName(host).getAddress();
    }
    catch (UnknownHostException e) {
      throw new KeyGenerationException(e.getMessage());
    }

    // Get the 32-bit IP address
    long servercode = 0;
    for (int i = 0; i &lt; 4; i++) {
      servercode &lt;&lt;= 8;
      servercode |= (hostIP[i] &amp; 255);
    }

    // Concatentate the 32-bit port number
    servercode &lt;&lt;= 32;
    servercode |= port;

    // The key is the logical not
    return ~servercode;
  }
}

class KeyGenerationException extends Exception {

  public KeyGenerationException() {
    super();
  }

  public KeyGenerationException(String msg) {
    super(msg);
  }
}</pre>
</blockquote>
</div>

<p>This servlet can either generate a full page (for handling GET
requests) or act as a server-side include.
</p>


<a name="ch04-12-fm2xml"></a>
<h3 class="sect2">4.4.3. Path Information</h3>

<p>In addition to parameters, an HTTP request can include something
called "<a name="INDEX-727"></a><a name="INDEX-728"></a><a name="INDEX-729"></a><a name="INDEX-730"></a><a name="INDEX-731"></a>extra path information" or a
"virtual path." In general, this extra path information
is used to indicate a file on the server that the servlet should use
for something. This path information is encoded in the URL of an HTTP
request. An example URL looks like this:
</p>

<blockquote>
<pre class="programlisting">http://server:port/servlet/ViewFile/index.html</pre>
</blockquote>

<p>This invokes the <tt class="literal">ViewFile</tt> servlet, passing
<tt class="literal">"/index.html"</tt> as extra path information. A servlet
can access this path information, and it can also translate the
<tt class="literal">"/index.html"</tt> string into the real path of the
<em class="filename">index.html</em> file. What is the real path of
<tt class="literal">"/index.html"</tt>? It's the full file system
path to the file--what the server would return if the client
asked for <tt class="literal">"/index.html"</tt> directly. This probably
turns out to be
<em class="replaceable">document_root</em><em class="filename">/index.html</em>,
but, of course, the server could have special aliasing that changes
this.
</p>

<p>Besides being specified explicitly in a URL, this extra path
information can also be encoded in the
<tt class="literal">ACTION</tt><a name="INDEX-732"></a><a name="INDEX-733"></a> parameter of an HTML form:
</p>

<blockquote>
<pre class="programlisting">&lt;FORM METHOD=GET ACTION="/servlet/Dictionary/dict/definitions.txt"&gt;
Word to look up: &lt;INPUT TYPE=TEXT NAME="word"&gt;&lt;P&gt;
&lt;INPUT TYPE=SUBMIT&gt;&lt;P&gt;
&lt;/FORM&gt;</pre>
</blockquote>

<p>This form invokes the <tt class="literal">Dictionary</tt> servlet to handle
its submissions and passes the <tt class="literal">Dictionary</tt> the
extra path information <tt class="literal">"/dict/definitions.txt"</tt>.
The <tt class="literal">Dictionary</tt> servlet can then know to look up
word definitions using the <em class="filename">definitions.txt</em> file,
the same file the client would see if it requested
<tt class="literal">"/dict/definitions.txt"</tt>, probably
<em class="replaceable">server_root</em><em class="filename">/public_html/dict/definitions.txt</em>.
</p>

<a name="ch04-13-fm2xml"></a>
<div class="sidebar">
<h4 class="objtitle">Why Extra Path Information?</h4>

<p>Why does HTTP have special support for extra path information?
Isn't it enough to pass the servlet a <tt class="literal">path</tt>
parameter? The answer is yes. Servlets don't need the special
support, but CGI programs do.
</p>

<p>A CGI program cannot interact with its server during execution, so it
has no way to receive a <tt class="literal">path</tt> parameter, let alone
ask the server to map it to a real file system location. The server
has to somehow translate the path <em class="emphasis">before</em>
invoking the CGI program. This is why there needs to be support for
special "extra path information." Servers know to
pretranslate this extra path and send the translation to the CGI
program as an environment variable. It's a fairly elegant
workaround to a shortcoming in CGI.
</p>

<p>Of course, just because servlets don't need the special
handling of "extra path information," it doesn't
mean they shouldn't use it. It provides a simple, convenient
way to attach a path along with a request.
</p>
</div>

<a name="ch04-14-fm2xml"></a>
<h3 class="sect3">4.4.3.1. Getting path information</h3>

<p>A servlet can use the <tt class="literal">getPathInfo()</tt> method to get
extra path information:
</p>

<blockquote>
<pre class="programlisting">public String HttpServletRequest.getPathInfo()</pre>
</blockquote>

<p>This method returns the extra path information associated with the
request or <tt class="literal">null</tt> if none was given. An example path
is <tt class="literal">"/dict/definitions.txt"</tt>. The path information
by itself, however, is only marginally useful. A servlet usually
needs to know the actual file system location of the file given in
the path info, which is where
<tt class="literal">getPathTranslated()</tt><a name="INDEX-734"></a><a name="INDEX-735"></a>
comes in:
</p>

<blockquote>
<pre class="programlisting">public String HttpServletRequest.getPathTranslated()</pre>
</blockquote>

<p>This method returns the extra path information translated to a real
file system path or <tt class="literal">null</tt> if there is no extra path
information. The returned path does not necessarily point to an
existing file or directory. An example translated path is
<tt class="literal">"C:\JavaWebServer1.1.1\public_html\dict\definitions.txt"</tt>.
</p>

<p>
<a href="#ch04-41969">Example 4-9</a> shows a servlet that uses these two
methods to print the extra path information it receives and the
resulting translation to a real path.
</p>

<a name="ch04-41969"></a>
<div class="example">
<h4 class="objtitle">Example 4-9. Showing where the path leads </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class FileLocation extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res) 
                               throws ServletException, IOException {
    res.setContentType("text/plain");
    PrintWriter out = res.getWriter();

    if (req.getPathInfo() != null) {
      out.println("The file \"" + req.getPathInfo() + "\"");
      out.println("Is stored at \"" + req.getPathTranslated() + "\"");
    }
  }
}</pre>
</blockquote>
</div>

<p>Some example output of this servlet might be:</p>

<blockquote>
<pre class="programlisting">The file "/index.html"
Is stored at "/usr/JavaWebServer1.1.1/public_html/index.html"</pre>
</blockquote>



<a name="ch04-15-fm2xml"></a>
<h3 class="sect3">4.4.3.2. Ad hoc path translations</h3>

<p>
<a name="INDEX-736"></a>
Sometimes a servlet needs to translate a path that wasn't
passed in as extra path information. You can use the
<tt class="literal">getRealPath()</tt><a name="INDEX-737"></a><a name="INDEX-738"></a>
method for this task:
</p>

<blockquote>
<pre class="programlisting">public String ServletRequest.getRealPath(String path)</pre>
</blockquote>

<p>This method returns the real path of any given "virtual
path" or <tt class="literal">null</tt> if the translation cannot be
performed. If the given path is <tt class="literal">"/"</tt>, the method
returns the document root (the place where documents are stored) for
the server. If the given path is
<tt class="literal">getPathInfo()</tt><a name="INDEX-739"></a><a name="INDEX-740"></a>
, the method returns the same real path as would be returned by
<tt class="literal">getPathTranslated()</tt><a name="INDEX-741"></a><a name="INDEX-742"></a>
. This method can be used by generic servlets as well as HTTP
servlets. There is no <a name="INDEX-743"></a>CGI counterpart.
</p>



<a name="ch04-16-fm2xml"></a>
<h3 class="sect3">4.4.3.3. Getting MIME types</h3>

<p>Once a <a name="INDEX-744"></a><a name="INDEX-745"></a>servlet has the path to a file, it
often needs to discover the type of the file. Use
<tt class="literal">getMimeType()</tt><a name="INDEX-746"></a><a name="INDEX-747"></a>
to do this:
</p>

<blockquote>
<pre class="programlisting">public String ServletContext.getMimeType(String file)</pre>
</blockquote>

<p>This method returns the MIME type of the given file or
<tt class="literal">null</tt> if it isn't known. Some implementations
return <tt class="literal">"text/plain"</tt> if the given file
doesn't exist. Common MIME types are
<tt class="literal">"text/html"</tt>, <tt class="literal">"text/plain"</tt>,
<tt class="literal">"image/gif"</tt>, and <tt class="literal">"image/jpeg"</tt>.
</p>

<p>The following code fragment finds the MIME type of the extra path
information:
</p>

<blockquote>
<pre class="programlisting">String type = getServletContext().getMimeType(req.getPathTranslated())</pre>
</blockquote>



<a name="ch04-17-fm2xml"></a>
<h3 class="sect2">4.4.4. Serving Files</h3>

<p>The <a name="INDEX-748"></a><a name="INDEX-749"></a>
Java Web Server itself uses servlets to handle every request. Besides
being a showcase for the ability of servlets, this gives the server a
modular design that allows the wholesale replacement of certain
aspects of its functionality. For example, all files are served by
the <tt class="literal">com.sun.server.http.FileServlet</tt> servlet,
registered under the name <tt class="literal">file</tt> and charged with
the responsibility to handle the <tt class="literal">"/"</tt> alias
(meaning it's the default handler for requests). But
there's nothing to say that Sun's
<tt class="literal">FileServlet</tt> cannot be replaced. In fact, it can
be, either by registering another servlet under the name
<tt class="literal">file</tt> or by changing the <tt class="literal">"/"</tt>
alias to use another servlet. Furthermore, it's not all that
hard to write a replacement for <tt class="literal">file</tt>, using the
methods we've just seen.
</p>

<p>
<a href="#ch04-35758">Example 4-10</a> shows a <tt class="literal">ViewFile</tt>
servlet that uses the <tt class="literal">getPathTranslated()</tt> and
<tt class="literal">getMimeType()</tt> methods to return whatever file is
given by the extra path information.
<a name="INDEX-750"></a><a name="INDEX-751"></a><a name="INDEX-752"></a><a name="INDEX-753"></a><a name="INDEX-754"></a>
</p>

<a name="ch04-35758"></a>
<div class="example">
<h4 class="objtitle">Example 4-10. Dynamically returning static files </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

import com.oreilly.servlet.ServletUtils;

public class ViewFile extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res) 
                               throws ServletException, IOException {
    // Use a ServletOutputStream because we may pass binary information
    ServletOutputStream out = res.getOutputStream();

    // Get the file to view
    String file = req.getPathTranslated();

    // No file, nothing to view
    if (file == null) {
      out.println("No file to view");
      return;
    }

    // Get and set the type of the file
    String contentType = getServletContext().getMimeType(file);
    res.setContentType(contentType);

    // Return the file
    try {
      ServletUtils.returnFile(file, out);
    }
    catch (FileNotFoundException e) { 
      out.println("File not found");
    }
    catch (IOException e) { 
      out.println("Problem sending file: " + e.getMessage());
    }
  }
}</pre>
</blockquote>
</div>

<p>This servlet first uses <tt class="literal">getPathTranslated()</tt> to get
the name of file it needs to display. Then it uses
<tt class="literal">getMimeType()</tt> to find the content type of this
file and sets the response content type to match. Last, it returns
the file using the <tt class="literal">returnFile()</tt> method found in
the <tt class="literal">com.oreilly.servlet.ServletUtils</tt> utility
class:
</p>

<blockquote>
<pre class="programlisting">// Send the contents of the file to the output stream
public static void returnFile(String filename, OutputStream out)
                           throws FileNotFoundException, IOException {
  // A FileInputStream is for bytes
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(filename);
    byte[] buf = new byte[4 * 1024];  // 4K buffer
    int bytesRead;
    while ((bytesRead = fis.read(buf)) != -1) {
      out.write(buf, 0, bytesRead);
    }
  }
  finally {
    if (fis != null) fis.close();
  }
}</pre>
</blockquote>

<p>The servlet's error handling is basic--it returns a page
that describes the error. This is acceptable for our simple example
(and really more than many programs seem capable of), but we'll
learn a better way using status codes in the next chapter.
</p>

<p>This servlet can be used directly with a URL like this.</p>

<blockquote>
<pre class="programlisting">http://server:port/servlet/ViewFile/index.html</pre>
</blockquote>

<p>Or, if you use it as a replacement for the <tt class="literal">"file"</tt>
servlet, it is automatically invoked even for a URL like this.
</p>

<blockquote>
<pre class="programlisting">http://server:port/index.html</pre>
</blockquote>

<p>Just beware that this servlet is a "proof of concept"
example and does not have the full functionality of the
<tt class="literal">com.sun.server.http.FileServlet</tt> servlet.
</p>


<a name="ch04-18-fm2xml"></a>
<h3 class="sect2">4.4.5. Determining What Was Requested</h3>

<p>A servlet can use several methods to find out exactly what file or
servlet the client requested. After all, only the most conceited
servlet would always assume itself to be the direct target of a
request. A servlet may be nothing more than a single link in a long
servlet chain.
</p>

<p>No method directly returns the original <a name="INDEX-755"></a>
Uniform Resource Locator
(<a name="INDEX-756"></a>
URL) used by the client to make a request. The
<tt class="literal">javax.servlet.http.HttpUtils</tt> class, however,
provides a
<tt class="literal">getRequestURL()</tt><a name="INDEX-757"></a><a name="INDEX-758"></a>
method that does about the same thing:<a href="#FOOTNOTE-4">[4]</a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-4"></a>
<p>[4] Why
isn't there a method that directly returns the original URL
shown in the browser? Because the browser never sends the full URL.
The port number, for example, is used by the client to make its HTTP
connection, but it isn't included in the request made to the
web server answering on that port.</p> </blockquote>

<blockquote>
<pre class="programlisting">public static StringBuffer HttpUtils.getRequestURL(HttpServletRequest req)</pre>
</blockquote>

<p>This method reconstructs the request URL based on information
available in the <tt class="literal">HttpServletRequest</tt> object. It
returns a <tt class="literal">StringBuffer</tt> that includes the scheme
(such as HTTP), server name, server port, and extra path information.
The reconstructed URL should look almost identical to the URL used by
the client. Differences between the original and reconstructed URLs
should be minor (that is, a space encoded by the client as
<tt class="literal">"%20"</tt> might be encoded by the server as a
<tt class="literal">"+"</tt>). Because this method returns a
<tt class="literal">StringBuffer</tt>, the request URL can be modified
efficiently (for example, by appending query parameters). This method
is often used for creating redirect messages and reporting errors.
</p>

<p>Most of the time, however, a servlet doesn't really need the
request URL. It just needs the request URI, which is returned by
<tt class="literal">getRequestURI()</tt>:
</p>

<blockquote>
<pre class="programlisting">public String HttpServletRequest.getRequestURI()</pre>
</blockquote>

<p>This method returns the <a name="INDEX-759"></a>Universal Resource Identifier
(URI) of the request. For normal HTTP servlets, a request URI can be
thought of as a URL minus the scheme, host, port, and query string,
but including any extra path information.<a href="#FOOTNOTE-5">[5]</a><a href="#ch04-31315">Table 4-2</a> shows the request URIs for several
request URLs.
</p>
<blockquote class="footnote">
<a name="FOOTNOTE-5"></a>
<p>[5]Technically, what is referred to here as a request URI could
more formally be called a "request URL path". This is
because a URI is, in the most precise sense, a general purpose
identifier for a resource. A URL is one type of URI; a
<a name="INDEX-760"></a>
URN (Uniform Resource Name) is another. For more information on URIs,
URLs, and URNs, see RFC 1630 at <a href="../../../../../../../www.ietf.org/rfc/rfc1630.txt">http://www.ietf.org/rfc/rfc1630.txt</a><a name="INDEX-761"></a><a name="INDEX-762"></a>.</p> </blockquote>

<a name="ch04-31315"></a>
<h4 class="objtitle">Table 4-2. URLs and Their URIs</h4>
<table border="1">



<tr>
<th>
<p>Request URL</p>
</th>
<th>
<p>Its URI Component</p>
</th>
</tr>


<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/Classname</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/Classname</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/registeredName</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/registeredName</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/Classname?var=val</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/Classname <a href="#FOOTNOTE-6">[6]</a></em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/Classname/pathinfo</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/Classname/pathinfo</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/Classname/pathinfo?var=val</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/Classname/pathinfo</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/ssi.shtml</em> (SSI)</p>
</td>
<td>
<p>
<em class="emphasis">/ssi.shtml</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/alias.html</em> (alias to a
servlet)
</p>
</td>
<td>
<p>
<em class="emphasis">/alias.html</em>
</p>
</td>
</tr>

</table>
<blockquote class="footnote"> <a name="FOOTNOTE-6"></a>
<p>[6] Several servlet
engines (including the Java Web Server 1.1.1) have a
<a name="INDEX-763"></a><a name="INDEX-764"></a>bug where
<tt class="literal">getRequestURI()</tt> erroneously includes the query
string. The JSDK 2.0 servlet runner behaves correctly.</p>
</blockquote>

<p>For servlets in a chain, the request URI is always that of the first
servlet in the chain.
</p>

<p>In some situations it is enough for a servlet to know the servlet
name under which it was invoked. You can retrieve this information
with
<tt class="literal">getServletPath()</tt><a name="INDEX-765"></a><a name="INDEX-766"></a>
:
</p>

<blockquote>
<pre class="programlisting">public String HttpServletRequest.getServletPath()</pre>
</blockquote>

<p>This method returns the part of the URI that refers to the servlet
being invoked or <tt class="literal">null</tt> if the URI does not directly
point to a servlet. The servlet path does not include extra path
information. <a href="#ch04-40527">Table 4-3</a> shows the servlet names for
several request URLs.
</p>

<a name="ch04-40527"></a>
<h4 class="objtitle">Table 4-3. URLs and Their Servlet Paths </h4>
<table border="1">



<tr>
<th>
<p>Request URL</p>
</th>
<th>
<p>Its Servlet Path</p>
</th>
</tr>


<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/Classname</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/Classname</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/registeredName</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/registeredName</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/Classname?var=val</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/Classname</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/Classname/pathinfo</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/Classname</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/servlet/Classname/pathinfo?var=val</em>
</p>
</td>
<td>
<p>
<em class="emphasis">/servlet/Classname</em>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/ssi.shtml</em> (SSI)</p>
</td>
<td>
<p>
<tt class="literal">null</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<em class="emphasis">http://server:port/alias.html</em> (alias to a
servlet)
</p>
</td>
<td>
<p>
<em class="emphasis">/alias.html</em>
</p>
</td>
</tr>

</table>

<p>For servlets in a filter chain, the servlet path is always the same
as the path of the first servlet in the chain. If the request URI
does not point at a servlet, <tt class="literal">getServletPath()</tt>
returns <tt class="literal">null</tt>. It does not matter that a servlet
(such as the <tt class="literal">file</tt> servlet) may have handled the
request behind the scenes or that the request eventually ended up in
a servlet.
</p>

<p>For example, if the client requests the page
<em class="emphasis">/</em><em class="filename">index.html </em>and the content
goes through the <tt class="literal">Deblink</tt> servlet from <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch02_01.htm">Chapter 2, "HTTP Servlet Basics"</a>, the <tt class="literal">Deblink</tt> servlet has a
<tt class="literal">null</tt> servlet path--the original request was
for a static file, not a servlet. If, however, the client requests
<em class="emphasis">/alias.html--</em>which is a direct alias to a
servlet--both that servlet and the <tt class="literal">Deblink</tt>
servlet have a servlet path of <em class="emphasis">/alias.html</em>.
</p>

<p>A servlet invoked as a server-side include behaves similarly. If it
is embedded in a static file, it too has a <tt class="literal">null</tt>
servlet path. The only way for it to have a
non-<tt class="literal">null</tt> servlet path is if it is part of a
servlet chain started by a servlet.
</p>


<a name="ch04-19-fm2xml"></a>
<h3 class="sect2">4.4.6. An Improved Counter</h3>

<p>We can make use of the request URI information to improve our
<a name="INDEX-767"></a><a name="INDEX-768"></a><a name="INDEX-769"></a>counter servlet. The counter example
from <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch03_01.htm">Chapter 3, "The Servlet Life Cycle"</a> could count only its own accesses.
A real counter has to be able to count accesses to pages other than
itself. There are two elegant ways to accomplish this: use the
counter as an SSI servlet embedded in a page or use the counter in a
servlet chain where it can replace any instances of the
<tt class="literal">&lt;COUNT&gt;</tt> tag with the appropriate number. For
each approach, a servlet can use the
<tt class="literal">getRequestURI()</tt> method to associate a separate
count with each requested URI.
</p>

<p>
<a href="#ch04-16369">Example 4-11</a> shows a
<tt class="literal">GenericCounter</tt> servlet superclass that knows how
to manage a hashtable that stores counts for different URIs. <a href="#ch04-22703">Example 4-12</a> and <a href="#ch04-15539">Example 4-13</a> show servlets
that subclass <tt class="literal">GenericCounter</tt> to act as a
server-side include counter and a chain-based counter,
respectively.<a href="#FOOTNOTE-7">[7]</a><a name="INDEX-770"></a><a name="INDEX-771"></a><a name="INDEX-772"></a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-7"></a>
<p>[7]For <a href="#ch04-22703">Example 4-12</a>,
please note that the Java Web Server 1.1.1 has a bug where the
<tt class="literal">PrintWriter</tt> returned by <tt class="literal">
getWriter()</tt> doesn't generate output for servlets used
as server side includes. See <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch02_01.htm">Chapter 2, "HTTP Servlet Basics"</a> for more
information.</p> </blockquote>

<a name="ch04-16369"></a>
<div class="example">
<h4 class="objtitle">Example 4-11. A generic counter superclass </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class GenericCounter extends HttpServlet {

  private Hashtable counts = new Hashtable();

  public void init(ServletConfig config) throws ServletException {
    // Always call super.init(config) first
    super.init(config);

    // Try to load the initial page counts from the saved persistent state
    try {
      FileReader fileReader = new FileReader(getClass().getName() + ".counts");
      BufferedReader bufferedReader = new BufferedReader(fileReader);
      String line = null;
      String uri = null;
      String count = null;
      int[] holder = null;  // holder for the count, to make it an object
      while ((line = bufferedReader.readLine()) != null) {
        StringTokenizer tokenizer = new StringTokenizer(line);
        if (tokenizer.countTokens() &lt; 2) continue;  // bogus line
        uri = tokenizer.nextToken();
        count = tokenizer.nextToken();
        // Store the uri/count pair in the counts hashtable
        // The count is saved as an int[1] to make it an "object"
        try {
          holder = new int[1];
          holder[0] = Integer.parseInt(count);
          counts.put(uri, holder);
        }
        catch (NumberFormatException e) { }  // bogus line
      }
    }
    catch (FileNotFoundException e) { }  // no saved state
    catch (IOException e) { }            // problem during read
  }

  // Increment and return the count for the given URI 
  public int incrementAndGetCount(String uri) {
    int[] holder = (int[])counts.get(uri);
    if (holder == null) {
      // Initialize the count to 0
      holder = new int[1];
      holder[0] = 0;
      counts.put(uri, holder);  // save the holder
    }
    holder[0]++;               // increment
    return holder[0];
  }

  public void destroy() {
    // Try to save the accumulated count
    try {
      FileWriter fileWriter = new FileWriter(getClass().getName() + ".counts");
      BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
      Enumeration keys = counts.keys();
      Enumeration elements = counts.elements();
      String output = null;
      while (keys.hasMoreElements() &amp;&amp; elements.hasMoreElements()) {
         String name = (String) keys.nextElement();
         int[] val = (int[]) elements.nextElement();
         bufferedWriter.write(name + " " + val[0] + "\n");
      }
      bufferedWriter.close();
      fileWriter.close();
      return;
    }
    catch (IOException e) { }  // problem during write
  }
}</pre>
</blockquote>
</div>

<a name="ch04-22703"></a>
<div class="example">
<h4 class="objtitle">Example 4-12. A server-side include counter </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class SSICounter extends GenericCounter {

  public void doGet(HttpServletRequest req, HttpServletResponse res) 
                               throws ServletException, IOException {
    PrintWriter out = res.getWriter();

    // Fetch the page we're on.
    String uri = req.getRequestURI();

    // Get and increment the count for that page
    int count = incrementAndGetCount(uri);

    // Fulfull our purpose: print the count
    out.println(count);
  }
}</pre>
</blockquote>
</div>

<a name="ch04-15539"></a>
<div class="example">
<h4 class="objtitle">Example 4-13. A chain-based counter that replaces &lt;COUNT&gt; with the hit count </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class ChainCounter extends GenericCounter {

  public void doGet(HttpServletRequest req, HttpServletResponse res) 
                               throws ServletException, IOException {

    String contentType = req.getContentType();
    res.setContentType(contentType);

    PrintWriter out = res.getWriter();

    // Fetch the page we're on.
    String uri = req.getRequestURI();

    // Get and increment the count
    int count = incrementAndGetCount(uri);

    // Prepare to read the input
    BufferedReader reader = req.getReader();

    String line = null;
    while ((line = reader.readLine()) != null) {
      line = replace(line, "&lt;COUNT&gt;", "" + count);  // case sensitive
      out.println(line);
    }
  }

  public void doPost(HttpServletRequest req, HttpServletResponse res)
                                throws ServletException, IOException {
    doGet(req, res);
  }

  private String replace(String line, String oldString, String newString) {
    int index = 0;
    while ((index = line.indexOf(oldString, index)) &gt;= 0) {
      line = line.substring(0, index) +
             newString +
             line.substring(index + oldString.length());
      index += newString.length();
    }
    return line;
  }
}</pre>
</blockquote>
</div>


<a name="ch04-20-fm2xml"></a>
<h3 class="sect2">4.4.7. How It Was Requested</h3>

<p>Besides knowing <em class="emphasis">what</em> was requested, a servlet
has several ways of finding out details about
<em class="emphasis">how</em> it was requested. The
<tt class="literal">getScheme()</tt><a name="INDEX-773"></a><a name="INDEX-774"></a>
method returns the scheme used to make this request:
</p>

<blockquote>
<pre class="programlisting">public String ServletRequest.getScheme()</pre>
</blockquote>

<p>Examples include <tt class="literal">"http"</tt>,
<tt class="literal">"https"</tt>, and <tt class="literal">"ftp"</tt>, as well as
the newer Java-specific schemes <tt class="literal">"jdbc"</tt> and
<tt class="literal">"rmi"</tt>. There is no direct
<a name="INDEX-775"></a>CGI counterpart (though some CGI
implementations have a
<tt class="literal">SERVER_URL</tt><a name="INDEX-776"></a><a name="INDEX-777"></a>
variable that includes the scheme). For HTTP servlets, this method
indicates whether the request was made over a secure connection using
the <a name="INDEX-778"></a><a name="INDEX-779"></a><a name="INDEX-780"></a>Secure Sockets Layer
(<a name="INDEX-781"></a>SSL), as indicated by the scheme
<tt class="literal">"https"</tt><a name="INDEX-782"></a>, or if it was an insecure request, as
indicated by the scheme
<tt class="literal">"http"</tt><a name="INDEX-783"></a>.
</p>

<p>The <tt class="literal">getProtocol()</tt> method returns the protocol and
version number used to make the request:
</p>

<blockquote>
<pre class="programlisting">public String ServletRequest.getProtocol()</pre>
</blockquote>

<p>The protocol and version number are separated by a slash. The method
returns <tt class="literal">null</tt> if no protocol could be determined.
For HTTP servlets, the protocol is usually
v<tt class="literal">HTTP/1.0</tt>v or v<tt class="literal">HTTP/1.1"</tt>. HTTP
servlets can use the protocol version to determine if it's okay
with the client to use the new features in HTTP Version 1.1.
</p>

<p>To find out what method was used for a request, a servlet uses
<tt class="literal">getMethod()</tt><a name="INDEX-784"></a><a name="INDEX-785"></a>
:
</p>

<blockquote>
<pre class="programlisting">public String HttpServletRequest.getMethod()</pre>
</blockquote>

<p>This method returns the HTTP method used to make the request.
Examples include <tt class="literal">"GET"</tt>, <tt class="literal">"POST"</tt>,
and <tt class="literal">"HEAD"</tt>. The
<tt class="literal">service()</tt><a name="INDEX-786"></a><a name="INDEX-787"></a>
method of the <tt class="literal">HttpServlet</tt> implementation uses this
method in its dispatching of requests.
</p>


<a name="ch04-21-fm2xml"></a>
<h3 class="sect2">4.4.8. Request Headers</h3>

<p>HTTP requests and responses can have a number of associated HTTP
"headers". These headers provide some extra information
about the request (or response). The HTTP Version 1.0 protocol
defines literally dozens of possible headers; the HTTP Version 1.1
protocol includes even more. A description of all the headers extends
beyond the scope of this book; we discuss only the headers most often
accessed by servlets. For a full list of HTTP headers and their uses,
we <a name="INDEX-788"></a><a name="INDEX-789"></a>recommend
<em class="emphasis">Web Client Programming</em><a name="INDEX-790"></a><a name="INDEX-791"></a> by Clinton Wong (O'Reilly)
or <a name="INDEX-792"></a><a name="INDEX-793"></a><em class="emphasis">Webmaster in a
Nutshell</em> by Stephen Spainhour and Valerie Quercia
(O'Reilly).
</p>

<p>A servlet rarely needs to read the HTTP headers accompanying a
request. Many of the headers associated with a request are handled by
the server itself. Take, for example, how a server restricts access
to its documents. The server uses HTTP headers, and servlets need not
know the details. When a server receives a request for a restricted
page, it checks that the request includes an appropriate
<tt class="literal">Authorization</tt><a name="INDEX-794"></a><a name="INDEX-795"></a><a name="INDEX-796"></a><a name="INDEX-797"></a> header that contains a valid username
and a password. If it doesn't, the server itself issues a
response containing a
<tt class="literal">WWW-Authenticate</tt><a name="INDEX-798"></a><a name="INDEX-799"></a>
header, to tell the browser its access to a resource was denied. When
the client sends a request that includes the proper
<tt class="literal">Authorization</tt> header, the server grants the access
and gives any servlet invoked access to the user's name via the
<tt class="literal">getRemoteUser()</tt><a name="INDEX-800"></a><a name="INDEX-801"></a>
call.
</p>

<p>Other headers are used by servlets, but indirectly. A good example is
the <tt class="literal">Last-Modified</tt> and
<tt class="literal">If-Last-Modified</tt> pair discussed in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch03_01.htm">Chapter 3, "The Servlet Life Cycle"</a>. The server itself sees the
<tt class="literal">If-Last-Modified</tt> header and calls the
servlet's <tt class="literal">getLastModified()</tt> method to
determine how to proceed.
</p>

<p>There are a few HTTP headers that a servlet may want to read on
occasion. These are listed in <a href="#ch04-38400">Table 4-4</a>.
</p>

<a name="ch04-38400"></a>
<h4 class="objtitle">Table 4-4. Useful HTTP Request Headers </h4>
<table border="1">



<tr>
<th>
<p>Header</p>
</th>
<th>
<p>Usage</p>
</th>
</tr>


<tr>
<td>
<p>
<tt class="literal">Accept</tt><a name="INDEX-802"></a><a name="INDEX-803"></a>
</p>
</td>
<td>
<p>Specifies the media
(<a name="INDEX-804"></a><a name="INDEX-805"></a>
MIME) types the client prefers to accept, separated by
commas.<a href="#FOOTNOTE-8">[8]</a> Each media type is divided into a type and subtype given
as <em class="replaceable">type/subtype</em>. An asterisk
(<tt class="literal">*</tt>) wildcard is allowed for the subtype
(<em class="replaceable">type</em><tt class="literal">/*</tt>) or for both
the type and subtype (<tt class="literal">*/*</tt>). For example:
</p>

<blockquote>
<pre class="programlisting">Accept: image/gif, image/jpeg, text/*, */*</pre>
</blockquote>

<p>A servlet can use this header to help determine what type of content
to return. If this header is not passed as part of the request, the
servlet can assume the client accepts all media types.
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">User-Agent</tt><a name="INDEX-806"></a><a name="INDEX-807"></a>
</p>
</td>
<td>
<p>Gives information about the
<a name="INDEX-808"></a><a name="INDEX-809"></a>client software. The format of the
returned string is relatively free form, but it often includes the
browser name and version as well as information about the machine on
which it is running.
<a name="INDEX-810"></a>Netscape 3.01 on an SGI Indy running
IRIX 6.2 reports:
</p>

<blockquote>
<pre class="programlisting">User-Agent: Mozilla/3.01SC-SGI (X11; I; IRIX 6.2 IP22)</pre>
</blockquote>

<p>
<a name="INDEX-811"></a>Microsoft Internet Explorer 4.0 running
on a Windows 95 machine reports:
</p>

<blockquote>
<pre class="programlisting">User-Agent: Mozilla/4.0 (compatible; MSIE 4.0; Windows 95)</pre>
</blockquote>

<p>A servlet can use this header to keep statistics or to customize its
response based on browser type.
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">Referer</tt><a name="INDEX-812"></a><a name="INDEX-813"></a>
</p>
</td>
<td>
<p>Gives the URL of the
<a name="INDEX-814"></a><a name="INDEX-815"></a>document that refers to the
requested URL (that is, the document that contains the link the
client followed to access this document).<a href="#FOOTNOTE-9">[9]</a> For example:
</p>

<blockquote>
<pre class="programlisting">Referer: http://www.gamelan.com/pages/Gamelan.sites.home.html</pre>
</blockquote>

<p>A servlet can use this header to keep statistics or, if there's
some error in the request, to keep track of the documents with
errors.
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">Authorization</tt><a name="INDEX-816"></a><a name="INDEX-817"></a>
</p>
</td>
<td>
<p>Provides the client's authorization to access the requested
URI, including a username and password encoded in Base64. Servlets
can use this for custom authorization, as discussed in <a href="ch08_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch08_01.htm">Chapter 8, "Security"</a>.
</p>
</td>
</tr>

</table>
<blockquote class="footnote"> <a name="FOOTNOTE-8"></a>
<p>[8] Some older browsers send a separate
<tt class="literal">Accept</tt> header for each media type. This can
confuse some servlet engines, including the Java Web Server.</p>
</blockquote>
<blockquote class="footnote"> <a name="FOOTNOTE-9"></a>
<p>[9] The
properly-spelled <tt class="literal">Referrer</tt> header gives you
nothing.</p> </blockquote>

<a name="ch04-22-fm2xml"></a>
<h3 class="sect3">4.4.8.1. Accessing header values</h3>

<p>HTTP header values are accessed through the
<tt class="literal">HttpServletRequest</tt> object. A header value can be
retrieved as a <tt class="literal">String</tt>, a <tt class="literal">long</tt>
(representing a <tt class="literal">Date</tt>), or an
<tt class="literal">int</tt>, using
<tt class="literal">getHeader()</tt><a name="INDEX-818"></a><a name="INDEX-819"></a>
,
<tt class="literal">getDateHeader()</tt><a name="INDEX-820"></a><a name="INDEX-821"></a>
, and
<tt class="literal">getIntHeader()</tt><a name="INDEX-822"></a><a name="INDEX-823"></a>
, respectively:
</p>

<blockquote>
<pre class="programlisting">public String HttpServletRequest.getHeader(String name)
public long HttpServletRequest.getDateHeader(String name)
public int HttpServletRequest.getIntHeader(String name)</pre>
</blockquote>

<p>
<tt class="literal">getHeader()</tt><a name="INDEX-824"></a><a name="INDEX-825"></a>
returns the value of the named header as a <tt class="literal">String</tt>
or <tt class="literal">null</tt> if the header was not sent as part of the
request. The name is case insensitive, as it is for all these
methods. Headers of all types can be retrieved with this method.
</p>

<p>
<tt class="literal">getDateHeader()</tt><a name="INDEX-826"></a><a name="INDEX-827"></a>
returns the value of the named header as a <tt class="literal">long</tt>
(representing a <tt class="literal">Date</tt>) that specifies the number of
milliseconds since the epoch) or <tt class="literal">-1</tt> if the header
was not sent as part of the request. This method throws an
<tt class="literal">IllegalArgumentException</tt> when called on a header
whose value cannot be converted to a <tt class="literal">Date</tt>. The
method is useful for handling headers like
<tt class="literal">Last-Modified</tt> and
<tt class="literal">If-Modified-Since</tt>.
</p>

<p>
<tt class="literal">getIntHeader()</tt><a name="INDEX-828"></a><a name="INDEX-829"></a>
returns the value of the named header as an <tt class="literal">int</tt> or
<tt class="literal">-1</tt> if the header was not sent as part of the
request. This method throws a
<tt class="literal">NumberFormatException</tt> when called on a header
whose value cannot be converted to an <tt class="literal">int</tt>.
</p>

<p>A servlet can also get the names of all the headers it can access
using
<tt class="literal">getHeaderNames()</tt><a name="INDEX-830"></a><a name="INDEX-831"></a>
:
</p>

<blockquote>
<pre class="programlisting">public Enumeration HttpServletRequest.getHeaderNames()</pre>
</blockquote>

<p>This method returns the names of all the headers as an
<tt class="literal">Enumeration</tt> of <tt class="literal">String</tt> objects.
It returns an empty <tt class="literal">Enumeration</tt> if there were no
headers. The Servlet API gives servlet engine implementations the
right to not allow headers to be accessed in this way, in which case
this method returns <tt class="literal">null</tt>.
</p>

<p>
<a href="#ch04-12841">Example 4-14</a> demonstrates the use of these methods in
a servlet that prints information about its HTTP
<a name="INDEX-832"></a><a name="INDEX-833"></a><a name="INDEX-834"></a><a name="INDEX-835"></a>
request headers.
</p>

<a name="ch04-12841"></a>
<div class="example">
<h4 class="objtitle">Example 4-14. Snooping headers </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class HeaderSnoop extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res)
                               throws ServletException, IOException {
    res.setContentType("text/plain");
    PrintWriter out = res.getWriter();

    out.println("Request Headers:");
    out.println();
    Enumeration enum = req.getHeaderNames();
    while (enum.hasMoreElements()) {
      String name = (String) enum.nextElement();
      String value = req.getHeader(name);
      if (value != null) {
        out.println(name + ": " + value);
      }
    }
  }
}</pre>
</blockquote>
</div>

<p>Some example output from this servlet might look like this:</p>

<blockquote>
<pre class="programlisting">Request Headers:

Connection: Keep-Alive
If-Modified-Since: Saturday, 13-Jun-98 20:50:31 GMT; length=297
User-Agent: Mozilla/4.05 [en] (X11; I; IRIX 6.2 IP22)
Host: localhost:8080
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
Cookie: jwssessionid=A3KBB1YAAAAABQDGPM5QAAA</pre>
</blockquote>



<a name="ch04-23-fm2xml"></a>
<h3 class="sect3">4.4.8.2. Headers in servlet chains</h3>

<p>Servlet <a name="INDEX-836"></a><a name="INDEX-837"></a>
chains add an interesting twist to how servlets handle headers.
Unlike all other servlets, a servlet in the middle or at the end of a
servlet chain reads header values not from the client's
request, but from the previous servlet's response.
</p>

<p>The power and flexibility of this approach comes from the fact that a
servlet can intelligently process a previous servlet's output,
not only in body content, but in header values. For example, it can
add extra headers to the response or change the value of existing
headers. It can even suppress the previous servlet's headers.
</p>

<p>But power comes with responsibilities: unless a chained servlet
specifically reads the previous servlet's response headers and
sends them as part of its own response, the headers are not passed on
and will not be seen by the client. A well-behaved chained servlet
always passes on the previous servlet's headers, unless it has
a specific reason to do otherwise.
</p>

<p>The code shown in <a href="#ch04-17475">Example 4-15</a> uses
<tt class="literal">getHeaderNames()</tt> in combination with
<tt class="literal">getHeader()</tt> and <tt class="literal">setHeader()</tt> to
pass on the headers from the previous servlet to the client (or
possibly to another servlet in the chain). The only header given
special treatment is the <tt class="literal">Content-Length</tt> header.
This header's value reports the length of the response in
bytes--a value that is likely to change during the chaining
process and so not appropriate to send on. Note that you
haven't seen the <tt class="literal">setHeader()</tt> method before.
It can be used to, well, set a header.
</p>

<a name="ch04-17475"></a>
<div class="example">
<h4 class="objtitle">Example 4-15. Passing on the headers </h4>
<blockquote>
<pre class="programlisting">Enumeration enum = req.getHeaderNames();
if (enum != null) {  // to be safe across all implementations
  while (enum.hasMoreElements()) {
    String header = (String)enum.nextElement();
    if ("Content-Length").equalsIgnoreCase(header))
      continue;
    String value = req.getHeader(header);
    res.setHeader(header, value);
  }
}</pre>
</blockquote>
</div>

<p>An HTTP servlet designed to function in a chain should include code
similar to this early on in its handling of a request, so as to pass
on the appropriate headers.
</p>



<a name="ch04-24-fm2xml"></a>
<h3 class="sect2">4.4.9. Wading the Input Stream</h3>

<p>Each request handled by a servlet has an <a name="INDEX-838"></a><a name="INDEX-839"></a>input stream associated with it. Just
as a servlet can write to a <tt class="literal">PrintWriter</tt> or
<tt class="literal">OutputStream</tt> associated with its response object,
it can read from a <tt class="literal">Reader</tt> or
<tt class="literal">InputStream</tt> associated with its request object.
The data read from the input stream can be of any content type and of
any length. The input stream has three purposes:
</p>

<ul>
<li>
<p>	To pass a chained servlet the response body from the previous servlet</p>
</li>
<li>
<p>	To pass an HTTP servlet the content associated with a POST request</p>
</li>
<li>
<p>	To pass a non-HTTP servlet the raw data sent by the client</p>
</li>
</ul>

<p>To read character data from the input stream, you should use
<tt class="literal">getReader()</tt><a name="INDEX-840"></a><a name="INDEX-841"></a>
to retrieve the input stream as a <tt class="literal">BufferedReader</tt>
object:
</p>

<blockquote>
<pre class="programlisting">public BufferedReader ServletRequest.getReader() throws IOException</pre>
</blockquote>

<p>The advantage of using a <tt class="literal">BufferedReader</tt> for
reading character-based data is that it should translate charsets as
appropriate. This method throws an
<tt class="literal">IllegalStateException</tt> if
<tt class="literal">getInputStream()</tt> has been called before on this
same request. It throws an
<tt class="literal">UnsupportedEncodingException</tt> if the character
encoding of the input is unsupported or unknown.
</p>

<p>To read binary data from the input stream, use
<tt class="literal">getInputStream()</tt><a name="INDEX-842"></a><a name="INDEX-843"></a>
to retrieve the input stream as a
<tt class="literal">ServletInputStream</tt> object:
</p>

<blockquote>
<pre class="programlisting">public ServletInputStream ServletRequest.getInputStream() throws IOException</pre>
</blockquote>

<p>A <tt class="literal">ServletInputStream</tt> is a direct subclass of
<tt class="literal">InputStream</tt> and can be treated as a normal
<tt class="literal">InputStream</tt>, with the added ability to efficiently
read input a line at a time into an array of bytes. The method throws
an <tt class="literal">IllegalStateException</tt> if
<tt class="literal">getReader()</tt> has been called before on this same
request. Once you have the <tt class="literal">ServletInputStream</tt>, you
can read a line from it using
<tt class="literal">readLine()</tt><a name="INDEX-844"></a><a name="INDEX-845"></a>
:
</p>

<blockquote>
<pre class="programlisting">public int ServletInputStream.readLine(byte b[], int off, int len)
  throws IOException</pre>
</blockquote>

<p>This method reads bytes from the input stream into the
<tt class="literal">byte</tt> array <tt class="literal">b</tt>, starting at an
offset in the array given by <tt class="literal">off</tt>. It stops reading
when it encounters an <tt class="literal">'\n'</tt> or when it has read
<tt class="literal">len</tt> number of bytes. The ending
<tt class="literal">'\n'</tt> character is read into the buffer as well.
The method returns the number of bytes read or <tt class="literal">-1</tt>
if the end of the stream is reached.
</p>

<p>A servlet can also check the content type and the length of the data
being sent via the input stream, using
<tt class="literal">getContentType()</tt><a name="INDEX-846"></a><a name="INDEX-847"></a>
and
<tt class="literal">getContentLength()</tt><a name="INDEX-848"></a><a name="INDEX-849"></a>
, respectively:
</p>

<blockquote>
<pre class="programlisting">public String ServletRequest.getContentType()
public int ServletRequest.getContentLength()</pre>
</blockquote>

<p>
<tt class="literal">getContentType()</tt> returns the media type of the
content being sent via the input stream or <tt class="literal">null</tt> if
the type is not known (such as when there is no data).
<tt class="literal">getContentLength()</tt> returns the length, in bytes,
of the content being sent via the input stream or
<tt class="literal">-1</tt> if this not known.
</p>

<a name="ch04-25-fm2xml"></a>
<h3 class="sect3">4.4.9.1. Chaining servlets using the input stream</h3>

<p>A servlet in a servlet <a name="INDEX-850"></a><a name="INDEX-851"></a> chain receives its response body from
the previous servlet in the chain through its input stream. This use
was first shown in the <tt class="literal">Deblink</tt> servlet in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch02_01.htm">Chapter 2, "HTTP Servlet Basics"</a>. The pertinent section is shown again here:
</p>

<blockquote>
<pre class="programlisting">String contentType = req.getContentType();  // get the incoming type
if (contentType == null) return;  // nothing incoming, nothing to do
res.setContentType(contentType);  // set outgoing type to be incoming type

BufferedReader br = req.getReader();

String line = null;
while ((line = br.readLine()) != null) {
  line = replace(line, "&lt;BLINK&gt;", "");
  line = replace(line, "&lt;/BLINK&gt;", "");
  out.println(line);
}</pre>
</blockquote>

<p>Notice the use of <tt class="literal">getContentType()</tt> to retrieve the
content type of the previous servlet's output. Also notice that
<tt class="literal">getContentLength()</tt> is not used. We don't
need to use it because all <tt class="literal">read()</tt> and
<tt class="literal">readLine()</tt> methods indicate that they have reached
the end of the stream with special return values. In fact, it's
better not to use <tt class="literal">getContentLength()</tt> in a servlet
chain because it is unsupported in many servlet engine
implementations. Presumably the reason is that the server may choose
to tie the output stream of one servlet directly to the input stream
of the next servlet, giving no chance to determine a total content
length.
</p>



<a name="ch04-26-fm2xml"></a>
<h3 class="sect3">4.4.9.2. Handling POST requests using the input stream</h3>

<p>It is a rare occurrence when a servlet handling a
<a name="INDEX-852"></a><a name="INDEX-853"></a><a name="INDEX-854"></a>POST request is forced to use its
input stream to access the POST data. Typically, the POST data is
nothing more than encoded parameter information, which a servlet can
conveniently retrieve with its
<tt class="literal">getParameter()</tt><a name="INDEX-855"></a><a name="INDEX-856"></a>
method.
</p>

<p>A servlet can identify this type of POST request by checking the
content type of the input stream. If it is of type
<tt class="literal">application/x-www-form-urlencoded</tt>, the data can be
retrieved with <tt class="literal">getParameter()</tt> and similar methods.
<a href="#ch04-40696">Example 4-16</a> demonstrates a servlet that keys off the
<a name="INDEX-857"></a> input stream's content
type to handle POST requests.
</p>

<a name="ch04-40696"></a>
<div class="example">
<h4 class="objtitle">Example 4-16. Reading parameters passed by POST </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class PostParams extends HttpServlet {

  public void doPost(HttpServletRequest req, HttpServletResponse res)
                                throws ServletException, IOException {
    res.setContentType("text/plain");
    PrintWriter out = res.getWriter();

    if ("application/x-www-form-urlencoded".equals(req.getContentType())) {
      Enumeration enum = req.getParameterNames();
      while (enum.hasMoreElements()) {
        String name = (String) enum.nextElement();
        String values[] = req.getParameterValues(name);
        if (values != null) {
          for (int i = 0; i &lt; values.length; i++) {
            out.println(name + " (" + i + "): " + values[i]);
          }
        }
      }
    }
  }
}</pre>
</blockquote>
</div>

<p>In case you were wondering, the odd arrangement of code that checks
the request's content type is arranged to avoid a
<tt class="literal">NullPointerException</tt> if the
<tt class="literal">getContentType()</tt> call returns
<tt class="literal">null</tt>.
</p>

<p>A servlet may wish to call the <tt class="literal">getContentLength()</tt>
method before calling <tt class="literal">getParameter()</tt><a name="INDEX-858"></a><a name="INDEX-859"></a> to prevent denial of
service attacks. A rogue client may send an absurdly large amount of
data as part of a POST request, hoping to slow the server to a crawl
as the servlet's <tt class="literal">getParameter()</tt> method
churns over the data. A servlet can use
<tt class="literal">getContentLength()</tt> to verify that the length is
reasonable, perhaps less than 4K, as a preventive measure.
</p>



<a name="ch04-27-fm2xml"></a>
<h3 class="sect3">4.4.9.3. Receiving files using the input stream</h3>

<p>A servlet can also receive a file upload using its input stream.
Before we see how, it's important to note that
<a name="INDEX-860"></a><a name="INDEX-861"></a>file
uploading is experimental and not supported in all browsers. Netscape
first supported file uploads with
<a name="INDEX-862"></a>Netscape Navigator 3;
<a name="INDEX-863"></a>
Microsoft first supported it with Internet Explorer 4.
</p>

<p>The full file upload specification is contained in experimental RFC
1867, available at <a href="../../../../../../../www.ietf.org/rfc/rfc1867.txt">http://www.ietf.org/rfc/rfc1867.txt</a><a name="INDEX-864"></a><a name="INDEX-865"></a>. The short
summary is that any number of files and parameters can be sent as
form data in a single POST request. The POST request is formatted
differently than standard
<tt class="literal">application/x-www-form-urlencoded</tt> form data and
indicates this fact by setting its content type to
<tt class="literal">multipart/form-data</tt>.
</p>

<p>It's fairly simple to write the client half of a file upload.
The following HTML generates a form that asks for a user's name
and a file to upload. Note the addition of the
<tt class="literal">ENCTYPE</tt> attribute and the use of a
<tt class="literal">FILE</tt> input type:
</p>

<blockquote>
<pre class="programlisting">&lt;FORM ACTION="/servlet/UploadTest" ENCTYPE="multipart/form-data" METHOD=POST&gt;
What is your name? &lt;INPUT TYPE=TEXT NAME=submitter&gt; &lt;BR&gt;
Which file do you want to upload? &lt;INPUT TYPE=FILE NAME=file&gt; &lt;BR&gt;
&lt;INPUT TYPE=SUBMIT&gt;
&lt;/FORM&gt;</pre>
</blockquote>

<p>A user receiving this form sees a page that looks something like
<a href="#ch04-34777">Figure 4-3</a>. A filename can be entered in the text
area, or it can be selected by browsing. After selection, the user
submits the form as
<a name="INDEX-866"></a>usual.
</p>

<a name="ch04-34777"></a>
<div class="figure">
<img alt="figure" src="figs/jsp_0403.gif" webstripperlinkwas="figs/jsp_0403.gif"></div>
<h4 class="objtitle">Figure 4-3. Choosing a file to upload</h4>

<p>The server's responsibilities during a file upload are slightly
more complicated. From the receiving servlet's perspective, the
submission is nothing more than a raw data stream in its input
stream--a data stream formatted according to the
<tt class="literal">multipart/form-data</tt> content type given in RFC
1867. The Servlet API, lamentably, provides no methods to aid in the
parsing of the data. To simplify your life (and ours since we
don't want to explain RFC 1867), Jason has written a utility
class that does the work for you. It's named
<tt class="literal">MultipartRequest</tt><a name="INDEX-867"></a><a name="INDEX-868"></a>
and is shown in <a href="#ch04-20158">Example 4-18</a> later in this section.
</p>

<p>
<tt class="literal">MultipartRequest</tt> wraps around a
<tt class="literal">ServletRequest</tt> and presents a simple API to the
servlet programmer. The class has two constructors:
</p>

<blockquote>
<pre class="programlisting">public MultipartRequest(ServletRequest request, String saveDirectory,
                        int maxPostSize) throws IOException
public MultipartRequest(ServletRequest request,
                        String saveDirectory) throws IOException</pre>
</blockquote>

<p>Each of these methods creates a new
<tt class="literal">MultipartRequest</tt> object to handle the specified
request, saving any uploaded files to
<tt class="literal">saveDirectory</tt>. Both constructors actually parse
the <tt class="literal">multipart/form-data</tt> content and throw an
<tt class="literal">IOException</tt> if there's any problem. The
constructor that takes a <tt class="literal">maxPostSize</tt> parameter
also throws an <tt class="literal">IOException</tt> if the uploaded content
is larger than <tt class="literal">maxPostSize</tt>. The second constructor
assumes a default <tt class="literal">maxPostSize</tt> of 1 MB.
</p>

<p>The <tt class="literal">MultipartRequest</tt> class has six public methods
that let you get at information about the request. You'll
notice that many of these methods are modeled after
<tt class="literal">ServletRequest</tt> methods. Use
<tt class="literal">getParameterNames()</tt><a name="INDEX-869"></a><a name="INDEX-870"></a>
to retrieve the names of all the request parameters:
</p>

<blockquote>
<pre class="programlisting">public Enumeration MultipartRequest.getParameterNames()</pre>
</blockquote>

<p>This method returns the names of all the parameters as an
<tt class="literal">Enumeration</tt> of <tt class="literal">String</tt> objects
or an empty <tt class="literal">Enumeration</tt> if there are no
parameters.
</p>

<p>To get the value of a named parameter, use
<tt class="literal">getParameter()</tt>:
</p>

<blockquote>
<pre class="programlisting">public String MultipartRequest.getParameter(String name)</pre>
</blockquote>

<p>This method returns the value of the named parameter as a
<tt class="literal">String</tt> or <tt class="literal">null</tt> if the parameter
was not given. The value is guaranteed to be in its normal, decoded
form. If the parameter has multiple values, only the last one is
returned.
</p>

<p>Use
<tt class="literal">getFileNames()</tt><a name="INDEX-871"></a><a name="INDEX-872"></a>
to get a list of all the uploaded files:
</p>

<blockquote>
<pre class="programlisting">public Enumeration MultipartRequest.getFileNames()</pre>
</blockquote>

<p>This method returns the names of all the uploaded files as an
<tt class="literal">Enumeration</tt> of <tt class="literal">String</tt> objects,
or an empty <tt class="literal">Enumeration</tt> if there are no uploaded
files. Note that each filename is the name specified by the HTML
form's <tt class="literal">name</tt> attribute, not by the user. Once
you have the name of a file, you can get its file system name using
<tt class="literal">getFilesystemName()</tt><a name="INDEX-873"></a><a name="INDEX-874"></a>
:
</p>

<blockquote>
<pre class="programlisting">public String MultipartRequest.getFilesystemName(String name)</pre>
</blockquote>

<p>This method returns the file system name of the specified file or
<tt class="literal">null</tt> if the file was not included in the upload. A
file system name is the name specified by the user. It is also the
name under which the file is actually saved. You can get the content
type of the file with
<tt class="literal">getContentType()</tt><a name="INDEX-875"></a><a name="INDEX-876"></a>
:
</p>

<blockquote>
<pre class="programlisting">public String MultipartRequest.getContentType(String name)</pre>
</blockquote>

<p>This method returns the content type of the specified file (as
supplied by the client browser) or <tt class="literal">null</tt> if the
file was not included in the upload. Finally, you can get a
<tt class="literal">java.io.File</tt> object for the file with
<tt class="literal">getFile()</tt><a name="INDEX-877"></a><a name="INDEX-878"></a>
:
</p>

<blockquote>
<pre class="programlisting">public File MultipartRequest.getFile(String name)</pre>
</blockquote>

<p>This method returns a <tt class="literal">File</tt> object for the
specified file saved on the server's file system or
<tt class="literal">null</tt> if the file was not included in the upload.
</p>

<p>
<a href="#ch04-30890">Example 4-17</a> shows how a servlet uses
<tt class="literal">MultipartRequest</tt>. The servlet does nothing but
display the statistics for what was uploaded. Notice that it does not
delete the files it saves.
</p>

<a name="ch04-30890"></a>
<div class="example">
<h4 class="objtitle">Example 4-17. Handling a file upload </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

import com.oreilly.servlet.MultipartRequest;

public class UploadTest extends HttpServlet {

  public void doPost(HttpServletRequest req, HttpServletResponse res)
                                throws ServletException, IOException {
    res.setContentType("text/html");
    PrintWriter out = res.getWriter();

    try {
      // Blindly take it on faith this is a multipart/form-data request

      // Construct a MultipartRequest to help read the information.
      // Pass in the request, a directory to save files to, and the
      // maximum POST size we should attempt to handle.
      // Here we (rudely) write to the server root and impose 5 Meg limit.
      MultipartRequest multi =
        new MultipartRequest(req, ".", 5 * 1024 * 1024);

      out.println("&lt;HTML&gt;");
      out.println("&lt;HEAD&gt;&lt;TITLE&gt;UploadTest&lt;/TITLE&gt;&lt;/HEAD&gt;");
      out.println("&lt;BODY&gt;");
      out.println("&lt;H1&gt;UploadTest&lt;/H1&gt;");

      // Print the parameters we received
      out.println("&lt;H3&gt;Params:&lt;/H3&gt;");
      out.println("&lt;PRE&gt;");
      Enumeration params = multi.getParameterNames();
      while (params.hasMoreElements()) {
        String name = (String)params.nextElement();
        String value = multi.getParameter(name);
        out.println(name + " = " + value);
      }
      out.println("&lt;/PRE&gt;");

      // Show which files we received
      out.println("&lt;H3&gt;Files:&lt;/H3&gt;");
      out.println("&lt;PRE&gt;");
      Enumeration files = multi.getFileNames();
      while (files.hasMoreElements()) {
        String name = (String)files.nextElement();
        String filename = multi.getFilesystemName(name);
        String type = multi.getContentType(name);
        File f = multi.getFile(name);
        out.println("name: " + name);
        out.println("filename: " + filename);
        out.println("type: " + type);
        if (f != null) {
          out.println("length: " + f.length());
          out.println();
        }
        out.println("&lt;/PRE&gt;");
      }
    }
    catch (Exception e) {
      out.println("&lt;PRE&gt;");
      e.printStackTrace(out);
      out.println("&lt;/PRE&gt;");
    }
    out.println("&lt;/BODY&gt;&lt;/HTML&gt;");
  }
}</pre>
</blockquote>
</div>

<p>The servlet passes its request object to the
<tt class="literal">MultipartRequest</tt> constructor, along with a
directory relative to the server root where the uploaded files are to
be saved (because large files may not fit in memory) and a maximum
POST size of 5 MB. The servlet then uses
<tt class="literal">MultipartRequest</tt> to iterate over the parameters
that were sent. Notice that the <tt class="literal">MultipartRequest</tt>
API for handling parameters matches that of
<tt class="literal">ServletRequest</tt>. Finally, the servlet uses its
<tt class="literal">MultipartRequest</tt> to iterate over the files that
were sent. For each file, it gets the file's name (as specified
on the form), file system name (as specified by the user), and
content type. It also gets a <tt class="literal">File</tt> reference and
uses it to display the length of the saved file. If there are any
problems, the servlet reports the exception to the user.
</p>

<p>
<a href="#ch04-20158">Example 4-18</a> shows the code for
<tt class="literal">MultipartRequest</tt>. This class could be written more
elegantly using a regular expression library, as discussed in <a href="ch13_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch13_01.htm">Chapter 13, "Odds and Ends"</a> ; however, not doing so allows this class to
be self-contained and works just as well. We aren't going to
elaborate on the class here--you should read the comments if you
want to understand everything that is going on. This class uses some
of the techniques that we've covered in this chapter, so it is
a good review of the material. You should also feel free to skip this
example for now and come back to it later if you'd like.
</p>

<a name="ch04-20158"></a>
<div class="example">
<h4 class="objtitle">Example 4-18. The MultipartRequest class </h4>
<blockquote>
<pre class="programlisting">package com.oreilly.servlet;

import java.io.*;
import java.util.*;
import javax.servlet.*;

public class MultipartRequest {

  private static final int DEFAULT_MAX_POST_SIZE = 1024 * 1024;  // 1 Meg

  private ServletRequest req;
  private File dir;
  private int maxSize;

  private Hashtable parameters = new Hashtable();  // name - value
  private Hashtable files = new Hashtable();       // name - UploadedFile

  public MultipartRequest(ServletRequest request,
                          String saveDirectory) throws IOException {
    this(request, saveDirectory, DEFAULT_MAX_POST_SIZE);
  }

  public MultipartRequest(ServletRequest request,
                          String saveDirectory,
                          int maxPostSize) throws IOException {
    // Sanity check values
    if (request == null)
      throw new IllegalArgumentException("request cannot be null");
    if (saveDirectory == null)
      throw new IllegalArgumentException("saveDirectory cannot be null");
    if (maxPostSize &lt;= 0) {
      throw new IllegalArgumentException("maxPostSize must be positive");
    }

    // Save the request, dir, and max size
    req = request;
    dir = new File(saveDirectory);
    maxSize = maxPostSize;

    // Check saveDirectory is truly a directory
    if (!dir.isDirectory())
      throw new IllegalArgumentException("Not a directory: " + saveDirectory);

    // Check saveDirectory is writable
    if (!dir.canWrite())
      throw new IllegalArgumentException("Not writable: " + saveDirectory);

    // Now parse the request saving data to "parameters" and "files";
    // write the file contents to the saveDirectory
    readRequest();
  }

  public Enumeration getParameterNames() {
    return parameters.keys();
  }

  public Enumeration getFileNames() {
    return files.keys();
  }

  public String getParameter(String name) {
    try {
      String param = (String)parameters.get(name);
      if (param.equals("")) return null;
      return param;
    }
    catch (Exception e) {
      return null;
    }
  }

  public String getFilesystemName(String name) {
    try {
      UploadedFile file = (UploadedFile)files.get(name);
      return file.getFilesystemName();  // may be null
    }
    catch (Exception e) {
      return null;
    }
  }

  public String getContentType(String name) {
    try {
      UploadedFile file = (UploadedFile)files.get(name);
      return file.getContentType();  // may be null
    }
    catch (Exception e) {
      return null;
    }
  }

  public File getFile(String name) {
    try {
      UploadedFile file = (UploadedFile)files.get(name);
      return file.getFile();  // may be null
    }
    catch (Exception e) {
      return null;
    }
  }

  protected void readRequest() throws IOException {
    // Check the content type to make sure it's "multipart/form-data"
    String type = req.getContentType();
    if (type == null || 
        !type.toLowerCase().startsWith("multipart/form-data")) {
      throw new IOException("Posted content type isn't multipart/form-data");
    }

    // Check the content length to prevent denial of service attacks
    int length = req.getContentLength();
    if (length &gt; maxSize) {
      throw new IOException("Posted content length of " + length + 
                            " exceeds limit of " + maxSize);
    }

    // Get the boundary string; it's included in the content type.
    // Should look something like "------------------------12012133613061"
    String boundary = extractBoundary(type);
    if (boundary == null) {
      throw new IOException("Separation boundary was not specified");
    }

    // Construct the special input stream we'll read from
    MultipartInputStreamHandler in =
      new MultipartInputStreamHandler(req.getInputStream(), boundary, length);

    // Read the first line, should be the first boundary
    String line = in.readLine();
    if (line == null) {
      throw new IOException("Corrupt form data: premature ending");
    }

    // Verify that the line is the boundary
    if (!line.startsWith(boundary)) {
      throw new IOException("Corrupt form data: no leading boundary");
    }

    // Now that we're just beyond the first boundary, loop over each part
    boolean done = false;
    while (!done) {
      done = readNextPart(in, boundary);
    }
  }

  protected boolean readNextPart(MultipartInputStreamHandler in,
                                 String boundary) throws IOException {
    // Read the first line, should look like this:
    // content-disposition: form-data; name="field1"; filename="file1.txt"
    String line = in.readLine();
    if (line == null) {
      // No parts left, we're done
      return true;
    }

    // Parse the content-disposition line
    String[] dispInfo = extractDispositionInfo(line);
    String disposition = dispInfo[0];
    String name = dispInfo[1];
    String filename = dispInfo[2];

    // Now onto the next line. This will either be empty 
    // or contain a Content-Type and then an empty line.
    line = in.readLine();
    if (line == null) {
      // No parts left, we're done
      return true;
    }

    // Get the content type, or null if none specified
    String contentType = extractContentType(line);
    if (contentType != null) {
      // Eat the empty line
      line = in.readLine();
      if (line == null || line.length() &gt; 0) {  // line should be empty
        throw new 
          IOException("Malformed line after content type: " + line);
      }
    }
    else {
      // Assume a default content type
      contentType = "application/octet-stream";
    }

    // Now, finally, we read the content (end after reading the boundary)
    if (filename == null) {
      // This is a parameter
      String value = readParameter(in, boundary);
      parameters.put(name, value);
    }
    else {
      // This is a file
      readAndSaveFile(in, boundary, filename);
      if (filename.equals("unknown")) {
        files.put(name, new UploadedFile(null, null, null));
      }
      else {
        files.put(name,
          new UploadedFile(dir.toString(), filename, contentType));
      }
    }
    return false;  // there's more to read
  }

  protected String readParameter(MultipartInputStreamHandler in,
                                 String boundary) throws IOException {
    StringBuffer sbuf = new StringBuffer();
    String line;

    while ((line = in.readLine()) != null) {
      if (line.startsWith(boundary)) break;
      sbuf.append(line + "\r\n");  // add the \r\n in case there are many lines
    }

    if (sbuf.length() == 0) {
      return null;  // nothing read
    }

    sbuf.setLength(sbuf.length() - 2);  // cut off the last line's \r\n
    return sbuf.toString();  // no URL decoding needed
  }

  protected void readAndSaveFile(MultipartInputStreamHandler in,
                                 String boundary,
                                 String filename) throws IOException {
    File f = new File(dir + File.separator + filename);
    FileOutputStream fos = new FileOutputStream(f);
    BufferedOutputStream out = new BufferedOutputStream(fos, 8 * 1024); // 8K

    byte[] bbuf = new byte[8 * 1024];  // 8K
    int result;
    String line;

    // ServletInputStream.readLine() has the annoying habit of 
    // adding a \r\n to the end of the last line. 
    // Since we want a byte-for-byte transfer, we have to cut those chars.
    boolean rnflag = false;
    while ((result = in.readLine(bbuf, 0, bbuf.length)) != -1) {
      // Check for boundary
      if (result &gt; 2 &amp;&amp; bbuf[0] == '-' &amp;&amp; bbuf[1] == '-') { // quick pre-check
        line = new String(bbuf, 0, result, "ISO-8859-1");
        if (line.startsWith(boundary)) break;
      }
      // Are we supposed to write \r\n for the last iteration?
      if (rnflag) {
        out.write('\r'); out.write('\n');
        rnflag = false;
      }
      // Write the buffer, postpone any ending \r\n
      if (result &gt;= 2 &amp;&amp; 
          bbuf[result - 2] == '\r' &amp;&amp; 
          bbuf[result - 1] == '\n') {
        out.write(bbuf, 0, result - 2);  // skip the last 2 chars
        rnflag = true;  // make a note to write them on the next iteration
      }
      else {
        out.write(bbuf, 0, result);
      }
    }
    out.flush();
    out.close();
    fos.close();
  }

  private String extractBoundary(String line) {
    int index = line.indexOf("boundary=");
    if (index == -1) {
      return null;
    }
    String boundary = line.substring(index + 9);  // 9 for "boundary="

    // The real boundary is always preceded by an extra "--"
    boundary = "--" + boundary;

    return boundary;
  }

  private String[] extractDispositionInfo(String line) throws IOException {
    // Return the line's data as an array: disposition, name, filename
    String[] retval = new String[3];

    // Convert the line to a lowercase string without the ending \r\n
    // Keep the original line for error messages and for variable names.
    String origline = line;
    line = origline.toLowerCase();

    // Get the content disposition, should be "form-data"
    int start = line.indexOf("content-disposition: ");
    int end = line.indexOf(";");
    if (start == -1 || end == -1) {
      throw new IOException("Content disposition corrupt: " + origline);
    }
    String disposition = line.substring(start + 21, end);
    if (!disposition.equals("form-data")) {
      throw new IOException("Invalid content disposition: " + disposition);
    }

    // Get the field name
    start = line.indexOf("name=\"", end);  // start at last semicolon
    end = line.indexOf("\"", start + 7);   // skip name=\"
    if (start == -1 || end == -1) {
      throw new IOException("Content disposition corrupt: " + origline);
    }
    String name = origline.substring(start + 6, end);

    // Get the filename, if given
    String filename = null;
    start = line.indexOf("filename=\"", end + 2);  // start after name
    end = line.indexOf("\"", start + 10);          // skip filename=\"
    if (start != -1 &amp;&amp; end != -1) {                // note the !=
      filename = origline.substring(start + 10, end);
      // The filename may contain a full path. Cut to just the filename.
      int slash =
        Math.max(filename.lastIndexOf('/'), filename.lastIndexOf('\\'));
      if (slash &gt; -1) {
        filename = filename.substring(slash + 1);  // past last slash
      }
      if (filename.equals("")) filename = "unknown"; // sanity check
    }

    // Return a String array: disposition, name, filename
    retval[0] = disposition;
    retval[1] = name;
    retval[2] = filename;
    return retval;
  }

  private String extractContentType(String line) throws IOException {
    String contentType = null;

    // Convert the line to a lowercase string
    String origline = line;
    line = origline.toLowerCase();

    // Get the content type, if any
    if (line.startsWith("content-type")) {
      int start = line.indexOf(" ");
      if (start == -1) {
        throw new IOException("Content type corrupt: " + origline);
      }
      contentType = line.substring(start + 1);
    }
    else if (line.length() != 0) {  // no content type, so should be empty
      throw new IOException("Malformed line after disposition: " + origline);
    }

    return contentType;
  }
}


// A class to hold information about an uploaded file.
//
class UploadedFile {

  private String dir;
  private String filename;
  private String type;

  UploadedFile(String dir, String filename, String type) {
    this.dir = dir;
    this.filename = filename;
    this.type = type;
  }

  public String getContentType() {
    return type;
  }

  public String getFilesystemName() {
    return filename;
  }

  public File getFile() {
    if (dir == null || filename == null) {
      return null;
    }
    else {
      return new File(dir + File.separator + filename);
    }
  }
}


// A class to aid in reading multipart/form-data from a ServletInputStream.
// It keeps track of how many bytes have been read and detects when the
// Content-Length limit has been reached. This is necessary because some 
// servlet engines are slow to notice the end of stream.
//
class MultipartInputStreamHandler {

  ServletInputStream in;
  String boundary;
  int totalExpected;
  int totalRead = 0;
  byte[] buf = new byte[8 * 1024];

  public MultipartInputStreamHandler(ServletInputStream in,
                                     String boundary,
                                     int totalExpected) {
    this.in = in;
    this.boundary = boundary;
    this.totalExpected = totalExpected;
  }

  public String readLine() throws IOException {
    StringBuffer sbuf = new StringBuffer();
    int result;
    String line;

    do {
      result = this.readLine(buf, 0, buf.length);  // this.readLine() does +=
      if (result != -1) {
        sbuf.append(new String(buf, 0, result, "ISO-8859-1"));
      }
    } while (result == buf.length);  // loop only if the buffer was filled

    if (sbuf.length() == 0) {
      return null;  // nothing read, must be at the end of stream
    }

    sbuf.setLength(sbuf.length() - 2);  // cut off the trailing \r\n
    return sbuf.toString();
  }

  public int readLine(byte b[], int off, int len) throws IOException {
    if (totalRead &gt;= totalExpected) {
      return -1;
    }
    else {
      int result = in.readLine(b, off, len);
      if (result &gt; 0) {
        totalRead += result;
      }
      return result;
    }
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-879"></a>
<a name="INDEX-880"></a>
<a name="INDEX-881"></a>
<a name="INDEX-882"></a>

<a name="ch04-28-fm2xml"></a>
<h3 class="sect2">4.4.10. Extra Attributes</h3>

<p>Sometimes a servlet needs to know something about a request
that's not available via any of the previously mentioned
methods. In these cases, there is one last alternative, the
<tt class="literal">getAttribute()</tt> method. Remember how
<tt class="literal">ServletContext</tt> has a
<tt class="literal">getAttribute()</tt> method that returns server-specific
attributes about the server itself? <tt class="literal">ServletRequest</tt>
also has a
<tt class="literal">getAttribute()</tt><a name="INDEX-883"></a><a name="INDEX-884"></a>
method:
</p>

<blockquote>
<pre class="programlisting">public Object ServletRequest.getAttribute(String name)</pre>
</blockquote>

<p>This method returns the value of a server-specific attribute for the
request or <tt class="literal">null</tt> if the server does not support the
named request attribute. This method allows a server to provide a
servlet with custom information about a request. For example, the
Java Web Server makes three attributes available:
<tt class="literal">javax.net.ssl.cipher_suite</tt>,
<tt class="literal">javax.net.ssl.peer_certificates</tt>, and
<tt class="literal">javax.net.ssl.session</tt>. A servlet running in the
Java Web Server can use these attributes to inspect the details of an
SSL connection with the client.
</p>

<p>
<a href="#ch04-14219">Example 4-19</a> shows a code snippet that uses
<tt class="literal">getAttribute()</tt> to query the server on the details
of its <a name="INDEX-885"></a><a name="INDEX-886"></a>SSL connection. Remember, these
attributes are server-specific and may not be available in servers
other than the Java Web Server.
</p>

<a name="ch04-14219"></a>
<div class="example">
<h4 class="objtitle">Example 4-19. Getting the attributes available in the Java Web Server </h4>
<blockquote>
<pre class="programlisting">import javax.security.cert.X509Certificate;
import javax.net.ssl.SSLSession;

out.println("&lt;PRE&gt;");

// Display the cipher suite in use
String cipherSuite = 
  (String) req.getAttribute("javax.net.ssl.cipher_suite");
out.println("Cipher Suite: " + cipherSuite);

// Display the client's certificates, if there are any
if (cipherSuite != null) {
  X509Certificate[] certChain = 
    (X509Certificate[]) req.getAttribute("javax.net.ssl.peer_certificates");
  if (certChain != null) {
    for (int i = 0; i &lt; certChain.length; i++) {
      out.println ("Client Certificate [" + i + "] = "
                      + certChain[i].toString());
    }
  }
}

out.println("&lt;/PRE&gt;");</pre>
</blockquote>
</div>

<p>The servlet's output on receiving a
<a name="INDEX-887"></a><a name="INDEX-888"></a><a name="INDEX-889"></a>
VeriSign certificate is shown below. What it means is
<a name="INDEX-890"></a>discussed in <a href="ch08_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch08_01.htm">Chapter 8, "Security"</a>.
</p>

<blockquote>
<pre class="programlisting">Cipher Suite:  SSL_RSA_EXPORT_WITH_RC4_40_MD5
Client Certificate [0] = [
  X.509v3 certificate,
  Subject is OID.1.2.840.113549.1.9.1=#160F6A68756E746572407367692E636F6D,
CN=Jason Hunter, OU=Digital ID Class 1 - Netscape,
OU="www.verisign.com/repository/CPS Incorp. by Ref.,LIAB.LTD(c)96",
OU=VeriSign Class 1 CA - Individual Subscriber, O="VeriSign, Inc.",
L=Internet
  Key:  algorithm = [RSA], exponent = 0x    010001, modulus = 
    b35ed5e7 45fc5328 e3f5ce70 838cc25d 0a0efd41 df4d3e1b 64f70617 528546c8
    fae46995 9922a093 7a54584d d466bee7 e7b5c259 c7827489 6478e1a9 3a16d45f
  Validity  until 
  Issuer is OU=VeriSign Class 1 CA - Individual Subscriber, O="VeriSign, 
Inc.", 
    L=Internet
  Issuer signature used [MD5withRSA]
  Serial number =     20556dc0 9e31dfa4 ada6e10d 77954704 
]
Client Certificate [1] = [
  X.509v3 certificate,
  Subject is OU=VeriSign Class 1 CA - Individual Subscriber, O="VeriSign, 
Inc.", L=Internet
  Key:  algorithm = [RSA], exponent = 0x    010001, modulus = 
    b614a6cf 4dd0050d d8ca23d0 6faab429 92638e2c f86f96d7 2e9d764b 11b1368d
    57c9c3fd 1cc6bafe 1e08ba33 ca95eabe e35bcd06 a8b7791d 442aed73 f2b15283
    68107064 91d73e6b f9f75d9d 14439b6e 97459881 47d12dcb ddbb72d7 4c3f71aa
    e240f254 39bc16ee cf7cecba db3f6c2a b316b186 129dae93 34d5b8d5 d0f73ea9
  Validity  until 
  Issuer is OU=Class 1 Public Primary Certification Authority, O="VeriSign,
Inc.", C=US
  Issuer signature used [MD2withRSA]
  Serial number =     521f351d f2707e00 2bbeca59 8704d539 
]</pre>
</blockquote>

<p>Servers are free to provide whatever attributes they choose, or even
no attributes at all. The only rules are that attribute names should
follow the same convention as package names, with the package names
<tt class="literal">java.*</tt><a name="INDEX-891"></a><a name="INDEX-892"></a>
and <tt class="literal">javax.*</tt><a name="INDEX-893"></a><a name="INDEX-894"></a>
reserved for use by the Java Software division of Sun Microsystems
(formerly known as JavaSoft) and
<tt class="literal">com.sun.*</tt><a name="INDEX-895"></a><a name="INDEX-896"></a>
reserved for use by Sun Microsystems. You should see your
server's documentation for a list of its attributes. There is
no <tt class="literal">getAttributeNames()</tt> method to help.
</p>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch04_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch04_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch05_01.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">4.3. The Client</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">5. Sending HTML Information</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
