<html>
<head>
<title>The JDBC API (Java Servlet Programming)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Jason Hunter and William Crawford">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-391-XE" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="The JDBC API">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm" alt="Java Servlet Programming"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch09_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch09_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch09_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch09_01.htm">Chapter 9: Database Connectivity</a></td><td align="right" valign="top" width="172"><a href="ch09_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch09_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">9.2. The JDBC API</h2>

<p>Previously, we've assumed that you have a general working
knowledge of the various Java APIs. Because even experienced Java
programmers may have had relatively little experience with databases,
this section provides a general introduction to JDBC. If this is your
first foray into the world of databases, we strongly recommend that
you take a breather and find a book on general database and JDBC
concepts. You may want to read <em class="emphasis">Database Programming with
JDBC and Java, </em><a name="INDEX-1577"></a><a name="INDEX-1578"></a>by George Reese
(O'Reilly), or<em class="emphasis"></em><em class="citetitle">JDBC Database
Access with Java</em><a name="INDEX-1579"></a><a name="INDEX-1580"></a>, by Graham Hamilton, Rick Cattell,
and Maydene Fisher (Addison-Wesley). The official JDBC specification
is also available online at <a href="../../../../../../../java.sun.com/products/jdbc">http://java.sun.com/products/jdbc</a><a name="INDEX-1581"></a><a name="INDEX-1582"></a>.
</p>

<p>
<a name="INDEX-1583"></a>JDBC is a SQL-level
<a name="INDEX-1584"></a><a name="INDEX-1585"></a><a name="INDEX-1586"></a>
API--one that allows you to execute SQL statements and retrieve
the results, if any. The API itself is a set of interfaces and
classes designed to perform actions against any database. <a href="#ch09-13020">Figure 9-2</a> shows how JDBC programs interact with
databases.
</p>

<a name="ch09-13020"></a>
<div class="figure">
<img alt="figure" src="figs/jsp_0902.gif" webstripperlinkwas="figs/jsp_0902.gif"></div>
<h4 class="objtitle">Figure 9-2. Java and the database</h4>

<a name="ch09-3-fm2xml"></a>
<h3 class="sect2">9.2.1. JDBC Drivers</h3>

<p>The JDBC API, found in the <tt class="literal">java.sql</tt> package,
contains only a few concrete classes. Much of the API is distributed
as database-neutral interface classes that specify behavior without
providing any implementation. The actual implementations are provided
by third-party vendors.
</p>

<p>An individual database system is accessed via a specific JDBC driver
that implements the <tt class="literal">java.sql.Driver</tt> interface.
Drivers exist for nearly all popular RDBMS systems, though few are
available for free. Sun bundles a free JDBC-ODBC bridge driver with
the JDK to allow access to standard ODBC data sources, such as a
Microsoft Access database. However, Sun advises against using the
bridge driver for anything other than development and very limited
deployment. Servlet developers in particular should heed this warning
because any problem in the JDBC-ODBC bridge driver's native
code section can crash the entire server, not just your servlets.
</p>

<p>JDBC drivers are available for most database platforms, from a number
of vendors and in a number of different flavors. There are four
driver categories:
</p>

<dl>
<dt>
<b>Type 1-<a name="INDEX-1587"></a>
<a name="INDEX-1588"></a>
JDBC-ODBC Bridge Driver</b>
</dt>
<dd>
<p>Type 1 drivers use a bridge technology to connect a Java client to an
ODBC database service. Sun's JDBC-ODBC bridge is the most
common Type 1 driver. These drivers are implemented using native
code.
</p>
</dd>

<dt>
<b>Type 2-<a name="INDEX-1589"></a>
Native-API Partly-Java Driver</b>
</dt>
<dd>
<p>Type 2 drivers wrap a thin layer of Java around database-specific
native code libraries. For Oracle databases, the native code
libraries might be based on the <a name="INDEX-1590"></a>OCI (<a name="INDEX-1591"></a>Oracle Call Interface)
libraries, which were originally designed for C/C++ programmers.
Because Type 2 drivers are implemented using native code, in some
cases they have better performance than their all-Java counterparts.
They add an element of risk, however, because a defect in a
driver's native code section can crash the entire server.
</p>
</dd>

<dt>
<b>Type 3-<a name="INDEX-1592"></a>
Net-Protocol All-Java Driver</b>
</dt>
<dd>
<p>Type 3 drivers communicate via a generic network protocol to a piece
of custom middleware. The middleware component might use any type of
driver to provide the actual database access. WebLogic's
<a name="INDEX-1593"></a><a name="INDEX-1594"></a><a name="INDEX-1595"></a>Tengah
product line is an example. These drivers are all Java, which makes
them useful for applet deployment and safe for servlet deployment.
</p>
</dd>

<dt>
<b>Type 4-<a name="INDEX-1596"></a>
Native-Protocol All-Java Driver</b>
</dt>
<dd>
<p>Type 4 drivers are the most direct of the lot. Written entirely in
Java, Type 4 drivers understand database-specific networking
protocols and can access the database directly without any additional
software.
</p>
</dd>

</dl>

<p>A list of currently available JDBC drivers can be found at
<a href="../../../../../../../java.sun.com/products/jdbc/jdbc.drivers.html">http://java.sun.com/products/jdbc/jdbc.drivers.html</a><a name="INDEX-1597"></a><a name="INDEX-1598"></a>
.
</p>


<a name="ch09-4-fm2xml"></a>
<h3 class="sect2">9.2.2. Getting a Connection</h3>

<p>The first step in using a JDBC driver to get a database
<a name="INDEX-1599"></a><a name="INDEX-1600"></a><a name="INDEX-1601"></a><a name="INDEX-1602"></a>
connection involves loading the specific driver class into the
application's JVM. This makes the driver available later, when
we need it for opening the connection. An easy way to
<a name="INDEX-1603"></a>
load the driver class is to use the
<tt class="literal">Class.forName()</tt><a name="INDEX-1604"></a><a name="INDEX-1605"></a>
method:
</p>

<blockquote>
<pre class="programlisting">Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");</pre>
</blockquote>

<p>When the driver is loaded into memory, it registers itself with the
<tt class="literal">java.sql.DriverManager</tt> class as an available
database driver.
</p>

<p>The next step is to ask the <tt class="literal">DriverManager</tt> class to
open a connection to a given database, where the database is
specified by a specially formatted URL. The method used to open the
connection is
<tt class="literal">DriverManager.getConnection()</tt><a name="INDEX-1606"></a><a name="INDEX-1607"></a>
. It returns a class that implements the
<tt class="literal">java.sql.Connection</tt> interface:
</p>

<blockquote>
<pre class="programlisting">Connection con =
  DriverManager.getConnection("jdbc:odbc:somedb", "user", "passwd");</pre>
</blockquote>

<p>A JDBC URL identifies an individual database in a driver-specific
manner. Different drivers may need different information in the URL
to specify the host database. JDBC URLs usually begin with
<em class="emphasis">jdbc:subprotocol:subname</em>.
For example, the Oracle JDBC-Thin driver uses a URL of the form of
<a href="../../../../../../../ext.rlab.cs.nyu.edu/~jsr/oreilly/WebStripper/protected.html">jdbc:oracle:thin:</a><em class="emphasis">@dbhost</em><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/">:</a><em class="emphasis">port</em>:<em class="emphasis">sid;</em><tt class="command">
</tt>the JDBC-ODBC bridge uses <a href="../../../../../../../ext.rlab.cs.nyu.edu/~jsr/oreilly/WebStripper/protected.html">jdbc:odbc:</a><em class="emphasis">data- sourcename
</em>;<em class="emphasis">odbcoptions</em>.
</p>

<p>During the call to
<tt class="literal">getConnection()</tt><a name="INDEX-1608"></a><a name="INDEX-1609"></a>
, the <tt class="literal">DriverManager </tt>object asks each registered
driver if it recognizes the URL. If a driver says yes, the driver
manager uses that driver to create the <tt class="literal">Connection</tt>
object. Here is a snippet of code a servlet might use to load its
database driver with the JDBC-ODBC bridge and create an initial
connection:
</p>

<blockquote>
<pre class="programlisting">Connection con = null;
try {
  // Load (and therefore register) the JDBC-ODBC Bridge
  // Might throw a ClassNotFoundException
  Class.forName("sun.jdbc.odbc.JdbcOdbcDriver"); 
     
  // Get a connection to the database
  // Might throw an SQLException
  con = DriverManager.getConnection("jdbc:odbc:somedb", "user", "passwd");
     
  // The rest of the code goes here.
}
catch (ClassNotFoundException e) {
  // Handle an error loading the driver
}
catch (SQLException e) {
  // Handle an error getting the connection
}
finally {
  // Close the Connection to release the database resources immediately.
  try {
    if (con != null) con.close();
  }
  catch (SQLException ignored) { }
} </pre>
</blockquote>

<a name="INDEX-1610"></a>


<a name="ch09-5-fm2xml"></a>
<h3 class="sect2">9.2.3. Executing SQL Queries</h3>

<p>To really use a database, we need to have some way to
<a name="INDEX-1611"></a><a name="INDEX-1612"></a><a name="INDEX-1613"></a>execute queries. The simplest way
to execute a query is to use the<tt class="literal"> java.sql.Statement
</tt><a name="INDEX-1614"></a><a name="INDEX-1615"></a>
class. <tt class="literal">Statement</tt> objects are never instantiated
directly; instead, a program calls the
<tt class="literal">createStatement()</tt> method of
<tt class="literal">Connection</tt> to obtain a new
<tt class="literal">Statement</tt> object:
</p>

<blockquote>
<pre class="programlisting">Statement stmt = con.createStatement();</pre>
</blockquote>

<p>A query that returns data can be executed using the
<tt class="literal">executeQuery()</tt><a name="INDEX-1616"></a><a name="INDEX-1617"></a><a name="INDEX-1618"></a>
method of <tt class="literal">Statement</tt>. This method executes the
statement and returns a <tt class="literal">java.sql.ResultSet</tt> that
encapsulates the retrieved data:
</p>

<blockquote>
<pre class="programlisting">ResultSet rs = stmt.executeQuery("SELECT * FROM CUSTOMERS");</pre>
</blockquote>

<p>You can think of a <tt class="literal">ResultSet</tt> object as a
representation of the query result returned one row at a time. You
use the <tt class="literal">next()</tt><a name="INDEX-1619"></a><a name="INDEX-1620"></a><a name="INDEX-1621"></a>method of
<tt class="literal">ResultSet</tt> to move from row to row. The
<tt class="literal">ResultSet</tt> interface also boasts a multitude of
methods designed for retrieving data from the current row. The
<tt class="literal">getString()</tt><a name="INDEX-1622"></a><a name="INDEX-1623"></a><a name="INDEX-1624"></a>and
<tt class="literal">getObject()</tt><a name="INDEX-1625"></a><a name="INDEX-1626"></a><a name="INDEX-1627"></a>methods
are among the most frequently used for retrieving column values:
</p>

<blockquote>
<pre class="programlisting">while(rs.next()) {
  String event = rs.getString("event");
  Object count = (Integer) rs.getObject("count");  
} </pre>
</blockquote>

<p>You should know that the <tt class="literal">ResultSet</tt> is linked to
its parent <tt class="literal">Statement</tt>. Therefore, if a
<tt class="literal">Statement</tt> is closed or used to execute another
query, any related <tt class="literal">ResultSet</tt> objects are closed
automatically.
</p>

<p>
<a href="#ch09-13266">Example 9-1</a> shows a very simple servlet that uses
the <a name="INDEX-1628"></a>Oracle JDBC driver to perform a simple
query, printing names and phone numbers for all employees listed in a
database table. We assume that the database contains a table named
<tt class="literal">EMPLOYEES</tt>, with at least two fields, <tt class="literal">NAME
</tt> and <tt class="literal">PHONE</tt>.
</p>

<a name="ch09-13266"></a>
<div class="example">
<h4 class="objtitle">Example 9-1. A JDBC-enabled servlet </h4>
<blockquote>
<pre class="programlisting">import java.io.*;
import java.sql.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class DBPhoneLookup extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res)
                               throws ServletException, IOException {
    Connection con = null;
    Statement stmt = null;
    ResultSet rs = null;

    res.setContentType("text/html");
    PrintWriter out = res.getWriter(); 

    try {
      // Load (and therefore register) the Oracle Driver
      Class.forName("oracle.jdbc.driver.OracleDriver"); 
     
      // Get a Connection to the database
      con = DriverManager.getConnection(
        "jdbc:oracle:thin:@dbhost:1528:ORCL", "user", "passwd");
     
      // Create a Statement object
      stmt = con.createStatement();
     
      // Execute an SQL query, get a ResultSet
      rs = stmt.executeQuery("SELECT NAME, PHONE FROM EMPLOYEES");
     
      // Display the result set as a list
      out.println("&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Phonebook&lt;/TITLE&gt;&lt;/HEAD&gt;");
      out.println("&lt;BODY&gt;");
      out.println("&lt;UL&gt;");
      while(rs.next()) {
        out.println("&lt;LI&gt;" + rs.getString("name") + " " + rs.getString("phone"));  
      } 
      out.println("&lt;/UL&gt;");
      out.println("&lt;/BODY&gt;&lt;/HTML&gt;");
    }
    catch(ClassNotFoundException e) { 
      out.println("Couldn't load database driver: " + e.getMessage());
    }
    catch(SQLException e) { 
      out.println("SQLException caught: " + e.getMessage());
    }
    finally {
      // Always close the database connection.
      try {
        if (con != null) con.close();
      }
      catch (SQLException ignored) { }
    }
  }
}</pre>
</blockquote>
</div>

<p>This is about as simple a database servlet as you are likely to see.
All <tt class="literal">DBPhoneLookup</tt> does is connect to the database,
run a query that retrieves the names and phone numbers of everyone in
the employees table, and display the list to the user.
</p>


<a name="ch09-6-fm2xml"></a>
<h3 class="sect2">9.2.4. Handling SQL Exceptions</h3>

<p>
<tt class="literal">DBPhoneLookup</tt> encloses most of its code in a
<tt class="literal">try</tt>/<tt class="literal">catch</tt> block. This block
catches two exceptions: <tt class="literal">ClassNotFoundException</tt> and
<tt class="literal">SQLException</tt><a name="INDEX-1629"></a>
. The former is thrown by the <tt class="literal">Class.forName()</tt>
method when the JDBC driver class can not be loaded. The latter is
thrown by any JDBC method that has a problem.
<tt class="literal">SQLException</tt> objects are just like any other
exception type, with the additional feature that they can chain. The
<tt class="literal">SQLException</tt> class defines an extra method,
<tt class="literal">getNextException()</tt>, that allows the exception to
encapsulate additional <tt class="literal">Exception</tt> objects. We
didn't bother with this feature in the previous example, but
here's how to use it:
</p>

<blockquote>
<pre class="programlisting">catch (SQLException e) {
  out.println(e.getMessage());
  while((e = e.getNextException()) != null) {
    out.println(e.getMessage());
  }
}</pre>
</blockquote>

<p>This code displays the message from the first exception and then
loops through all the remaining exceptions, outputting the error
message associated with each one. In practice, the first exception
will generally include the most relevant information.
</p>


<a name="ch09-7-fm2xml"></a>
<h3 class="sect2">9.2.5. Result Sets in Detail</h3>

<p>Before we continue, we should take a closer look at the
<tt class="literal">ResultSet</tt> interface and the related
<tt class="literal">ResultSetMetaData</tt> interface. In <a href="#ch09-13266">Example 9-1</a>, we knew what our
<a name="INDEX-1630"></a><a name="INDEX-1631"></a>query looked like, and we knew what we
expected to get back, so we formatted the output appropriately. But,
if we want to display the results of a query in an HTML table, it
would nice to have some Java code that builds the table automatically
from the <tt class="literal">ResultSet</tt> rather than having to write the
same loop-and-display code over and over. As an added bonus, this
kind of code makes it possible to change the contents of the table
simply by changing the query.
</p>

<p>The <tt class="literal">ResultSetMetaData</tt> interface provides a way for
a program to learn about the underlying structure of a query result
on the fly. We can use it to build an object that dynamically
generates an HTML table from a <tt class="literal">ResultSet</tt>, as shown
in <a href="#ch09-23970">Example 9-2</a>. Many Java HTML generation tools
(such as WebLogic's
<a name="INDEX-1632"></a><a name="INDEX-1633"></a>htmlKona toolkit discussed in
<a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch05_01.htm">Chapter 5, "Sending HTML Information"</a>) have a similar capability.
</p>

<a name="ch09-23970"></a>
<div class="example">
<h4 class="objtitle">Example 9-2. A class to generate an HTML table from a ResultSet using ResultSetMetaData </h4>
<blockquote>
<pre class="programlisting">import java.sql.*;

public class HtmlResultSet {

  private ResultSet rs;

  public HtmlResultSet(ResultSet rs) {
    this.rs = rs;
  }

  public String toString() {  // can be called at most once
    StringBuffer out = new StringBuffer();
    // Start a table to display the result set
    out.append("&lt;TABLE&gt;\n");

    try {
      ResultSetMetaData rsmd = rs.getMetaData();

      int numcols = rsmd.getColumnCount();
		
      // Title the table with the result set's column labels
      out.append("&lt;TR&gt;");
      for (int i = 1; i &lt;= numcols; i++) {
        out.append("&lt;TH&gt;" + rsmd.getColumnLabel(i));
      }
      out.append("&lt;/TR&gt;\n");

      while(rs.next()) {
        out.append("&lt;TR&gt;"); // start a new row
        for (int i = 1; i &lt;= numcols; i++) {
          out.append("&lt;TD&gt;"); // start a new data element
          Object obj = rs.getObject(i);
          if (obj != null)
            out.append(obj.toString());
          else
            out.append("&amp;nbsp;");
        } 
        out.append("&lt;/TR&gt;\n");
      }

      // End the table
      out.append("&lt;/TABLE&gt;\n");
    }
    catch (SQLException e) {
      out.append("&lt;/TABLE&gt;&lt;H1&gt;ERROR:&lt;/H1&gt; " + e.getMessage() + "\n");
    }       
		
    return out.toString();
  }
}</pre>
</blockquote>
</div>

<p>This example shows how to use two basic methods of
<tt class="literal">ResultSetMetaData</tt>:
<tt class="literal">getColumnCount()</tt><a name="INDEX-1634"></a><a name="INDEX-1635"></a><a name="INDEX-1636"></a>and
<tt class="literal">getColumnLabel()</tt><a name="INDEX-1637"></a><a name="INDEX-1638"></a><a name="INDEX-1639"></a>.
The first returns the number of columns in the
<tt class="literal">ResultSet</tt>, while the second retrieves the name of
a particular column in a result set based on its numerical index.
<a name="INDEX-1640"></a><a name="INDEX-1641"></a>Indexes in <tt class="literal">ResultSet</tt>
objects follow the RDBMS standard rather than the C++/Java standard,
which means they are numbered from <tt class="literal">1</tt> to
<tt class="literal">n</tt> rather than from <tt class="literal">0</tt> to
<tt class="literal">n-1</tt>.
</p>

<p>This example also uses the <tt class="literal">getObject()</tt> method of
<tt class="literal">ResultSet</tt> to retrieve the value of each column.
All of the
<tt class="literal">get</tt><em class="replaceable">XXX</em><tt class="literal">()</tt>
methods work with column indexes as well as with column names.
Accessing data this way is more efficient, and, with well-written
SQL, is more portable. Here we use
<tt class="literal">getObject().toString()</tt> instead of
<tt class="literal">getString()</tt> to simplify the handling of
<tt class="literal">null</tt> values, as discussed in the next section.
</p>

<p>
<a href="#ch09-22421">Table 9-1</a> shows the
<a name="INDEX-1642"></a><a name="INDEX-1643"></a><a name="INDEX-1644"></a>Java methods you can use to retrieve some
common SQL data types from a database. No matter what the type, you
can always use the <tt class="literal">getObject() </tt>method of<tt class="literal">
ResultSet</tt>, in which case the type of the object returned is
shown in the second column. You can also use a specific
<tt class="literal">get</tt><em class="replaceable">XXX</em><tt class="literal">()</tt>
method. These methods are shown in the third column, along with the
Java data types they return. Remember that supported SQL data types
vary from database to database.
</p>

<a name="ch09-22421"></a>
<h4 class="objtitle">Table 9-1. Methods to Retrieve Data from a ResultSet </h4>
<table border="1">




<tr>
<th>
<p>SQL Data Type</p>
</th>
<th>
<p>Java Type Returned by getObject()</p>
</th>
<th>
<p>Recommended Alternative to getObject()</p>
</th>
</tr>


<tr>
<td>
<p>
<tt class="literal">CHAR</tt>
</p>
</td>
<td>
<p>
<tt class="literal">String</tt>
</p>
</td>
<td>
<p>
<tt class="literal">String getString()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">VARCHAR</tt>
</p>
</td>
<td>
<p>
<tt class="literal">String</tt>
</p>
</td>
<td>
<p>
<tt class="literal">String getString()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">LONGVARCHAR</tt>
</p>
</td>
<td>
<p>
<tt class="literal">String</tt>
</p>
</td>
<td>
<p>
<tt class="literal">InputStream getAsciiStream() InputStream getUnicodeStream()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">NUMERIC</tt>
</p>
</td>
<td>
<p>
<tt class="literal">java.math.BigDecimal</tt>
</p>
</td>
<td>
<p>
<tt class="literal">java.math.BigDecimal getBigDecimal()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">DECIMAL</tt>
</p>
</td>
<td>
<p>
<tt class="literal">java.math.BigDecimal</tt>
</p>
</td>
<td>
<p>
<tt class="literal">java.math.BigDecimal getBigDecimal()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">BIT</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Boolean</tt>
</p>
</td>
<td>
<p>
<tt class="literal">boolean getBoolean()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">TINYINT</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Integer</tt>
</p>
</td>
<td>
<p>
<tt class="literal">byte getByte()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SMALLINT</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Integer</tt>
</p>
</td>
<td>
<p>
<tt class="literal">short getShort()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">INTEGER</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Integer</tt>
</p>
</td>
<td>
<p>
<tt class="literal">int getInt()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">BIGINT</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Long</tt>
</p>
</td>
<td>
<p>
<tt class="literal">long getLong()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">REAL</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Float</tt>
</p>
</td>
<td>
<p>
<tt class="literal">float getFloat()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">FLOAT</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Double</tt>
</p>
</td>
<td>
<p>
<tt class="literal">double getDouble()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">DOUBLE</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Double</tt>
</p>
</td>
<td>
<p>
<tt class="literal">double getDouble()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">BINARY</tt>
</p>
</td>
<td>
<p>
<tt class="literal">byte[]</tt>
</p>
</td>
<td>
<p>
<tt class="literal">byte[] getBytes()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">VARBINARY</tt>
</p>
</td>
<td>
<p>
<tt class="literal">byte[]</tt>
</p>
</td>
<td>
<p>
<tt class="literal">byte[] getBytes()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">LONGVARBINARY</tt>
</p>
</td>
<td>
<p>
<tt class="literal">byte[]</tt>
</p>
</td>
<td>
<p>
<tt class="literal">getBinaryStream()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">DATE</tt>
</p>
</td>
<td>
<p>
<tt class="literal">java.sql.Date</tt>
</p>
</td>
<td>
<p>
<tt class="literal">java.sql.Date getDate()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">TIME</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Java.sql.Time</tt>
</p>
</td>
<td>
<p>
<tt class="literal">java.sql.Time getTime()</tt>
</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">TIMESTAMP</tt>
</p>
</td>
<td>
<p>
<tt class="literal">Java.sql.Timestamp</tt>
</p>
</td>
<td>
<p>
<tt class="literal">java.sql.Timestamp getTimestamp()</tt>
</p>
</td>
</tr>

</table>


<a name="ch09-8-fm2xml"></a>
<h3 class="sect2">9.2.6. Handling Null Fields</h3>

<p>Handling <tt class="literal">null</tt><a name="INDEX-1645"></a><a name="INDEX-1646"></a>database values with JDBC can be a
little tricky. (A database field can be set to
<tt class="literal">null</tt> to indicate that no value is present, in much
the same way that a Java object can be set to
<tt class="literal">null</tt>.) A method that doesn't return an
object, like <tt class="literal">getInt()</tt>, has no way of indicating
whether a column is <tt class="literal">null</tt> or whether it contains
actual information. (Some drivers return a string that contains the
text <tt class="literal">"null"</tt> when <tt class="literal">getString()</tt> is
called on a <tt class="literal">null</tt> column!) Any special value like
-1, might be a legitimate value. Therefore, JDBC includes the
<tt class="literal">wasNull()</tt> method in <tt class="literal">ResultSet</tt>,
which returns <tt class="literal">true</tt> or <tt class="literal">false</tt>
depending on whether the last column read was a true database
<tt class="literal">null</tt>. This means that you must read data from the
<tt class="literal">ResultSet</tt> into a variable, call
<tt class="literal">wasNull()</tt>, and proceed accordingly. It's not
pretty, but it works. Here's an example:
</p>

<blockquote>
<pre class="programlisting">int age = rs.getInt("age");
if (!rs.wasNull())
 out.println("Age: " + age); </pre>
</blockquote>

<p>Another way to check for <tt class="literal">null</tt> values is to use the
<tt class="literal">getObject()</tt> method. If a column is
<tt class="literal">null</tt>, <tt class="literal">getObject()</tt> always
returns <tt class="literal">null</tt>. Compare this to the
<tt class="literal">getString()</tt> method that has been known, in some
implementations, to return the empty string if a column is
<tt class="literal">null</tt>. Using <tt class="literal">getObject()
</tt>eliminates the need to call <tt class="literal">wasNull()</tt>
and leads to simpler code.
</p>


<a name="ch09-9-fm2xml"></a>
<h3 class="sect2">9.2.7. Updating the Database</h3>

<p>Most
<a name="INDEX-1647"></a><a name="INDEX-1648"></a><a name="INDEX-1649"></a>database-enabled web sites need to
do more than just perform queries. When a client submits an order or
provides some kind of information, the data needs to be entered into
the database. When you know you're executing a SQL
<tt class="literal">UPDATE</tt>, <tt class="literal">INSERT</tt>, or
<tt class="literal">DELETE </tt>statement and you know you don't
expect a <tt class="literal">ResultSet</tt>, you can use the
<tt class="literal">executeUpdate()</tt> method of
<tt class="literal">Statement</tt>. It returns a count that indicates the
number of rows modified by the statement. It's used like this:
</p>

<blockquote>
<pre class="programlisting">int count = 
  stmt.executeUpdate("DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = 5");</pre>
</blockquote>

<p>If you are executing SQL that may return either a
<tt class="literal">ResultSet</tt> or a count (say, if you're
handling user-submitted SQL or building generic data-handling
classes), use the generic <tt class="literal">execute()</tt> method of
<tt class="literal">Statement</tt>. It returns a <tt class="literal">boolean</tt>
whose value is <tt class="literal">true</tt> if the SQL statement produced
one or more <tt class="literal">ResultSet</tt> objects or
<tt class="literal">false</tt> if it resulted in an update count:
</p>

<blockquote>
<pre class="programlisting">boolean b = stmt.execute(sql);</pre>
</blockquote>

<p>The <tt class="literal">getResultSet()</tt><a name="INDEX-1650"></a><a name="INDEX-1651"></a><a name="INDEX-1652"></a>and
<tt class="literal">getUpdateCount()</tt><a name="INDEX-1653"></a><a name="INDEX-1654"></a><a name="INDEX-1655"></a>methods of <tt class="literal">Statement</tt>
provide access to the results of the <tt class="literal">execute()</tt>
method. <a href="#ch09-42048">Example 9-3</a> demonstrates the use of these
methods with a new version of <tt class="literal">HtmlResultSet</tt>, named
<tt class="literal">HtmlSQLResult</tt>, that creates an HTML table from any
kind of SQL statement.
</p>

<a name="ch09-42048"></a>
<div class="example">
<h4 class="objtitle">Example 9-3. A class to generate an HTML table from a ResultSet using the ResultSetMetaData </h4>
<blockquote>
<pre class="programlisting">import java.sql.*;

public class HtmlSQLResult {
  private String sql;
  private Connection con;

  public HtmlSQLResult(String sql, Connection con) {
    this.sql = sql;
    this.con = con;
  }

  public String toString() {  // can be called at most once
    StringBuffer out = new StringBuffer();

    // Uncomment the following line to display the SQL command at start of table
    // out.append("Results of SQL Statement: " + sql + "&lt;P&gt;\n");

    try {
      Statement stmt = con.createStatement();

      if (stmt.execute(sql)) { 
        // There's a ResultSet to be had
        ResultSet rs = stmt.getResultSet();    
        out.append("&lt;TABLE&gt;\n");

        ResultSetMetaData rsmd = rs.getMetaData();

        int numcols = rsmd.getColumnCount();
		
        // Title the table with the result set's column labels
        out.append("&lt;TR&gt;");
        for (int i = 1; i &lt;= numcols; i++)
          out.append("&lt;TH&gt;" + rsmd.getColumnLabel(i));
        out.append("&lt;/TR&gt;\n");

        while(rs.next()) {
          out.append("&lt;TR&gt;");  // start a new row
          for(int i = 1; i &lt;= numcols; i++) {
            out.append("&lt;TD&gt;");  // start a new data element
            Object obj = rs.getObject(i);
            if (obj != null)
              out.append(obj.toString());
            else
              out.append("&amp;nbsp;");
            }
          out.append("&lt;/TR&gt;\n");
        }

        // End the table
        out.append("&lt;/TABLE&gt;\n");
      }
      else {
        // There's a count to be had
        out.append("&lt;B&gt;Records Affected:&lt;/B&gt; " + stmt.getUpdateCount()); 
      }
    }
    catch (SQLException e) {
      out.append("&lt;/TABLE&gt;&lt;H1&gt;ERROR:&lt;/H1&gt; " + e.getMessage());
    }       
		
    return out.toString();
  }
}</pre>
</blockquote>
</div>

<p>This example uses <tt class="literal">execute()</tt> to execute whatever
SQL statement is passed to the <tt class="literal">HtmlSQLResult</tt>
constructor. Then, depending on the return value, it either calls
<tt class="literal">getResultSet()</tt> or
<tt class="literal">getUpdateCount()</tt>. Note that neither
<tt class="literal">getResultSet()</tt><a name="INDEX-1656"></a><a name="INDEX-1657"></a><a name="INDEX-1658"></a> nor
<tt class="literal">getUpdateCount()</tt><a name="INDEX-1659"></a><a name="INDEX-1660"></a><a name="INDEX-1661"></a> should be called more than once per
query.
</p>


<a name="ch09-10-fm2xml"></a>
<h3 class="sect2">9.2.8. Using Prepared Statements</h3>

<p>A <tt class="literal">PreparedStatement </tt><a name="INDEX-1662"></a><a name="INDEX-1663"></a>object is<tt class="literal"></tt>like a
regular <tt class="literal">Statement</tt> object, in that it can be used
to execute SQL statements. The important difference is that the SQL
in a <tt class="literal">PreparedStatement</tt> is precompiled by the
database for faster execution. Once a
<tt class="literal">PreparedStatement</tt> has been compiled, it can still
be customized by adjusting predefined parameters. Prepared statements
are useful in applications that have to run the same general SQL
command over and over.
</p>

<p>Use the
<tt class="literal">prepareStatement(String)</tt><a name="INDEX-1664"></a><a name="INDEX-1665"></a><a name="INDEX-1666"></a>
method of <tt class="literal">Connection</tt> to create
<tt class="literal">PreparedStatement</tt> objects. Use the
<tt class="literal">?</tt> character as a placeholder for values to be
substituted later. For example:
</p>

<blockquote>
<pre class="programlisting">PreparedStatement pstmt = con.prepareStatement(
  "INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, TOTAL) VALUES (?,?,?)");

// Other code

pstmt.clearParameters();   // clear any previous parameter values
pstmt.setInt(1, 2);        // set ORDER_ID
pstmt.setInt(2, 4);        // set CUSTOMER_ID
pstmt.setDouble(3, 53.43); // set TOTAL
pstmt.executeUpdate();     // execute the stored SQL</pre>
</blockquote>

<p>The
<tt class="literal">clearParameters()</tt><a name="INDEX-1667"></a><a name="INDEX-1668"></a>
method removes any previously defined parameter values, while the
<tt class="literal">set</tt><em class="replaceable">XXX</em><tt class="literal">()</tt>
methods are used to assign actual values to each of the placeholder
question marks. Once you have assigned values for all the parameters,
call
<tt class="literal">executeUpdate()</tt><a name="INDEX-1669"></a><a name="INDEX-1670"></a>
to execute the <tt class="literal">PreparedStatement</tt>.
</p>

<p>The <tt class="literal">PreparedStatement</tt> class has an important
application in conjunction with servlets. When loading user-submitted
text into the database using <tt class="literal">Statement</tt> objects and
dynamic SQL, you must be careful not to accidentally introduce any
<a name="INDEX-1671"></a>SQL control characters (such as
<tt class="literal">"</tt> or <tt class="literal">'</tt>) without escaping them
in the manner required by your database. With a database like Oracle
that surrounds strings with single quotes, an attempt to insert
<tt class="literal">"John d'Artagan"</tt> into the database results in this
corrupted SQL:
</p>

<blockquote>
<pre class="programlisting">INSERT INTO MUSKETEERS (NAME) VALUES ('John d'Artagan')</pre>
</blockquote>

<p>As you can see, the string terminates twice. One solution is to
manually replace the single quote <tt class="literal">'</tt> with two
single quotes <tt class="literal">''</tt>, the Oracle escape sequence for
one single quote. This solution, requires you to escape every
character that your database treats as special--not an easy task
and not consistent with writing platform-independent code. A far
better solution is to use a <tt class="literal">PreparedStatement</tt> and
pass the string using its<tt class="literal"> setString()</tt> method, as
shown below. The <tt class="literal">PreparedStatement</tt> automatically
escapes the string as necessary for your database:
<a name="INDEX-1672"></a><a name="INDEX-1673"></a>
</p>

<blockquote>
<pre class="programlisting">PreparedStatement pstmt = con.prepareStatement(
  "INSERT INTO MUSKETEERS (NAME) VALUES (?)");
pstmt.setString(1, "John d'Artagan");
pstmt.executeUpdate(); </pre>
</blockquote>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch09_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch09_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch09_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/ch09_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">9.1. Relational Databases</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">9.3. Reusing Database Objects</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
