<html>
<head>
<title>The Stateful Session Bean (Enterprise JavaBeans)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Richard Monson-Haefel">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-869-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="The Stateful Session Bean">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm" alt="Enterprise JavaBeans"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch07_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">Chapter 7: Session Beans</a></td><td align="right" valign="top" width="172"><a href="ch07_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_04.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">7.3. The Stateful Session Bean</h2>

<p>
<a name="INDEX-1432"></a>Stateful session beans offer an
alternative that lies between entity beans and stateless session
beans. Stateful session beans are dedicated to one client for the
life of the bean instance; a stateful session bean acts on behalf of
a client as its agent. They are not swapped among EJB objects or kept
in an instance pool like entity and stateless bean instances. Once a
stateful session bean is instantiated and assigned to an EJB object,
it is dedicated to that EJB object for its entire life
cycle.<a href="#FOOTNOTE-8">[8]</a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-8"></a>
<p>[8] This is a conceptual model. Some EJB
containers may actually use instance swapping with stateful session
beans but make it appear as if the same instance is servicing all
requests. Conceptually, however, the same stateful session bean
instance services all requests.</p> </blockquote>

<p>Stateful session beans maintain <a name="INDEX-1433"></a><a name="INDEX-1434"></a>conversational state, which means that
the instance variables of the bean class can cache data relative to
the client between method invocations. This makes it possible for
methods to be interdependent, so that changes made by methods to the
bean's state can affect the result of subsequent method
invocations. In contrast, the stateless session beans we have been
talking about do not maintain conversational state. Although
stateless beans may have instance variables, these fields are not
specific to one client. A stateless instance is swapped among many
EJB objects, so you can't predict which instance will service a
method call. With stateful session beans, every method call from a
client is serviced by the same instance (at least conceptually), so
the bean instance's state can be predicted from one method
invocation to the next.
</p>

<p>Although <a name="INDEX-1435"></a>stateful session beans maintain
conversational state, they are not themselves persistent like entity
beans. Entity beans represent data in the database; their persistent
fields are written directly to the database. Stateful session beans,
like stateless beans, can access the database but do not represent
data in the database. In addition, session beans are not used
<a name="INDEX-1436"></a>concurrently like
entity beans. If you have an entity EJB object that wraps an instance
of the ship called <em class="emphasis">Paradise</em>, for example, all
client requests for that ship will be coordinated through the same
EJB object.<a href="#FOOTNOTE-9">[9]</a> With session beans, the EJB object is
dedicated to one client--session beans are not used
concurrently.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-9"></a>
<p>[9] This is a conceptual model. Some EJB
containers may actually use separate EJB objects for concurrent
access to the same entity, relying on the database to control
concurrency. Conceptually, however, the end result is the
same.</p> </blockquote>

<p>Stateful session beans are often thought of as extensions of the
<a name="INDEX-1437"></a><a name="INDEX-1438"></a>client. This makes sense if you think
of a client as being made up of operations and state. Each task may
rely on some information gathered or changed by a previous operation.
A GUI client is a perfect example: when you fill in the fields on a
GUI client you are creating conversational state. Pressing a button
executes an operation that might fill in more fields, based on the
information you entered previously. The information in the fields is
<a name="INDEX-1439"></a>conversational state.
</p>

<p>Stateful session beans allow you to
<a name="INDEX-1440"></a>encapsulate the
<a name="INDEX-1441"></a>business logic and
the conversational state of a client and move it to the server.
Moving this logic to the server thins the client application and
makes the system as a whole easier to manage. The stateful session
bean acts as an agent for the client, managing processes or
<em class="emphasis">workflow</em><a name="INDEX-1442"></a> to accomplish a set of tasks; it manages
the interactions of other beans in addition to direct data access
over several operations to accomplish a complex set of tasks. By
encapsulating and managing workflow on behalf of the client, stateful
beans present a simplified interface that hides the details of many
interdependent operations on the database and other beans from the
client.
</p>

<a name="JBEANS-CH-7-SECT-3.1"></a>
<h3 class="sect2">7.3.1. The TravelAgent Bean</h3>

<p>The TravelAgent bean, which we have already seen, is a <a name="INDEX-1443"></a><a name="INDEX-1444"></a>stateful session bean that encapsulates
the process of making a reservation on a cruise. We will develop this
bean further to demonstrate how stateful session beans can be used as
workflow objects.
</p>

<a name="JBEANS-CH-7-SECT-3.1.1"></a>
<h3 class="sect3">7.3.1.1. TravelAgent: The remote interface</h3>

<p>
<a name="INDEX-1445"></a><a name="INDEX-1446"></a>In <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, we
developed an early version of the <tt class="literal">TravelAgent</tt>
interface that contained a single business method,
<tt class="literal">listCabins()</tt>. We are going to remove the
<tt class="literal">listCabins()</tt> method and redefine the TravelAgent
bean so that it behaves like a workflow object. Later in the chapter,
we will add a modified listing method for obtaining a more specific
list of cabins for the user.
</p>

<p>As a stateful session bean that models
<a name="INDEX-1447"></a>
workflow, TravelAgent manages the interactions of several other beans
while maintaining conversational state. The following code contains
the modified <tt class="literal">TravelAgent</tt> interface:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import java.rmi.RemoteException;
import javax.ejb.FinderException;
import com.titan.cruise.Cruise;
import com.titan.customer.Customer;
import com.titan.processpayment.CreditCard;

public interface <tt class="userinput"><b>TravelAgent</b></tt> extends javax.ejb.EJBObject {

    public void setCruiseID(int cruise) 
        throws RemoteException, FinderException;
    public int getCruiseID() throws RemoteException,
                                    IncompleteConversationalState;

    public void setCabinID(int cabin) 
        throws RemoteException, FinderException;
    public int getCabinID() throws RemoteException,
                                   IncompleteConversationalState;
    public int getCustomerID() throws RemoteException,
                                       IncompleteConversationalState;
    
    public Ticket bookPassage(CreditCard card, double price)
        throws RemoteException,IncompleteConversationalState;   
}</pre>
</blockquote>

<p>The purpose of the TravelAgent bean is to make cruise reservations.
To accomplish this task, the bean needs to know which cruise, cabin,
and customer make up the reservation. Therefore, the client using the
TravelAgent bean needs to gather this kind of information before
making the booking. The <tt class="literal">TravelAgent</tt> remote
interface provides methods for setting the IDs of the cruise and
cabin that the customer wants to book. We can assume that the cabin
ID came from a list and that the cruise ID came from some other
source. The customer is set in the <tt class="literal">create()</tt> method
of the home interface--more about this later.
</p>

<p>Once the customer, cruise, and cabin are chosen, the TravelAgent bean
is ready to process the reservation. This operation is performed by
the <tt class="literal">bookPassage()</tt> method, which needs the
customer's credit card information and the price of the cruise.
<tt class="literal">bookPassage()</tt> is responsible for charging the
customer's account, reserving the chosen cabin in the right
ship on the right cruise, and generating a ticket for the customer.
How this is accomplished is not important to us at this point; when
we are developing the remote interface, we are only concerned with
the business definition of the bean. We will discuss the
implementation when we talk about the bean class.
</p>

<p>
<a name="INDEX-1448"></a><a name="INDEX-1449"></a>
Like the <tt class="literal">CreditCard</tt> and <tt class="literal">Check</tt>
classes used in the ProcessPayment bean, the
<tt class="literal">Ticket</tt> class that <tt class="literal">bookPassage()</tt>
returns is defined as a pass-by-value object. It can be argued that a
ticket should be an entity bean since it is not dependent and may be
accessed outside the context of the TravelAgent bean. However,
determining how a business object is used can also dictate whether it
should be a bean or simply a class. The <tt class="literal">Ticket</tt>
object, for example, could be digitally signed and emailed to the
client as proof of purchase. This wouldn't be feasible if the
<tt class="literal">Ticket</tt> object had been an entity bean. Enterprise
beans are only referenced through their remote interfaces and are not
passed by value, as are serializable objects such as
<tt class="literal">Ticket</tt>, <tt class="literal">CreditCard</tt>, and
<tt class="literal">Check</tt>. As an exercise in pass-by-value, we define
the <tt class="literal">Ticket</tt> as a simple serializable object instead
of a bean:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import com.titan.cruise.Cruise;
import com.titan.cabin.Cabin;
import com.titan.customer.Customer;
import java.rmi.RemoteException;

public class Ticket implements java.io.Serializable {
    public int cruiseID;
    public int cabinID;
    public double price;
    public String description;
    
    public Ticket(Customer customer, Cruise cruise, Cabin cabin, double price)
            throws javax.ejb.FinderException, RemoteException,  
            javax.naming.NamingException {
        
       description = customer.getFirstName()+" "+customer.getMiddleName()+ 
           " " + customer.getLastName() + 
           " has been booked for the " + cruise.getName().trim() + 
           " cruise on ship " + cruise.getShipID() + ".\n" +  
           " Your accommodations include " + cabin.getName().trim() + 
           " a " + cabin.getBedCount() + 
           " bed cabin on deck level " + cabin.getDeckLevel() + 
           ".\n Total charge = " + price;
    }
        
    public String toString() {
        return description;
    }
}</pre>
</blockquote>

<p>
<a name="INDEX-1450"></a><a name="INDEX-1451"></a>Note that the
<tt class="literal">bookPassage()</tt> method throws an
application-specific exception, the
<tt class="literal">IncompleteConversationalState</tt>. This exception is
used to communicate business problems encountered while booking a
customer on a cruise. The
<tt class="literal">IncompleteConversationalState</tt> exception indicates
that the TravelAgent bean didn't have enough information to
process the booking. The
<tt class="literal">IncompleteConversationalState</tt><a name="INDEX-1452"></a> application exception class is
<a name="INDEX-1453"></a><a name="INDEX-1454"></a>
defined below:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

public class IncompleteConversationalState extends java.lang.Exception {
    public IncompleteConversationalState(){super();}
    public IncompleteConversationalState(String msg){super(msg);}
}</pre>
</blockquote>



<a name="JBEANS-CH-7-SECT-3.1.2"></a>
<h3 class="sect3">7.3.1.2. TravelAgentHome: The home interface</h3>

<p>
<a name="INDEX-1455"></a><a name="INDEX-1456"></a>Starting with the
<tt class="literal">TravelAgentHome</tt> interface that we developed in
<a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, we can modify the
<tt class="literal">create()</tt> method to take a remote reference to the
customer who is making the reservation:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import java.rmi.RemoteException;
import javax.ejb.CreateException;
import com.titan.customer.Customer;

public interface TravelAgentHome extends javax.ejb.EJBHome {

    public TravelAgent create(Customer cust)
        throws RemoteException, CreateException;
}</pre>
</blockquote>

<p>
<a name="INDEX-1457"></a>The
<tt class="literal">create()</tt> method in this home interface requires
that a remote reference to a Customer bean be used to create the
TravelAgent bean. Because there are no other
<tt class="literal">create()</tt> methods, you can't create a
TravelAgent bean if you don't know who the customer is. The
Customer bean reference provides the TravelAgent bean with some of
the conversational state it will need to process the
<tt class="literal">bookPassage()</tt> method.
</p>



<a name="JBEANS-CH-7-SECT-3.1.3"></a>
<h3 class="sect3">7.3.1.3. Taking a peek at the client view</h3>

<p>
<a name="INDEX-1458"></a>Before settling on definitions
for your remote interface and home interface, it is a good idea to
figure out how the bean will be used by clients. Imagine that the
TravelAgent bean is used by a Java <a name="INDEX-1459"></a>applet with GUI fields. The GUI
fields capture the customer's preference for the type of cruise
and cabin. We start by examining the code used at the beginning of
the reservation process:
</p>

<blockquote>
<pre class="programlisting">Context jndiContext = getInitialContext();
// EJB 1.0: Use native cast instead of narrow()
Object ref = jndiContext.lookup("CustomerHome");
CustomerHome customerHome =(CustomerHome)
    PortableRemoteObject.narrow(ref, CustomerHome.class);

String ln = tfLastName.getText();
String fn = tfFirstName.getText();
String mn = tfMiddleName.getText();
Customer customer = customerHome.create(nextID, ln, fn, mn); 

// EJB 1.0: Use native cast instead of narrow()
ref = jndiContext.lookup("TravelAgentHome");
TravelAgentHome home = (TravelAgentHome)
    PortableRemoteObject.narrow(ref, TravelAgentHome.class);

<b class="emphasis-bold">TravelAgent agent = home.create(customer);</b>
</pre>
</blockquote>

<p>This snippet of code creates a new Customer bean based on information
the travel agent gathered over the phone. The
<tt class="literal">Customer</tt> reference is then used to create a
TravelAgent bean. Next, we gather the cruise and cabin choices from
another part of the applet:
</p>

<blockquote>
<pre class="programlisting">int cruise_id = Integer.parseInt(textField_cruiseNumber.getText());
int cabin_id = Integer.parseInt(textField_cabinNumber.getText());
<b class="emphasis-bold">agent.setCruiseID(cruise_id);</b>
<b class="emphasis-bold">agent.setCabinID(cabin_id);</b>
</pre>
</blockquote>

<p>The user chooses the cruise and cabin that the customer wishes to
reserve. These IDs are set in the TravelAgent bean, which maintains
the conversational state for the whole process.
</p>

<p>At the end of the process, the travel agent completes the reservation
by processing the booking and generating a ticket. Because the
TravelAgent bean has maintained the conversational state, caching the
<tt class="literal">Customer</tt>, <tt class="literal">Cabin</tt>, and
<tt class="literal">Cruise</tt> information, only the credit card and price
are needed to complete the transaction:
</p>

<blockquote>
<pre class="programlisting">long cardNumber = Long.parseLong(textField_cardNumber.getText());
Date date = 
    dateFormatter.format(textField_cardExpiration.getText());
String cardBrand = textField_cardBrand.getText();
CreditCard <tt class="userinput"><b>card</b></tt> = new CreditCard(cardNumber,date,cardBrand);
double <tt class="userinput"><b>price</b></tt> =
    double.valueOf(textField_cruisePrice.getText()).doubleValue();
<em class="emphasis">Ticket ticket = agent.bookPassage(card,price);</em>
PrintingService.print(ticket);</pre>
</blockquote>

<p>We can now move ahead with development; this summary of how the
client will use the TravelAgent bean confirms that our remote
interface and home interface definitions are workable.
</p>



<a name="JBEANS-CH-7-SECT-3.1.4"></a>
<h3 class="sect3">7.3.1.4. TravelAgentBean: The bean class</h3>

<p>
<a name="INDEX-1460"></a><a name="INDEX-1461"></a>We now implement all the behavior
expressed in the new remote interface and home interface for the
TravelAgent bean. Here is a partial definition of the new
<tt class="literal">TravelAgentBean</tt>; the <tt class="literal">getHome()</tt>
method and, for EJB 1.0, the <tt class="literal">getJNDIContext()</tt>
method will be added as we go along:<a href="#FOOTNOTE-10">[10]</a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-10"></a>
<p>[10] If you're
modifying the bean developed in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>,
remember to delete the <tt class="literal">listCabin()</tt>method. We will
add a new implementation of that method later in this chapter.
</p> </blockquote>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import com.titan.cabin.*;
import com.titan.cruise.*;
import com.titan.customer.*;
import com.titan.processpayment.*;
import com.titan.reservation.*;

import java.sql.*;
import javax.sql.DataSource;
import java.util.Vector;
import java.rmi.RemoteException;
import javax.naming.NamingException;
import javax.ejb.EJBException;

public class TravelAgentBean implements javax.ejb.SessionBean {

    public Customer customer;
    public Cruise cruise;
    public Cabin cabin;

    public javax.ejb.SessionContext ejbContext;
    // EJB 1.0: jndiContext should be declared transient
    public javax.naming.Context jndiContext;

    public void ejbCreate(Customer cust) {
        customer = cust;
    }
    public int getCustomerID()
        throws IncompleteConversationalState {
        // EJB 1.0: also throws RemoteException
        try { // EJB 1.0: remove try/catch
            if (customer == null)
                throw new IncompleteConversationalState();
            return ((CustomerPK)customer.getPrimaryKey()).id;
        } catch(RemoteException re) {
            throw new EJBException(re);
        }
    }
    public int getCruiseID()
        throws IncompleteConversationalState {
        // EJB 1.0: also throws RemoteException
        try { // EJB 1.0: remove try/catch
            if (cruise == null)
                throw new IncompleteConversationalState();
            return ((CruisePK)cruise.getPrimaryKey()).id;
        } catch(RemoteException re) {
            throw new EJBException(re);
        }
        
    }
        
    public int getCabinID()
        throws IncompleteConversationalState {
        // EJB 1.0: also throws RemoteException
        try { // EJB 1.0: remove try/catch
            if (cabin==null)
                throw new IncompleteConversationalState();
            return ((CabinPK)cabin.getPrimaryKey()).id;
        } catch(RemoteException re) {
            throw new EJBException(re);
        }
    }
    public void setCabinID(int cabinID)
        throws javax.ejb.FinderException { // EJB 1.0: also throws RemoteException
        try { // EJB 1.0: remove try/catch
            CabinHome home = (CabinHome)getHome("CabinHome",CabinHome.class);
            CabinPK pk = new CabinPK();
            pk.id=cabinID;
            cabin = home.findByPrimaryKey(pk);
        } catch(RemoteException re) {
            throw new EJBException(re);
        }
    }
    public void setCruiseID(int cruiseID)
        throws javax.ejb.FinderException { // EJB 1.0: also throws RemoteException
        try { // EJB 1.0: remove try/catch
            CruiseHome home = (CruiseHome)getHome("CruiseHome", CruiseHome.class);
            cruise = home.findByPrimaryKey(new CruisePK(cruiseID));
        } catch(RemoteException re) {
            throw new EJBException(re);
        }
        
    }
    public Ticket bookPassage(CreditCard card, double price)
        throws IncompleteConversationalState {
        // EJB 1.0: also throws RemoteException
                    
        if (customer == null || cruise == null || cabin == null) {
            throw new IncompleteConversationalState();
        }
        try {
            ReservationHome resHome = (ReservationHome)
                getHome("ReservationHome",ReservationHome.class);
            Reservation reservation =
                resHome.create(customer, cruise, cabin, price);
            ProcessPaymentHome ppHome = (ProcessPaymentHome)
                getHome("ProcessPaymentHome",ProcessPaymentHome.class);
            ProcessPayment process = ppHome.create();
            process.byCredit(customer, card, price);

            Ticket ticket = new Ticket(customer,cruise,cabin,price);
            return ticket;
        } catch(Exception e) {
            // EJB 1.0: throw new RemoteException("",e);
            throw new EJBException(e);
        }
    }
    public void ejbRemove() {}
    public void ejbActivate() {}

    public void ejbPassivate() {
        /*
        EJB 1.0: Close the JNDI Context and set to null. 
        try {
            jndiContext.close();
        } catch(NamingException ne) {}
        jndiContext = null;
        */
    }
    public void setSessionContext(javax.ejb.SessionContext cntx) {
        // EJB 1.0: throws RemoteException
        ejbContext = cntx;
        try {
          jndiContext = new javax.naming.InitialContext();
        } catch(NamingException ne) {
            // EJB 1.0: throw new RemoteException("",ne);
            throw new EJBException(ne);
        }
    }
    protected Object getHome(String name, Class type)
    {// EJB 1.0: throws RemoteException
        // EJB 1.1 and EJB 1.0 specific implementations 
    }
} </pre>
</blockquote>

<p>
<a name="INDEX-1462"></a>
There is a lot of code to digest, so we will approach it in small
pieces. First, let's examine the
<tt class="literal">ejbCreate()</tt><a name="INDEX-1463"></a> method:
</p>

<blockquote>
<pre class="programlisting">public class TravelAgentBean implements javax.ejb.SessionBean {

    public Customer customer;
    public Cruise cruise;
    public Cabin cabin;

    public javax.ejb.SessionContext ejbContext;
    // EJB 1.0: jndiContext should be declared transient
    public javax.naming.Context jndiContext;

    public void ejbCreate(Customer cust) {
        customer = cust;
    }</pre>
</blockquote>

<p>When the bean is created, the remote reference to the Customer bean
is passed to the bean instance and maintained in the
<tt class="literal">customer</tt> field. The <tt class="literal">customer</tt>
field is part of the bean's conversational state. We could have
obtained the customer's identity as an integer ID and
constructed the remote reference to the Customer bean in the
<tt class="literal">ejbCreate()</tt> method. However, we passed the
reference directly to demonstrate that remote references to beans can
be passed from a client application to a bean. They can also be
returned from the bean to the client and passed between beans on the
same EJB server or between EJB servers.
</p>

<p>References to the <tt class="literal">SessionContext</tt> and JNDI context
are held in fields called <tt class="literal">ejbContext</tt> and
<tt class="literal">jndiContext</tt>. Prefixing the names of these context
types helps avoid confusion.
</p>

<dl>
<dt>
<b>EJB 1.1: the <a name="INDEX-1464"></a>
jndiContext</b>
</dt>
<dd>
<p>When a bean is passivated in EJB 1.1, the <a name="INDEX-1465"></a><a name="INDEX-1466"></a><a name="INDEX-1467"></a>JNDI ENC must be
maintained as part of the bean's conversational state. This
means that the JNDI context should not be
<tt class="literal">transient</tt>, as was the case in EJB 1.0. In EJB 1.1,
once a field is set to reference the JNDI ENC, the reference remains
valid for the life of the bean. In the
<tt class="literal">TravelAgentBean</tt>, we set the field
<tt class="literal">jndiContext</tt> to reference the JNDI ENC when the
<tt class="literal">SessionContext</tt> is set a the beginning of the
bean's life cycle:
</p>

<blockquote>
<pre class="programlisting">public void setSessionContext(javax.ejb.SessionContext cntx) {
    // EJB 1.0: throws RemoteException
    ejbContext = cntx;
    try {
        jndiContext = new InitialContext();
    } catch(NamingException ne) {
        // EJB 1.0: throw new RemoteException("",ne);
        throw new EJBException(ne);
    }
}</pre>
</blockquote>

<p>EJB 1.1 makes special accommodations for references
to <tt class="literal">SessionContext</tt>, the JNDI ENC, references to
other beans (remote and home interface types) and the JTA
<tt class="literal">UserTransaction</tt> type, which is discussed in detail
in <a href="ch08_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch08_01.htm">Chapter 8, "Transactions"</a>. The container must maintain any
instance fields that reference objects of these types as part of the
conversational state, even if they are not serializable. (In EJB 1.0,
references to most of these special types had to be closed or set to
<tt class="literal">null</tt> in the <tt class="literal">ejbPassivate()</tt>
method.) All other fields must be serializable or
<tt class="literal">null</tt> when the bean is passivated. </p>
<p>Open resources such as sockets or JDBC connections must be
closed whenever the bean is passivated. In stateful session beans,
open resources will not be maintained for the life of the bean
instance. When a stateful session bean is passivated, any open
resource can cause problems with the activation mechanism. </p>
</dd>


<dt>
<b>EJB 1.0: the <a name="INDEX-1468"></a>
jndiContext</b>
</dt>
<dd>
<p>In EJB 1.0, references to a JNDI context are not considered part of
the bean's <a name="INDEX-1469"></a>conversational state; the JNDI context is
an open resource that must be referenced by a
<tt class="literal">transient</tt> field and should be closed when the bean
is passivated. In the <tt class="literal">TravelAgentBean</tt>, the
<tt class="literal">jndiContext</tt> is obtained through the method
<tt class="literal">getJndiContext()</tt><a name="INDEX-1470"></a>:
</p>

<blockquote>
<pre class="programlisting">
<b class="emphasis-bold">protected javax.naming.Context getJndiContext()</b>
        <tt class="userinput"><b>throws javax.naming.NamingException {</b></tt>

        if (jndiContext != null)
            return jndiContext;
        
        // ... Specify the JNDI properties specific to the vendor.
    
        jndiContext = new InitialContext(p);
        return jndiContext; }</pre>
</blockquote>

<p>
<a name="INDEX-1471"></a><a name="INDEX-1472"></a>
The
<tt class="literal">InitialContext</tt><a name="INDEX-1473"></a>, obtained by the
<tt class="literal">getJndiContext()</tt> method, is saved in the instance
variable <tt class="literal">jndiContext</tt>. This reduces the number of
times the <tt class="literal">InitialContext</tt> needs to be
created.<a href="#FOOTNOTE-11">[11]</a> However, because the JNDI
context is an open resource, it must be closed whenever the bean is
<a name="INDEX-1474"></a>passivated. When a stateful session
bean is passivated, any open resource can cause problems with the
activation mechanism. <tt class="literal">TravelAgentBean</tt> uses the
<tt class="literal">ejbPassivate()</tt><a name="INDEX-1475"></a> notification method to close the
JNDI context and set the <tt class="literal">jndiContext</tt> variable to
<tt class="literal">null</tt>: </p>
<blockquote class="footnote"> <a name="FOOTNOTE-11"></a>
<p>[11] The advantage gained by maintaining the
connection will be marginal if the container calls
<tt class="literal">ejbPassivate()</tt> after every method call--which
some implementations do.</p> </blockquote>

<blockquote>
<pre class="programlisting">public void ejbPassivate() {
    try {
        jndiContext.close();
    } catch(NamingException ne) {}
    jndiContext = null;
}</pre>
</blockquote>
</dd>

</dl>

<p>The TravelAgent bean has methods for setting the desired cruise and
cabin. These methods take integer IDs as arguments and retrieve
references to the appropriate Cruise or Cabin bean from the
appropriate home interface. These references are also a part of the
TravelAgent bean's conversational state:
</p>

<blockquote>
<pre class="programlisting">public void setCabinID(int cabinID)
throws javax.ejb.FinderException { // EJB 1.0: also throws RemoteException
    try { // EJB 1.0: remove try/catch
        CabinHome home = (CabinHome)getHome("CabinHome",CabinHome.class);
        CabinPK pk = new CabinPK();
        pk.id=cabinID;
        cabin = home.findByPrimaryKey(pk);
    } catch(RemoteException re) {
        throw new EJBException(re);
    }
}
public void setCruiseID(int cruiseID)
throws javax.ejb.FinderException { // EJB 1.0: also throws RemoteException
    try { // EJB 1.0: remove try/catch
        CruiseHome home = (CruiseHome)getHome("CruiseHome", CruiseHome.class);
        cruise = home.findByPrimaryKey(new CruisePK(cruiseID));
    } catch(RemoteException re) {
        throw new EJBException(re);
    }
}</pre>
</blockquote>

<p>It may seem strange that we set these values using the integer IDs,
but we keep them in the conversational state as remote references.
Using the integer IDs for these objects is simpler for the client,
which doesn't work with their remote references. In the client
code, we got cabin and cruise IDs from text fields. Why make the
client obtain a remote reference to the Cruise and Cabin beans when
an ID is simpler? In addition, using the ID is cheaper than passing a
network reference in terms of network traffic. We need the EJB object
references to these bean types in the
<tt class="literal">bookPassage()</tt> method, so we use their IDs to
obtain actual remote references. We could have waited until the
<tt class="literal">bookPassage()</tt> method was invoked before
reconstructing the remote references, but this way we keep the
<tt class="literal">bookPassage()</tt> method simple.
</p>

<p>The method <tt class="literal">getHome()</tt>, used in both set methods, is
a convenience method defined in the
<tt class="literal">TravelAgentBean</tt>. It hides the details of obtaining
a remote reference to an EJB home object.
</p>

<dl>
<dt>
<b>EJB 1.1: accessing EJB references</b>
</dt>
<dd>
<p>In EJB 1.1, the JNDI ENC can be used to obtain a reference to the
home interface of other beans. Using the ENC lets you avoid
hardcoding vendor-specific JNDI properties into the bean--a
common problem in EJB 1.0. In other words, the
<a name="INDEX-1476"></a>JNDI ENC allows EJB
references to be network and vendor independent.
</p>

<p>In the <tt class="literal">TravelAgentBean</tt>, the
<tt class="literal">getHome()</tt><a name="INDEX-1477"></a> method uses the
<tt class="literal">jndiContext</tt> reference to obtain references to the
Cabin, Ship, ProcessPayment, and Cruise home objects:
</p>

<blockquote>
<pre class="programlisting">protected Object getHome(String name,Class type) {
    try {
        Object ref = jndiContext.lookup("java:comp/env/ejb/"+name);
        return PortableRemoteObject.narrow(ref, type);
    } catch(NamingException ne) {
        throw new EJBException(ne);
    }
}</pre>
</blockquote>

<p>EJB 1.1 recommends that all EJB references be bound to the
<tt class="literal">"java:comp/env/ejb"</tt> context, which is the
convention followed here. In the TravelAgent bean, we pass in the
name of the home object we want and append it to the
<tt class="literal">"java:comp/env/ejb"</tt> context to do the lookup.
</p>

<p>The <a name="INDEX-1478"></a><a name="INDEX-1479"></a>deployment descriptor provides a
special set of tags for declaring EJB references. Here's how
the <tt class="literal">&lt;ejb-ref&gt;</tt> tag and its subelements are
used:
</p>

<blockquote>
<pre class="programlisting">&lt;ejb-ref&gt;
    &lt;ejb-ref-name&gt;ejb/CabinHome&lt;/ejb-ref-name&gt;
    &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt;
    &lt;home&gt;com.titan.cabin.CabinHome&lt;/home&gt;
    &lt;remote&gt;com.titan.cabin.Cabin&lt;/remote&gt;
&lt;/ejb-ref&gt; </pre>
</blockquote>

<p>The <tt class="literal">&lt;ejb-ref&gt;</tt><a name="INDEX-1480"></a><a name="INDEX-1481"></a> tag and its subelements should be
self explanatory: they define a name for the bean within the ENC,
declare the bean's type, and give the names of its remote and
home interfaces. When a bean is deployed, the deployer maps the
<tt class="literal">&lt;ejb-ref&gt;</tt> elements to actual beans in a way
specific to the vendor. The <tt class="literal">&lt;ejb-ref&gt;</tt>
elements can also be linked by the application assembler to beans in
the same deployment (a subject covered in detail in <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch10_01.htm">Chapter 10, "XML Deployment Descriptors"</a>, which is about the XML deployment
descriptors).
</p>
</dd>


<dt>
<b>EJB 1.0: <a name="INDEX-1482"></a>
<a name="INDEX-1483"></a>
accessing EJB references</b>
</dt>
<dd>
<p>In EJB 1.0, beans access other beans in exactly the same way that
application clients access beans: you use JNDI to look up the
bean's home interface. To accomplish this, the JNDI
<tt class="literal">InitialContext</tt> must be created and initialized
with properties specific to the EJB vendor.
</p>

<p>The TravelAgent bean uses the <tt class="literal">getJndiContext()</tt>
method and the <tt class="literal">DeploymentDescriptor</tt> environment
properties to obtain references to other beans. The
<tt class="literal">getHome()</tt> method should be implemented as follows:
</p>
</dd>

</dl>

<blockquote>
<pre class="programlisting">
<b class="emphasis-bold">protected Object getHome(String name, Class type) throws RemoteException {</b>
<b class="emphasis-bold">    try {</b>
<b class="emphasis-bold">        String jndiName =</b>
<b class="emphasis-bold">            ejbContext.getEnvironment().getProperty(name);</b>
<b class="emphasis-bold">        return getJndiContext().lookup(jndiName);</b>
<b class="emphasis-bold">    } catch(NamingException ne) {</b>
<b class="emphasis-bold">        throw new RemoteException("Could not lookup ("+name+")",ne);</b>
<b class="emphasis-bold">    }</b>
<b class="emphasis-bold">}</b>
</pre>
</blockquote>

<p>The last point of interest in our bean definition is the
<tt class="literal">bookPassage()</tt> method. This method leverages the
conversational state accumulated by the
<tt class="literal">ejbCreate()</tt> method and the methods
(<tt class="literal">setCabinID()</tt>,<tt class="literal">setCruiseID()</tt>)
to process a reservation for a customer on a cruise:
</p>

<blockquote>
<pre class="programlisting">public Ticket bookPassage(CreditCard card, double price)
throws IncompleteConversationalState{// EJB 1.0: also throws RemoteException
                    
    if (customer == null || cruise == null || cabin == null) {
        throw new IncompleteConversationalState();
    }
    try {
        ReservationHome resHome =
            (ReservationHome) getHome("ReservationHome",ReservationHome.class);
        Reservation reservation =
            resHome.create(customer, cruise, cabin, price);
        ProcessPaymentHome ppHome = (ProcessPaymentHome)
            getHome("ProcessPaymentHome",ProcessPaymentHome.class);
        ProcessPayment process = ppHome.create();
        process.byCredit(customer, card, price);

        Ticket ticket = new Ticket(customer, cruise, cabin, price);
        return ticket;
    } catch(Exception e) {
        // EJB 1.0: throw new RemoteException("",e);
        throw new EJBException(e);
    }
}</pre>
</blockquote>

<p>
<a name="INDEX-1484"></a><a name="INDEX-1485"></a>This
method exemplifies the workflow concept. It uses several beans,
including the Reservation bean, the ProcessPayment bean, the Customer
bean, the Cabin bean, and the Cruise bean to accomplish one task:
book a customer on a cruise.Deceptively simple, this method
encapsulates several interactions that ordinarily might have been
performed on the client. For the price of one
<tt class="literal">bookPassage()</tt> call from the client, the
TravelAgent bean performs many operations:
</p>

<ol>
<li>
<p>Look up and obtain a remote reference to the Reservation bean's
EJB home.
</p>
</li>
<li>
<p>Create a new Reservation bean resulting in a database insert.</p>
</li>
<li>
<p>Look up and obtain a remote reference to the ProcessPayment
bean's EJB home.
</p>
</li>
<li>
<p>Create a new ProcessPayment bean.</p>
</li>
<li>
<p>Charge the customer's credit card using the ProcessPayment bean.</p>
</li>
<li>
<p>Generate a new <tt class="literal">Ticket</tt> with all the pertinent
information describing the customer's purchase.
</p>
</li>
</ol>
<p>From a design standpoint, encapsulating the workflow in a stateful
session bean means a less complex interface for the client and more
flexibility for implementing changes. We could, for example, easily
change the <tt class="literal">bookPassage()</tt> method to include a check
for overlapped booking (when a customer books passage on two
different cruises that overlap). If Titan's customers often
book passage on cruises that overlap, we could add logic to
<tt class="literal">bookPassage()</tt> to detect the problem. This type of
enhancement would not change the remote interface, so the client
application wouldn't need modification. Encapsulating workflow
in stateful session beans allows the system to evolve over time
without impacting clients.
</p>

<p>In addition, the type of clients used can change. One of the biggest
problems with two-tier architectures--besides scalability and
transactional control--is that the business logic is intertwined
with the client logic. This makes it difficult to reuse the business
logic in a different kind of client. With stateful session beans this
is not a problem, because stateful session beans are an extension of
the client but are not bound to the client's presentation.
Let's say that our first implementation of the reservation
system used a Java applet with GUI widgets. The TravelAgent bean
would manage conversational state and perform all the business logic
while the applet focused on the GUI presentation. If, at a later
date, we decide to go to a thin client (HTML generated by a Java
servlet, for example), we would simply reuse the TravelAgent bean in
the servlet. Because all the business logic is in the stateful
session bean, the presentation (Java applet or servlet or something
else) can change easily.
</p>

<p>The TravelAgent bean also provides transactional integrity for
processing the customer's reservation. As explained in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>, if any one of the operations within the body
of the <tt class="literal">bookPassage()</tt> method fails, all the
operations are rolled back so that none of the changes are accepted.
If the credit card can't be charged by the ProcessPayment bean,
the newly created Reservation bean and its associated record are
removed. The transactional aspects of the TravelAgent bean are
explained in <a name="INDEX-1486"></a><a name="INDEX-1487"></a> detail in <a href="ch08_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch08_01.htm">Chapter 8, "Transactions"</a>.
</p>



<a name="JBEANS-CH-7-SECT-3.1.5"></a>
<h3 class="sect3">7.3.1.5. Why use a Reservation entity bean?</h3>

<p>
<a name="INDEX-1488"></a><a name="INDEX-1489"></a>
Although the Reservation bean is an <a name="INDEX-1490"></a><a name="INDEX-1491"></a>entity bean, understanding its design and
purpose is important to understanding how and why it's used
within the TravelAgent bean. For this reason, we will depart
momentarily from our discussion of session beans, and the TravelAgent
bean in particular, to expand our understanding of the Reservation
bean. (The code for this bean is available on the O'Reilly web
site. See the preface for details.)
</p>

<p>The Reservation bean represents an immutable record in the database:
a reservation. It records an event in the history of the reservation
system. If you examine the Reservation bean closely, you will
discover that you cannot modify its contents once it is created. This
means it can't be changed, although it can be deleted. So why
make it an entity bean at all? Why not simply write records into the
database?
</p>

<p>Titan discovered that customers were averaging two calls to confirm
their reservations between the time they made the reservation and the
time they actually went on the trip. This is a lot of calls when you
consider that ships book 2,000 to 3,000 passengers each. Titan also
discovered that about 15% of its reservations are canceled. Canceling
a reservation means deleting a record, which can be tricky business.
In short, Titan was accessing reservation information a lot, mostly
to confirm data, but also to delete reservations for cancellations.
To provide consistent and safe access to reservation data, Titan
created a Reservation bean. This helped encapsulate the logic for
creating, reading, and deleting reservation data, so that it could be
reused in several different kinds of workflow. In addition to the
TravelAgent session, the ConfirmReservation and CancelReservation
beans also use the Reservation bean (we don't create bean types
like these in this book). These other stateful session beans have
different workflow and reuse the Reservation bean differently.
Encapsulating the reservation record as an entity bean ensures
consistent and safe access to sensitive data.
</p>

<p>Another advantage of the Reservation bean is that it can help prevent
double booking--when two different customers book the same cabin
on the same cruise. There is a gap between the time the customer
chooses a cabin and cruise and the time when
<tt class="literal">bookPassage()</tt> is invoked. During this time, some
other reservation agent could book the same cabin and cruise for a
different customer. To prevent a double booking, we can place a
unique index on the <tt class="literal">CABIN_ID</tt> and
<tt class="literal">CRUISE_ID</tt> in the <tt class="literal">RESERVATION</tt>
table. Any attempt to add a new record--by creating a
Reservation bean--with the same <tt class="literal">CABIN_ID</tt> and
<tt class="literal">CRUISE_ID</tt> will result in an
<tt class="literal">SQLException</tt>, effectively preventing a double
booking.
</p>

<p>
<a name="INDEX-1492"></a>EJB provides its own strategy for
handling <a name="INDEX-1493"></a>duplicate records through the
<tt class="literal">DuplicateKeyException</tt>. The
<tt class="literal">DuplicateKeyException</tt> is a type of
<tt class="literal">CreateException</tt> that is thrown by the
<a name="INDEX-1494"></a><tt class="literal">create()</tt> methods
of the home interfaces for entity beans if the bean cannot be created
because a bean with that same primary key already exists. The
Reservation bean's <a name="INDEX-1495"></a>primary key is defined as follows:
</p>

<blockquote>
<pre class="programlisting">package com.titan.reservation;
public class ReservationPK implements java.io.Serializable {

    public int cruiseID;
    public int cabinID;

    public ReservationPK(){}
    public ReservationPK(int crsID, int cbnID) {
        cruiseID = crsID;
        cabinID = cbnID;
    }
    ...// equals() &amp; hashCode() methods not shown
}</pre>
</blockquote>

<p>Notice that the <tt class="literal">cruiseID</tt> and
<tt class="literal">cabinID</tt> combination is used to define the
uniqueness of a Reservation entity. With
<a name="INDEX-1496"></a><a name="INDEX-1497"></a>container-managed
persistence, the <tt class="literal">DuplicateKeyException</tt> is thrown
automatically; with
<a name="INDEX-1498"></a>bean-managed persistence, we
need to capture the
<tt class="literal">SQLException</tt><a name="INDEX-1499"></a>
 resulting from the attempted insert and throw the
<tt class="literal">DuplicateKeyException</tt><a name="INDEX-1500"></a>
 explicitly. Either way, the <tt class="literal">DuplicateKeyException</tt>
causes the <tt class="literal">bookPassage()</tt> method to fail,
preventing the customer from double booking. In our example, we
capture the <tt class="literal">DuplicateKeyException</tt> and rethrow it
as a <tt class="literal">DoubleBookedException</tt>, which is more
understandable from the client's perspective.
</p>

<p>If we have a Reservation bean, why do we need a TravelAgent bean?
Good question! The TravelAgent bean uses the Reservation bean to
create a reservation, but it also has to charge the customer and
generate a ticket. These are not activities that are specific to the
Reservation bean, so they need to be captured in a stateful session
bean that can manage workflow and transactional scope. In addition,
the TravelAgent bean also provides listing behavior, which spans
concepts in Titan's system. It would have been inappropriate to
include any of these other behaviors in the Reservation entity bean.
</p>



<a name="JBEANS-CH-7-SECT-3.1.6"></a>
<h3 class="sect3">7.3.1.6. listAvailableCabins( ): Listing behavior</h3>

<p>
<a name="INDEX-1501"></a><a name="INDEX-1502"></a>As promised, we are going to bring back
the cabin-listing behavior we played around with in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>. This time, however, we are not going to use
the Cabin bean to get the list; instead, we will access the database
directly. Accessing the database directly is a double-edged sword. On
one hand, we don't want to access the database directly if
entity beans exist that can access the same information. Entity beans
provide a safe and consistent interface for a particular set of data.
Once an entity bean has been tested and proven, it can be reused
throughout the system, substantially reducing data integrity
problems. The Reservation bean is an example of that kind of usage.
In addition, entity beans can pull together disjointed data and apply
additional business logic such as validation, limits, and security to
ensure that data access follows the business rules.
</p>

<p>But entity beans cannot define every possible data access needed, and
they shouldn't. One of the biggest problems with entity beans
is that they tend to become bloated over time. A development effort
that relies too heavily on entity beans will create beans that have
more functionality than is normally needed. Huge entity beans with
dozens of methods are a sure sign of poor design. Entity beans should
be focused on providing data access to a very limited, but
conceptually bound, set of data. You should be able to update, read,
and insert records or data specific to that concept. Data access that
spans concepts, however, should not be encapsulated in one entity
bean. An example of this is listing behavior.
</p>

<p>Systems always need listing behavior to present clients with choices.
In the reservation system, for example, customers will want to choose
a cabin from a list of <em class="emphasis">available</em> cabins. The
word <em class="emphasis">available</em> is key to the definition of this
behavior. The Cabin bean can provide us with a list of cabins, but
not available cabins. That's because a cabin doesn't know
if it is available; it only knows the details that describe it. The
question of whether a cabin is available or not is relevant to the
process using it--in this case
<tt class="literal">TravelAgent</tt>--but is not relevant to the cabin
itself. As an analogy, an automobile entity would not care what road
it's on; it is only concerned with characteristics that
describe its state and behavior. An automobile-tracking system would
be concerned with the location of individual automobiles.
</p>

<p>To get availability information, we need to compare the list of
cabins on our ship to the list of cabins that have already been
reserved. The <tt class="literal">listAvailableCabins()</tt> method does
exactly that. It uses a complex SQL query to produce a list of cabins
that have not yet been reserved for the cruise chosen by the client:
</p>

<blockquote>
<pre class="programlisting">public String [] listAvailableCabins(int bedCount)
    throws IncompleteConversationalState { // EJB 1.0: also throws RemoteException

    if (cruise == null) throw new IncompleteConversationalState();

    Connection con = null;
    PreparedStatement ps = null;;
    ResultSet result = null;
    try {
        int cruiseID = ((CruisePK)cruise.getPrimaryKey()).id;
        int shipID = cruise.getShipID();
        con = getConnection();
        ps = con.prepareStatement(
            "select ID, NAME, DECK_LEVEL  from CABIN "+
            "where SHIP_ID = ? and ID NOT IN "+
            "(SELECT CABIN_ID FROM RESERVATION WHERE CRUISE_ID = ?)");

        ps.setInt(1,shipID);
        ps.setInt(2,cruiseID);
        result = ps.executeQuery();
        Vector vect = new Vector();
        while(result.next()) {
            StringBuffer buf = new StringBuffer();
            buf.append(result.getString(1));
            buf.append(',');
            buf.append(result.getString(2));
            buf.append(',');
            buf.append(result.getString(3));
            vect.addElement(buf.toString());
        }
        String [] returnArray = new String[vect.size()];
        vect.copyInto(returnArray);
        return returnArray;
    }
    catch (Exception e) {
        // EJB 1.0: throw new RemoteException("",e);
        throw new EJBException(e);
    }
    finally {
        try {
        if (result != null) result.close();
        if (ps != null) ps.close();
        if (con!= null) con.close();
        }catch(SQLException se){se.printStackTrace();}
    }
}</pre>
</blockquote>

<p>As you can see, the SQL query is complex. It could have been defined
in a bean-managed Cabin bean using a method like
<tt class="literal">Cabin.findAvailableCabins(Cruise</tt><tt class="literal">cruise)</tt> but this would be a poor design choice.
First, the Cabin bean would need to access the
<tt class="literal">RESERVATION</tt> table, which is not a part of its
definition. Entity beans should focus on only the data that defines
them.
</p>

<p>It might make a little more sense to make this behavior a find method
of the Cruise bean. One can imagine a method like
<tt class="literal">Cruise.findAvailableCabins()</tt>. You can certainly
argue that a cruise should be aware of its own reservations. But this
behavior is not very reusable. In other words, this kind of listing
behavior is only used in the reservation system. Making it part of
the Cruise bean's behavior suggests that is universally useful,
which it's not.
</p>

<p>
<a name="INDEX-1503"></a><a name="INDEX-1504"></a>The
<tt class="literal">listAvailableCabins()</tt> method returns an array of
<tt class="literal">String</tt> objects. This is important because we could
have opted to return an collection of <tt class="literal">Cabin</tt> remote
references, but we didn't. The reason is simple: we want to
keep the client application as lightweight as possible. A list of
<tt class="literal">String</tt> objects is much more lightweight than the
alternative, a collection of remote references. In addition, a
collection of remote references means that client would be working
with many stubs, each with its own connection to EJB objects on the
server. By returning a lightweight string array, we reduce the number
of stubs on the client, which keeps the client simple and conserves
resources on the server.
</p>

<p>To make this method work, you need to create a
<tt class="literal">getConnection()</tt> method for obtaining a database
connection and add it to the <tt class="literal">TravelAgentBean</tt>:
</p>

<blockquote>
<pre class="programlisting">// EJB 1.1: getConnection()
private Connection getConnection() throws SQLException {
    try {
       DataSource ds = (DataSource)jndiContext.lookup(
           "java:comp/env/jdbc/titanDB");
       return ds.getConnection();
    } catch(NamingException ne) {throw new EJBException(ne);}
}

// EJB 1.0: getConnection()
private Connection getConnection() throws SQLException {
    return DriverManager.getConnection(
        ejbContext.getEnvironment().getProperty("jdbcURL"));
}</pre>
</blockquote>

<p>Change the remote interface for TravelAgent to include the
<tt class="literal">listAvailableCabins()</tt> method as shown in the
following code:<a name="INDEX-1505"></a><a name="INDEX-1506"></a>

        throws RemoteException,IncompleteConversationalState; <a name="INDEX-1507"></a><a name="INDEX-1508"></a>
</p>

<blockquote>
<pre class="programlisting">public interface TravelAgent extends javax.ejb.EJBObject {

    public void setCruiseID(int cruise) 
        throws RemoteException, FinderException;
    public int getCruiseID() throws RemoteException;
    
    public void setCabinID(int cabin) throws RemoteException, FinderException;
    public int getCabinID() throws RemoteException;
    public int getCustomerID() throws RemoteException;
    
    public Ticket bookPassage(CreditCard card, double price)

    public String [] listAvailableCabins(int bedCount)
        throws RemoteException, IncompleteConversationalState;
}</pre>
</blockquote>



<a name="JBEANS-CH-7-SECT-3.1.7"></a>
<h3 class="sect3">7.3.1.7. EJB 1.1: The TravelAgent deployment descriptor</h3>

<p>Use the following <a name="INDEX-1509"></a><a name="INDEX-1510"></a><a name="INDEX-1511"></a>XML deployment descriptor when
deploying the TravelAgent bean. The most important difference between
this descriptor and the deployment descriptor used for the
ProcessPayment bean is the <tt class="literal">&lt;session-type&gt;</tt>
tag, which states that this bean is stateful, and the use of the
<tt class="literal">&lt;ejb-ref&gt;</tt> elements to describe beans that
are referenced through the ENC:
</p>

<blockquote>
<pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE ejb-jar PUBLIC "-//Sun Microsystems, Inc.//DTD Enterprise
JavaBeans 1.1//EN" "http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd"&gt;

&lt;ejb-jar&gt;
 &lt;enterprise-beans&gt;
   &lt;session&gt;
      &lt;description&gt;
          Acts as a travel agent for booking passage on a ship.
      &lt;/description&gt;
      &lt;ejb-name&gt;TravelAgentBean&lt;/ejb-name&gt;
      &lt;home&gt;com.titan.travelagent.TravelAgentHome&lt;/home&gt;
      &lt;remote&gt;com.titan.travelagent.TravelAgent&lt;/remote&gt;
      &lt;ejb-class&gt;com.titan.travelagent.TravelAgentBean&lt;/ejb-class&gt;
      &lt;session-type&gt;Stateful&lt;/session-type&gt;
      &lt;transaction-type&gt;Container&lt;/transaction-type&gt;
      
      &lt;ejb-ref&gt;
           &lt;ejb-ref-name&gt;ejb/ProcessPaymentHome&lt;/ejb-ref-name&gt;
           &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
           &lt;home&gt;com.titan.processpayment.ProcessPaymentHome&lt;/home&gt;
           &lt;remote&gt;com.titan.processpayment.ProcessPayment&lt;/remote&gt;
      &lt;/ejb-ref&gt;
      &lt;ejb-ref&gt;
           &lt;ejb-ref-name&gt;ejb/CabinHome&lt;/ejb-ref-name&gt;
           &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt;
           &lt;home&gt;com.titan.cabin.CabinHome&lt;/home&gt;
           &lt;remote&gt;com.titan.cabin.Cabin&lt;/remote&gt;
      &lt;/ejb-ref&gt;
      &lt;ejb-ref&gt;
           &lt;ejb-ref-name&gt;ejb/CruiseHome&lt;/ejb-ref-name&gt;
           &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt;
           &lt;home&gt;com.titan.cruise.CruiseHome&lt;/home&gt;
           &lt;remote&gt;com.titan.cruise.Cruise&lt;/remote&gt;
      &lt;/ejb-ref&gt;
      &lt;ejb-ref&gt;
           &lt;ejb-ref-name&gt;ejb/CustomerHome&lt;/ejb-ref-name&gt;
           &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt;
           &lt;home&gt;com.titan.customer.CustomerHome&lt;/home&gt;
           &lt;remote&gt;com.titan.customer.Customer&lt;/remote&gt;
      &lt;/ejb-ref&gt;
      &lt;ejb-ref&gt;
           &lt;ejb-ref-name&gt;ejb/ReservationHome&lt;/ejb-ref-name&gt;
           &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt;
           &lt;home&gt;com.titan.reservation.ReservationHome&lt;/home&gt;
           &lt;remote&gt;com.titan.reservation.Reservation&lt;/remote&gt;
      &lt;/ejb-ref&gt;

      &lt;resource-ref&gt;
           &lt;description&gt;DataSource for the Titan database&lt;/description&gt;
           &lt;res-ref-name&gt;jdbc/titanDB&lt;/res-ref-name&gt;
           &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
           &lt;res-auth&gt;Container&lt;/res-auth&gt;
      &lt;/resource-ref&gt;

  &lt;/session&gt;
 &lt;/enterprise-beans&gt;
 
 &lt;assembly-descriptor&gt;
   &lt;security-role&gt;
      &lt;description&gt;
         This role represents everyone who is allowed full access 
         to the TravelAgent bean.
      &lt;/description&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
   &lt;/security-role&gt;

   &lt;method-permission&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
     &lt;method&gt;
         &lt;ejb-name&gt;TravelAgentBean&lt;/ejb-name&gt;
         &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
   &lt;/method-permission&gt;

   &lt;container-transaction&gt;
     &lt;method&gt;
        &lt;ejb-name&gt;TravelAgentBean&lt;/ejb-name&gt;
        &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
     &lt;trans-attribute&gt;Required&lt;/trans-attribute&gt;
   &lt;/container-transaction&gt;
 &lt;/assembly-descriptor&gt;
&lt;/ejb-jar&gt;</pre>
</blockquote>

<p>Once you have generated the deployment descriptor,
<em class="filename">jar</em> the TravelAgent bean and deploy it in your
EJB server. You will also need to deploy the Reservation, Cruise, and
Customer beans that you downloaded earlier. Based on the business
methods in the remote interface of the TravelAgent bean and your past
experiences with the Cabin, Ship, and ProcessPayment beans, you
should be able to create your own client application to test this
<a name="INDEX-1512"></a><a name="INDEX-1513"></a><a name="INDEX-1514"></a>
code.
</p>



<a name="JBEANS-CH-7-SECT-3.1.8"></a>
<h3 class="sect3">7.3.1.8. EJB 1.0: The TravelAgent deployment descriptor</h3>

<p>For EJB 1.0, we need to make one change to <a name="INDEX-1515"></a><a name="INDEX-1516"></a>the
deployment descriptor for the TravelAgent bean that we created in
<a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>. We need to change the state management
type from stateless to stateful. Here is the new definition of the
<tt class="literal">MakeDD</tt> class used to generate the deployment
descriptor for the TravelAgent bean:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import javax.ejb.deployment.*;
import javax.naming.CompoundName;
import java.util.*;
import java.io.*;

public class MakeDD {

    public static void main(String args []) {
        try {
            if (args.length &lt;1) {
                System.out.println("must specify target directory");
                return;
            }

        SessionDescriptor sd = new SessionDescriptor();

        sd.setEnterpriseBeanClassName(
            "com.titan.travelagent.TravelAgentBean");
        sd.setHomeInterfaceClassName(
            "com.titan.travelagent.TravelAgentHome");
        sd.setRemoteInterfaceClassName(
            "com.titan.travelagent.TravelAgent");

        sd.setSessionTimeout(60);
        sd.setStateManagementType(SessionDescriptor.STATEFUL_SESSION);

        ControlDescriptor cd = new ControlDescriptor();
        cd.setIsolationLevel(ControlDescriptor.TRANSACTION_READ_COMMITTED);
        cd.setMethod(null);
        cd.setRunAsMode(ControlDescriptor.CLIENT_IDENTITY);
        cd.setTransactionAttribute(ControlDescriptor.TX_REQUIRED);
        ControlDescriptor [] cdArray = {cd};
        sd.setControlDescriptors(cdArray);
         
        // Set enterprise bean's environment properties.
        Properties ep = new Properties();
<b class="emphasis-bold">        ep.put("CruiseHome","CruiseHome");</b>
<b class="emphasis-bold">        ep.put("CabinHome","CabinHome");</b>
<b class="emphasis-bold">        ep.put("ReservationHome","ReservationHome");</b>
<b class="emphasis-bold">        ep.put("ProcessPaymentHome","ProcessPaymentHome");</b>
<b class="emphasis-bold">        ep.put("ShipHome","ShipHome");</b>
<b class="emphasis-bold">        ep.put("jdbcURL","jdbc:<tt class="userinput"><b>subprotocol</b></tt>
:<tt class="userinput"><b>subname</b></tt>
");</b>
        sd.setEnvironmentProperties(ep);

        Properties jndiProps = new Properties();
        CompoundName jndiName = 
            new CompoundName("TravelAgentHome",jndiProps);
        sd.setBeanHomeName(jndiName);

        String fileSeparator = 
            System.getProperties().getProperty("file.separator");
        if (! args[0].endsWith(fileSeparator))
            args[0] += fileSeparator;

        FileOutputStream fis = 
            new FileOutputStream(args[0]+"TravelAgentDD.ser");
        ObjectOutputStream oos = new ObjectOutputStream(fis);
        oos.writeObject(sd);
        oos.flush();
        oos.close();
        fis.close();
        } catch(Throwable t) {t.printStackTrace();}
    }
}</pre>
</blockquote>

<p>In addition to changing the state management type, we added several
environment properties that help us to locate the beans that the
TravelAgent bean needs to work with.
</p>

<p>Once you have generated the deployment descriptor,
<em class="filename">jar</em> the TravelAgent bean and deploy it in your
EJB server. You will also need to deploy the Reservation, Cruise, and
Customer beans that you downloaded earlier. Based on the business
methods in the remote interface of the TravelAgent bean and your past
experiences with the Cabin, Ship, and ProcessPayment beans, you
should be able to create your own client application to test this
<a name="INDEX-1517"></a><a name="INDEX-1518"></a> code.
</p>





<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch07_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch07_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_04.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">7.2. The Life Cycle of a Stateless Session Bean</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">7.4. The Life Cycle of a Stateful Session Bean</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
