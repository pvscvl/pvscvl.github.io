<html>
<head>
<title>Architectural Overview (Enterprise JavaBeans)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Richard Monson-Haefel">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-869-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Architectural Overview">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm" alt="Enterprise JavaBeans"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_08.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch01_08.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm">Enterprise JavaBeans</a></td><td align="right" valign="top" width="172"><a href="ch02_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h1 class="chapter">Chapter 2.  Architectural Overview</h1>
<div class="htmltoc">
<h4 class="tochead">Contents:</h4>
<p>
<a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">The Enterprise Bean Component</a>
<br>
<a href="ch02_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_02.htm">Using Enterprise Beans</a>
<br>
<a href="ch02_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_03.htm"> The Bean-Container Contract</a>
<br>
<a href="ch02_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_04.htm">Summary</a>
<br>
</p>
</div>


<p>As <a name="INDEX-160"></a><a name="INDEX-161"></a>
you learned in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a>, Enterprise JavaBeans is
a component model for component transaction monitors, the most
advanced type of business application server available today. To
effectively use Enterprise JavaBeans, you need to understand the EJB
architecture, so this book includes two chapters on the subject. This
chapter explores the core of EJB: how enterprise beans are
distributed as business objects. <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>
explores the services and resource management techniques supported by
EJB.
</p>

<p>To be truly versatile, the EJB component design had to be smart. For
application developers, assembling enterprise beans is simple,
requiring little or no expertise in the complex system-level issues
that often plague three-tier development efforts. While EJB makes it
easy for application developers, it also provides system developers
(the people who write EJB servers) with a great deal of flexibility
in how they support the EJB specification.
</p>

<p>The similarities among different <a name="INDEX-162"></a>component transaction monitors (CTMs)
allow the EJB abstraction to be a standard component model for all of
them. Each vendor's CTM is implemented differently, but they
all support the same primary services and similar resource management
techniques. The primary services and resource management techniques
are covered in more detail in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>, but some
of the infrastructure for supporting them is addressed in this
chapter.
</p>



<h2 class="sect1">2.1. The Enterprise Bean Component</h2>

<p>
<a name="INDEX-163"></a><a name="INDEX-164"></a>Enterprise JavaBeans server-side
components come in two fundamentally different types:
<a name="INDEX-165"></a><a name="INDEX-166"></a><em class="emphasis">entity beans</em> and
<a name="INDEX-167"></a><em class="emphasis">session beans</em>. A good rule of thumb is that
entity beans model business concepts that can be expressed as nouns.
For example, an entity bean might represent a customer, a piece of
equipment, an item in inventory, or even a place. In other words,
entity beans model real-world objects; these objects are usually
persistent records in some kind of database. Our hypothetical cruise
line will need entity beans that represent cabins, customers, ships,
etc.
</p>

<p>
<a name="INDEX-168"></a>Session beans are an
extension of the <a name="INDEX-169"></a>client application and are responsible for
managing processes or tasks. A Ship bean provides methods for doing
things directly to a ship but doesn't say anything about the
context under which those actions are taken. Booking passengers on
the ship requires that we use a Ship bean, but also requires a lot of
things that have nothing to do with the Ship itself: we'll need
to know about passengers, ticket rates, schedules, and so on. A
session bean is responsible for this kind of coordination. Session
beans tend to manage particular kinds of activities, for example, the
act of making a reservation. They have a lot to do with the
relationships between different enterprise beans. A TravelAgent
session bean, for example, might make use of a Cruise, a Cabin, and a
Customer--all entity beans--to make a reservation.
</p>

<p>The activity that a session bean represents is fundamentally
transient: you start making a reservation, you do a bunch of work,
and then it's finished. A session bean doesn't represent
something in a database. Obviously, session beans have lots of side
effects on the database: in the process of making a reservation, you
might create a new Reservation by assigning a Customer to a
particular Cabin on a particular Ship. All of these changes would be
reflected in the database by actions on the respective entity beans.
Session beans like TravelAgent, which is responsible for making a
reservation on a cruise, can even access a database directly and
perform reads, updates, and deletes to data. But there's no
TravelAgent record in the database--once the reservation is
made, it's done.
</p>

<p>What makes this distinction difficult is that it's extremely
flexible. <a name="INDEX-170"></a>
The relevant distinction for Enterprise JavaBeans is that an entity
bean has persistent state; a session bean models interactions but
doesn't have persistent state.
</p>

<a name="JBEANS-CH-2-SECT-1.1"></a>
<h3 class="sect2">2.1.1. Classes and Interfaces</h3>

<p>A good way to understand the design of <a name="INDEX-171"></a><a name="INDEX-172"></a><a name="INDEX-173"></a><a name="INDEX-174"></a>enterprise beans is to look at
how you'd go about implementing one. To implement an
<a name="INDEX-175"></a>enterprise bean, you need to define two
interfaces and one or two classes:
</p>

<dl>
<dt>
<b>Remote interface</b>
</dt>
<dd>
<p>The <a name="INDEX-176"></a><a name="INDEX-177"></a>remote interface for an
enterprise bean defines the bean's business methods: the
methods a bean presents to the outside world to do its work. The
remote interface extends <tt class="literal">javax.ejb.EJBObject</tt>,
which in turn extends <tt class="literal">java.rmi.Remote</tt>.
(We'll call the rather shadowy entity that actually implements
this interface the <em class="emphasis">EJB object</em>.)
</p>
</dd>

<dt>
<b>Home interface</b>
</dt>
<dd>
<p>The <a name="INDEX-178"></a>home
interface defines the bean's life cycle methods: methods for
creating new beans, removing beans, and finding beans. The home
interface extends <tt class="literal">javax.ejb.EJBHome</tt>, which in turn
extends <tt class="literal">java.rmi.Remote</tt>. (We'll call the
object that implements the home interface the <em class="emphasis">EJB
home</em>.)
</p>
</dd>

<dt>
<b>Bean class</b>
</dt>
<dd>
<p>The <a name="INDEX-179"></a><a name="INDEX-180"></a>bean class actually
implements the bean's business methods. Note, however, that the
bean class usually does not implement the bean's home or remote
interfaces. However, it must have methods matching the signatures of
the methods defined in the remote interface and must have methods
corresponding to some of the methods in the home interface. If this
sounds perfectly confusing, it is. We'll try to clarify this as
we go along. An entity bean must implement
<tt class="literal">javax.ejb.EntityBean</tt>; a session bean must
implement <tt class="literal">javax.ejb.SessionBean</tt>. Both
<tt class="literal">EntityBean</tt> and <tt class="literal">SessionBean</tt>
extend <tt class="literal">javax.ejb.EnterpriseBean</tt>.
</p>
</dd>

<dt>
<b>Primary key</b>
</dt>
<dd>
<p>The <a name="INDEX-181"></a><a name="INDEX-182"></a>primary key is a very simple
class that provides a pointer into the database. Only entity beans
need a primary key; the only requirement for this class is that it
implements <tt class="literal">java.io.Serializable</tt>.
</p>
</dd>

</dl>

<p>The complexity--particularly all the confusion about classes
implementing the methods of an interface but not implementing the
interface itself--comes about because enterprise beans exist in
the middle between some kind of client software and some kind of
database. The client never interacts with a bean class directly; it
always uses the methods of the bean's home and remote
interfaces to do its work, interacting with stubs that are generated
automatically. (For that matter, a bean that needs the services of
another bean is just another client: it uses the same stubs, rather
than interacting with the bean class directly.)
</p>

<p>There are also lots of interactions between a bean and its server.
These interactions are managed by a
"<a name="INDEX-183"></a>container," which is responsible
for presenting a uniform interface between the bean and the server.
(Although it's incorrect, many people use the terms
"container" and
"<a name="INDEX-184"></a>server" interchangeably. We
won't promise consistency ourselves. But it's helpful to
understand the difference.) The container is responsible for creating
new instances of beans, making sure that they are stored properly by
the server, and so on. Tools provided by the container's vendor
do a tremendous amount of work behind the scenes. At least one tool
will take care of creating the mapping between entity beans and
records in your database. Other tools generate a lot of code based on
the home interface, the remote interface, and the bean class itself.
The code generated does things like create the bean, store it in the
database, and so on. This code (in addition to the stubs) is what
actually implements the two interfaces, and is the reason your bean
class doesn't have to.
</p>

<p>Before going on let's first establish some
<a name="INDEX-185"></a><a name="INDEX-186"></a>conventions. When we speak about an
enterprise bean as a whole, its remote interface, home interface,
bean class, and so forth, we will call it by its remote-interface
name, followed by the word "bean." For example, an
enterprise bean that is developed to model a cabin on a ship will be
called the "Cabin bean." Notice that we didn't use
a constant width font for "Cabin." We do this because we
are referring to all the parts of the bean (remote interface, home
interface, bean class, etc.) as a whole, not just one particular part
like the remote interface or bean class. When we are talking about
the remote interface of the Cabin bean we will use constant width.
For example, the remote interface for the Cabin bean is called the
<tt class="literal">Cabin</tt> remote interface. Likewise, we use constant
width for the names of the classes that make up the other parts of
the bean. The bean class itself would be called
<tt class="literal">CabinBean</tt>, the home interface
<tt class="literal">CabinHome</tt>, and the primary key would be called
<tt class="literal">CabinPK</tt>.
</p>

<a name="JBEANS-CH-2-SECT-1.1.1"></a>
<h3 class="sect3">2.1.1.1. The remote interface</h3>

<p>
<a name="INDEX-187"></a>Having
introduced the machinery, let's look at how to build a bean. In
this section, we will examine the Cabin bean, an entity bean that
models a cabin on a cruise ship. Let's start with its remote
interface.
</p>

<p>We'll define the remote interface for a Cabin bean using the
interface called <tt class="literal">Cabin</tt>, which defines business
methods for working with cabins. All remote-interface types extend
the <tt class="literal">javax.ejb.EJBObject</tt> interface.
</p>

<blockquote>
<pre class="programlisting">import java.rmi.RemoteException;

public interface Cabin extends javax.ejb.EJBObject {
    public String getName() throws RemoteException;
    public void setName(String str) throws RemoteException;
    public int getDeckLevel() throws RemoteException;
    public void setDeckLevel(int level) throws RemoteException;
}</pre>
</blockquote>

<p>These are methods for naming the cabin and methods for setting the
cabin's deck level; you can probably imagine lots of other
methods that you'd need, but this is enough to get started. All
of these methods declare that they throw
<tt class="literal">RemoteException</tt>, which is required of any method
that can be invoked through RMI. EJB requires the use of
<a name="INDEX-188"></a>Java RMI-IIOP
conventions, although the underlying protocol can be CORBA IIOP, Java
Remote Method Protocol ( JRMP), or some other protocol. Java RMI-IIOP
will be discussed in more detail in the next chapter.
</p>



<a name="JBEANS-CH-2-SECT-1.1.2"></a>
<h3 class="sect3">2.1.1.2. The home interface</h3>

<p>The <a name="INDEX-189"></a><a name="INDEX-190"></a>home interface defines
life-cycle methods and methods for looking up beans. The home
interface extends <tt class="literal">javax.ejb.EJBHome</tt>. We'll
call the home interface for the Cabin bean
<tt class="literal">CabinHome</tt> and define it like this:
<a name="INDEX-191"></a>
</p>

<blockquote>
<pre class="programlisting">import java.rmi.RemoteException;
import javax.ejb.CreateException;
import javax.ejb.FinderException;

public interface CabinHome extends javax.ejb.EJBHome {
    public Cabin create(int id) 
        throws CreateException, RemoteException;
    public Cabin findByPrimaryKey(CabinPK pk)
        throws FinderException, RemoteException;
}</pre>
</blockquote>

<p>The <a name="INDEX-192"></a><tt class="literal">create()</tt>
method will be responsible for initializing an instance of our bean.
If your application needs it, you can provide other
<tt class="literal">create()</tt> methods, with different arguments.
</p>

<p>In addition to the <a name="INDEX-193"></a><tt class="literal">findByPrimaryKey()</tt>, you are free to define other
methods that provide convenient ways to look up Cabin beans--for
example, you might want to define a method called
<tt class="literal">findByShip()</tt> that returns all the cabins on a
particular ship. Find methods like these are only used in
<tt class="literal">EntityBean</tt> types and are not used in
<tt class="literal">SessionBean</tt> types.
</p>



<a name="JBEANS-CH-2-SECT-1.1.3"></a>
<h3 class="sect3">2.1.1.3. The bean class</h3>

<p>Now let's look at an actual <a name="INDEX-194"></a>bean.
Here's the code for the <tt class="literal">CabinBean</tt>;
it's a sparse implementation, but it will show you how the
pieces fit together:
</p>

<blockquote>
<pre class="programlisting">import javax.ejb.EntityContext;

public class CabinBean implements javax.ejb.EntityBean {

    public int id;
    public String name;
    public int deckLevel;
 
    // EJB 1.0: return void   
    public CabinPK ejbCreate(int id){
        this.id = id;
        // EJB 1.0 no return statement
        return null;
    }
    public void ejbPostCreate(int id){
        // do nothing
    }
    public String getName(){
        return name;
    }
    public void setName(String str){
        name = str;
    }
    public int getDeckLevel(){
        return deckLevel;
    }
    public void setDeckLevel(int level){
        deckLevel = level;
    }

    public void setEntityContext(EntityContext ctx){
        // not implemented
    }
    public void unsetEntityContext(){
        // not implemented
    }
    public void ejbActivate(){
        // not implemented
    }
    public void ejbPassivate(){
        // not implemented
    }
    public void ejbLoad(){
        // not implemented
    }
    public void ejbStore(){
        // not implemented
    }
    public void ejbRemove(){
        // not implemented
    }
}</pre>
</blockquote>

<a name="ch02-6-fm2xml"></a>
<blockquote class="note">
<h4 class="objtitle">NOTE</h4> <p>The <tt class="literal">//</tt><tt class="literal">EJB</tt><tt class="literal">1.0</tt><a name="INDEX-195"></a>comments indicate how to modify the code to
work with an EJB 1.0 server. As written, this code (and the other
examples in this book) assume EJB 1.1, unless otherwise noted.</p>
</blockquote>

<p>
<a name="INDEX-196"></a><a name="INDEX-197"></a>The set and get methods for the
cabin's name and deck level are the business methods of the
<tt class="literal">CabinBean</tt>; they match the business methods defined
by the bean's remote interface, <tt class="literal">Cabin</tt>. The
<tt class="literal">CabinBean</tt> class has state and business behavior
that models the concept of a cabin. The business methods are the only
methods that are visible to the client application; the other methods
are visible only to the EJB container. The other methods are required
by the EJB component model and are not really part of the bean
class's public business definition.
</p>

<p>The <tt class="literal">ejbCreate()</tt> and
<tt class="literal">ejbPostCreate()</tt> methods initialize the instance of
the bean class when a new cabin record is to be added to the
database. The last seven methods in the <tt class="literal">CabinBean</tt>
are defined in the <tt class="literal">javax.ejb.EntityBean</tt> interface.
These methods are
<a name="INDEX-198"></a><a name="INDEX-199"></a>
state management callback methods. The EJB server invokes these
callback methods on the bean class when important state management
events occur. The <tt class="literal">ejbRemove()</tt> method, for example,
notifies an entity bean that its data is about to be deleted from the
database. The <tt class="literal">ejbLoad()</tt> and
<tt class="literal">ejbStore()</tt> methods notify the bean instance that
its state is being read or written to the database. The
<tt class="literal">ejbActivate()</tt> and
<tt class="literal">ejbPassivate()</tt> methods notify the bean instance
that it is about to be activated or deactivated, a process that
conserves memory and other resources.
<tt class="literal">setEntityContext()</tt> provides the bean with an
interface to the EJB server that allows the bean class to get
information about itself and its surroundings.
<tt class="literal">unsetEntityContext()</tt> is called by the EJB server
to notify the bean instance that it is about to be dereferenced for
garbage collection.
</p>

<p>All these callback methods provide the bean class with
<a name="INDEX-200"></a><a name="INDEX-201"></a><em class="emphasis">notifications</em> of
when an action is about to be taken, or was just taken, on the bean
class's behalf by the EJB server. These notifications simply
inform the bean of an event, the bean doesn't have to do
anything about it. The callback notifications tell the bean where it
is during its life cycle, when it is about to be loaded, removed,
deactivated, and so on. Most of the callback methods pertain to
persistence, which can be done automatically for the bean class by
the EJB server. Because the callback methods are defined in the
<tt class="literal">javax.ejb.EntityBean</tt><a name="INDEX-202"></a> interface, the bean class must implement
them, but it isn't required to do anything meaningful with the
methods if it doesn't need to. Our bean, the
<tt class="literal">CabinBean</tt>, won't need to do anything when
these callback methods are invoked, so these methods are empty
implementations. Details about these callback methods, when they are
called and how a bean should react, are covered in <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>.<a name="INDEX-203"></a>
</p>



<a name="JBEANS-CH-2-SECT-1.1.4"></a>
<h3 class="sect3">2.1.1.4. The primary key</h3>

<p>Certain public fields of an entity bean are stored in a database.
These fields are called <a name="INDEX-204"></a><a name="INDEX-205"></a><a name="INDEX-206"></a><em class="emphasis">persistent fields</em>. Determining how the data in
the database relates to the persistent fields of the bean class is
called <a name="INDEX-207"></a><a name="INDEX-208"></a><em class="emphasis">data mapping</em>. When a bean is deployed into an
EJB server, its persistent fields must be mapped to the database. The
data used to populate persistent fields in the bean instance is
obtained using a primary key. The primary key is a pointer that helps
locate data that describes a unique record or entity in the database;
it is used in the <tt class="literal">findByPrimaryKey()</tt> method of the
home interface to locate a specific entity. Primary keys are defined
by the bean developer and must be some type of serializable object.
Here's the primary key for the Cabin bean:
</p>

<blockquote>
<pre class="programlisting">public class CabinPK implements java.io.Serializable{
    public int id;
    
    public int hashCode(){ 
         return id;
    }
    public boolean equals(Object obj){
        if (obj instanceof CabinPK){
            if (((CabinPK)obj).id == id)
                return true;
        }
        return false;
    }
}</pre>
</blockquote>

<p>Most EJB container
<a name="INDEX-209"></a><a name="INDEX-210"></a>vendors provide some kind of tool,
available at deployment time, that helps to map the primary key and
the bean's persistent fields to the database. These kinds of
tools may present the persistent fields of the bean as well as the
structure of the database in a graphical presentation. The person
deploying the bean simply ties the bean's fields to its
representation in the database, which could be relational database
columns, an objectified version of the database, or a more direct
mapping to an object database.
</p>



<a name="JBEANS-CH-2-SECT-1.1.5"></a>
<h3 class="sect3">2.1.1.5. What about session beans?</h3>

<p>
<tt class="literal">CabinBean</tt> is an entity bean, but a
<a name="INDEX-211"></a>session bean
wouldn't be all that different. It would extend
<tt class="literal">SessionBean</tt> instead of
<tt class="literal">EntityBean</tt>; it would have an
<tt class="literal">ejbCreate()</tt> method that would initialize the
bean's state, but no <tt class="literal">ejbPostCreate()</tt>.
Session beans don't have an <tt class="literal">ejbLoad()</tt> or
<tt class="literal">ejbStore()</tt> because session beans are not
persistent. While session beans have a
<tt class="literal">setSessionContext()</tt> method, they don't have
an <tt class="literal">unsetSessionContext()</tt> method. Finally, a
session bean would provide an <tt class="literal">ejbRemove()</tt> method,
which would be called to notify the bean that the client no longer
needs it. However, this method wouldn't tell the bean that its
data was about to be removed from the database, because a session
bean doesn't represent data in the database.
</p>

<p>Session beans don't have a <a name="INDEX-212"></a><a name="INDEX-213"></a>primary key. That's because session
beans are not persistent themselves, so there is no need for key that
maps to the database.<a name="INDEX-214"></a><a name="INDEX-215"></a><a name="INDEX-216"></a>
</p>



<a name="JBEANS-CH-2-SECT-1.2"></a>
<h3 class="sect2">2.1.2. Deployment Descriptors and JAR Files</h3>

<p>
<a name="INDEX-217"></a><a name="INDEX-218"></a>Much of the information about how beans
are managed at runtime is not addressed in the interfaces and classes
discussed previously. You may have noticed, for example, that we
didn't talk about how beans interact with security,
transactions, naming, and other services common to distributed object
systems.
<a name="INDEX-219"></a>As you know from prior discussions,
these types of primary services are handled automatically by the EJB
CTM server, but the EJB server still needs to know how to apply the
primary services to each bean class at runtime. To do this, we use
<em class="emphasis">deployment descriptors</em>.
</p>

<p>Deployment <a name="INDEX-220"></a>descriptors serve a function very
similar to <a name="INDEX-221"></a>property files. They
allow us to customize behavior of software (enterprise beans) at
runtime without having to change the software itself. Property files
are often used with applications, but deployment descriptors are
specific to a class of enterprise bean. Deployment descriptors are
also similar in purpose to property sheets used in Visual Basic and
PowerBuilder. Where property sheets allow us to describe the runtime
attributes of visual widgets (background color, font size, etc.),
deployment descriptors allow us to describe runtime attributes of
server-side components (security, transactional context, etc.).
Deployment descriptors allow certain runtime behaviors of beans to be
customized, without altering the bean class or its interfaces.
</p>

<p>When a bean class and its interfaces have been defined, a deployment
descriptor for the bean is created and populated with data about the
bean. Frequently, <a name="INDEX-222"></a>IDEs (integrated development
environments) that support development of Enterprise JavaBeans will
allow developers to graphically set up the deployment descriptors
using visual utilities like property sheets. After the developer has
set all the properties for a bean, the deployment descriptor is saved
to a file. Once the deployment descriptor is complete and saved to a
file, the bean can be packaged in a JAR file for deployment.
</p>

<p>
<a name="INDEX-223"></a>JAR ( <em class="emphasis"> J</em> ava
<em class="emphasis">ar</em> chive) files are ZIP files that are used
specifically for packaging Java classes (and other resources such as
images) that are ready to be used in some type of application. JARs
are used for packaging applets, Java applications, JavaBeans, and
Enterprise JavaBeans. A JAR file containing one or more enterprise
beans includes the bean classes, remote interfaces, home interfaces,
and primary keys (<tt class="literal">EntityBean</tt> types only), for each
bean. It also contains one deployment descriptor, which is used for
all the beans in the JAR files. When a bean is deployed, the
JAR's path is given to the container's deployment tools,
which read the JAR file. The container uses the deployment descriptor
to learn about the beans contained in the JAR file.
</p>

<a name="ch02-10-fm2xml"></a>
<blockquote class="note">
<h4 class="objtitle">NOTE</h4>
<p>EJB 1.0 also requires information in the <a name="INDEX-224"></a>
JAR manifest (a kind of table of contents for the JAR), to denote which entry points to the deployment descriptor. When a bean is deployed, the JAR's path is given to the container's deployment tools, which read the JAR file. The first thing read out of the JAR file after the manifest is the deployment descriptor.</p>
<p>EJB 1.1 doesn't use the JAR's manifest; the first thing read in the JAR is the deployment descriptor.</p>
</blockquote>

<p>When the JAR file is read at deployment time, the container tools
read the deployment descriptor to learn about the bean and how it
should be managed at runtime. The deployment descriptor tells the
deployment tools what kind of beans are in the JAR file
(<tt class="literal">SessionBean</tt> or <tt class="literal">EntityBean</tt>),
how they should be managed in transactions, who has access to the
beans at runtime, and other runtime attributes of the beans. The
person who is deploying the bean can alter some of these settings,
like transactional and security access attributes, to customize the
bean for a particular application. Many container tools provide
property sheets for graphically reading and altering the deployment
descriptor when the bean is deployed. These graphical property sheets
are similar to those used by bean developers.
</p>

<p>The deployment descriptors help the deployment tools to add beans to
the EJB container. Once the bean is deployed, the properties
described in the deployment descriptors will continue to be used to
tell the EJB container how to manage the bean at <a name="INDEX-225"></a><a name="INDEX-226"></a> runtime.
</p>

<a name="JBEANS-CH-2-SECT-1.2.1"></a>
<h3 class="sect3">2.1.2.1. EJB 1.0: Deployment descriptors</h3>

<p>
<a name="INDEX-227"></a><a name="INDEX-228"></a>
Enterprise JavaBeans Version 1.0 uses a set of
<a name="INDEX-229"></a>serializable classes to set and store the
deployment descriptor information. Instances of these classes are
created and populated with deployment information when the bean is
developed, then serialized to a file. The container deploying the
bean deserializes the deployment descriptor objects and reads their
properties to obtain the deployment information.
</p>

<p>Here are some of the property methods defined in the main descriptor
class, <a name="INDEX-230"></a><tt class="literal">DeploymentDescriptor</tt>. The method bodies have been
omitted; what's important at this stage is to get a feel for
what methods are defined by a descriptor.
</p>

<blockquote>
<pre class="programlisting">public abstract Class javax.ejb.deployment.DeploymentDescriptor 
    extends Object implements Serializable {

  // The release version of the bean
  protected int versionNumber;    
  
  // Get the AccessControlEntry objects for the enterprise bean.   
  public AccessControlEntry[]<tt class="userinput"><b> getAccessControlEntries()</b></tt> {}
  // Get the control descriptor at the specified index. 
  public ControlDescriptor <tt class="userinput"><b>getControlDescriptors(int index)</b></tt> {}
  // Get the enterprise bean's full class name. 
  public String <tt class="userinput"><b>getEnterpriseBeanClassName()</b></tt>{}
  // Get enterprise bean's environment properties. 
  public Properties <tt class="userinput"><b>getEnvironmentProperties()</b></tt> {} 
  // Get the full name of the enterprise bean's home interface. 
  public String <tt class="userinput"><b>getHomeInterfaceClassName()</b></tt> {} 
  // Get the full name of the enterprise bean's remote interface. 
  public String <tt class="userinput"><b>getRemoteInterfaceClassName()</b></tt> {} 

  // Set the AccessControlEntry objects for the enterprise bean.
  public void <tt class="userinput"><b>setAccessControlEntries(AccessControlEntry values [])</b></tt>{}  
  // Set the control descriptor at the specified index. 
  public void <tt class="userinput"><b>setControlDescriptors(int index, ControlDescriptor value)</b></tt> {}
  // Set the enterprise bean's full class name. 
  public void <tt class="userinput"><b>setEnterpriseBeanClassName(String value)</b></tt> {}
  // Set enterprise bean's environment properties. 
  public void <tt class="userinput"><b>setEnvironmentProperties(Properties value)</b></tt> {}  
  // Set the full name of the enterprise bean's home interface. 
  public void <tt class="userinput"><b>setHomeInterfaceClassName(String value)</b></tt> {}
  // Specify that the enterprise bean is reentrant. 
  public void <tt class="userinput"><b>setReentrant(boolean value)</b></tt> {}
  // Set the full name of the enterprise bean's remote interface. 
  public void <tt class="userinput"><b>setRemoteInterfaceClassName(String value)</b></tt> {}  
  
  // ... Other set and get methods for properties follow.
}</pre>
</blockquote>

<p>The classes used to provide deployment information are found in the
<tt class="literal">javax.ejb.deployment</tt><a name="INDEX-231"></a> package, which has five deployment
descriptor classes:
</p>

<dl>
<dt>
<b><tt class="literal">DeploymentDescriptor</tt></b>
</dt>
<dd>
<p>The
<tt class="literal">DeploymentDescriptor</tt><a name="INDEX-232"></a> class is the abstract superclass for both
<tt class="literal">EntityDescriptor</tt> and
<tt class="literal">SessionDescriptor</tt>. It provides the accessor
methods for reading properties that describe the bean's version
number, and the names of the classes for the bean's remote
interface, home interface, and bean class. In addition, the
deployment descriptor provides access to the
<tt class="literal">ControlDescriptor</tt>s and
<tt class="literal">AccessControlEntry</tt>s.
</p>
</dd>

<dt>
<b>
<a name="INDEX-233"></a>
<tt class="literal">ControlDescriptor</tt></b>
</dt>
<dd>
<p>The <tt class="literal">ControlDescriptor</tt> class provides accessor
methods for defining the security and transactional attributes of a
bean at runtime. <tt class="literal">ControlDescriptor</tt>s can be applied
to the bean as a whole, or to specific methods of the bean. Any
method that doesn't have a <tt class="literal">ControlDescriptor</tt>
uses the default properties defined by the
<tt class="literal">ControlDescriptor</tt> for the bean itself. Security
properties in the <tt class="literal">ControlDescriptor</tt> indicate how
<tt class="literal">AccessControlEntry</tt>s are applied at runtime.
Transactional properties indicate how the bean or specific method
will be involved in transactions at runtime.
</p>
</dd>

<dt>
<b><tt class="literal">AccessControlEntry</tt></b>
</dt>
<dd>
<p>Each <a name="INDEX-234"></a><tt class="literal">AccessControlEntry</tt>
identifies a person, group, or role that can access the bean or one
of its methods. Like <tt class="literal">ControlDescriptor</tt>,
<tt class="literal">AccessControlEntry</tt> can be applied to the bean as a
whole or to a specific method. An
<tt class="literal">AccessControlEntry</tt> that is specific to a method
overrides the default <tt class="literal">AccessControlEntry</tt>s set for
the bean. The <tt class="literal">AccessControlEntry</tt>s are used in
combination with the security properties in the
<tt class="literal">ControlDescriptor</tt> to provide more control over
runtime access to the bean and its methods.
</p>
</dd>

<dt>
<b><tt class="literal">EntityDescriptor</tt></b>
</dt>
<dd>
<p>The <a name="INDEX-235"></a><tt class="literal">EntityDescriptor</tt> class extends
<tt class="literal">DeploymentDescriptor</tt> to provide properties
specific to an <tt class="literal">EntityBean</tt> object. Entity bean
properties include the name of the primary key class and what
instance variables are managed automatically by the container.
</p>
</dd>

<dt>
<b><tt class="literal">SessionDescriptor</tt></b>
</dt>
<dd>
<p>The <a name="INDEX-236"></a><tt class="literal">SessionDescriptor</tt> class extends
<tt class="literal">DeploymentDescriptor</tt> to provide properties
specific to a <tt class="literal">SessionBean</tt> object. Session bean
properties include a timeout setting (how long a session can go
unused before it's automatically removed) and a stateless
session property. The stateless session property indicates whether
the session is a stateless session bean or a stateful session bean.
(More about stateless and stateful session beans later.)
</p>
</dd>

</dl>

<p>Several of the properties described by the deployment descriptors,
such as transactional and security attributes, have not yet been
discussed. Later we will discuss these topics in more detail, but for
now it's important that you understand that the deployment
descriptors in EJB 1.0 are serialized class instances that describe
the bean and some of its runtime behavior to the <a name="INDEX-237"></a><a name="INDEX-238"></a> container.
</p>



<a name="JBEANS-CH-2-SECT-1.2.2"></a>
<h3 class="sect3">2.1.2.2. EJB 1.1: Deployment descriptors</h3>

<p>
<a name="INDEX-239"></a><a name="INDEX-240"></a>Enterprise JavaBeans 1.1 dropped the
<a name="INDEX-241"></a>
serializable deployment descriptor classes used in EJB 1.0 in favor
of a more flexible file format based on XML (E<em class="emphasis">x
</em>tensible <em class="emphasis">M </em>arkup
<em class="emphasis">L</em>anguage). The new <a name="INDEX-242"></a><a name="INDEX-243"></a>XML deployment
descriptors are text files structured according to a standard
<a name="INDEX-244"></a><a name="INDEX-245"></a>EJB DTD (Document Type
Definition) that can be extended so the type of deployment
information stored can evolve as the specification evolves. <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch10_01.htm">Chapter 10, "XML Deployment Descriptors"</a> provides a a detailed description of EJB 1.1
deployment descriptors. This section provides a brief overview of XML
deployment descriptors.
</p>

<p>The following deployment descriptor might be used to describe the
Cabin bean:
</p>

<blockquote>
<pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE ejb-jar PUBLIC "-//Sun Microsystems, Inc.//DTD Enterprise
JavaBeans 1.2//EN" "http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd"&gt;

&lt;ejb-jar&gt;
    &lt;enterprise-beans&gt;
        &lt;entity&gt;
            &lt;ejb-name&gt;CabinEJB&lt;/ejb-name&gt;
            &lt;home&gt;com.titan.cabin.CabinHome&lt;/home&gt;
            &lt;remote&gt;com.titan.cabin.Cabin&lt;/remote&gt;
            &lt;ejb-class&gt;com.titan.cabin.CabinBean&lt;/ejb-class&gt;
            &lt;prim-key-class&gt;com.titan.cabin.CabinPK&lt;/prim-key-class&gt;
            &lt;persistence-type&gt;Container&lt;/persistence-type&gt;
            &lt;reentrant&gt;False&lt;/reentrant&gt;
        &lt;/entity&gt;
    &lt;/enterprise-beans&gt;
&lt;/ejb-jar&gt;</pre>
</blockquote>

<p>The deployment descriptor for a real bean would have a lot more
information; this example simply illustrates the type of information
that you'll find in an XML deployment descriptor.
</p>

<p>The second element in any XML document is
<tt class="literal">!DOCTYPE</tt><a name="INDEX-246"></a><a name="INDEX-247"></a>. This element
describes the organization that defined the DTD for the XML document,
the DTD's version, and a URL location of the DTD. The DTD
describes how a particular XML document is structured.
</p>

<p>All the other <a name="INDEX-248"></a><a name="INDEX-249"></a>
elements in the <a name="INDEX-250"></a>XML
document are specific to EJB 1.1. They do not represent all the
elements used in deployment descriptors, but they illustrate the
types of elements that are used. Here's what the elements mean:
</p>

<dl>
<dt>
<b><tt class="literal">ejb-jar</tt>
<a name="INDEX-251"></a>
<a name="INDEX-252"></a>
</b>
</dt>
<dd>
<p>The root of the XML deployment descriptor. All other elements must be
nested below this one. It must contain one
<tt class="literal">enterprise-beans</tt> element as well as other optional
elements.
</p>
</dd>

<dt>
<b><tt class="literal">enterprise-beans</tt>
<a name="INDEX-253"></a>
</b>
</dt>
<dd>
<p>Contains declarations for all the beans described by this XML
document. It may contain <tt class="literal">entity</tt> and
<tt class="literal">session</tt> elements, which describe entity beans and
session beans respectively.
</p>
</dd>

<dt>
<b><tt class="literal">entity</tt>
<a name="INDEX-254"></a>
</b>
</dt>
<dd>
<p>Describes an entity bean and its deployment information. There must
be one of these elements for every entity bean described by the XML
deployment descriptor. (The <tt class="literal">session</tt> element is
used in the same way to describe a session bean.)
</p>
</dd>

<dt>
<b><tt class="literal">ejb-name</tt>
<a name="INDEX-255"></a>
<a name="INDEX-256"></a>
</b>
</dt>
<dd>
<p>The descriptive name of the bean. It's the name we use for the
bean in conversation, when talking about the bean component as a
whole.
</p>
</dd>

<dt>
<b><tt class="literal">home</tt>
<a name="INDEX-257"></a>
<a name="INDEX-258"></a>
</b>
</dt>
<dd>
<p>The fully qualified class name of the home interface. This is the
interface that defines the life-cycle behaviors (create, find,
remove) of the bean.
</p>
</dd>

<dt>
<b><tt class="literal">remote</tt>
<a name="INDEX-259"></a>
</b>
</dt>
<dd>
<p>The fully qualified class name of the remote interface. This is the
interface that defines the bean's business methods.
</p>
</dd>

<dt>
<b><tt class="literal">ejb-class</tt>
<a name="INDEX-260"></a>
<a name="INDEX-261"></a>
</b>
</dt>
<dd>
<p>The fully qualified class name of the bean class. This is the class
that implements the business methods of the bean.
</p>
</dd>

<dt>
<b><tt class="literal">prim-key-class</tt>
<a name="INDEX-262"></a>
<a name="INDEX-263"></a>
<a name="INDEX-264"></a>
</b>
</dt>
<dd>
<p>The fully qualified class name of the bean's primary key. The
primary key is used to find the bean data in the database.
</p>
</dd>

</dl>

<p>The last two elements in the deployment descriptor, the
persistence-type and reentrant elements, express the persistence
strategy and concurrency policies of the entity bean. These elements
are explained in more detail later in the book.
</p>

<p>As you progress through this book, you will be introduced to the
elements that describe concepts we have not covered yet, so
don't worry about knowing all of the things you might find in a
deployment <a name="INDEX-265"></a><a name="INDEX-266"></a> descriptor.
</p>



<a name="JBEANS-CH-2-SECT-1.3"></a>
<h3 class="sect2">2.1.3. The Unseen Pieces</h3>

<p>We've done a lot of hand waving about the strange relationships
between an enterprise bean and its interfaces. Now it's time to
talk a little more precisely about what's going on.
Unfortunately, we can't talk as precisely as we'd like.
There are a number of ways for an EJB container to implement these
relationships; we'll show some of the possibilities.
</p>

<p>The two missing pieces are the <a name="INDEX-267"></a>EJB object itself and the
<a name="INDEX-268"></a>EJB home.
You will probably never see the EJB home and EJB object classes
because their class definitions are proprietary to the vendor's
EJB implementation and are generally not made public. This is good
because it represents a separation of responsibilities along areas of
expertise. As an application developer, you are intimately familiar
with how your business environment works and needs to be modeled, so
you will focus on creating the applications and beans that describe
your business. System-level developers, the people who write EJB
servers, don't understand your business, but they do understand
how to develop CTMs and support distributed objects. It makes sense
for system-level developers to apply their skills to mechanics of
managing distributed objects but leave the business logic to you, the
application developer. Let's talk briefly about the EJB object
and the EJB home so you understand the missing pieces in the big
picture.
</p>

<a name="JBEANS-CH-2-SECT-1.3.1"></a>
<h3 class="sect3">2.1.3.1. The EJB object</h3>

<p>This chapter has said a lot about a bean's remote interface,
which extends the <a name="INDEX-269"></a><tt class="literal">EJBObject</tt> interface.
Who implements that interface? Clearly, the client
<a name="INDEX-270"></a><a name="INDEX-271"></a>stub: we understand that
much. But what about the <a name="INDEX-272"></a>server
side?
</p>

<p>On the server side, an EJB object is a distributed object that
implements the remote interface of the bean. It wraps the bean
instance--that is, the enterprise bean class you've
created (in our example, the <tt class="literal">CabinBean</tt>)--on
the server and expands its functionality to include
<tt class="literal">javax.ejb.EJBObject</tt> behavior. The EJB object is
generated by the utilities provided by the vendor of your EJB
container and is based on the bean classes and the information
provided by the deployment descriptor. The EJB object wraps the bean
instance and works with the container to apply transactions,
security, and other system-level operations to the bean at runtime.
<a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a> talks more about the EJB object's
role with regard to system-level operations.
</p>

<p>There are a number of strategies that a
<a name="INDEX-273"></a><a name="INDEX-274"></a>vendor can use to implement the
EJB object; <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a> illustrates three
possibilities.
</p>

<a name="JBEANS-CH-2-FIG-1"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0201.gif" webstripperlinkwas="figs/ejb2_0201.gif"></div>
<h4 class="objtitle">Figure 2-1. Three ways to implement the EJB object</h4>

<p>In <a href="#JBEANS-CH-2-FIG-1">Figure 2-1</a>(a) you see that the EJB object is a
classic wrapper because it holds a reference to the bean class and
delegates the requests to the bean. <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a>(b)
shows that the EJB object class actually extends the
<a name="INDEX-275"></a>bean class, adding functionality
specific to the EJB container. In <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a>(c),
you see that the bean class is no longer included in the model. In
this case, the EJB object has both a proprietary implementation
required by the EJB container and bean class method implementations
that were copied from the bean class's definition.
</p>

<p>The EJB object design that is shown in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a>(a) is perhaps the most common. Throughout this
book, particularly in the next chapter, we will explain how EJB works
with the assumption that the EJB object wraps the bean class instance
as depicted in <a href="#JBEANS-CH-2-FIG-1">Figure 2-1</a>(a). But the other
implementations are used; it shouldn't make a difference which
one your vendor has chosen. The bottom line is that you never really
know much about the EJB object: its implementation is up to the
vendor. Knowing that it exists and knowing that its existence answers
a lot of questions about how enterprise beans are structured, should
be sufficient. Everything that any client (including other enterprise
beans) really needs to know about any bean is described by the remote
and home interfaces.<a name="INDEX-276"></a>
</p>



<a name="JBEANS-CH-2-SECT-1.3.2"></a>
<h3 class="sect3">2.1.3.2. The EJB home</h3>

<p>The <a name="INDEX-277"></a>EJB
home is a lot like the EJB object. It's another class
that's generated automatically when you install an enterprise
bean in a <a name="INDEX-278"></a>container. It implements all
the methods defined by the home interface and is responsible for
helping the container in managing the bean's life cycle.
Working closely with the EJB container, the EJB home is responsible
for locating, creating, and removing enterprise beans. This may
involve working with the EJB server's resource managers,
instance pooling, and persistence mechanisms, the details of which
are hidden from the developer.
</p>

<p>
<a name="INDEX-279"></a><a name="INDEX-280"></a>For
example, when a create method is invoked on the home interface, the
EJB home creates an instance of the EJB object which references a
bean instance of the appropriate type. Once the bean instance is
associated with the EJB object, the instance's matching
<tt class="literal">ejbCreate()</tt> method is called. In the case of an
entity bean, a new record is inserted into the database. With session
beans the instance is simply initialized. Once the
<tt class="literal">ejbCreate()</tt> method has completed, the EJB home
returns a remote reference (i.e., a stub) for the EJB object to the
client. The client can then begin to work with the EJB object by
invoking <a name="INDEX-281"></a><a name="INDEX-282"></a>business methods using the stub. The
stub relays the methods to the EJB object; in turn, the EJB object
delegates those method calls to the bean instance.
</p>

<p>
<a href="#JBEANS-CH-2-FIG-2">Figure 2-2</a> illustrates the architecture of EJB with
the EJB home and EJB object implementing the home interface and
remote interface respectively. The bean class is also shown as being
wrapped by the EJB object.
</p>

<a name="JBEANS-CH-2-FIG-2"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0202.gif" webstripperlinkwas="figs/ejb2_0202.gif"></div>
<h4 class="objtitle">Figure 2-2. EJB architecture</h4>



<a name="JBEANS-CH-2-SECT-1.3.3"></a>
<h3 class="sect3">2.1.3.3. Deploying a bean</h3>

<p>
<a name="INDEX-283"></a><a name="INDEX-284"></a><a name="INDEX-285"></a>The EJB object and EJB home are
generated during the deployment process. After the files that define
the bean (the home interface, the remote interface, and the bean
classes) have been packaged into a JAR file, the bean is ready to be
deployed: that is, added to an EJB container so that it can be
accessed as a distributed component. During the deployment process,
tools provided by the EJB container vendor generate the EJB object
and EJB home classes by examining the deployment descriptor and the
other interfaces and <a name="INDEX-286"></a><a name="INDEX-287"></a> classes in the JAR
file.<a name="INDEX-288"></a><a name="INDEX-289"></a>
</p>












<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_08.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch01_08.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch02_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">1.8. What's Next?</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">2.2. Using Enterprise Beans</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
