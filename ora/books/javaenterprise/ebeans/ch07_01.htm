<html>
<head>
<title>Session Beans (Enterprise JavaBeans)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Richard Monson-Haefel">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-869-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Session Beans">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm" alt="Enterprise JavaBeans"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch06_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm">Enterprise JavaBeans</a></td><td align="right" valign="top" width="172"><a href="ch07_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h1 class="chapter">Chapter 7.  Session Beans</h1>
<div class="htmltoc">
<h4 class="tochead">Contents:</h4>
<p>
<a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">The Stateless Session Bean</a>
<br>
<a href="ch07_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_02.htm">The Life Cycle of a Stateless Session Bean</a>
<br>
<a href="ch07_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_03.htm">The Stateful Session Bean</a>
<br>
<a href="ch07_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_04.htm">The Life Cycle of a Stateful Session Bean</a>
<br>
</p>
</div>


<p>
<a name="INDEX-1306"></a>
As you learned in <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>, entity beans provide
an object-oriented interface that makes it easier for developers to
create, modify, and delete data from the database. Entity beans make
developers more productive by encouraging reuse and by reducing
development costs. A concept like a Ship can be reused throughout a
business system without having to redefine, recode, or retest the
business logic and data access defined by the Ship bean.
</p>

<p>
<a name="INDEX-1307"></a><a name="INDEX-1308"></a>
However, entity beans are not the entire story. We have also seen
another kind of enterprise bean: the session bean. Session beans fill
the gaps left by entity beans. They are useful for describing
interactions between other beans (workflow) or for implementing
particular tasks. Unlike entity beans, session beans don't
represent shared data in the database, but they can access shared
data. This means that we can use session beans to read, update, and
insert data. For example, we might use a session bean to provide
lists of information, such as a list of all available cabins.
Sometimes we might generate the list by interacting with entity
beans, like the cabin list we developed in the TravelAgent bean in
<a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>. More frequently, session beans will
generate lists by accessing the database directly.
</p>

<p>So when do you use an entity bean and when do you use a session bean
to directly access data? Good question! As a rule of thumb, an entity
bean is developed to provide a safe and consistent interface to a set
of shared data that defines a concept. This data may be updated
frequently. Session beans access data that spans concepts, is not
shared, or is usually read-only.
</p>

<p>In addition to accessing data directly, session beans can represent
<em class="emphasis">workflow</em><a name="INDEX-1309"></a>. Workflow describes all
the steps required to accomplish a particular task, such as booking
passage on a ship or renting a video. Session beans are part of the
same business API as entity beans, but as workflow components, they
serve a different purpose. Session beans can manage the interactions
between entity beans, describing how they work together to accomplish
a specific task. The relationship between session beans and entity
beans is like the relationship between a script for a play and the
actors that perform the play. Where entity beans are the actors and
props, the session bean is the script. Actors and props without a
script can each serve a function individually, but only in the
context of a script can they tell a story. In terms of our example,
it makes no sense to have a database full of cabins, ships,
passengers, and other objects if we can't create interactions
between them, like booking a passenger for a cruise.
</p>

<p>Session beans are divided into two basic types:
<em class="emphasis">stateless</em> and <em class="emphasis">stateful.</em> A
<em class="emphasis">stateless</em> session bean is a collection of
related services, each represented by a method; the bean maintains no
state from one method invocation to the next. When you invoke a
method on a stateless session bean, it executes the method and
returns the result without knowing or caring what other requests have
gone before or might follow. Think of a stateless session bean as a
set of procedures or batch programs that execute a request based on
some parameters and return a result. Stateless session beans tend to
be general-purpose or reusable, such as a software service.
</p>

<p>
<a name="INDEX-1310"></a><a name="INDEX-1311"></a>A
<em class="emphasis">stateful</em> session bean is an extension of the
client application. It performs tasks on behalf of the client and
maintains state related to that client. This state is called
<em class="emphasis">conversational
state</em><a name="INDEX-1312"></a><a name="INDEX-1313"></a>because
it represents a continuing conversation between the stateful session
bean and the client. Methods invoked on a stateful session bean can
write and read data to and from this conversational state, which is
shared among all methods in the bean. Stateful session beans tend to
be specific to one scenario. They represent logic that might have
been captured in the client application of a two-tier system.
</p>

<p>Session beans, whether they are stateful or stateless, are not
<a name="INDEX-1314"></a>persistent like entity beans. In other
words, session beans are not saved to the database.
<a name="INDEX-1315"></a>Stateful session beans are dedicated to
one client and may have a preset timeout period. In EJB 1.0, the
timeout period, which is specified in the deployment descriptor, is
defined in seconds and is applied between business method invocations
by the client.Each time a business method is invoked, the timeout
clock is reset.<a href="#FOOTNOTE-1">[1]</a> In EJB 1.1, the bean deployer
declares the timeout in a vendor-dependent manner. Timeouts are no
longer included in the <a name="INDEX-1316"></a>deployment descriptor.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-1"></a>
<p>[1] This was not clearly defined in the
EJB 1.0 specification. As a result, some vendors incorrectly measure
the timeout period from the creation of the bean by the client, and
the timeout period is not reset between method invocations. Consult
your vendor's documentation to determine which strategy your
vendor employs.</p> </blockquote>

<p>If the client fails to use the stateful bean before it times out, the
bean instance is destroyed and the remote reference is invalidated.
This prevents the stateful session bean from lingering long after a
client has shut down or otherwise finished using it. A client can
also explicitly remove a stateful session bean by calling one of its
remove methods.
</p>

<p>Stateless session beans have longer lives because they don't
retain any <a name="INDEX-1317"></a>conversational state and are not
dedicated to one client, but they still aren't saved in a
database because they don't represent any data. Once a
stateless session bean has finished a method invocation for a client,
it can be reassigned to any other EJB object to service a new client.
A client can maintain a connection to a stateless session
bean's EJB object, but the bean instance itself is free to
service requests from anywhere. Because it doesn't contain any
state information, there's no difference between one client and
the next. Stateless session beans may also have a
<a name="INDEX-1318"></a>timeout period and can be removed by
the client, but the impact of these events is different than with a
stateful session bean. With a stateless session bean, a timeout or
remove operation simply invalidates the remote reference for that
client; the bean instance is not destroyed and is free to service
other client requests.
</p>



<h2 class="sect1">7.1. The Stateless Session Bean</h2>

<p>
<a name="INDEX-1319"></a>A stateless session bean is relatively
easy to develop and also very efficient. Stateless session beans
require few server resources because they are neither persistent nor
dedicated to one client. Because they aren't dedicated to one
client, many EJB objects can use just a few instances of a stateless
bean. A stateless session bean does not maintain
<a name="INDEX-1320"></a><a name="INDEX-1321"></a>conversational state relative to the
EJB object it is servicing, so it can be swapped freely between EJB
objects. As soon as a stateless instance services a method
invocation, it can be swapped to another EJB object immediately.
Because there is no conversational state, a stateless session bean
doesn't require passivation or activation, further reducing the
overhead of swapping. In short, they are lightweight and fast!
</p>

<p>Stateless session beans often perform services that are fairly
generic and reusable. The services may be related, but they are not
interdependent. This means that everything a stateless session bean
method needs to know has to be passed via the method's
parameters. The only exception to this rule is information obtainable
from the <tt class="literal">SessionContext</tt> and in EJB 1.1, the JNDI
ENC. This provides an interesting limitation. Stateless session beans
can't remember anything from one method invocation to the next,
which means that they have to take care of the entire task in one
method invocation.
</p>

<p>Stateless session beans are EJB's version of the traditional
transaction processing applications, which are executed using a
procedure call. The procedure executes from beginning to end and then
returns the result. Once the procedure is done, nothing about the
data that was manipulated or the details of the request are
remembered. There is no state.
</p>

<p>These restrictions don't mean that a stateless session bean
can't have <a name="INDEX-1322"></a><a name="INDEX-1323"></a>instance variables and therefore
some kind of internal state. There's nothing that prevents you
from keeping a variable that tracks the number of times a bean has
been called or that tracks data for debugging. An instance variable
can even hold a reference to a live resource like a URL connection
for writing debugging data, verifying credit cards, or anything else
that might be useful. However, it's important to remember that
this state can never be visible to a client. A client can't
assume that the same bean instance will service it every time. If
these instance variables have different values in different bean
instances, their values will appear to change randomly as stateless
session beans are swapped from one client to another. Therefore, any
resources that you reference in instance variables should be generic.
For example, each bean instance might reasonably record debugging
messages in a different file--that might be the only way to
figure out what was happening on a large server with many bean
instances. The client doesn't know or care where debugging
output is going. However, it would be clearly inappropriate for a
stateless bean to remember that it was in the process of making a
reservation for Madame X--the next time it is called, it may be
servicing another client entirely.
</p>

<p>
<a name="INDEX-1324"></a>
Stateless session beans can be used for report generation, batch
processing, or some stateless services like validating a credit card.
Another good application would be a StockQuote bean that returns a
stock's current price. Any activity that can be accomplished in
one method call is a good candidate for the high-performance
stateless session bean.
</p>

<a name="JBEANS-CH-7-SECT-1.1"></a>
<h3 class="sect2">7.1.1. Downloading the Missing Pieces</h3>

<p>
<a name="INDEX-1325"></a><a name="INDEX-1326"></a><a name="INDEX-1327"></a>Both the TravelAgent bean and the
<a name="INDEX-1328"></a><a name="INDEX-1329"></a>
ProcessPayment beans, which we develop in this chapter, depend on
other entity beans, some of which we developed earlier in this book
and several that you can download from O'Reilly's web
site. The Cabin was developed in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, but we
still need several other beans to develop this example. The other
beans are the Cruise, Customer, and Reservation beans. The source
code for these beans is available with the rest of the examples for
this book at the O'Reilly download site. Instructions for
downloading code are available in the preface of this book.
</p>

<p>Before you can use these beans, you will need to create some new
tables in your database. Here are the <a name="INDEX-1330"></a>table definitions that the new entity
beans will need. The Cruise bean maps to the
<tt class="literal">CRUISE</tt> table:
</p>

<blockquote>
<pre class="programlisting">CREATE TABLE CRUISE 
(
   ID         INT PRIMARY KEY, 
   NAME       CHAR(30), 
   SHIP_ID    INT
)</pre>
</blockquote>

<p>The Customer bean maps to the <tt class="literal">CUSTOMER</tt> table:</p>

<blockquote>
<pre class="programlisting">CREATE TABLE CUSTOMER
(
   ID             INT PRIMARY KEY, 
   FIRST_NAME     CHAR(30), 
   LAST_NAME      CHAR(30), 
   MIDDLE_NAME    CHAR(30)
)</pre>
</blockquote>

<p>The Reservation bean maps to the <tt class="literal">RESERVATION</tt> table:</p>

<blockquote>
<pre class="programlisting">CREATE TABLE RESERVATION 
(
   CUSTOMER_ID    INT, 
   CABIN_ID       INT, 
   CRUISE_ID      INT, 
   PRICE          NUMERIC
)</pre>
</blockquote>

<p>Once you have created the tables, deploy these beans as
container-managed entities in your EJB server and test them to ensure
that they are working properly.
</p>


<a name="JBEANS-CH-7-SECT-1.2"></a>
<h3 class="sect2">7.1.2. The ProcessPayment Bean</h3>

<p>
<a name="INDEX-1331"></a><a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a> and <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a> discussed the
TravelAgent bean, which had a business method called
<tt class="literal">bookPassage()</tt>. This bean demonstrated how a
session bean manages workflow. Here is the code for
<tt class="literal">bookPassage()</tt><a name="INDEX-1332"></a>:
</p>

<blockquote>
<pre class="programlisting">public Ticket bookPassage(CreditCard card, double price)
    throws IncompleteConversationalState {// EJB 1.0: also throws RemoteException
                
    if (customer == null || cruise == null || cabin == null) {
        throw new IncompleteConversationalState();
    }
    try {
        ReservationHome resHome = (ReservationHome)
            getHome("ReservationHome",ReservationHome.class);
        Reservation reservation =
        resHome.create(customer, cruise, cabin, price);
        ProcessPaymentHome ppHome = (ProcessPaymentHome)
            getHome("ProcessPaymentHome",ProcessPaymentHome.class);
        ProcessPayment process = ppHome.create();
        process.byCredit(customer, card, price);

        Ticket ticket = new Ticket(customer, cruise, cabin, price);
        return ticket;
    } catch (Exception e) {
        // EJB 1.0: throw new RemoteException("",e);
        throw new EJBException(e);
    }
}</pre>
</blockquote>

<p>In the next section, we will develop a complete definition of the
TravelAgent bean, including the logic of the
<tt class="literal">bookPassage()</tt> method. At this point, however, we
are interested in the <a name="INDEX-1333"></a>ProcessPayment bean, which is a
stateless bean used by the TravelAgent bean. The TravelAgent bean
uses the ProcessPayment bean to charge the customer for the price of
the cruise.
</p>

<p>The process of charging customers is a common activity in
Titan's business systems. Not only does the reservation system
need to charge customers, but so do Titan's gift shops,
boutiques, and other related businesses. The process of charging a
customer for services is common to many systems, so it has been
encapsulated in its own bean.
</p>

<p>Payments are recorded in a special database table called
<tt class="literal">PAYMENT</tt>. The <tt class="literal">PAYMENT</tt> data is
batch processed for accounting purposes and is not normally used
outside of accounting. In other words, the data is only inserted by
Titan's system; it's not read, updated, or deleted.
Because the process of making a charge can be completed in one
method, and because the data is not updated frequently or shared, a
stateless session bean has been chosen for processing payments.
Several different forms of payment can be used: credit card, check,
or cash. We will model these payment forms in our stateless
ProcessPayment bean.
</p>

<a name="JBEANS-CH-7-SECT-1.2.1"></a>
<h3 class="sect3">7.1.2.1. PAYMENT: The database table</h3>

<p>
<a name="INDEX-1334"></a> The
ProcessPayment bean accesses an existing table in Titan's
system called the <tt class="literal">PAYMENT</tt> table. Create a table in
your database called <tt class="literal">PAYMENT</tt> with this definition:
</p>

<blockquote>
<pre class="programlisting">CREATE TABLE PAYMENT 
(
    customer_id     NUMERIC, 
    amount          DECIMAL(8,2), 
    type            CHAR(10), 
    check_bar_code  CHAR(50),
    check_number    INTEGER,
    credit_number   NUMERIC, 
    credit_exp_date DATE
)</pre>
</blockquote>



<a name="JBEANS-CH-7-SECT-1.2.2"></a>
<h3 class="sect3">7.1.2.2. ProcessPayment: The remote interface</h3>

<p>
<a name="INDEX-1335"></a><a name="INDEX-1336"></a>A
stateless session bean, like any other bean, needs a
<a name="INDEX-1337"></a><a name="INDEX-1338"></a>remote interface. We obviously need
a <tt class="literal">byCredit()</tt> method because the TravelAgent bean
uses it. We can also identify two other methods that we'll
need: <tt class="literal">byCash()</tt> for customers paying cash and
<tt class="literal">byCheck()</tt> for customers paying with a personal
check.
</p>

<p>Here is a complete definition of the remote interface for the
ProcessPayment bean:
</p>

<blockquote>
<pre class="programlisting">package com.titan.processpayment;

import java.rmi.RemoteException;
import java.util.Date;
import com.titan.customer.Customer;

public interface ProcessPayment extends javax.ejb.EJBObject {

    public boolean <tt class="userinput"><b>byCheck</b></tt>(Customer customer, Check check, double amount)
      throws RemoteException,PaymentException;

    public boolean <tt class="userinput"><b>byCash</b></tt>(Customer customer, double amount)
      throws RemoteException,PaymentException;

    public boolean <tt class="userinput"><b>byCredit</b></tt>(Customer customer, CreditCard card, double amount)
      throws RemoteException,PaymentException;
}</pre>
</blockquote>

<p>Remote interfaces in session beans follow the same rules as the
entity beans. Here we have defined the three business methods,
<tt class="literal">byCheck()</tt>, <tt class="literal">byCash()</tt>, and
<tt class="literal">byCredit()</tt>, which take information relevant to the
form of payment used and return a <tt class="literal">boolean</tt> value
that indicates the success of the payment. In
<a name="INDEX-1339"></a>addition to the
required
<tt class="literal">RemoteException</tt><a name="INDEX-1340"></a>, these methods can throw an
<a name="INDEX-1341"></a>application-specific exception, the
<tt class="literal">PaymentException</tt>. The
<tt class="literal">PaymentException</tt> is thrown if any problems occur
while processing the payment, such as a low check number or an
expired credit card. Notice, however, that nothing about the
<tt class="literal">ProcessPayment</tt> interface is specific to the
reservation system. It could be used just about anywhere in
Titan's system. In addition, each method defined in the remote
interface is completely independent of the others. All the data that
is required to process a payment is obtained through the
method's arguments.
</p>

<p>As an extension of the <tt class="literal">javax.ejb.EJBObject</tt>
interface, the remote interface of a session bean inherits the same
functionality as the remote interface of an entity bean. However, the
<tt class="literal">getPrimaryKey()</tt><a name="INDEX-1342"></a>
 method throws a <tt class="literal">RemoteException</tt>, since session
beans do not have a <a name="INDEX-1343"></a>primary key to return:<a href="#FOOTNOTE-2">[2]</a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-2"></a>
<p>[2]
The exact behavior of primary key related operations on session beans
is undefined in EJB 1.0. Because it is undefined, certain vendors may
choose to return <tt class="literal">null</tt> or throw a different
exception when these methods are invoked. The behavior described
here, however, is the recommended behavior for EJB 1.0 -compliant
servers and is the required behavior in EJB 1.1.</p> </blockquote>

<blockquote>
<pre class="programlisting">public interface javax.ejb.EJBObject extends java.rmi.Remote {
    public abstract EJBHome getEJBHome()
     throws RemoteException;
    public abstract Handle <tt class="userinput"><b>getHandle</b></tt>() 
     throws RemoteException;
    public abstract Object <tt class="userinput"><b>getPrimaryKey</b></tt>() 
     throws RemoteException;
    public abstract boolean isIdentical(EJBObject obj) 
     throws RemoteException;
    public abstract void remove() 
     throws RemoteException, RemoveException;
}</pre>
</blockquote>

<p>
<a name="INDEX-1344"></a><a name="INDEX-1345"></a>The
<tt class="literal">getHandle()</tt> method returns a
<a name="INDEX-1346"></a>
serializable handle object, just like the
<tt class="literal">getHandle()</tt> method in the entity bean. For
stateless session beans, this handle can be serialized and reused any
time, as long as the stateless bean type is still available in the
container that generated the handle.
</p>

<a name="ch07-6-fm2xml"></a>
<blockquote class="note">
<h4 class="objtitle">NOTE</h4>
<p>Unlike stateless session beans, <a name="INDEX-1347"></a><a name="INDEX-1348"></a>stateful session beans are only available through the handle for as long as that specific bean instance is kept alive on the EJB server. If the client explicitly destroys the stateful session bean using one of the <tt class="literal">remove()</tt> methods, or if the bean times out, the instance is destroyed and the handle becomes invalid. As soon as the server removes a stateful session bean, its handle is no longer valid and will throw a <tt class="literal">RemoteException</tt> when its <tt class="literal">getEJBObject()</tt> is invoked.</p>
</blockquote>

<p>A <a name="INDEX-1349"></a>remote reference to the
bean can be obtained from the handle by invoking its
<tt class="literal">getEJBObject()</tt> method:
</p>

<blockquote>
<pre class="programlisting">public interface javax.ejb.Handle {
    public abstract EJBObject <tt class="userinput"><b>getEJBObject</b></tt>()
      throws RemoteException;
}</pre>
</blockquote>

<p>We've placed the ProcessPayment bean in its own package, which
means it has its own directory in our development tree,
<em class="filename">dev/com/titan/processpayment</em>. That's where
we'll store all the code and compile class files for this bean.
</p>



<a name="ch07-7-fm2xml"></a>
<h3 class="sect3">7.1.2.3. Dependent classes: The CreditCard and Check classes</h3>
<p>
<a name="INDEX-1350"></a><a name="INDEX-1351"></a>

The ProcessPayment bean's <a name="INDEX-1352"></a>remote interface uses two classes in its
definition that are particularly interesting: the
<tt class="literal">CreditCard</tt> and <tt class="literal">Check</tt> classes.
The definitions for these classes are as follows:
</p>

<blockquote>
<pre class="programlisting">/* CreditCard.java */
package com.titan.processpayment;

import java.util.Date;

public class CreditCard implements java.io.Serializable {
    final static public String MASTER_CARD = "MASTER_CARD";
    final static public String VISA = "VISA";
    final static public String AMERICAN_EXPRESS = "AMERICAN_EXPRESS";
    final static public String DISCOVER = "DISCOVER";
    final static public String DINERS_CARD = "DINERS_CARD";

    public long number;
    public Date expiration;
    public String type;

    public CreditCard(long nmbr, Date exp, String typ) {
        number = nmbr;
        expiration = exp;
        type = typ;
    }
}

/* Check.java */
package com.titan.processpayment;

public class Check implements java.io.Serializable {
    String checkBarCode;
    int checkNumber;
    public Check(String barCode, int number) {
        checkBarCode = barCode;
        checkNumber = number;
    }
}</pre>
</blockquote>

<p>
<a name="INDEX-1353"></a><a name="INDEX-1354"></a>If you examine the class definitions of
the <tt class="literal">CreditCard</tt> and <tt class="literal">Check</tt>
classes, you will see that they are not enterprise beans. They are
simply serializable Java classes. These classes provide a convenient
mechanism for transporting and binding together related data.
<tt class="literal">CreditCard</tt>, for example, binds all the credit card
data together in once class, making it easier to pass the information
around as well as making our interfaces a little cleaner.
</p>

<p>It may be <a name="INDEX-1355"></a>surprising that these classes aren't
entity beans, and there's certainly no restriction in the
specification preventing you from implementing them that way.
However, just because something can be an entity bean doesn't
mean that it has to be, and in this case, there are good reasons for
this design decision. Making everything an entity bean is unnecessary
and will hurt the performance of your EJB application. Remember that
supporting an entity bean requires a lot of overhead on the
server's part. When that overhead isn't necessary,
it's best avoided. Fine-grained, dependent objects like
<tt class="literal">Check</tt> and <tt class="literal">CreditCard</tt>
don't make practical entity beans, because they are not shared
or changed over time and they are dependent on the
<tt class="literal">Customer</tt> to provide them with context. The use of
dependent classes should be limited to <a name="INDEX-1356"></a>pass-by-value objects, which is explored
in more detail in <a href="ch09_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch09_01.htm">Chapter 9, "Design Strategies"</a>.
</p>



<a name="JBEANS-CH-7-SECT-1.2.4"></a>
<h3 class="sect3">7.1.2.4. PaymentException: An application exception</h3>

<p>Any remote interface, whether it's for an entity bean or a
session bean, can throw <a name="INDEX-1357"></a><a name="INDEX-1358"></a>application exceptions, in addition to
the required <tt class="literal">RemoteException</tt>. Application
exceptions are created by the bean developer and should describe a
business logic problem--in this particular case, a problem
making a payment. Application exceptions should be meaningful to the
client, providing an explanation of the error that is both brief and
relevant.
</p>

<p>
<a name="INDEX-1359"></a><a name="INDEX-1360"></a>It's important to understand what
exceptions to use and when to use them. The
<tt class="literal">RemoteException</tt> indicates subsystem-level problems
and is used by the RMI facility. Likewise, exceptions like
<tt class="literal">javax.naming.NamingException</tt> and
<tt class="literal">java.sql.SQLException</tt> are thrown by other Java
subsystems; usually these should not be thrown explicitly by your
beans. The Java Compiler requires that you use
<tt class="literal">try</tt>/<tt class="literal">catch</tt> blocks to capture
checked exceptions like these.
</p>

<dl>
<dt>
<b>EJB 1.1 <a name="INDEX-1361"></a>
<a name="INDEX-1362"></a>
subsystem exceptions</b>
</dt>
<dd>
<p>When a <a name="INDEX-1363"></a>checked exception from a subsystem (
JDBC, JNDI, JMS, etc.) is caught by a bean method, it should be
rethrown as an <tt class="literal">EJBException</tt> or an application
exception. You would rethrow a checked exception as an
<tt class="literal">EJBException</tt> if it represented a system-level
problem; checked exceptions are rethrown as application exceptions
when they result from business logic problems. Your beans incorporate
your business logic; if a problem occurs in the business logic, that
problem should be represented by an application exception. When an
<tt class="literal">EJBException</tt> is thrown, it's first processed
by the container, and then a <tt class="literal">RemoteException</tt> is
thrown to the client.
</p>
</dd>

<dt>
<b>EJB 1.0 subsystem exceptions</b>
</dt>
<dd>
<p>When a checked exception from a subsystem (JDBC, JNDI, JMS, etc.) is
caught by a bean method, it should be rethrown as a
<tt class="literal">RemoteException</tt> or an application exception. You
would rethrow a checked exception as a
<tt class="literal">RemoteException</tt> if it represented a system-level
problem; checked exceptions are rethrown as application exceptions
when they result from business logic problems. Your beans incorporate
your business logic; if a problem occurs in the
<a name="INDEX-1364"></a>
business logic, that problem should be represented by an application
exception.
</p>
</dd>

</dl>

<p>In either EJB 1.0 or EJB 1.1, if an unchecked exception, like
<tt class="literal">java.lang.NullPointerException</tt>, is thrown by the
bean instance, the container automatically throws a
<tt class="literal">RemoteException</tt> to the client.
</p>

<p>The <tt class="literal">PaymentException</tt> describes a specific business
problem, so it is an application exception. Application exceptions
extend <tt class="literal">java.lang.Exception</tt>. If you choose to
include any instance variables in the exception, they should all be
serializable. Here is the definition of
<tt class="literal">ProcessPayment</tt> application exception:
<a name="INDEX-1365"></a><a name="INDEX-1366"></a>
</p>

<blockquote>
<pre class="programlisting">package com.titan.processpayment;

public class PaymentException extends java.lang.Exception {
    public PaymentException() {
        super();
    }
    public PaymentException(String msg) {
        super(msg);
    }
}</pre>
</blockquote>



<a name="JBEANS-CH-7-SECT-1.2.5"></a>
<h3 class="sect3">7.1.2.5. ProcessPaymentHome: The home interface</h3>

<p>
<a name="INDEX-1367"></a><a name="INDEX-1368"></a>The home interface of all stateless
session beans contains one <a name="INDEX-1369"></a><tt class="literal">create()</tt> method with no arguments. This is a
requirement of the EJB specification. It is illegal to define
<tt class="literal">create()</tt> methods with arguments, because stateless
session beans don't maintain conversational state that needs to
be initialized. There are no find methods in session beans, because
session beans do not have primary keys and do not represent data in
the database. Here is the definition of the home interface for the
ProcessPayment bean:
</p>

<blockquote>
<pre class="programlisting">package com.titan.processpayment;

import java.rmi.RemoteException;
import javax.ejb.CreateException;

public interface ProcessPaymentHome extends javax.ejb.EJBHome {
   public ProcessPayment <tt class="userinput"><b>create</b></tt>()
       throws RemoteException, CreateException;
}</pre>
</blockquote>

<p>
<a name="INDEX-1370"></a>The
<tt class="literal">CreateException</tt> is mandatory, as is the
<tt class="literal">RemoteException</tt>. The
<tt class="literal">CreateException</tt> can be thrown by the bean itself
to indicate an application error in creating the bean. A
<tt class="literal">RemoteException</tt> is thrown when other system errors
occur, for example, when there is a problem with network
communication or when an unchecked exception is thrown from the bean
class.
</p>

<p>The <tt class="literal">ProcessPaymentHome</tt> interface, as an extension
of the <tt class="literal">javax.ejb.EJBHome</tt>, offers the same
<tt class="literal">EJBHome</tt> methods as entity beans. The only
difference is that <tt class="literal">remove(Object</tt><tt class="literal">primaryKey)</tt> doesn't work because session
beans don't have primary keys. If
<tt class="literal">EJBHome.remove(Object</tt><tt class="literal">primaryKey)</tt> is invoked on a session bean
(stateless or stateful), a <tt class="literal">RemoteException</tt> is
thrown.<a href="#FOOTNOTE-3">[3]</a> Logically, this method should
never be invoked on the home interface of a session bean.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-3"></a>
<p>[3] The exact behavior of the
<tt class="literal">EJBHome.remove(ObjectprimaryKey)</tt> in session beans
is undefined in EJB 1.0. The recommended behavior in EJB 1.0 is to
throw a <tt class="literal">RemoteException</tt>, which is the specified
behavior in the EJB 1.1 specification. Check your vendor's
documentation to determine how this behavior was implemented for EJB
1.0 containers.</p> </blockquote>

<p>Here are the definitions of the
<tt class="literal">EJBHome</tt><a name="INDEX-1371"></a> interface for EJB 1.1 and EJB 1.0:
</p>

<blockquote>
<pre class="programlisting">// EJBHome interface, EJB 1.1
public interface javax.ejb.EJBHome extends java.rmi.Remote {
   public abstract HomeHandle getHomeHandle()
     throws RemoteException;
   public abstract EJBMetaData <tt class="userinput"><b>getEJBMetaData</b></tt>()
     throws RemoteException;
   public abstract void remove(Handle handle)
     throws RemoteException, RemoveException;
   public abstract void <tt class="userinput"><b>remove</b></tt>(Object primaryKey)
     throws RemoteException, RemoveException;
}

// EJBHome interface, EJB 1.0
public interface javax.ejb.EJBHome extends java.rmi.Remote {
   public abstract EJBMetaData <tt class="userinput"><b>getEJBMetaData</b></tt>()
     throws RemoteException;
   public abstract void remove(Handle handle)
     throws RemoteException, RemoveException;
   public abstract void <tt class="userinput"><b>remove</b></tt>(Object primaryKey)
     throws RemoteException, RemoveException;
}</pre>
</blockquote>

<p>The home interface of a session bean can return the
<tt class="literal">EJBMetaData</tt> for the bean, just like an entity
bean. <tt class="literal">EJBMetaData</tt> is a serializable object that
provides information about the bean's interfaces. The only
difference between the
<tt class="literal">EJBMetaData</tt><a name="INDEX-1372"></a><a name="INDEX-1373"></a> for a session bean and an entity bean
is that the
<tt class="literal">getPrimaryKeyClass()</tt><a name="INDEX-1374"></a>
 on the session bean's <tt class="literal">EJBMetaData</tt> throws a
<tt class="literal">java.lang.RuntimeException</tt> when invoked:<a href="#FOOTNOTE-4">[4]</a>
</p>
<blockquote class="footnote">
<a name="FOOTNOTE-4"></a>
<p>[4] The exact behavior of the
<tt class="literal">MetaData.getPrimaryKeyClass()</tt> method is undefined
for session beans in EJB 1.0. The recommended behavior in EJB 1.0 is
to throw a runtime exception, which is the specified behavior in the
EJB 1.1 specification.</p> </blockquote>

<blockquote>
<pre class="programlisting">public interface javax.ejb.EJBMetaData {
    public abstract EJBHome <tt class="userinput"><b>getEJBHome</b></tt>();
    public abstract Class <tt class="userinput"><b>getHomeInterfaceClass</b></tt>();
    public abstract Class <tt class="userinput"><b>getPrimaryKeyClass</b></tt>();
    public abstract Class <tt class="userinput"><b>getRemoteInterfaceClass</b></tt>();
    public abstract boolean <tt class="userinput"><b>isSession</b></tt>();
    public abstract boolean isStateless();  // EJB 1.0 only
}</pre>
</blockquote>



<a name="JBEANS-CH-7-SECT-1.2.6"></a>
<h3 class="sect3">7.1.2.6. ProcessPaymentBean: The bean class</h3>

<p>
<a name="INDEX-1375"></a><a name="INDEX-1376"></a>As
stated earlier, the ProcessPayment bean accesses data that is not
generally shared by systems, so it is an excellent candidate for a
stateless session bean. This bean really represents a set of
independent operations that can be invoked and then thrown
away--another indication that it's a good candidate for a
stateless session bean. Here is the complete definition of our
<tt class="literal">ProcessPaymentBean</tt> class:
</p>

<blockquote>
<pre class="programlisting">package com.titan.processpayment;
import com.titan.customer.*;

import java.sql.*;
import java.rmi.RemoteException;
import javax.ejb.SessionContext;

import javax.naming.InitialContext;
import javax.sql.DataSource;
import javax.ejb.EJBException;
import javax.naming.NamingException;

public class ProcessPaymentBean implements javax.ejb.SessionBean {

    final public static String CASH = "CASH";
    final public static String CREDIT = "CREDIT";
    final public static String CHECK = "CHECK";
        
    public SessionContext context;

    public void ejbCreate() {
    }
    
    public boolean byCash(Customer customer, double amount)
    throws PaymentException{// EJB 1.0: also throws RemoteException
        return process(getCustomerID(customer),amount,
                       CASH,null,-1,-1,null);
    }
    
    public boolean byCheck(Customer customer, Check check, double amount)
    throws PaymentException{// EJB 1.0: also throws RemoteException
        int minCheckNumber = getMinCheckNumber();
        if (check.checkNumber &gt; minCheckNumber) {
            return process(getCustomerID(customer), amount, CHECK, 
                           check.checkBarCode,check.checkNumber,-1,null);
        }
        else {
           throw new PaymentException(
              "Check number is too low. Must be at least "+minCheckNumber);
        }
    }
    public boolean byCredit(Customer customer, CreditCard card, double amount)
    throws PaymentException {// EJB 1.0: also throws RemoteException
        if (card.expiration.before(new java.util.Date())) {
             throw new PaymentException("Expiration date has passed");
        }
        else {
            return process(getCustomerID(customer), amount, CREDIT, null,
                           -1, card.number,
                           new java.sql.Date(card.expiration.getTime()));
        }
    }
    private boolean process(long customerID, double amount, String type,
                            String checkBarCode, int checkNumber,
                            long creditNumber, java.sql.Date creditExpDate)
        throws PaymentException{// EJB 1.0: also throws RemoteException

        Connection con = null;
        
        PreparedStatement ps = null;

        try {
            con = getConnection();
            ps = con.prepareStatement
                ("INSERT INTO payment (customer_id, amount, type,"+ 
                  "check_bar_code,check_number,credit_number,"+
                  "credit_exp_date) VALUES (?,?,?,?,?,?,?)");
            ps.setLong(1,customerID);
            ps.setDouble(2,amount);
            ps.setString(3,type);
            ps.setString(4,checkBarCode);
            ps.setInt(5,checkNumber);
            ps.setLong(6,creditNumber);
            ps.setDate(7,creditExpDate);
            int retVal = ps.executeUpdate();
            if (retVal!=1) {
                // EJB 1.0: throw new RemoteException("Payment insert failed");
                throw new EJBException("Payment insert failed");
            }
            
            return true;
        } catch(SQLException sql) {
             // EJB 1.0: throw new RemoteException("",sql);
             throw new EJBException(sql);
        } finally {
             try {
                 if (ps != null) ps.close();
                 if (con!= null) con.close();
             } catch(SQLException se){se.printStackTrace();}
        }
    }
    public void ejbActivate() {}
    public void ejbPassivate() {}
    public void ejbRemove() {}
    public void setSessionContext(SessionContext ctx) {
        context = ctx;
    }
    private int getCustomerID(Customer customer) {
    // EJB 1.0: throws RemoteException
        try {// EJB 1.0: remove try/catch
            return ((CustomerPK)customer.getPrimaryKey()).id;
        } catch(RemoteException re) {
            throw new EJBException(re);
        }
    }

    private Connection getConnection() throws SQLException {
        // Implementations for EJB 1.0 and EJB 1.1 shown below
    }
    private int getMinCheckNumber() {
        // Implementations for EJB 1.0 and EJB 1.1 shown below
    }
}</pre>
</blockquote>

<p>
<a name="INDEX-1377"></a><a name="INDEX-1378"></a>The three payment methods all use the
private helper method <tt class="literal">process()</tt>, which does the
work of adding the payment to the database. This strategy reduces the
possibility of programmer error and makes the bean easier to
maintain. The <tt class="literal">process()</tt> method simply inserts the
payment information into the <tt class="literal">PAYMENT</tt> table. The
use of JDBC in this method should be familiar to you from your work
on the bean-managed Ship bean in <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>. The
<a name="INDEX-1379"></a>JDBC connection is obtained from the
<tt class="literal">getConnection()</tt><a name="INDEX-1380"></a>
 method; here are the EJB 1.1 and EJB 1.0 versions of this method:
</p>

<blockquote>
<pre class="programlisting">// getConnection() for EJB 1.1
private Connection getConnection() throws SQLException {
    try {
        InitialContext jndiCntx = new InitialContext();
        DataSource ds = (DataSource)
            jndiCntx.lookup("java:comp/env/jdbc/titanDB");
        return ds.getConnection();
    } catch(NamingException ne){throw new EJBException(ne);}
}

// getConnection() for EJB 1.0
private Connection getConnection() throws SQLException {
    return DriverManager.getConnection(
        context.getEnvironment().getProperty("jdbcURL"));
}</pre>
</blockquote>

<p>Both the <tt class="literal">byCheck()</tt> and the
<tt class="literal">byCredit()</tt> methods contain some logic to validate
the data before processing it. The <tt class="literal">byCredit()</tt>
method checks to ensure that the credit card's expiration data
does not precede the current date. If it does, a
<tt class="literal">PaymentException</tt> is thrown.
</p>

<p>
<a name="INDEX-1381"></a><a name="INDEX-1382"></a><a name="INDEX-1383"></a>
The <tt class="literal">byCheck()</tt> method checks to ensure that the
check is above a minimum number, as determined by a property
that's defined when the bean is deployed. If the check number
is below this value, a <tt class="literal">PaymentException</tt> is thrown.
The property is obtained from the
<tt class="literal">getMinCheckNumber()</tt> method. In EJB 1.1, we can use
the JNDI ENC to read the value of the
<tt class="literal">minCheckNumber</tt> property. In 1.0, we read this
property from the <tt class="literal">SessionContext</tt>:
</p>

<blockquote>
<pre class="programlisting">// getMinCheckNumber() for EJB 1.1: uses JNDI ENC
private int getMinCheckNumber() {
         try {
            InitialContext jndiCntx = new InitialContext( );
            Integer value = (Integer)
                jndiCntx.lookup("java:comp/env/minCheckNumber");
            return value.intValue();
         } catch(NamingException ne){throw new EJBException(ne);}
}

// getMinCheckNumber() for EJB 1.0
private int getMinCheckNumber() {
  String min_check_string =
      context.getEnvironment().getProperty("minCheckNumber");
  return Integer.parseInt(min_check_string);
}</pre>
</blockquote>

<p>Thus, we are using an <a name="INDEX-1384"></a>environment property, set in the
deployment descriptor, to change the business behavior of a bean. It
is a good idea to capture thresholds and other limits in the
environment properties of the bean rather than hardcoding them. This
gives you greater flexibility. If, for example, Titan decided to
raise the minimum check number, you would only need to change the
bean's deployment descriptor, not the class definition. (You
could also obtain this type of information directly <a name="INDEX-1385"></a><a name="INDEX-1386"></a> from the database.)
</p>



<a name="JBEANS-CH-7-SECT-1.2.7"></a>
<h3 class="sect3">7.1.2.7. EJB 1.1: Accessing environment properties</h3>

<p>In EJB 1.1, the bean container contract has been extended to include
the <a name="INDEX-1387"></a><a name="INDEX-1388"></a>
JNDI environment naming context ( JNDI ENC). The JNDI ENC is a JNDI
name space that is specific to each bean type. This name space can be
referenced from within any bean, not just entity beans, using the
name <tt class="literal">"java:comp/env"</tt>. The enterprise naming
context provides a flexible, yet standard, mechanism for accessing
properties, other beans, and resources from the container.
</p>

<p>We've already seen the JNDI ENC several times. In <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>, we used it to access a resource factory, the
<tt class="literal">DataSource</tt>. The
<tt class="literal">ProcessPaymentBean</tt> also uses the JNDI ENC to
access a <tt class="literal">DataSource</tt> in the
<tt class="literal">getConnection()</tt> method; further, it uses the ENC
to access an environment property in the
<tt class="literal">getMinCheckNumber()</tt> method. This section examines
the use of the JNDI ENC to access environment properties.
</p>

<p>Named properties can be declared in a bean's deployment
descriptor. The bean accesses these properties at runtime by using
the JNDI ENC. Properties can be of type <tt class="literal">String</tt> or
one of several primitive wrapper types including
<tt class="literal">Integer</tt>, <tt class="literal">Long</tt>,
<tt class="literal">Double</tt>, <tt class="literal">Float</tt>,
<tt class="literal">Byte</tt>, <tt class="literal">Boolean</tt>, and
<tt class="literal">Short</tt>. By modifying the deployment descriptor, the
bean deployer can change the bean's behavior without changing
its code. As we've seen in the ProcessPayment bean, we could
change the minimum check number that we're willing to accept by
modifying the <tt class="literal">minCheckNumber</tt> property at
deployment. Two ProcessPayment beans deployed in different containers
could easily have different minimum check numbers, as shown in the
following example:
</p>

<blockquote>
<pre class="programlisting">&lt;ejb-jar&gt;
    &lt;enterprise-beans&gt;
        &lt;session&gt;
            &lt;env-entry&gt;
                &lt;env-entry-name&gt;minCheckNumber&lt;/env-entry-name&gt;
                &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt;
                &lt;env-entry-value&gt;2000&lt;/env-entry-value&gt;
            &lt;/env-entry&gt;
            ...
        &lt;/session&gt;
        ...
    &lt;enterprise-beans&gt;
    ...
&lt;/ejb-jar&gt;</pre>
</blockquote>



<a name="JBEANS-CH-7-SECT-1.2.8"></a>
<h3 class="sect3">7.1.2.8. EJB 1.1: EJBContext</h3>

<p>The
<tt class="literal">EJBContext.getEnvironment()</tt><a name="INDEX-1389"></a><a name="INDEX-1390"></a> method is optional in EJB 1.1,
which means that it may or may not be supported. If it is not
functional, the method will throw a
<tt class="literal">RuntimeException</tt>. If it is functional, it returns
only those values declared in the deployment descriptor as follows
(where <tt class="literal">minCheckNumber</tt> is the property name):
</p>

<blockquote>
<pre class="programlisting">&lt;ejb-jar&gt;
    &lt;enterprise-beans&gt;
        &lt;session&gt;
            &lt;env-entry&gt;
                &lt;env-entry-name&gt;ejb10-properties/minCheckNumber&lt;/env-entry-name&gt;
                &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-name&gt;
                &lt;env-entry-value&gt;20000&lt;/env-entry-value&gt;
            &lt;/env-entry&gt;
            ...
        &lt;/session&gt;
        ...
    &lt;/enterprise-beans&gt;
     ...
&lt;/ejb-jar&gt;</pre>
</blockquote>

<p>The <tt class="literal">ejb10-properties</tt> subcontext specifies that the
property <tt class="literal">minCheckNumber</tt> is available from both
JNDI ENC context
<tt class="literal">"java:comp/env/ejb10-properties/minCheckNumber"</tt>
(as a <tt class="literal">String</tt> value), and from the
<tt class="literal">getEnvironment()</tt> method.
</p>

<p>Only those
<a name="INDEX-1391"></a><a name="INDEX-1392"></a>
properties declared under the <tt class="literal">ejb10-properties</tt>
subcontext are available via the <tt class="literal">EJBContext</tt>.
Furthermore, such properties are only available through the
<tt class="literal">EJBContext</tt> in containers that choose to support
the EJB 1.0 <tt class="literal">getEnvironment()</tt> method; all other
containers will throw a <tt class="literal">RuntimeException</tt>.
</p>



<a name="JBEANS-CH-7-SECT-1.2.9"></a>
<h3 class="sect3">7.1.2.9. EJB 1.1: The ProcessPayment bean's deployment descriptor</h3>

<p>Deploying <a name="INDEX-1393"></a>the
ProcessPayment bean presents no <a name="INDEX-1394"></a><a name="INDEX-1395"></a>significant problems. It's
essentially the same as deploying the Ship or Cabin beans, except
that the ProcessPayment bean has no primary key or persistent fields.
Here is the XML deployment descriptor for the ProcessPayment bean:
</p>

<blockquote>
<pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE ejb-jar PUBLIC "-//Sun Microsystems, Inc.//DTD Enterprise
JavaBeans 1.1//EN" "http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd"&gt;

&lt;ejb-jar&gt;
 &lt;enterprise-beans&gt;
   &lt;session&gt;
      &lt;description&gt;
            A service that handles monetary payments.
      &lt;/description&gt;
      &lt;ejb-name&gt;ProcessPaymentBean&lt;/ejb-name&gt;
      &lt;home&gt;com.titan.processpayment.ProcessPaymentHome&lt;/home&gt;
      &lt;remote&gt;com.titan.processpayment.ProcessPayment&lt;/remote&gt;
      &lt;ejb-class&gt;com.titan.processpayment.ProcessPaymentBean&lt;/ejb-class&gt;
      &lt;session-type&gt;Stateless&lt;/session-type&gt;
      &lt;transaction-type&gt;Container&lt;/transaction-type&gt;
      &lt;env-entry&gt;
           &lt;env-entry-name&gt;minCheckNumber&lt;/env-entry-name&gt;
           &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt;
           &lt;env-entry-value&gt;2000&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;resource-ref&gt;
           &lt;description&gt;DataSource for the Titan database&lt;/description&gt;
           &lt;res-ref-name&gt;jdbc/titanDB&lt;/res-ref-name&gt;
           &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
           &lt;res-auth&gt;Container&lt;/res-auth&gt;
      &lt;/resource-ref&gt;

  &lt;/session&gt;
 &lt;/enterprise-beans&gt;
 
 &lt;assembly-descriptor&gt;
   &lt;security-role&gt;
      &lt;description&gt;
         This role represents everyone who is allowed full access 
         to the ProcessPayment bean.
      &lt;/description&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
   &lt;/security-role&gt;

   &lt;method-permission&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
     &lt;method&gt;
         &lt;ejb-name&gt;ProcessPaymentBean&lt;/ejb-name&gt;
         &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
   &lt;/method-permission&gt;

   &lt;container-transaction&gt;
     &lt;method&gt;
        &lt;ejb-name&gt;ProcessPaymentBean&lt;/ejb-name&gt;
        &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
     &lt;trans-attribute&gt;Required&lt;/trans-attribute&gt;
   &lt;/container-transaction&gt;
 &lt;/assembly-descriptor&gt;
&lt;/ejb-jar&gt;</pre>
</blockquote>



<a name="JBEANS-CH-7-SECT-1.2.10"></a>
<h3 class="sect3">7.1.2.10. EJB 1.0: The ProcessPayment bean's deployment descriptor</h3>

<p>
<a name="INDEX-1396"></a><a name="INDEX-1397"></a>The
<tt class="literal">DeploymentDescriptor</tt> for the
<tt class="literal">ProcessPayment</tt> bean is created and serialized
using an application called <tt class="literal">MakeDD</tt>, which is
basically the same as the one used to create the
<em class="emphasis">TravelAgentDD.ser</em> file in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>:
</p>

<blockquote>
<pre class="programlisting">package com.titan.processpayment;

import javax.ejb.deployment.*;
import javax.naming.CompoundName;

import java.util.*;
import java.io.*;

public class MakeDD {

    public static void main(String args []) {
        try {
        if (args.length &lt;1) {
            System.out.println("must specify target directory");
            return;
        }

        SessionDescriptor paymentDD = new SessionDescriptor();
        paymentDD.setRemoteInterfaceClassName(
          "com.titan.processpayment.ProcessPayment");
        paymentDD.setHomeInterfaceClassName(
          "com.titan.processpayment.ProcessPaymentHome");
        paymentDD.setEnterpriseBeanClassName(
          "com.titan.processpayment.ProcessPaymentBean");
        paymentDD.setSessionTimeout(60);
        paymentDD.setStateManagementType(
            SessionDescriptor.STATELESS_SESSION);

        Properties props = new Properties();
        props.put("jdbcURL","jdbc:<em class="replaceable">subprotocol</em>:<em class="replaceable">subname</em>"); 

        props.put("minCheckNumber","1000");
        paymentDD.setEnvironmentProperties(props);

        ControlDescriptor cd = new ControlDescriptor();
        cd.setIsolationLevel(ControlDescriptor.TRANSACTION_READ_COMMITTED);
        cd.setMethod(null);
        cd.setRunAsMode(ControlDescriptor.CLIENT_IDENTITY);
        cd.setTransactionAttribute(ControlDescriptor.TX_REQUIRED);
        ControlDescriptor [] cdArray = {cd};
        paymentDD.setControlDescriptors(cdArray);

        CompoundName jndiName = 
            new CompoundName("ProcessPaymentHome", new Properties());
        paymentDD.setBeanHomeName(jndiName);

        String fileSeparator = 
            System.getProperties().getProperty("file.separator");
        if (! args[0].endsWith(fileSeparator))
            args[0] += fileSeparator;

        FileOutputStream fis = 
            new FileOutputStream(args[0]+"ProcessPaymentDD.ser");
        ObjectOutputStream oos = new ObjectOutputStream(fis);
        oos.writeObject(paymentDD);
        oos.flush();
        oos.close();
        fis.close();
        } catch(Throwable t) {t.printStackTrace();}
    }
}</pre>
</blockquote>

<p>The class names, the JNDI name, and the environment properties are
the only differences between the two descriptors. We create a
properties table, add two properties to it, and call
<tt class="literal">setEnvironmentProperties()</tt> to install the table.
The two properties are <tt class="literal">"jdbcURL"</tt>, which tells the
bean how to contact the database, and
<tt class="literal">"minCheckNumber"</tt>, which tells the bean the minimum
check number that it is allowed to accept. You will need to replace
the value associated with the <tt class="literal">"jdbcURL"</tt>
environment property with a JDBC URL specific to your EJB server and
database.
</p>

<p>In this context, it's important to notice that the state
management type that we specify for this bean is
<tt class="literal">STATELESS_SESSION</tt>. In the deployment descriptor
for the TravelAgent bean, this was a piece of black magic that we
didn't really explain in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>. Now we
know what it means. This informs the container that the bean instance
can be swapped between method invocations from EJB object to EJB
object; it doesn't need to maintain conversational state.
</p>

<p>Deploy the ProcessPayment bean and make some payments. You should
also attempt to make payments in such a way that an application
exception is thrown. You could, for example, submit a check payment
with a check number that is too low or a credit card payment with an
expiration <a name="INDEX-1398"></a><a name="INDEX-1399"></a> date that has passed.
</p>












<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch06_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch07_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">6.3. The Life Cycle of an Entity Bean</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">7.2. The Life Cycle of a Stateless Session Bean</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
