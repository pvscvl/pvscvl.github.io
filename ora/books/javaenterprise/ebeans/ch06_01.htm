<html>
<head>
<title>Entity Beans (Enterprise JavaBeans)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Richard Monson-Haefel">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-869-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Entity Beans">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm" alt="Enterprise JavaBeans"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm">Enterprise JavaBeans</a></td><td align="right" valign="top" width="172"><a href="ch06_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h1 class="chapter">Chapter 6.  Entity Beans</h1>
<div class="htmltoc">
<h4 class="tochead">Contents:</h4>
<p>
<a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Container-Managed Persistence</a>
<br>
<a href="ch06_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_02.htm">Bean-Managed Persistence</a>
<br>
<a href="ch06_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_03.htm">The Life Cycle of an Entity Bean</a>
<br>
</p>
</div>


<p>
<a name="INDEX-905"></a>In
<a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, we started developing some simple
enterprise beans, skipping over a lot of the details in the process.
In this chapter, we'll take a thorough look at the process of
developing entity beans. On the surface, some of this material may
look familiar, but it is much more detailed and specific to entity
beans.
</p>

<p>Entity beans model <a name="INDEX-906"></a><a name="INDEX-907"></a>business concepts that can be expressed
as nouns. This is a rule of thumb rather than a requirement, but it
helps in determining when a business concept is a candidate for
implementation as an entity bean. In grammar school you learned that
nouns are words that describe a person, place, or thing. The concepts
of "person" and "place" are fairly obvious: a
person bean might represent a customer or a passenger, and a place
bean might represent a city or a port-of-call. Similarly, entity
beans often represent "things": real-world objects like
ships, cabins, and so on. A bean can even represent a fairly abstract
"thing," such as a ticket or a reservation. Entity beans
describe both the state and behavior of real-world objects and allow
developers to encapsulate the data and business rules associated with
specific concepts; a cabin bean encapsulates the data and business
rules associated with a cabin, and so on. This makes it possible for
data associated with a concept to be manipulated consistently and
safely.
</p>

<p>In Titan's cruise ship business, we can identify hundreds of
business concepts that are nouns and therefore could conceivably be
modeled by entity beans. We've already seen a simple Cabin bean
in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, and we'll develop a Ship bean
in this chapter. Titan could clearly make use of a PortOfCall bean, a
Passenger bean, and many others. Each of these business concepts
represents data that needs to be tracked and possibly manipulated.
Entities really represent data in the database, so changes to an
entity bean result in changes to the database.
</p>

<p>
<a name="INDEX-908"></a><a name="INDEX-909"></a>There are many advantages to
using entity beans instead of accessing the database directly.
Utilizing entity beans to objectify data provides programmers with a
simpler mechanism for accessing and changing data. It is much easier,
for example, to change a ship's name by calling
<tt class="literal">ship.setName()</tt> than to execute an SQL command
against the database. In addition, objectifying the data using entity
beans also provides for more software reuse. Once an entity bean has
been defined, its definition can be used throughout Titan's
system in a consistent manner. The concept of ship, for example, is
used in many areas of Titan's business, including booking,
scheduling, and marketing. A Ship bean provides Titan with one
complete way of accessing ship information, and thus it ensures that
access to the information is consistent and simple. Representing data
as entity beans makes development easier and more cost effective.
</p>

<p>When a new bean is created, a new record must be inserted into the
database and a bean instance must be associated with that data. As
the bean is used and its state changes, these changes must be
synchronized with the data in the database: entries must be inserted,
updated, and removed. <a name="INDEX-910"></a><a name="INDEX-911"></a>The process of coordinating the data
represented by a bean instance with the database is called
<em class="emphasis">persistence</em>.
</p>

<p>There are two types of entity beans, and they are distinguished by
how they manage persistence. <em class="emphasis">Container-managed</em>
beans have their persistence automatically managed by the EJB
container. The container knows how a bean instance's fields map
to the database and automatically takes care of inserting, updating,
and deleting the data associated with entities in the database. Beans
using <em class="emphasis">bean-managed</em> persistence do all this work
explicitly: the bean developer must write the code to manipulate the
database. The EJB container tells the bean instance when it is safe
to insert, update, and delete its data from the database, but it
provides no other help. The bean instance does all the persistence
work itself.
</p>

<p>The next two sections will describe how EJB works with
container-managed and bean- managed entity beans.
</p>



<h2 class="sect1">6.1. Container-Managed Persistence</h2>

<p>
<a name="INDEX-912"></a><a name="INDEX-913"></a>
Container-managed entity beans are the simplest to develop because
they allow you to focus on the business logic, delegating the
responsibility of persistence to the EJB container. When you deploy
the bean, you identify which fields in the entity are managed by the
container and how they map to the database. Once you have defined the
fields that will be automatically managed and how they map to the
database, the container generates the logic necessary to save the
bean instance's
<a name="INDEX-914"></a>state automatically.
</p>

<p>Fields that are mapped to the database are called
<a name="INDEX-915"></a>container-managed fields.
Container-managed fields can be any <a name="INDEX-916"></a><a name="INDEX-917"></a><a name="INDEX-918"></a><a name="INDEX-919"></a>Java primitive type or serializable
objects. Most beans will use Java primitive types when persisting to
a relational database, since it's easier to map Java primitives
to relational data types.
</p>

<a name="ch06-2-fm2xml"></a>
<blockquote class="note">
<h4 class="objtitle">NOTE</h4>
<p>EJB 1.1 also allows references to other beans to be <a name="INDEX-920"></a>container-managed fields. The EJB vendor must support converting bean references (remote or home interface types) from remote references to something that can be persisted in the database and converted back to a remote reference automatically. Vendors will normally convert remote references to primary keys, <tt class="literal">Handle</tt> or <tt class="literal">HomeHandle</tt> objects, or some other proprietary pointer type, which can be used to preserve the bean reference in the database. The container will manage this conversion from remote reference to persistent pointer and back automatically.</p>
</blockquote>

<p>The advantage of container-managed persistence is that the bean can
be defined independently of the database used to store its state.
Container-managed beans can take advantage of a
<a name="INDEX-921"></a>relational database or an
<a name="INDEX-922"></a>object-oriented database. The bean state
is defined independently, which makes the bean more reusable and
flexible across applications.
</p>

<p>The disadvantage of container-managed beans is that they require
sophisticated mapping tools to define how the bean's fields map
to the database. In some cases, this may be a simple matter of
mapping each field in the bean instance to a column in the database
or of serializing the bean to a file. In other cases, it may be more
difficult. The state of some beans, for example, may be defined in
terms of a complex relational database join or mapped to some kind of
legacy system such as CICS or IMS.
</p>

<p>In <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, we developed our first
container-managed bean, the Cabin bean. During the development of the
Cabin bean, we glossed over some important aspects of
container-managed entity beans. In this section, we will create a new
container-managed entity bean, the Ship bean, but this time we will
examine it in detail.
</p>

<p>Let's start by thinking about what we're trying to do. An
enormous amount of data would go into a complete description of a
ship, but for our purposes we will limit the scope of the data to a
small set of information. For now, we can say that a ship has the
following characteristics or attributes: its name, passenger
capacity, and tonnage (i.e., size). The Ship bean will encapsulate
this data; we'll need to create a <tt class="literal">SHIP</tt> table
in our database to hold this data. Here is the definition for the
<tt class="literal">SHIP</tt> table expressed in <a name="INDEX-923"></a><a name="INDEX-924"></a>
standard SQL:
</p>

<blockquote>
<pre class="programlisting">CREATE TABLE SHIP (ID INT PRIMARY KEY, NAME CHAR(30), CAPACITY INT, 
TONNAGE DECIMAL(8,2))</pre>
</blockquote>

<p>When defining any bean, we start by coding the remote interfaces.
This focuses our attention on the most important aspect of any bean:
its business purpose. Once we have defined the interfaces, we can
start working on the actual bean definition.
</p>

<a name="JBEANS-CH-6-SECT-1.1"></a>
<h3 class="sect2">6.1.1. The Remote Interface</h3>

<p>
<a name="INDEX-925"></a><a name="INDEX-926"></a><a name="INDEX-927"></a>For the Ship bean we will
need a <tt class="literal">Ship</tt> remote interface. This interface
defines the business methods that clients will use to interact with
the bean. When defining the remote interface, we will take into
account all the different areas in Titan's system that may want
to use the ship concept. Here is the remote interface for
<tt class="literal">Ship</tt>:
</p>

<blockquote>
<pre class="programlisting">package com.titan.ship;

import javax.ejb.EJBObject;
import java.rmi.RemoteException;

public interface Ship extends javax.ejb.EJBObject {
    public String getName() throws RemoteException;
    public void setName(String name) throws RemoteException;
    public void setCapacity(int cap) throws RemoteException;
    public int getCapacity() throws RemoteException;
    public double getTonnage() throws RemoteException;
    public void setTonnage(double tons) throws RemoteException;
}</pre>
</blockquote>

<p>We put this interface into the <tt class="literal">com.titan.ship</tt>
package, which we will use for all the components of the Ship bean.
This means that the code should reside in a development directory
named <em class="filename">dev/com/titan/ship</em>. This is the same
convention for package and directory names that we used for the Cabin
bean.
</p>

<a name="JBEANS-CH-6-SECT-1.1.1"></a>
<h3 class="sect3">6.1.1.1. Set and get methods</h3>

<p>The <tt class="literal">Ship</tt> definition <a name="INDEX-928"></a>uses a series of
<a name="INDEX-929"></a><a name="INDEX-930"></a>
accessor methods whose <a name="INDEX-931"></a><a name="INDEX-932"></a>names begin with
<tt class="literal">set</tt> and <tt class="literal">get</tt>. This is not a
required signature pattern, but it is the naming convention used by
most Java developers when obtaining and changing the values of object
attributes or fields. These methods are often referred to as
<em class="emphasis">setters</em> and <em class="emphasis">getters</em> (a.k.a.
<a name="INDEX-933"></a><a name="INDEX-934"></a>mutators and
accessors) and the attributes that they manipulate can be
called<a name="INDEX-935"></a><a name="INDEX-936"></a><em class="emphasis">properties</em>.<a href="#FOOTNOTE-1">[1]</a> These properties
should be defined independently of the anticipated storage structure
of the data. In other words, you should design the remote interface
to model the <a name="INDEX-937"></a>business concepts, not the underlying
data. Just because there's a <tt class="literal">capacity</tt>
property doesn't mean that there has to be a capacity field in
the bean or the database; the <tt class="literal">getCapacity()</tt> method
could conceivably compute the capacity from a list of cabins, by
looking up the ship's model and configuration, or with some
other algorithm.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-1"></a>
<p>[1]Although EJB is
different from its GUI counterpart, JavaBeans, the concept of
accessors and properties are similar. You can learn about this idiom
by reading <em class="emphasis">Developing Java Beans&#153;</em>by Rob
Englander (O'Reilly).</p> </blockquote>

<p>Defining <a name="INDEX-938"></a>entity properties according to the
business concept and not the underlying data is not always possible,
but you should try to employ this strategy whenever you can. The
reason is two-fold. First, the underlying data doesn't always
clearly define the business purpose or concept being modeled by the
entity bean. Remote interfaces will be used by developers who know
the business, not the database configuration. It is important to them
that the entity bean reflect the business concept. Second, defining
the properties of the entity bean independent of the data allows the
bean and data to evolve separately. This is important because it
allows a database implementation to change over time; it also allows
for new behavior to be added to the entity bean as needed. If the
bean's definition is independent of the data source, the impact
of these <a name="INDEX-939"></a><a name="INDEX-940"></a><a name="INDEX-941"></a>
evolutions is limited.
</p>



<a name="JBEANS-CH-6-SECT-1.2"></a>
<h3 class="sect2">6.1.2. The Primary Key</h3>

<p>
<a name="INDEX-942"></a><a name="INDEX-943"></a><a name="INDEX-944"></a>A primary key is an object that uniquely
identifies an entity bean according to the bean type, home interface,
and container context from which it is used.
</p>

<a name="JBEANS-CH-6-ADMON-2"></a>
<blockquote class="note">
<h4 class="objtitle">NOTE</h4>
<p>
EJB 1.1: In container-managed persistence, a primary key can be a serializable object defined specifically for the bean by the bean developer, or its definition can be deferred until deployment. We will examine deployer-defined primary keys later. For now we will consider primary keys defined by the bean developer.</p>
</blockquote>
<p>For our purposes, we will define all primary keys as serializable
classes with names that match the pattern
<em class="replaceable">BeanName</em><tt class="literal">PK</tt>. Therefore,
the primary key for the Ship bean will be <tt class="literal">ShipPK</tt>.
Unlike the remote interface and the home interface, the
<a name="INDEX-945"></a>primary key is a class, and its
definition is normally bound to the bean class definition, which we
have not yet addressed. Peeking ahead, however, we can make a
preliminary definition of a primary key that wraps an integer value
called <tt class="literal">id</tt>. Later, we will have to make sure that
this field has a corresponding field in the bean class with a
matching identifier (name) and data type.
</p>

<blockquote>
<pre class="programlisting">package com.titan.ship;

import java.io.Serializable;

public class ShipPK implements java.io.Serializable {

    public int id;

    public ShipPK() {}
    public ShipPK(int value) {
        id = value;
    }

    public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof ShipPK))
            return false;
        else if (((ShipPK)obj).id == id)
            return true;
        else
            return false;
    }
    public int hashCode(){
      return id;
    }

    public String toString(){
      return String.valueOf(id);
    }
}</pre>
</blockquote>

<p>The primary key defines attributes that can be used to locate a
specific bean in the database. In this case, we need only one
attribute, <tt class="literal">id</tt>, but in other cases, a primary key
may have several attributes, all of which uniquely identify a
bean's data.
</p>

<p>As discussed in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, primary keys should
override the <a name="INDEX-946"></a><a name="INDEX-947"></a><tt class="literal">equals()</tt> and
<tt class="literal">hashCode()</tt><a name="INDEX-948"></a> methods of <tt class="literal">Object</tt> to
ensure that these method behave properly when invoked. For example,
two <tt class="literal">ShipPK</tt> objects with the same
<tt class="literal">id</tt> value may not evaluate to the same hash code
unless the
<a name="INDEX-949"></a><tt class="literal">hashCode()</tt>
method is overridden as shown in the previous code example. This can
cause problems if you store primary keys in a hash table and expect
that primary keys for the same entity will evaluate to the same
position in the table. In addition, we have overridden the
<tt class="literal">toString()</tt><a name="INDEX-950"></a> method to return a meaningful value.
(The default implementation defined in <tt class="literal">Object</tt>
returns the class name of the object appended to the object identity
for that name space. Our implementation simply returns the
<tt class="literal">String</tt> value of the <tt class="literal">id</tt>, which
has more meaning.)
</p>

<p>The primary key for the Ship bean is fairly simple. More complex
keys--ones with multiple values--will require more
intelligent hash code algorithms to ensure as few collisions in a
hash table as possible.
</p>

<p>
<a name="INDEX-951"></a><a name="INDEX-952"></a>The
<tt class="literal">ShipPK</tt> class also defines two constructors: a
no-argument constructor and an overloaded constructor that sets the
<tt class="literal">id</tt> field. The overloaded constructor is a
convenience method that reduces the number of steps required to
create a primary key. The <a name="INDEX-953"></a>no-argument constructor is
<em class="emphasis">required</em> for
<a name="INDEX-954"></a><a name="INDEX-955"></a>
container-managed persistence. When a new bean is created, the
container automatically instantiates the primary key using the
<tt class="literal">Class.newInstance()</tt><a name="INDEX-956"></a><a name="INDEX-957"></a> method, and populates it from the bean
class's container-managed fields. A no-argument constructor
must exist in order for that to work. You'll learn more about
the relationship between the primary key and the bean class later in
this section.
</p>

<p>The EJB specification requires that all fields in the primary key
class be declared <tt class="literal">public</tt><a name="INDEX-958"></a>. This
requirement ensures that the container can read the fields at runtime
via Java reflection. Some EJB servers may be able to read fields with
more restrictive access modifiers depending on how the security
manager is designed, but making the fields <tt class="literal">public</tt>
ensures that fields are always accessible, regardless of the
server's vendor. Portability is the key reason that the primary
key's fields must be public.
</p>

<p>Because the primary key will be used in remote invocations, it must
also adhere to the restrictions imposed by Java RMI-IIOP. These are
addressed in <a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm">Chapter 5, "The Client View"</a>, but for most cases, you
just need to make the primary key serializable.
</p>

<p>Both EJB 1.0 and EJB 1.1 specifications allow two types of primary
keys: <a name="INDEX-959"></a><a name="INDEX-960"></a>
compound and single-field keys. In either case, the
<a name="INDEX-961"></a><a name="INDEX-962"></a>primary key must fulfill two criteria: it
must be a valid Java RMI type ( Java RMI-IIOP value type for EJB
1.1), so it must be serializable; and it must implement
<tt class="literal">equals()</tt> and <tt class="literal">hashCode()</tt> methods
appropriately.
</p>

<a name="JBEANS-CH-6-SECT-1.2.1"></a>
<h3 class="sect3">6.1.2.1. Compound primary keys</h3>

<p>A compound primary key is a class that implements
<tt class="literal">Serializable</tt> and contains one or more public
fields whose names and types match a subset of the container-managed
fields in the bean class. <tt class="literal">ShipPK</tt> is a typical
example of a compound primary key. In this class, the
<tt class="literal">ShipPK.id</tt> field must map to a
<tt class="literal">ShipBean.id</tt> field of type <tt class="literal">int</tt>
in the <tt class="literal">ShipBean</tt> class. A compound key may have
several fields that map to corresponding fields in the bean class.
</p>



<a name="JBEANS-CH-6-SECT-1.2.2"></a>
<h3 class="sect3">6.1.2.2. Single-field key</h3>

<p>The <tt class="literal">String</tt> class and the
<a name="INDEX-963"></a><a name="INDEX-964"></a>
wrapper classes for the <a name="INDEX-965"></a><a name="INDEX-966"></a><a name="INDEX-967"></a>primitive data types can also be
used as primary keys. In the case of the <tt class="literal">ShipBean</tt>,
for example, we could have specified an <tt class="literal">Integer</tt>
type as the primary key:
</p>

<blockquote>
<pre class="programlisting">public interface ShipHome extends javax.ejb.EJBHome {
    public Ship findByPrimaryKey(<tt class="userinput"><b>java.lang.Integer key</b></tt>) 
        throws FinderException, RemoteException;
    ... 
}</pre>
</blockquote>

<p>In this case, there is no explicit primary key class. However, there
must still be an identifiable primary key within the bean class
itself. That is, there must be a single field in the bean class with
the appropriate type. For the <tt class="literal">ShipBean</tt>, we would
need to change the <tt class="literal">id</tt> field to be of type
<tt class="literal">java.lang.Integer</tt>.
</p>

<p>Although primary keys can be primitive wrappers
(<tt class="literal">Integer</tt>, <tt class="literal">Double</tt>,
<tt class="literal">Long</tt>, etc.), primary keys cannot be primitive
types (<tt class="literal">int</tt>, <tt class="literal">double</tt>,
<tt class="literal">long</tt>, etc.); some of the semantics of EJB
interfaces prohibit the use of primitives. For example, the
<tt class="literal">EJBObject.getPrimaryKey()</tt> method returns an
<tt class="literal">Object</tt> type, thus forcing primary keys to be
<tt class="literal">Object</tt>s. As you learn more about the EJB,
you'll discover other reasons that primitives can't be
used for single-field keys.
</p>

<dl>
<dt>
<b>EJB 1.0 support for <a name="INDEX-968"></a>
single-field keys</b>
</dt>
<dd>
<p>In EJB 1.0, the specification is unclear about whether or not
single-field types like String or primitive wrapper types are
supported. Some EJB 1.0 servers support them, while others only
support compound primary keys. Consult your vendor documentation to
be sure, or use compound primary keys. When single-field types are
supported, there must be only one container-managed field of that
type in the bean class. Otherwise, the container doesn't know
to which field it should map the primary
key.<a name="INDEX-969"></a>
</p>
</dd>

<dt>
<b>EJB 1.1 support for single-field keys</b>
</dt>
<dd>
<p>EJB 1.1 is unambiguous in its support for single-field keys. With
single-field types, you cannot identify the matching field in the
bean class by name, since the primary key is not a named field.
Instead, you use the
<tt class="literal">&lt;primkey-field&gt;</tt><a name="INDEX-970"></a><a name="INDEX-971"></a><a name="INDEX-972"></a> tag in the deployment descriptor to
specify one of the bean's container-managed fields as the
primary key:
</p>
<blockquote>
<pre class="programlisting">&lt;ejb-jar&gt;
 &lt;enterprise-beans&gt;
 &lt;entity&gt;
    <tt class="userinput"><b>&lt;primkey-field&gt;id&lt;/primkey-field&gt;</b></tt>
  ...
&lt;/ejb-jar&gt;</pre>
</blockquote>
<p>The <tt class="literal">primkey-field</tt> (single-field
keys) is not used in the Ship bean example. The Ship bean uses
primary key class, <tt class="literal">ShipPK</tt>, but the use of
<tt class="literal">primkey-field</tt> is explored in more <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch10_01.htm">Chapter 10, "XML Deployment Descriptors"</a>. </p>
</dd> 
</dl>



<a name="JBEANS-CH-6-SECT-1.2.3"></a>
<h3 class="sect3">6.1.2.3. EJB 1.1: Undefined primary keys</h3>

<p>One objective of EJB is to <a name="INDEX-973"></a><a name="INDEX-974"></a>create a
market for third-party components that can be used independently.
Container-managed persistence beans provide an excellent model for a
component market because they make few assumptions about the
underlying database. One problem with container-managed persistence
in EJB 1.0 was that the bean developer had to define the primary key
before the bean was deployed. In turn, this requirement forced the
developer to make assumptions about the environment in which the bean
would be used, and thus it limited the bean's portability
across databases. For
<a name="INDEX-975"></a><a name="INDEX-976"></a>example, a relational database will use a
set of columns in a table as the primary key, to which bean fields
map nicely. An object database, however, uses a completely different
mechanism for indexing objects to which a primary key may not map
very well. The same is true for legacy systems and
<a name="INDEX-977"></a>Enterprise
Resource Planing (ERP) systems. To overcome this problem, EJB 1.1
allows the primary key to remain undefined until the bean is
deployed. An undefined primary key allows the deployer to choose a
system-specific key at deployment time. An object database may
generate an Object ID, while an ERP system may generate some other
primary key. These keys are generated by the database or backend
system automatically. This may require that the CMP bean be altered
or extended to support the key, but this is immaterial to the bean
developer; she concentrates on the business logic of the bean and
leaves the indexing to the container.
</p>

<p>To facilitate an undefined primary key, the bean class and its
interfaces use the
<tt class="literal">Object</tt><a name="INDEX-978"></a><a name="INDEX-979"></a> type to identify the primary key.
The following code shows how the home interface and bean class would
be defined for a container-managed bean with an undefined primary
key:
</p>

<blockquote>
<pre class="programlisting">public interface ShipHome extends EJBHome {
    public Ship findByPrimaryKey(<tt class="userinput"><b>java.lang.Object primaryKey</b></tt>) 
        throws RemoteException, FinderException;
...
}
public class ShipBean extends EntityBean {
    public String name;
    public int capacity;
    public double tonnage;
          
    public <tt class="userinput"><b>java.lang.Object</b></tt> ejbCreate() {
    ...
    }
...
}</pre>
</blockquote>

<p>The use of an undefined primary key means that the bean developer and
application developer (client code) must work with a
<tt class="literal">java.lang.Object</tt> type and not a specific primary
key type, which <a name="INDEX-980"></a><a name="INDEX-981"></a><a name="INDEX-982"></a> can be limiting.
</p>



<a name="JBEANS-CH-6-SECT-1.3"></a>
<h3 class="sect2">6.1.3. The Home Interface</h3>

<p>
<a name="INDEX-983"></a><a name="INDEX-984"></a><a name="INDEX-985"></a>The home interface of any
entity bean is used to create, locate, and remove objects from EJB
systems. Each entity bean type has its own home interface. The home
interface defines two basic kinds of methods: zero or more
<a name="INDEX-986"></a><a name="INDEX-987"></a>
create methods and one or more <a name="INDEX-988"></a><a name="INDEX-989"></a><a name="INDEX-990"></a>find methods.<a href="#FOOTNOTE-2">[2]</a> The create methods
act like remote constructors and define how new Ship beans are
created. (In our home interface, we only provide a single
<tt class="literal">create()</tt> method.) The find method is used to
locate a specific ship or ships.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-2"></a>
<p>[2]<a href="ch09_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch09_01.htm">Chapter 9, "Design Strategies"</a> explains when you should not define any create
methods in the home interface.</p> </blockquote>

<p>The following code contains the complete definition of the
<tt class="literal">ShipHome</tt> interface:
</p>

<blockquote>
<pre class="programlisting">package com.titan.ship;

import javax.ejb.EJBHome;
import javax.ejb.CreateException;
import javax.ejb.FinderException;
import java.rmi.RemoteException;
import java.util.Enumeration;

public interface ShipHome extends javax.ejb.EJBHome {

    public Ship create(int id, String name, int capacity, double tonnage)
        throws RemoteException,CreateException;
    public Ship create(int id, String name)
        throws RemoteException,CreateException;
    public Ship findByPrimaryKey(ShipPK primaryKey)
        throws FinderException, RemoteException;
    public Enumeration findByCapacity(int capacity)
        throws FinderException, RemoteException;
}</pre>
</blockquote>

<p>Enterprise JavaBeans specifies that create methods in the home
interface must throw the
<a name="INDEX-991"></a><tt class="literal">javax.ejb.CreateException</tt><a name="INDEX-992"></a><a name="INDEX-993"></a>
. In the case of container-managed persistence, the container needs a
common exception for communicating problems experienced during the
create process.
</p>

<a name="JBEANS-CH-6-SECT-1.3.1"></a>
<h3 class="sect3">6.1.3.1. The find methods</h3>

<p>
<a name="INDEX-994"></a><a name="INDEX-995"></a>With container-managed persistence,
implementations of the <a name="INDEX-996"></a>find
methods are generated automatically at deployment time. Different EJB
container vendors employ different strategies for defining how the
find methods work. Regardless of the implementation, when you deploy
the bean, you'll need to do some work to define the rules of
the find method. <a name="INDEX-997"></a><tt class="literal">findByPrimaryKey()</tt>
is a standard method that all home interfaces for entity beans must
support. This method locates beans based on the attributes of the
primary key. In the case of the Ship bean, the primary key is the
<tt class="literal">ShipPK</tt> class, which has one attribute,
<tt class="literal">id</tt>. With relational databases, the primary key
attributes usually map to a primary key in a table. In the
<tt class="literal">ShipPK</tt>, for example, the <tt class="literal">id</tt>
attribute maps to the <tt class="literal">ID</tt> primary key column in the
<tt class="literal">SHIP</tt> table. In an object-oriented database, the
primary key's attributes might point to some other unique
identifier.
</p>

<p>EJB allows you to specify other find methods in the home interface,
in addition to <tt class="literal">findByPrimaryKey()</tt>. All find
methods must have names that match the pattern
<tt class="literal">find</tt><em class="replaceable">lookup-type</em>. So,
for example, if we were to include a find method based on the Ship
bean's capacity, it might be called
<tt class="literal">findByCapacity(int</tt><tt class="literal">capacity)</tt>.
In container-managed persistence, any find method included in the
home interface must be explained to the container. In other words,
the deployer needs to define how the find method should work in terms
that the container understands. This is done at deployment time,
using the vendor's deployment tools and syntax specific to the
vendor.
</p>

<p>Find methods return either the remote-interface type appropriate for
that bean, or an instance of
<tt class="literal">java.util.Enumeration</tt><a name="INDEX-998"></a><a name="INDEX-999"></a><a name="INDEX-1000"></a>.
</p>

<a name="JBEANS-CH-6-ADMON-3"></a>
<blockquote class="note">
<h4 class="objtitle">NOTE</h4>
<p>
The EJB 1.1 specification also allows multiple references to be returned as a <tt class="literal">java.util.Collection</tt> type, which provides more flexibility to application and bean developers.</p>
</blockquote>
<p>Specifying a remote-interface type indicates that the method only
locates one bean. The <tt class="literal">findByPrimaryKey()</tt> method
obviously returns one remote reference because there is a one-to-one
relationship between a primary key's value and an entity. The
<tt class="literal">findByCapacity(int</tt><tt class="literal">capacity)</tt>
method, however, could return several remote references, one for
every ship that has a capacity equal to the parameter
<tt class="literal">capacity</tt>. The possibility of returning several
remote references requires the use of the
<tt class="literal">Enumeration</tt> type or a <tt class="literal">Collection</tt> type (EJB 1.1
only). Enterprise JavaBeans specifies that any find method used in a
home interface must throw the
<a name="INDEX-1001"></a><tt class="literal">javax.ejb.FinderException</tt><a name="INDEX-1002"></a>
. Find methods that return a single remote reference throw a
<tt class="literal">FinderException</tt> if an
<a name="INDEX-1003"></a>
application error occurs and a
<a name="INDEX-1004"></a><tt class="literal">javax.ejb.ObjectNotFoundException</tt> if a matching
bean cannot be found. The
<tt class="literal">ObjectNotFoundException</tt><a name="INDEX-1005"></a>
 is a subtype of <tt class="literal">FinderException</tt> and is only thrown
by find methods that return single remote references.
</p>

<dl>
<dt>
<b>EJB 1.1 <a name="INDEX-1006"></a>
multi-entity find methods</b>
</dt>
<dd>
<p>Find methods that return an <tt class="literal">Enumeration</tt> or
<tt class="literal">Collection</tt> type (multi-entity finders) return an
empty collection (not a null reference) if no matching beans can be
found or throw a <tt class="literal">FinderException</tt> if an application
error occurs.
</p>
</dd>

<dt>
<b>EJB 1.0 multi-entity find methods</b>
</dt>
<dd>
<p>Find methods that return an <tt class="literal">Enumeration</tt> return
<tt class="literal">null</tt> if no matching beans can be found or throw a
<tt class="literal">FinderException</tt> if a failure in the request
occurs.
</p>
</dd>

</dl>

<p>How find methods are mapped to the database for container-managed
persistence is not defined in the EJB specification; it is
vendor-specific. Consult the documentation provided by your EJB
vendor to determine how find methods are defined at <a name="INDEX-1007"></a><a name="INDEX-1008"></a><a name="INDEX-1009"></a> deployment time.
</p>



<a name="ch06-13-fm2xml"></a>
<h3 class="sect2">6.1.4. Java RMI Return Types, Parameters, and Exceptions</h3>
<p>
<a name="INDEX-1010"></a><a name="INDEX-1011"></a>

Both the <a name="INDEX-1012"></a><a name="INDEX-1013"></a><a name="INDEX-1014"></a>remote interface and
<a name="INDEX-1015"></a><a name="INDEX-1016"></a>home
interface <a name="INDEX-1017"></a><a name="INDEX-1018"></a>extend, indirectly, the
<tt class="literal">java.rmi.Remote</tt> interface. Remote interfaces must
follow several guidelines, some of which apply to the return types
and parameters that are allowed. To be compatible, the
<em class="emphasis">actual</em> return types and parameter types used in
the <tt class="literal">java.rmi.Remote</tt> interfaces must be primitives,
<tt class="literal">String</tt><a name="INDEX-1019"></a> types, <tt class="literal">java.rmi.Remote</tt>
types, or <a name="INDEX-1020"></a>serializable types.
</p>

<p>There is a difference between
<em class="emphasis">declared</em><a name="INDEX-1021"></a><a name="INDEX-1022"></a><a name="INDEX-1023"></a>
types, which are checked by the compiler, and
<em class="emphasis">actual</em> types, which are checked by the runtime.
The types which may be used in Java RMI are
<em class="emphasis">actual</em> types, which are either primitive types,
object types implementing (even indirectly)
<tt class="literal">java.rmi.Remote</tt>, or object types implementing
(even indirectly) <tt class="literal">java.io.Serializable</tt>. The
<tt class="literal">java.util.Enumeration</tt> type returned by
multi-entity find methods is, for example, is a perfectly valid
return type for a remote method, provided that the concrete class
implementing <tt class="literal">Enumeration</tt> is
<tt class="literal">Serializable</tt>. So Java RMI has
<em class="emphasis">no</em> special rules regarding declared return types
or parameter types. At runtime, a type that is not a
<tt class="literal">java.rmi.Remote</tt> type is assumed to be
serializable; if it is not, an exception is thrown. The actual type
passed cannot be checked by the compiler, it must be checked at the
runtime.
</p>

<p>Here is a list of the types that can be passed as parameters or
returned in Java RMI:
</p>

<ul>
<li>
<p>Primitives: <tt class="literal">byte</tt>, <tt class="literal">boolean</tt>,
<tt class="literal">char</tt>, <tt class="literal">short</tt>,
<tt class="literal">int</tt>, <tt class="literal">long</tt>,
<tt class="literal">double</tt>, <tt class="literal">float</tt>
</p>
</li>
<li>
<p>Java serializable types: any class that implements or any interface
that extends <tt class="literal">java.io.Serializable</tt>
</p>
</li>
<li>
<p>
<a name="INDEX-1024"></a>Java RMI remote types: any class that
implements or any interface that extends
<tt class="literal">java.rmi.Remote</tt>
</p>
</li>
</ul>
<p>All methods defined in remote interfaces must throw
<a name="INDEX-1025"></a><tt class="literal">java.rmi.RemoteException</tt>. A
<tt class="literal">RemoteException</tt> is thrown by the underlying system
(the EJB object) when a communication error or system failure of some
kind occurs. Although methods in the remote interface and home
interface are required by the compiler to declare that they throw
<tt class="literal">RemoteException</tt>, it's not required that the
matching methods in the bean class actually throw it.
</p>


<a name="JBEANS-CH-6-SECT-1.5"></a>
<h3 class="sect2">6.1.5. The ShipBean Class</h3>

<p>
<a name="INDEX-1026"></a><a name="INDEX-1027"></a><a name="INDEX-1028"></a>No bean is complete without
its<a name="INDEX-1029"></a>implementation class. Now that we have
defined the Ship bean's remote interfaces and primary key, we
are ready to define the <tt class="literal">ShipBean</tt> itself. The
<tt class="literal">ShipBean</tt> will reside on the EJB server. When a
client application or bean invokes a business method on the Ship
bean's remote interface, that method invocation is received by
the EJB object, which then delegates it to the
<tt class="literal">ShipBean</tt>.
</p>

<p>When developing any bean, we have to use the bean's remote
interfaces as a guide. <a name="INDEX-1030"></a>Business methods defined in the remote
interface must be duplicated in the bean class. In container-managed
beans, the create methods of the home interface must also have
matching methods in the bean class according to the EJB
specification. Finally, <a name="INDEX-1031"></a>callback methods defined by the
<tt class="literal">javax.ejb.EntityBean</tt> interface must be
implemented. Here is the code for the <tt class="literal">ShipBean</tt>
class. We have omitted the <tt class="literal">ejbCreate()</tt> method,
which will be discussed later because it's different in EJB 1.0
and EJB 1.1:
</p>

<blockquote>
<pre class="programlisting">package com.titan.ship;

import javax.ejb.EntityContext;

public class ShipBean implements javax.ejb.EntityBean {
    public int id;
    public String name;
    public int capacity;
    public double tonnage;

    public EntityContext context;
        
    /*************************************
    *    ejbCreate() method goes here
    *************************************/

    public void ejbPostCreate(int id, String name, int capacity,
                              double tonnage){
        ShipPK pk = (ShipPK)context.getPrimaryKey();
        // Do something useful with the primary key.
    }

    public void ejbPostCreate(int id, String name) {
        Ship myself = (Ship)context.getEJBObject();
        // Do something useful with the EJBObject reference.
    }
    public void setEntityContext(EntityContext ctx) {
        context = ctx;
    }
    public void unsetEntityContext() { 
        context = null;
    }
    public void ejbActivate() {}
    public void ejbPassivate() {}
    public void ejbLoad() {}
    public void ejbStore() {}
    public void ejbRemove() {}

    public String getName() {
        return name;
    }
    public void setName(String n) {
        name = n;
    }
    public void setCapacity(int cap) {
        capacity = cap;
    }
    public int getCapacity() {
        return capacity;
    }
    public double getTonnage() {
        return tonnage;
    }
    public void setTonnage(double tons) {
        tonnage = tons;
    }
}</pre>
</blockquote>

<p>The Ship bean defines four
<a name="INDEX-1032"></a>persistent fields:
<tt class="literal">id</tt>, <tt class="literal">name</tt>,
<tt class="literal">capacity</tt>, and <tt class="literal">tonnage</tt>. No
mystery here: these fields represent the persistent state of the Ship
bean; they are the state that defines a unique ship entity in the
database. The Ship bean also defines another field,
<tt class="literal">context</tt>, which holds the bean's
<tt class="literal">EntityContext</tt>. We'll have more to say about
this later.
</p>

<p>The set and get methods are the <a name="INDEX-1033"></a><a name="INDEX-1034"></a>business methods we defined for the Ship
bean; both the remote interface and the bean class must support them.
This means that the signatures of these methods must be exactly the
same, except for the <tt class="literal">javax.ejb.RemoteException</tt>.
The bean class's business methods aren't required to
throw the <tt class="literal">RemoteException</tt>. This makes sense
because these methods aren't actually invoked
remotely--they're invoked by the EJB object. If a
communication problem occurs, the container will throw the
<tt class="literal">RemoteException</tt> for the bean <a name="INDEX-1035"></a><a name="INDEX-1036"></a><a name="INDEX-1037"></a> automatically.
</p>


<a name="JBEANS-CH-6-SECT-1.6"></a>
<h3 class="sect2">6.1.6. Implementing the javax.ejb.EntityBean Interface</h3>

<p>
<a name="INDEX-1038"></a><a name="INDEX-1039"></a>To make the <tt class="literal">ShipBean</tt>
an entity bean, it must implement the <a name="INDEX-1040"></a><tt class="literal">javax.ejb.EntityBean</tt> interface. The
<tt class="literal">EntityBean</tt> interface contains a number of callback
methods that the container uses to alert the bean instance of various
runtime events:
</p>

<blockquote>
<pre class="programlisting">public interface javax.ejb.EntityBean extends javax.ejb.EnterpriseBean {
    public abstract void ejbActivate() throws RemoteException;
    public abstract void ejbPassivate() throws RemoteException;
    public abstract void ejbLoad() throws RemoteException;
    public abstract void ejbStore() throws RemoteException;
    public abstract void ejbRemove() throws RemoteException;
    public abstract void setEntityContext(EntityContext ctx) 
        throws RemoteException;
    public abstract void unsetEntityContext() throws RemoteException;
}</pre>
</blockquote>

<p>Each callback method is called at a specific time during the life
cycle of a <tt class="literal">ShipBean</tt>. In many cases,
container-managed beans, like the <tt class="literal">ShipBean</tt>,
don't need to do anything when a callback method is invoked.
Container-managed beans have persistence managed automatically, so
many of the resources and logic that might be managed by these
methods are already handled by the container. Except for the
<tt class="literal">EntityContext</tt> methods, we will leave the
discussion of these methods for the section on bean-managed
persistence. This version of the Ship bean has empty implementations
for its callback methods. It is important to note, however, that even
a container-managed bean can take advantage of these callback methods
if needed; we just don't need them in our
<tt class="literal">ShipBean</tt> at this time.
</p>


<a name="JBEANS-CH-6-SECT-1.7"></a>
<h3 class="sect2">6.1.7. The EntityContext</h3>

<p>The <a name="INDEX-1041"></a>
first method called after a bean instance is created is
<tt class="literal">setEntityContext()</tt><a name="INDEX-1042"></a>. As the method signature
indicates, this method passes the <a name="INDEX-1043"></a>bean instance a reference to a
<tt class="literal">javax.ejb.EntityContext</tt>, which is really the bean
instance's interface to the container. The definition of
<tt class="literal">EntityContext</tt> is as follows:
</p>

<blockquote>
<pre class="programlisting">public interface javax.ejb.EntityContext extends javax.ejb.EJBContext {
    public abstract EJBObject getEJBObject() throws IllegalStateException;
    public abstract Object getPrimaryKey() throws IllegalStateException;
}</pre>
</blockquote>

<p>The <tt class="literal">setEntityContext()</tt> method is called prior to
the bean instance's entry into the instance pool. In <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>, we discussed the instance pool that EJB
containers maintain, where instances of entity and stateless session
beans are kept ready to use. <tt class="literal">EntityBean</tt> instances
in the instance pool are not associated with any data in the
database; their state is not unique. When a request for a specific
entity is made by a client, an instance from the pool is chosen,
populated with data from the database, and assigned to service the
client.
</p>

<p>When an entity from the pool is assigned to service a client, the
instance is associated with or "wrapped" by an
<a name="INDEX-1044"></a>EJB object. The EJB object
provides the remote reference, or stub, that implements the
bean's remote interface and is used by the client. When the
client invokes methods on the stub, the EJB object receives the
message and delegates it to the bean instance. The EJB object
protects the bean instance from direct contact with the client by
intervening in business method invocations to ensure that
transactions, security, concurrency, and other primary services are
managed appropriately.
</p>

<p>The EJB object also maintains the bean instance's identity,
which is available from the <tt class="literal">EntityContext</tt>. The
<tt class="literal">EntityContext</tt> allows the bean instance to obtain
its own primary key and a remote reference to the EJB object.
Containers often use a swapping strategy to get maximum use of bean
instances. Swapping doesn't impact the client reference to the
stub because the stub communicates with the EJB object, not the bean
instance. So, as bean instances are assigned to and removed from
association with the EJB object server, the server maintains a
constant connection to the stub on the client.
</p>

<p>When a method is invoked on the EJB object via the stub, a bean
instance from the pool is populated with the appropriate data and
assigned to the EJB object. When a bean instance is assigned to an
EJB object, its <tt class="literal">EntityContext</tt> changes so that the
primary key and EJB object obtainable through the
<tt class="literal">EntityContext</tt> match the EJB object the bean
instance is currently associated with. Because the bean
instance's identity changes every time the bean is swapped into
a different EJB object, the values returned by the
<tt class="literal">EntityContext</tt> change depending on which bean
instance it is associated with.
</p>

<p>At the end of the bean instance's life, after the bean instance
is removed permanently from the <a name="INDEX-1045"></a><a name="INDEX-1046"></a><a name="INDEX-1047"></a>instance pool and before the bean
instance is garbage collected, the
<tt class="literal">unsetEntityContext()</tt> method is called, indicating
that the bean instance's <tt class="literal">EntityContext</tt> is no
longer implemented by the container.
</p>


<a name="JBEANS-CH-6-SECT-1.8"></a>
<h3 class="sect2">6.1.8. The Create Methods</h3>

<p>
<a name="INDEX-1048"></a><a name="INDEX-1049"></a>When
a create method is invoked on the home interface, the EJB home
delegates it to the bean instance in the same way that business
methods on the remote interface are handled. This means that we need
an <tt class="literal">ejbCreate()</tt><a name="INDEX-1050"></a> method in the bean class that
corresponds to each <tt class="literal">create()</tt> method in the home
interface. Here are the <tt class="literal">ejbCreate()</tt> methods that
we omitted from the source code for the <tt class="literal">ShipBean</tt>
class. Note the difference between EJB 1.0 and 1.1:
</p>

<blockquote>
<pre class="programlisting">// For EJB 1.1, returns a ShipPK
public ShipPK ejbCreate(int id, String name, int capacity, double tonnage) {
        this.id = id;
        this.name = name;
        this.capacity = capacity;
        this.tonnage = tonnage;
        return null;
}
public ShipPK ejbCreate(int id, String name) {
        this.id = id;
        this.name = name;
        capacity = 0;
        tonnage = 0;
}

// For EJB 1.0: returns void
public void ejbCreate(int id, String name, int capacity, double tonnage) {
        this.id = id;
        this.name = name;
        this.capacity = capacity;
        this.tonnage = tonnage;
}
public void ejbCreate(int id, String name) {
        this.id = id;
        this.name = name;
        capacity = 0;
        tonnage = 0;
}</pre>
</blockquote>

<p>The <tt class="literal">ejbCreate()</tt> method returns
<tt class="literal">void</tt> in EJB 1.0 and a <tt class="literal">null</tt>
value of type <tt class="literal">ShipPK</tt> for the bean's primary
key in EJB 1.1. The end result is the same: in both EJB 1.0 and EJB
1.1, the return value of the <tt class="literal">ejbCreate()</tt> method
for a container-managed bean is ignored. EJB 1.1 changed its return
value from <tt class="literal">void</tt> to the primary key type to
facilitate subclassing; the change was made so that it's easier
for a bean-managed bean to extend a container-managed bean. In EJB
1.0, this is not possible because Java won't allow you to
overload methods with different return values. By changing this
definition so that a bean-managed bean can extend a container-managed
bean, the new specification allows vendors to support
container-managed persistence by extending the container-managed bean
with a generated bean-managed bean--a fairly simple solution to
a difficult problem. Bean developers can also take advantage of
inheritance to change an existing CMP bean into a BMP bean, which may
be needed to overcome difficult persistence problems.
</p>

<p>For every <tt class="literal">create()</tt> method defined in the entity
bean's home interface, there must be a corresponding
<tt class="literal">ejbPostCreate()</tt> method in the bean instance class.
In other words, <tt class="literal">ejbCreate()</tt> and
<tt class="literal">ejbPostCreate()</tt> methods occur in pairs with
matching signatures; there must be one pair for each
<tt class="literal">create()</tt> method defined in the home interface.
</p>

<a name="JBEANS-CH-6-SECT-1.8.1"></a>
<h3 class="sect3">6.1.8.1. ejbCreate( )</h3>

<p>In a container-managed bean, the <tt class="literal">ejbCreate()</tt>
method is called just prior to writing the bean's
container-managed fields to the database. Values passed in to the
<tt class="literal">ejbCreate()</tt> method should be used to initialize
the fields of the bean instance. Once the
<tt class="literal">ejbCreate()</tt> method completes, a new record, based
on the container-managed fields, is written to the database.
</p>

<p>Each <tt class="literal">ejbCreate()</tt> method must have parameters that
match a <tt class="literal">create()</tt> method in the home interface. The
<tt class="literal">ShipHome</tt>, for example, specifies two
<tt class="literal">create()</tt> methods. According
to the EJB specification, our <tt class="literal">ShipBean</tt> class must
therefore have two <tt class="literal">ejbCreate()</tt> methods that match
the parameters of the <tt class="literal">ShipHome</tt><tt class="literal">create()</tt> methods. If you look at the
<tt class="literal">ShipBean</tt> class definition and compare it to the
<tt class="literal">ShipHome</tt> definition, you can see how the
parameters for the create methods match exactly in type and sequence.
This enables the container to delegate the
<tt class="literal">create()</tt> method on the home interface to the
proper <tt class="literal">ejbCreate()</tt> method in the bean instance.
</p>

<p>The <tt class="literal">EntityContext</tt> maintained by the bean instance
does not provide it with the proper identity until the
<tt class="literal">ejbCreate()</tt> method has completed. This means that
during the course of the <tt class="literal">ejbCreate()</tt> method, the
bean instance doesn't have access to its primary key or EJB
object.<a href="#FOOTNOTE-3">[3]</a> The
<tt class="literal">EntityContext</tt> does, however, provide the bean with
information about the caller's identity, access to its EJB home
object, and properties.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-3"></a>
<p>[3] Information that is not specific to the bean
identity, such as the environment properties, may be available during
the <tt class="literal">ejbCreate()</tt>.</p> </blockquote>

<a name="JBEANS-CH-6-ADMON-4"></a>
<blockquote class="note">
<h4 class="objtitle">NOTE</h4>
<p>In EJB 1.1, the bean can also use the JNDI environment naming context to access other beans and resource managers like <tt class="literal">javax.sql.DataSource</tt>.</p>
</blockquote>
<p>The bean developer must ensure that the
<tt class="literal">ejbCreate()</tt> method sets the persistent fields that
correspond to the fields of the <a name="INDEX-1051"></a>
primary key. When a primary key is defined for a container-managed
bean, it must define fields that match one or more of the
container-managed (persistent) fields in the bean class. The fields
must match with regard to type and name exactly. At runtime, the
container will assume that fields in the primary key match some or
all of the fields in the bean class. When a new bean is created, the
container will use those container- managed fields in the bean class
to instantiate and populate a primary key for the bean automatically.
In the case of the <tt class="literal">ShipBean</tt>, the container-managed
<tt class="literal">id</tt> field corresponds to the
<tt class="literal">ShipPK.id</tt> field. When the record is inserted, the
<tt class="literal">ShipBean.id</tt> field is used to populate a newly
instantiated <tt class="literal">ShipPK</tt> object.
</p>

<p>Once the bean's state has been populated and its
<tt class="literal">EntityContext</tt> established, an
<tt class="literal">ejbPostCreate()</tt> method is invoked. This method
gives the bean an opportunity to perform any post-processing prior to
servicing client <a name="INDEX-1052"></a> requests.
</p>



<a name="JBEANS-CH-6-SECT-1.8.2"></a>
<h3 class="sect3">6.1.8.2. ejbPostCreate( )</h3>

<p>The bean identity isn't available to the bean during the call
to <tt class="literal">ejbCreate()</tt>, but is available in the
<a name="INDEX-1053"></a><tt class="literal">ejbPostCreate()</tt> method. This means that the bean
can access its own primary key and EJB object, which can be useful
for initializing the <a name="INDEX-1054"></a>bean instance prior to
servicing business method invocations. You can use the
<tt class="literal">ejbPostCreate()</tt> method to perform any additional
initialization. Each <tt class="literal">ejbPostCreate()</tt> method must
have the same parameters as its corresponding
<tt class="literal">ejbCreate()</tt> method. The
<tt class="literal">ejbPostCreate()</tt> method returns
<tt class="literal">void</tt>.
</p>

<p>It may seem a little silly to define the
<tt class="literal">ejbPostCreate()</tt> method with the same parameters as
its matching <tt class="literal">ejbCreate()</tt> method, especially in the
<tt class="literal">ShipBean</tt> where the instance variables are just as
easily retrieved from the bean instance's fields. There are,
however, two very good reasons for matching the parameter lists.
First, it indicates which <tt class="literal">ejbPostCreate()</tt> method
is associated with which <tt class="literal">ejbCreate()</tt> method. This
ensures that the container calls the correct
<tt class="literal">ejbPostCreate()</tt> method after
<tt class="literal">ejbCreate()</tt> is done. Second, it is possible that
one of the parameters passed is not assigned to a bean instance field
or is only relevant to the <tt class="literal">ejbPostCreate()</tt>. In
either case, you would need to duplicate the parameters of the
<tt class="literal">ejbCreate()</tt> method to have that information
available in the <tt class="literal">ejbPostCreate()</tt> method.
</p>



<a name="JBEANS-CH-6-SECT-1.8.3"></a>
<h3 class="sect3">6.1.8.3. ejbCreate() and ejbPostCreate( ) sequence of events</h3>

<p>
<a name="INDEX-1055"></a>To understand
how a <a name="INDEX-1056"></a>bean
instance gets up and running, we have to think of a bean in the
context of its life cycle. <a href="#ch06-11453">Figure 6-1</a> shows the
sequence of events during a portion of the bean's life cycle,
as defined by the EJB specification. Every EJB vendor must support
this sequence of events.
</p>

<a name="ch06-11453"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0601.gif" webstripperlinkwas="figs/ejb2_0601.gif"></div>
<h4 class="objtitle">Figure 6-1. The sequence of events for bean instance creation</h4>
<p>
<a name="INDEX-1057"></a>
The process begins when the client invokes one of the
<tt class="literal">create()</tt> methods on the bean's EJB home. A
<tt class="literal">create()</tt> method is invoked on the EJB home stub
(step 1), which communicates the method to the EJB home across the
network (step 2). The EJB home plucks a <tt class="literal">ShipBean</tt>
instance from the pool and invokes its corresponding
<tt class="literal">ejbCreate()</tt> method (step 3).
</p>

<p>The <tt class="literal">create()</tt> and <tt class="literal">ejbCreate()</tt>
methods pair are responsible for initializing the bean instance so
that the container can insert a record into the database. In the case
of the <tt class="literal">ShipBean</tt>, the minimal information required
to add a new ship to the system is the ship's unique
<tt class="literal">id</tt> and a <tt class="literal">name</tt>. These fields are
initialized during the <tt class="literal">ejbCreate()</tt> method
invocation (step 4).
</p>

<p>In a container-managed <tt class="literal">EntityBean</tt>, the container
uses the bean instance's public fields (<tt class="literal">id</tt>,
<tt class="literal">name</tt>, <tt class="literal">capacity</tt>, and
<tt class="literal">tonnage</tt>) to insert a record in the database which
it reads from the bean (step 5). Only those fields described as
container-managed in the deployment descriptor are accessed
automatically. Once the container has read the container-managed
fields from the bean instance, it will automatically insert a new
record into the database using those fields (step 6). How the data is
written to the database is defined when the bean's fields are
mapped at deployment time. In our example, a new record is inserted
into the <tt class="literal">SHIP</tt> table.
</p>

<p>Once the record has been inserted into the database, the bean
instance is ready to be assigned to an EJB object (step 7). Once the
bean is assigned to an EJB object, the bean's identity is
available. This is when the <tt class="literal">ejbPostCreate()</tt> method
is invoked (step 8).
</p>

<p>Finally, when the <tt class="literal">ejbPostCreate()</tt> processing is
complete, the bean is ready to service client requests. The EJB
object stub is created and returned to client application, which will
use it to invoke business methods on the bean (step 9).
</p>



<a name="JBEANS-CH-6-SECT-1.8.4"></a>
<h3 class="sect3">6.1.8.4. Using ejbLoad() and ejbStore( ) in container-managed beans</h3>

<p>The <a name="INDEX-1058"></a><a name="INDEX-1059"></a>process of ensuring
that the database record and the entity bean instance are equivalent
is called
<em class="emphasis">synchronization</em><a name="INDEX-1060"></a><a name="INDEX-1061"></a>. In container-managed
persistence, the bean's container-managed fields are
automatically synchronized with the
<a name="INDEX-1062"></a>database. In most
cases, we will not need the <tt class="literal">ejbLoad()</tt> and
<tt class="literal">ejbStore()</tt> methods because persistence in
container-managed beans is uncomplicated.
</p>

<p>Leveraging the <a name="INDEX-1063"></a><a name="INDEX-1064"></a><a name="INDEX-1065"></a><tt class="literal">ejbLoad()</tt> and
<tt class="literal">ejbStore()</tt> callback methods in container-managed
beans, however, can be useful if more sophisticated logic is needed
when synchronizing container-managed fields. Data intended for the
database can be reformatted or compressed to conserve space; data
just retrieved from the database can be used to calculate derived
values for nonpersistent properties.
</p>

<p>Imagine a hypothetical bean class that includes an
<a name="INDEX-1066"></a><a name="INDEX-1067"></a><a name="INDEX-1068"></a>
array of <tt class="literal">Strings</tt> that you want to store in the
database. Relational databases do not support arrays, so you need to
convert the array into some other format. Using the
<tt class="literal">ejbLoad()</tt> and <tt class="literal">ejbStore()</tt>
methods in a container-managed bean allows the bean instance to
reformat the data as appropriate for the state of the bean and the
structure of the database. Here's how this might work:
</p>

<blockquote>
<pre class="programlisting">public class HypotheticalBean extends javax.ejb.EntityBean {
    public transient String [] array_of_messages;
    public String messages;

    // Parses the messages into an array_of_messages. This is called on a 
    // container-managed bean just after the bean instance is synchronized 
    // with the database (right after the bean gets its data).
    public void ejbLoad() {
        StringTokenizer st = new StringTokenizer(messages, "~");
        array_of_messages = new String[st.countTokens()];
        for (int i = 0; st.hasMoreTokens(); i++) {
            array_of_messages[i] = st.nextToken();
        }
    }
    // Creates a '~' delimited string of messages from the
    // array_of_messages. This method is called immediately 
    // prior to synchronization of the database with the bean;
    // just before the bean is written to the database.
    public void ejbStore() {
        messages = new String();
        int i = 0;
        for (; i &lt; array_of_messages.length-1;i++) {
            messages += array_of_messages[i]+"~";
        }
        messages += array_of_messages[i];
    }
    // a business method that uses the array_of_messages
    public String [] getMessages() {
        return array_of_messages;
    }
 ...
}</pre>
</blockquote>

<p>Just before the container reads the container-managed field
<tt class="literal">messages</tt>, it calls the
<tt class="literal">ejbStore()</tt> method. This method makes a tilde (~)
delimited string from the <tt class="literal">array_of_messages</tt> and
places the new string in the <tt class="literal">messages</tt> field. This
trick formats the messages so the database can store them easily.
</p>

<p>Just after the container updates the fields of the
<tt class="literal">HypotheticalBean</tt> with fresh data from the
database, it calls the <tt class="literal">ejbLoad()</tt> method, which
parses the tilde-delimited <tt class="literal">message</tt> field and
populates the <tt class="literal">array_of_messages</tt> with the strings.
This reformats the database data into an array that is easier for the
<tt class="literal">HypotheticalBean</tt> to return to the client.
</p>



<a name="JBEANS-CH-6-SECT-1.8.5"></a>
<h3 class="sect3">6.1.8.5. EJB 1.1: Deploying the ShipBean</h3>

<p>With a complete <a name="INDEX-1069"></a><a name="INDEX-1070"></a>definition of the Ship bean, including
the remote interface, home interface, and primary key, we are ready
to create a deployment descriptor. The following listing shows the
bean's <a name="INDEX-1071"></a>XML deployment descriptor. This
deployment descriptor is not significantly different from the
descriptor we created for the Cabin bean in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, so it won't be discussed in detail.
</p>

<blockquote>
<pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE ejb-jar PUBLIC "-//Sun Microsystems, Inc.//DTD Enterprise
JavaBeans 1.1//EN" "http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd"&gt;

&lt;ejb-jar&gt;
 &lt;enterprise-beans&gt;
   &lt;entity&gt;
      &lt;description&gt;
            This bean represents a cruise ship.
      &lt;/description&gt;
      &lt;ejb-name&gt;ShipBean&lt;/ejb-name&gt;
      &lt;home&gt;com.titan.ship.ShipHome&lt;/home&gt;
      &lt;remote&gt;com.titan.ship.Ship&lt;/remote&gt;
      &lt;ejb-class&gt;com.titan.ship.ShipBean&lt;/ejb-class&gt;
      &lt;persistence-type&gt;Container&lt;/persistence-type&gt;
      &lt;prim-key-class&gt;com.titan.ship.ShipPK&lt;/prim-key-class&gt;
      &lt;reentrant&gt;False&lt;/reentrant&gt;

      &lt;cmp-field&gt;&lt;field-name&gt;id&lt;/field-name&gt;&lt;/cmp-field&gt;
      &lt;cmp-field&gt;&lt;field-name&gt;name&lt;/field-name&gt;&lt;/cmp-field&gt;
      &lt;cmp-field&gt;&lt;field-name&gt;capacity&lt;/field-name&gt;&lt;/cmp-field&gt;
      &lt;cmp-field&gt;&lt;field-name&gt;tonnage&lt;/field-name&gt;&lt;/cmp-field&gt;
   &lt;/entity&gt;
 &lt;/enterprise-beans&gt;
 
 &lt;assembly-descriptor&gt;
   &lt;security-role&gt;
      &lt;description&gt;
         This role represents everyone who is allowed full access 
         to the Ship bean.
      &lt;/description&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
   &lt;/security-role&gt;

   &lt;method-permission&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
     &lt;method&gt;
         &lt;ejb-name&gt;ShipBean&lt;/ejb-name&gt;
         &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
   &lt;/method-permission&gt;

   &lt;container-transaction&gt;
     &lt;method&gt;
        &lt;ejb-name&gt;ShipBean&lt;/ejb-name&gt;
        &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
     &lt;trans-attribute&gt;Required&lt;/trans-attribute&gt;
   &lt;/container-transaction&gt;
 &lt;/assembly-descriptor&gt;
&lt;/ejb-jar&gt;</pre>
</blockquote>

<p>Save the Ship bean's deployment descriptor into the
<em class="filename">com/titan/ship</em> directory as
<em class="filename">ejb-jar.xml</em>.
</p>

<p>Now that you have put all the necessary files in one directory,
creating the JAR file is easy. Position yourself in the
<em class="filename">dev</em> directory that is just above the
<em class="filename">com/titan/ship</em> directory tree, and execute the
<em class="filename">jar</em> utility as you did in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>:
</p>

<blockquote>
<pre class="programlisting">\dev % jar cf ship.jar com/titan/ship/*.class META-INF/ejb-jar.xml

F:\..\dev&gt;jar cf ship.jar com\titan\ship\*.class META-INF\ejb-jar.xml</pre>
</blockquote>

<p>The <tt class="literal">c</tt> option tells the <em class="emphasis">jar</em>
utility to create a new JAR file that contains the files indicated in
subsequent parameters. It also tells the <em class="emphasis">jar</em>
utility to stream the resulting JAR file to standard output. The
<tt class="literal">f</tt> option tells <em class="emphasis">jar</em> to
redirect the standard output to a new file named in the second
parameter (<tt class="literal">ship.jar</tt>). It's important to get
the order of the option letters and the command-line parameters to
match.
</p>



<a name="JBEANS-CH-6-SECT-1.8.6"></a>
<h3 class="sect3">6.1.8.6. EJB 1.0: Deploying the ShipBean</h3>

<p>If you're <a name="INDEX-1072"></a><a name="INDEX-1073"></a>using EJB 1.0, you need to create an
old-style deployment descriptor, which is a serialized Java object.
To create the deployment descriptor, we write a
<tt class="literal">MakeDD</tt> application, just as we did in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a> for the Cabin bean. Other than changing the
name of classes, the JNDI name, and the container-managed fields,
there isn't much difference between Ship's
<tt class="literal">MakeDD</tt> application and the Cabin bean's.
</p>

<blockquote>
<pre class="programlisting">package com.titan.ship;

import javax.ejb.deployment.EntityDescriptor;
import javax.ejb.deployment.ControlDescriptor;
import javax.naming.CompoundName;

import java.util.Properties;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;

public class MakeDD {

    public static void main(String args []) {
        try {

        if (args.length &lt;1) {
            System.out.println("must specify target directory");
            return;
        }
        EntityDescriptor shipDD = new EntityDescriptor();
        shipDD.setEnterpriseBeanClassName("com.titan.ship.ShipBean");
        shipDD.setHomeInterfaceClassName("com.titan.ship.ShipHome");
        shipDD.setRemoteInterfaceClassName("com.titan.ship.Ship");
        shipDD.setPrimaryKeyClassName("com.titan.ship.ShipPK");

        Class beanClass = ShipBean.class;
        Field [] persistentFields = new Field[4];
        persistentFields[0] = beanClass.getDeclaredField("id");
        persistentFields[1] = beanClass.getDeclaredField("name");
        persistentFields[2] = beanClass.getDeclaredField("capacity");
        persistentFields[3] = beanClass.getDeclaredField("tonnage");
        shipDD.setContainerManagedFields(persistentFields);

        shipDD.setReentrant(false);

        CompoundName jndiName = new CompoundName("ShipHome", new Properties());
        shipDD.setBeanHomeName(jndiName);

        ControlDescriptor cd = new ControlDescriptor();
        cd.setIsolationLevel(ControlDescriptor.TRANSACTION_READ_COMMITTED);
        cd.setMethod(null);
        cd.setRunAsMode(ControlDescriptor.CLIENT_IDENTITY);
        cd.setTransactionAttribute(ControlDescriptor.TX_REQUIRED);
        ControlDescriptor [] cdArray = {cd};
        shipDD.setControlDescriptors(cdArray);

        // Set the name to associate with the enterprise bean
        // in the JNDI name space.

        String fileSeparator = 
            System.getProperties().getProperty("file.separator");

        if (! args[0].endsWith(fileSeparator))
            args[0] += fileSeparator;

        FileOutputStream fis = new FileOutputStream(args[0]+"ShipDD.ser");
        ObjectOutputStream oos = new ObjectOutputStream(fis);
        oos.writeObject(shipDD);
        oos.flush();
        oos.close();
        fis.close();
        } catch (Throwable t){t.printStackTrace();}
    }
}</pre>
</blockquote>

<p>Compile this class and run it: </p>

<blockquote>
<pre class="programlisting">\dev % java com.titan.ship.MakeDD com/titan/ship

F:\..\dev&gt;java com.titan.ship.MakeDD com\titan\ship</pre>
</blockquote>

<p>If you run this application, you should end up with a file called
<em class="emphasis">ShipDD.ser</em> in the
<em class="filename">com/titan/ship</em> directory. This is your
serialized <tt class="literal">DeploymentDescriptor</tt> for the Ship bean.
We examined the code for this type of <tt class="literal">MakeDD</tt>
application in detail in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>, so we
won't do it again here.
</p>

<p>Next, place the Ship bean in a JAR file using the same process we
used for the Cabin and TravelAgent beans in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>. First, we have to specify a manifest file for
the <tt class="literal">Ship</tt> bean, which we will save in the
<em class="filename">com/titan/ship</em> directory:
</p>

<blockquote>
<pre class="programlisting">Name: com/titan/ship/ShipDD.ser
Enterprise-Bean: True</pre>
</blockquote>

<p>Now that the manifest is ready, we can JAR the Ship bean so that
it's ready for deployment. Again, we use the same process that
we used for the Cabin and TravelAgent beans:
</p>

<blockquote>
<pre class="programlisting">\dev % jar cmf com/titan/ship/manifest ship.jar \
com/titan/ship/*.class com/titan/ship/*.ser

F:\..\dev&gt;jar cmf com\titan\ship\manifest ship.jar com\titan\ship\*.class 
com\titan\ship\*.ser</pre>
</blockquote>

<p>The Ship bean is now complete and ready to be deployed. Use the
wizards and deployment utilities provided by your vendor to deploy
the <a name="INDEX-1074"></a><a name="INDEX-1075"></a> Ship
bean into the EJB server.
</p>



<a name="JBEANS-CH-6-SECT-1.9"></a>
<h3 class="sect2">6.1.9. The Client Application</h3>

<p>
<a name="INDEX-1076"></a><a name="INDEX-1077"></a><a name="INDEX-1078"></a>In <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a> and <a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm">Chapter 5, "The Client View"</a>, you learned
how to write a Java client that uses the EJB client API to access and
work with enterprise beans. Here's a simple client that
accesses the Ship bean; it creates a single ship, the
<em class="emphasis">Paradise</em>, that can handle 3,000 passengers:
</p>

<blockquote>
<pre class="programlisting">package com.titan.ship;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NamingException;
import java.rmi.RemoteException;
import java.util.Properties;

public class Client_1 {
    public static void main(String [] args) {
        try {
            Context ctx = getInitialContext();
          
            // EJB 1.0: Use native cast instead of narrow()
            Object ref = ctx.lookup("ShipHome");
            ShipHome home = (ShipHome)
                PortableRemoteObjectnarrow(ref,ShipHome.class);

            Ship ship = home.create(1,"Paradise",3000,100000);
            int t = ship.getCapacity();
            System.out.println("Capacity = " +t);

        } catch (Exception e){e.printStackTrace();}
    }
    public static Context getInitialContext() 
        throws javax.naming.NamingException {

        Properties p = new Properties();
        // ... Specify the JNDI properties specific to the vendor.
        return new javax.naming.InitialContext(p);
    }
}</pre>
</blockquote>

<p>Once you have created the ship, you should be able to modify the
client to look up the ship using its primary key, as shown in the
following code:
</p>

<blockquote>
<pre class="programlisting">package com.titan.ship;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NamingException;
import java.rmi.RemoteException;
import java.util.Properties;
import java.util.Enumeration;

public class Client_2 {
    public static void main(String [] args){
        try {
            Context ctx = getInitialContext();

            // EJB 1.0: Use native cast instead of narrow().
            Object ref = ctx.lookup("ShipHome");
            ShipHome home = (ShipHome)
                PortableRemoteObject.narrow(ref,ShipHome.class);

            home.create(2,"Utopia",4500,8939);
            home.create(3,"Valhalla",3300,93939);
            ShipPK pk = new ShipPK();
            pk.id = 1;
            Ship ship = home.findByPrimaryKey(pk);
            ship.setCapacity(4500);
            int capacity = ship.getCapacity();
            
            Enumeration enum = home.findByCapacity(4500);
            while (enum.hasMoreElements()) {
                // EJB 1.0: Use native cast instead of narrow() 
                ref = enum.nextElement();
                Ship aShip = (Ship) 
                    PortableRemoteObject.narrow(ref,Ship.class);

                System.out.println(aShip.getName());
            }
        } catch (Exception e){e.printStackTrace();}
    }
    public static Context getInitialContext() 
        throws javax.naming.NamingException {
        Properties p = new Properties();
        // ... Specify the JNDI properties specific to the vendor.
        return new javax.naming.InitialContext(p);
    }
}</pre>
</blockquote>

<p>The preceding client code demonstrates that the ship was
automatically inserted into the database by the container. Now any
changes you make to ship attributes (<tt class="literal">name</tt>,
<tt class="literal">capacity</tt>, <tt class="literal">tonnage</tt>) will result
in a change to the database.
</p>

<p>Spend some time creating, finding, and removing Ships using the
client application. You should also explore the use of all the
methods in the <tt class="literal">EJBObject</tt> and
<tt class="literal">EJBHome</tt> interfaces as you did in <a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm">Chapter 5, "The Client View"</a><a name="INDEX-1079"></a><a name="INDEX-1080"></a><a name="INDEX-1081"></a> with the <a name="INDEX-1082"></a><a name="INDEX-1083"></a> Cabin and TravelAgent beans.
</p>









<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch06_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">5.2. The EJB Client-Side API</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">6.2. Bean-Managed Persistence</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
