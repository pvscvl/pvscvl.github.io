<html>
<head>
<title>The EJB Client-Side API (Enterprise JavaBeans)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Richard Monson-Haefel">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-869-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="The EJB Client-Side API">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm" alt="Enterprise JavaBeans"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm">Chapter 5: The Client View</a></td><td align="right" valign="top" width="172"><a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">5.2. The EJB Client-Side API</h2>

<p>
<a name="INDEX-744"></a><a name="INDEX-745"></a>
Enterprise bean developers are required to provide a bean class, two
remote interfaces, and for entity beans, a primary key class. Of
these types, the remote interfaces and primary key class are visible
to the client, while the bean class is not. The remote interface,
home interface, and primary key contribute to the client-side API in
EJB. The methods defined in these types as well as the methods of
their supertypes provide the mechanisms that clients use to interact
with an EJB business system.
</p>

<p>The following sections examine in more detail the home interface, the
remote interface, and the primary key, as well as other types that
make up EJB's client-side API. This will provide you with a
better understanding of how the client-side API is used and its
relationship with the bean class on the EJB server.
</p>

<a name="JBEANS-CH-5-SECT-2.1"></a>
<h3 class="sect2">5.2.1. EJB 1.1: Java RMI-IIOP Conformance Requirement</h3>

<p>Enterprise JavaBeans 1.0 defines its distributed interfaces in terms
of Java RMI. RMI assumes that both the client and server are Java
applications, so it takes full advantage of Java types as arguments
and return values. Enterprise JavaBeans 1.1 also defines its
distributed interfaces in terms of Java RMI, but it enforces
compliance with <a name="INDEX-746"></a>CORBA's interface, reference, and
value types by requiring that only <a name="INDEX-747"></a>Java RMI-IIOP types be used. In
other words, the underlying protocol can be anything that the vendor
wants as long as it supports the types of interfaces and arguments
specified by Java RMI-IIOP. In a future version of EJB, Java RMI-IIOP
( Java RMI over IIOP) will be the required programming model for
accessing beans. Requiring partial support for the Java RMI-IIOP
standard ensures that early Java RMI-IIOP adopters are supported and
makes for a seamless transition for other vendors in the future.
</p>

<p>To be CORBA-compliant, Java RMI-IIOP had to restrict the definition
of interfaces and arguments to types that map nicely to CORBA. The
restrictions are really not all that bad, and you probably
won't even notice them while developing your beans, but
it's important to know what they are. The next few paragraphs
discuss the Java RMI programming model for both EJB 1.0 and EJB 1.1,
and point out the additional restrictions placed on RMI-IIOP types
after discussing the restrictions shared by traditional Java RMI and
Java RMI-IIOP.
</p>


<a name="JBEANS-CH-5-SECT-2.2"></a>
<h3 class="sect2">5.2.2. EJB 1.1 and 1.0: The Java RMI Programming Model</h3>

<p>The supertypes of the <a name="INDEX-748"></a>home interface and
<a name="INDEX-749"></a><a name="INDEX-750"></a><a name="INDEX-751"></a><a name="INDEX-752"></a>remote
interface,
<tt class="literal">javax.ejb.EJBHome</tt><a name="INDEX-753"></a> and
<tt class="literal">javax.ejb.EJBObject</tt><a name="INDEX-754"></a>, both extend
<a name="INDEX-755"></a><tt class="literal">java.rmi.Remote</tt>. As <tt class="literal">Remote</tt>
interface subtypes, they are expected to adhere to the Java RMI
specification for <tt class="literal">Remote</tt> interfaces. The Java RMI
specification states that every method defined in a
<tt class="literal">Remote</tt> interface must throw a
<a name="INDEX-756"></a><tt class="literal">java.rmi.RemoteException</tt>. The
<tt class="literal">RemoteException</tt> is used when problems occur with
the distributed object communications, like a network failure or
inability to locate the object server. In addition,
<tt class="literal">Remote</tt> interface types can throw any
application-specific exceptions (exceptions defined by the
application developer) that are necessary. The following code shows
the remote interface to the TravelAgent bean discussed in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a>. <tt class="literal">TravelAgent</tt> has several
remote methods, including <tt class="literal">bookPassage()</tt>. The
<tt class="literal">bookPassage()</tt> method can throw a
<tt class="literal">RemoteException</tt> (as required), in addition to an
<a name="INDEX-757"></a>
application exception,
<a name="INDEX-758"></a><tt class="literal">IncompleteConversationalState</tt>.
</p>

<blockquote>
<pre class="programlisting">public interface TravelAgent extends javax.ejb.EJBObject {

    public void setCruiseID(int cruise) throws RemoteException, FinderException;
    public int getCruiseID() throws RemoteException;
    
    public void setCabinID(int cabin) throws RemoteException, FinderException;
    public int getCabinID() throws RemoteException;
    
    public int getCustomerID() throws RemoteException;
    
    public Ticket bookPassage(CreditCard card, double price)
        throws RemoteException,IncompleteConversationalState; 
               
    public String [] listAvailableCabins(int bedCount)
        throws RemoteException, IncompleteConversationalState;
    
}</pre>
</blockquote>

<p>Java RMI requires that all parameters and return values be either
Java primitive types (<tt class="literal">int</tt>,
<tt class="literal">double</tt>, <tt class="literal">byte</tt>, etc.) or objects
that implement <tt class="literal">java.io.Serializable</tt>.
<a name="INDEX-759"></a><a name="INDEX-760"></a><a name="INDEX-761"></a>Serializable objects are passed by
copy (a.k.a. passed by value), not by reference, which means that
changes in a serialized object on one tier are not automatically
reflected on the others. Objects that implement
<tt class="literal">Remote</tt>, like <tt class="literal">Customer</tt>,
<tt class="literal">Cruise</tt>, and <tt class="literal">Cabin</tt>, are passed
as remote references--which is a little different. A remote
reference is a <tt class="literal">Remote</tt> interface implemented by a
distributed object stub. When a remote reference is passed as a
parameter or returned from a method, it is the stub that is
serialized and passed by value, not the object server remotely
referenced by the stub. In the home interface for the TravelAgent
bean, the <tt class="literal">create()</tt><a name="INDEX-762"></a> method
takes a reference to a Customer bean as its only argument.
</p>

<blockquote>
<pre class="programlisting">public interface TravelAgentHome extends javax.ejb.EJBHome {
    public TravelAgent create(Customer customer)
        throws RemoteException, CreateException;
}</pre>
</blockquote>

<p>The <tt class="literal">customer</tt> is a remote reference to a Customer
bean that is passed into the <tt class="literal">create()</tt> method. When
a remote reference is passed or returned in EJB, the EJB object
<a name="INDEX-763"></a>stub is passed by copy. The copy of the
EJB object stub points to the same EJB object as the original stub.
This results in both the bean instance and the client having remote
references to the same EJB object. So changes made on the client
using the remote reference will be reflected when the bean instance
uses the same remote reference. <a href="#JBEANS-CH-5-FIG-1">Figure 5-1</a> and
<a href="#JBEANS-CH-5-FIG-2">Figure 5-2</a> show the difference between a
serializable object and a <a name="INDEX-764"></a>remote reference argument in Java RMI.
</p>

<a name="JBEANS-CH-5-FIG-1"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0501.gif" webstripperlinkwas="figs/ejb2_0501.gif"></div>
<h4 class="objtitle">Figure 5-1. Serializable arguments in Java RMI</h4>

<a name="JBEANS-CH-5-FIG-2"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0502.gif" webstripperlinkwas="figs/ejb2_0502.gif"></div>
<h4 class="objtitle">Figure 5-2. Remote reference arguments in Java RMI</h4>

<a name="JBEANS-CH-5-SECT-2.2.1"></a>
<h3 class="sect3">5.2.2.1. EJB 1.1: Java RMI-IIOP type restrictions</h3>

<p>In addition to the Java RMI programming model discussed earlier, Java
RMI-IIOP imposes additional restrictions on the
<a name="INDEX-765"></a><a name="INDEX-766"></a>remote interfaces
and value types used in EJB 1.1. These restrictions are born of
limitations inherit in the <a name="INDEX-767"></a>
Interface Definition Language (IDL) upon which CORBA IIOP is based.
The exact nature of these limitations is outside the scope of this
book. I have only listed two restrictions because the others, like
IDL name collisions, are so rarely encountered that it wouldn't
be constructive to mention them.<a href="#FOOTNOTE-1">[1]</a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-1"></a>
<p>[1]To learn more about
CORBA IDL and its mapping to the Java language consult <em class="emphasis">The
Common Object Request Broker: Architecture and
Specification</em> and <em class="citetitle">The Java Language to IDL
Mapping</em> available at the OMG site (<a href="www.omg.org" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/www.omg.org">www.omg.org</a>).</p> </blockquote>

<ul>
<li>
<p>
<a name="INDEX-768"></a>Method overloading is restricted; a remote
interface may not <em class="emphasis">directly</em> extend two or more
interfaces that have methods with the same name (even if their
arguments are different). A remote interface may, however, overload
its own methods and extend a remote interface with overloaded method
names. Overloading is viewed, here, as including overriding. Figure
5-3 illustrates both of these situations.
</p>
</li>
</ul>
<a name="JBEANS-CH-5-FIG-3"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0503.gif" webstripperlinkwas="figs/ejb2_0503.gif"></div>
<h4 class="objtitle">Figure 5-3. Overloading rules for Remote interface inheritance in Java RMI-IIOP</h4>

<ul>
<li>
<p>
<tt class="literal">Serializable</tt> types must not directly or indirectly
implement the <tt class="literal">java.rmi.Remote</tt> interface.
</p>
</li>
</ul>


<a name="JBEANS-CH-5-SECT-2.2.2"></a>
<h3 class="sect3">5.2.2.2. EJB 1.1: Explicit narrowing using PortableRemoteObject</h3>

<p>A significant difference between EJB 1.0 and EJB 1.1 is that the new
specification requires that <a name="INDEX-769"></a><a name="INDEX-770"></a><a name="INDEX-771"></a>remote references be explicitly
narrowed using the
<tt class="literal">javax.rmi.PortableRemoteObject.narrow()</tt><a name="INDEX-772"></a> method. The typical
practice in Java would be to cast the reference to the more specific
<a name="INDEX-773"></a><a name="INDEX-774"></a>type, as follows:
</p>

<blockquote>
<pre class="programlisting">javax.naming.Context jndiContext;
...
CabinHome home = (CabinHome)jndiContext.lookup("CabinHome");</pre>
</blockquote>

<p>The
<tt class="literal">javax.naming.Context.lookup()</tt><a name="INDEX-775"></a><a name="INDEX-776"></a> method returns an
<tt class="literal">Object</tt>. In EJB 1.0, which uses simple Java RMI, we
can assume that it is legal to cast the return argument to a legal
Java type. However, EJB 1.1 must be compatible with Java RMI-IIOP,
which means that clients must adhere to limitations imposed by the
<a name="INDEX-777"></a><a name="INDEX-778"></a>IIOP protocol. IIOP is not
specific to any one programming language. As part of the
<a name="INDEX-779"></a>CORBA standard, it must accommodate
many programming languages including C++, Ada, COBOL, and others. All
programming languages do <em class="emphasis">not</em> support casting,
and for this reason casting is <em class="emphasis">not</em> native to
IIOP. In fact, some languages have no concept of
<a name="INDEX-780"></a><a name="INDEX-781"></a><a name="INDEX-782"></a>polymorphism or inheritance (COBOL for
example), so <a name="INDEX-783"></a>implicit casting in CORBA is out of the
question.
</p>

<p>To accommodate all languages, IIOP does not support
<a name="INDEX-784"></a>stubs that implement
multiple interfaces. The stub returned in IIOP implements only the
interface specified by the return type of the remote method that was
invoked. If the return type is <tt class="literal">Object</tt>, as is the
remote reference returned by the <tt class="literal">lookup()</tt> method,
the stub will only implement methods specific to the
<tt class="literal">Object</tt> type.
</p>

<p>Of course, some means for converting a remote reference from a more
general type to a more specific type is essential in an
object-oriented environment. CORBA provides a mechanism for
explicitly narrowing references to a specific type. The
<tt class="literal">javax.rmi.PortableRemoteObject.narrow()</tt> method
abstracts this mechanism to provide narrowing in IIOP as well as
other protocols. Remember while Java RMI-IIOP defines the reference
and argument types, in EJB 1.1 it does not define the underlying
protocol. Other protocols besides IIOP may also require explicit
narrowing. The <tt class="literal">PortableRemoteObject</tt> abstracts the
narrowing process so that any protocol can be used.
</p>

<p>To narrow the return argument of the
<tt class="literal">Context.lookup()</tt> method to the appropriate type,
we must explicitly ask for a remote reference that implements the
interface we want:
</p>

<blockquote>
<pre class="programlisting">import javax.rmi.PortableRemoteObject;
...
javax.naming.Context jndiContext;
...
Object ref = jndiContext.lookup("CabinHome");
CabinHome home = (CabinHome)
    PortableRemoteObject.narrow(ref, CabinHome.class);</pre>
</blockquote>

<p>When the <tt class="literal">narrow()</tt> method has successfully
executed, it returns a stub that implements the
<tt class="literal">Remote</tt> interface specified. Because the stub is
known to implement the correct type, you can now use Java's
native casting to narrow the stub to the correct
<tt class="literal">Remote</tt> interface. The <tt class="literal">narrow()</tt>
method takes two arguments: the remote reference that is to be
narrowed and the type it should be narrowed to. The definition of the
<tt class="literal">narrow()</tt><a name="INDEX-785"></a> method is:<a href="#FOOTNOTE-2">[2]</a>
</p>
<blockquote class="footnote">
<a name="FOOTNOTE-2"></a>
<p>[2]Other methods included in the
<tt class="literal">PortableRemoteObject</tt> class are not important to
EJB application developers. They are intended for Java RMI
developers.</p> </blockquote>

<blockquote>
<pre class="programlisting">package javax.rmi;

public class PortableRemoteObject extends java.lang.Object {

    public static java.lang.Object narrow(java.lang.Object narrowFrom,
                                         java.lang.Class narrowTo)
    throws java.lang.ClassCastException;
    ...
}</pre>
</blockquote>

<p>The <tt class="literal">narrow()</tt> method only needs to be used when a
<a name="INDEX-786"></a>remote reference to an EJB home or EJB
object is returned without a specific <tt class="literal">Remote</tt>
interface type. This occurs in six circumstances:
</p>

<ul>
<li>
<p>When an EJB home reference is obtained using the
<tt class="literal">javax.naming.Context.lookup()</tt> method:
</p>
</li>
</ul>
<blockquote>
<pre class="programlisting">Object ref = jndiContext.lookup("CabinHome");
CabinHome home = (CabinHome) PortableRemoteObject.narrow(ref, CabinHome.class);</pre>
</blockquote>
<ul>
<li>
<p>When an EJB object reference is obtained using the
<tt class="literal">javax.ejb.Handle.getEJBObject()</tt><a name="INDEX-787"></a><a name="INDEX-788"></a> method:
</p>
</li>
</ul>

<blockquote>
<pre class="programlisting">Handle handle = .... // get handle
Object ref = handle.getEJBObject();
Cabin cabin = (Cabin) PortableRemoteObject.narrow(ref,Cabin.class);</pre>
</blockquote>
<ul>
<li>
<p>When an EJB home reference is obtained using the
<tt class="literal">javax.ejb.HomeHandle.getEJBHome()</tt><a name="INDEX-789"></a><a name="INDEX-790"></a> method:
</p>
</li>
</ul>

<blockquote>
<pre class="programlisting">HomeHandle homeHdle = ... // get home handle
EJBHome ref = homeHdle.getEJBHome(); 
CabinHome home = (CabinHome)
    PortableRemoteObject.narrow(ref, CabinHome.class);</pre>
</blockquote>
<ul>
<li>
<p>When an EJB home reference is obtained using the
<tt class="literal">javax.ejb.EJBMetaData.getEJBHome()</tt><a name="INDEX-791"></a><a name="INDEX-792"></a> method:
</p>
</li>
</ul>

<blockquote>
<pre class="programlisting">EJBMetaData metaData = homeHdle.getEJBMetaData();
EJBHome ref = metaData.getEJBHome();
CabinHome home = (CabinHome) PortableRemoteObject.narrow(ref, CabinHome.class);</pre>
</blockquote>
<ul>
<li>
<p>When an EJB object reference is obtained from a collection returned
by a Home interface finder method:
</p>
</li>
</ul>

<blockquote>
<pre class="programlisting">ShipHome shipHome = ... // get ship home
Enumeration enum = shipHome.findByCapacity(2000);
while(enum.hasMoreElements()){
    Object ref = enum.nextElement();
    Ship ship = (Ship) PortableRemoteObject.narrow(ref, Ship.class);
    // do something with Ship reference
}</pre>
</blockquote>
<ul>
<li>
<p>When a wide EJB object type is returned from any
<a name="INDEX-793"></a><a name="INDEX-794"></a>business
method. Here is a hypothetical example:
</p>
</li>
</ul>

<blockquote>
<pre class="programlisting">// Officer extends Crewman
Ship ship = // get Ship remote reference
Crewman crew = ship.getCrewman("Burns", "John", "1st Lieutenant");
Officer burns = (Officer) PortableRemoteObject.narrow(crew, Officer.class);</pre>
</blockquote>

<p>The <tt class="literal">PortableRemoteObject.narrow()</tt><a name="INDEX-795"></a>method is not required when the
remote type is specified in the method signature. This is true of the
<tt class="literal">create()</tt> methods and find methods that return a
single bean. For example, the <tt class="literal">create()</tt> and
<tt class="literal">findByPrimaryKey()</tt> methods defined in the
<tt class="literal">CabinHome</tt> interface (<a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>)
do not require the use of <tt class="literal">narrow()</tt> because these
methods already return the correct EJB object type. Business methods
that return the correct type do not need to use the
<tt class="literal">narrow()</tt> method either, as the following code
illustrates:
<a name="INDEX-796"></a><a name="INDEX-797"></a><a name="INDEX-798"></a>
</p>

<blockquote>
<pre class="programlisting">/* The CabinHome.create() method specifies 
 * the Cabin remote interface as the return type 
 * so explicit narrowing is not needed.*/
Cabin cabin = cabinHome.create(12345);

/* The CabinHome.findByPrimaryKey() method specifies 
 * the Cabin remote interface as the return type 
 * so explicit narrowing is not needed.*/
Cabin cabin = cabinHome.findByPrimaryKey(12345);

/* The Ship.getCrewman() business method specifies 
 * the Crewman remote interface as the return type 
 * so explicit narrowing is not needed.*/
Crewman crew = ship.getCrewman("Burns", "John", "1st Lieutenant");</pre>
</blockquote>



<a name="JBEANS-CH-5-SECT-2.3"></a>
<h3 class="sect2">5.2.3. The Home Interface</h3>

<p>
<a name="INDEX-799"></a><a name="INDEX-800"></a>The
home interface provides life-cycle operations and metadata for the
bean. When you use JNDI to access a bean, you obtain a remote
reference, or stub, to the bean's EJB home, which implements
the home interface. Every bean type has one home interface, which
extends the <a name="INDEX-801"></a><tt class="literal">javax.ejb.EJBHome</tt> interface.
</p>

<p>Here is the <tt class="literal">EJBHome</tt><a name="INDEX-802"></a> interface for EJB 1.1:
</p>

<blockquote>
<pre class="programlisting">// EJB 1.1
public interface javax.ejb.EJBHome extends java.rmi.Remote {
    public abstract EJBMetaData <tt class="userinput"><b>getEJBMetaData</b></tt>()
      throws RemoteException;
    public HomeHandle <tt class="userinput"><b>getHomeHandle</b></tt>()    // new in 1.1
      throws RemoteException;
    public abstract void <tt class="userinput"><b>remove</b></tt>(Handle handle)
      throws RemoteException, RemoveException;
    public abstract void <tt class="userinput"><b>remove</b></tt>(Object primaryKey)
      throws RemoteException, RemoveException;
}</pre>
</blockquote>

<p>EJB 1.1 adds the
<tt class="literal">getHomeHandle()</tt><a name="INDEX-803"></a> method for accessing the
<tt class="literal">HomeHandle</tt><a name="INDEX-804"></a>, which doesn't exist in EJB 1.0:
</p>

<blockquote>
<pre class="programlisting">// EJB 1.0
public interface javax.ejb.EJBHome extends java.rmi.Remote {
    public abstract EJBMetaData <tt class="userinput"><b>getEJBMetaData</b></tt>()
      throws RemoteException;
    public abstract void <tt class="userinput"><b>remove</b></tt>(Handle handle)
      throws RemoteException, RemoveException;
    public abstract void <tt class="userinput"><b>remove</b></tt>(Object primaryKey)
      throws RemoteException, RemoveException;
}</pre>
</blockquote>

<a name="ch05-8-fm2xml"></a>
<h3 class="sect3">5.2.3.1. Removing beans</h3>

<p>
<a name="INDEX-805"></a>
The <a name="INDEX-806"></a><a name="INDEX-807"></a><tt class="literal">EJBHome.remove()</tt>
methods are responsible for deleting a bean. The argument is either
the <tt class="literal">javax.ejb.Handle</tt> of the bean or, if it's
an entity bean, its primary key. The <tt class="literal">Handle</tt> will
be discussed in more detail later, but it is essentially a
serializable pointer to a specific bean. When either of the
<tt class="literal">EJBHome.remove()</tt> methods are invoked, the remote
reference to the bean on the client becomes invalid: the stub to the
bean that was removed no longer works. If for some reason the bean
can't be removed, a <tt class="literal">RemoveException</tt> is
thrown.
</p>

<p>The impact of the <a name="INDEX-808"></a><a name="INDEX-809"></a><tt class="literal">EJBHome.remove()</tt>
on the bean itself depends on the type of bean. For session beans,
the <tt class="literal">EJBHome.remove()</tt> methods end the
session's service to the client. When
<tt class="literal">EJBHome.remove()</tt> is invoked, the remote reference
to the <a name="INDEX-810"></a>session beans becomes invalid, and
any conversational state maintained by the bean is lost. The
TravelAgent bean is stateless, so no conversational state exists
(more about this in <a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">Chapter 7, "Session Beans"</a>).
</p>

<p>When a <tt class="literal">remove()</tt> method is invoked on an
<a name="INDEX-811"></a>entity
bean, the remote reference becomes invalid, and any data that it
represents is actually deleted from the database. This is a far more
destructive activity because once an entity bean is removed, the data
that it represents no longer exists. The difference between using a
<tt class="literal">remove()</tt> method on a session bean and using
<tt class="literal">remove()</tt> on an entity bean is similar to the
difference between hanging up on a telephone conversation and
actually killing the caller on the other end. Both end the
conversation, but the end results are a little different.
</p>

<p>The following code fragment is taken from the
<tt class="literal">main()</tt><a name="INDEX-812"></a>
 method of a client application that is similar to the clients we
created to exercise the Cabin and TravelAgent beans. It shows that
you can remove beans using a <a name="INDEX-813"></a>
primary key (entity only) or a
<a name="INDEX-814"></a>handle. Removing an entity bean deletes
the entity from the database; removing a session bean results in the
remote reference becoming invalid.
</p>

<blockquote>
<pre class="programlisting">Context jndiContext = getInitialContext();

// Obtain a list of all the cabins for ship 1 with bed count of 3.

// EJB 1.0: Use native cast instead of narrow()
Object ref = jndiContext.lookup("TravelAgentHome");
TravelAgentHome agentHome = (TravelAgentHome)
    PortableRemoteObject.narrow(ref,TravelAgentHome.class);

TravelAgent agent = agentHome.create();
String list [] = agent.listCabins(1,3);  
System.out.println("1st List: Before deleting cabin number 30");
for(int i = 0; i &lt; list.length; i++){
    System.out.println(list[i]);
}

// Obtain the CabinHome and remove cabin 30. Rerun the same cabin list.

// EJB 1.0: Use native cast instead of narrow()
ref = jndiContext.lookup("CabinHome");
CabinHome c_home = (CabinHome)
    PortableRemoteObject.narrow(ref, CabinHome.class);

CabinPK pk = new CabinPK();
pk.id = 30;
c_home.remove(pk);
list = agent.listCabins(1,3);  
System.out.println("2nd List: After deleting cabin number 30");
for (int i = 0; i &lt; list.length; i++) {
    System.out.println(list[i]);
}</pre>
</blockquote>

<p>Your output should look something like the following:</p>

<blockquote>
<pre class="programlisting">1st List: Before deleting cabin number 30
1,Master Suite                  ,1
3,Suite 101                     ,1
5,Suite 103                     ,1
7,Suite 105                     ,1
9,Suite 107                     ,1
12,Suite 201                     ,2
14,Suite 203                     ,2
16,Suite 205                     ,2
18,Suite 207                     ,2
20,Suite 209                     ,2
22,Suite 301                     ,3
24,Suite 303                     ,3
26,Suite 305                     ,3
28,Suite 307                     ,3
30,Suite 309                     ,3
2nd List: After deleting cabin number 30
1,Master Suite                  ,1
3,Suite 101                     ,1
5,Suite 103                     ,1
7,Suite 105                     ,1
9,Suite 107                     ,1
12,Suite 201                     ,2
14,Suite 203                     ,2
16,Suite 205                     ,2
18,Suite 207                     ,2
20,Suite 209                     ,2
22,Suite 301                     ,3
24,Suite 303                     ,3
26,Suite 305                     ,3
28,Suite 307                     ,3</pre>
</blockquote>

<p>First, we create a list of cabins, including the cabin with the
primary key 30. Then we remove the Cabin bean with this primary key
and create the list again. The second time through, cabin 30 is not
listed. Because it was removed, the <tt class="literal">listCabin()</tt>
method was unable to find a cabin with a
<tt class="literal">CabinPK.id</tt> equal to 30, so it stopped making the
list. The bean, including its data, is no longer in the <a name="INDEX-815"></a><a name="INDEX-816"></a> database.
</p>



<a name="JBEANS-CH-5-SECT-2.3.2"></a>
<h3 class="sect3">5.2.3.2. Bean metadata</h3>

<p>
<tt class="literal">EJBHome.getEJBMetaData()</tt><a name="INDEX-817"></a><a name="INDEX-818"></a> returns an instance of
<tt class="literal">javax.ejb.EJBMetaData</tt><a name="INDEX-819"></a> that describes the home interface,
remote interface, and primary key classes, plus whether the bean is a
session or entity bean. This type of metadata is valuable to Java
tools like IDEs that have wizards or other mechanisms for interacting
with a bean from a client's perspective. A tool could, for
example, use the class definitions provided by the
<tt class="literal">EJBMetaData</tt> with Java reflection to create an
environment where deployed beans can be "wired" together
by developers. Of course, information such as the JNDI names and URLs
of the beans is also needed.
</p>

<p>Most application developers rarely use the
<tt class="literal">EJBMetaData</tt>. Knowing that it's there,
however, is valuable when you need to create automatic code
generators or some other automatic facility. In those cases,
familiarity with the Reflection API is necessary.<a href="#FOOTNOTE-3">[3]</a> The following code
shows the interface definition for <tt class="literal">EJBMetaData</tt>.
Any class that implements the <tt class="literal">EJBMetaData</tt>
interface must be <a name="INDEX-820"></a>
serializable; it cannot be a stub to a distributed object. This
allows IDEs and other tools to save the
<tt class="literal">EJBMetaData</tt> for later use.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-3"></a>
<p>[3]
The Reflection API is outside the scope of this book, but it is
covered in <em class="emphasis">Java&#153; in a Nutshell</em>, by David
Flanagan (O'Reilly).</p> </blockquote>

<blockquote>
<pre class="programlisting">public interface javax.ejb.EJBMetaData {
    public abstract EJBHome <tt class="userinput"><b>getEJBHome</b></tt>();
    public abstract Class <tt class="userinput"><b>getHomeInterfaceClass</b></tt>();
    public abstract Class <tt class="userinput"><b>getPrimaryKeyClass</b></tt>();
    public abstract Class <tt class="userinput"><b>getRemoteInterfaceClass</b></tt>();
    public abstract boolean <tt class="userinput"><b>isSession</b></tt>();
}</pre>
</blockquote>

<p>The following code shows how the <tt class="literal">EJBMetaData</tt> for
the Cabin bean could be used to get more information about the bean.
Notice that there is no way to get the bean class using the
<tt class="literal">EJBMetaData</tt>; the <a name="INDEX-821"></a>bean
class is not part of the client API and therefore doesn't
belong to the metadata.
</p>

<blockquote>
<pre class="programlisting">Context jndiContext = getInitialContext();

// EJB 1.0: Use native cast instead of narrow()
Object ref = jndiContext.lookup("CabinHome");
CabinHome c_home = (CabinHome)
    PortableRemoteObject.narrow(ref, CabinHome.class);

EJBMetaData meta = c_home.getEJBMetaData();

System.out.println(meta.getHomeInterfaceClass().getName());
System.out.println(meta.getRemoteInterfaceClass().getName());
System.out.println(meta.getPrimaryKeyClass().getName());
System.out.println(meta.isSession());</pre>
</blockquote>

<p>This creates output like the following:</p>

<blockquote>
<pre class="programlisting">com.titan.cabin.CabinHome
com.titan.cabin.Cabin
com.titan.cabin.CabinPK
false</pre>
</blockquote>

<p>In addition to providing the class types of the bean, the
<tt class="literal">EJBMetaData</tt> also makes available the EJB home for
the bean. By obtaining the EJB home from the
<tt class="literal">EJBMetaData</tt>, we can obtain references to the EJB
object and perform other functions. In the following code, we use the
<tt class="literal">EJBMetaData</tt> to get the <a name="INDEX-822"></a>
primary key class, create a key instance, obtain the EJB home, and
from it, get a remote reference to the EJB object for a specific
cabin entity:
<a name="INDEX-823"></a><a name="INDEX-824"></a>
</p>

<blockquote>
<pre class="programlisting">CabinPK pk = (CabinPK)meta.getPrimaryKeyClass().newInstance();
pk.id = 1;

// EJB 1.0: Use native cast instead of narrow()
Object ref = meta.getEJBHome();
CabinHome c_home2 = (CabinHome)
    PortableRemoteObject.narrow(ref,CabinHome.class);

Cabin cabin = c_home2.findByPrimaryKey(pk);
System.out.println(cabin.getName());</pre>
</blockquote>



<a name="JBEANS-CH-5-SECT-2.3.3"></a>
<h3 class="sect3">5.2.3.3. EJB 1.1: The HomeHandle</h3>

<p>EJB 1.1 provides a new object called a <tt class="literal">HomeHandle</tt>,
which is accessed by calling the
<tt class="literal">EJBObject.getHomeHandle()</tt><a name="INDEX-825"></a><a name="INDEX-826"></a><a name="INDEX-827"></a> method. This method returns a
<tt class="literal">javax.ejb.HomeHandle</tt> object, which provides a
serializable reference to a bean home. The
<tt class="literal">HomeHandle</tt> allows a remote home reference to be
stored and used later. It is similar to the
<tt class="literal">javax.ejb.Handle</tt> and is discussed in more detail
near the end of the chapter.
</p>



<a name="JBEANS-CH-5-SECT-2.3.4"></a>
<h3 class="sect3">5.2.3.4. Creating and finding beans</h3>

<p>
<a name="INDEX-828"></a><a name="INDEX-829"></a><a name="INDEX-830"></a>In addition to the standard
<tt class="literal">javax.ejb.EJBHome</tt> methods that all home interfaces
inherit, <a name="INDEX-831"></a>home interfaces also include special
<em class="emphasis">create</em> and <em class="emphasis">find</em> methods for
the bean. We have already talked about create and find methods, but a
little review will solidify your understanding of the home
interface's role in the client-side API. The following code
shows the home interface defined for the Cabin bean:
</p>

<blockquote>
<pre class="programlisting">public interface CabinHome extends javax.ejb.EJBHome {
    public Cabin <tt class="userinput"><b>create</b></tt>(int id)
        throws CreateException, RemoteException;

    public Cabin <tt class="userinput"><b>findByPrimaryKey</b></tt>(CabinPK pk)
        throws FinderException, RemoteException;
}</pre>
</blockquote>

<p>Create methods throw a <tt class="literal">CreateException</tt> if
something goes wrong during the creation process; find methods throw
a <tt class="literal">FinderException</tt> if the requested bean
can't be located. Since these methods are defined in an
interface that subclasses <tt class="literal">Remote</tt>, they must also
declare that they throw <tt class="literal">RemoteException</tt>.
</p>

<p>The <a name="INDEX-832"></a><a name="INDEX-833"></a>create and find methods are
specific to the bean, so it is up to the bean developer to define the
appropriate create and find methods in the home interface.
<tt class="literal">CabinHome</tt> currently has only one create method
that creates a cabin with a specified ID and a find method that looks
up a bean given its primary key, but it's easy to imagine
methods that would create and find a cabin with particular
properties--for example, a cabin with three beds, or a deluxe
cabin with blue wallpaper. Unlike entity beans, the home interfaces
for <a name="INDEX-834"></a><a name="INDEX-835"></a>
session beans do not have find methods. Entity beans represent unique
identifiable data within a database and therefore can be found.
Session beans, on the other hand, do not represent data: they are
created to serve a client application and are not persistent, so
there is nothing to find. A find method for a session bean would be
meaningless.
</p>

<p>
<a name="INDEX-836"></a><a name="INDEX-837"></a><a name="INDEX-838"></a><a name="INDEX-839"></a>
The create and find methods defined in the home interfaces are
straightforward and can be easily employed by the client. The create
methods on the home interface have to match the
<tt class="literal">ejbCreate()</tt> methods on the bean class. A
<tt class="literal">create</tt><a name="INDEX-840"></a>() and
<tt class="literal">ejbCreate()</tt><a name="INDEX-841"></a> method match when
they have the same parameters, when the arguments are of same type
and in the same order. This way, when a client calls the create
method on the home interface, the call can be delegated to the
corresponding <tt class="literal">ejbCreate()</tt> method on the bean
instance. The find methods in the home interface work similarly for
bean-managed entities. Every find method in the home interface must
correspond to an <tt class="literal">ejbFind()</tt> method in the bean
itself. Container-managed entities do not implement
<tt class="literal">ejbFind()</tt> methods in the bean class; the EJB
container supports find methods automatically. You will discover more
about how to implement the <tt class="literal">ebjCreate()</tt> and
<tt class="literal">ejbFind()</tt> methods in the <a name="INDEX-842"></a><a name="INDEX-843"></a> bean in Chapters
<a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a> and <a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">Chapter 7, "Session Beans"</a>.<a name="INDEX-844"></a><a name="INDEX-845"></a>
</p>



<a name="JBEANS-CH-5-SECT-2.4"></a>
<h3 class="sect2">5.2.4. The Remote Interface</h3>

<p>
<a name="INDEX-846"></a><a name="INDEX-847"></a>The
business methods of an enterprise bean are defined by the remote
interface provided by the bean developer. The
<tt class="literal">javax.ejb.EJBObject</tt> interface, which extends the
<tt class="literal">java.rmi.Remote</tt> interface, is the base class for
all remote interfaces.
</p>

<p>The following code is the remote interface for the TravelAgent bean
that we developed in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>:
</p>

<blockquote>
<pre class="programlisting">public interface TravelAgent extends javax.ejb.EJBObject {

    public String [] listCabins(int shipID, int bedCount)
        throws RemoteException;
}</pre>
</blockquote>

<p>
<a href="#JBEANS-CH-5-FIG-4">Figure 5-4</a> shows the <tt class="literal">TravelAgent</tt>
interface's inheritance hierarchy.
</p>

<a name="JBEANS-CH-5-FIG-4"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0504.gif" webstripperlinkwas="figs/ejb2_0504.gif"></div>
<h4 class="objtitle">Figure 5-4. Enterprise bean interface inheritance hierarchy</h4>

<p>Remote interfaces are focused on the business problem and do not
include methods for system-level operations such as persistence,
security, concurrency, or transactions. System-level operations are
handled by the EJB server, which relieves the client developer of
many responsibilities. All remote interface methods for beans must
throw, at the very least, a
<a name="INDEX-848"></a><a name="INDEX-849"></a><tt class="literal">java.rmi.RemoteException</tt>, which identifies
problems with distributed communications. In addition, methods in the
remote interface can throw as many custom exceptions as needed to
indicate abnormal business-related conditions or errors in executing
the business method. You will learn more about defining custom
exceptions in <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>.
</p>


<a name="JBEANS-CH-5-SECT-2.5"></a>
<h3 class="sect2">5.2.5. EJBObject, Handle, and Primary Key</h3>

<p>All remote interfaces extend the
<tt class="literal">javax.ejb.EJBObject</tt> interface, which provides a
set of utility methods and return types. These methods and return
types are valuable in managing the client's interactions with
beans. Here is the definition for the <a name="INDEX-850"></a><a name="INDEX-851"></a><tt class="literal">EJBObject</tt> interface:
</p>

<blockquote>
<pre class="programlisting">public interface javax.ejb.EJBObject extends java.rmi.Remote {
    public abstract EJBHome <tt class="userinput"><b>getEJBHome</b></tt>()
        throws RemoteException;
    public abstract Handle <tt class="userinput"><b>getHandle</b></tt>() 
        throws RemoteException;
    public abstract Object <tt class="userinput"><b>getPrimaryKey</b></tt>() 
        throws RemoteException;
    public abstract boolean <tt class="userinput"><b>isIdentical</b></tt>(EJBObject obj) 
        throws RemoteException;
    public abstract void <tt class="userinput"><b>remove</b></tt>() 
        throws RemoteException, RemoveException;
}</pre>
</blockquote>

<p>When the client obtains a reference to the remote interface, it is
actually obtaining a remote reference to an EJB object. The EJB
object implements the remote interface by delegating business method
calls to the bean class; it provides its own implementations for the
<tt class="literal">EJBObject</tt> methods. These methods return
information about the corresponding bean instance on the server. As
discussed in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a>, the EJB object is
automatically generated when deploying the bean in the EJB server, so
the bean developer doesn't need to write an
<tt class="literal">EJBObject</tt> implementation.
</p>

<a name="JBEANS-CH-5-SECT-2.5.1"></a>
<h3 class="sect3">5.2.5.1. Getting the EJBHome</h3>

<p>The
<tt class="literal">getEJBHome()</tt><a name="INDEX-852"></a><a name="INDEX-853"></a>
 method returns a remote reference to the EJB home for the bean. The
remote reference is returned as a <a name="INDEX-854"></a><tt class="literal">javax.ejb.EJBHome</tt>
object, which can be narrowed or cast to the specific bean's
home interface. This method is useful when an EJB object has left the
scope of the EJB home that manufactured it. Because remote references
can be passed as references and returned from methods, like any other
Java object on the client, a remote reference can quickly find itself
in a completely different part of the application from its home. The
following code is contrived, but it illustrates how a remote
reference can move out of the scope of its home and how
<tt class="literal">getEJBHome()</tt> can be used to get a new reference to
the EJB home at any time:
</p>

<blockquote>
<pre class="programlisting">public static void main(String [] args) {
    try {
        Context jndiContext = getInitialContext();  
        // EJB 1.0: Use native cast instead of narrow()
        Object ref = jndiContext.lookup("TravelAgentHome");
        TravelAgentHome home = (TravelAgentHome)
            PortableRemoteObject.narrow(ref,TravelAgentHome.class);

        // Get a remote reference to the bean (EJB object).
        TravelAgent agent = home.create();
        // Pass the remote reference to some method.
        getTheEJBHome(agent);

        } catch (java.rmi.RemoteException re){re.printStackTrace();}
          catch (Throwable t){t.printStackTrace();}
}

public static void getTheEJBHome(TravelAgent agent)
    throws RemoteException {

    // The home interface is out of scope in this method,
    // so it must be obtained from the EJB object.
    // EJB 1.0: Use native cast instead of narrow()
    Object ref = agent.getEJBHome();
    TravelAgentHome home = (TravelAgentHome)
        PortableRemoteObject.narrow(ref,TravelAgentHome.class); 
// Do something useful with the home interface.
}</pre>
</blockquote>



<a name="JBEANS-CH-5-SECT-2.5.2"></a>
<h3 class="sect3">5.2.5.2. Primary key</h3>

<p>
<a name="INDEX-855"></a><a name="INDEX-856"></a><a name="INDEX-857"></a><tt class="literal">EJBObject.getPrimaryKey()</tt><a name="INDEX-858"></a> returns the primary key for a bean.
This method is only supported by EJB objects that represent
<a name="INDEX-859"></a>entity beans. Entity beans represent
specific data that can be identified using this primary key. Session
beans represent tasks or processes, not data, so a primary key would
be meaningless. To better understand the nature of a primary key, we
need to look beyond the boundaries of the client's view into
the EJB container's layer, which was introduced in Chapters
<a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a> and <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>.
</p>

<p>The EJB
<a name="INDEX-860"></a>
container is responsible for persistence of the entity beans, but the
exact mechanism for persistence is up to the vendor. In order to
locate an instance of a bean in a persistent store, the data that
makes up the entity must be mapped to some kind of unique key. In
relational databases, data is uniquely identified by one or more
column values that can be combined to form a primary key. In an
object-oriented database, the key wraps an <a name="INDEX-861"></a>object ID (OID) or some kind of
database pointer. Regardless of the mechanism--which isn't
really relevant from the client's perspective--the unique
key for an entity bean's data is
<a name="INDEX-862"></a>encapsulated by the primary key, which
is returned by the <tt class="literal">EJBObject.getPrimaryKey()</tt>
method.
</p>

<p>The primary key can be used to obtain remote references to entity
beans using the <tt class="literal">findByPrimaryKey()</tt> method on the
home interface. From the client's perspective, the primary key
object can be used to identify a unique entity bean. Understanding
the context of a primary key's uniqueness is important, as the
following code shows:
</p>

<blockquote>
<pre class="programlisting">Context jndiContext = getInitialContext()
 
// EJB 1.0: Use native cast instead of narrow()
Object ref = jndiContext.lookup("CabinHome");
CabinHome home = (CabinHome)
    PortableRemoteObject.narrow(ref,CabinHome.class);

Cabin cabin_1 = home.create(101);
<b class="emphasis-bold">CabinPK pk = (CabinPK)cabin_1.getPrimaryKey();</b>
Cabin cabin_2 = home.findByPrimaryKey(pk);</pre>
</blockquote>

<p>In this code, the client creates a Cabin, retrieves the primary key
of that Cabin, and then uses the key to get a new reference to the
Cabin. Thus, we have two local variables, <tt class="literal">cabin_1</tt>
and <tt class="literal">cabin_2</tt>, which are remote references to EJB
objects. These both reference the same Cabin bean, with the same
underlying data, because they have the same primary key.
</p>

<p>The primary key must be used for the correct bean in the correct
container. If, for example, you were to obtain a primary key from a
Cabin EJB object and then try to use that key in the
<tt class="literal">findByPrimaryKey()</tt> method of a different bean
type, like a Ship bean, it wouldn't work; either it
wouldn't compile or you would get a runtime error or
<tt class="literal">FinderException</tt><a name="INDEX-863"></a>
. While this seems fairly obvious, the primary key's
relationship to a specific container and home interface is important.
The primary key can only be guaranteed to return the same entity if
it is used within the container that produced the key. As an example,
imagine that a third-party vendor sells the Cabin bean as a product.
The vendor sells the Cabin bean to both Titan and to a competitor.
Both companies deploy the bean using their own relational databases
with their own data. A <tt class="literal">CabinPK</tt> primary key with an
<tt class="literal">id</tt> value of 20 in Titan's EJB system will
not map to the same Cabin entity in the competitor's EJB
system. Both cruise companies have a Cabin bean with an
<tt class="literal">id</tt> equal to 20, but they represent different
cabins for different ships. The Cabin beans come from different EJB
containers, so their primary keys are not equivalent.
</p>

<p>
<em class="emphasis">Sun Microsystems' Enterprise JavaBeans&#153;
Specification,</em> Versions 1.0 and 1.1, describes the primary
key and object identity in the following way:
</p>

<p>Every entity EJB object has a unique identity with its home....If two EJB objects have the same home and same primary key, they are considered identical.</p>

<p>
<a name="INDEX-864"></a><a name="INDEX-865"></a><a name="INDEX-866"></a><a name="INDEX-867"></a>A primary key must
implement the <tt class="literal">java.io.Serializable</tt> interface. This
means that the primary key, regardless of its form, can be obtained
from an EJB object, stored on the client using the Java serialization
mechanism, and deserialized when needed. When a primary key is
deserialized, it can be used to obtain a remote reference to that
entity using <tt class="literal">findByPrimaryKey()</tt>, provided that the
key is used on the right home interface and container. Preserving the
primary key using serialization might be useful if the client
application needs to access specific entity beans at a later date. In
EJB 1.0, preserving the primary keys is also useful for beans that
maintain relationships to other beans. Bean relationships are
discussed in more detail in <a href="ch09_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch09_01.htm">Chapter 9, "Design Strategies"</a>.
</p>

<p>The following code shows a primary key that is serialized and then
deserialized to reobtain a remote reference to the same bean:
<a name="INDEX-868"></a><a name="INDEX-869"></a><a name="INDEX-870"></a>
</p>

<blockquote>
<pre class="programlisting">// Obtain cabin 101 and set its name.
Context jndiContext = getInitialContext(); 

// EJB 1.0: Use native cast instead of narrow()
Object ref = jndiContext.lookup("CabinHome");
CabinHome home = (CabinHome)
    PortableRemoteObject.narrow(ref, CabinHome.class);

CabinPK pk_1 = new CabinPK();
pk_1.id = 101;
Cabin cabin_1 = home.findByPrimaryKey(pk_1);
cabin_1.setName("Presidential Suite");

// Serialize the primary key for cabin 101 to a file.
FileOutputStream fos = new FileOutputStream("pk101.ser");
ObjectOutputStream outStream = new ObjectOutputStream(fos);
outStream.writeObject(pk_1);
outStream.flush();
outStream.close();
pk_1 = null;

// Deserialize the primary key for cabin 101.
FileInputStream fis = new FileInputStream("pk101.ser");
ObjectInputStream inStream = new ObjectInputStream(fis);
CabinPK pk_2 = (CabinPK)inStream.readObject();
inStream.close();

// Re-obtain a remote reference to cabin 101 and read its name.
Cabin cabin_2 = home.findByPrimaryKey(pk_2);
System.out.println(cabin_2.getName());</pre>
</blockquote>



<a name="JBEANS-CH-5-SECT-2.5.3"></a>
<h3 class="sect3">5.2.5.3. Comparing beans for identity</h3>

<p>
<a name="INDEX-871"></a><a name="INDEX-872"></a>The
<a name="INDEX-873"></a><a name="INDEX-874"></a><tt class="literal">EJBObject.isIdentical()</tt> method compares two EJB
object remote references. It's worth considering why
<tt class="literal">Object.equals()</tt><a name="INDEX-875"></a><a name="INDEX-876"></a> isn't sufficient for comparing
EJB objects. An EJB object is a distributed object stub and therefore
contains a lot of networking and other state. As a result, references
to two EJB objects may be unequal, even if they both represent the
same unique bean. The <tt class="literal">EJBObject.isIdentical()</tt>
method returns <tt class="literal">true</tt> if two EJB object references
represent the same bean, even if the EJB object stubs are different
object instances.
</p>

<p>The following code shows how this might work. It starts by creating
two remote references to the TravelAgent bean. These EJB objects both
refer to the same type of bean; comparing them with
<tt class="literal">isIdentical()</tt> returns <tt class="literal">true</tt>. The
two TravelAgent beans were created separately, but because they are
stateless they are considered to be equivalent. If TravelAgent had
been a stateful bean (which it becomes in <a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">Chapter 7, "Session Beans"</a>) the outcome would have been very different.
Comparing two stateful beans in this manner will result in
<tt class="literal">false</tt> because stateful beans have conversational
state, which makes them unique. When we use
<tt class="literal">CabinHome.findByPrimaryKey()</tt> to locate two EJB
objects that refer to the same Cabin entity bean, we know the beans
are identical, because we used the same primary key. In this case,
<tt class="literal">isIdentical()</tt> also returns <tt class="literal">true</tt>
because both EJB object references point to the same entity.
</p>

<blockquote>
<pre class="programlisting">Context ctx  = getInitialContext();

// EJB 1.0: Use native cast instead of narrow()
Object ref = ctx.lookup("TravelAgentHome");
TravelAgentHome agentHome =(TravelAgentHome) 
    PortableRemoteObject.narrow(ref, TravelAgentHome.class);

TravelAgent agent_1 = agentHome.create();
TravelAgent agent_2 = agentHome.create();
boolean x = agent_1.isIdentical(agent_2);
// x will equal true; the two EJB objects are equal.

// EJB 1.0: Use native cast instead of narrow()
ref = ctx.lookup("CabinHome");
CabinHome c_home = (CabinHome) 
    PortableRemoteObject.narrow(ref, CabinHome.class);

CabinPK pk = new CabinPK();
pk.id = 101;
Cabin cabin_1 = c_home.findByPrimaryKey(pk);
Cabin cabin_2 = c_home.findByPrimaryKey(pk);
x = cabin_1.isIdentical(cabin_2); 
// x will equal true; the two EJB objects are equal.</pre>
</blockquote>

<p>The primary key used in the Cabin bean is simple. More complex
primary keys require us to override
<tt class="literal">Object.equals()</tt> and
<tt class="literal">Object.hashCode()</tt> in order for the
<tt class="literal">EJBObject.isIdentical()</tt> method to work. <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a> discusses this in more detail.
</p>



<a name="JBEANS-CH-5-SECT-2.5.4"></a>
<h3 class="sect3">5.2.5.4. Removing beans</h3>

<p>
<a name="INDEX-877"></a><a name="INDEX-878"></a><a name="INDEX-879"></a><a name="INDEX-880"></a>The
<tt class="literal">EJBObject.remove()</tt> method is used to remove the
session or entity bean. The impact of this method is the same as the
<tt class="literal">EJBHome.remove()</tt> method discussed previously. For
session beans, <tt class="literal">remove()</tt> causes the session to be
released and the EJB object reference to become invalid. For entity
beans, the actual entity data is deleted from the database and the
remote reference becomes invalid. The following code shows the
<tt class="literal">EJBObject.remove()</tt> method in use:
</p>

<blockquote>
<pre class="programlisting">Context jndiContext = getInitialContext();

// EJB 1.0: Use native cast instead of narrow()
Object ref = jndiContext.lookup("CabinHome");
CabinHome c_home = (CabinHome)
    PortableRemoteObject.narrow(ref,CabinHome.class);

CabinPK pk = new CabinPK();
pk.id = 101;
Cabin cabin = c_home.findByPrimaryKey(pk);
cabin.remove();</pre>
</blockquote>

<p>The <tt class="literal">remove()</tt> method throws a
<tt class="literal">RemoveException</tt> if for some reason the reference
can't be deleted.
</p>



<a name="JBEANS-CH-5-SECT-2.5.5"></a>
<h3 class="sect3">5.2.5.5. The bean handle</h3>

<p>
<a name="INDEX-881"></a><a name="INDEX-882"></a>The
<tt class="literal">EJBObject.getHandle()</tt><a name="INDEX-883"></a> method returns a
<tt class="literal">javax.ejb.Handle</tt> object. The
<tt class="literal">Handle</tt> is a serializable reference to the EJB
object. This means that the client can save the
<tt class="literal">Handle</tt> object using Java serialization and then
deserialize it to reobtain a reference to the same EJB object. This
is similar to serializing and reusing the primary key. The
<tt class="literal">Handle</tt> allows us to recreate an EJB object remote
reference that points to the same <em class="emphasis">type</em> of
session bean or the same unique entity bean that the handle came
from.
</p>

<p>Here is the interface definition of the <tt class="literal">Handle</tt>:</p>

<blockquote>
<pre class="programlisting">public interface javax.ejb.Handle {
    public abstract EJBObject <tt class="userinput"><b>getEJBObject</b></tt>()
      throws RemoteException;
}</pre>
</blockquote>

<p>The <tt class="literal">Handle</tt> interface specifies only one method,
<tt class="literal">getEJBObject()</tt><a name="INDEX-884"></a><a name="INDEX-885"></a>. Calling this method returns the
EJB object from which the handle was created. Once you've
gotten the object back, you can narrow or cast it to the appropriate
remote-interface type. The following code shows how to serialize and
deserialize the
<a name="INDEX-886"></a><a name="INDEX-887"></a>EJB
<tt class="literal">Handle</tt> on a client:
</p>

<blockquote>
<pre class="programlisting">// Obtain cabin 100.
Context jndiContext = getInitialContext();

// EJB 1.0: Use native cast instead of narrow()
Object ref = jndiContext.lookup("CabinHome");
CabinHome home = (CabinHome)
    PortableRemoteObject.narrow(ref,CabinHome.class);

CabinPK pk_1 = new CabinPK();
pk_1.id = 100;
Cabin cabin_1 = home.findByPrimaryKey(pk_1);

// Serialize the Handle for cabin 100 to a file.
<b class="emphasis-bold">Handle handle = cabin_1.getHandle();</b>
FileOutputStream fos = new FileOutputStream("handle100.ser");
ObjectOutputStream outStream = new ObjectOutputStream(fos);
<b class="emphasis-bold">outStream.writeObject(handle);</b>
outStream.flush();
fos.close();
handle = null;

// Deserialize the Handle for cabin 100.
FileInputStream fis = new FileInputStream("handle100.ser");
ObjectInputStream inStream = new ObjectInputStream(fis);
<b class="emphasis-bold">handle = (Handle)inStream.readObject();</b>
fis.close();

// Reobtain a remote reference to cabin 100 and read its name.

// EJB 1.0: Use native cast instead of narrow()
<b class="emphasis-bold">ref = handle.getEJBObject();</b>
<b class="emphasis-bold">Cabin cabin_2 = (Cabin)</b>
<b class="emphasis-bold">    PortableRemoteObject.narrow(ref, Cabin.class);</b>

System.out.println(cabin_2.getName());</pre>
</blockquote>

<p>
<a name="INDEX-888"></a><a name="INDEX-889"></a>At first
glance, the <tt class="literal">Handle</tt> and the primary key appear to
do the same thing, but in truth they are very different. Using the
primary key requires you to have the correct EJB home--if you no
longer have a reference to the EJB home, you must look up the
container using JNDI and get a new home. Only then can you call
<tt class="literal">findByPrimaryKey()</tt> to locate the actual bean. The
following code shows how this might work:
</p>

<blockquote>
<pre class="programlisting">// Obtain the primary key from an input stream.
CabinPK primaryKey = (CabinPK)inStream.readObject();

// The JNDI API is used to get a root directory or initial context.
javax.naming.Context ctx = new javax.naming.InitialContext();

// Using the initial context, obtain the EJBHome for the Cabin bean.

// EJB 1.0: Use native cast instead of narrow()
Object ref = ctx.lookup("CabinHome");
CabinHome home = (CabinHome)
    PortableRemoteObject.narrow(ref,CabinHome.class);

// Obtain a reference to an EJB object that represents the entity instance.
Cabin cabin_2 = CabinHome.findByPrimaryKey(primaryKey);</pre>
</blockquote>

<p>The <tt class="literal">Handle</tt> object is easier to use because it
encapsulates the details of doing a JNDI lookup on the container.
With a <tt class="literal">Handle</tt>, the correct EJB object can be
obtained in one method call,
<tt class="literal">Handle.getEJBObject()</tt>, rather than using the three
method calls required to look up the context, get the home, and find
the actual bean.
</p>

<p>Furthermore, while the primary key can be used to obtain remote
references to unique <em class="emphasis">entity</em> beans, it is not
available for session beans; a
<a name="INDEX-890"></a><a name="INDEX-891"></a>handle can be used with either type of
enterprise bean. This makes using a handle more consistent across
bean types. Consistency is, of course, good in its own right, but it
isn't the whole story. Normally, we think of session beans as
not having identifiable instances because they exist for only the
life of the client session, but this is not exactly true. We have
mentioned (but not yet shown) stateful session beans, which retain
state information between method invocations. With stateful session
beans, two instances are not equivalent. A handle allows you to work
with a stateful session bean, deactivate the bean, and then
reactivate it at a later time using the handle.
</p>

<p>A client could, for example, be using a stateful session bean to
process an order when the process needs to be interrupted for some
reason. Instead of losing all the work performed in the session, a
handle can be obtained from the EJB object and the client application
can be closed down. When the user is ready to continue the order, the
handle can be used to obtain a reference to the stateful session EJB
object. Note that this process is not as fault tolerant as using the
handle or primary key of an entity object. If the EJB server goes
down or crashes, the stateful session bean will be lost and the
handle will be useless. It's also possible for the session bean
to time out, which would cause the container to remove it from
service so that it is no longer available to the client.
</p>

<p>
<a name="INDEX-892"></a>Changes to the container technology
can invalidate both handles and primary keys. If you think your
container technology might change, be careful to take this limitation
into account. Primary keys obtain EJB objects by providing unique
identification of instances in persistent data stores. A change in
the persistence mechanism, however, can impact the integrity of the
key.
</p>



<a name="JBEANS-CH-5-SECT-2.5.6"></a>
<h3 class="sect3">5.2.5.6. EJB 1.1: HomeHandle</h3>

<p>The
<tt class="literal">javax.ejb.HomeHandle</tt><a name="INDEX-893"></a> is similar in purpose to
<tt class="literal">javax.ejb.Handle</tt>. Just as the
<tt class="literal">Handle</tt> is used to store and retrieve references to
EJB objects, the <tt class="literal">HomeHandle</tt> is used to store and
retrieve remote references to EJB homes. In other words, the
<tt class="literal">HomeHandle</tt> can be stored and later used to access
an EJB home's remote reference the same way that a
<tt class="literal">Handle</tt> can be serialized and later used to access
an EJB object's remote reference. The
<tt class="literal">HomeHandle</tt> and the method
<tt class="literal">EJBHome.getHomeHandle()</tt> are new to EJB 1.1. The
following code shows how the <tt class="literal">HomeHandle</tt> can be
obtained, serialized, and used.
</p>

<blockquote>
<pre class="programlisting">// Obtain cabin 100.
Context jndiContext = getInitialContext();

// EJB 1.0: Use native cast instead of narrow()
Object ref = jndiContext.lookup("CabinHome");
CabinHome home = (CabinHome)
    PortableRemoteObject.narrow(ref,CabinHome.class);

// Serialize the HomeHandle for the cabin bean.
<b class="emphasis-bold">HomeHandle homeHandle = home.getHomeHandle();</b>
FileOutputStream fos = new FileOutputStream("handle.ser");
ObjectOutputStream outStream = new ObjectOutputStream(fos);
<b class="emphasis-bold">outStream.writeObject(homeHandle);</b>
outStream.flush();
fos.close();
homeHandle = null;

// Deserialize the HomeHandle for the cabin bean.
FileInputStream fis = new FileInputStream("handle.ser");
ObjectInputStream inStream = new ObjectInputStream(fis);
<b class="emphasis-bold">homeHandle = (HomeHandle)inStream.readObject();</b>
fis.close();

// EJB 1.0: Use native cast instead of narrow()
<b class="emphasis-bold">EJBHome home = homeHandle.getEJBHome();</b>
<b class="emphasis-bold">CabinHome home2 = (CabinHome)</b>
<b class="emphasis-bold">    PortableRemoteObject.narrow(home,CabinHome.class);</b>
</pre>
</blockquote>



<a name="JBEANS-CH-5-SECT-2.6"></a>
<h3 class="sect2">5.2.6. Inside the Handle</h3>

<p>
<a name="INDEX-894"></a>
Different <a name="INDEX-895"></a><a name="INDEX-896"></a> vendors define their concrete
implementations of the EJB handle differently. However, thinking
about a hypothetical implementation of handles will give you a better
understanding of how they work. In this example, we define the
implementation of a handle for an <a name="INDEX-897"></a>entity bean. Our implementation
encapsulates the JNDI lookup and use of the home's
<tt class="literal">findByPrimaryKey()</tt><a name="INDEX-898"></a>
 method so that any change that invalidates the key invalidates
preserved handles that depend on that key. Here's the code for
our hypothetical implementation of a <tt class="literal">Handle</tt>:
</p>

<blockquote>
<pre class="programlisting">package com.titan.cabin;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NamingException;
import javax.ejb.EJBObject;
import javax.ejb.Handle;
import java.rmi.RemoteException;
import java.util.Properties;

public class VendorX_CabinHandle
    implements javax.ejb.Handle, java.io.Serializable {

    private CabinPK primary_key;
    private String home_name;
    private Properties jndi_properties;

    public VendorX_CabinHandle(CabinPK pk, String hn, Properties p) {
        primary_key = pk;
        home_name = hn;
        jndi_properties = p;
    }

    public EJBObject getEJBObject() throws RemoteException {
      try {
        Context ctx = new InitialContext(jndi_properties);
   
       // EJB 1.0: Use native cast instead of narrow()
       Object ref = ctx.lookup(home_name);
       CabinHome home =(CabinHome)
           PortableRemoteObject.narrow(ref,CabinHome.class);

       return home.findByPrimaryKey(primary_key);
      } catch (javax.ejb.FinderException fe) {
            throw new RemoteException("Cannot locate EJB object",fe);
      } catch (javax.naming.NamingException ne) {
            throw new RemoteException("Cannot locate EJB object",ne);
      }
    }
}</pre>
</blockquote>

<p>The <tt class="literal">Handle</tt> is less stable than the primary key
because it relies on the networking configuration and
naming--the IP address of the EJB server and the JNDI name of
the bean's home--to remain stable. If the EJB
server's network address changes or the name used to identify
the home changes, the handle becomes useless.
</p>

<p>In addition, some vendors choose to implement a security mechanism in
the handle that prevents its use outside the scope of the client
application that originally requested it. How this mechanism would
work is unclear, but the security limitation it implies should be
considered before attempting to use a <a name="INDEX-899"></a><a name="INDEX-900"></a> handle <a name="INDEX-901"></a><a name="INDEX-902"></a> outside the client's
scope.<a name="INDEX-903"></a><a name="INDEX-904"></a>
</p>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">5.1. Locating Beans with JNDI</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">6. Entity Beans</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
