<html>
<head>
<title>Developing an Entity Bean (Enterprise JavaBeans)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Richard Monson-Haefel">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-869-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Developing an Entity Bean">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm" alt="Enterprise JavaBeans"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4: Developing Your First Enterprise Beans</a></td><td align="right" valign="top" width="172"><a href="ch04_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">4.2. Developing an Entity Bean</h2>

<p>
<a name="INDEX-548"></a>There seems to be no better place
to start than the Cabin bean, which we have been examining throughout
the previous chapters. The Cabin bean is an entity bean that
encapsulates the data and behavior associated with a real-world
cruise ship cabin in Titan's business domain.
</p>

<a name="JBEANS-CH-4-SECT-2.1"></a>
<h3 class="sect2">4.2.1. Cabin: The Remote Interface</h3>

<p>
<a name="INDEX-549"></a><a name="INDEX-550"></a>When developing an entity bean, we
first want to define the bean's remote interface. The remote
interface defines the bean's <a name="INDEX-551"></a>business purpose; the methods of
this interface must capture the concept of the entity. We defined the
remote interface for the Cabin bean in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a>;
here, we add two new methods for setting and getting the ship ID and
the bed count. The ship ID identifies the ship that the cabin belongs
to, and the bed count tells how many people the cabin can
accommodate.
</p>

<blockquote>
<pre class="programlisting">package com.titan.cabin;

import java.rmi.RemoteException;

public interface Cabin extends javax.ejb.EJBObject {
    public String getName() throws RemoteException;
    public void setName(String str) throws RemoteException;
    public int getDeckLevel() throws RemoteException;
    public void setDeckLevel(int level) throws RemoteException;
<b class="emphasis-bold">    public int getShip() throws RemoteException;</b>
<b class="emphasis-bold">    public void setShip(int sp) throws RemoteException;</b>
<b class="emphasis-bold">    public int getBedCount() throws RemoteException;</b>
<b class="emphasis-bold">    public void setBedCount(int bc) throws RemoteException; </b>
}</pre>
</blockquote>

<p>The <tt class="literal">Cabin</tt> interface defines four properties: the
<tt class="literal">name</tt>, <tt class="literal">deckLevel</tt>,
<tt class="literal">ship</tt>, and <tt class="literal">bedCount</tt>.
<a name="INDEX-552"></a><a name="INDEX-553"></a><em class="emphasis">Properties</em> are attributes of a bean that can be
accessed by public set and get methods. The methods that access these
properties are not explicitly defined in the <tt class="literal">Cabin</tt>
interface, but the interface clearly specifies that these attributes
are readable and changeable by a client.
</p>

<p>Notice that we have made the <tt class="literal">Cabin</tt> interface a
part of a new package named <tt class="literal">com.titan.cabin</tt>. In
this book, we place all the classes and interfaces associated with
each type of bean in a package specific to the bean. Because our
beans are for the use of the Titan cruise line, we place these
packages in the <tt class="literal">com.titan</tt> package hierarchy. We
also create directory structures that match package structures. If
you are using an IDE that works directly with Java files, create a
new directory somewhere called <em class="filename">dev</em> (for
development) and create the <a name="INDEX-554"></a>
directory structure shown in <a href="#JBEANS-CH-4-FIG-1">Figure 4-1</a>. Copy the
<tt class="literal">Cabin</tt> interface into your IDE and save its
definition to the <em class="emphasis">cabin</em> directory. Compile the
<tt class="literal">Cabin</tt> interface to ensure that its definition is
correct. The <em class="emphasis">Cabin.class</em> file, generated by the
IDE's compiler, should be written to the
<em class="emphasis">cabin</em> directory, the same directory as the
<em class="emphasis">Cabin.java</em>file.
</p>

<a name="JBEANS-CH-4-FIG-1"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0401.gif" webstripperlinkwas="figs/ejb2_0401.gif"></div>
<h4 class="objtitle">Figure 4-1. Directory structure for the Cabin bean</h4>


<a name="JBEANS-CH-4-SECT-2.2"></a>
<h3 class="sect2">4.2.2. CabinHome: The Home Interface</h3>

<p>
<a name="INDEX-555"></a><a name="INDEX-556"></a>
Once we have defined the remote interface of the Cabin bean, we have
defined the world's view of this simple entity bean. Next, we
need to define the Cabin bean's home interface, which specifies
how the bean can be created, located, and destroyed; in other words,
the Cabin bean's life-cycle behavior. Here is a complete
definition of the <tt class="literal">CabinHome</tt> home interface:
</p>

<blockquote>
<pre class="programlisting">package com.titan.cabin;

import java.rmi.RemoteException;
import javax.ejb.CreateException;
import javax.ejb.FinderException;

public interface CabinHome extends javax.ejb.EJBHome {

    public Cabin create(int id)
        throws CreateException, RemoteException;

    public Cabin findByPrimaryKey(CabinPK pk)
        throws FinderException, RemoteException;
}</pre>
</blockquote>

<p>The <tt class="literal">CabinHome</tt> interface extends the
<a name="INDEX-557"></a><tt class="literal">javax.ejb.EJBHome</tt> and defines two life- cycle
methods: <tt class="literal">create()</tt><a name="INDEX-558"></a> and
<tt class="literal">findByPrimaryKey()</tt><a name="INDEX-559"></a>. These methods create and locate
Cabin beans. Remove methods (for deleting beans) are defined in the
<tt class="literal">javax.ejb.EJBHome</tt> interface, so the
<tt class="literal">CabinHome</tt> interface inherits them. This interface
is packaged in <tt class="literal">com.titan.cabin</tt>, just like the
<tt class="literal">Cabin</tt> interface. It should be copied to your IDE
and saved as <em class="emphasis">CabinHome.java</em> in the same
directory as the <em class="emphasis">Cabin.java</em> file. If you attempt
to compile the <tt class="literal">CabinHome</tt> interface, you will get
an error stating that the <tt class="literal">CabinPK</tt> class could not
be found. Next, we will create the <tt class="literal">CabinPK</tt> class
to correct this problem.
</p>


<a name="JBEANS-CH-4-SECT-2.3"></a>
<h3 class="sect2">4.2.3. CabinPK: The Primary Key</h3>

<p>
<a name="INDEX-560"></a><a name="INDEX-561"></a>The
<tt class="literal">CabinPK</tt> is the primary key class of the Cabin
bean. All entity beans must have a serializable primary key that can
be used to uniquely identify an entity bean in the database. Here is
the class definition of the <tt class="literal">CabinPK</tt> primary key:
</p>

<blockquote>
<pre class="programlisting">package com.titan.cabin;

public class CabinPK implements java.io.Serializable {
    public int id;

    public int hashCode() {
        return id;
    }
    public boolean equals(Object obj) {
        if (obj instanceof CabinPK) {
            return (id == ((CabinPK)obj).id);
        }
        return false;
    } 
}</pre>
</blockquote>

<p>The primary <a name="INDEX-562"></a>
key belongs to the <tt class="literal">com.titan.cabin</tt> package and
implements the <tt class="literal">java.io.Serializable</tt> interface. The
<tt class="literal">CabinPK</tt> defines one public attribute,
<tt class="literal">id.</tt> This <tt class="literal">id</tt> field is used to
locate specific <tt class="literal">Cabin</tt> entities or records in the
database at runtime. EJB 1.1 requires that we override the
<tt class="literal">Object.hashCode()</tt> and
<tt class="literal">Object.equals()</tt> methods; EJB 1.0 doesn't
require this, but it's a good practice regardless of the
version of EJB you are using. These methods ensure that the primary
key evaluates properly when used with hash tables and in other
situations.<a href="#FOOTNOTE-2">[2]</a> Later, we will learn that the
primary key must encapsulate attributes that match one or more
container-managed fields in the bean class. In this case, the
<tt class="literal">id</tt> field will have to match a field in the
<tt class="literal">CabinBean</tt> class. Copy the
<tt class="literal">CabinPK</tt> definition into your IDE, and save it to
the cabin directory as <em class="emphasis">CabinPK.java</em> file.
Compile it. Now that <tt class="literal">CabinPK</tt> has been compiled,
you should be able to compile <tt class="literal">CabinHome</tt> without
errors.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-2"></a>
<p>[2]In <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>
and <a href="ch09_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch09_01.htm">Chapter 9, "Design Strategies"</a>, we discuss implementing the
<tt class="literal">hashCode()</tt>and <tt class="literal">equals()</tt>methods
in more detail.</p> </blockquote>


<a name="JBEANS-CH-4-SECT-2.4"></a>
<h3 class="sect2">4.2.4. CabinBean: The Bean Class</h3>

<p>You <a name="INDEX-563"></a><a name="INDEX-564"></a>have now defined the complete
client-side API for creating, locating, removing, and using the Cabin
bean. Now we need to define <tt class="literal">CabinBean</tt>, the class
that provides the implementation on the server for the Cabin bean.
The <tt class="literal">CabinBean</tt> class is an entity bean that uses
container-managed persistence, so its definition will be fairly
simple. In addition to the callback methods discussed in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a> and <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>, we
must also define EJB implementations for most of the methods defined
in the <tt class="literal">Cabin</tt> and <tt class="literal">CabinHome</tt>
interfaces. Here is the complete definition of the
<tt class="literal">CabinBean</tt> class in EJB 1.1:
</p>

<blockquote>
<pre class="programlisting">// EJB 1.1 CabinBean
package com.titan.cabin;

import javax.ejb.EntityContext;

public class CabinBean implements javax.ejb.EntityBean {

    public int id;
    public String name;
    public int deckLevel;
    public int ship;
    public int bedCount;
<b class="emphasis-bold">    public CabinPK ejbCreate(int id) {</b>
<b class="emphasis-bold">        this.id = id;</b>
<b class="emphasis-bold">        return null;</b>
<b class="emphasis-bold">    }</b>
    public void ejbPostCreate(int id) {
        // Do nothing. Required.
    }
    public String getName() {
        return name;
    }
    public void setName(String str) {
        name = str;
    }
    public int getShip() {
        return ship;
    }
    public void setShip(int sp) {
        ship = sp;
    }
    public int getBedCount() {
        return bedCount;
    }
    public void setBedCount(int bc) {
        bedCount = bc;
    }  
    public int getDeckLevel() {
        return deckLevel;
    }
    public void setDeckLevel(int level ) {
        deckLevel = level;
    }

    public void setEntityContext(EntityContext ctx) {
         // Not implemented.
    }
    public void unsetEntityContext() {
         // Not implemented.
    }
    public void ejbActivate() {
        // Not implemented.
    }
    public void ejbPassivate() {
        // Not implemented.
    }
    public void ejbLoad() {
        // Not implemented.
    }
    public void ejbStore() {
        // Not implemented.
    }
    public void ejbRemove() {
        // Not implemented.
    }
}</pre>
</blockquote>

<p>And here's the <tt class="literal">CabinBean</tt> class for EJB 1.0.
It differs only in the return value of
<tt class="literal">ejbCreate()</tt>:
</p>

<blockquote>
<pre class="programlisting">// EJB 1.0 CabinBean
import javax.ejb.EntityContext;

public class CabinBean implements javax.ejb.EntityBean {

    public int id;
    public String name;
    public int deckLevel;
    public int ship;
    public int bedCount;
<b class="emphasis-bold">    public void ejbCreate(int id) {</b>
<b class="emphasis-bold">        this.id = id;</b>
<b class="emphasis-bold">    }</b>
    public void ejbPostCreate(int id) {
        // Do nothing. Required.
    }
    public String getName() {
        return name;
    }
    public void setName(String str) {
        name = str;
    }
    public int getShip() {
        return ship;
    }
    public void setShip(int sp) {
        ship = sp;
    }
    public int getBedCount() {
        return bedCount;
    }
    public void setBedCount(int bc) {
        bedCount = bc;
    }  
    public int getDeckLevel() {
        return deckLevel;
    }
    public void setDeckLevel(int level ) {
        deckLevel = level;
    }

    public void setEntityContext(EntityContext ctx) {
        // Not implemented.
    }
    public void unsetEntityContext() {
        // Not implemented.
    }
    public void ejbActivate(){
        // Not implemented.
    }
    public void ejbPassivate(){
        // Not implemented.
    }
    public void ejbLoad(){
        // Not implemented.
    }
    public void ejbStore(){
        // Not implemented.
    }
    public void ejbRemove(){
        // Not implemented.
    }
}</pre>
</blockquote>

<p>The <tt class="literal">CabinBean</tt> class belongs to the
<tt class="literal">com.titan.cabin</tt> package, just like the interfaces
and primary key class. The <tt class="literal">CabinBean</tt> class can be
divided into four sections for discussion: declarations for the
container-managed fields, the <tt class="literal">ejbCreate()</tt> methods,
the callback methods, and the remote interface implementations.
</p>

<p>
<a name="INDEX-565"></a><a name="INDEX-566"></a>Declared fields in a bean class can
be persistent fields and property fields. These categories are not
mutually exclusive. The <a name="INDEX-567"></a>persistent field declarations describe
the fields that will be mapped to the database. A persistent field is
often a property (in the JavaBeans sense): any attribute that is
available using public set and get methods. Of course, a bean can
have any fields that it needs; they need not all be persistent, or
properties. Fields that aren't persistent won't be saved
in the database. In <tt class="literal">CabinBean</tt>, all the fields are
persistent.
</p>

<p>The <tt class="literal">id</tt> field is persistent, but it is not a
property. In other words, <tt class="literal">id</tt> is mapped to the
database but cannot be accessed through the remote interface. The
primary key, <tt class="literal">CabinPK</tt>, also contains an integer
field called <tt class="literal">id</tt>, just like the
<tt class="literal">CabinBean</tt>. This means that the primary key for the
<tt class="literal">CabinBean</tt> is its <tt class="literal">id</tt> field
because the signatures match.
</p>

<p>The <tt class="literal">name</tt>, <tt class="literal">deckLevel</tt>,
<tt class="literal">ship</tt>, and <tt class="literal">bedCount</tt> fields are
persistent fields. They will be mapped to the database at deployment
time. These fields are also properties because they are publicly
available through the remote interface.
</p>

<p>In the case of the Cabin bean, there was only one
<tt class="literal">create()</tt> method, so there is only one
corresponding <a name="INDEX-568"></a><tt class="literal">ejbCreate()</tt> method and one
<a name="INDEX-569"></a><tt class="literal">ejbPostCreate()</tt> method, which is shown in both the
EJB 1.1 and EJB 1.0 listings. When a client invokes a method on the
home interface, it is delegated to a matching
<tt class="literal">ejbCreate()</tt> method on the bean instance. The
<tt class="literal">ejbCreate()</tt> method initializes the fields; in the
case of the <tt class="literal">CabinBean</tt>, it sets the
<tt class="literal">id</tt> field to equal the passed integer.
</p>

<p>In the case of EJB 1.0, the <tt class="literal">ejbCreate()</tt> method
returns <tt class="literal">void</tt> for container-managed persistence;
this method returns the bean's primary key in bean-managed
persistence. In EJB 1.1, the <tt class="literal">ejbCreate()</tt> method
always returns the primary key type; with container-managed
persistence, this method returns the <tt class="literal">null</tt> value.
It's the container's responsibility to create the primary
key. Why the change? Simply put, the change makes it easier for a
bean-managed bean to extend a container-managed bean. In EJB 1.0,
this is not possible because Java won't allow you to overload
methods with different return values. Container-managed and
bean-managed persistence was touched on in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a> and is discussed in detail in <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>.
</p>

<p>Once the <tt class="literal">ejbCreate()</tt> method has executed, the
<tt class="literal">ejbPostCreate()</tt> method is called to perform any
follow-up operations. The <tt class="literal">ejbCreate()</tt> and
<tt class="literal">ejbPostCreate()</tt> methods must have signatures that
match the parameters and (optionally) the exceptions of the home
interface's <tt class="literal">create()</tt> method. However,
<tt class="literal">ejbCreate()</tt> and <tt class="literal">ejbPostCreate()</tt>
aren't required to throw the <tt class="literal">RemoteException</tt>
or <tt class="literal">CreateException</tt>. The EJB container throws these
exceptions automatically at runtime if there is a problem with
communications or some other system-level problem.
</p>

<p>
<a name="INDEX-570"></a><a name="INDEX-571"></a>The
<tt class="literal">findByPrimaryKey()</tt><a name="INDEX-572"></a> method is not defined in
container-managed bean classes. With container-managed beans you do
not explicitly declare find methods in the bean class. Instead, find
methods are generated at deployment and implemented by the container.
With bean-managed beans (beans that explicitly manage their own
persistence), find methods must be defined in the bean class. Our
Cabin bean is a container-managed bean, so we will not need to define
its find method. In <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>, when you develop
bean-managed entity beans, you will define the find methods in the
bean classes you develop.
</p>

<p>
<a name="INDEX-573"></a><a name="INDEX-574"></a>The business methods in the
<tt class="literal">CabinBean</tt> match the signatures of the business
methods defined in the remote interface. These include
<tt class="literal">getName()</tt>, <tt class="literal">setName()</tt>,
<tt class="literal">getDeckLevel()</tt>, <tt class="literal">setDeckLevel()</tt>,
<tt class="literal">getShip()</tt>, <tt class="literal">setShip()</tt>,
<tt class="literal">getBedCount()</tt>, and
<tt class="literal">setBedCount()</tt>. When a client invokes one of these
methods on the remote interface, the method is delegated to the
matching method on the bean class. Again, the business methods do not
throw the <tt class="literal">RemoteException</tt> like the matching
methods in the remote interface. In both the
<tt class="literal">ejbCreate()</tt> and remote interface methods, it is
possible to define application or custom exceptions. If a custom
exception is defined, both the interface method and its matching
method in the bean class must throw it. We will learn more about
custom exceptions in <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>.
</p>

<p>
<a name="INDEX-575"></a>The entity context methods are
responsible for setting and unsetting the
<tt class="literal">EntityContext</tt>. The
<a name="INDEX-576"></a><tt class="literal">EntityContext</tt> is an interface implemented by the
EJB container that provides the bean with information about the
container, the identity of the client, transactional control, and
other environmental information if the bean needs it. Because the
Cabin bean is a very simple container-managed bean, this example does
not use the <tt class="literal">EntityContext</tt>. Subsequent examples in
<a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a> will make good use of the
<tt class="literal">EntityContext</tt>.
</p>

<p>
<a name="INDEX-577"></a><a name="INDEX-578"></a>The <tt class="literal">CabinBean</tt> class
implements <a name="INDEX-579"></a><tt class="literal">javax.ejb.EntityBean</tt>, which defines five callback
methods: <tt class="literal">ejbActivate()</tt>,
<tt class="literal">ejbPassivate()</tt>, <tt class="literal">ejbLoad()</tt>,
<tt class="literal">ejbStore()</tt>, and <tt class="literal">ejbRemove()</tt>.
The container uses these callback methods to notify the
<tt class="literal">CabinBean</tt> of certain events in its life cycle.
Although the callback methods are implemented, the implementations
are empty. The <tt class="literal">CabinBean</tt> is simple enough that it
doesn't need to do any special processing during its life
cycle. When we study entity beans in more detail in <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch06_01.htm">Chapter 6, "Entity Beans"</a>, we will take advantage of these callback
methods.
</p>

<p>That's enough talk about the <tt class="literal">CabinBean</tt>
definition. Now that you are familiar with it, copy it to your IDE,
save it to the cabin directory as
<em class="filename">CabinBean.java</em>, and compile it.
</p>

<p>You are now ready to create a deployment descriptor for the
<tt class="literal">Cabin</tt> bean. The <a name="INDEX-580"></a><a name="INDEX-581"></a>deployment descriptor performs a
function similar to a properties file. It describes which classes
make up a bean and how the bean should be managed at runtime. During
deployment, the deployment descriptor is read and its properties are
displayed for editing. The deployer can then modify and add settings
as appropriate for the application's operational environment.
Once the deployer is satisfied with the deployment information, he or
she uses it to generate the entire supporting infrastructure needed
to deploy the bean in the EJB server. This may include adding the
bean to the naming system and generating the bean's EJB object
and EJB home, persistence infrastructure, transactional support,
resolving bean references, and so forth.
</p>

<p>Although most EJB server products provide a wizard for creating and
editing deployment descriptors, we will create ours directly so that
the bean is defined in a vendor-independent manner. This requires
some manual labor, but it gives you a much better understanding of
how deployment descriptors are created. Once the deployment
descriptor is finished, the bean can be placed in a JAR file and
deployed on any EJB-compliant server of the appropriate <a name="INDEX-582"></a><a name="INDEX-583"></a> version.
</p>


<a name="JBEANS-CH-4-SECT-2.5"></a>
<h3 class="sect2">4.2.5. EJB 1.1: The Deployment Descriptor</h3>

<p>An XML deployment descriptor for every example in this book has
already been created and is available from the download site. If you
haven't downloaded the examples, do so now. The examples are
packaged in a ZIP file and organized by chapter and bean, so you will
need to put the <em class="emphasis">ejb-jar.xml</em> file from the
directory <em class="filename">chapter4/EJB11/com/titan/cabin</em> in the
ZIP file. When you create the <a name="INDEX-584"></a>JAR file to deploy the Cabin
bean, this <em class="emphasis">ejb-jar.xml</em> file
<em class="emphasis">must</em> be in the JAR as
<em class="filename">META-INF/ejb-jar.xml </em>in order for it to be
found. If it has any other name or any other location, this
deployment descriptor will not be used.
</p>

<p>Here's a quick peek at the deployment descriptor for the Cabin
bean, so you can get a feel for how an XML deployment descriptor is
structured and the type of information it contains:
</p>

<blockquote>
<pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE ejb-jar PUBLIC "-//Sun Microsystems, Inc.//DTD Enterprise
JavaBeans 1.1//EN" "http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd"&gt;

&lt;ejb-jar&gt;
 &lt;enterprise-beans&gt;
   &lt;entity&gt;
      &lt;description&gt;
          This Cabin enterprise bean entity represents a cabin on 
          a cruise ship.
      &lt;/description&gt;
      &lt;ejb-name&gt;CabinBean&lt;/ejb-name&gt;
      &lt;home&gt;com.titan.cabin.CabinHome&lt;/home&gt;
      &lt;remote&gt;com.titan.cabin.Cabin&lt;/remote&gt;
      &lt;ejb-class&gt;com.titan.cabin.CabinBean&lt;/ejb-class&gt;
      &lt;persistence-type&gt;Container&lt;/persistence-type&gt;
      &lt;prim-key-class&gt;com.titan.cabin.CabinPK&lt;/prim-key-class&gt;
      &lt;reentrant&gt;False&lt;/reentrant&gt;

      &lt;cmp-field&gt;&lt;field-name&gt;id&lt;/field-name&gt;&lt;/cmp-field&gt;
      &lt;cmp-field&gt;&lt;field-name&gt;name&lt;/field-name&gt;&lt;/cmp-field&gt;
      &lt;cmp-field&gt;&lt;field-name&gt;deckLevel&lt;/field-name&gt;&lt;/cmp-field&gt;
      &lt;cmp-field&gt;&lt;field-name&gt;ship&lt;/field-name&gt;&lt;/cmp-field&gt;
      &lt;cmp-field&gt;&lt;field-name&gt;bedCount&lt;/field-name&gt;&lt;/cmp-field&gt;
   &lt;/entity&gt;
 &lt;/enterprise-beans&gt;
 
 &lt;assembly-descriptor&gt;
   &lt;security-role&gt;
      &lt;description&gt;
          This role represents everyone who is allowed full access 
          to the cabin bean.
      &lt;/description&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
   &lt;/security-role&gt;

   &lt;method-permission&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
     &lt;method&gt;
         &lt;ejb-name&gt;CabinBean&lt;/ejb-name&gt;
         &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
   &lt;/method-permission&gt;

   &lt;container-transaction&gt;
     &lt;method&gt;
        &lt;ejb-name&gt;CabinBean&lt;/ejb-name&gt;
        &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
     &lt;trans-attribute&gt;Required&lt;/trans-attribute&gt;
   &lt;/container-transaction&gt;
 &lt;/assembly-descriptor&gt;
&lt;/ejb-jar&gt;</pre>
</blockquote>

<p>The <tt class="literal">&lt;!DOCTYPE&gt;</tt><a name="INDEX-585"></a><a name="INDEX-586"></a> element describes
the purpose of the XML file, its root element, and the location of
its DTD. The DTD is used to verify that the document is structured
correctly. This element is discussed in detail in <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch10_01.htm">Chapter 10, "XML Deployment Descriptors"</a> and is not important to understanding this
example.
</p>

<p>The rest of the
<a name="INDEX-587"></a>elements are nested one within the
other and <a name="INDEX-588"></a><a name="INDEX-589"></a>are
delimited by a beginning tag and ending tag. The structure is really
not very complicated. If you have done any HTML coding you should
already understand the format. An element always starts with
&lt;<em class="emphasis">name of tag&gt;</em> tag and ends with
&lt;/<em class="emphasis">name of tag&gt;</em> tag. Everything in
between--even other elements--is part of the enclosing
element.
</p>

<p>The first major element is the
<tt class="literal">&lt;ejb-jar&gt;</tt><a name="INDEX-590"></a><a name="INDEX-591"></a> element, which is the root of the
document. All the other elements must lie within this element. Next
is the
<tt class="literal">&lt;enterprise-beans&gt;</tt><a name="INDEX-592"></a> element. Every bean declared in an XML
file must be included in this section. This file only describes the
Cabin bean, but we could define several beans in one deployment
descriptor.
</p>

<p>The <tt class="literal">&lt;entity&gt;</tt><a name="INDEX-593"></a> element shows that the beans defined
within this tag are entity beans. Similarly, a
<tt class="literal">&lt;session&gt;</tt> element describes session beans;
since the Cabin bean is an entity bean, we don't need a
<tt class="literal">&lt;session&gt;</tt><a name="INDEX-594"></a> element. In addition to a description,
the <tt class="literal">&lt;entity&gt;</tt> element provides the fully
qualified class names of the remote interface, home interface, bean
class, and primary key. The
<tt class="literal">&lt;cmp-field&gt;</tt><a name="INDEX-595"></a><a name="INDEX-596"></a><a name="INDEX-597"></a> elements list all the
container-managed fields in the entity bean class. These are the
fields that will be persisted in the database and are managed by the
container at runtime. The <tt class="literal">&lt;entity&gt;</tt> element
also includes a
<tt class="literal">&lt;reentrant&gt;</tt><a name="INDEX-598"></a> element that can be set as
<tt class="literal">True</tt> or <tt class="literal">False</tt> depending on
whether the bean allows reentrant
<a name="INDEX-599"></a>loopbacks or not.
</p>

<p>The next section of the XML file, after the
<tt class="literal">&lt;enterprise-bean&gt;</tt> element, is enclosed by
the
<tt class="literal">&lt;assembly-descriptor&gt;</tt><a name="INDEX-600"></a><a name="INDEX-601"></a><a name="INDEX-602"></a> element, which describes the security
roles and transactional attributes of the bean. It may seem odd to
separate this information from the
<tt class="literal">&lt;enterprise-beans&gt;</tt> element, since it clearly
applies to the Cabin bean, but in the scheme of things it's
perfectly natural. An XML deployment descriptor can describe several
beans, which might all rely on the same security roles and
transactional attributes. To make it easier to deploy several beans
together, all this common information is separated into the
<tt class="literal">&lt;assembly-descriptor&gt;</tt> element.
</p>

<p>There is another reason (perhaps a more important reason) for
separating information about the bean itself from the security roles
and transactional attributes. The EJB 1.1 specification clearly
defines the responsibilities of different participants in the
development and deployment of beans. We don't address these
development roles in this book because they are not critical to
learning the fundamentals of EJB. For now, it's enough to know
that the person who develops the bean and the person who assembles
the beans into an application have separate responsibilities and
therefore separate parts of the XML deployment descriptor. The bean
developer is responsible for everything within the
<tt class="literal">&lt;enterprise-beans&gt;</tt> element; the bean
assembler is responsible for everything within the
<tt class="literal">&lt;assembly-descriptor&gt;</tt>. In our example,
we're playing both roles, developing the beans and assembling
them. But in real life, you might buy a set of beans developed by a
third-party vendor, who would have no idea how you intend to use the
beans, what your security requirements are, etc.
</p>

<p>The <tt class="literal">&lt;assembly-descriptor&gt;</tt> contains the
<tt class="literal">&lt;security-role&gt;</tt> elements and their
corresponding <tt class="literal">&lt;method-permission&gt;</tt> elements,
which were described in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a> under <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>. In this example there is one security
role, <tt class="literal">everyone</tt>, which is mapped to all the methods
in the Cabin bean using the
<tt class="literal">&lt;method-permission&gt;</tt> element. (The
<tt class="literal">*</tt> in the <tt class="literal">&lt;method-name&gt;</tt>
element means "all methods").
</p>

<p>The <a name="INDEX-603"></a>container-transaction element declares
that all the methods of the Cabin bean have a
<tt class="literal">Required</tt> transactional attribute. Transactional
attributes are explained in more detail in <a href="ch08_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch08_01.htm">Chapter 8, "Transactions"</a>, but for now it means that all the methods
must be executed within a transaction. The deployment descriptor ends
with the enclosing tab of the <tt class="literal">&lt;ejb-jar&gt;</tt>
element.
</p>

<p>Copy the Cabin bean's deployment descriptor into the same
directory as the class files for the Cabin bean files
(<em class="emphasis">Cabin.class</em>,
<em class="emphasis">CabinHome.class</em>,
<em class="emphasis">CabinBean.class</em>, and
<em class="emphasis">CabinPK.class</em>) and save it as
<em class="emphasis">ejb-jar.xml</em>. You have now created all the files
you need to package your EJB 1.1 Cabin bean. <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a> shows all the files that should be in the
<em class="emphasis">cabin</em> directory.
</p>

<a name="ch04-42845"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0402.gif" webstripperlinkwas="figs/ejb2_0402.gif"></div>
<h4 class="objtitle">Figure 4-2. The Cabin bean files (EJB 1.1)</h4>


<a name="JBEANS-CH-4-SECT-2.6"></a>
<h3 class="sect2">4.2.6. EJB 1.0: The Deployment Descriptor</h3>

<p>
<a name="INDEX-604"></a><a name="INDEX-605"></a>
Here is a Java <a name="INDEX-606"></a><a name="INDEX-607"></a>application that instantiates, populates,
and serializes a <tt class="literal">DeploymentDescriptor</tt> for the EJB
1.0 Cabin bean:
</p>

<blockquote>
<pre class="programlisting">package com.titan.cabin;

import javax.ejb.deployment.EntityDescriptor;
import javax.ejb.deployment.ControlDescriptor;
import javax.naming.CompoundName;
import com.titan.cabin.CabinBean;
import java.util.Properties;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;

public class MakeDD {

    public static void main(String [] args) {
        try {
          if (args.length &lt;1){
            System.out.println("must specify target directory");
            return;
          }
        
        EntityDescriptor cabinDD = new EntityDescriptor();
        
        cabinDD.setEnterpriseBeanClassName("com.titan.cabin.CabinBean");
        cabinDD.setHomeInterfaceClassName("com.titan.cabin.CabinHome");
        cabinDD.setRemoteInterfaceClassName("com.titan.cabin.Cabin");
        cabinDD.setPrimaryKeyClassName("com.titan.cabin.CabinPK");

        Class beanClass = CabinBean.class;
        Field [] persistentFields = new Field[5];
        persistentFields[0] = beanClass.getDeclaredField("id");
        persistentFields[1] = beanClass.getDeclaredField("name");
        persistentFields[2] = beanClass.getDeclaredField("deckLevel");
        persistentFields[3] = beanClass.getDeclaredField("ship");
        persistentFields[4] = beanClass.getDeclaredField("bedCount");

        cabinDD.setContainerManagedFields(persistentFields);
        
        cabinDD.setReentrant(false);   
        
        CompoundName jndiName = new CompoundName("CabinHome", 
                                                 new Properties());
        cabinDD.setBeanHomeName(jndiName);
        
        ControlDescriptor cd = new ControlDescriptor();
        
        cd.setIsolationLevel(ControlDescriptor.TRANSACTION_READ_COMMITTED);
        cd.setTransactionAttribute(ControlDescriptor.TX_REQUIRED);
        
        cd.setRunAsMode(ControlDescriptor.CLIENT_IDENTITY);
        
        cd.setMethod(null);
        ControlDescriptor [] cdArray = {cd};
        cabinDD.setControlDescriptors(cdArray);
 
        String fileSeparator = 
            System.getProperties().getProperty("file.separator");
        if (! args[0].endsWith(fileSeparator))
            args[0] += fileSeparator;

        FileOutputStream fos = new FileOutputStream(args[0]+"CabinDD.ser");
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(cabinDD);
        oos.flush();
        oos.close();
        fos.close();

        } catch (Throwable t) { t.printStackTrace();}
    }
}</pre>
</blockquote>

<p>Copy this definition into your IDE, save it in the
<em class="emphasis">cabin</em> directory, and compile it. When you run
the application, <tt class="literal">MakeDD</tt>, use the path to the
<em class="emphasis">cabin</em> directory, where all the other Cabin bean
files are stored, as a command-line parameter:
</p>

<blockquote>
<pre class="programlisting">\dev % java com.titan.cabin.MakeDD com/titan/cabin

F:\..\dev&gt;java com.titan.cabin.MakeDD com\titan\cabin</pre>
</blockquote>

<p>If you run this application, you should end up with a file called
<em class="emphasis">CabinDD.ser</em> in the
<em class="filename">com/titan/cabin</em> directory. This is your
serialized <tt class="literal">DeploymentDescriptor</tt> for the Cabin
bean. Now that you know that the application works properly,
let's look at it in more detail. We begin with the creation of
the <tt class="literal">EntityDescriptor</tt>:
</p>

<blockquote>
<pre class="programlisting">EntityDescriptor cabinDD = new EntityDescriptor();</pre>
</blockquote>

<p>
<a name="INDEX-608"></a>An
entity descriptor is a <tt class="literal">DeploymentDescriptor</tt> that
has been extended to support entity beans. If we were creating a
<tt class="literal">DeploymentDescriptor</tt> for a session bean, we would
use the <tt class="literal">SessionDescriptor</tt> subclass. Notice that we
are not extending <tt class="literal">EntityDescriptor</tt> to create a
special cabin <tt class="literal">DeploymentDescriptor</tt>. We are using
the <tt class="literal">EntityDescriptor</tt> class provided by the EJB
package <tt class="literal">javax.ejb.deployment</tt>.
</p>

<p>The <tt class="literal">EntityDescriptor</tt> describes the classes and
interfaces used by the Cabin bean. The next section of code sets the
names of the bean class, the home interface, the remote interface,
and the primary key. All of these set methods are defined in the
<tt class="literal">EntityDescriptor</tt>'s superclass,
<tt class="literal">DeploymentDescriptor</tt>, except for
<tt class="literal">setPrimaryKeyClassName()</tt>; this method is defined
in the <tt class="literal">EntityDescriptor</tt> class.
</p>

<blockquote>
<pre class="programlisting">cabinDD.setEnterpriseBeanClassName("com.titan.cabin.CabinBean");
cabinDD.setHomeInterfaceClassName("com.titan.cabin.CabinHome");
cabinDD.setRemoteInterfaceClassName("com.titan.cabin.Cabin");
cabinDD.setPrimaryKeyClassName("com.titan.cabin.CabinPK");</pre>
</blockquote>

<p>When the bean is deployed, the deployment tools will read these
properties so that the tools can locate the bean interfaces and
primary key class and generate all the supporting code, such as the
EJB object and EJB home.
</p>

<p>The next section is a little more complicated. Our Cabin bean is
going to be a
<a name="INDEX-609"></a><a name="INDEX-610"></a>container-managed entity bean, which
means that the container will automatically handle persistence. To
handle persistence, the container must know which of the
<tt class="literal">CabinBean</tt>'s fields it is responsible for.
Earlier, it was decided that the <tt class="literal">id</tt>,
<tt class="literal">name</tt>, <tt class="literal">deckLevel</tt>,
<tt class="literal">ship</tt>, and <tt class="literal">bedCount</tt> fields were
all persistent fields in the <tt class="literal">CabinBean</tt>. The
following code tells the <tt class="literal">EntityDescriptor</tt> that
these fields are container managed by using the Reflection API to
pass an array of <tt class="literal">Field</tt> objects to
<tt class="literal">setContainerManagedFields()</tt>:
</p>

<blockquote>
<pre class="programlisting">Class beanClass = CabinBean.class;
Field [] persistentFields = new Field[5];
persistentFields[0] = beanClass.getDeclaredField("id");
persistentFields[1] = beanClass.getDeclaredField("name");
persistentFields[2] = beanClass.getDeclaredField("deckLevel");
persistentFields[3] = beanClass.getDeclaredField("ship");
persistentFields[4] = beanClass.getDeclaredField("bedCount");

cabinDD.setContainerManagedFields(persistentFields);</pre>
</blockquote>

<p>Although the code tells the <tt class="literal">EntityDescriptor</tt> which
fields are container- managed, it doesn't describe how these
fields will map to the database. The actual mapping of the fields to
the database depends on the type of database and on the EJB server
used. The mapping is vendor- and database-dependent, so we
won't worry about it just now. When the bean is actually
deployed in some EJB server, the deployer will map the
container-managed fields to whatever database is used.
</p>

<p>
<a name="INDEX-611"></a><a name="INDEX-612"></a>The next line tells the
<tt class="literal">EntityDescriptor</tt> that the Cabin bean is
nonreentrant. We discussed the problems associated with reentrant
beans in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>. Entity beans are not reentrant
by default, but it never hurts to make this explicit.
</p>

<blockquote>
<pre class="programlisting">cabinDD.setReentrant(false);   </pre>
</blockquote>

<p>The following code uses the <a name="INDEX-613"></a>JNDI API to set the lookup name
of the bean in the EJB server's directory structure. In <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>, we saw that Enterprise JavaBeans requires
servers to support the use of JNDI for organizing beans in a
<a name="INDEX-614"></a>directory structure. Later, when we create
a client application, the name we assign to the Cabin bean will be
used to locate and obtain a remote reference to the bean's EJB
home.
</p>

<blockquote>
<pre class="programlisting">CompoundName jndiName = new CompoundName("CabinHome", new Properties());
cabinDD.setBeanHomeName(jndiName);</pre>
</blockquote>

<p>We have created a directory entry that places the bean under the name
<em class="emphasis">CabinHome</em>. Although it makes sense to assign
names that reflect the organization of your beans, you can give the
EJB home any lookup name you like. We could have used other names
assigned to the Cabin bean, like <em class="emphasis">HomeCabin</em> or
just <em class="emphasis">cabin</em>.
</p>

<p>
<a name="INDEX-615"></a><a name="INDEX-616"></a><a name="INDEX-617"></a>Next, we create a
<tt class="literal">ControlDescriptor</tt> to set the bean's
transactional and security attributes:
</p>

<blockquote>
<pre class="programlisting">ControlDescriptor cd = new ControlDescriptor();
        
cd.setIsolationLevel(ControlDescriptor.TRANSACTION_READ_COMMITTED);
cd.setTransactionAttribute(ControlDescriptor.TX_REQUIRED);
        
cd.setRunAsMode(ControlDescriptor.CLIENT_IDENTITY);
        
cd.setMethod(null);
ControlDescriptor [] cdArray = {cd};
cabinDD.setControlDescriptors(cdArray);</pre>
</blockquote>

<p>After creating the <tt class="literal">ControlDescriptor</tt>, we set its
transactional attributes. This includes setting the transactional
context and isolation level. Transactions are fairly complicated and
are discussed in detail in <a href="ch08_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch08_01.htm">Chapter 8, "Transactions"</a>. Essentially,
we are saying that the bean must be executed in a transaction and
that the bean is not accessible by any other client while executing a
transaction. Next, we set the runAs mode of the bean. The runAs mode
determines how the bean's methods will execute at runtime. In
this case, the methods will be executed under the identity that
invoked the bean. This means that any other beans or resources
accessed by the method will be validated based on the client's
identity. Then we set the methods that the
<tt class="literal">ControlDescriptor</tt> represents and add the
<tt class="literal">ControlDescriptor</tt> to the
<tt class="literal">EntityDescriptor</tt>. Here we set the method to
<tt class="literal">null</tt>, which means that the
<tt class="literal">ControlDescriptor</tt> is the default for all methods
of the Cabin bean. Any method that doesn't have its own
<tt class="literal">ControlDescriptor</tt> uses the default
<tt class="literal">ControlDescriptor</tt> for the bean. In this case, we
only specify a default descriptor. Once all the properties on the
<tt class="literal">ControlDescriptor</tt> have been set, it is added to
the <tt class="literal">EntityDescriptor</tt>.
</p>

<p>
<a name="INDEX-618"></a><a name="INDEX-619"></a>Finally, we serialize the
<tt class="literal">EntityDescriptor</tt> with all its Cabin bean
properties to a file called <em class="emphasis">CabinDD.ser</em>. This
serialized <tt class="literal">EntityDescriptor</tt> should be saved to the
same directory that holds all the other files for the Cabin bean, the
<em class="filename">dev/com/titan/cabin</em> directory.
</p>

<blockquote>
<pre class="programlisting">String fileSeparator = System.getProperties().getProperty("file.separator");
if (! args[0].endsWith(fileSeparator))
    args[0] += fileSeparator;

FileOutputStream fos = new FileOutputStream(args[0]+"CabinDD.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);
oos.writeObject(cabinDD);
oos.flush();
oos.close();
fos.close();</pre>
</blockquote>

<p>The first part of the serialization section simply determines whether
the path ends with a file separator for that operating system. If it
doesn't, the code adds one. The second part serializes the
deployment descriptor to a file called
<em class="emphasis">CabinDD.ser</em> in the directory passed in at the
command line.
</p>

<p>You have now created everything you need to package your EJB 1.0
Cabin bean for deployment. <a href="#ch04-89167">Figure 4-3</a> shows all the
files that should be in the <em class="emphasis">cabin</em> directory.
</p>

<a name="ch04-89167"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0403.gif" webstripperlinkwas="figs/ejb2_0403.gif"></div>
<h4 class="objtitle">Figure 4-3. The Cabin bean files (EJB 1.0)</h4>


<a name="JBEANS-CH-4-SECT-2.7"></a>
<h3 class="sect2">4.2.7. cabin.jar: The JAR File</h3>

<p>
<a name="INDEX-620"></a><a name="INDEX-621"></a><a name="INDEX-622"></a><a name="INDEX-623"></a>The JAR file is a platform-independent
file format for compressing, packaging, and delivering several files
together. Based on ZIP file format and the ZLIB compression
standards, the JAR ( Java archive) packages and tool were originally
developed to make downloads of Java applets more efficient. As a
packaging mechanism, however, the JAR file format is a very
convenient way to "shrink-wrap" components and other
software for delivery to third parties. The original JavaBeans
component architecture depends on JAR files for packaging, as does
Enterprise JavaBeans. The goal in using the JAR file format in EJB is
to package all the classes and interfaces associated with a bean,
including the deployment descriptor into one file. The process of
creating an EJB JAR file is slightly different between EJB 1.1 and
EJB 1.0.
</p>

<a name="JBEANS-CH-4-SECT-2.7.1"></a>
<h3 class="sect3">4.2.7.1. EJB 1.1: Packaging the Cabin bean</h3>

<p>Now <a name="INDEX-624"></a>that you have put all the necessary files
in one directory, creating the JAR file is easy. Position yourself in
the <em class="filename">dev</em> directory that is just above
the<em class="filename"> com/titan/cabin</em> directory tree, and execute
the command:
</p>

<blockquote>
<pre class="programlisting">\dev % jar cf cabin.jar com/titan/cabin/*.class META-INF/ejb-jar.xml

F:\..\dev&gt;jar cf cabin.jar com\titan\cabin\*.class META-INF\ejb-jar.xml</pre>
</blockquote>

<p>You might have to create the <a name="INDEX-625"></a>META-INF directory first and copy
<em class="filename">ejb-jar.xml</em><a name="INDEX-626"></a>into that directory. The
<tt class="literal">c</tt> option tells the <em class="emphasis">jar</em>
utility to create a new JAR file that contains the files indicated in
subsequent parameters. It also tells the <em class="emphasis">jar</em>
utility to stream the resulting JAR file to standard output. The
<tt class="literal">f</tt> option tells <em class="emphasis">jar</em> to
redirect the standard output to a new file named in the second
parameter (<em class="filename">cabin.jar)</em> . It's important to
get the order of the option letters and the command-line parameters
to match. You can learn more about the <em class="emphasis">jar</em>
utility and the <tt class="literal">java.util.zip</tt> package in
<em class="emphasis">Java&#153; in a Nutshell</em> by David Flanagan, or
<em class="emphasis">Learning Java&#153;</em> (formerly
<em class="citetitle">Exploring Java</em>), by Pat Niemeyer and Jonathan
Knudsen (both published by O'Reilly).
</p>

<p>The <em class="emphasis">jar</em><a name="INDEX-627"></a>utility creates the file
<em class="emphasis">cabin.jar</em> in the <em class="filename">dev</em>
directory. <a name="INDEX-628"></a>If you're interested in looking at
the contents of the JAR file, you can use any standard ZIP
application (WinZip, PKZIP, etc.), or you can use the command
<em class="emphasis">jar tvf cabin.jar</em>.
</p>



<a name="JBEANS-CH-4-SECT-2.7.2"></a>
<h3 class="sect3">4.2.7.2. EJB 1.0: Packaging the Cabin bean</h3>

<p>In addition to the bean's classes and deployment descriptor,
the <a name="INDEX-629"></a>JAR file contains
a<a name="INDEX-630"></a><em class="emphasis">manifest</em> generated by the
<em class="emphasis">jar</em> utility. The manifest essentially serves as
a README file, describing the contents in a way that's useful
for any tools that work with the archive. We need to add an entry
into the JAR file to specify which file contains our serialized
deployment descriptor. To do this, we add two simple lines to the
manifest by creating an ASCII text file named
<em class="emphasis">manifest</em> :
</p>

<blockquote>
<pre class="programlisting">Name: com/titan/cabin/CabinDD.ser
Enterprise-Bean: True</pre>
</blockquote>

<p>That's it! When we run the <em class="emphasis">jar</em> utility, we
will tell it to use our manifest information when it build the JAR.
The manifest for this bean is now complete. A manifest is always
organized as a set of name-value pairs that describe the files in the
JAR file. In this case, we need to point to the location of the
serialized deployment descriptor and define the JAR as an EJB JAR.
The first line points to the serialized
<tt class="literal">EntityDescriptor</tt>,
<em class="emphasis">CabinDD.ser</em>, for the Cabin bean. Notice that
forward slashes ("/") must be used as path separators;
this could be confusing if you are used to the Windows environment.
The next line of the manifest identifies the JAR as an EJB JAR. Most
EJB server deployment tools check for this name-value pair before
trying to read the JAR file's contents. Save the manifest in
the <em class="emphasis">cabin</em> directory where all the other Cabin
bean files are located. It should be saved as the file name
<em class="emphasis">manifest</em> with no extension.
</p>

<p>Now that you have put all the necessary files in one directory,
creating the JAR file is easy. Position yourself in the
<em class="filename">dev</em> directory that is just above the
<em class="filename">com/titan/cabin</em> directory tree, and execute the
following command:
</p>

<blockquote>
<pre class="programlisting">\dev % jar cmf com/titan/cabin/manifest cabin.jar com/titan/cabin/*.class \
com/titan/cabin/*.ser

F:\..\dev&gt;jar cmf com\titan\cabin\manifest cabin.jar com\titan\cabin\*.class 
com\titan\cabin\*.ser</pre>
</blockquote>

<p>If you want, you may remove the <em class="emphasis">MakeDD.class</em>
file from the JAR archive, since it's not a standard EJB class
and the EJB deployment tools do not use it. Leaving it there will not
impact deployment of the <a name="INDEX-631"></a><a name="INDEX-632"></a> Cabin bean.
</p>



<a name="JBEANS-CH-4-SECT-2.8"></a>
<h3 class="sect2">4.2.8. Creating a CABIN Table in the Database</h3>

<p>
<a name="INDEX-633"></a><a name="INDEX-634"></a>One
of the primary jobs of a deployment tool is mapping entity beans to
databases. In the case of the Cabin bean, we must map its
<tt class="literal">id</tt>, <tt class="literal">name</tt>,
<tt class="literal">deckLevel</tt>, <tt class="literal">ship</tt>, and
<tt class="literal">bedCount</tt> (the bean's container-managed
fields) to some data source. Before proceeding with deployment, you
need to set up a database and create a <tt class="literal">CABIN</tt>
table. You can use the following standard SQL statement to create a
<tt class="literal">CABIN</tt> table that will be consistent with the
examples provided in this chapter:
</p>

<blockquote>
<pre class="programlisting">create table CABIN 
(
  ID int primary key, 
  SHIP_ID int, 
  BED_COUNT int, 
  NAME char(30), 
  DECK_LEVEL int
)</pre>
</blockquote>

<p>This statement creates a <tt class="literal">CABIN</tt> table that has five
columns corresponding to the container-managed fields in the
<tt class="literal">CabinBean</tt> class. Once the table is created and
connectivity to the database is confirmed, you can proceed with the
deployment process.
</p>


<a name="JBEANS-CH-4-SECT-2.9"></a>
<h3 class="sect2">4.2.9. Deploying the Cabin Bean</h3>

<p>
<a name="INDEX-635"></a><a name="INDEX-636"></a>Deployment is the process of reading
the bean's JAR file, changing or adding properties to the
deployment descriptor, mapping the bean to the database, defining
access control in the security domain, and generating vendor-specific
classes needed to support the bean in the EJB environment. Every EJB
server product has its own deployment tools, which may provide a
graphical user interface, a set of command-line programs, or both.
Graphical deployment
"<a name="INDEX-637"></a><a name="INDEX-638"></a>wizards" are the easiest
deployment tools to work with.
</p>

<a name="JBEANS-CH-4-SECT-2.9.1"></a>
<h3 class="sect3">4.2.9.1. EJB 1.1 deployment tools</h3>

<p>A deployment tool reads the JAR file and looks for the
<em class="emphasis">ejb-jar.xml</em> file. In a graphical deployment
wizard, the deployment descriptor elements will be presented in a set
of property sheets similar to those used to customize visual
components in environments like Visual Basic, PowerBuilder, JBuilder,
and Symantec Caf&eacute;. <a href="#JBEANS-CH-4-FIG-4">Figure 4-4</a> shows the
deployment wizard used in the <a name="INDEX-639"></a><a name="INDEX-640"></a>J2EE Reference Implementation.
</p>

<a name="JBEANS-CH-4-FIG-4"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0404.gif" webstripperlinkwas="figs/ejb2_0404.gif"></div>
<h4 class="objtitle">Figure 4-4.  J2EE Reference Implementation's deployment wizard</h4>

<p>The J2EE Reference Implementation's deployment wizard has
fields and panels that match the XML deployment descriptor. You can
map security roles to users groups, set the JNDI look up name, map
the container-managed fields to the database, etc.
</p>



<a name="JBEANS-CH-4-SECT-2.9.2"></a>
<h3 class="sect3">4.2.9.2. EJB 1.0 deployment tools</h3>

<p>A <a name="INDEX-641"></a><a name="INDEX-642"></a>deployment tool reads the JAR file
and uses the manifest to locate the bean's serialized
deployment descriptor. Once the deployment descriptor file has been
located, it is deserialized into an object and its properties are
read by invoking its get methods. In a graphical deployment wizard,
these properties will be presented to the deployer in a set of
property sheets, similar to those used to customize visual components
in environments like Visual Basic, PowerBuilder, JBuilder, and
Symantec Cafe. <a href="#JBEANS-CH-4-FIG-5">Figure 4-5</a> shows the deployment
wizard used in BEA's WebLogic EJB server.
</p>

<a name="JBEANS-CH-4-FIG-5"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0405.gif" webstripperlinkwas="figs/ejb2_0405.gif"></div>
<h4 class="objtitle">Figure 4-5. WebLogic deployment wizard</h4>

<p>The <a name="INDEX-643"></a><a name="INDEX-644"></a>WebLogic deployment wizard
has fields and panels that match properties and deployment classes
specified in the <a name="INDEX-645"></a><a name="INDEX-646"></a><tt class="literal">javax.ejb.deployment</tt> package. The
"CabinBean" tab, for example, contains text fields for
each of the interfaces and classes that we described in the Cabin
bean's <tt class="literal">EntityDescriptor</tt>, the
<em class="emphasis">CabinDD.ser</em>. There is also an "Access
control" tab that corresponds to the
<tt class="literal">AccessControlEntry</tt> class, and a "Control
descriptors" tab that corresponds to the
<tt class="literal">ControlDescriptor</tt> class. In addition, there is a
"Container-managed fields" tab that shows the
container-managed fields we defined when creating the
<em class="emphasis">CabinDD.ser</em>. Graphical deployment wizards
provided by other EJB products will look different but provide the
same kinds of features.
</p>

<p>At this point, you can choose to change deployment information, such
as the transactional isolation level, to change the Cabin
bean's JNDI name, or to deselect one of the container-managed
fields. You can also add properties to the deployment descriptor, for
example, by setting the <tt class="literal">AccessControlEntry</tt>s for
the methods and adding environment properties. The
<em class="emphasis">CabinDD.ser</em> that we created should have
specified the minimum information that most EJB servers need to
deploy the bean without changes. It is likely that all you will need
to do is specify the persistence mapping from the container-managed
fields to the <tt class="literal">CABIN</tt> table in the relational
database.
</p>

<p>Different EJB deployment tools will provide varying degrees of
support for <a name="INDEX-647"></a><a name="INDEX-648"></a><a name="INDEX-649"></a>
mapping container-managed fields to a data source. Some provide very
robust and sophisticated graphical user interfaces, while others are
simpler and less flexible. Fortunately, mapping the
<tt class="literal">CabinBean</tt>'s container-managed fields to the
<tt class="literal">CABIN</tt> table is a fairly straightforward process.
Read the documentation for the deployment tool provided by your EJB
vendor to determine how to do this mapping. Once you have finished
the mapping, you can complete the deployment of the bean and prepare
to access it from the <a name="INDEX-650"></a><a name="INDEX-651"></a> EJB server.
</p>



<a name="JBEANS-CH-4-SECT-2.10"></a>
<h3 class="sect2">4.2.10. Creating a Client Application</h3>

<p>
<a name="INDEX-652"></a><a name="INDEX-653"></a>Now that the Cabin bean has been
deployed in the EJB server, we want to access it from a remote
client. When we say remote, we are not necessarily talking about a
client application that is located on a different computer, just one
that is not part of the EJB server. In this section, we will create a
remote client that will connect to the EJB server, locate the EJB
home for the Cabin bean, and create and interact with several Cabin
beans. The following code shows a Java application that is designed
to create a new Cabin bean, set its <tt class="literal">name</tt>,
<tt class="literal">deckLevel</tt>, <tt class="literal">ship</tt>, and
<tt class="literal">bedCount</tt> properties, and then locate it again
using its primary key:
</p>

<blockquote>
<pre class="programlisting">package com.titan.cabin;

import com.titan.cabin.CabinHome;
import com.titan.cabin.Cabin;
import com.titan.cabin.CabinPK;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NamingException;
import java.rmi.RemoteException;
import java.util.Properties;

public class Client_1 {
    public static void main(String [] args) {
        try {
            Context jndiContext = getInitialContext();
            Object ref = 
                jndiContext.lookup("CabinHome");
                CabinHome home = (CabinHome)
            // EJB 1.0:Use Java cast instead of narrow( )
                PortableRemoteObject.narrow(ref,CabinHome.class);
            Cabin cabin_1 = home.create(1);
            cabin_1.setName("Master Suite");
            cabin_1.setDeckLevel(1);
            cabin_1.setShip(1);
            cabin_1.setBedCount(3);
                
            CabinPK pk = new CabinPK();
            pk.id = 1;
            
            Cabin cabin_2 = home.findByPrimaryKey(pk);
            System.out.println(cabin_2.getName());
            System.out.println(cabin_2.getDeckLevel());
            System.out.println(cabin_2.getShip());
            System.out.println(cabin_2.getBedCount());

        } catch (java.rmi.RemoteException re){re.printStackTrace();}
          catch (javax.naming.NamingException ne){ne.printStackTrace();}
          catch (javax.ejb.CreateException ce){ce.printStackTrace();}
          catch (javax.ejb.FinderException fe){fe.printStackTrace();}
    }

    public static Context getInitialContext() 
        throws javax.naming.NamingException {

        Properties p = new Properties();
        // ... Specify the JNDI properties specific to the vendor.
        return new javax.naming.InitialContext(p);
    }
}</pre>
</blockquote>

<p>
<a name="INDEX-654"></a><a name="INDEX-655"></a><a name="INDEX-656"></a>To access an enterprise bean, a
client starts by using the JNDI package to obtain a directory
connection to a bean's container. JNDI is an
implementation-independent API for directory and naming systems.
Every EJB vendor must provide directory services that are
JNDI-compliant. This means that they must provide a JNDI service
provider, which is a piece of software analogous to a driver in JDBC.
Different service providers connect to different directory
services--not unlike JDBC, where different drivers connect to
different relational databases. The method
<a name="INDEX-657"></a><tt class="literal">getInitialContext()</tt> contains logic that uses JNDI
to obtain a network connection to the EJB server.
</p>

<p>The code used to obtain the JNDI <tt class="literal">Context</tt> will be
different depending on which EJB vendor you are using. You will need
to research your EJB vendor's requirements for obtaining a JNDI
<tt class="literal">Context</tt> appropriate to that product.
</p>

<p>The code used to obtain a JNDI <tt class="literal">Context</tt> in
Gemstone/J, for example, might look something like the following:
</p>

<blockquote>
<pre class="programlisting">public static Context getInitialContext() throws javax.naming.NamingException {
   Properties p = new Properties();
   p.put(com.gemstone.naming.Defaults.NAME_SERVICE_HOST,"localhost");
   String port = System.getProperty("com.gemstone.naming.NameServicePort",
                                    "10200");
   p.put(com.gemstone.naming.Defaults.NAME_SERVICE_PORT, port);
   p.put(Context.INITIAL_CONTEXT_FACTORY,"com.gemstone.naming.GsCtxFactory");
   return new InitialContext(p);
}</pre>
</blockquote>

<p>The same method developed for BEA's WebLogic Server would be
different:
</p>

<blockquote>
<pre class="programlisting">public static Context getInitialContext() 
   throws javax.naming.NamingException {
   Properties p = new Properties();
   p.put(Context.INITIAL_CONTEXT_FACTORY,
         "weblogic.jndi.TengahInitialContextFactory");
   p.put(Context.PROVIDER_URL, "t3://localhost:7001");
   return new javax.naming.InitialContext(p);
}</pre>
</blockquote>

<p>Once a JNDI connection is established and a context is obtained from
the <tt class="literal">getIntialContext()</tt> method, the context can be
used to look up the EJB home of the Cabin bean:
</p>

<a name="JBEANS-CH-4-SECT-2.10.1"></a>
<h3 class="sect3">4.2.10.1. EJB 1.1: Obtaining a remote reference to the home interface</h3>

<p>The previous example uses the
<tt class="literal">PortableRemoteObject.narrow()</tt> method as prescribed
in EJB 1.1:
</p>

<blockquote>
<pre class="programlisting">Object ref = jndiContext.lookup("CabinHome");
CabinHome home = (CabinHome)
// EJB 1.0: Use Java cast instead of narrow()
    PortableRemoteObject.narrow(ref,CabinHome.class);</pre>
</blockquote>

<p>The <tt class="literal">PortableRemoteObject.narrow()</tt> method is new to
EJB 1.1. It is needed to support the requirements of RMI over IIOP.
Because CORBA supports many different languages, casting is not
native to CORBA (some languages don't have casting). Therefore,
to get a remote reference to <tt class="literal">CabinHome</tt>, we must
explicitly narrow the object returned from
<tt class="literal">lookup()</tt>. This has the same effect as casting and
is explained in more detail in <a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm">Chapter 5, "The Client View"</a>.
</p>

<p>The name used to find the Cabin bean's EJB home is set by the
deployer using a deployment wizard like the one pictured earlier. The
JNDI name is entirely up to the person deploying the bean; it can be
the same as the bean name set in the XML deployment descriptor or
something completely different.
</p>



<a name="JBEANS-CH-4-SECT-2.10.2"></a>
<h3 class="sect3">4.2.10.2. EJB 1.0: Obtaining a remote reference to the home interface</h3>

<p>In EJB 1.0, you do not need to use the
<tt class="literal">PortableRemoteObject.narrow()</tt> method to cast
objects to the correct type. EJB 1.0 allows the use of Java native
casting to narrow the type returned by the JNDI API to the home
interface type. When you see the
<tt class="literal">PortableRemoteObject</tt> being used, replace it with
Java native casting as follows:
</p>

<blockquote>
<pre class="programlisting">CabinHome home = (CabinHome)jndiContext.lookup("CabinHome");</pre>
</blockquote>

<p>To locate the EJB home, we specify the name that we set using the
<tt class="literal">DeploymentDescriptor.setBeanHomeName(String</tt><tt class="literal">name)</tt> method in the <tt class="literal">MakeDD</tt>
application earlier. If this lookup succeeds, the
<tt class="literal">home</tt> variable will contain a remote reference to
the Cabin bean's EJB home.
</p>



<a name="JBEANS-CH-4-SECT-2.10.3"></a>
<h3 class="sect3">4.2.10.3. Creating a new Cabin bean</h3>

<p>Once we have a remote reference to the EJB home, we can use it to
create a new <tt class="literal">Cabin</tt> entity:
</p>

<blockquote>
<pre class="programlisting">Cabin cabin_1 = home.create(1);</pre>
</blockquote>

<p>We create a new <tt class="literal">Cabin</tt> entity using the
<tt class="literal">create(int</tt><tt class="literal">id)</tt> method defined
in the home interface of the Cabin bean. When this method is invoked,
the EJB home works with the EJB server to create a Cabin bean, adding
its data to the database. The EJB server then creates an EJB object
to wrap the Cabin bean instance and returns a remote reference to the
EJB object to the client. The <tt class="literal">cabin_1</tt> variable
then contains a remote reference to the Cabin bean we just created.
</p>

<a name="JBEANS-CH-4-ADMON-1"></a>
<blockquote class="note">
<h4 class="objtitle">NOTE</h4>
<p>
In EJB 1.1, we don't need to use the <tt class="literal">PortableRemoteObject.narrow()</tt> method to get the EJB object from the home reference, because it was declared as returning the <tt class="literal">Cabin</tt> type; no casting was required. We don't need to explicitly narrow remote references returned by <tt class="literal">findByPrimaryKey()</tt> for the same reason.</p>
</blockquote>
<p>With the remote reference to the EJB object, we can update the
<tt class="literal">name</tt>, <tt class="literal">deckLevel</tt>,
<tt class="literal">ship</tt>, and <tt class="literal">bedCount</tt> of the
<tt class="literal">Cabin</tt> entity:
</p>

<blockquote>
<pre class="programlisting">Cabin cabin_1 = home.create(1);
cabin_1.setName("Master Suite");
cabin_1.setDeckLevel(1);
cabin_1.setShip(1);
cabin_1.setBedCount(3);</pre>
</blockquote>

<p>
<a href="#JBEANS-CH-4-FIG-6">Figure 4-6</a> shows how the relational database table
that we created should look after executing this code. It should
contain one record.
</p>

<a name="JBEANS-CH-4-FIG-6"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0406.gif" webstripperlinkwas="figs/ejb2_0406.gif"></div>
<h4 class="objtitle">Figure 4-6. CABIN table with one cabin record</h4>

<p>After an entity bean has been created, a client can locate it using
the <tt class="literal">findByPrimaryKey()</tt> method in the home
interface. First, we create a primary key of the correct type, in
this case <tt class="literal">CabinPK</tt>, and set its field
<tt class="literal">id</tt> to equal the <tt class="literal">id</tt> of the cabin
we want. (So far, we only have one cabin available to us.) When we
invoke this method on the home interface, we get back a remote
reference to the EJB object. We can now interrogate the remote
reference returned by <tt class="literal">findByPrimaryKey()</tt> to get
the <tt class="literal">Cabin</tt> entity's <tt class="literal">name</tt>,
<tt class="literal">deckLevel</tt>, <tt class="literal">ship</tt>, and
<tt class="literal">bedCount</tt>:
</p>

<blockquote>
<pre class="programlisting">CabinPK pk = new CabinPK();
pk.id = 1;
            
Cabin cabin_2 = home.findByPrimaryKey(pk);
System.out.println(cabin_2.getName());
System.out.println(cabin_2.getDeckLevel());
System.out.println(cabin_2.getShip());
System.out.println(cabin_2.getBedCount());</pre>
</blockquote>

<p>Copy and save the <tt class="literal">Client_1</tt> application to any
directory, and compile it. If you haven't started your EJB
server and deployed the Cabin bean, do so now. When you're
finished, you're ready to run the <tt class="literal">Client_1</tt>
in your IDE's debugger so that you can watch each step of the
program. Your output should look something like the following:
</p>

<blockquote>
<pre class="programlisting">Master Suite
1
1
3</pre>
</blockquote>

<p>You just created and used your first entity bean! Of course, the
client application doesn't do much. Before going on to create
session beans, create another client that adds some test data to the
database. Here we'll create <tt class="literal">Client_2</tt> as a
modification of <tt class="literal">Client_1</tt> that populates the
database with a large number of cabins for three different ships:
</p>

<blockquote>
<pre class="programlisting">package com.titan.cabin;

import com.titan.cabin.CabinHome;
import com.titan.cabin.Cabin;
import com.titan.cabin.CabinPK;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NamingException;
import javax.ejb.CreateException;
import java.rmi.RemoteException;
import java.util.Properties;

public class Client_2 {

    public static void main(String [] args) {
        try {
            Context jndiContext = getInitialContext();
            
            Object ref = 
                jndiContext.lookup("CabinHome");
            CabinHome home = (CabinHome)
            // EJB 1.0: Use Java native cast
                PortableRemoteObject.narrow(ref,CabinHome.class);
            // Add 9 cabins to deck 1 of ship 1.
            makeCabins(home, 2, 10, 1, 1);
            // Add 10 cabins to deck 2 of ship 1.
            makeCabins(home, 11, 20, 2, 1);
            // Add 10 cabins to deck 3 of ship 1.
            makeCabins(home, 21, 30, 3, 1);
            
            // Add 10 cabins to deck 1 of ship 2.
            makeCabins(home, 31, 40, 1, 2);
            // Add 10 cabins to deck 2 of ship 2.
            makeCabins(home, 41, 50, 2, 2);
            // Add 10 cabins to deck 3 of ship 2.
            makeCabins(home, 51, 60, 3, 2);
            
            // Add 10 cabins to deck 1 of ship 3.
            makeCabins(home, 61, 70, 1, 3);
            // Add 10 cabins to deck 2 of ship 3.
            makeCabins(home, 71, 80, 2, 3);
            // Add 10 cabins to deck 3 of ship 3.
            makeCabins(home, 81, 90, 3, 3);
            // Add 10 cabins to deck 4 of ship 3.
            makeCabins(home, 91, 100, 4, 3);

            for (int i = 1; i &lt;= 100; i++){
                CabinPK pk = new CabinPK();
                pk.id = i;
                Cabin cabin = home.findByPrimaryKey(pk);
                System.out.println("PK = "+i+", Ship = "+cabin.getShip()
                  + ", Deck = "+cabin.getDeckLevel()
                  + ", BedCount = "+cabin.getBedCount()
                  + ", Name = "+cabin.getName());
            }

        } catch (java.rmi.RemoteException re) {re.printStackTrace();}
          catch (javax.naming.NamingException ne) {ne.printStackTrace();}
          catch (javax.ejb.CreateException ce) {ce.printStackTrace();}
          catch (javax.ejb.FinderException fe) {fe.printStackTrace();}
  }

  public static javax.naming.Context getInitialContext() 
       throws javax.naming.NamingException{
    Properties p = new Properties();
    // ... Specify the JNDI properties specific to the vendor.
    return new javax.naming.InitialContext(p);
  }

  public static void makeCabins(CabinHome home, int fromId, int toId, 
                                int deckLevel, int shipNumber)
    throws RemoteException, CreateException {

    int bc = 3;
    for (int i = fromId; i &lt;= toId; i++) {        
        Cabin cabin = home.create(i);
        int suiteNumber = deckLevel*100+(i-fromId);
        cabin.setName("Suite "+suiteNumber);
        cabin.setDeckLevel(deckLevel);
        bc = (bc==3)?2:3;
        cabin.setBedCount(bc);
        cabin.setShip(shipNumber);
    }
  }
}</pre>
</blockquote>

<p>Copy this code into your IDE, save, and recompile the
<tt class="literal">Client_2</tt> application. When it compiles
successfully, run it. There's lots of output--here are the
first few lines:
</p>

<blockquote>
<pre class="programlisting">PK = 1, Ship = 1, Deck = 1, BedCount = 3, Name = Master Suite
PK = 2, Ship = 1, Deck = 1, BedCount = 2, Name = Suite 100
PK = 3, Ship = 1, Deck = 1, BedCount = 3, Name = Suite 101
PK = 4, Ship = 1, Deck = 1, BedCount = 2, Name = Suite 102
PK = 5, Ship = 1, Deck = 1, BedCount = 3, Name = Suite 103
PK = 6, Ship = 1, Deck = 1, BedCount = 2, Name = Suite 104
PK = 7, Ship = 1, Deck = 1, BedCount = 3, Name = Suite 105
...</pre>
</blockquote>

<p>You now have 100 cabin records in your <tt class="literal">CABIN</tt>
table, representing 100 cabin entities in your EJB system. This
provides a good set of test data for the session bean we will create
in the next section, and for <a name="INDEX-658"></a> subsequent <a name="INDEX-659"></a><a name="INDEX-660"></a> examples throughout
the book.
</p>





<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch04_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">4.1. Choosing and Setting Up an EJB Server</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">4.3. Developing a Session Bean</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
