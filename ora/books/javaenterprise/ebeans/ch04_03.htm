<html>
<head>
<title>Developing a Session Bean (Enterprise JavaBeans)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Richard Monson-Haefel">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-869-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Developing a Session Bean">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm" alt="Enterprise JavaBeans"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch04_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4: Developing Your First Enterprise Beans</a></td><td align="right" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">4.3. Developing a Session Bean</h2>

<p>
<a name="INDEX-661"></a>Session beans act as agents to the
client, controlling workflow (the business process) and filling the
gaps between the representation of data by entity beans and the
business logic that interacts with that data. Session beans are often
used to manage interactions between entity beans and can perform
complex manipulations of beans to accomplish some task. Since we have
only defined one entity bean so far, we will focus on a complex
manipulation of the Cabin bean rather than the interactions of the
Cabin bean with other entity beans. In <a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">Chapter 7, "Session Beans"</a>,
after we have had the opportunity to develop other entity beans,
interactions of entity beans within session beans will be explored in
greater detail.
</p>

<p>
<a name="INDEX-662"></a><a name="INDEX-663"></a>Client applications and other beans use
the Cabin bean in a variety of ways. Some of these uses were
predictable when the Cabin bean was defined, but most were not. After
all, an entity bean represents data--in this case, data
describing a cabin. The uses to which we put that data will change
over time--hence the importance of separating the data itself
from the workflow. In Titan's business system, for example, we
will need to list and report on cabins in ways that were not
predictable when the Cabin bean was defined. Rather than change the
Cabin bean every time we need to look at it differently, we will
obtain the information we need using a session bean. Changing the
definition of an entity bean should only be done within the context
of a larger process--for example, a major redesign of the
business system.
</p>

<p>In <a href="ch01_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch01_01.htm">Chapter 1, "Introduction"</a> and <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch02_01.htm">Chapter 2, "Architectural Overview"</a>, we talked hypothetically about a TravelAgent
bean that was responsible for the workflow of booking a passage on a
cruise. This session bean will be used in client applications
accessed by travel agents throughout the world. In addition to
booking tickets, the TravelAgent bean also provides information about
which cabins are available on the cruise. In this chapter, we will
develop the first implementation of this listing behavior in the
TravelAgent bean. The listing method we develop in this example is
admittedly very crude and far from optimal. However, this example is
useful for demonstrating how to develop a very simple stateless
session bean and how these session beans can manage other beans. In
<a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">Chapter 7, "Session Beans"</a>, we will rewrite the listing method.
This "list cabins" behavior is used by travel agents to
provide customers with a list of cabins that can accommodate the
customer's needs. The Cabin bean does not directly support the
kind of list, nor should it. The list we need is specific to the
TravelAgent bean, so it's the Travel- Agent bean's
responsibility to query the Cabin beans and produce the list.
</p>

<p>Before we get started, we will need to create a
<a name="INDEX-664"></a>development directory for the
TravelAgent bean, as we did for the Cabin bean. We name this
directory <em class="emphasis">travelagent</em> and nest it below the
<em class="filename">com/titan</em> directory, which also contains the
<em class="emphasis">cabin</em> directory (see <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_01.htm">Chapter 4, "Developing Your First Enterprise Beans"</a>).
</p>

<a name="JBEANS-CH-4-FIG-7"></a>
<div class="figure">
<img alt="figure" src="figs/ejb2_0407.gif" webstripperlinkwas="figs/ejb2_0407.gif"></div>
<h4 class="objtitle">Figure 4-7. Directory structure for the TravelAgent bean</h4>

<a name="JBEANS-CH-4-SECT-3.1"></a>
<h3 class="sect2">4.3.1. TravelAgent: The Remote Interface</h3>

<p>
<a name="INDEX-665"></a><a name="INDEX-666"></a>
As before, we start by defining the remote interface so that our
focus is on the business purpose of the bean, rather than its
implementation. Starting small, we know that the TravelAgent will
need to provide a method for listing all the cabins available with a
specified bed count for a specific ship. We'll call that method
<tt class="literal">listCabins()</tt>. Since we only need a list of cabin
names and deck levels, we'll define
<tt class="literal">listCabins()</tt> to return an array of
<tt class="literal">String</tt>s. Here's the remote interface for
<tt class="literal">TravelAgent</tt>:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import java.rmi.RemoteException;
import javax.ejb.FinderException;

public interface TravelAgent extends javax.ejb.EJBObject {

    // String elements follow the format "id, name, deck level"
    public String [] listCabins(int shipID, int bedCount)
        throws RemoteException;
}</pre>
</blockquote>

<p>Copy the <tt class="literal">TravelAgent</tt> interface definition into
your IDE, and save it to the <em class="emphasis">travel- agent</em>
directory. Compile the class to ensure that it is correct.
</p>


<a name="JBEANS-CH-4-SECT-3.2"></a>
<h3 class="sect2">4.3.2. TravelAgentHome: The Home Interface</h3>

<p>
<a name="INDEX-667"></a><a name="INDEX-668"></a><a name="INDEX-669"></a>The
second step in the development of any bean is to create the home
interface. The home interface for a session bean defines the create
methods that initialize a new session bean for use by a client.
</p>

<p>
<a name="INDEX-670"></a><a name="INDEX-671"></a>Find
methods are not used in session beans; they are used with entity
beans to locate persistent entities for use on a client. Unlike
entity beans, session beans are not persistent and do not represent
data in the database, so a find method would not be meaningful; there
is no specific session to locate. A session bean is dedicated to a
client for the life of that client (or less). For the same reason, we
don't need to worry about primary keys; since session beans
don't represent persistent data, we don't need a key to
access that data.
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import java.rmi.RemoteException;
import javax.ejb.CreateException;

public interface TravelAgentHome extends javax.ejb.EJBHome {
    public TravelAgent create()
        throws RemoteException, CreateException;
}</pre>
</blockquote>

<p>In the case of the TravelAgent bean, we only need a simple
<tt class="literal">create()</tt> method to get a reference to the bean.
Invoking this <tt class="literal">create()</tt> method returns a
<tt class="literal">Travel-Agent</tt> remote reference that the client can
use for the reservation process. Copy the
<tt class="literal">TravelAgentHome</tt> definition into your IDE and save
it to the <em class="filename">travelagent</em> directory. Compile the
class to ensure that it is correct.
</p>


<a name="JBEANS-CH-4-SECT-3.3"></a>
<h3 class="sect2">4.3.3. TravelAgentBean: The Bean Class</h3>

<p>
<a name="INDEX-672"></a><a name="INDEX-673"></a>
Using the remote interface as a guide, we can define the
<tt class="literal">TravelAgentBean</tt> class that implements the
<tt class="literal">listCabins()</tt> method. The following code contains
the complete definition of <tt class="literal">TravelAgentBean</tt> for
this example. Copy the <tt class="literal">TravelAgentBean</tt> definition
into your IDE and save it to the <em class="filename">travelagent</em>
directory. Compile the class to ensure that it is correct. EJB 1.1
and EJB 1.0 differ significantly in how one bean locates another, so
I have provided separate TravelAgentBean listings for each version.
</p>

<a name="JBEANS-CH-4-SECT-3.3.1"></a>
<h3 class="sect3">4.3.3.1. EJB 1.1: TravelAgentBean</h3>

<p>Here's the <a name="INDEX-674"></a>code for the EJB 1.1 version of the
<tt class="literal">TravelAgentBean</tt>:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import com.titan.cabin.Cabin;
import com.titan.cabin.CabinHome;
import com.titan.cabin.CabinPK;
import java.rmi.RemoteException;
import javax.naming.InitialContext;
import javax.naming.Context;
import java.util.Properties;
import java.util.Vector;

public class TravelAgentBean implements javax.ejb.SessionBean {

   public void ejbCreate() {
   // Do nothing.
   }
   public String [] listCabins(int shipID, int bedCount) {

        try {
            javax.naming.Context jndiContext = new InitialContext();
            Object obj = jndiContext.lookup("java:comp/env/ejb/CabinHome");

            CabinHome home = (CabinHome)
                javax.rmi.PortableRemoteObject.narrow(obj, CabinHome.class);
    
            Vector vect = new Vector();
            CabinPK pk = new CabinPK();
            Cabin cabin;
            for (int i = 1; ; i++) {
               pk.id = i;
               try {
                  cabin = home.findByPrimaryKey(pk);
                } catch(javax.ejb.FinderException fe) {
                    break;
                }
                // Check to see if the bed count and ship ID match.
                if (cabin.getShip() == shipID &amp;&amp; 
                    cabin.getBedCount() == bedCount) {
                  String details = 
                    i+","+cabin.getName()+","+cabin.getDeckLevel();
                  vect.addElement(details);
                }
            }
        
            String [] list = new String[vect.size()];
            vect.copyInto(list);
            return list;
       
       } catch(Exception e) {throw new EJBException(e);}    
   }

   private javax.naming.Context getInitialContext() 
   throws javax.naming.NamingException {
      Properties p = new Properties();
      // ... Specify the JNDI properties specific to the vendor.
      return new javax.naming.InitialContext(p);
   }

   public void ejbRemove(){}
   public void ejbActivate(){}
   public void ejbPassivate(){}
   public void setSessionContext(javax.ejb.SessionContext cntx){}
}</pre>
</blockquote>

<p>Examining the <tt class="literal">listCabins()</tt> method in detail, we
can address the implementation in pieces, starting with the use of
JNDI to locate the <tt class="literal">CabinHome</tt>:
</p>

<blockquote>
<pre class="programlisting">javax.naming.Context jndiContext = new InitialContext();

Object obj = jndiContext.lookup("java:comp/env/ejb/CabinHome");

CabinHome home = (CabinHome)
    javax.rmi.PortableRemoteObject.narrow(obj, CabinHome.class);</pre>
</blockquote>

<p>
<a name="INDEX-675"></a>Beans are clients to other
beans, just like client applications. This means that they must
interact with other beans in the same way that client applications
interact with beans. In order for one bean to locate and use another
bean, it must first locate and obtain a <a name="INDEX-676"></a><a name="INDEX-677"></a><a name="INDEX-678"></a>reference to the
bean's EJB home. This is accomplished using JNDI, in exactly
the same way we used JNDI to obtain a reference to the
<tt class="literal">CabinHome</tt> in the client application we developed
earlier. In EJB 1.1, all beans have a default JNDI context called the
environment context, which was discussed a little in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch03_01.htm">Chapter 3, "Resource Management and the Primary Services"</a>. The default context exists in the name space
(directory) called <tt class="literal">"java:comp/env"</tt> and its
subdirectories. When the bean is deployed, any beans it uses are
mapped into the subdirectory <tt class="literal">"java:comp/env/ejb"</tt>,
so that bean references can be obtained at runtime through a simple
and consistent use of the JNDI default context. We'll come back
to this when we take a look at the deployment descriptor for the
TravelAgent bean below.
</p>

<p>Once the EJB home of the Cabin bean is obtained, we can use it to
produce a list of cabins that match the parameters passed. The
following code loops through all the Cabin beans and produces a list
that includes only those cabins with the ship and bed count
specified:
</p>

<blockquote>
<pre class="programlisting">Vector vect = new Vector();
CabinPK pk = new CabinPK();
Cabin cabin;
for (int i = 1; ; i++) {
   pk.id = i;
   try {
       cabin = home.findByPrimaryKey(pk);
   } catch(javax.ejb.FinderException fe){
       break;
   }
   // Check to see if the bed count and ship ID match.
   if (cabin.getShip() == shipID &amp;&amp; cabin.getBedCount() == bedCount) {
      String details = i+","+cabin.getName()+","+cabin.getDeckLevel();
      vect.addElement(details);
   }
}</pre>
</blockquote>

<p>This method simply iterates through all the primary keys, obtaining a
remote reference to each Cabin bean in the system and checking
whether its <tt class="literal">ship</tt> and <tt class="literal">bedCount</tt>
match the parameters passed in. The <tt class="literal">for</tt> loop
continues until a <tt class="literal">FinderException</tt> is thrown, which
would probably occur when a primary key is used that isn't
associated with a bean. (This isn't the most robust code
possible, but it will do for now.) Following this block of code, we
simply copy the <tt class="literal">Vector</tt>'s contents into an
array and return it to the client.
</p>

<p>
<a name="INDEX-679"></a><a name="INDEX-680"></a>While this is a very crude
approach to locating the right Cabin beans--we will define a
better method in <a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">Chapter 7, "Session Beans"</a>--it is adequate
for our current purposes. The purpose of this example is to
illustrate that the workflow associated with this listing behavior is
not included in the Cabin bean nor is it embedded in a client
application. Workflow logic, whether it's a process like
booking a reservation or obtaining a list, is <a name="INDEX-681"></a> placed in a
session bean.
</p>



<a name="JBEANS-CH-4-SECT-3.3.2"></a>
<h3 class="sect3">4.3.3.2. EJB 1.0: TravelAgentBean</h3>

<p>Here's the <a name="INDEX-682"></a>code for the EJB 1.0 version of the
<tt class="literal">TravelAgentBean</tt>:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import com.titan.cabin.Cabin;
import com.titan.cabin.CabinHome;
import com.titan.cabin.CabinPK;
import java.rmi.RemoteException;
import javax.naming.InitialContext;
import javax.naming.Context;
import java.util.Properties;
import java.util.Vector;

public class TravelAgentBean implements javax.ejb.SessionBean {

   public void ejbCreate() {
   // Do nothing.
   }
   public String [] listCabins(int shipID, int bedCount)
      throws RemoteException {
        try {
            Context jndiContext = getInitialContext();
            CabinHome home = (CabinHome)jndiContext.lookup("CabinHome");
    
            Vector vect = new Vector();
            CabinPK pk = new CabinPK();
            Cabin cabin;
            for (int i = 1; ; i++) {
               pk.id = i;
               try {
                   cabin = home.findByPrimaryKey(pk);
               } catch(javax.ejb.FinderException fe) {
                   break;
               }
               // Check to see if the bed count and ship ID match.
               if (cabin.getShip() == shipID &amp;&amp; 
                   cabin.getBedCount() == bedCount) {
                 String details = 
                   i+","+cabin.getName()+","+cabin.getDeckLevel();
                 vect.addElement(details);
               }
            }
        
            String [] list = new String[vect.size()];
            vect.copyInto(list);
            return list;
       
       } catch (javax.naming.NamingException ne) {
            throw new RemoteException("Unable to locate CabinHome",ne);
       }    
   }

   private javax.naming.Context getInitialContext() 
   throws javax.naming.NamingException {
      Properties p = new Properties();
      // ... Specify the JNDI properties specific to the vendor.
      return new javax.naming.InitialContext(p);
   }

   public void ejbRemove(){}
   public void ejbActivate(){}
   public void ejbPassivate(){}
   public void setSessionContext(javax.ejb.SessionContext cntx){}
}</pre>
</blockquote>

<p>The most significant difference between this code and the EJB 1.1
code is the use of JNDI to locate the <tt class="literal">CabinHome</tt>:
</p>

<blockquote>
<pre class="programlisting">Context jndiContext = getInitialContext();
CabinHome cabinHome = (CabinHome)jndiContext.lookup("CabinHome");</pre>
</blockquote>

<p>
<a name="INDEX-683"></a>Beans interact with other
beans in the same way that clients interact with beans. In order for
one bean to locate and use another bean, it must first locate and
obtain a <a name="INDEX-684"></a><a name="INDEX-685"></a><a name="INDEX-686"></a>reference to the
bean's EJB home. This is accomplished using JNDI, in exactly
the same way we used JNDI to obtain a reference to the
<tt class="literal">CabinHome</tt> in the client application we developed
earlier. If you take a close look at the method
<a name="INDEX-687"></a><tt class="literal">getInitialContext()</tt>, you will discover that it is
exactly the same as the <tt class="literal">getInitialContext()</tt> method
in the client classes defined earlier. The only difference is that
the method is not static. You will need to change this code to match
the correct settings for your EJB server. Once the EJB home of the
Cabin bean is obtained, we can use it to produce our list of cabins
that match the parameters passed.
</p>

<p>The logic for finding beans with cabins that match the desired
parameters is the same in EJB 1.1 and EJB 1.0. Again, it's a
crude approach: we will define a better method in <a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch07_01.htm">Chapter 7, "Session Beans"</a>. Our purpose here is to demonstrate that the
workflow associated with this listing behavior is not included in the
Cabin bean nor is it embedded in a client application. Workflow
logic, whether it's a process like booking a reservation or
<a name="INDEX-688"></a>
obtaining a list, is placed in a session <a name="INDEX-689"></a><a name="INDEX-690"></a> bean.
</p>



<a name="JBEANS-CH-4-SECT-3.4"></a>
<h3 class="sect2">4.3.4. EJB 1.1: TravelAgent Bean's Deployment Descriptor</h3>

<p>The TravelAgent bean uses an <a name="INDEX-691"></a><a name="INDEX-692"></a>XML deployment descriptor similar to the
one used for the Cabin entity bean. Here is the
<em class="emphasis">ejb-jar.xml</em> file used to deploy the TravelAgent.
In <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch10_01.htm">Chapter 10, "XML Deployment Descriptors"</a>, you will learn how to deploy several
beans in one deployment descriptor, but for now the TravelAgent and
Cabin beans are deployed separately.
</p>

<blockquote>
<pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE ejb-jar PUBLIC "-//Sun Microsystems, Inc.//DTD Enterprise
JavaBeans 1.1//EN" "http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd"&gt;
&lt;ejb-jar&gt;
 &lt;enterprise-beans&gt;
  &lt;session&gt;
    &lt;ejb-name&gt;TravelAgentBean&lt;/ejb-name&gt;
    &lt;home&gt;com.titan.travelagent.TravelAgentHome&lt;/home&gt;
    &lt;remote&gt;com.titan.travelagent.TravelAgent&lt;/remote&gt;
    &lt;ejb-class&gt;com.titan.travelagent.TravelAgentBean&lt;/ejb-class&gt;
    &lt;session-type&gt;Stateless&lt;/session-type&gt;
    &lt;transaction-type&gt;Container&lt;/transaction-type&gt;

    &lt;ejb-ref&gt;
      &lt;ejb-ref-name&gt;ejb/CabinHome&lt;/ejb-ref-name&gt;
      &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt;
      &lt;home&gt;com.titan.cabin.CabinHome&lt;/home&gt;
      &lt;remote&gt;com.titan.cabin.Cabin&lt;/remote&gt;
   &lt;/ejb-ref&gt;
  &lt;/session&gt;
 &lt;/enterprise-beans&gt;
 
 &lt;assembly-descriptor&gt;
   &lt;security-role&gt;
      &lt;description&gt;
         This role represents everyone who is allowed full access 
         to the cabin bean.
      &lt;/description&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
   &lt;/security-role&gt;

   &lt;method-permission&gt;
     &lt;role-name&gt;everyone&lt;/role-name&gt;
     &lt;method&gt;
         &lt;ejb-name&gt;TravelAgentBean&lt;/ejb-name&gt;
         &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
   &lt;/method-permission&gt;

   &lt;container-transaction&gt;
     &lt;method&gt;
        &lt;ejb-name&gt;TravelAgentBean&lt;/ejb-name&gt;
        &lt;method-name&gt;*&lt;/method-name&gt;
     &lt;/method&gt;
     &lt;trans-attribute&gt;Required&lt;/trans-attribute&gt;
   &lt;/container-transaction&gt;
 &lt;/assembly-descriptor&gt;
&lt;/ejb-jar&gt;</pre>
</blockquote>

<p>Other than the
<tt class="literal">&lt;session-type&gt;</tt><a name="INDEX-693"></a>and
<tt class="literal">&lt;ejb-ref&gt;</tt><a name="INDEX-694"></a> elements, this XML deployment
descriptor should make sense since it uses many of the same elements
as the Cabin bean's. The
<tt class="literal">&lt;session-type&gt;</tt> element can
<a name="INDEX-695"></a><a name="INDEX-696"></a>be
<tt class="literal">Stateful</tt> or <tt class="literal">Stateless</tt> to
indicate which type of session bean is used.
</p>

<p>The <tt class="literal">&lt;ejb-ref&gt;</tt> element is used at deployment
time to map the bean references used within the TravelAgent bean. In
this case, the <tt class="literal">&lt;ejb-ref&gt;</tt> element describes
the Cabin bean, which we already deployed. The
<tt class="literal">&lt;ejb-ref-name&gt;</tt><a name="INDEX-697"></a> element specifies the name that must be
used by the TravelAgent bean to obtain a reference to the Cabin
bean's home. The
<tt class="literal">&lt;ejb-ref-type&gt;</tt><a name="INDEX-698"></a> tells the container what kind of bean
it is, <tt class="literal">Entity</tt> or <tt class="literal">Session</tt>. The
<tt class="literal">&lt;home&gt;</tt> and <tt class="literal">&lt;remote&gt;</tt>
elements specify the fully qualified interface names of the
Cabin's home and remote bean interfaces.
</p>

<p>When the bean is deployed, the <tt class="literal">&lt;ejb-ref&gt;</tt>
will be mapped to the Cabin bean in the EJB server. This is a
vendor-specific process, but the outcome should always be the same.
When the TravelAgent does a JNDI lookup using the context name
<tt class="literal">"java:comp/env/ejb/CabinHome"</tt> it will obtain a
remote reference to the Cabin bean's home. The purpose of the
<tt class="literal">&lt;ejb-ref&gt;</tt> element is to eliminate network
specific and implementation specific use of JNDI to obtain bean
references. This makes a bean more portable because the network
location and JNDI service provider can change without impacting the
bean code or even the XML deployment <a name="INDEX-699"></a><a name="INDEX-700"></a> descriptor.
</p>


<a name="JBEANS-CH-4-SECT-3.5"></a>
<h3 class="sect2">4.3.5. EJB 1.0: The TravelAgent Beans' Deployment Descriptor</h3>

<p>
<a name="INDEX-701"></a>Deploying the TravelAgent bean is
essentially the same as deploying the Cabin bean, except we use a
<tt class="literal">SessionDescriptor</tt><a name="INDEX-702"></a> instead of an
<tt class="literal">EntityDescriptor</tt>. Here is the definition of the
<tt class="literal">MakeDD</tt> for creating and serializing a
<tt class="literal">SessionDescriptor</tt> for the
<tt class="literal">TravelAgentBean</tt>:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import javax.ejb.deployment.*;
import javax.naming.CompoundName;
import java.util.*;
import java.io.*;

public class MakeDD {

    public static void main(String [] args) {
        try {

            if (args.length &lt;1) {
                System.out.println("must specify target directory");
                return;
            }
<b class="emphasis-bold">
            SessionDescriptor sd = new SessionDescriptor();</b>

            sd.setEnterpriseBeanClassName(
                "com.titan.travelagent.TravelAgentBean");
            sd.setHomeInterfaceClassName(
                "com.titan.travelagent.TravelAgentHome");
            sd.setRemoteInterfaceClassName(
                "com.titan.travelagent.TravelAgent");
<b class="emphasis-bold">
            sd.setSessionTimeout(300);</b>
<b class="emphasis-bold">
            sd.setStateManagementType(SessionDescriptor.STATELESS_SESSION);</b>

            ControlDescriptor cd = new ControlDescriptor();
            cd.setIsolationLevel(ControlDescriptor.TRANSACTION_READ_COMMITTED);
            cd.setMethod(null);
            cd.setRunAsMode(ControlDescriptor.CLIENT_IDENTITY);
            cd.setTransactionAttribute(ControlDescriptor.TX_REQUIRED);
            ControlDescriptor [] cdArray = {cd};
            sd.setControlDescriptors(cdArray);
<b class="emphasis-bold">
            CompoundName jndiName = </b>
<b class="emphasis-bold">            new CompoundName("TravelAgentHome", new Properties());</b>
            sd.setBeanHomeName(jndiName);

            String fileSeparator = 
                System.getProperties().getProperty("file.separator");
            if(! args[0].endsWith(fileSeparator))
                args[0] += fileSeparator;

            FileOutputStream fis = 
                new FileOutputStream(args[0]+"TravelAgentDD.ser");
            ObjectOutputStream oos = new ObjectOutputStream(fis);
            oos.writeObject(sd);
            oos.flush();
            oos.close();
            fis.close();
        } catch(Throwable t) { t.printStackTrace(); }
    }
}</pre>
</blockquote>

<p>The <tt class="literal">MakeDD</tt> definition for the TravelAgent bean is
essentially the same as the one for the Cabin bean. The difference is
that we are using a <tt class="literal">SessionDescriptor</tt> instead of
an <tt class="literal">EntityDescriptor</tt> and the bean class names and
JNDI name are different. We do not specify any container-managed
fields because session beans are not persistent.
</p>

<p>After instantiating the
<tt class="literal">javax.ejb.SessionDescriptor</tt>, the
<tt class="literal">MakeDD</tt> application sets the remote interface and
bean class names:
</p>

<blockquote>
<pre class="programlisting">sd.setEnterpriseBeanClassName("com.titan.travelagent.TravelAgentBean");
sd.setHomeInterfaceClassName("com.titan.travelagent.TravelAgentHome");
sd.setRemoteInterfaceClassName("com.titan.travelagent.TravelAgent");</pre>
</blockquote>

<p>Next, we set two properties that control session timeouts (what
happens if the bean is idle) and state management:
</p>

<blockquote>
<pre class="programlisting">sd.setSessionTimeout(300);
sd.setStateManagementType(SessionDescriptor.STATELESS_SESSION);</pre>
</blockquote>

<p>
<a name="INDEX-703"></a><tt class="literal">setSessionTimeout()</tt> specifies how many seconds the
session should remain alive if it is not being used. In
<tt class="literal">MakeDD</tt> we specify 300 seconds. This means that if
no method is invoked on the session for over five minutes, it will be
removed and will no longer be available for use.<a href="#FOOTNOTE-3">[3]</a> If a method is invoked on a bean
that has timed out, a
<tt class="literal">javax.ejb.ObjectNotFoundException</tt> will be thrown.
Once a stateful session bean has timed out, all of its accumulated
state is lost. When a session bean times out, the client must create
a new TravelAgent bean by invoking the
<tt class="literal">TravelAgentHome.create()</tt> method. The
<a name="INDEX-704"></a><tt class="literal">setStateManagement()</tt> method determines whether the
bean is stateful or stateless. At this point in it its development,
the <tt class="literal">TravelAgentBean</tt> doesn't have any
conversational state that needs to be maintained from one method to
the next, so we make it a stateless session bean, which is more
efficient. Both of these methods are unique to session descriptors;
there are no corresponding methods in <a name="INDEX-705"></a> the
<tt class="literal">EntityDescriptor</tt> class.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-3"></a>
<p>[3]
Whether a session timeout is measured from creation time (the time
the session bean is created) or from the time of last activity (when
the last business method is invoked) is not clearly described in EJB
1.0. As a result, some vendors set the timeout relative to one of
these two events (creation or last activity). Consult your
vendor's documentation to determine your EJB server's
timeout policy.</p> </blockquote>

<p>The next section specifies the default
<a name="INDEX-706"></a><a name="INDEX-707"></a><a name="INDEX-708"></a><tt class="literal">ControlDescriptor</tt> for
the <tt class="literal">TravelAgentBean</tt>. These settings are the same
as those used in the Cabin bean. The isolation level determines the
visibility of the data being accessed. <a href="ch08_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch08_01.htm">Chapter 8, "Transactions"</a>
explores isolation levels in more detail. The transactional
attribute, <tt class="literal">TX_REQUIRED</tt>, tells the EJB server that
this bean must be included in the transactional scope of the client
invoking it; if the client is not in a transaction, a new transaction
must be created for the method invocation, as follows:
</p>

<blockquote>
<pre class="programlisting">ControlDescriptor cd = new ControlDescriptor();
cd.setIsolationLevel(ControlDescriptor.TRANSACTION_READ_COMMITTED);
cd.setMethod(null);
cd.setRunAsMode(ControlDescriptor.CLIENT_IDENTITY);
cd.setTransactionAttribute(ControlDescriptor.TX_REQUIRED);
ControlDescriptor [] cdArray = {cd};
sd.setControlDescriptors(cdArray);</pre>
</blockquote>

<p>The next section creates a JNDI name for
<tt class="literal">TravelAgent</tt>'s EJB home. When we use JNDI to
look up the <tt class="literal">TravelAgentHome</tt>, this will be the name
we specify:
</p>

<blockquote>
<pre class="programlisting">CompoundName jndiName = new CompoundName("TravelAgentHome",new Properties());</pre>
</blockquote>

<p>Finally, the <tt class="literal">MakeDD</tt> serializes the
<tt class="literal">SessionDescriptor</tt><a name="INDEX-709"></a>
 to a file named
<em class="emphasis">TravelAgentDD</em>.<em class="emphasis">ser</em> and saves
it to the <em class="filename">travelagent</em> directory.
</p>

<p>You will need to compile and run the <tt class="literal">MakeDD</tt> class
before <a name="INDEX-710"></a> continuing:
</p>

<blockquote>
<pre class="programlisting">\dev % java com.titan.travelagent.MakeDD com/titan/travelagent

F:\..\dev&gt;java com.titan.travelagent.MakeDD com\titan\travelagent</pre>
</blockquote>


<a name="JBEANS-CH-4-SECT-3.6"></a>
<h3 class="sect2">4.3.6. EJB 1.1: The JAR File</h3>

<p>
<a name="INDEX-711"></a><a name="INDEX-712"></a>To
place the TravelAgent bean in a JAR file, we use the same process we
used for the Cabin bean. We shrink-wrap the TravelAgent bean class
and its deployment descriptor into a JAR file and save to the
<em class="filename">com/titan/travelagent</em> directory:
</p>

<blockquote>
<pre class="programlisting">\dev % jar cf cabin.jar com/titan/travelagent/*.class META-INF/ejb-jar.xml

F:\..\dev&gt;jar cf cabin.jar com\titan\travelagent\*.class META-INF\ejb-jar.xml</pre>
</blockquote>

<p>You might have to create the <em class="filename">META-INF</em> directory first, and copy
<em class="filename">ejb-jar.xml</em> into that directory. The TravelAgent
bean is now complete and ready to be
deployed.<a name="INDEX-713"></a><a name="INDEX-714"></a>
</p>


<a name="JBEANS-CH-4-SECT-3.7"></a>
<h3 class="sect2">4.3.7. EJB 1.0: The JAR File</h3>

<p>
<a name="INDEX-715"></a><a name="INDEX-716"></a>To
place the TravelAgent bean in a JAR file, we use the same process we
used for the Cabin bean. First, we have to create a manifest file,
which we save in the <em class="filename">com/titan/travelagent</em>
directory:
</p>

<blockquote>
<pre class="programlisting">Name: com/titan/travelagent/TravelAgentDD.ser
Enterprise-Bean: True</pre>
</blockquote>

<p>Now that the manifest is ready, we can shrink-wrap the TravelAgent
bean so that it's ready for deployment:
</p>

<blockquote>
<pre class="programlisting">\dev % jar cmf com/titan/travelagent/manifest \
TravelAgent.jar com/titan/travelagent/*.class com/titan/travelagent/*.ser

F:\..\dev&gt;jar cmf com\titan\travelagent\manifest TravelAgent.jar 
com\titan\travelagent\*.class com\titan\travelagent\*.ser</pre>
</blockquote>

<p>The TravelAgent bean is now complete and ready to be deployed.</p>


<a name="JBEANS-CH-4-SECT-3.8"></a>
<h3 class="sect2">4.3.8. Deploying the TravelAgent Bean</h3>

<p>
<a name="INDEX-717"></a><a name="INDEX-718"></a>To make
your TravelAgent bean available to a client application, you need to
use the deployment utility or wizard of your EJB server. The
deployment utility reads the JAR file to add the TravelAgent bean to
the EJB server environment. Unless your EJB server has special
requirements, it is unlikely that you will need to change or add any
new attributes to the bean. You will not need to create a database
table for this example, since the TravelAgent bean is using only the
Cabin bean and is not itself persistent. Deploy the TravelAgent bean
and proceed to the next section.
</p>


<a name="JBEANS-CH-4-SECT-3.9"></a>
<h3 class="sect2">4.3.9. Creating a Client Application</h3>

<p>
<a name="INDEX-719"></a><a name="INDEX-720"></a>To show that our session bean works,
we'll create a simple client application that uses it. This
client simply produces a list of cabins assigned to ship 1 with a bed
count of 3. Its logic is similar to the client we created earlier to
test the Cabin bean: it creates a context for looking up
<tt class="literal">TravelAgentHome</tt>, creates a TravelAgent bean, and
invokes <tt class="literal">listCabins()</tt> to generate a list of the
cabins available. Here's the code:
</p>

<blockquote>
<pre class="programlisting">package com.titan.travelagent;

import com.titan.cabin.CabinHome;
import com.titan.cabin.Cabin;
import com.titan.cabin.CabinPK;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NamingException;
import javax.ejb.CreateException;
import java.rmi.RemoteException;
import java.util.Properties;

public class Client_1 {
    public static int SHIP_ID = 1;
    public static int BED_COUNT = 3;

    public static void main(String [] args) {
        try {
           Context jndiContext = getInitialContext();
           
           Object ref = (TravelAgentHome)
               jndiContext.lookup("TravelAgentHome");
           TravelAgentHome home = (TravelAgentHome)
               // EJB 1.0: Use Java cast instead of narrow()
               PortableRemoteObject.narrow(ref,TravelAgentHome.class);
        
           TravelAgent reserve = home.create();
        
           // Get a list of all cabins on ship 1 with a bed count of 3.
<b class="emphasis-bold">           String list [] = reserve.listCabins(SHIP_ID,BED_COUNT);</b>
        
           for(int i = 0; i &lt; list.length; i++){
              System.out.println(list[i]);
           }
        
        } catch(java.rmi.RemoteException re){re.printStackTrace();}
          catch(Throwable t){t.printStackTrace();}
  }
  static public Context getInitialContext() throws Exception {
    Properties p = new Properties();
    // ... Specify the JNDI properties specific to the vendor.
    return new InitialContext(p);
  }
}</pre>
</blockquote>

<p>The output should look like this:</p>

<blockquote>
<pre class="programlisting">1,Master Suite                  ,1
3,Suite 101                     ,1
5,Suite 103                     ,1
7,Suite 105                     ,1
9,Suite 107                     ,1
12,Suite 201                     ,2
14,Suite 203                     ,2
16,Suite 205                     ,2
18,Suite 207                     ,2
20,Suite 209                     ,2
22,Suite 301                     ,3
24,Suite 303                     ,3
26,Suite 305                     ,3
28,Suite 307                     ,3
30,Suite 309                     ,3</pre>
</blockquote>

<p>You have now successfully created the first piece of the TravelAgent
session bean: a method that obtains a list of cabins by <a name="INDEX-721"></a> manipulating the
<a name="INDEX-722"></a>
Cabin bean <a name="INDEX-723"></a><a name="INDEX-724"></a> entity.
</p>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch04_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch04_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/ch05_01.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">4.2. Developing an Entity Bean</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">5. The Client View</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
