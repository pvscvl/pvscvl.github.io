<html>
<head>
<title>Statements (Java in a Nutshell)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David Flanagan">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-487-8E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Statements">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm" alt="Java Enterprise in a Nutshell"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch02_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_05.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2: Java Syntax

from the Ground Up</a></td><td align="right" valign="top" width="172"><a href="ch02_07.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_07.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY --><h2 class="sect1">2.6. Statements</h2>
<p>
<a name="INDEX-314"></a>

      A <em class="emphasis">statement</em> is a single "command" that is
      executed by the Java interpreter. By default, the Java interpreter
      runs one statement 
      after another, in the order they are written. Many of the
      statements defined by Java, however, are flow-control
      statements, such as conditionals and loops, that alter this default
      order of execution in well-defined ways. <a href="#javanut3-ch-2-tab-6">Table 2-6</a> summarizes the statements defined
      by Java. </p>

<a name="javanut3-ch-2-tab-6"></a>
<h4 class="objtitle">Table 2-6. Java Statements</h4>
<table border="1">
<tr>
<th>Statement</th><th>Purpose</th><th>Syntax</th>
</tr>
<tr>
<td><em class="emphasis">expression</em></td><td>side effects</td><td>
<p>
<em class="replaceable">var</em><tt class="literal">=</tt><em class="replaceable">expr</em><tt class="literal">;</tt><em class="replaceable">expr</em><tt class="literal">++;</tt><em class="replaceable">method</em><tt class="literal">();</tt><tt class="literal">new</tt><em class="replaceable">Type</em><tt class="literal">();</tt>
</p>
</td>
</tr>
<a name="INDEX-315"></a>
<tr>
<td><em class="emphasis">compound</em></td><td>group statements</td><td><tt class="literal">{</tt> <em class="replaceable">statements</em> <tt class="literal">}</tt></td>
</tr>
<tr>
<td><em class="emphasis">empty</em></td><td>do nothing</td><td><tt class="literal">;</tt></td>
</tr>
<tr>
<td><em class="emphasis">labeled</em></td><td>name a statement</td><td><em class="replaceable">label</em> <tt class="literal">:</tt> <em class="replaceable">statement</em></td>
</tr>
<tr>
<td><em class="emphasis">variable</em></td><td>declare a variable</td><td>[<tt class="literal">final</tt>] <em class="replaceable">type</em> <em class="replaceable">name</em> [<tt class="literal">=</tt> <em class="replaceable">value</em>] [<tt class="literal">,</tt> <em class="replaceable">name</em> [<tt class="literal">=</tt> <em class="replaceable">value</em>]] ...<tt class="literal">;</tt></td>
</tr>
<tr>
<td><tt class="literal">if</tt></td><td>conditional</td><td><tt class="literal">if (</tt> <em class="replaceable">expr</em> <tt class="literal">)</tt> <em class="replaceable">statement</em> [ <tt class="literal">else</tt> <em class="replaceable">statement</em>]</td>
</tr>
<tr>
<td><tt class="literal">switch</tt></td><td>conditional</td><td>
<p>
<tt class="literal">switch (</tt><em class="replaceable">expr</em><tt class="literal">) {</tt>

	      [ <tt class="literal">case</tt><em class="replaceable">expr</em><tt class="literal">:</tt><em class="replaceable">statements</em> ] ... 


	      [ <tt class="literal">default:</tt><em class="replaceable">statements</em> ]
<tt class="literal">}</tt>
</p>
</td>
</tr>
<tr>
<td><tt class="literal">while</tt></td><td>loop</td><td><tt class="literal">while (</tt> <em class="replaceable">expr</em> <tt class="literal">)</tt> <em class="replaceable">statement</em></td>
</tr>
<tr>
<td><tt class="literal">do</tt></td><td>loop</td><td><tt class="literal">do</tt> <em class="replaceable">statement</em> <tt class="literal">while (</tt> <em class="replaceable">expr</em> <tt class="literal">);</tt></td>
</tr>
<tr>
<td><tt class="literal">for</tt></td><td>simplified loop</td><td><tt class="literal">for (</tt> <em class="replaceable">init</em> <tt class="literal">;</tt> <em class="replaceable">test</em> <tt class="literal">;</tt> <em class="replaceable">increment</em> <tt class="literal">)</tt> <em class="replaceable">statement</em></td>
</tr>
<tr>
<td><tt class="literal">break</tt></td><td>exit block</td><td><tt class="literal">break</tt> [ <em class="replaceable">label</em> ] <tt class="literal">;</tt></td>
</tr>
<tr>
<td><tt class="literal">continue</tt></td><td>restart loop</td><td><tt class="literal">continue</tt> [ <em class="replaceable">label</em> ] <tt class="literal">;</tt></td>
</tr>
<tr>
<td><tt class="literal">return</tt></td><td>end method</td><td><tt class="literal">return</tt> [ <em class="replaceable">expr</em> ] <tt class="literal">;</tt></td>
</tr>
<tr>
<td><tt class="literal">synchronized</tt></td><td>critical section</td><td><tt class="literal">synchronized (</tt> <em class="replaceable">expr</em> <tt class="literal">) {</tt> <em class="replaceable">statements</em> <tt class="literal">}</tt></td>
</tr>
<tr>
<td><tt class="literal">throw</tt></td><td>throw exception</td><td><tt class="literal">throw</tt> <em class="replaceable">expr</em> <tt class="literal">;</tt></td>
</tr>
<tr>
<td><tt class="literal">try</tt></td><td>handle exception</td><td>
<p>
<tt class="literal">try {</tt><em class="replaceable">statements</em><tt class="literal">}</tt>

	    [ <tt class="literal">catch (</tt><em class="replaceable">type</em><em class="replaceable">name</em><tt class="literal">) {</tt><em class="replaceable">statements</em><tt class="literal">}</tt> ] ... 


	    [ <tt class="literal">finally {</tt><em class="replaceable">statements</em><tt class="literal">}</tt> ]
		</p>
</td>
</tr>
</table>

<h3 class="sect2">2.6.1. Expression Statements</h3>
<p>
<a name="INDEX-316"></a><a name="INDEX-317"></a>

	As we saw earlier in the chapter, certain types of Java
	expressions have side effects. In other words, they do not simply
	evaluate to some value, but also change the program state in
	some way. Any expression with side effects can be used as a
	statement simply by following it with a semicolon. The legal
	types of expression statements are assignments, increments and
	decrements, method calls, and object creation. For example:
</p>
<blockquote>
<pre class="programlisting">a = 1;                             // Assignment
x *= 2;                            // Assignment with operation
i++;                               // Post-increment
--c;                               // Pre-decrement
System.out.println("statement");   // Method invocation</pre>
</blockquote>
<h3 class="sect2">2.6.2. Compound Statements</h3>
<p>
<a name="INDEX-318"></a><a name="INDEX-319"></a>

	A <em class="emphasis">compound statement</em> is any 
	number and kind of statements grouped together within curly
	braces. You can use a
	compound statement anywhere a
	<em class="replaceable">statement</em> is required by Java syntax:
</p>
<blockquote>
<pre class="programlisting">for(int i = 0; i &lt; 10; i++) {                             
  a[i]++;                     // Body of this loop is a compound
  statement. b[i]--;          // It consists of two expression statements
}                             // within curly braces. </pre>
</blockquote>
<h3 class="sect2">2.6.3. The Empty Statement</h3>
<p>
<a name="INDEX-320"></a><a name="INDEX-321"></a>

	An <em class="emphasis">empty statement</em> in Java is written as a single
	semicolon. The empty statement doesn't do anything, but the
	syntax is occasionally useful. For example, you can use it
	to indicate an empty
	loop body of a <tt class="literal">for</tt> loop:
</p>
<blockquote>
<pre class="programlisting">for(int i = 0; i &lt; 10; a[i++]++)  // Increment array elements
    /* empty */;                  // Loop body is empty statement</pre>
</blockquote>
<h3 class="sect2">2.6.4. Labeled Statements</h3>
<p>
<a name="INDEX-322"></a><a name="INDEX-323"></a>

	A <em class="emphasis">labeled statement</em> 
	is simply a statement that has been given a
	name by prepending a identifier and a colon to it. Labels are
	used by the <tt class="literal">break</tt> and
	<tt class="literal">continue</tt> statements. For example:
</p>
<blockquote>
<pre class="programlisting">rowLoop: for(int r = 0; r &lt; rows.length; r++) {        // A labeled loop
  colLoop: for(int c = 0; c &lt; columns.length; c++) {   // Another one
    break rowLoop;                                     // Use a label
  }
}</pre>
</blockquote>
<h3 class="sect2">2.6.5. Local Variable Declaration Statements</h3>
<p>
<a name="INDEX-324"></a><a name="INDEX-325"></a><a name="INDEX-326"></a>

	A <em class="emphasis">local variable</em>, often 
	simply called a variable, is a symbolic
	name for a location where a value can be stored that is
	defined within a method or compound statement. All variables
	must be declared before they can be used; this is done with a
	variable declaration statement. Because Java is a
	strongly typed language, a variable declaration specifies the
	type of the variable, and only values of that type can be stored
	in the variable. </p>
<p>	In its simplest form, a variable declaration specifies a
	variable's type and name:
</p>
<blockquote>
<pre class="programlisting">int counter;
String s;</pre>
</blockquote>
<p>	A variable declaration can also include an
	<em class="emphasis">initializer</em> : an expression that specifies
	an initial value for the variable. For example:
</p>
<blockquote>
<pre class="programlisting">int i = 0;
String s = readLine();
int[] data = {x+1, x+2, x+3};  // Array initializers are documented later</pre>
</blockquote>
<p>
        The Java compiler does not
	allow you to use a variable that has not been initialized, so it
	is usually convenient to combine variable declaration and
	initialization into a single statement. The initializer expression need not be a literal value
	or a constant expression that can be evaluated by the compiler;
	it can be an arbitrarily complex expression whose value is
	computed when the program is run. </p>
<p>	A single variable declaration statement can declare and
	initialize more than one variable, but all variables
	must be of the same type. Variable names and optional
	initializers are separated from each other with commas:
</p>
<blockquote>
<pre class="programlisting">int i, j, k;
float x = 1.0, y = 1.0;
String question = "Really Quit?", response;</pre>
</blockquote>
<p>	In Java 1.1 and later, variable declaration statements can begin
	with the <tt class="literal">final</tt> keyword. This modifier
	specifies that once an initial value is specified for the
	variable, that value is never allowed to change:
</p>
<blockquote>
<pre class="programlisting">final String greeting = getLocalLanguageGreeting();</pre>
</blockquote>
<p>	C programmers should note that Java variable declaration
	statements can appear anywhere in Java code; they are not
	restricted to the beginning of a method or block of code. Local
	variable declarations can also be integrated with the
	<em class="replaceable">initialize</em> portion of a
	<tt class="literal">for</tt> loop, as we'll discuss shortly. </p>
<p>	Local variables can be used only within the method or block of
	code in which they are defined. This is called their
	<em class="emphasis">scope</em> or <em class="emphasis">lexical
	scope</em> :
</p>
<blockquote>
<pre class="programlisting">void method() {           // A generic method
  int i = 0;              // Declare variable i
  while (i &lt; 10) {        // i is in scope here
    int j = 0;            // Declare j; i and j are in scope here
  }                       // j is no longer in scope; can't use it anymore
  System.out.println(i);  // i is still in scope here
}                         // The scope of i ends here</pre>
</blockquote>
<h3 class="sect2">2.6.6. The if/else Statement</h3>
<p>
<a name="INDEX-327"></a><a name="INDEX-328"></a>

	The <tt class="literal">if</tt> statement is the fundamental control
	statement that allows Java to make decisions or, more
	precisely, to execute statements conditionally. The
	<tt class="literal">if</tt> statement has an associated expression and
	statement. If the expression evaluates to
	<tt class="literal">true</tt>, the interpreter 
	executes the statement. If the
	expression evaluates to <tt class="literal">false</tt>, however,
	the interpreter skips the statement. For example:
      </p>
<blockquote>
<pre class="programlisting">if (username == null)         // If username is null,
  username = "John Doe";      // define it. </pre>
</blockquote>
<p>	Although they look extraneous, the parentheses around the
	expression are a required part of the syntax for the
	<tt class="literal">if</tt> statement. </p>
<p>	As I already mentioned, a block of statements enclosed in curly
	braces is itself a statement, so we can also write
	<tt class="literal">if</tt> statements that look as follows:
      </p>
<blockquote>
<pre class="programlisting">if ((address == null) || (address.equals(""))) {
  address = "[undefined]";
  System.out.println("WARNING: no address specified.");
}</pre>
</blockquote>
<p>	An <tt class="literal">if</tt> statement can include an optional
	<tt class="literal">else</tt> keyword that is followed by a second
	statement. In this form of the statement, the
	expression is evaluated, and, if it is
	<tt class="literal">true</tt>, the first statement is executed. Otherwise, the second statement is executed. For example:
      </p>
<blockquote>
<pre class="programlisting">if (username != null) 
  System.out.println("Hello " + username);
else {
  username = askQuestion("What is your name?");
  System.out.println("Hello " + username + ". Welcome!");
}</pre>
</blockquote>
<p>	When you use nested <tt class="literal">if/else</tt> statements, some
	caution is required to ensure that the <tt class="literal">else</tt>
	clause goes with the appropriate <tt class="literal">if</tt>
	statement. Consider the following lines:
      </p>
<blockquote>
<pre class="programlisting">if (i == j) 
  if (j == k)
    System.out.println("i equals k");
else 
  System.out.println("i doesn't equal j");    // WRONG!!</pre>
</blockquote>
<p>	In this example, the inner <tt class="literal">if</tt> statement forms
	the single statement allowed by the syntax of the outer
	<tt class="literal">if</tt> statement. Unfortunately, it is not clear
	(except from the hint given by the indentation) which
	<tt class="literal">if</tt> the <tt class="literal">else</tt> goes with. And
	in this example, the indentation hint is wrong. The rule is
	that an <tt class="literal">else</tt> 
	clause like this is associated with the nearest
	<tt class="literal">if</tt> statement. Properly indented, this code
	looks like this:
      </p>
<blockquote>
<pre class="programlisting">if (i == j) 
  if (j == k)
    System.out.println("i equals k");
  else 
    System.out.println("i doesn't equal j");    // WRONG!!</pre>
</blockquote>
<p>	This is legal code, but it is clearly not what the programmer had
	in mind. When working with nested <tt class="literal">if</tt>
	statements, you should use curly braces to make your code easier
	to read. Here is a better way to write the code:
      </p>
<blockquote>
<pre class="programlisting">if (i == j) {
  if (j == k) 
    System.out.println("i equals k");
}
else {
  System.out.println("i doesn't equal j");
}</pre>
</blockquote>
<h3 class="sect3">2.6.6.1. The else if clause</h3>
<p>
<a name="INDEX-329"></a>

	  The <tt class="literal">if/else</tt> statement is
	  useful for testing a condition and choosing between two
	  statements or blocks of code to execute. But what about when
	  you need to choose between several blocks of code?  This is
	  typically done with an <tt class="literal">else</tt><tt class="literal">if</tt> clause,
	  which is not really new syntax, but a common idiomatic usage
	  of the standard <tt class="literal">if/else</tt> statement. It
	  looks like this:
</p>
<blockquote>
<pre class="programlisting">if (n == 1) {
   // Execute code block #1
}
else if (n == 2) {
   // Execute code block #2
}
else if (n == 3) {
   // Execute code block #3
}
else {
   // If all else fails, execute block #4
}</pre>
</blockquote>
<p>      There is nothing special about this code. It is just a series of
      <tt class="literal">if</tt> statements, where each <tt class="literal">if</tt>
      is part of the <tt class="literal">else</tt> clause of the previous
      statement. Using the <tt class="literal">else</tt><tt class="literal">if</tt> idiom is preferable to, and more legible
      than, writing these statements out in their fully nested form:
</p>
<blockquote>
<pre class="programlisting">if (n == 1) {
  // Execute code block #1
}
else {
  if (n == 2) {
    // Execute code block #2
  }
  else {
    if (n == 3) {
      // Execute code block #3
    }
    else {
      // If all else fails, execute block #4
    }
  }
}</pre>
</blockquote>
<p>
</p>
<h3 class="sect2">2.6.7. The switch Statement</h3>
<p>
<a name="INDEX-330"></a><a name="INDEX-331"></a>

	An <tt class="literal">if</tt> statement causes a branch in the flow
	of a program's execution. You can use multiple <tt class="literal">if</tt> 
	statements, as shown
	in the previous section, to perform a multiway branch. This is not always the best solution, however, especially 
	when all of the branches depend on the value of a
	single variable. In this case, 
	it is inefficient to repeatedly check
	the value of the same variable in multiple <tt class="literal">if</tt>
	statements. </p>
<p>	A better solution is to use a
	<tt class="literal">switch</tt> statement, which
	is inherited from the C programming language. Although the
	syntax of this statement is not nearly as elegant as 
	other parts of Java, the brute practicality of the construct
	makes it worthwhile. If you are not familiar with the
	<tt class="literal">switch</tt> statement itself, you may at least be
	familiar with the basic concept, under the name computed goto
	or jump table. A <tt class="literal">switch</tt> statement has an integer
	expression and a body that contains various numbered entry
	points. The expression is evaluated, and control jumps to the
	entry point specified by that value. For example, the following
	<tt class="literal">switch</tt> statement is equivalent to the
	repeated <tt class="literal">if</tt> and <tt class="literal">else/if</tt>
	statements shown in the previous section:
      </p>
<blockquote>
<pre class="programlisting">switch(n) {
  case 1:                         // Start here if n == 1
    // Execute code block #1
    break;                        // Stop here
  case 2:                         // Start here if n == 2
    // Execute code block #2
    break;                        // Stop here
  case 3:                         // Start here if n == 3
    // Execute code block #3
    break;                        // Stop here
  default:                        // If all else fails... 
                                  // Execute code block #4
    break;                        // Stop here
}</pre>
</blockquote>
<p>	As you can see from the example, the various entry points into a
	<tt class="literal">switch</tt> statement are labeled either 
	with the keyword
	<tt class="literal">case</tt>, followed by an integer value and a
	colon, or with the special <tt class="literal">default</tt> keyword,
	followed by a colon. When a <tt class="literal">switch</tt> statement
	executes,
	the interpreter 
	computes the value of the expression in parentheses and then
	looks for a <tt class="literal">case</tt> label that matches that
	value. If it finds one, the interpreter 
	starts executing the block of code
	at the first statement following the <tt class="literal">case</tt>
	label. If it does not find a <tt class="literal">case</tt> label with
	a matching value, the interpreter 
	starts execution at the first statement
	following a special-case <tt class="literal">default:</tt> label. Or,
	if there is no <tt class="literal">default:</tt> label, the interpreter
	skips the
	body of the <tt class="literal">switch</tt> statement altogether. </p>
<p>	Note the use of the <tt class="literal">break</tt> keyword at the end of
	each <tt class="literal">case</tt> in the previous code. The
	<tt class="literal">break</tt> statement is described later in this
	chapter, but, in this case, it causes the interpreter to exit the
	body of the <tt class="literal">switch</tt> 
	statement. The <tt class="literal">case</tt>
	clauses in a <tt class="literal">switch</tt> statement specify
	only the <em class="emphasis">starting point</em> of the desired code. The individual cases are not independent blocks of code, and
	they do not have any implicit ending point. Therefore, you must
	explicitly specify the end of each case with a
	<tt class="literal">break</tt> or related statement. In the absence
	of <tt class="literal">break</tt> 
	statements, a <tt class="literal">switch</tt> statement begins
	executing code at the first statement after 
	the matching <tt class="literal">case</tt> label and continues
	executing statements until it reaches the end of the block. On
	rare occasions, it is useful to write code like this that falls
	through from one <tt class="literal">case</tt> label to the next, but
	99% of the time you should be careful to end every
	<tt class="literal">case</tt> and <tt class="literal">default</tt> section
	with a statement that causes the
	<tt class="literal">switch</tt> statement to stop executing. Normally
	you use a <tt class="literal">break</tt> statement, but
	<tt class="literal">return</tt> and <tt class="literal">throw</tt> also work. </p>
<p>	A <tt class="literal">switch</tt> statement can have more
	than one <tt class="literal">case</tt> clause labeling the same
	statement. Consider the <tt class="literal">switch</tt> statement in
	the following method:
</p>
<blockquote>
<pre class="programlisting">boolean parseYesOrNoResponse(char response) {
  switch(response) {
    case 'y':
    case 'Y': return true;
    case 'n':
    case 'N': return false;
    default: throw new IllegalArgumentException("Response must be Y or N");
  }
}</pre>
</blockquote>
<p>	There are some important restrictions on the
	<tt class="literal">switch</tt> statement and its
	<tt class="literal">case</tt> labels. First, the expression
	associated with a <tt class="literal">switch</tt> statement must have
	a <tt class="literal">byte</tt>, <tt class="literal">char</tt>,
	<tt class="literal">short</tt>, or <tt class="literal">int</tt> value. The
	floating-point and <tt class="literal">boolean</tt> types are not
	supported, and neither is <tt class="literal">long</tt>, even though
	<tt class="literal">long</tt> is an integer type. Second, the value
	associated with each <tt class="literal">case</tt> label must be a
	constant value or a constant expression the compiler can
	evaluate. A <tt class="literal">case</tt> label cannot contain a
	runtime expressions involving variables or method calls, for
	example. Third, the <tt class="literal">case</tt> label values
	must be within the range of the data type used for the
	<tt class="literal">switch</tt> expression. And finally, it is
	obviously not legal to have two or more <tt class="literal">case</tt>
	labels with the same value or more than one
	<tt class="literal">default</tt> label. </p>
<h3 class="sect2">2.6.8. The while Statement</h3>
<p>
<a name="INDEX-332"></a><a name="INDEX-333"></a>

	Just as the <tt class="literal">if</tt> statement is the basic control
	statement that allows Java to make decisions, the
	<tt class="literal">while</tt> statement is the basic statement that
	allows Java to perform repetitive actions. It has the following
	syntax:
      </p>
<blockquote>
<pre class="programlisting">while (<em class="replaceable">expression</em>) 
  <em class="replaceable">statement</em>
</pre>
</blockquote>
<p>	The <tt class="literal">while</tt> statement works by first evaluating
	the <em class="replaceable">expression</em>. If it is
	<tt class="literal">false</tt>, the interpreter skips the
	<em class="replaceable">statement</em> associated with the loop
	and moves to the next statement in the program. If it is
	<tt class="literal">true</tt>, however, the
	<em class="replaceable">statement</em> that forms the body of the
	loop is executed, and the
	<em class="replaceable">expression</em> is reevaluated. Again,
	if the value of <em class="replaceable">expression</em> is
	<tt class="literal">false</tt>, the interpreter moves on to the next
	statement in the program; otherwise it executes the
	<em class="replaceable">statement</em> again. This cycle
	continues while the
	<em class="replaceable">expression</em> remains
	<tt class="literal">true</tt> (i.e., until it evaluates to
	<tt class="literal">false</tt>), at which point the
	<tt class="literal">while</tt> statement ends, and the interpreter
	moves on to the next statement. You can create an
	infinite loop with the syntax <tt class="literal">while(true)</tt>. </p>
<p>	Here is an example <tt class="literal">while</tt> loop that prints the
	numbers 0 to 9:
      </p>
<blockquote>
<pre class="programlisting">int count = 0; 
while (count &lt; 10) {
  System.out.println(count);
  count++;
}</pre>
</blockquote>
<p>	As you can see, the variable <tt class="literal">count</tt> starts off
	at 0 in this example and is incremented each time the body of
	the loop runs. Once the loop has executed 10 times, the
	expression becomes <tt class="literal">false</tt> 
	(i.e., <tt class="literal">count</tt> is no longer less than 10), the
	<tt class="literal">while</tt> statement finishes, and the Java
	interpreter can move to the next statement in the
	program. Most loops have a counter variable like
	<tt class="literal">count</tt>. The variable names
	<tt class="literal">i</tt>, <tt class="literal">j</tt>, and
	<tt class="literal">k</tt> are commonly used as a loop counters,
	although you should use more descriptive names if it makes your
	code easier to understand. </p>
<h3 class="sect2">2.6.9. The do Statement</h3>
<p>
<a name="INDEX-334"></a><a name="INDEX-335"></a>

	A <tt class="literal">do</tt> loop is much like a
	<tt class="literal">while</tt> loop, except that the loop expression
	is tested at the bottom of the loop, rather than at the top. This means that the body of the loop is always executed at least
	once. The syntax is:
</p>
<blockquote>
<pre class="programlisting">do 
  <em class="replaceable">statement</em> 
while ( <em class="replaceable">expression</em> ) ;</pre>
</blockquote>
<p>	There are a couple of differences to notice between the
	<tt class="literal">do</tt> loop and the more ordinary
	<tt class="literal">while</tt> loop. First, the <tt class="literal">do</tt>
	loop requires both the <tt class="literal">do</tt> keyword to mark the
	beginning of the loop and the <tt class="literal">while</tt> keyword
	to mark the end and introduce the loop condition. Also, unlike
	the <tt class="literal">while</tt> loop, the <tt class="literal">do</tt>
	loop is terminated with a semicolon. This is because the
	<tt class="literal">do</tt> loop ends with the loop condition, rather
	than simply ending with a curly brace that marks the end of the
	loop body. The following <tt class="literal">do</tt> loop prints the
	same output as the <tt class="literal">while</tt> loop shown above:
      </p>
<blockquote>
<pre class="programlisting">int count = 0;
do {
  System.out.println(count);
  count++;
} while(count &lt; 10);</pre>
</blockquote>
<p>	Note that the <tt class="literal">do</tt> loop is much less commonly
	used than its <tt class="literal">while</tt> cousin. This is because,
	in practice, it is unusual to encounter a situation where you
	are sure you always want a loop to execute at least once. </p>
<h3 class="sect2">2.6.10. The for Statement</h3>
<p>
<a name="INDEX-336"></a><a name="INDEX-337"></a>

	The <tt class="literal">for</tt> statement provides a looping
	construct that is often more convenient than the
	<tt class="literal">while</tt> and <tt class="literal">do</tt> loops. The
	<tt class="literal">for</tt> statement takes advantage of a common
	looping pattern. Most loops have a counter, or state variable of
	some kind, that is initialized before the loop starts, tested
	to determine whether to execute the loop body, and then
	incremented, or updated somehow, at the end of the loop body
	before the test expression is evaluated again. The initialization, test, and update steps are the three crucial
	manipulations of a loop variable, and the <tt class="literal">for</tt>
	statement makes these three steps an explicit part of the
	loop syntax:

</p>
<blockquote>
<pre class="programlisting">for(<em class="replaceable">initialize</em> ; <em class="replaceable">test</em> ; <em class="replaceable">increment</em>)
    <em class="replaceable">statement</em>
</pre>
</blockquote>
<p>	This <tt class="literal">for</tt> loop is basically
	equivalent to the following <tt class="literal">while</tt> 
	loop:<a href="#FOOTNOTE-2">[2]</a>
</p>
<blockquote class="footnote">
<a name="FOOTNOTE-2"></a>
<p>[2] As you'll see when we consider the
	<tt class="literal">continue</tt> statement, this
	<tt class="literal">while</tt> loop is not exactly equivalent to the
	<tt class="literal">for</tt> loop. We'll discuss how to write the true
	equivalent when we talk about the
	<tt class="literal">try/catch/finally</tt> statement.</p>
</blockquote>
<blockquote>
<pre class="programlisting">
<em class="replaceable">initialize</em>;
while(<em class="replaceable">test</em>) {
  <em class="replaceable">statement</em>;
  <em class="replaceable">increment</em>;
}</pre>
</blockquote>
<p>
	Placing the <em class="replaceable">initialize</em>, <em class="replaceable">test</em>, and <em class="replaceable">increment</em> expressions at the
	top of a <tt class="literal">for</tt> loop makes it especially easy to
	understand what the loop is doing, and it prevents mistakes such as
	forgetting to initialize or increment the loop variable. The interpreter discards the values of the
	<em class="replaceable">initialize</em> and
	<em class="replaceable">increment</em> expressions, so in order to
	be useful, these expressions must have side effects. <em class="replaceable">initialize</em> is typically an assignment
	expression, while <em class="replaceable">increment</em> 
	is usually an increment, decrement, or some other assignment. </p>
<p>	The following <tt class="literal">for</tt> loop prints the numbers 0
	to 9, just as the previous <tt class="literal">while</tt> and
	<tt class="literal">do</tt> loops have done:
      </p>
<blockquote>
<pre class="programlisting">int count;
for(count = 0 ; count &lt; 10 ; count++)
  System.out.println(count);</pre>
</blockquote>
<p>	Notice how this syntax places all the important information about
	the loop variable on a single line, making it very clear how
	the loop executes. Placing the increment
	expression in the <tt class="literal">for</tt> statement itself also
	simplifies the body of the loop to a single statement; 


we
	don't even need to use curly braces to produce a statement block. </p>
<p>	The <tt class="literal">for</tt> loop supports some additional syntax
	that makes it even more convenient to use. Because many loops
	use their loop variables only within the loop, the
	<tt class="literal">for</tt> loop allows the
	<em class="replaceable">initialize</em> expression to be a full
	variable declaration, so that the variable is scoped to the body
	of the loop and is not visible outside of it. For example:
</p>
<blockquote>
<pre class="programlisting">for(int count = 0 ; count &lt; 10 ; count++)
  System.out.println(count);</pre>
</blockquote>
<p>	Furthermore, the <tt class="literal">for</tt> loop syntax does not
	restrict you to writing loops that use only a single variable. Both the <em class="replaceable">initialize</em> and
	<em class="replaceable">increment</em> expressions of a
	<tt class="literal">for</tt> loop can use a comma to separate
	multiple initializations and increment expressions. For example:
</p>
<blockquote>
<pre class="programlisting">for(int i = 0, j = 10 ; i &lt; 10 ; i++, j--)
    sum += i * j;</pre>
</blockquote>
<p>	Even though all the examples so far have counted numbers, 
	<tt class="literal">for</tt> loops are not restricted to loops that
	count numbers. For example, you 
	might use a <tt class="literal">for</tt> loop to
	iterate through the elements of a linked list:
</p>
<blockquote>
<pre class="programlisting">for(Node n = listHead; n != null; n = n.nextNode())
  process(n);</pre>
</blockquote>
<p>	The <em class="replaceable">initialize</em>,
	<em class="replaceable">test</em>, and
	<em class="replaceable">increment</em> expressions of a
	<tt class="literal">for</tt> loop are all optional; 
	only the semicolons that separate the expressions are required. If the <em class="replaceable">test</em> expression is omitted, it
	is assumed to be <tt class="literal">true</tt>. Thus, you can write
	an infinite loop as <tt class="literal">for(;;)</tt>. </p>
<h3 class="sect2">2.6.11. The break Statement</h3>
<p>
<a name="INDEX-338"></a><a name="INDEX-339"></a>

	A <tt class="literal">break</tt> statement causes the Java
	interpreter to skip immediately to the end of a containing
	statement. We have already seen the <tt class="literal">break</tt>
	statement used with the <tt class="literal">switch</tt> statement. The <tt class="literal">break</tt> statement is most often written as
	simply the keyword <tt class="literal">break</tt> followed by a
	semicolon:
</p>
<blockquote>
<pre class="programlisting">break;</pre>
</blockquote>
<p>
	When used in this form, it causes the Java interpreter to
	immediately exit the innermost containing
	<tt class="literal">while</tt>, <tt class="literal">do</tt>, 
	<tt class="literal">for</tt>, or <tt class="literal">switch</tt>
	statement. For example:
</p>
<blockquote>
<pre class="programlisting">for(int i = 0; i &lt; data.length; i++) {  // Loop through the data array. 
  if (data[i] == target) {              // When we find what we're looking for,
    index = i;                          // remember where we found it
    break;                              // and stop looking!
  }
}   // The Java interpreter goes here after executing break</pre>
</blockquote>
<p>	The <tt class="literal">break</tt> statement can also be followed by
	the name of a containing labeled statement. When used in this
	form, <tt class="literal">break</tt> causes the Java interpreter to
	immediately exit from the named block, which can be any kind of
	statement, not just a loop or <tt class="literal">switch</tt>. For example:
</p>
<blockquote>
<pre class="programlisting">testfornull: if (data != null) {             // If the array is defined,
  for(int row = 0; row &lt; numrows; row++) {   // loop through one dimension,
    for(int col = 0; col &lt; numcols; col++) { // then loop through the other. 
      if (data[row][col] == null)            // If the array is missing data,
        break testfornull;                   // treat the array as undefined. 
    }
  }
}  // Java interpreter goes here after executing break testfornull</pre>
</blockquote>
<h3 class="sect2">2.6.12. The continue Statement</h3>
<p>
<a name="INDEX-340"></a><a name="INDEX-341"></a>

	While a <tt class="literal">break</tt> statement exits a loop, a
	<tt class="literal">continue</tt> statement quits the current
	iteration of a loop and starts the next one. <tt class="literal">continue</tt>, in both its unlabeled and labeled
	forms, can be used only within a <tt class="literal">while</tt>,
	<tt class="literal">do</tt>, or <tt class="literal">for</tt> loop. When
	used without a label, <tt class="literal">continue</tt> causes the
	innermost loop to start a new iteration. When used with a
	label that is the name of a containing loop, it causes the named
	loop to start a new iteration. For example:
</p>
<blockquote>
<pre class="programlisting">for(int i = 0; i &lt; data.length; i++) {  // Loop through data. 
  if (data[i] == -1)                    // If a data value is missing,
    continue;                           // skip to the next iteration. 
  process(data[i]);                     // Process the data value. 
}</pre>
</blockquote>
<p>
<tt class="literal">while</tt>, <tt class="literal">do</tt>, and
	<tt class="literal">for</tt> loops differ slightly in the way that 
	<tt class="literal">continue</tt> starts a new iteration:
	</p>
<ul>
<li>
<p>	      With a <tt class="literal">while</tt> loop, the Java
	      interpreter simply returns to the top of the loop, tests
	      the loop condition again, and, if it evaluates to
	      <tt class="literal">true</tt>, executes the body of the loop
	      again. </p>
</li>
<li>
<p>	      With a <tt class="literal">do</tt> loop, the interpreter
	      jumps to the bottom of the loop, where it tests the loop
	      condition to decide whether to perform another
	      iteration of the loop. </p>
</li>
<li>
<p>	      With a <tt class="literal">for</tt> loop, the
	      interpreter jumps to the top of the loop, where it first
	      evaluates the <em class="replaceable">increment</em>
	      expression and then evaluates the
	      <em class="replaceable">test</em> expression to
	      decide whether to loop again. As you can see, the
	      behavior of a <tt class="literal">for</tt> loop with a
	      <tt class="literal">continue</tt> statement is
	      different from the behavior of the "basically equivalent" 
	      <tt class="literal">while</tt> loop I presented 
	      earlier; <em class="replaceable">increment</em>
	      gets evaluated in the <tt class="literal">for</tt> loop,
	      but not in the equivalent <tt class="literal">while</tt> loop. </p>
</li>
</ul>
<h3 class="sect2">2.6.13. The return Statement</h3>
<p>
<a name="INDEX-342"></a><a name="INDEX-343"></a>

	A <tt class="literal">return</tt> statement tells the Java
	interpreter to stop executing the current method. If the method
	is declared to return a value, the
	<tt class="literal">return</tt> statement is followed by an
	expression. The value of the expression becomes the return
	value of the method. For example, the following method
	computes and returns the square of a number:
</p>
<blockquote>
<pre class="programlisting">double square(double x) {      // A method to compute x squared
  return x * x;                // Compute and return a value
}</pre>
</blockquote>
<p>	Some methods are declared <tt class="literal">void</tt> to indicate
	they do not return any value. The Java interpreter runs
	methods like this by executing its statements one by one until
	it reaches the end of the method. After executing the last
	statement, the interpreter returns implicitly. Sometimes,
	however, a <tt class="literal">void</tt> method has to return
	explicitly before reaching the last statement. In this case, it
	can use the <tt class="literal">return</tt> statement by itself,
	without any expression. For example, the following method
	prints, but does not return, the square root of its argument. If the argument is a negative number, it returns without
	printing anything:
</p>
<blockquote>
<pre class="programlisting">void printSquareRoot(double x) {     // A method to print square root of x
  if (x &lt; 0) return;                 // If x is negative, return explicitly
  System.out.println(Math.sqrt(x));  // Print the square root of x
}                                    // End of method: return implicitly</pre>
</blockquote>
<h3 class="sect2">2.6.14. The synchronized Statement</h3>
<p>
<a name="INDEX-344"></a><a name="INDEX-345"></a>

	Since Java is a multithreaded system, you must often take care
	to prevent multiple threads from modifying an object
	simultaneously in a way that might corrupt the object's state. Sections of code that must not be executed
	simultaneously are known as <em class="emphasis">critical
	sections</em>. Java provides 
	the <tt class="literal">synchronized</tt> statement to protect these
	critical sections. The syntax is:
      </p>
<blockquote>
<pre class="programlisting">synchronized ( <em class="replaceable">expression</em> ) {
  <em class="replaceable">statements</em>
}</pre>
</blockquote>
<p>
<em class="replaceable">expression</em> is an expression that must
	evaluate to an object or an array. The
	<em class="replaceable">statements</em> constitute the code of the
	critical section and must be enclosed in curly braces. Before
	executing the critical section, the Java interpreter first
	obtains an exclusive lock on the object or array specified by
	<em class="replaceable">expression</em>. It holds the lock until
	it is finished running the critical section, then releases
	it. While a thread holds the lock on an object, no other thread
	can obtain that lock. Therefore, no other thread can execute
	this or any other critical sections that require a lock on the
	same object. If a
	thread cannot immediately obtain the lock required to execute a
	critical section, it simply waits until the lock becomes
	available. </p>
<p>	Note that you do not have to use the
	<tt class="literal">synchronized</tt> statement unless your program
	creates multiple threads that share data. If only one thread
	ever accesses a data structure, there is no need to protect it
	with <tt class="literal">synchronized</tt>. When you do have to use
	<tt class="literal">synchronized</tt>, 
	it might be in code like the following:
      </p>
<blockquote>
<pre class="programlisting">public static void SortIntArray(int[] a) {
  // Sort the array a. This is synchronized so that some other thread
  // cannot change elements of the array while we're sorting it (at
  // least not other threads that protect their changes to the array
  // with synchronized). 
  synchronized (a) {
    // Do the array sort here... 
  }
}</pre>
</blockquote>
<p>	The <tt class="literal">synchronized</tt> keyword is also available as
	a modifier in Java and is more commonly used in this form than 
	as a statement. When applied to a
	method, the <tt class="literal">synchronized</tt> keyword 
	indicates that the entire method is a critical
	section. For a <tt class="literal">synchronized</tt> class method (a
	static method), Java obtains an exclusive lock on the class
	before executing the method. For a
	<tt class="literal">synchronized</tt> instance method, Java obtains an
	exclusive lock 


on the class instance. (Class and
	instance methods are discussed in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_01.htm">Chapter 3, "Object-Oriented Programming in Java"</a>.)
      </p>
<h3 class="sect2">2.6.15. The throw Statement</h3>
<p>
<a name="INDEX-346"></a><a name="INDEX-347"></a><a name="INDEX-348"></a>

	An <em class="emphasis">exception</em> is a signal that indicates
	some sort of exceptional condition or error has occurred. To <em class="emphasis">throw</em> an exception is to signal an
	exceptional condition. To <em class="emphasis">catch</em> an
	exception is to handle it--to take whatever actions are
	necessary to recover from it. </p>
<p>	In Java, the <tt class="literal">throw</tt> statement is used to throw
	an exception:
</p>
<blockquote>
<pre class="programlisting">throw <em class="replaceable">expression</em> ;</pre>
</blockquote>
<p>
	The <em class="replaceable">expression</em> must evaluate to an
	exception object that describes the exception or error that has
	occurred. We'll talk more about types of exceptions shortly; for
	now, all you need to know is that an exception is represented by
	an object. Here is some example code that throws an exception:
</p>
<blockquote>
<pre class="programlisting">public static double factorial(int x) {
  if (x &lt; 0) 
    throw new IllegalArgumentException("x must be &gt;= 0"));
  double fact;
  for(fact=1.0; x &gt; 1; fact *= x, x--) 
    /* empty */ ;          // Note use of the empty statement
  return fact;
}                                      </pre>
</blockquote>
<p>	When the Java interpreter executes a <tt class="literal">throw</tt>
	statement, it immediately stops normal program execution and
	starts looking for an exception handler that can catch, or
	handle, the exception. Exception handlers are written with the
	<tt class="literal">try/catch/finally</tt> statement, which is
	described in the next section. The Java interpreter first looks at the
	enclosing block of code to see if it has an associated exception
	handler. If so, it exits that block of code and starts running
	the exception-handling code associated with the block. After
	running the exception handler, the interpreter continues
	execution at the statement immediately following the handler
	code. </p>
<p>	If the enclosing block of code does not have an appropriate
	exception handler, the interpreter checks the next higher
	enclosing block of code in the method. This continues until a handler is
	found. If the method does not contain an exception handler
	that can handle the exception thrown by the
	<tt class="literal">throw</tt> statement, the interpreter stops
	running the current method and returns to the caller. Now the
	interpreter
	starts looking for an exception handler in the blocks of code of
	the calling method. In this way, exceptions propagate up through
	the lexical structure of Java methods, up the call stack of
	the Java interpreter. If the exception is never caught, it
	propagates all the way up to the <tt class="literal">main()</tt>
	method of the program. If it is not handled in that method,
	the Java interpreter prints an error message, prints a stack
	trace to indicate where the exception occurred, and then exits. </p>
<h3 class="sect3">2.6.15.1. Exception types</h3>
<p>	  An exception in Java is an object. The type of this object is
	  <tt class="literal">java.langThrowable</tt>, or more commonly, 
	  some subclass
	  of <tt class="literal">Throwable</tt> that more specifically
	  describes the type of exception that
	  occurred.<a href="#FOOTNOTE-3">[3]</a><tt class="literal">Throwable</tt> has two standard subclasses:
	  <tt class="literal">java.lang.Error</tt> and
	  <tt class="literal">java.lang.Exception</tt>. Exceptions that are
	  subclasses of <tt class="literal">Error</tt> generally indicate
	  unrecoverable problems: the virtual machine has run out of memory,
	  or a class file is corrupted and cannot be read, for example. Exceptions of this sort can be caught and handled, but it is
	  rare to do so. Exceptions that are subclasses of
	  <tt class="literal">Exception</tt>, on the other hand, indicate less
	  severe conditions. These are exceptions that can be
	  reasonably caught and handled. They include such exceptions
	  as <tt class="literal">java.io.EOFException</tt>, which signals the
	  end of a file, and
	  <tt class="literal">java.lang.ArrayIndexOutOfBoundsException</tt>,
	  which indicates that a program has tried to read past the end
	  of an array. In this book, I use the term "exception" to refer
	  to any exception object, regardless of whether the type of
	  that exception is <tt class="literal">Exception</tt> or
	  <tt class="literal">Error</tt>. </p>
<blockquote class="footnote">
<a name="FOOTNOTE-3"></a>
<p>[3]We haven't talked about subclasses
	  yet; they are covered in detail in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_01.htm">Chapter 3, "Object-Oriented Programming in Java"</a>.</p>
</blockquote>

<p>	  Since an exception is an object, it can contain data, and its
	  class can define methods that operate on that data. The
	  <tt class="literal">Throwable</tt> class and all its subclasses
	  include a <tt class="literal">String</tt> field that stores a
	  human-readable error message that describes the exceptional
	  condition. It's set when the exception object is created
	  and can be read from the exception with the
	  <tt class="literal">getMessage()</tt> method. Most exceptions
	  contain only this single message, but a few add other data. The <tt class="literal">java.io.InterruptedIOException</tt>, for
	  example, adds a field named
	  <tt class="literal">bytesTransferred</tt> that specifies how much 
	  input or output was completed before the exceptional condition
	  interrupted it.</p>
<h3 class="sect3">2.6.15.2. Declaring exceptions</h3>
<p>	  In addition to making a distinction between
	  <tt class="literal">Error</tt> and <tt class="literal">Exception</tt>
	  classes, the Java exception-handling scheme also makes a
	  distinction between checked and unchecked exceptions. Any
	  exception object that is an <tt class="literal">Error</tt> is
	  unchecked. Any exception object that is an
	  <tt class="literal">Exception</tt> is checked, unless it is a
	  subclass of <tt class="literal">java.lang.RuntimeException</tt>, 
	  in which case
	  it is unchecked. (<tt class="literal">RuntimeException</tt> is a
	  subclass of <tt class="literal">Exception</tt>.)  The reason for
	  this distinction is that virtually any method can throw an
	  unchecked exception, at essentially any time. There is no way
	  to predict an <tt class="literal">OutOfMemoryError</tt>, for
	  example, and any method that uses objects or arrays can throw
	  a <tt class="literal">NullPointerException</tt> if it is passed an
	  invalid <tt class="literal">null</tt> argument. Checked exceptions, on the other hand, arise only in specific,
	  well-defined circumstances. If you try to read data from a
	  file, for example, you must at least consider the possibility
	  that a <tt class="literal">FileNotFoundException</tt> will be thrown
	  if the specified file cannot be found. </p>
<p>	  Java has different rules for working with checked and
	  unchecked exceptions. If you write a method that throws a
	  checked exception, you must use a <tt class="literal">throws</tt>
	  clause to declare the exception in the method signature. The
	  reason these types of exceptions are called checked
	  exceptions is that the Java compiler checks to make sure you have
	  declared them in method signatures and produces a
	  compilation error if you have not. The
	  <tt class="literal">factorial()</tt> method shown earlier throws an
	  exception of type
	  <tt class="literal">java.lang.IllegalArgumentException</tt>. This is a
	  subclass of <tt class="literal">RuntimeException</tt>, so it is an
	  unchecked exception, and we do not have to declare it with a
	  <tt class="literal">throws</tt> clause (although we can if we
	  want to be explicit). </p>
<p>	  Even if you never <tt class="literal">throw</tt> an exception
	  yourself, there are times when you must use a
	  <tt class="literal">throws</tt> clause to declare an exception. If
	  your method calls a method that can throw a checked exception,
	  you must either include exception-handling code to handle
	  that exception or use <tt class="literal">throws</tt> to
	  declare that your method can also throw that exception. </p>
<p>	  How do you know if the method you are calling can throw a checked
	  exception?  You can look at its method signature to find
	  out. Or, failing that, the Java compiler will tell you 
	  (by reporting a compilation error) if
	  you've called a method whose exceptions you must handle or
	  declare. The following method reads the first line of text
	  from a named file. It uses methods that can throw various
	  types of <tt class="literal">java.io.IOException</tt> objects, so it
	  declares this fact with a <tt class="literal">throws</tt> clause:
</p>
<blockquote>
<pre class="programlisting">public static String readFirstLine(String filename) throws IOException {
  BufferedReader in = new BufferedReader(new FileReader(filename));
  return in.readLine();
}</pre>
</blockquote>
<p>
	  We'll talk more about method declarations and method signatures
	  later in this chapter.
<a name="INDEX-349"></a>
</p>
<h3 class="sect2">2.6.16. The try/catch/finally Statement</h3>
<p>
<a name="INDEX-350"></a><a name="INDEX-351"></a>

	The <tt class="literal">try/catch/finally</tt> statement is Java's
	exception-handling mechanism. The <tt class="literal">try</tt>
	clause of this statement establishes a block of code for exception handling. This <tt class="literal">try</tt> block
	is followed by zero or more <tt class="literal">catch</tt> clauses,
	each of which is a block of statements designed to handle a
	specific type of exception. The <tt class="literal">catch</tt>
	clauses are followed by an optional <tt class="literal">finally</tt>
	block that contains cleanup code guaranteed to be
	executed regardless of what happens in the
	<tt class="literal">try</tt> block. Both the
	<tt class="literal">catch</tt> and <tt class="literal">finally</tt> clauses
	are optional, but every <tt class="literal">try</tt> block must be
	accompanied by at
	least one or the other. The <tt class="literal">try</tt>,
	<tt class="literal">catch</tt>, and <tt class="literal">finally</tt> blocks
	all begin and end with curly braces. These are a required part of
	the syntax and cannot be omitted, even if the clause contains
	only a single statement. </p>
<p>	The following code illustrates the syntax and purpose of the
	<tt class="literal">try/catch/finally</tt> statement:
</p>
<blockquote>
<pre class="programlisting">try {
  // Normally this code runs from the top of the block to the bottom 
  // without problems. But it can sometimes throw an exception,
  // either directly with a throw statement or indirectly by calling
  // a method that throws an exception. 
}
catch (SomeException e1) {
  // This block contains statements that handle an exception object
  // of type SomeException or a subclass of that type. Statements in
  // this block can refer to that exception object by the name e1. 
}
catch (AnotherException e2) {
  // This block contains statements that handle an exception object
  // of type AnotherException or a subclass of that type. Statements
  // in this block can refer to that exception object by the name e2. 
}


finally {
  // This block contains statements that are always executed 
  // after we leave the try clause, regardless of whether we leave it:
  //   1) normally, after reaching the bottom of the block;
  //   2) because of a break, continue, or return statement;
  //   3) with an exception that is handled by a catch clause above; or
  //   4) with an uncaught exception that has not been handled. 
  // If the try clause calls System.exit(), however, the interpreter
  // exits before the finally clause can be run. 
}</pre>
</blockquote>
<h3 class="sect3">2.6.16.1. try</h3>
<p>
<a name="INDEX-352"></a>

	  The <tt class="literal">try</tt> clause simply establishes a block
	  of code that either has its exceptions handled or needs
	  special cleanup code to be run when it terminates for any
	  reason. The <tt class="literal">try</tt> clause by itself doesn't
	  do anything interesting; it is the <tt class="literal">catch</tt>
	  and <tt class="literal">finally</tt> clauses that do the exception-handling and cleanup operations. </p>
<h3 class="sect3">2.6.16.2. catch</h3>
<p>
<a name="INDEX-353"></a>

	  A <tt class="literal">try</tt> block can be followed by zero or more
	  <tt class="literal">catch</tt> clauses that specify code to handle
	  various types of exceptions. Each <tt class="literal">catch</tt>
	  clause is declared with a single argument that specifies the
	  type of exceptions the clause can handle and also provides a
	  name the clause can use to refer to the exception object
	  it is currently handling. The type and name of an exception
	  handled by a <tt class="literal">catch</tt> clause are exactly like
	  the type and name of an argument passed to a method, except
	  that for a <tt class="literal">catch</tt> clause, the argument type
	  must be <tt class="literal">Throwable</tt> or one of its subclasses. </p>
<p>	  When an exception is thrown, the Java interpreter looks for a
	  <tt class="literal">catch</tt> clause with an argument of the same
	  type as the exception object or a
	  superclass of that type. The interpreter invokes the first such
	  <tt class="literal">catch</tt> clause it finds. The code within a
	  <tt class="literal">catch</tt> block should take whatever action is
	  necessary to cope with the exceptional condition. If the
	  exception is a
	  <tt class="literal">java.io.FileNotFoundException</tt> exception,
	  for example, you might handle it by asking the user to check
	  his spelling and try again. It is not
	  required to have a <tt class="literal">catch</tt> clause for every
	  possible exception; in some cases the correct response is
	  to allow the exception to propagate up and be caught by the
	  invoking method. In other cases, such as a programming error
	  signaled by <tt class="literal">NullPointerException</tt>, the
	  correct response is probably not to 
	  catch the exception at all, but 
	  allow it to propagate and have the Java interpreter exit
	  with a stack trace and an error message. </p>
<h3 class="sect3">2.6.16.3. finally</h3>
<p>
<a name="INDEX-354"></a>

	  The <tt class="literal">finally</tt> clause is generally used to
	  clean up after the code in the <tt class="literal">try</tt> 
	  clause (e.g., close files, shut down network connections). What is
	  useful about the <tt class="literal">finally</tt> clause is that it
	  is guaranteed to be
	  executed if any portion of the <tt class="literal">try</tt> block is
	  executed, regardless of how the code in the
	  <tt class="literal">try</tt> block completes. In fact, the only way
	  a <tt class="literal">try</tt> clause can exit without allowing
	  the <tt class="literal">finally</tt> clause to be executed is by
	  invoking the <tt class="literal">System.exit()</tt> method, which
	  causes the Java interpreter to stop running. </p>
<p>	  In the normal case, control reaches the end of the
	  <tt class="literal">try</tt> block and then proceeds to the
	  <tt class="literal">finally</tt> block, which performs any necessary
	  cleanup. If control leaves the <tt class="literal">try</tt> block
	  because of a <tt class="literal">return</tt>,
	  <tt class="literal">continue</tt>, or <tt class="literal">break</tt>
	  statement, the <tt class="literal">finally</tt>
	  block is executed before control transfers to its new
	  destination. </p>
<p>	  If an exception occurs in the <tt class="literal">try</tt> block, and
	  there is an associated <tt class="literal">catch</tt> block to
	  handle the exception, control transfers first to the
	  <tt class="literal">catch</tt> block and then to the
	  <tt class="literal">finally</tt> block. If there is no local
	  <tt class="literal">catch</tt> block to handle the exception,
	  control transfers first to the <tt class="literal">finally</tt>
	  block, and then propagates up to the nearest containing
	  <tt class="literal">catch</tt> clause that can handle the exception. </p>
<p>	  If a <tt class="literal">finally</tt> block itself
	  transfers control with a <tt class="literal">return</tt>,
	  <tt class="literal">continue</tt>, <tt class="literal">break</tt>, or
	  <tt class="literal">throw</tt> statement or by calling a method
	  that throws an exception, the pending control transfer is
	  abandoned, and this new transfer is processed. For example,
	  if a <tt class="literal">finally</tt> clause throws an exception,
	  that exception replaces any exception that was in the
	  process of being thrown. If a <tt class="literal">finally</tt>
	  clause issues a <tt class="literal">return</tt> statement, the
	  method returns normally, even if an exception has been
	  thrown and has not been handled yet. </p>
<p>
<tt class="literal">try</tt> and
	  <tt class="literal">finally</tt> can be used together without
	  exceptions or any <tt class="literal">catch</tt> clauses. In this
	  case, the <tt class="literal">finally</tt> block is simply cleanup
	  code that is guaranteed to be executed, regardless of any
	  <tt class="literal">break</tt>, <tt class="literal">continue</tt>, or
	  <tt class="literal">return</tt> statements within the
	  <tt class="literal">try</tt> clause. </p>
<p>
<a name="INDEX-355"></a>

	  In previous discussions of the <tt class="literal">for</tt> and
	  <tt class="literal">continue</tt> statements, we've seen that a
	  <tt class="literal">for</tt> loop cannot be naively translated into
	  a <tt class="literal">while</tt> loop because the
	  <tt class="literal">continue</tt> statement behaves slightly
	  differently when used in a <tt class="literal">for</tt> loop than it
	  does when used in a <tt class="literal">while</tt> loop. The
	  <tt class="literal">finally</tt> clause gives us a way to write a
	  <tt class="literal">while</tt> loop that is truly equivalent to a
	  <tt class="literal">for</tt> loop. Consider the following
	  generalized <tt class="literal">for</tt> loop:
</p>
<blockquote>
<pre class="programlisting">for( <em class="replaceable">initialize</em> ; <em class="replaceable">test</em> ; <em class="replaceable">increment</em> )
    <em class="replaceable">statement</em>
</pre>
</blockquote>
<p>
</p>
<p>	  The following <tt class="literal">while</tt> loop behaves the same,
	  even if the <tt class="literal">statement</tt> block contains a
	  <tt class="literal">continue</tt> statement:
</p>
<blockquote>
<pre class="programlisting">
<em class="replaceable">initialize</em> ;
while ( <em class="replaceable">test</em> ) {
  try { <em class="replaceable">statement</em> }
  finally { <em class="replaceable">increment</em> ; }
}</pre>
</blockquote>
<p>
</p>

<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch02_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_05.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch02_07.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_07.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">2.5. Expressions and Operators</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">2.7. Methods</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
