<html>
<head>
<title>Expressions and Operators (Java in a Nutshell)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David Flanagan">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-487-8E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Expressions and Operators">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm" alt="Java Enterprise in a Nutshell"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch02_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_04.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2: Java Syntax

from the Ground Up</a></td><td align="right" valign="top" width="172"><a href="ch02_06.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_06.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY --><h2 class="sect1">2.5. Expressions and Operators</h2>
<p>
<a name="INDEX-207"></a><a name="INDEX-208"></a><a name="INDEX-209"></a><a name="INDEX-210"></a>

      So far in this chapter, we've learned about the primitive types
      that Java programs can manipulate and seen how to include
      primitive values as <em class="emphasis">literals</em> in a Java
      program. We've also used <em class="emphasis">variables</em> as
      symbolic names that represent, or hold, values. These literals
      and variables are the tokens out of which
      Java programs are built. </p>
<p>
<a name="INDEX-211"></a>

      An <em class="emphasis">expression</em> is the next higher level of
      structure in a Java program. The Java interpreter
      <em class="emphasis">evaluates</em> an expression to compute its
      value. The very simplest expressions are called <em class="emphasis">primary
      expressions</em> and consist of 
      literals and variables. So, for example, the
      following are all expressions:
</p>
<blockquote>
<pre class="programlisting">1.7         // An integer literal
true        // A boolean literal
sum         // A variable</pre>
</blockquote>
<p>
      When the Java interpreter evaluates a literal expression, the
      resulting value is the literal itself. When the interpreter
      evaluates a variable expression, the resulting 
      value is the value stored in
      the variable. </p>
<p>      Primary expressions are not very interesting. More complex
      expressions are made by using
      <em class="emphasis">operators</em> to combine primary
      expressions. For example, the following expression uses
      the assignment operator to combine two primary expressions--a
      variable and a floating-point literal--into an assignment
      expression:
</p>
<blockquote>
<pre class="programlisting">sum = 1.7</pre>
</blockquote>
<p>
      But operators are used not only with primary
      expressions; they can also be used with expressions at any level
      of complexity. Thus, the following are all legal expressions:
</p>
<blockquote>
<pre class="programlisting">sum = 1 + 2 + 3*1.2 + (4 + 8)/3.0
sum/Math.sqrt(3.0 * 1.234)
(int)(sum + 33)</pre>
</blockquote>
<h3 class="sect2">2.5.1. Operator Summary</h3>
<p>
<a name="INDEX-212"></a><a name="INDEX-213"></a>

	The kinds of expressions you can write in a programming language
	depend entirely on the set of operators available to
	you. <a href="#javanut3-ch-2-tab-5">Table 2-5</a> summarizes the
	operators available in Java. The P and A
	columns of the table specify the precedence and associativity of
	each group of related operators, respectively. </p>
<a name="javanut3-ch-2-tab-5"></a>
<h4 class="objtitle">Table 2-5. Java Operators</h4>
<table border="1">
<tr>
<th>P</th><th>A</th><th>Operator</th><th>Operand Type(s)</th><th>Operation Performed</th>
</tr>
<tr>
<td>15</td><td>L</td><td><tt class="literal">.</tt></td><td>object, member</td><td>object member access</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">[]</tt></td><td>array, int</td><td>array element access</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">(</tt> <em class="replaceable">args</em> <tt class="literal">)</tt></td><td>method, arglist</td><td>method invocation</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">++</tt>, <tt class="literal">&minus; &minus;</tt></td><td>variable</td><td>post-increment, decrement</td>
</tr>
<tr>
<td>14</td><td>R</td><td><tt class="literal">++</tt>, <tt class="literal">&minus; &minus;</tt></td><td>variable</td><td>pre-increment, decrement</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">+</tt>, <tt class="literal">&minus;</tt></td><td>number</td><td>unary plus, unary minus</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">~</tt></td><td>integer</td><td>bitwise complement</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">!</tt></td><td>boolean</td><td>boolean NOT</td>
</tr>
<tr>
<td>13</td><td>R</td><td><tt class="literal">new</tt></td><td>class, arglist</td><td>object creation</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">(</tt> <em class="replaceable">type</em> <tt class="literal">)</tt></td><td>type, any</td><td>cast (type conversion)</td>
</tr>
<tr>
<td>12</td><td>L</td><td><tt class="literal">*</tt>, <tt class="literal">/</tt>, <tt class="literal">%</tt></td><td>number, number</td><td>
<p>multiplication, division, remainder</p>
</td>
</tr>
<tr>
<td>11</td><td>L</td><td><tt class="literal">+</tt>, <tt class="literal">&minus;</tt></td><td>number, number</td><td>
<p>addition, subtraction</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">+</tt></td><td>string, any</td><td>
<p>string concatenation</p>
</td>
</tr>
<tr>
<td>10</td><td>L</td><td><tt class="literal">&lt;&lt;</tt></td><td>integer, integer</td><td>
<p>left shift</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">&gt;&gt;</tt></td><td>integer, integer</td><td>
<p>right shift with sign extension</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">&gt;&gt;&gt;</tt></td><td>integer, integer</td><td>
<p>right shift with zero extension</p>
</td>
</tr>
<tr>
<td>9</td><td>L</td><td><tt class="literal">&lt;</tt>, <tt class="literal">&lt;=</tt></td><td>number, number</td><td>
<p>less than, less than or equal</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">&gt;</tt>, <tt class="literal">&gt;=</tt></td><td>number, number</td><td>
<p>greater than, greater than or equal</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">instanceof</tt></td><td>reference, type</td><td>
<p>type comparison</p>
</td>
</tr>
<tr>
<td>8</td><td>L</td><td><tt class="literal">= =</tt></td><td>primitive, primitive</td><td>
<p>equal (have identical values)</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">!=</tt></td><td>primitive, primitive</td><td>
<p>not equal (have different values)</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">= =</tt></td><td>reference, reference</td><td>
<p>equal (refer to same object)</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">!=</tt></td><td>reference, reference</td><td>
<p>not equal (refer to different objects)</p>
</td>
</tr>
<tr>
<td>7</td><td>L</td><td><tt class="literal">&amp;</tt></td><td>integer, integer</td><td>
<p>bitwise AND</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">&amp;</tt></td><td>boolean, boolean</td><td>
<p>boolean AND</p>
</td>
</tr>
<tr>
<td>6</td><td>L</td><td><tt class="literal">^</tt></td><td>integer, integer</td><td>
<p>bitwise XOR</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">^</tt></td><td>boolean, boolean</td><td>
<p>boolean XOR</p>
</td>
</tr>
<tr>
<td>5</td><td>L</td><td><tt class="literal">|</tt></td><td>integer, integer</td><td>
<p>bitwise OR</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">|</tt></td><td>boolean, boolean</td><td>
<p>boolean OR</p>
</td>
</tr>
<tr>
<td>4</td><td>L</td><td><tt class="literal">&amp;&amp;</tt></td><td>boolean, boolean</td><td>
<p>conditional AND</p>
</td>
</tr>
<tr>
<td>3</td><td>L</td><td><tt class="literal">||</tt></td><td>boolean, boolean</td><td>
<p>conditional OR</p>
</td>
</tr>
<tr>
<td>2</td><td>R</td><td><tt class="literal">?:</tt></td><td>boolean, any, any</td><td>
<p>conditional (ternary) operator</p>
</td>
</tr>
<tr>
<td>1</td><td>R</td><td><tt class="literal">=</tt></td><td>variable, any</td><td>
<p>assignment</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">*=</tt>, <tt class="literal">/=</tt>, <tt class="literal">%=</tt>, </td><td>variable, any</td><td>
<p>assignment with operation</p>
</td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">+=</tt>, <tt class="literal">&minus;=</tt>, <tt class="literal">&lt;&lt;=</tt>, </td><td></td><td></td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">&gt;&gt;=</tt>, <tt class="literal">&gt;&gt;&gt;=</tt>,</td><td></td><td></td>
</tr>
<tr>
<td></td><td></td><td><tt class="literal">&amp;=</tt>, <tt class="literal">^=</tt>, <tt class="literal">|=</tt></td><td></td><td></td>
</tr>
</table>
<h3 class="sect3">2.5.1.1. Precedence</h3>
<p>
<a name="INDEX-214"></a>

	  The P column of 
	  <a href="#javanut3-ch-2-tab-5">Table 2-5</a> specifies the
	  <em class="emphasis">precedence</em> of each operator. Precedence
	  specifies the order in which operations are performed. Consider this expression:
</p>
<blockquote>
<pre class="programlisting">a + b * c      </pre>
</blockquote>
<p>
	  The multiplication operator has higher precedence than the
	  addition operator, so <tt class="literal">a</tt> is added to the
	  product of <tt class="literal">b</tt> and <tt class="literal">c</tt>. Operator precedence can be thought of as a measure of how
	  tightly operators bind to their operands. The higher the
	  number, the more tightly they bind. </p>
<p>	  Default operator precedence can be overridden through the
	  use of parentheses, to explicitly specify the order of
	  operations. The previous expression can be rewritten as follows
	  to specify that the addition should be performed before the
	  multiplication: 
</p>
<blockquote>
<pre class="programlisting">(a + b) * c</pre>
</blockquote>
<p>
	  The default operator precedence in Java was chosen for
	  compatibility with C; the designers of C chose this precedence
	  so that most expressions can be written naturally without
	  parentheses. There are only a few common Java idioms for which
	  parentheses are required. Examples include:
</p>
<blockquote>
<pre class="programlisting">// Class cast combined with member access
((Integer) o).intValue();

// Assignment combined with comparison
while((line = in.readLine()) != null) { ... }

// Bitwise operators combined with comparison
if ((flags &amp; (PUBLIC | PROTECTED)) != 0) { ... }</pre>
</blockquote>
<p>
</p>
<h3 class="sect3">2.5.1.2. Associativity</h3>
<p>
<a name="INDEX-215"></a><a name="INDEX-216"></a><a name="INDEX-217"></a>

	  When an expression involves several operators that have the
	  same precedence, the operator associativity governs the order
	  in which the operations are performed. Most operators are
	  left-to-right associative, which means that the operations 
	  are performed from left to right. The assignment and unary operators, however,
	  have right-to-left associativity. The A column of <a href="#javanut3-ch-2-tab-5">Table 2-5</a> specifies the associativity of
	  each operator or group of operators. The value L means
	  left to right, and R means right to left. </p>
<p>	  The additive operators are all left-to-right associative, so
	  the expression <tt class="literal">a+b-c</tt> is evaluated from
	  left to right: <tt class="literal">(a+b)-c</tt>. Unary operators
	  and assignment operators are evaluated from right to left. Consider this complex expression:
</p>
<blockquote>
<pre class="programlisting">a = b += c = -~d</pre>
</blockquote>
<p>
	  This is evaluated as follows:
</p>
<blockquote>
<pre class="programlisting">a = (b += (c = -(~d)))</pre>
</blockquote>
<p>
</p>
<p>	  As with operator precedence, operator associativity
	  establishes a default order of evaluation for an expression. This default order can be overridden through the use of
	  parentheses. However, the default operator associativity 
	  in Java has been chosen to yield a natural expression syntax, 
	  and you rarely need to alter it. </p>
<h3 class="sect3">2.5.1.3. Operand number and type</h3>
<p>
<a name="INDEX-218"></a>

	  The fourth column of <a href="#javanut3-ch-2-tab-5">Table 2-5</a>
	  specifies the number and type of the operands expected by each
	  operator. Some operators operate on only one operand; these
	  are called unary operators. For example, the unary minus
	  operator changes the sign of a single number:
</p>
<blockquote>
<pre class="programlisting">-n             // The unary minus operator</pre>
</blockquote>
<p>
	  Most operators, however, are binary operators that operate on
	  two operand values. The <tt class="literal">&minus;</tt> operator
	  actually comes in both forms:
</p>
<blockquote>
<pre class="programlisting">a - b          // The subtraction operator is a binary operator</pre>
</blockquote>
<p>
</p>
<p>	  Java also defines one ternary operator, often called the
	  conditional operator. It is like an
	  <tt class="literal">if</tt> statement inside an expression. Its three operands are separated by a question mark and a colon; 
	  the second and third operators must both be of the same type:
</p>
<blockquote>
<pre class="programlisting">x &gt; y ? x : y  // Ternary expression; evaluates to the larger of x and y</pre>
</blockquote>
<p>
</p>
<p>	  In addition to expecting a certain number of operands, each
	  operator also expects particular types of operands. Column
	  four of the table lists the operand types. Some of the codes
	  used in that column require further explanation:
	  </p>
<dl>
<dt>
<b>number</b>
</dt>
<dd>
<p>		  An integer, floating-point value, or character 
		  (i.e., any primitive type except <tt class="literal">boolean</tt>) 
		</p>
</dd>
<dt>
<b>integer</b>
</dt>
<dd>
<p>		  A <tt class="literal">byte</tt>, <tt class="literal">short</tt>,
		  <tt class="literal">int</tt>, <tt class="literal">long</tt>, or
		  <tt class="literal">char</tt> value (<tt class="literal">long</tt> 
		  values are not allowed for
		  the array access operator <tt class="literal">[]</tt>)
		</p>
</dd>
<dt>
<b>reference</b>
</dt>
<dd>
<p>		  An object or array
		</p>
</dd>
<dt>
<b>variable</b>
</dt>
<dd>
<p>		  A variable or anything else, such as an array element,
		  to which a value can be assigned
		</p>
</dd>
</dl>
<p>
</p>
<h3 class="sect3">2.5.1.4. Return type</h3>
<p>
<a name="INDEX-219"></a>

	  Just as every operator expects its operands to be of specific
	  types, each operator produces a value of a specific type. The
	  arithmetic, increment and decrement, bitwise, and shift
	  operators return a <tt class="literal">double</tt> if at least one
	  of the operands is a <tt class="literal">double</tt>. Otherwise,
	  they return a <tt class="literal">float</tt> if at least one of the
	  operands is a <tt class="literal">float</tt>. Otherwise, they return a
	  <tt class="literal">long</tt> if at least one of the operands is a
	  <tt class="literal">long</tt>. Otherwise, they return an
	  <tt class="literal">int</tt>, even if both operands are
	  <tt class="literal">byte</tt>, <tt class="literal">short</tt>, or
	  <tt class="literal">char</tt> types that are narrower than
	  <tt class="literal">int</tt>. </p>
<p>	  The comparison, equality, and boolean operators always return
	  <tt class="literal">boolean</tt> values. Each assignment operator
	  returns whatever value it assigned, which is of a type
	  compatible with the variable on the left side of the
	  expression. The
	  conditional operator returns the value of its second
	  or third argument (which must both be of the same type). </p>
<h3 class="sect3">2.5.1.5. Side effects</h3>
<p>
<a name="INDEX-220"></a><a name="INDEX-221"></a><a name="INDEX-222"></a>


	  Every operator computes a value based on one or
	  more operand values. Some operators, however, have
	  <em class="emphasis">side effects</em> in addition to their basic
	  evaluation. If an expression contains side effects, 
	  evaluating it changes the state of a Java program in such a way
	  that evaluating the expression again may yield a different
	  result. For example, the <tt class="literal">++</tt> increment
	  operator has the side effect of incrementing a variable. The
	  expression <tt class="literal">++a</tt> increments the variable
	  <tt class="literal">a</tt> and returns the newly incremented
	  value. If this expression is evaluated again, the value will
	  be different. The various assignment operators also have side effects. For
	  example, the expression 
	  <tt class="literal">a*=2</tt> can also be written as
	  <tt class="literal">a=a*2</tt>. The value of the expression is
	  the value of <tt class="literal">a</tt> multiplied by 2, 
	  but the expression also has
	  the side effect of storing that value back
	  into <tt class="literal">a</tt>. The method invocation operator
	  <tt class="literal">()</tt> has side effects if the invoked method
	  has side effects. Some methods, such as
	  <tt class="literal">Math.sqrt()</tt>, simply compute and return a
	  value without side effects of any kind. Typically, however,
	  methods do have side effects. Finally, the
	  <tt class="literal">new</tt> operator has the profound side effect
	  of creating a new object. </p>
<h3 class="sect3">2.5.1.6. Order of evaluation</h3>
<p>
<a name="INDEX-223"></a><a name="INDEX-224"></a><a name="INDEX-225"></a>

	  When the Java interpreter evaluates an expression, 
	  it performs the various operations in an order specified
	  by the parentheses in the expression, the precedence of the
	  operators, and the associativity of the operators. Before any
	  operation is performed, however, the interpreter first
	  evaluates the operands of the operator. (The exceptions are
	  the <tt class="literal">&amp;&amp;</tt>, <tt class="literal">||</tt>, and
	  <tt class="literal">?:</tt> operators, which do not always evaluate
	  all their operands.)  The interpreter always evaluates
	  operands in order from left to right. This matters if any of
	  the operands are expressions that contain side effects. Consider this code, for example:
</p>
<blockquote>
<pre class="programlisting">int a = 2;
int v = ++a + ++a * ++a;</pre>
</blockquote>
<p>
	  Although the multiplication is performed before the addition,
	  the operands of the <tt class="literal">+</tt> operator are
	  evaluated first. Thus, the expression evaluates to 3+4*5, or 23.
<a name="INDEX-226"></a>
</p>
<h3 class="sect2">2.5.2. Arithmetic Operators</h3>
<p>
<a name="INDEX-227"></a><a name="INDEX-228"></a>

	Since most programs operate primarily on numbers, the most
	commonly used operators are often those that perform arithmetic
	operations. The arithmetic operators can be used with integers,
	floating-point numbers, and even characters (i.e., they can
	be used with any primitive type other than
	<tt class="literal">boolean</tt>). If either of the operands is a
	floating-point number, floating-point arithmetic is used;
	otherwise, integer arithmetic is used. This matters because
	integer arithmetic and floating-point arithmetic differ in the
	way division is performed and in the way underflows and
	overflows are handled, for example. The arithmetic operators
	are:
      </p>
<dl>
<dt>
<b><em class="emphasis">Addition</em> (<tt class="literal">+</tt>)</b>
</dt>
<dd>
<p>
<a name="INDEX-229"></a><a name="INDEX-230"></a>

	      The <tt class="literal">+</tt> operator adds two numbers. As
	      we'll see shortly, the <tt class="literal">+</tt> operator can
	      also be used to concatenate strings. If either operand of
	      <tt class="literal">+</tt> is a string, the other one is
	      converted to a string as well. Be sure to use parentheses
	      when you want to combine addition with concatenation. For
	      example:
</p>
<blockquote>
<pre class="programlisting">System.out.println("Total: " + 3 + 4);    // Prints "Total: 34", not 7!</pre>
</blockquote>
<p>
</p>
</dd>
<dt>
<b>	    <em class="emphasis">Subtraction</em> (<tt class="literal">&minus;</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-231"></a><a name="INDEX-232"></a>
 
	      When <tt class="literal">&minus;</tt> is used as a binary
	      operator, it subtracts its second operand from its first. For example, 7-3 evaluates to 4. The <tt class="literal">&minus;</tt> operator can perform
	      unary negation. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Multiplication</em> (<tt class="literal">*</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-233"></a><a name="INDEX-234"></a>

	      The <tt class="literal">*</tt> operator multiplies its two
	      operands. For example, 7*3 evaluates
	      to 21. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Division</em> (<tt class="literal">/</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-235"></a><a name="INDEX-236"></a>

	      The <tt class="literal">/</tt> operator divides its first
	      operand by its second. If both operands are integers,
	      the result is an integer, and any remainder is
	      lost. If either operand is a floating-point value,
	      however, the result is a floating-point value. When
	      dividing two integers, division by zero throws an
	      <tt class="literal">ArithmeticException</tt>. For
	      floating-point calculations, however, division by zero
	      simply yields an infinite result or NaN:
</p>
<blockquote>
<pre class="programlisting">7/3          // Evaluates to 2
7/3.0f       // Evaluates to 2.333333f
7/0          // Throws an ArithmeticException
7/0.0        // Evaluates to positive infinity
0.0/0.0      // Evaluates to NaN</pre>
</blockquote>
<p>
</p>
</dd>
<dt>
<b><em class="emphasis">Modulo</em> (<tt class="literal">%</tt>)</b>
</dt>
<dd>
<p>
<a name="INDEX-237"></a><a name="INDEX-238"></a>

	      The <tt class="literal">%</tt> operator computes the first
	      operand modulo the second operand (i.e., it returns the
	      remainder when the first operand is divided by the second
	      operand an integral number of times). For example,
	      7%3 is 1. The sign of the
	      result is the same as the sign of the first operand. While the modulo operator is typically used with integer
	      operands, it also works for floating-point values. For
	      example, 4.3%2.1 evaluates to 0.1. When operating with integers, trying to compute a value
	      modulo zero causes an
	      <tt class="literal">ArithmeticException</tt>. When working with
	      floating-point values, anything modulo 0.0 evaluates to
	      <tt class="literal">NaN</tt>, as does infinity modulo anything. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Unary Minus</em> (<tt class="literal">&minus;</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-239"></a><a name="INDEX-240"></a>

	      When <tt class="literal">&minus;</tt> is used as a unary
	      operator, before a single operand, it performs unary
	      negation. In other words, it converts a positive value to
	      an equivalently negative value, and vice versa. </p>
</dd>
</dl>
<h3 class="sect2">2.5.3. String Concatenation Operator</h3>
<p>
<a name="INDEX-241"></a>

	In addition to adding numbers, the <tt class="literal">+</tt> operator
	(and the related <tt class="literal">+=</tt> operator) also
	concatenates, or joins, strings. If either of the operands to
	<tt class="literal">+</tt> is a string, the operator converts the
	other operand to a string. For example:
</p>
<blockquote>
<pre class="programlisting">System.out.println("Quotient: " + 7/3.0f);  // Prints "Quotient: 2.3333333"</pre>
</blockquote>
<p>
	As a result, you must be careful to put
	any addition expressions in parentheses when combining
	them with string concatenation. If you do not, the addition
	operator is interpreted as a concatenation operator.

<a name="INDEX-242"></a>
</p>
<p>	The Java interpreter has built-in string conversions for all
	primitive types. An object is converted to a string by invoking
	its <tt class="literal">toString()</tt> method. Some classes define
	custom <tt class="literal">toString()</tt> methods, so that objects of
	that class can easily be converted to strings in this way. An array is converted to a string by invoking the built-in
	<tt class="literal">toString()</tt> method, which, unfortunately, does
	not return a useful string representation of the array contents. </p>
<h3 class="sect2">2.5.4. Increment and Decrement Operators</h3>
<p>
<a name="INDEX-243"></a><a name="INDEX-244"></a><a name="INDEX-245"></a><a name="INDEX-246"></a>

	The <tt class="literal">++</tt> operator increments 
	its single operand, which must be a variable, an element of an
	array, or a field of an object, by one. The behavior of this
	operator depends on its position relative to the operand. When
	used before the operand, where it is known as the <em class="emphasis">pre-increment</em>
	operator, it increments the operand and evaluates to the
	incremented value of that operand. When used after the operand,
	where it is known as the <em class="emphasis">post-increment</em> operator, it increments
	its operand, but evaluates to the
	value of that operand before it was incremented. </p>
<p>	For example, the following code sets both <tt class="literal">i</tt>
	and <tt class="literal">j</tt> to 2:
	</p>
<blockquote>
<pre class="programlisting">i = 1;
j = ++i;</pre>
</blockquote>
<p>
	But these lines set <tt class="literal">i</tt> to 2
	and <tt class="literal">j</tt> to 1:
	</p>
<blockquote>
<pre class="programlisting">i = 1;
j = i++;</pre>
</blockquote>
<p>
<a name="INDEX-247"></a><a name="INDEX-248"></a>

	Similarly, the <tt class="literal">&minus; &minus;</tt> operator
	decrements its single numeric operand,
	which must be a variable, an element of an array, or a field of
	an object, by one. Like the <tt class="literal">++</tt> operator, the
	behavior of <tt class="literal">&minus; &minus;</tt> depends on
	its position relative to the operand. When used before the
	operand, it decrements the operand 
	and returns the decremented value. When
	used after the operand, 


it decrements the operand, but returns the
	<em class="emphasis">un-decremented</em> value.

<a name="INDEX-249"></a>
</p>
<p>	The expressions <tt class="literal">x++</tt> and
	<tt class="literal">x&minus; &minus;</tt> are equivalent to
	<tt class="literal">x=x+1</tt> and <tt class="literal">x=x&minus;1</tt>,
	respectively, except
	that when using the increment and decrement operators,
	<tt class="literal">x</tt> is only evaluated once. If
	<tt class="literal">x</tt> is itself an expression with side effects, this
	makes a big difference. For example, these two expressions are
	not equivalent:
</p>
<blockquote>
<pre class="programlisting">a[i++]++;             // Increments an element of an array
a[i++] = a[i++] + 1;  // Adds one to an array element and stores it in another</pre>
</blockquote>
<p>	These operators, in both prefix and postfix forms, are most
	commonly used to increment or decrement the counter that
	controls a loop. </p>
<h3 class="sect2">2.5.5. Comparison Operators</h3>
<p>
<a name="INDEX-250"></a><a name="INDEX-251"></a>


	The comparison operators consist of the equality operators that
	test values for equality or inequality and the
	relational operators used with ordered types (numbers and
	characters) to test for greater than and less than
	relationships. Both types of operators yield a
	<tt class="literal">boolean</tt> result, so they are typically used
	with <tt class="literal">if</tt> statements and
	<tt class="literal">while</tt> and <tt class="literal">for</tt> loops to
	make branching and looping decisions. For example:
</p>
<blockquote>
<pre class="programlisting">if (o != null) ...;           // The not equals operator
while(i &lt; a.length) ...;      // The less than operator</pre>
</blockquote>
<p>	Java provides the following equality operators:
	</p>
<dl>
<dt>
<b>	      <em class="emphasis">Equals</em>
	      (<tt class="literal">= =</tt>)
	    </b>
</dt>
<dd>
<p>
<a name="INDEX-252"></a><a name="INDEX-253"></a>

		The <tt class="literal">= =</tt> operator evaluates to
		<tt class="literal">true</tt> if its two operands are equal
		and <tt class="literal">false</tt> otherwise. With primitive operands, it tests whether the operand
		values themselves are identical. For operands of
		reference types, however, 
		it tests whether the operands refer to
		the same object or array. In other words, 
		it does not test the equality
		of two distinct objects or arrays. In particular, note
		that you cannot test two distinct strings for equality
		with this operator. </p>
<p>		If <tt class="literal">= =</tt> is used to compare two
		numeric or character operands that are not of the same
		type, the narrower operand is converted to the type
		of the wider operand before the comparison is done. For
		example, when comparing a <tt class="literal">short</tt> to a
		<tt class="literal">float</tt>, the <tt class="literal">short</tt>
		is first converted to a <tt class="literal">float</tt> 
		before the comparison is performed. For floating-point numbers, the special negative zero
		value tests equal to the regular, positive zero value. Also, the special NaN (not-a-number) value is not equal
		to any other number, including itself. To test whether
		a floating-point value is NaN, use the
		<tt class="literal">Float.isNan()</tt> or
		<tt class="literal">Double.isNan()</tt> method. </p>
</dd>
<dt>
<b>	      <em class="emphasis">Not Equals</em> (<tt class="literal">!=</tt>)
	    </b>
</dt>
<dd>
<p>
<a name="INDEX-254"></a><a name="INDEX-255"></a>

		The <tt class="literal">!=</tt> operator is exactly the
		opposite of the <tt class="literal">= =</tt>
		operator. It evaluates to <tt class="literal">true</tt> if its two
		primitive operands have different values or if its two
		reference operands refer to different objects or
		arrays. Otherwise, it evaluates to <tt class="literal">false</tt>. </p>
</dd>
</dl>
<p>	The relational operators can be used with
	numbers and characters, but not with
	<tt class="literal">boolean</tt> values, objects, or arrays
	because those types are not ordered. Java provides
	the following relational operators:
	</p>
<dl>
<dt>
<b>	      <em class="emphasis">Less Than</em> (<tt class="literal">&lt;</tt>)
	    </b>
</dt>
<dd>
<p>
<a name="INDEX-256"></a><a name="INDEX-257"></a>
		Evaluates to <tt class="literal">true</tt> if
		the first operand is less than the second. </p>
</dd>
<dt>
<b>	      <em class="emphasis">Less Than or Equal</em> (<tt class="literal">&lt;=</tt>)
	    </b>
</dt>
<dd>
<p>
<a name="INDEX-258"></a><a name="INDEX-259"></a>
		Evaluates to <tt class="literal">true</tt> if
		the first operand is less than or equal to the second. </p>
</dd>
<dt>
<b>	      <em class="emphasis">Greater Than</em> (<tt class="literal">&gt;</tt>)
	    </b>
</dt>
<dd>
<p>
<a name="INDEX-260"></a><a name="INDEX-261"></a>
		Evaluates to <tt class="literal">true</tt> if
		the first operand is greater than the second. </p>
</dd>
<dt>
<b>	      <em class="emphasis">Greater Than or Equal</em> (<tt class="literal">&gt;=</tt>)
	    </b>
</dt>
<dd>
<p>
<a name="INDEX-262"></a><a name="INDEX-263"></a>
		Evaluates to <tt class="literal">true</tt> if
		the first operand is greater than or equal to the second. </p>
</dd>
</dl>
<h3 class="sect2">2.5.6. Boolean Operators</h3>
<p>	As we've just seen, the comparison operators compare their
	operands and yield a <tt class="literal">boolean</tt> result, which is
	often used in branching and looping statements. In order to
	make branching and looping decisions based on conditions more
	interesting 
	than a single comparison, you can use the Boolean (or
	logical) operators to
	combine multiple comparison expressions into a single, more
	complex, expression. The Boolean operators require their
	operands to be <tt class="literal">boolean</tt> values and they
	evaluate to 
	<tt class="literal">boolean</tt> values. 

  The operators are:
      </p>
<dl>
<dt>
<b>	    <em class="emphasis">Conditional AND</em> (<tt class="literal">&amp;&amp;</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-264"></a><a name="INDEX-265"></a>

	      This operator performs a Boolean AND operation on its
	      operands. It evaluates to <tt class="literal">true</tt> if and
	      only if both its operands are 
	      <tt class="literal">true</tt>. If either or both
	      operands are <tt class="literal">false</tt>, it evaluates to
	      <tt class="literal">false</tt>. For example:
</p>
<blockquote>
<pre class="programlisting">if (x &lt; 10 &amp;&amp; y &gt; 3) ... // If both comparisons are true</pre>
</blockquote>
<p>
	      This operator (and all the Boolean operators
	      except the unary <tt class="literal">!</tt> operator) have a
	      lower precedence than the comparison operators. Thus, it
	      is perfectly legal to write a line of code like the one
	      above. However, some 
	      programmers prefer to use parentheses to make
	      the order of evaluation explicit:
</p>
<blockquote>
<pre class="programlisting">if ((x &lt; 10) &amp;&amp; (y &gt; 3)) ... </pre>
</blockquote>
<p>
	      You should use whichever style you find easier to read. </p>
<p>	      This operator is called a conditional AND because it
	      conditionally evaluates its second operand. If the
	      first operand evaluates to <tt class="literal">false</tt>, 
	      the value of the expression is
	      <tt class="literal">false</tt>, regardless of the value of the
	      second operand. Therefore, to increase efficiency, the
	      Java interpreter takes a shortcut and skips the second
	      operand. Since the second operand is not guaranteed to be
	      evaluated, you must use caution when using this operator
	      with expressions that have side effects. On the other
	      hand, the 
	      conditional nature of this operator allows us to write
	      Java expressions such as the following:
</p>
<blockquote>
<pre class="programlisting">if (data != null &amp;&amp; i &lt; data.length &amp;&amp; data[i] != -1) ... </pre>
</blockquote>
<p>
	      The second and third comparisons in this expression would
	      cause errors if the first or second comparisons
	      evaluated to <tt class="literal">false</tt>. Fortunately, we
	      don't have to worry about this because of the conditional
	      behavior of the <tt class="literal">&amp;&amp;</tt> operator. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Conditional OR</em> (<tt class="literal">||</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-266"></a><a name="INDEX-267"></a>

	      This operator performs a Boolean OR operation on its two
	      <tt class="literal">boolean</tt> operands. It evaluates to
	      <tt class="literal">true</tt> if either or both of its
	      operands are <tt class="literal">true</tt>. If both operands are
	      <tt class="literal">false</tt>, it evaluates to
	      <tt class="literal">false</tt>. Like the
	      <tt class="literal">&amp;&amp;</tt> operator,
	      <tt class="literal">||</tt> does not always evaluate its second
	      operand. If the first operand evaluates to
	      <tt class="literal">true</tt>, the value of the expression
	      is <tt class="literal">true</tt>, regardless of the value of
	      the second operand. Thus, the operator simply skips that
	      second operand in that case. </p>
</dd>
<dt>
<b>Boolean NOT (<tt class="literal">!</tt>)</b>
</dt>
<dd>
<p>
<a name="INDEX-268"></a><a name="INDEX-269"></a>
	      This unary operator changes the <tt class="literal">boolean</tt> 
	      value of its
	      operand. If applied to a <tt class="literal">true</tt> value,
	      it evaluates to <tt class="literal">false</tt>, and if applied
	      to a <tt class="literal">false</tt> value, it evaluates to
	      <tt class="literal">true</tt>. It is useful in expressions like
	      these:
</p>
<blockquote>
<pre class="programlisting">if (!found) ...          // found is a boolean variable declared somewhere
while (!c.isEmpty()) ... // The isEmpty() method returns a boolean value</pre>
</blockquote>
<p>
	      Because <tt class="literal">!</tt> is a unary operator, it has a
	      high precedence and often must be used with parentheses:
</p>
<blockquote>
<pre class="programlisting">if (!(x &gt; y &amp;&amp; y &gt; z)) </pre>
</blockquote>
<p>
</p>
</dd>
<dt>
<b>	    <em class="emphasis">Boolean AND</em> (<tt class="literal">&amp;</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-270"></a><a name="INDEX-271"></a>
	      When used with <tt class="literal">boolean</tt> operands, the
	      <tt class="literal">&amp;</tt> operator behaves like the 
	      <tt class="literal">&amp;&amp;</tt> operator, except that it
	      always evaluates both operands, regardless of the value of
	      the first operand. This operator is almost always used
	      as a bitwise operator with integer operands, however,
	      and many Java
	      programmers would not even recognize its use with
	      <tt class="literal">boolean</tt> operands as legal Java code. </p>
</dd>
<dt>
<b><em class="emphasis">Boolean OR</em> (<tt class="literal">|</tt>)</b>
</dt>
<dd>
<p>
<a name="INDEX-272"></a><a name="INDEX-273"></a>

	      This operator performs a Boolean OR operation on its two
	      <tt class="literal">boolean</tt> operands. It is like the
	      <tt class="literal">||</tt> operator, except that it always
	      evaluates both operands, even if the first one is
	      <tt class="literal">true</tt>. The <tt class="literal">|</tt>
	      operator is almost always used as a bitwise operator on
	      integer operands; its use with
	      <tt class="literal">boolean</tt> operands is very rare. </p>
</dd>
<dt>
<b><em class="emphasis">Boolean XOR</em> (<tt class="literal">^</tt>)</b>
</dt>
<dd>
<p>
<a name="INDEX-274"></a><a name="INDEX-275"></a>

	      When used with <tt class="literal">boolean</tt> operands, this
	      operator computes the Exclusive OR (XOR) of its
	      operands. It evaluates to <tt class="literal">true</tt> if
	      exactly one of the two operands is
	      <tt class="literal">true</tt>. In other words, it evaluates to
	      <tt class="literal">false</tt> if both operands are
	      <tt class="literal">false</tt> or if both operands are
	      <tt class="literal">true</tt>. Unlike the
	      <tt class="literal">&amp;&amp;</tt> and <tt class="literal">||</tt>
	      operators, this one must always evaluate both operands. The <tt class="literal">^</tt> operator is much more commonly
	      used as a bitwise operator on integer operands. With <tt class="literal">boolean</tt> operands, this operator is
	      equivalent to the <tt class="literal">!=</tt> operator. </p>
</dd>
</dl>
<h3 class="sect2">2.5.7. Bitwise and Shift Operators</h3>
<p>
<a name="INDEX-276"></a>

	The bitwise and shift operators are low-level operators that
	manipulate the individual bits that make up an integer value. The bitwise operators are most commonly used for testing and
	setting individual flag bits in a value. In order to understand their behavior, you must understand
	binary (base-2) numbers and the twos-complement format used to
	represent negative integers. You cannot use these operators
	with floating-point, <tt class="literal">boolean</tt>, array, or
	object operands. When used with
	<tt class="literal">boolean</tt> operands, the
	<tt class="literal">&amp;</tt>, <tt class="literal">|</tt>, and
	<tt class="literal">^</tt> operators perform a different operation,
	as described in the previous section. </p>
<p>	If either of the arguments to a bitwise operator is a
	<tt class="literal">long</tt>, the result is a
	<tt class="literal">long</tt>. Otherwise, the result is an
	<tt class="literal">int</tt>. If the left operand of a shift operator
	is a <tt class="literal">long</tt>, the result is a <tt class="literal">long</tt>;
	otherwise, the result is an <tt class="literal">int</tt>. The operators are:
      </p>
<dl>
<dt>
<b>	    <em class="emphasis">Bitwise Complement</em> (<tt class="literal">~</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-277"></a><a name="INDEX-278"></a><a name="INDEX-279"></a><a name="INDEX-280"></a><a name="INDEX-281"></a>

	      The unary <tt class="literal">~</tt> operator is known as the
	      bitwise complement, or bitwise NOT, operator. It inverts
	      each bit of its single operand, converting ones to zeros
	      and zeros to ones. For example:
</p>
<blockquote>
<pre class="programlisting">byte b = ~12;           // ~00000110 ==&gt; 11111001 or -13 decimal
flags = flags &amp; ~f;     // Clear flag f in a set of flags</pre>
</blockquote>
<p>
</p>
</dd>
<dt>
<b>	    <em class="emphasis">Bitwise AND</em> (<tt class="literal">&amp;</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-282"></a><a name="INDEX-283"></a>

	      This operator combines its two integer operands by
	      performing a Boolean AND operation on their individual
	      bits. The result has a bit set only if the
	      corresponding bit is set in both operands. For example:
</p>
<blockquote>
<pre class="programlisting">10 &amp; 7                   // 00001010 &amp; 00000111 ==&gt; 00000010 or 2
if ((flags &amp; f) != 0)    // Test whether flag f is set</pre>
</blockquote>
<p>
	      When used with <tt class="literal">boolean</tt> operands, 
	      <tt class="literal">&amp;</tt> is the infrequently used Boolean
	      AND operator described earlier. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Bitwise OR</em> (<tt class="literal">|</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-284"></a><a name="INDEX-285"></a>

	      This operator combines its two integer operands by
	      performing a Boolean OR operation on their individual
	      bits. The result has a bit set if the
	      corresponding bit is set in either or both of the
	      operands. It has a zero bit only where both
	      corresponding operand bits are zero. For example:
</p>
<blockquote>
<pre class="programlisting">10 | 7               // 00001010 | 00000111 ==&gt; 00001111 or 15
flags = flags | f;   // Set flag f</pre>
</blockquote>
<p>
	      When used with <tt class="literal">boolean</tt> operands,
	      <tt class="literal">|</tt> is the infrequently used Boolean OR
	      operator described earlier. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Bitwise XOR</em> (<tt class="literal">^</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-286"></a><a name="INDEX-287"></a>

	      This operator combines its two integer operands by
	      performing a Boolean XOR (Exclusive OR) operation on their
	      individual bits. The result has a bit set if
	      the corresponding bits in the two operands are
	      different. If the corresponding operand bits are both ones or
	      both zeros, the result bit is a zero. For example:
</p>
<blockquote>
<pre class="programlisting">10 &amp; 7               // 00001010 ^ 00000111 ==&gt; 00001101 or 13</pre>
</blockquote>
<p>
	      When used with <tt class="literal">boolean</tt> operands,
	      <tt class="literal">^</tt> is the infrequently used Boolean XOR
	      operator. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Left Shift</em> (<tt class="literal">&lt;&lt;</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-288"></a><a name="INDEX-289"></a>
	      The <tt class="literal">&lt;&lt;</tt> operator shifts the bits
	      of the left operand left by the number of places specified
	      by the right operand. High-order bits of the left operand
	      are lost, and zero bits are shifted in from the right. Shifting an integer left by <em class="replaceable">n</em>
	      places is equivalent to multiplying that number by 
	      2<sup class="superscript"><em class="replaceable">n</em></sup>. For example:
</p>
<blockquote>
<pre class="programlisting">10 &lt;&lt; 1    // 00001010 &lt;&lt; 1 = 00010100 = 20 = 10*2
7 &lt;&lt; 3     // 00000111 &lt;&lt; 3 = 00111000 = 56 = 7*8
-1 &lt;&lt; 2    // 0xFFFFFFFF &lt;&lt; 2 = 0xFFFFFFFC = -4 = -1*4</pre>
</blockquote>
<p>
	      If the left operand 
	      is a <tt class="literal">long</tt>, the right operand
	      should be between 0 and 63. Otherwise, the left
	      operand is taken to be an <tt class="literal">int</tt>, and the
	      right operand should be between 0 and 31. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Signed Right Shift</em>
	    (<tt class="literal">&gt;&gt;</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-290"></a><a name="INDEX-291"></a>
	      The <tt class="literal">&gt;&gt;</tt> operator shifts the bits
	      of the left operand to the right by the number of places
	      specified by the right operand. The low-order bits
	      of the left operand are shifted away and are lost. The
	      high-order bits shifted in are the same as the original
	      high-order bit of the left operand. In other words, if the
	      left operand is positive, zeros are shifted into the
	      high-order bits. If the left operand is
	      negative, ones are shifted in instead. This technique is
	      known as <em class="emphasis">sign extension</em>; it is
	      used to preserve the sign of the left operand. For
	      example:
</p>
<blockquote>
<pre class="programlisting">10 &gt;&gt; 1      // 00001010 &gt;&gt; 1 = 00000101 = 5 = 10/2
27 &gt;&gt; 3      // 00011011 &gt;&gt; 3 = 00000011 = 3 = 27/8
-50 &gt;&gt; 2     // 11001110 &gt;&gt; 2 = 11110011 = -13 != -50/4</pre>
</blockquote>
<p>
	      If the left operand is positive and the
	      right operand is <em class="replaceable">n</em>, the
	      <tt class="literal">&gt;&gt;</tt> operator is the same as
	      integer division by
	      2<sup class="superscript"><em class="replaceable">n</em></sup>. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Unsigned Right Shift</em>
	    (<tt class="literal">&gt;&gt;&gt;</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-292"></a><a name="INDEX-293"></a>

	      This operator is like the <tt class="literal">&gt;&gt;</tt>
	      operator, except that it always shifts zeros into the
	      high-order bits of the result, regardless of the sign of
	      the left-hand operand. This technique is called
	      <em class="emphasis">zero extension</em>&#8202;; it is appropriate
	      when the left operand is being treated as an unsigned
	      value (despite the fact that Java integer types are
	      all signed). Examples:
</p>
<blockquote>
<pre class="programlisting">-50 &gt;&gt;&gt; 2     // 11001110 &gt;&gt;&gt; 2 = 00110011 = 51
0xff &gt;&gt;&gt; 4    // 11111111 &gt;&gt;&gt; 4 = 00001111 = 15  = 255/16</pre>
</blockquote>
<p>
</p>
</dd>
</dl>
<h3 class="sect2">2.5.8. Assignment Operators</h3>
<p>
<a name="INDEX-294"></a><a name="INDEX-295"></a><a name="INDEX-296"></a>

	The assignment operators store, or assign, a value into some kind
	of variable. The left operand must evaluate to an
	appropriate local variable, array element, or object field. The
	right side can be any value of a type compatible with the
	variable. An assignment expression evaluates to the value that
	is assigned to the variable. More importantly, however, the
	expression has the side effect of actually performing the
	assignment. Unlike all other binary operators, the assignment
	operators are right-associative, which means that the
	assignments in <tt class="literal">a=b=c</tt> are performed
	right-to-left, as follows: <tt class="literal">a=(b=c)</tt>. </p>
<p>	The basic assignment operator is <tt class="literal">=</tt>. Do not
	confuse it with the equality operator,
	<tt class="literal">= =</tt>. In order to keep these two
	operators distinct, I recommend that you read
	<tt class="literal">=</tt> as "is assigned the value."
      </p>
<p>	In addition to this simple assignment operator, Java also
	defines 11 other operators that combine assignment with the 5
	arithmetic operators and the 6 bitwise and shift operators. For
	example, the <tt class="literal">+=</tt> operator reads the value
	of the left variable, adds the value of the right
	operand to it, stores the sum back into the left
	variable as a side effect, and returns the sum as the value of
	the expression. Thus, the expression <tt class="literal">x+=2</tt> is
	almost the same <tt class="literal">x=x+2</tt>. The difference
	between these two expressions is that when you use the
	<tt class="literal">+=</tt> operator, the left operand is
	evaluated only once. This makes a difference when that operand
	has a side effect. Consider the following two expressions,
	which are not equivalent:
</p>
<blockquote>
<pre class="programlisting">a[i++] += 2;
a[i++] = a[i++] + 2;</pre>
</blockquote>
<p>	The general form of these combination assignment operators is:
</p>
<blockquote>
<pre class="programlisting">var <em class="replaceable">op</em>= value</pre>
</blockquote>
<p>
	This is equivalent (unless there are side effects in
	<tt class="literal">var</tt>) to:
</p>
<blockquote>
<pre class="programlisting">var = var <em class="replaceable">op</em> value</pre>
</blockquote>
<p>
	The available operators are:
</p>
<blockquote>
<pre class="programlisting">+=    &minus;=    *=    /=    %=    // Arithmetic operators plus assignment
&amp;=    |=    ^=                // Bitwise operators plus assignment
&lt;&lt;=   &gt;&gt;=   &gt;&gt;&gt;=              // Shift operators plus assignment</pre>
</blockquote>
<p>
	The most commonly used operators are <tt class="literal">+=</tt> and
	<tt class="literal">&minus; =</tt>, although <tt class="literal">&amp;=</tt> and
	<tt class="literal">|=</tt> can also be useful when working with
	<tt class="literal">boolean</tt> flags. For example:
</p>
<blockquote>
<pre class="programlisting">i += 2;          // Increment a loop counter by 2
c &minus;= 5;          // Decrement a counter by 5
flags |= f;      // Set a flag f in an integer set of flags
flags &amp;= ~f;     // Clear a flag f in an integer set of flags</pre>
</blockquote>
<h3 class="sect2">2.5.9. The Conditional Operator</h3>
<p>
<a name="INDEX-297"></a><a name="INDEX-298"></a><a name="INDEX-299"></a>

	The conditional operator <tt class="literal">?:</tt> is a somewhat
	obscure ternary (three-operand) operator inherited from C. It
	allows you to embed a conditional within an expression. You can think
	of it as the operator version of the <tt class="literal">if/else</tt>
	statement. The first and second operands of the conditional
	operator are separated by a question mark (<tt class="literal">?</tt>), 
	while the second and third operands are separated by a colon
	(<tt class="literal">:</tt>). The first operand must evaluate to a
	<tt class="literal">boolean</tt> value. The second and third operands can
	be of any type, but they must both be of the same type. </p>
<p>	The conditional operator starts by evaluating its first operand. If
	it is <tt class="literal">true</tt>, the operator evaluates its second
	operand and uses that as the value of the expression. On the
	other hand, if the first operand is <tt class="literal">false</tt>,
	the conditional operator evaluates and returns its third
	operand. The conditional operator never evaluates both its
	second and third operand, so be careful when using expressions
	with side effects with this operator. Examples of this operator
	are:
</p>
<blockquote>
<pre class="programlisting">int max = (x &gt; y) ? x : y;
String name = (name != null) ? name : "unknown";</pre>
</blockquote>
<p>
	Note that the <tt class="literal">?:</tt> operator has lower
	precedence than all other operators except the assignment
	operators, so parentheses are not usually necessary around the
	operands of this operator. Many programmers find conditional
	expressions easier to read if the first operand is placed within
	parentheses, however. This is especially true because the
	conditional <tt class="literal">if</tt> statement always has its
	conditional expression written within parentheses. </p>
<h3 class="sect2">2.5.10. The instanceof Operator</h3>
<p>
<a name="INDEX-300"></a>

	The <tt class="literal">instanceof</tt> operator requires an object or
	array value as its left operand and the name of a reference
	type as its right operand. It evaluates to
	<tt class="literal">true</tt> if the object or array is an
	<em class="emphasis">instance</em> of the specified type; it returns
	<tt class="literal">false</tt> otherwise. If the left operand is
	<tt class="literal">null</tt>, <tt class="literal">instanceof</tt> always
	evaluates to <tt class="literal">false</tt>. If an
	<tt class="literal">instanceof</tt> expression evaluates to
	<tt class="literal">true</tt>, it means that you can safely cast and
	assign the left operand to a variable of the type of the
	right operand. </p>
<p>	The <tt class="literal">instanceof</tt> operator can be used only with
	array and object types and values, not primitive types and
	values. Object and array types are discussed in detail later in
	this chapter. Examples of <tt class="literal">instanceof</tt> are:
</p>
<blockquote>
<pre class="programlisting">"string" instanceof String      // True: all strings are instances of String
"" instanceof Object            // True: strings are also instances of Object
new int[] {1} instanceof int[]  // True: the array value is an int array
new int[] {1} instanceof byte[] // False: the array value is not a byte array
new int[] {1} instanceof Object // True: all arrays are instances of Object
null instanceof String          // False: null is never instanceof anything

// Use instanceof to make sure that it is safe to cast an object
if (object instanceof Point) {
  Point p = (Point) object;
}</pre>
</blockquote>
<h3 class="sect2">2.5.11. Special Operators</h3>
<p>
<a name="INDEX-301"></a><a name="INDEX-302"></a>

	There are five language constructs in Java that are sometimes
	considered operators and sometimes considered simply part
	of the basic language syntax. These "operators" are listed in <a href="#javanut3-ch-2-tab-5">Table 2-5</a> in order to show their precedence
	relative to the other true operators. The use of these
	language constructs is detailed elsewhere in this chapter, but
	is described briefly here, so that you can recognize these
	constructs when you encounter them in code examples:
      </p>
<dl>
<dt>
<b>	    <em class="emphasis">Object member access</em>
	    (<tt class="literal">.</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-303"></a><a name="INDEX-304"></a>

	      An <em class="emphasis">object</em> 
	      is a collection of data and methods that operate
	      on that data; the data fields and methods of an object
	      are called its members. The dot (<tt class="literal">.</tt>)
	      operator accesses these members. If <tt class="literal">o</tt>
	      is an expression that evaluates to an object reference,
	      and <tt class="literal">f</tt> is the name of a field of the
	      object, <tt class="literal">o.f</tt> evaluates to the value
	      contained in that field. If <tt class="literal">m</tt> is the
	      name of a method, <tt class="literal">o.m</tt> refers to
	      that method and allows it to be invoked using the
	      <tt class="literal">()</tt> operator shown later. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Array element access</em>
	    (<tt class="literal">[]</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-305"></a><a name="INDEX-306"></a>

	      An <em class="emphasis">array</em> is a numbered list of
	      values. Each element of an array can be referred to
	      by its number, or <em class="emphasis">index</em>. The
	      <tt class="literal">[]</tt> operator allows you to refer to the
	      individual elements of an array. If <tt class="literal">a</tt>
	      is an array, and <tt class="literal">i</tt> is an expression
	      that evaluates to an <tt class="literal">int</tt>, 
	      <tt class="literal">a[i]</tt> 
	      refers to one of the elements of <tt class="literal">a</tt>. Unlike other operators that work with integer
	      values, this operator restricts array index values to be
	      of type <tt class="literal">int</tt> or narrower. </p>
</dd>
<dt>
<b>	    <em class="emphasis">Method invocation</em>
	    (<tt class="literal">()</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-307"></a><a name="INDEX-308"></a>

	      A <em class="emphasis">method</em> is a named collection of
	      Java code that can be run, or <em class="emphasis">invoked</em>,
	      by following the name of the method with zero or more
	      comma-separated expressions contained within parentheses. The values of these expressions are the
	      <em class="emphasis">arguments</em> to the method. The method
	      processes the arguments and optionally returns a value
	      that becomes the value of the method invocation
	      expression. If <tt class="literal">o.m</tt> is a method that
	      expects no arguments, the method can be invoked with
	      <tt class="literal">o.m()</tt>. If the method expects three arguments, for example, it can be
	      invoked with an expression such as
	      <tt class="literal">o.m(x,y,z)</tt>. Before the Java
	      interpreter invokes a method, it evaluates each of the
	      arguments to be passed to the method. These expressions
	      are guaranteed to be evaluated in order from
	      left to right (which matters if any of the arguments have
	      side effects). </p>
</dd>
<dt>
<b>	    <em class="emphasis">Object creation</em>
	    (<tt class="literal">new</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-309"></a><a name="INDEX-310"></a>

	      In Java, objects are created with the
	      <tt class="literal">new</tt> operator, which is followed by the
	      type of the object to be created and a parenthesized
	      list of arguments to be passed to the object
	      <em class="emphasis">constructor</em>. A constructor is a
	      special method that initializes a newly created object, so
	      the object creation syntax is similar to the Java method
	      invocation syntax. For example:
</p>
<blockquote>
<pre class="programlisting">new ArrayList();
new Point(1,2)</pre>
</blockquote>
<p>
</p>
</dd>
<dt>
<b>	    <em class="emphasis">Type conversion or casting</em>
	    (<tt class="literal">()</tt>)
	  </b>
</dt>
<dd>
<p>
<a name="INDEX-311"></a><a name="INDEX-312"></a><a name="INDEX-313"></a>

	      As we've already seen, parentheses
	      can also be used as an operator to perform narrowing type
	      conversions, or casts. The first operand of this operator
	      is the type to be converted to; it is placed between the
	      parentheses. The second operand is the value to be
	      converted; it follows the parentheses. For example:
</p>
<blockquote>
<pre class="programlisting">(byte) 28          // An integer literal cast to a byte type
(int) (x + 3.14f)  // A floating-point sum value cast to an integer value
(String)h.get(k)   // A generic object cast to a more specific string type</pre>
</blockquote>
<p>
</p>
</dd>
</dl>

<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch02_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_04.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch02_06.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_06.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">2.4. Primitive Data Types</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">2.6. Statements</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
