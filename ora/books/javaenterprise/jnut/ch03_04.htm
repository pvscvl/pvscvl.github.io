<html>
<head>
<title>Subclasses and Inheritance (Java in a Nutshell)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David Flanagan">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-487-8E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Subclasses and Inheritance">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm" alt="Java Enterprise in a Nutshell"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch03_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_01.htm">Chapter 3: Object-Oriented Programming in Java</a></td><td align="right" valign="top" width="172"><a href="ch03_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_05.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY --><h2 class="sect1">3.4. Subclasses and Inheritance</h2>
<p>
<a name="INDEX-448"></a><a name="INDEX-449"></a>

      The <tt class="literal">Circle</tt> defined earlier is a simple class
      that distinguishes circle objects only by their radii. Suppose, instead, that we want to represent circles that have both
      a size and a position. For example, a circle of radius 1.0
      centered at point 0,0 in the Cartesian plane is different from
      the circle of radius 1.0 centered at point 1,2. To do this, we
      need a new class, which we'll call
      <tt class="literal">PlaneCircle</tt>. We'd like to add the ability to
      represent the position of a circle without losing any of the
      existing functionality of the <tt class="literal">Circle</tt> class. This is done by defining <tt class="literal">PlaneCircle</tt> as a
      subclass of <tt class="literal">Circle</tt>, so that
      <tt class="literal">PlaneCircle</tt>
      inherits the fields and methods of its
      superclass, <tt class="literal">Circle</tt>. The ability to add functionality to a class by subclassing, or
      extending, it is central to the
      object-oriented programming paradigm. </p>
<h3 class="sect2">3.4.1. Extending a Class</h3>
<p>
<a name="INDEX-450"></a><a href="#javanut3-ch-3-ex-planecircle">Example 3-3</a> shows how we can
	implement <tt class="literal">PlaneCircle</tt> as a subclass of
	the <tt class="literal">Circle</tt> class. </p>
<a name="javanut3-ch-3-ex-planecircle"></a>
<div class="example">
<h4 class="objtitle">Example 3-3. Extending the Circle Class</h4>
<blockquote>
<pre class="programlisting">public class PlaneCircle extends Circle {
  // We automatically inherit the fields and methods of Circle, 
  // so we only have to put the new stuff here. 
  // New instance fields that store the center point of the circle
  public double cx, cy;

  // A new constructor method to initialize the new fields
  // It uses a special syntax to invoke the Circle() constructor
  public PlaneCircle(double r, double x, double y) {
    super(r);       // Invoke the constructor of the superclass, Circle()
    this.cx = x;    // Initialize the instance field cx
    this.cy = y;    // Initialize the instance field cy
  }

  // The area() and circumference() methods are inherited from Circle
  // A new instance method that checks whether a point is inside the circle
  // Note that it uses the inherited instance field r
  public boolean isInside(double x, double y) {
    double dx = x - cx, dy = y - cy;             // Distance from center
    double distance = Math.sqrt(dx*dx + dy*dy);  // Pythagorean theorem
    return (distance &lt; r);                       // Returns true or false
  }
}</pre>
</blockquote>
</div>
<p>	Note the use of the keyword <tt class="literal">extends</tt> in the
	first line of <a href="#javanut3-ch-3-ex-planecircle">Example 3-3</a>. This keyword tells Java that <tt class="literal">PlaneCircle</tt>
	extends, or subclasses, <tt class="literal">Circle</tt>, meaning that it
	inherits the fields and methods of that
	class.<a href="#FOOTNOTE-2">[2]</a>  The definition of the
	<tt class="literal">isInside()</tt> method shows field
	inheritance; this method uses the field
	<tt class="literal">r</tt> (defined by the <tt class="literal">Circle</tt>
	class) as if it were defined right in
	<tt class="literal">PlaneCircle</tt> itself. <tt class="literal">PlaneCircle</tt> also inherits the methods of
	<tt class="literal">Circle</tt>. Thus, if we have a
	<tt class="literal">PlaneCircle</tt> object referenced by variable
	<tt class="literal">pc</tt>, we can say:
      </p>
<blockquote class="footnote">
<a name="FOOTNOTE-2"></a>
<p>[2]C++ programmers should note that
	<tt class="literal">extends</tt> is the Java equivalent of
	<tt class="literal">:</tt> in C++; both are used to indicate the
	superclass of a class.</p>
</blockquote>
<blockquote>
<pre class="programlisting">double ratio = pc.circumference() / pc.area();</pre>
</blockquote>
<p>	This works just as if the <tt class="literal">area()</tt> and
	<tt class="literal">circumference()</tt> methods were defined in
	<tt class="literal">PlaneCircle</tt> itself. </p>
<p>	Another feature of subclassing is that every
	<tt class="literal">PlaneCircle</tt> object is also a perfectly
	legal <tt class="literal">Circle</tt> object. Thus, if
	<tt class="literal">pc</tt> refers to a
	<tt class="literal">PlaneCircle</tt> object, we can assign it to a
	<tt class="literal">Circle</tt> variable and forget all about
	its extra positioning capabilities: 
</p>
<blockquote>
<pre class="programlisting">PlaneCircle pc = new PlaneCircle(1.0, 0.0, 0.0);  // Unit circle at the origin
Circle c = pc;     // Assigned to a Circle variable without casting</pre>
</blockquote>
<p>
	This assignment of a <tt class="literal">PlaneCircle</tt>
	object to a <tt class="literal">Circle</tt> variable can be done
	without a cast. As we discussed in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2, "Java Syntax

from the Ground Up"</a>,
	this is a
	widening conversion and is always legal. The value held in
	the <tt class="literal">Circle</tt> variable <tt class="literal">c</tt> is
	still a valid <tt class="literal">PlaneCircle</tt> object, but the
	compiler cannot know this for sure, so it doesn't allow us to do
	the opposite (narrowing) conversion without a cast:
</p>
<blockquote>
<pre class="programlisting">// Narrowing conversions require a cast (and a runtime check by the VM)
PlaneCircle pc2 = (PlaneCircle) c;  
boolean origininside = ((PlaneCircle) c).isInside(0.0, 0.0);</pre>
</blockquote>
<h3 class="sect3">3.4.1.1. Final classes</h3>
<p>
<a name="INDEX-451"></a><a name="INDEX-452"></a>

	  When a class is declared with the <tt class="literal">final</tt>
	  modifier, it means that it cannot be extended or subclassed. <tt class="literal">java.lang.System</tt> is an example of a
	  <tt class="literal">final</tt> class. Declaring a class
	  <tt class="literal">final</tt> prevents unwanted extensions to the
	  class, and it also allows the compiler to make some
	  optimizations when invoking the methods of a class. We'll
	  explore this in more detail later in this chapter, when 
	  we talk about method overriding. </p>
<h3 class="sect2">3.4.2. Superclasses, Object, and the Class Hierarchy</h3>
<p>
<a name="INDEX-453"></a>

	In our example, <tt class="literal">PlaneCircle</tt> is a subclass
	of <tt class="literal">Circle</tt>. We can also say that
	<tt class="literal">Circle</tt> is the superclass
	of <tt class="literal">PlaneCircle</tt>. The superclass of a class
	is specified in its <tt class="literal">extends</tt> clause:
      </p>
<blockquote>
<pre class="programlisting">public class PlaneCircle extends Circle { ... }</pre>
</blockquote>
<p>
<a name="INDEX-454"></a><a name="INDEX-455"></a>


	Every class you define has a superclass. If you do not specify
	the superclass with an <tt class="literal">extends</tt> clause, the
	superclass is the class <tt class="literal">java.lang.Object</tt>. <tt class="literal">Object</tt> is a special class for a couple of
	reasons:
      </p>
<ul>
<li>
<p>	    It is the only class in Java that does not have a superclass. </p>
</li>
<li>
<p>	    All Java classes inherit the methods of <tt class="literal">Object</tt>. </p>
</li>
</ul>
<p>
<a name="INDEX-456"></a><a name="INDEX-457"></a>

	Because every class has a superclass, classes in Java form a
	class hierarchy, which can be represented
	as a tree with <tt class="literal">Object</tt> at its root. <a href="#javanut3-ch-3-fig-1">Figure 3-1</a> shows a class hierarchy diagram
	that includes our <tt class="literal">Circle</tt> and
	<tt class="literal">PlaneCircle</tt> classes, as well as some of the
	standard classes from the Java API. Every API quick-reference chapter in <a href="part2.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/part2.htm">Part 2, "API Quick Reference"</a> includes a
	class-hierarchy diagram for the classes it documents. </p>
<a name="javanut3-ch-3-fig-1"></a>
<div class="figure">
<img alt="figure" src="figs/JN3_0301.gif" webstripperlinkwas="figs/JN3_0301.gif"></div>
<h4 class="objtitle">Figure 3-1. A class hierarchy diagram</h4>
<h3 class="sect2">3.4.3. Subclass Constructors</h3>
<p>
<a name="INDEX-458"></a><a name="INDEX-459"></a>

	Look again at the <tt class="literal">PlaneCircle()</tt> constructor
	method of <a href="#javanut3-ch-3-ex-planecircle">Example 3-3</a>:
</p>
<blockquote>
<pre class="programlisting">public PlaneCircle(double r, double x, double y) {
  super(r);       // Invoke the constructor of the superclass, Circle()
  this.cx = x;    // Initialize the instance field cx
  this.cy = y;    // Initialize the instance field cy
}</pre>
</blockquote>
<p>	This constructor explicitly initializes the
	<tt class="literal">cx</tt> and <tt class="literal">cy</tt> fields
	newly defined by <tt class="literal">PlaneCircle</tt>, but it relies
	on the superclass <tt class="literal">Circle()</tt> constructor to
	initialize the inherited fields of the class. To invoke the
	superclass constructor, our constructor	
	calls <tt class="literal">super()</tt>. <tt class="literal">super</tt> is a reserved word in Java. One of its
	uses is to invoke the constructor method of a superclass from
	within the constructor method of a subclass. This use is
	analogous to the use of <tt class="literal">this()</tt> to invoke one
	constructor method of a class from within another constructor
	method of the same class. Using <tt class="literal">super()</tt> to
	invoke a constructor is subject to the same restrictions as
	using <tt class="literal">this()</tt> to invoke a constructor:
      </p>
<ul>
<li>
<p>
<tt class="literal">super()</tt> can be used in this way only within a
	    constructor method. </p>
</li>
<li>
<p>	    The call to the superclass constructor must appear as the
	    first statement within the constructor method, 
	    even before local variable declarations. </p>
</li>
</ul>
<p>	The arguments passed to <tt class="literal">super()</tt> must match
	the parameters of the superclass constructor. If the
	superclass defines more than one constructor, 
	<tt class="literal">super()</tt> can be used to invoke any one of
	them, depending on the arguments passed. </p>
<h3 class="sect2">3.4.4. Constructor Chaining and the Default Constructor</h3>
<p>
<a name="INDEX-460"></a><a name="INDEX-461"></a><a name="INDEX-462"></a>


	Java guarantees that the constructor method of a class is called
	whenever an instance of that class is created. It also
	guarantees that the constructor is called whenever an instance of
	any subclass is created. In order to guarantee this second
	point, Java must ensure that every constructor method calls its
	superclass constructor method. Thus, if the first statement in a
	constructor does not explicitly invoke another constructor with
	<tt class="literal">this()</tt> or <tt class="literal">super()</tt>, 
	Java implicitly inserts the call
	<tt class="literal">super()</tt>; that is, it calls the
	superclass constructor with no arguments. If the
	superclass does not have a constructor that takes no arguments,
	this implicit invocation causes a compilation error. </p>
<p>	Consider what happens when we create a new instance of the
	<tt class="literal">PlaneCircle</tt> class. First, the
	<tt class="literal">PlaneCircle</tt> constructor is invoked. This
	constructor explicitly calls <tt class="literal">super(r)</tt> to
	invoke a <tt class="literal">Circle</tt> constructor, and that
	<tt class="literal">Circle()</tt> constructor implicitly calls
	<tt class="literal">super()</tt> to invoke the constructor of its
	superclass, <tt class="literal">Object</tt>. The body of the
	<tt class="literal">Object</tt> constructor runs first. When it
	returns, the body of the <tt class="literal">Circle()</tt> constructor
	runs. Finally, when the call to
	<tt class="literal">super(r)</tt> returns, the remaining statements of
	the <tt class="literal">PlaneCircle()</tt> constructor are executed. </p>
<p>	What all this means is that constructor calls are
	chained; any time an object is created, a sequence of
	constructor methods is invoked, from subclass to superclass on
	up to <tt class="literal">Object</tt> at the root of the class
	hierarchy. Because a superclass constructor is always invoked
	as the first statement of its subclass constructor, the body of
	the <tt class="literal">Object</tt> constructor always runs first,
	followed by the constructor of its subclass and on down the class
	hierarchy to the class that is being instantiated. There is
	an important implication here; when 
	a constructor is invoked, it can count on the
	fields of its superclass to be initialized. </p>
<h3 class="sect3">3.4.4.1. The default constructor</h3>
<p>	  There is one missing piece in the previous 
	  description of constructor
	  chaining. If a constructor does not invoke a
	  superclass constructor, Java does so implicitly. But what
	  if a class is declared without a constructor?  In
	  this case, Java implicitly adds a constructor to the class. This default constructor does nothing but invoke the
	  superclass constructor. For example, if we don't declare a constructor for the
	  <tt class="literal">PlaneCircle</tt> class, Java implicitly
	  inserts this constructor:
</p>
<blockquote>
<pre class="programlisting">public PlaneCircle() { super(); }</pre>
</blockquote>
<p>
</p>
<p>	  If the superclass, <tt class="literal">Circle</tt>, doesn't
	  declare a no-argument constructor, the
	  <tt class="literal">super()</tt> call in this automatically inserted
	  default constructor for <tt class="literal">PlaneCircle()</tt>
	  causes a compilation error. In general, if a class does not define a
	  no-argument constructor, all its subclasses must define
	  constructors that explicitly invoke the superclass constructor
	  with the necessary arguments. </p>
<p>	  If a class does not declare any constructors, it is given a
	  no-argument constructor by default. Classes declared
	  <tt class="literal">public</tt> are given <tt class="literal">public</tt>
	  constructors. All other classes are given a default constructor
	  that is declared without any visibility modifier:
	  such a constructor has default visibility. (The
	  notion of visibility is 
	  explained later in this chapter.)  If you are creating 
	  a <tt class="literal">public</tt> class that should not be publicly
	  instantiated, you should declare at least one
	  non-<tt class="literal">public</tt> constructor to prevent the
	  insertion of a default <tt class="literal">public</tt> constructor. Classes that should never be instantiated (such as
	  <tt class="literal">java.lang.Math</tt> or
	  <tt class="literal">java.lang.System</tt>) should define a
	  <tt class="literal">private</tt> constructor. Such a constructor can
	  never be invoked from outside of the class, but it prevents the
	  automatic insertion of the default constructor. </p>
<h3 class="sect3">3.4.4.2. Finalizer chaining?</h3>
<p>
<a name="INDEX-463"></a>

	  You might assume that, since Java chains constructor methods,
	  it also automatically chains the finalizer methods for an
	  object. In other words, you might assume that the finalizer method
	  of a class automatically invokes the finalizer of its
	  superclass, and so on. In fact, Java does <em class="emphasis">not</em> do
	  this. When you write a <tt class="literal">finalize()</tt> method,
	  you must explicitly invoke the superclass finalizer. (You
	  should do this even if you know that the superclass does not
	  have a finalizer because a future implementation of the
	  superclass might add a finalizer.)  
	</p>
<p>	  As we saw in our example finalizer earlier in the chapter, you
	  can invoke a superclass method with a special syntax that uses
	  the <tt class="literal">super</tt> keyword:
</p>
<blockquote>
<pre class="programlisting">// Invoke the finalizer of our superclass. super.finalize();</pre>
</blockquote>
<p>
	  We'll discuss this syntax in more detail when we consider
	  method overriding. In practice, the need for
	  finalizer methods, and thus finalizer chaining, rarely arises.
<a name="INDEX-464"></a>
</p>
<h3 class="sect2">3.4.5. Shadowing Superclass Fields</h3>
<p>
<a name="INDEX-465"></a><a name="INDEX-466"></a><a name="INDEX-467"></a>


	For the sake of example, imagine that our
	<tt class="literal">PlaneCircle</tt> class needs to know the distance
	between the center of the circle and the origin (0,0). We can
	add another instance field to hold this value:
</p>
<blockquote>
<pre class="programlisting">public double r;</pre>
</blockquote>
<p>
	Adding the following line to the constructor computes the
	value of the field:
</p>
<blockquote>
<pre class="programlisting">this.r = Math.sqrt(cx*cx + cy*cy);  // Pythagorean Theorem</pre>
</blockquote>
<p>
	But wait, this new field <tt class="literal">r</tt> has the same name
	as the radius field <tt class="literal">r</tt> in the
	<tt class="literal">Circle</tt> superclass. When this happens, we say
	that the field <tt class="literal">r</tt> of
	<tt class="literal">PlaneCircle</tt><em class="emphasis">shadows</em> the
	field <tt class="literal">r</tt> of <tt class="literal">Circle</tt>. (This
	is a contrived example, of course: the new field should really
	be called <tt class="literal">distanceFromOrigin</tt>. Although you
	should attempt to avoid it, subclass fields do sometimes shadow
	fields of their superclass.) 
      </p>
<p>	With this new definition of <tt class="literal">PlaneCircle</tt>, the
	expressions <tt class="literal">r</tt> and <tt class="literal">this.r</tt>
	both refer to the field of <tt class="literal">PlaneCircle</tt>. How, then, can we refer
	to the field <tt class="literal">r</tt> of <tt class="literal">Circle</tt>
	that holds the radius of the circle?  There is a special syntax
	for this that uses the <tt class="literal">super</tt> keyword:
      </p>
<blockquote>
<pre class="programlisting">r        // Refers to the PlaneCircle field
this.r   // Refers to the PlaneCircle field
super.r  // Refers to the Circle field</pre>
</blockquote>
<p>	Another way to refer to a shadowed field is to cast
	<tt class="literal">this</tt> (or any instance of the class) to the
	appropriate superclass and then access the field:
</p>
<blockquote>
<pre class="programlisting">((Circle) this).r   // Refers to field r of the Circle class</pre>
</blockquote>
<p>
	This casting technique is particularly useful when you need to
	refer to a shadowed field defined in a class that is not the
	immediate superclass. Suppose, for example, that classes
	<tt class="literal">A</tt>, <tt class="literal">B</tt>, and
	<tt class="literal">C</tt> all define a field named
	<tt class="literal">x</tt> and that <tt class="literal">C</tt> is a
	subclass of <tt class="literal">B</tt>, which is a subclass of
	<tt class="literal">A</tt>. Then, in the methods of class
	<tt class="literal">C</tt>, you can refer to these different
	fields as follows:
</p>
<blockquote>
<pre class="programlisting">x                // Field x in class C
this.x           // Field x in class C
super.x          // Field x in class B
((B)this).x      // Field x in class B
((A)this).x      // Field x in class A
super.super.x    // Illegal; does not refer to x in class A</pre>
</blockquote>
<p>
	You cannot refer to a shadowed field
	<tt class="literal">x</tt> in the superclass of a superclass with
	<tt class="literal">super.super.x</tt>. This is not legal syntax. </p>
<p>	Similarly, if you have an instance <tt class="literal">c</tt> of class
	<tt class="literal">C</tt>, you can refer to the three fields named
	<tt class="literal">x</tt> like this:
</p>
<blockquote>
<pre class="programlisting">c.x              // Field x of class C 
((B)c).x         // Field x of class B
((A)c).x         // Field x of class A</pre>
</blockquote>
<p>	So far, we've been discussing instance fields. Class
	fields can also be shadowed. You can use the same
	<tt class="literal">super</tt> syntax to refer to the shadowed value
	of the field, but this is never necessary since you can
	always refer to a class field by prepending the name of the
	desired class. Suppose that the implementer of
	<tt class="literal">PlaneCircle</tt> decides that the
	<tt class="literal">Circle.PI</tt> field does not express &pi; to
	enough decimal places. She can define her own class field
	<tt class="literal">PI</tt>: 
</p>
<blockquote>
<pre class="programlisting">public static final double PI = 3.14159265358979323846;</pre>
</blockquote>
<p>
	Now, code in <tt class="literal">PlaneCircle</tt> can use this more
	accurate value with the expressions <tt class="literal">PI</tt> or
	<tt class="literal">PlaneCircle.PI</tt>. It can also refer to
	the old, less accurate value with the expressions
	<tt class="literal">super.PI</tt> and <tt class="literal">Circle.PI</tt>. Note, however, that the <tt class="literal">area()</tt> and
	<tt class="literal">circumference()</tt> methods inherited by
	<tt class="literal">PlaneCircle</tt> are defined in the
	<tt class="literal">Circle</tt> class, so they use the value
	<tt class="literal">Circle.PI</tt>, even though that value is shadowed
	now by <tt class="literal">PlaneCircle.PI</tt>. </p>
<h3 class="sect2">3.4.6. Overriding Superclass Methods</h3>
<p>
<a name="INDEX-468"></a><a name="INDEX-469"></a><a name="INDEX-470"></a><a name="INDEX-471"></a><a name="INDEX-472"></a>

	When a class defines an instance method using the same name,
	return type, and parameters as a method in its superclass, that
	method <em class="emphasis">overrides</em> the method of the
	superclass. When the method is invoked for an object of the
	class, it is the new definition of the method that is called,
	not the superclass's old definition. </p>
<p>	Method overriding is an important and useful technique in
	object-oriented programming. <tt class="literal">PlaneCircle</tt>
	does not override either of the methods defined by
	<tt class="literal">Circle</tt>, but suppose we define another subclass of
	<tt class="literal">Circle</tt>, named
	<tt class="literal">Ellipse</tt>.<a href="#FOOTNOTE-3">[3]</a>  In this case, 
	it is important for
	<tt class="literal">Ellipse</tt> to override the
	<tt class="literal">area()</tt> and <tt class="literal">circumference()</tt>
	methods of <tt class="literal">Circle</tt>, since the formulas used
	to compute the area and circumference of a circle do not work
	for ellipses. </p>
<blockquote class="footnote">
<a name="FOOTNOTE-3"></a>
<p>[3]Mathematical purists
	may argue that since all circles are ellipses,
	<tt class="literal">Ellipse</tt> should be the superclass and
	<tt class="literal">Circle</tt> the subclass. A pragmatic engineer
	might counterargue that circles can be represented with fewer
	instance fields, so <tt class="literal">Circle</tt> objects should
	not be burdened by inheriting unnecessary fields from
	<tt class="literal">Ellipse</tt>. In any case, this is a useful
	example here.</p>
</blockquote>
<p>	The upcoming discussion of method overriding considers only instance
	methods. Class methods behave quite differently, and there 
	isn't much to say. Like fields, class methods
	can be shadowed by a subclass, but not overridden. As
	I noted earlier in this chapter, it is good programming style to
	always prefix a class method invocation with the name of the
	class in which it is defined. If you consider the class name part of the class method name, the two methods have
	different names, so nothing is actually shadowed at all. It is, however, illegal for a class method to shadow an
	instance method. </p>
<p>	Before we go any further with the discussion of method
	overriding, you need to 
	be sure you understand the difference between
	method overriding and method overloading. As we discussed in
	<a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2, "Java Syntax

from the Ground Up"</a>, method
	overloading refers to the practice of defining multiple methods
	(in the same class) that have the same name, but different
	parameter lists. This is very different from method overriding,
	so don't get them confused. </p>
<h3 class="sect3">3.4.6.1. Overriding is not shadowing</h3>
<p>
<a name="INDEX-473"></a><a name="INDEX-474"></a>
	  Although Java treats the fields and methods of a class
	  analogously in many ways, method overriding is not like
	  field shadowing at all. You can refer to shadowed fields
	  simply by casting an object to an instance of the appropriate
	  superclass, but you cannot invoke overridden instance methods
	  with this technique. The following code 
	  illustrates this crucial
	  difference:
	</p>
<blockquote>
<pre class="programlisting">class A {                          // Define a class named A
  int i = 1;                       // An instance field
  int f() { return i; }            // An instance method
  static char g() { return 'A'; }  // A class method
}

class B extends A {                // Define a subclass of A
  int i = 2;                       // Shadows field i in class A
  int f() { return -i; }           // Overrides instance method f in class A
  static char g() { return 'B'; }  // Shadows class method g() in class A
}

public class OverrideTest {
  public static void main(String args[]) {
    B b = new B();               // Creates a new object of type B
    System.out.println(b.i);     // Refers to B.i; prints 2
    System.out.println(b.f());   // Refers to B.f(); prints -2
    System.out.println(b.g());   // Refers to B.g(); prints B
    System.out.println(B.g());   // This is a better way to invoke B.g()

    A a = (A) b;                 // Casts b to an instance of class A
    System.out.println(a.i);     // Now refers to A.i; prints 1
    System.out.println(a.f());   // Still refers to B.f(); prints -2
    System.out.println(a.g());   // Refers to A.g(); prints A
    System.out.println(A.g());   // This is a better way to invoke A.g()
  }
}</pre>
</blockquote>
<p>	  While this difference between method overriding and field
	  shadowing may seem surprising at first, a little thought makes
	  the purpose clear. Suppose we have a bunch of
	  <tt class="literal">Circle</tt> and <tt class="literal">Ellipse</tt>
	  objects we are manipulating. To keep track of the
	  circles and ellipses, we store them in an array of type
	  <tt class="literal">Circle[]</tt>. (We can do this because 
	  <tt class="literal">Ellipse</tt> is a subclass of
	  <tt class="literal">Circle</tt>, so all <tt class="literal">Ellipse</tt>
	  objects are legal <tt class="literal">Circle</tt> objects.)  
	  When we loop through the elements of this array, we don't have
	  to know or care whether the element is actually a
	  <tt class="literal">Circle</tt> or an <tt class="literal">Ellipse</tt>. What we do care about very much, however, is that the correct
	  value is computed when we invoke the <tt class="literal">area()</tt>
	  method of any element of the array. In other words, 
	  we don't want to
	  use the formula for the area of a circle when the object is
	  actually an ellipse!
	  Seen in this context, it is not surprising at all that method
	  overriding is handled differently by Java than field
	  shadowing. </p>
<h3 class="sect3">3.4.6.2. Dynamic method lookup</h3>
<p>
<a name="INDEX-475"></a>

	  If we have a <tt class="literal">Circle[]</tt> array that holds
	  <tt class="literal">Circle</tt> and <tt class="literal">Ellipse</tt>
	  objects, how does the compiler know whether to call the
	  <tt class="literal">area()</tt> method of the
	  <tt class="literal">Circle</tt> class or the
	  <tt class="literal">Ellipse</tt> class for any given item in the
	  array?  In fact, the compiler does not know this because 
	  it cannot know it. The
	  compiler knows that it does not know, however, and produces
	  code that uses dynamic method lookup at runtime. When the
	  interpreter runs the code, it looks up the appropriate
	  <tt class="literal">area()</tt> method to call for each of the
	  objects in the array. That is, when the interpreter interprets the
	  expression <tt class="literal">o.area()</tt>, it checks the actual
	  type of the object referred to by the variable
	  <tt class="literal">o</tt> and then finds the
	  <tt class="literal">area()</tt> method that is appropriate for that
	  type. It does not simply use the <tt class="literal">area()</tt>
	  method that is statically associated with the type of the
	  variable <tt class="literal">o</tt>. This process of
	  dynamic method lookup is sometimes also called virtual method
	  invocation.<a href="#FOOTNOTE-4">[4]</a>
</p>
<blockquote class="footnote">
<a name="FOOTNOTE-4"></a>
<p>[4]<a name="INDEX-476"></a>
C++ programmers
	  should note that dynamic method lookup is what C++ does for
	  <tt class="literal">virtual</tt> functions. An important difference
	  between Java and C++ is that Java does not have a
	  <tt class="literal">virtual</tt> keyword. In Java, methods are
	  virtual by default.</p>
</blockquote>
<h3 class="sect3">3.4.6.3. Final methods and static method lookup</h3>
<p>
<a name="INDEX-477"></a><a name="INDEX-478"></a><a name="INDEX-479"></a>

	  Virtual method invocation is fast, but method invocation is
	  faster when no dynamic lookup is necessary at runtime. Fortunately, there are a number of situations in which Java 
	  does not need to use dynamic method lookup. In particular, if a method is declared with 
	  the <tt class="literal">final</tt>
	  modifier, it means that the method definition is the final
	  one; it cannot be overridden by any subclasses. If a
	  method cannot be overridden, the compiler knows that
	  there is only one version of the method, and dynamic method
	  lookup is not necessary.<a href="#FOOTNOTE-5">[5]</a>
	  In addition, all 
	  methods of a <tt class="literal">final</tt> class are themselves
	  implicitly final and cannot be overridden. As we'll discuss
	  later in this chapter, <tt class="literal">private</tt> methods are
	  not inherited by subclasses and, therefore, cannot be
	  overridden (i.e., all <tt class="literal">private</tt> methods
	  are implicitly <tt class="literal">final</tt>). Finally, 
	  class methods behave like fields (i.e., they can be
	  shadowed by subclasses but not overridden). Taken together,
	  this means that all methods
	  of a class that is declared <tt class="literal">final</tt>, as well as
	  all methods
	  that are <tt class="literal">final</tt>, <tt class="literal">private</tt>,
	  or <tt class="literal">static</tt>, are invoked without dynamic
	  method lookup. These methods are also candidates for inlining
	  at runtime by a just-in-time compiler ( JIT) or similar
	  optimization tool. </p>
<blockquote class="footnote">
<a name="FOOTNOTE-5"></a>
<p>[5]In this sense, the
	  <tt class="literal">final</tt> modifier is the opposite of the
	  <tt class="literal">virtual</tt> modifier in C++. All
	  non-<tt class="literal">final</tt> methods in Java are
	  <tt class="literal">virtual</tt>.</p>
</blockquote>
<h3 class="sect3">3.4.6.4. Invoking an overridden method</h3>
<p>
<a name="INDEX-480"></a>

	  We've seen the important differences between method overriding
	  and field shadowing. Nevertheless, the Java syntax for
	  invoking an overridden method is quite similar to the syntax for
	  accessing a shadowed field: both use the
	  <tt class="literal">super</tt> keyword. The following code illustrates:
	</p>
<blockquote>
<pre class="programlisting">class A {
  int i = 1;                // An instance field shadowed by subclass B
  int f() { return i; }     // An instance method overridden by subclass B
}
class B extends A {
  int i;                    // This field shadows i in A
  int f() {                 // This method overrides f() in A
    i = super.i + 1;        // It can retrieve A.i like this
    return super.f() + i;   // It can invoke A.f() like this
  }
}</pre>
</blockquote>
<p>	  Recall that when you use <tt class="literal">super</tt> to refer to
	  a shadowed field, it is the same as casting
	  <tt class="literal">this</tt> to the superclass type and accessing
	  the field through that. Using
	  <tt class="literal">super</tt> to invoke an overridden method,
	  however, is not
	  the same as casting <tt class="literal">this</tt>. In other words,
	  in the previous code,
	  the expression <tt class="literal">super.f()</tt> is not the
	  same as <tt class="literal">((A)this).f()</tt>. </p>
<p>	  When the interpreter invokes an instance method with this
	  <tt class="literal">super</tt> syntax, a modified form of dynamic
	  method lookup is performed. The first step, as in regular
	  dynamic method lookup, is to determine the actual class of the
	  object through which the method is invoked. Normally, the
	  dynamic search for an appropriate method definition would
	  begin with this class. When a method is invoked with the
	  <tt class="literal">super</tt> syntax, however, the search begins at
	  the superclass of the class. If the superclass implements the
	  method directly, that version of the method is invoked. If the superclass inherits the method, the inherited
	  version of the method is invoked. </p>
<p>	  Note that the <tt class="literal">super</tt> keyword invokes the
	  most immediately overridden version of a method. Suppose
	  class <tt class="literal">A</tt> has a subclass
	  <tt class="literal">B</tt> that has a subclass
	  <tt class="literal">C</tt>, and all three classes define the same
	  method <tt class="literal">f()</tt>. Then the method
	  <tt class="literal">C.f()</tt> can invoke the method
	  <tt class="literal">B.f()</tt>, which it overrides directly, with
	  <tt class="literal">super.f()</tt>. But there is no way for
	  <tt class="literal">C.f()</tt> to invoke <tt class="literal">A.f()</tt>
	  directly: <tt class="literal">super.super.f()</tt> is not legal Java
	  syntax. Of course, if <tt class="literal">C.f()</tt> invokes
	  <tt class="literal">B.f()</tt>, it is reasonable to suppose that
	  <tt class="literal">B.f()</tt> might also invoke
	  <tt class="literal">A.f()</tt>. This kind of chaining is
	  relatively common when working with overridden methods: it is a
	  way of augmenting the behavior of a method without replacing
	  the method entirely. We saw this technique in the the example
	  <tt class="literal">finalize()</tt> method shown earlier in the
	  chapter: that method invoked
	  <tt class="literal">super.finalize()</tt> to run its superclass
	  finalization method. </p>
<p>	  Don't confuse the use of <tt class="literal">super</tt> to invoke
	  an overridden method with the <tt class="literal">super()</tt>
	  method call used in constructor methods to invoke a superclass
	  constructor. Although they both use the same keyword, these
	  are two entirely different syntaxes. In particular, you can
	  use <tt class="literal">super</tt> to invoke an overridden method
	  anywhere in the overriding method, while you can use
	  <tt class="literal">super()</tt> only to invoke a superclass constructor
	  as the very first statement of a constructor. </p>
<p>	  It is also important to remember that <tt class="literal">super</tt> can
	  be used only to invoke an overridden method from within the
	  method that overrides it. Given an <tt class="literal">Ellipse</tt>
	  object <tt class="literal">e</tt>, there is no way for a
	  program that uses an object (with or without
	  the <tt class="literal">super</tt> syntax) to invoke the
	  <tt class="literal">area()</tt> method defined by the
	  <tt class="literal">Circle</tt> class on this object. </p>
<p>	  I've already explained that class methods can shadow class
	  methods in superclasses, but cannot override them. The
	  preferred way to invoke class methods is to include the
	  name of the class in the invocation. If you do not do this,
	  however, you can use the <tt class="literal">super</tt> syntax to
	  invoke a shadowed class method, just as you would invoke an
	  instance method or refer to a shadowed
	  field.
<a name="INDEX-481"></a><a name="INDEX-482"></a><a name="INDEX-483"></a><a name="INDEX-484"></a><a name="INDEX-485"></a><a name="INDEX-486"></a>
</p>

<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch03_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch03_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_05.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">3.3. Destroying and Finalizing Objects</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">3.5. Data Hiding and Encapsulation</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
