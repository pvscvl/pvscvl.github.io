<html>
<head>
<title>Primitive Data Types (Java in a Nutshell)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David Flanagan">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-487-8E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Primitive Data Types">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm" alt="Java Enterprise in a Nutshell"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch02_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2: Java Syntax

from the Ground Up</a></td><td align="right" valign="top" width="172"><a href="ch02_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_05.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY --><h2 class="sect1">2.4. Primitive Data Types</h2>
<p>
<a name="INDEX-190"></a><a name="INDEX-191"></a>

      Java supports eight basic data types known as <em class="emphasis">primitive
      types</em>. In addition, it supports classes and arrays as
      composite data types, or reference types. Classes and arrays
      are documented later in this chapter. The primitive types are: a
      boolean type, a character type, four integer types, and two
      floating-point types. The four integer types and the two
      floating-point types differ in the number of bits that
      represent them, and therefore in the range of numbers they
      can represent. <a href="#javanut3-ch-2-tab-2">Table 2-2</a> summarizes
      these primitive data types. </p>
<a name="javanut3-ch-2-tab-2"></a>
<h4 class="objtitle">Table 2-2. Java Primitive Data Types</h4>
<table border="1">
<tr>
<th>Type</th><th>Contains</th><th>Default</th><th>Size</th><th>Range</th>
</tr>
<tr>
<td><tt class="literal">boolean</tt></td><td><tt class="literal">true</tt> or <tt class="literal">false</tt></td><td><tt class="literal">false</tt></td><td>1 bit</td><td>NA</td>
</tr>
<tr>
<td><tt class="literal">char</tt></td><td>Unicode character</td><td><tt class="literal">\u0000</tt></td><td>16 bits</td><td><tt class="literal">\u0000</tt> to <tt class="literal">\uFFFF</tt></td>
</tr>
<tr>
<td><tt class="literal">byte</tt></td><td>Signed integer</td><td>0</td><td>8 bits</td><td>-128 to 127</td>
</tr>
<tr>
<td><tt class="literal">short</tt></td><td>Signed integer</td><td>0</td><td>16 bits</td><td>-32768 to 32767</td>
</tr>
<tr>
<td><tt class="literal">int</tt></td><td>Signed integer</td><td>0</td><td>32 bits</td><td>-2147483648 to 2147483647</td>
</tr>
<tr>
<td><tt class="literal">long</tt></td><td>Signed integer</td><td>0</td><td>64 bits</td><td>
<p>        -9223372036854775808 to


	    9223372036854775807
        </p>
</td>
</tr>
<tr>
<td><tt class="literal">float</tt></td><td>
<p>
        IEEE 754


	    floating point
        </p>
</td><td>0.0</td><td>32 bits</td><td>
<p>        &plusmn;1.4E-45 to


	    &plusmn;3.4028235E+38
        </p>
</td>
</tr>
<tr>
<td><tt class="literal">double</tt></td><td>
<p>        IEEE 754


	    floating point
        </p>
</td><td>0.0</td><td>64 bits</td><td>
<p>        &plusmn;4.9E-324 to


	    &plusmn;1.7976931348623157E+308
        </p>
</td>
</tr>
</table>
<h3 class="sect2">2.4.1. The boolean Type</h3>
<p>
<a name="INDEX-192"></a>

	The <tt class="literal">boolean</tt> type represents a truth value. There are only two possible values of this type, representing
	the two boolean states: on or off, yes or no,
	true or false. Java reserves the words <tt class="literal">true</tt>
	and <tt class="literal">false</tt> to represent these two boolean
	values. </p>
<p>	C and C++ programmers should note that Java is quite strict about
	its <tt class="literal">boolean</tt> type: <tt class="literal">boolean</tt>
	values can never be converted to or from other data types. In
	particular, a <tt class="literal">boolean</tt> is not an integral
	type, and integer values cannot be used in place of a
	<tt class="literal">boolean</tt>. In other words, you cannot take
	shortcuts such as the following in Java:
</p>
<blockquote>
<pre class="programlisting">if (o) {
  while(i) {
  }
}</pre>
</blockquote>
<p>
	Instead, Java forces you to write cleaner code by explicitly
	stating the comparisons you want:
</p>
<blockquote>
<pre class="programlisting">if (o != null) {
  while(i != 0) {
  }
}</pre>
</blockquote>
<h3 class="sect2">2.4.2. The char Type</h3>
<p>
<a name="INDEX-193"></a>

	The <tt class="literal">char</tt> type represents Unicode characters. It surprises many experienced programmers to learn that
	Java <tt class="literal">char</tt> values are 16 bits long, but in
	practice this fact is totally transparent. To include a character
	literal in a Java program, simply place it between single
	quotes (apostrophes):
</p>
<blockquote>
<pre class="programlisting">char c = 'A';</pre>
</blockquote>
<p>	You can, of course, use any Unicode character as a character
	literal, and you can use the <tt class="literal">\u</tt> Unicode
	escape sequence. In addition, Java supports a number of other
	escape sequences that make it easy both to represent commonly used
	nonprinting ASCII characters such as newline and to
	escape certain punctuation characters that have special meaning
	in Java. For example:
</p>
<blockquote>
<pre class="programlisting">char tab = '\t', apostrophe = '\'', nul = '\000', aleph='\u05D0';</pre>
</blockquote>
<p>
<a href="#javanut3-ch-2-tab-3">Table 2-3</a> lists the escape characters
	that can be used in <tt class="literal">char</tt> literals. These
	characters can also be used in string literals, which are
	covered later in this chapter. </p>
<a name="javanut3-ch-2-tab-3"></a>
<h4 class="objtitle">Table 2-3. Java Escape Characters</h4>
<table border="1">
<tr>
<th>Escape Sequence</th><th>Character Value</th>
</tr>
<tr>
<td><tt class="literal">\b</tt></td><td>Backspace</td>
</tr>
<tr>
<td><tt class="literal">\t</tt></td><td>Horizontal tab</td>
</tr>
<a name="INDEX-194"></a>
<tr>
<td><tt class="literal">\n</tt></td><td>Newline</td>
</tr>
<tr>
<td><tt class="literal">\f</tt></td><td>Form feed</td>
</tr>
<tr>
<td><tt class="literal">\r</tt></td><td>Carriage return</td>
</tr>
<tr>
<td><tt class="literal">\"</tt></td><td>Double quote</td>
</tr>
<tr>
<td><tt class="literal">\'</tt></td><td>Single quote</td>
</tr>
<tr>
<td><tt class="literal">\\</tt></td><td>Backslash</td>
</tr>
<tr>
<td><tt class="literal">\</tt><em class="replaceable">xxx</em></td><td>
<p>		  The Latin-1 character with the encoding
		  <em class="replaceable">xxx</em>, where
		  <em class="replaceable">xxx</em> 
		  is an octal (base 8) number between 000 and 377. The
		  forms <tt class="literal">\</tt><em class="replaceable">x</em>
		  and <tt class="literal">\</tt><em class="replaceable">xx</em>
		  are also legal, as in <tt class="literal">'\0'</tt>, but are
		  not recommended because they can cause difficulties in
		  string constants where the escape sequence is followed
		  by a regular digit. </p>
</td>
</tr>
<tr>
<td><tt class="literal">\u</tt><em class="replaceable">xxxx</em></td><td>
<p>		  The Unicode character with encoding
		  <em class="replaceable">xxxx</em>, where
		  <em class="replaceable">xxxx</em> 
		  is four hexadecimal digits. Unicode escapes can
		  appear anywhere in a Java program, not only in
		  character and string literals. </p>
</td>
</tr>
</table>
<p>
<tt class="literal">char</tt> values can be converted to and from the
	various integral types. Unlike <tt class="literal">byte</tt>,
	<tt class="literal">short</tt>, <tt class="literal">int</tt>, and
	<tt class="literal">long</tt>, however, <tt class="literal">char</tt> is an
	unsigned type. The <tt class="literal">Character</tt>
	class defines a number of useful <tt class="literal">static</tt>
	methods for working with characters, including
	<tt class="literal">isDigit()</tt>, <tt class="literal">isJavaLetter()</tt>,
	<tt class="literal">isLowerCase()</tt>, and
	<tt class="literal">toUpperCase()</tt>. </p>
<h3 class="sect2">2.4.3. Integer Types</h3>
<p>
<a name="INDEX-195"></a>

	The integer types in Java are <tt class="literal">byte</tt>,
	<tt class="literal">short</tt>, <tt class="literal">int</tt>, and
	<tt class="literal">long</tt>. As shown in <a href="#javanut3-ch-2-tab-2">Table 2-2</a>, these four types differ only in
	the number of bits and, therefore, in the range of numbers each
	type can represent. All integral types represent signed
	numbers; there is no <tt class="literal">unsigned</tt> keyword as
	there is in C and C++. </p>
<p>	Literals for each of these types are written exactly as you
	would expect: as a string of decimal digits. Although it is not
	technically part of the literal syntax, any integer literal
	can be preceded by the unary minus operator to indicate a
	negative number. Here are some legal integer literals:
</p>
<blockquote>
<pre class="programlisting">0
1
123
-42000</pre>
</blockquote>
<p>	Integer literals can also be expressed in hexadecimal or octal
	notation. A literal that begins with <tt class="literal">0x</tt> or
	<tt class="literal">0X</tt> is taken as a hexadecimal number, using
	the letters <tt class="literal">A</tt> to <tt class="literal">F</tt> (or
	<tt class="literal">a</tt> to <tt class="literal">f</tt>) as the additional
	digits required for base-16 numbers. Integer literals
	beginning with a leading <tt class="literal">0</tt> are taken to be
	octal (base-8) numbers and cannot include the digits 8 or 9. Java
	does not allow integer literals to be expressed in binary 
	(base-2) notation. Legal hexadecimal and octal literals include:
</p>
<blockquote>
<pre class="programlisting">0xff              // Decimal 255, expressed in hexadecimal
0377              // The same number, expressed in octal (base 8)
0xCAFEBABE        // A magic number used to identify Java class files</pre>
</blockquote>
<p>	Integer literals are 32-bit <tt class="literal">int</tt> values unless
	they end with the character <tt class="literal">L</tt> or
	<tt class="literal">l</tt>, in which case they are 64-bit
	<tt class="literal">long</tt> values:
</p>
<blockquote>
<pre class="programlisting">1234        // An int value
1234L       // A long value
0xffL       // Another long value</pre>
</blockquote>
<p>	Integer arithmetic in Java is modular,
	which means that it never produces an overflow or an underflow
	when you exceed the range of a given integer
	type. Instead, numbers just wrap around. For example:
</p>
<blockquote>
<pre class="programlisting">byte b1 = 127, b2 = 1;   // Largest byte is 127
byte sum = b1 + b2;      // Sum wraps to -128, which is the smallest byte</pre>
</blockquote>
<p>
	Neither the Java compiler nor the Java interpreter warns
	you in any way when this occurs. When doing integer
	arithmetic, you simply must ensure that the type you are using
	has a sufficient range for the purposes you intend. Integer division by zero and 
	modulo by zero are illegal and
	cause an <tt class="literal">ArithmeticException</tt> to be thrown. </p>
<p>	Each integer type has a corresponding wrapper class:
	<tt class="literal">Byte</tt>, <tt class="literal">Short</tt>,
	<tt class="literal">Integer</tt>, and <tt class="literal">Long</tt>. Each of
	these classes defines <tt class="literal">MIN_VALUE</tt> and
	<tt class="literal">MAX_VALUE</tt> constants that describe the range
	of the type. The classes also define useful static methods, such as
	<tt class="literal">Byte.parseByte()</tt> and
	<tt class="literal">Integer.parseInt()</tt>, for converting strings to
	integer values. </p>
<h3 class="sect2">2.4.4. Floating-Point Types</h3>
<p>
<a name="INDEX-196"></a>

	Real numbers in Java are represented with the
	<tt class="literal">float</tt> and <tt class="literal">double</tt> data
	types. As shown in <a href="#javanut3-ch-2-tab-3">Table 2-3</a>,
	<tt class="literal">float</tt> is a 32-bit, single-precision
	floating-point value, and <tt class="literal">double</tt> is a 64-bit,
	double-precision floating-point value. Both types adhere to the
	IEEE 754-1985 standard, which specifies both the format of the
	numbers and the behavior of arithmetic for the numbers. </p>
<p>	Floating-point values can be included literally in a Java
	program as an optional string of digits, followed by a decimal
	point and another string of digits. Here are some examples:
</p>
<blockquote>
<pre class="programlisting">123.45
0.0
.01</pre>
</blockquote>
<p>
	Floating-point literals can also use exponential, or scientific,
	notation, in which a number is followed by the letter
	<tt class="literal">e</tt> or <tt class="literal">E</tt> (for exponent) and
	another number. This second number represents the power of ten
	by which the first number is multiplied. For example:
</p>
<blockquote>
<pre class="programlisting">1.2345E02      // 1.2345 * 10^2, or 123.45
1e-6           // 1 * 10^-6, or 0.000001
6.02e23        // Avagadro's Number: 6.02 * 10^23</pre>
</blockquote>
<p>	Floating-point literals are <tt class="literal">double</tt> values by
	default. To include a <tt class="literal">float</tt> value literally in
	a program, follow the number by the character <tt class="literal">f</tt>
	or <tt class="literal">F</tt>:
</p>
<blockquote>
<pre class="programlisting">double d = 6.02E23;
float f = 6.02e23f;</pre>
</blockquote>
<p>
	Floating-point literals cannot be expressed in hexadecimal or
	octal notation. </p>
<p>	Most real numbers, by their very nature, cannot be represented
	exactly in any finite number of bits. Thus, it is important to
	remember that <tt class="literal">float</tt> and
	<tt class="literal">double</tt> values are only approximations of the
	numbers they are meant to represent. A <tt class="literal">float</tt>
	is a 32-bit approximation, which results in at least 6 significant
	decimal digits, and a <tt class="literal">double</tt> is a 64-bit
	approximation, which results in at least 15 significant digits. In practice, these data types are suitable for most real-number
	computations. </p>
<p>	In addition to representing ordinary numbers, the
	<tt class="literal">float</tt> and <tt class="literal">double</tt> types can
	also represent four special values: positive and negative infinity,
	zero, and NaN. The infinity values result when a floating-point
	computation produces a value that overflows the representable
	range of a <tt class="literal">float</tt> or <tt class="literal">double</tt>. When a floating-point
	computation underflows the representable range of a
	<tt class="literal">float</tt> or a <tt class="literal">double</tt>, a zero
	value results. The Java floating-point types make a
	distinction between positive zero and negative zero, depending on
	the direction from which the underflow occurred. In practice,
	positive and negative zero behave pretty much the same. Finally, the last special floating-point value is NaN, which
	stands for not-a-number. The NaN value results when an
	illegal floating-point operation, such as 0/0,
	is performed. Here are examples of statements that result
	in these special values:
</p>
<blockquote>
<pre class="programlisting">double inf = 1/0;             // Infinity
double neginf = -1/0;         // -Infinity
double negzero = -1/inf;      // Negative zero
double NaN = 0/0;             // NaN</pre>
</blockquote>
<p>
	Because the Java floating-point types can handle overflow to
	infinity and underflow to zero and have a special NaN value,
	floating-point arithmetic never throws exceptions, even when
	performing illegal operations, like dividing zero by zero or
	taking the square root of a negative number. </p>
<p>	The <tt class="literal">float</tt> and <tt class="literal">double</tt>
	primitive types have corresponding classes, named
	<tt class="literal">Float</tt> and <tt class="literal">Double</tt>. Each of
	these classes defines the following useful constants:
	<tt class="literal">MIN_VALUE</tt>, <tt class="literal">MAX_VALUE</tt>,
	<tt class="literal">NEGATIVE_INFINITY</tt>,
	<tt class="literal">POSITIVE_INFINITY</tt>, and
	<tt class="literal">NaN</tt>. </p>
<p>	The infinite floating-point values behave as you would expect. Adding or subtracting anything to or from infinity, for example, yields
	infinity. Negative zero behaves almost identically to positive
	zero, and, in fact, the <tt class="literal">= =</tt> equality operator
	reports that negative zero is equal to positive zero. The only
	way to distinguish negative zero from positive, or regular, zero
	is to divide by it. 1/0 yields positive infinity, but 1 divided by
	negative zero yields negative infinity. Finally, since NaN is
	not-a-number, the <tt class="literal">= =</tt> operator says that it
	is not equal to any other number, including itself !  To check
	whether a <tt class="literal">float</tt> or <tt class="literal">double</tt>
	value is NaN, you must use the <tt class="literal">Float.isNan()</tt>
	and <tt class="literal">Double.isNan()</tt> methods. </p>
<h3 class="sect2">2.4.5. Strings</h3>
<p>
<a name="INDEX-197"></a>


        In addition to the boolean, character, integer, and
        floating-point data types, Java also has a data type for working
        with strings of text (usually simply called <em class="emphasis">strings</em>). The
        <tt class="literal">String</tt> type is a class, however, and is not
        one of the primitive types of the language. Because strings are
        so commonly used, though, Java does have a syntax for including
        string values literally in a program. A
        <tt class="literal">String</tt> literal consists of arbitrary text
        within double quotes. For example:
</p>
<blockquote>
<pre class="programlisting">"Hello, world"
"'This' is a string!"</pre>
</blockquote>
<p>
        String literals can contain any of the escape sequences that can
        appear as <tt class="literal">char</tt> literals  (see <a href="#javanut3-ch-2-tab-3">Table 2-3</a>). Use the <tt class="literal">\"</tt>
        sequence to include a double-quote within a
        <tt class="literal">String</tt> literal. Strings and string literals
        are discussed in more detail later in this chapter. <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch04_01.htm">Chapter 4, "The Java Platform"</a>, demonstrates some of the ways you can
        work with <tt class="literal">String</tt> objects in Java. </p>
<h3 class="sect2">2.4.6. Type Conversions</h3>
<p>
<a name="INDEX-198"></a>

	Java allows conversions between integer values and
	floating-point values. In addition, 
	because every character corresponds
	to a number in the Unicode encoding, <tt class="literal">char</tt>
	types can be converted to and from the integer and
	floating-point types. In fact, <tt class="literal">boolean</tt> is
	the only primitive type that cannot be converted to or from
	another primitive type in Java. </p>
<p>
<a name="INDEX-199"></a><a name="INDEX-200"></a>

	There are two basic types of conversions. A <em class="emphasis">widening
	conversion</em> occurs when a value of one type is
	converted to a wider type--one that is represented with more bits
	and therefore has a wider range of legal values. A
	<em class="emphasis">narrowing
	conversion</em> occurs when a value is converted to a
	type that is represented with fewer bits. Java
	performs widening conversions automatically when, for example,
	you assign an <tt class="literal">int</tt> literal to a
	<tt class="literal">double</tt> variable or a
	<tt class="literal">char</tt> literal to an <tt class="literal">int</tt>
	variable. </p>
<p>	Narrowing conversions are another matter, however, and are not
	always safe. It is reasonable to convert the integer value 13 to
	a <tt class="literal">byte</tt>, for example, but it is not reasonable
	to convert 13000 to a <tt class="literal">byte</tt>, since
	<tt class="literal">byte</tt> can only hold numbers between -128 and
	127. Because you can lose data in a narrowing conversion, the
	Java compiler complains when you attempt any narrowing
	conversion, even if the value being converted would in fact fit
	in the narrower range of the specified type:
</p>
<blockquote>
<pre class="programlisting">int i = 13;
byte b = i;    // The compiler does not allow this</pre>
</blockquote>
<p>
	The one exception to this rule is that you can assign an integer
	literal (an <tt class="literal">int</tt> value) to a
	<tt class="literal">byte</tt> or <tt class="literal">short</tt> variable, if
	the literal falls within the range of the variable. </p>
<p>
<a name="INDEX-201"></a>

	If you need to perform a narrowing conversion and are
	confident you can do so without losing data or precision,
	you can force Java to perform the conversion using a language
	construct known as a <em class="emphasis">cast</em>. Perform a cast by placing the name of the desired
	type in parentheses before the value to be converted. For example:
</p>
<blockquote>
<pre class="programlisting">int i = 13;
byte b = (byte) i;   // Force the int to be converted to a byte
i = (int) 13.456;    // Force this double literal to the int 13</pre>
</blockquote>
<p>
	Casts of primitive types are most often used to convert
	floating-point values to integers. When you do this, the
	fractional part of the floating-point value is simply
	truncated (i.e., the floating-point value is rounded towards
	zero, not towards the nearest integer). The methods
	<tt class="literal">Math.round()</tt>, <tt class="literal">Math.floor()</tt>,
	and <tt class="literal">Math.ceil()</tt> perform other types of
	rounding. </p>
<p>	The <tt class="literal">char</tt> type acts like an integer type in
	most ways, so a <tt class="literal">char</tt> value can be used
	anywhere an <tt class="literal">int</tt> or <tt class="literal">long</tt>
	value is required. Recall, however, that the
	<tt class="literal">char</tt> type is <em class="emphasis">unsigned</em>,
	so it behaves differently than the <tt class="literal">short</tt>
	type, even though both of them are 16 bits wide:
	</p>
<blockquote>
<pre class="programlisting">short s = (short) 0xffff; // These bits represent the number -1
char c = '\uffff';        // The same bits, representing a Unicode character
int i1 = s;               // Converting the short to an int yields -1
int i2 = c;               // Converting the char to an int yields 65535
	</pre>
</blockquote>
<p>
<a href="#javanut3-ch-2-tab-4">Table 2-4</a> is a grid that shows which
	primitive types can be converted to which other types and how
	the conversion is performed. The letter N in the table means
	that the conversion cannot be performed. The letter Y means
	that the conversion is a widening conversion and is therefore
	performed
	automatically and implicitly by Java. The letter C means that
	the conversion is a narrowing conversion and requires an
	explicit cast. Finally, the notation Y* means that the
	conversion is an automatic widening conversion, but
	that some of the least significant digits of the value may be
	lost by the conversion. This can happen when converting an
	<tt class="literal">int</tt> or <tt class="literal">long</tt> to a
	<tt class="literal">float</tt> or <tt class="literal">double</tt>. The
	floating-point types have a larger range than the integer types,
	so any <tt class="literal">int</tt> or <tt class="literal">long</tt> can be
	represented by a <tt class="literal">float</tt> or
	<tt class="literal">double</tt>. However, the floating-point types
	are approximations of numbers and cannot always hold as many
	significant digits as the integer types.

</p>
<a name="javanut3-ch-2-tab-4"></a>
<h4 class="objtitle">Table 2-4. Java Primitive Type Conversions</h4>
<table border="1">
<tr>
<th>Convert</th><th>Convert To:</th>
</tr>
<tr>
<th>From:</th><th><tt class="literal">boolean</tt></th><th><tt class="literal">byte</tt></th><th><tt class="literal">short</tt></th><th><tt class="literal">char</tt></th><th><tt class="literal">int</tt></th><th><tt class="literal">long</tt></th><th><tt class="literal">float</tt></th><th><tt class="literal">double</tt></th>
</tr>
<tr>
<td><tt class="literal">boolean</tt></td><td>-</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td>
</tr>
<tr>
<td><tt class="literal">byte</tt></td><td>N</td><td>-</td><td>Y</td><td>C</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td>
</tr>
<tr>
<td><tt class="literal">short</tt></td><td>N</td><td>C</td><td>-</td><td>C</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td>
</tr>
<tr>
<td><tt class="literal">char</tt></td><td>N</td><td>C</td><td>C</td><td>-</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td>
</tr>
<tr>
<td><tt class="literal">int</tt></td><td>N</td><td>C</td><td>C</td><td>C</td><td>-</td><td>Y</td><td>Y*</td><td>Y</td>
</tr>
<tr>
<td><tt class="literal">long</tt></td><td>N</td><td>C</td><td>C</td><td>C</td><td>C</td><td>-</td><td>Y*</td><td>Y*</td>
</tr>
<tr>
<td><tt class="literal">float</tt></td><td>N</td><td>C</td><td>C</td><td>C</td><td>C</td><td>C</td><td>-</td><td>Y</td>
</tr>
<tr>
<td><tt class="literal">double</tt></td><td>N</td><td>C</td><td>C</td><td>C</td><td>C</td><td>C</td><td>C</td><td>-</td>
</tr>
</table>
<h3 class="sect2">2.4.7. Reference Types</h3>
<p>
<a name="INDEX-202"></a><a name="INDEX-203"></a><a name="INDEX-204"></a>

	In addition to its eight primitive types, Java defines two
	additional categories of data types: classes and arrays. Java
	programs consist of class definitions; each class defines a
	new data type that can be manipulated by Java programs. For 
	example, a
	program might define a class named <tt class="literal">Point</tt> and
	use it to store and manipulate X,Y points in a Cartesian
	coordinate system. This makes <tt class="literal">Point</tt> a new
	data type in that program. An array type represents a list of
	values of some other type. <tt class="literal">char</tt> is a data
	type, and an array of <tt class="literal">char</tt> values is another
	data type, written <tt class="literal">char[]</tt>. An array of
	<tt class="literal">Point</tt> objects is a data type, written
	<tt class="literal">Point[]</tt>. And an array of
	<tt class="literal">Point</tt> arrays is yet another type, written
	<tt class="literal">Point[][]</tt>. </p>
<p>	As you can see, there are an infinite number of possible class
	and array data types. Collectively, these data types are known
	as <em class="emphasis">reference types</em>. The reason for this name will become
	clear later in this chapter. For now, however, what is
	important to understand is that class and array types differ
	significantly from primitive types, in that they are compound, or
	composite, types. A primitive data type holds exactly one value. Classes and arrays are aggregate types that contain multiple
	values. The <tt class="literal">Point</tt> type, for example, 
	holds two <tt class="literal">double</tt> values representing the X and
	Y coordinates of the point. And <tt class="literal">char[]</tt> is
	obviously a compound type because it represents a list of
	characters. By their very nature, class and array types are more complicated
	than the primitive data types. We'll discuss classes and arrays
	in detail later in this chapter and examine classes in
	even more detail in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_01.htm">Chapter 3, "Object-Oriented Programming in Java"</a>.
<a name="INDEX-205"></a><a name="INDEX-206"></a>
</p>

<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch02_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch02_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_05.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">2.3. Identifiers and Reserved Words</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">2.5. Expressions and Operators</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
