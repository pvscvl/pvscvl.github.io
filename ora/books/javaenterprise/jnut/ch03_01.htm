<html>
<head>
<title>Object-Oriented Programming in Java (Java in a Nutshell)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David Flanagan">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-487-8E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Object-Oriented Programming in Java">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm" alt="Java Enterprise in a Nutshell"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch02_14.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_14.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="part1.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/part1.htm">Part 1: Introducing Java</a></td><td align="right" valign="top" width="172"><a href="ch03_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY --><h1 class="chapter">Chapter 3.  Object-Oriented Programming in Java</h1>
<div class="htmltoc">
<h4 class="tochead">Contents:</h4>
<p>
<a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_01.htm">The Members of a Class</a>
<br>
<a href="ch03_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_02.htm">Creating and Initializing Objects</a>
<br>
<a href="ch03_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_03.htm">Destroying and Finalizing Objects</a>
<br>
<a href="ch03_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_04.htm">Subclasses and Inheritance</a>
<br>
<a href="ch03_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_05.htm">Data Hiding and Encapsulation</a>
<br>
<a href="ch03_06.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_06.htm">Abstract Classes and Methods</a>
<br>
<a href="ch03_07.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_07.htm">Interfaces</a>
<br>
<a href="ch03_08.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_08.htm">Inner Class Overview</a>
<br>
<a href="ch03_09.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_09.htm">Static Member Classes</a>
<br>
<a href="ch03_10.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_10.htm">Member Classes</a>
<br>
<a href="ch03_11.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_11.htm">Local Classes</a>
<br>
<a href="ch03_12.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_12.htm">Anonymous Classes</a>
<br>
<a href="ch03_13.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_13.htm">How Inner Classes Work</a>
<br>
<a href="ch03_14.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_14.htm">Modifier Summary</a>
<br>
<a href="ch03_15.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_15.htm">C++ Features Not Found in Java</a>
<br>
</p>
</div>

<p>
<a name="INDEX-416"></a><a name="INDEX-417"></a>

    Java is an object-oriented programming
    language. As we discussed in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2, "Java Syntax

from the Ground Up"</a>,
    all Java programs use objects, and every Java program is
    defined as a class. The previous chapter explained the
    basic syntax of the Java programming language, including data types,
    operators, and expressions, and even showed how to define simple
    classes and work with objects. This chapter continues where
    that one left off, explaining the details of object-oriented
    programming in Java. </p>
<p>
<a name="INDEX-418"></a><a name="INDEX-419"></a>

    If you do not have any object-oriented (OO) 
    programming background, don't
    worry; this chapter does not assume any prior experience. If you do
    have experience with OO programming, however, be careful. The
    term "object-oriented" has different meanings in different
    languages. Don't assume that Java works the same way as your
    favorite OO language. This is particularly true for C++
    programmers. We saw in the last chapter that close analogies can be
    drawn between Java and C. The same is not true for Java and C++,
    however. Java uses object-oriented programming concepts that are
    familiar to C++ programmers and even borrows C++ syntax in a
    number of places, but the similarities between Java and C++ are not
    nearly as strong as those between Java and C. Don't let your
    experience with C++ lull you into a false familiarity with Java. </p>
<h2 class="sect1">3.1. The Members of a Class</h2>
<p>
<a name="INDEX-420"></a><a name="INDEX-421"></a>

      As we discussed in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2, "Java Syntax

from the Ground Up"</a>,
      a class is a collection of data, stored in named fields, and code,
      organized into named methods, that operates on that data. The
      fields and methods are called <em class="emphasis">members</em> of a
      class. In Java 1.1 and later, classes can also contain
      other classes. These member classes, or inner classes, are an
      advanced feature that is discussed later in the chapter. For now,
      we are going to discuss only fields and methods. The
      members of a class come in two distinct types: class, or
      static, members are associated with the class itself, while
      instance members are associated with individual instances of the
      class (i.e., with objects). Ignoring member classes for
      now, this gives us four types of members:

      </p>
<ul>
<li>
<p>	    Class fields
	  </p>
</li>
<li>
<p>	    Class methods
	  </p>
</li>
<li>
<p>	    Instance fields
	  </p>
</li>
<li>
<p>	    Instance methods
	  </p>
</li>
</ul>
<p>      The simple class definition for the class <tt class="literal">Circle</tt>,
      shown in <a href="#javanut3-ch-3-ex-firstcircle">Example 3-1</a>, contains all four types
      of members. </p>
<a name="javanut3-ch-3-ex-firstcircle"></a>
<div class="example">
<h4 class="objtitle">Example 3-1. A Simple Class and its Members</h4>
<blockquote>
<pre class="programlisting">public class Circle {
  // A class field
  public static final double PI= 3.14159;     // A useful constant

  // A class method: just compute a value based on the arguments
  public static double radiansToDegrees(double rads) { 
    return rads * 180 / PI; 
  }

  // An instance field
  public double r;                  // The radius of the circle

  // Two instance methods: they operate on the instance fields of an object
  public double area() {            // Compute the area of the circle
    return PI * r * r; 
  }
  public double circumference() {   // Compute the circumference of the circle
    return 2 * PI * r; 
  }
}</pre>
</blockquote>
</div>
<h3 class="sect2">3.1.1. Class Fields</h3>
<p>
<a name="INDEX-422"></a>

	A <em class="emphasis">class</em><em class="emphasis">field</em> is associated with the class in which it is
	defined, rather than with an instance of the class. The
	following line declares a class field:
</p>
<blockquote>
<pre class="programlisting">public static final double PI = 3.14159;</pre>
</blockquote>
<p>
	This line declares a field of type <tt class="literal">double</tt>
	named <tt class="literal">PI</tt> and assigns it a value of 3.14159. As you can see, a field declaration looks quite a bit like
	the local variable declarations we discussed in <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2, "Java Syntax

from the Ground Up"</a>. The difference, of course, is that
	variables are defined within methods, while fields are members
	of classes. </p>
<p>	The <tt class="literal">static</tt> modifier says that the field is a
	class field. Class fields are sometimes called static fields
	because of this <tt class="literal">static</tt> modifier. The
	<tt class="literal">final</tt> modifier says that the value of the
	field does not change. Since the field <tt class="literal">PI</tt>
	represents a constant, we declare it <tt class="literal">final</tt> so
	that it cannot be changed. It is a convention in Java (and many
	other languages) that constants are named with capital letters,
	which is why our field is named <tt class="literal">PI</tt>, not
	<tt class="literal">pi</tt>. Defining constants like this is a common
	use for class fields, meaning that the <tt class="literal">static</tt> and
	<tt class="literal">final</tt> modifiers are often used together. Not
	all class fields are constants, however. In other words,
	a field can be
	declared <tt class="literal">static</tt> without declaring it
	<tt class="literal">final</tt>. Finally, the
	<tt class="literal">public</tt> modifier says that anyone can use the
	field. This is a visibility modifier, and we'll discuss it and
	related modifiers in more detail later in this chapter. </p>
<p>	The key point to understand about a static field is that there is
	only a single copy of it. This field is associated with the class
	itself, not with instances of the class. If you look at the
	various methods of the <tt class="literal">Circle</tt> class, you'll
	see that they use this field. From inside the
	<tt class="literal">Circle</tt> class, the field can be
	referred to simply as <tt class="literal">PI</tt>. Outside the class,
	however, both class and field names are required
	to uniquely specify the field. Methods that are not part of
	<tt class="literal">Circle</tt> access this field as
	<tt class="literal">Circle.PI</tt>. </p>
<p>	A class field is essentially a global variable. The
	names of class fields are qualified by the unique names of the
	classes that contain them, however. Thus, 
	Java does not suffer from the
	name collisions that can affect other languages when different
	modules of code define global variables with the same name. </p>
<h3 class="sect2">3.1.2. Class Methods</h3>
<p>
<a name="INDEX-423"></a>

	As with class fields, <em class="emphasis">class</em><em class="emphasis">methods</em> are declared with the
	<tt class="literal">static</tt> modifier:
</p>
<blockquote>
<pre class="programlisting">public static double radiansToDegrees(double rads) { return rads * 180 / PI; }</pre>
</blockquote>
<p>
	This line declares a class method named
	<tt class="literal">radiansToDegrees()</tt>. It has a single
	parameter of type <tt class="literal">double</tt> and returns a
	<tt class="literal">double</tt> value. The body of the method is quite
	short; it performs a simple computation and returns the result. </p>
<p>	Like class fields, class methods are associated with a class,
	rather than with an object. When invoking a class method from
	code that exists outside the class, you must specify both the
	name of the class and the method. For example:
</p>
<blockquote>
<pre class="programlisting">// How many degrees is 2.0 radians?
double d = Circle.radiansToDegrees(2.0);</pre>
</blockquote>
<p>
	If you want to invoke a class method from inside the class in
	which it is defined, you don't have to specify the class name. However, it is often good style to specify the class name
	anyway, to make it clear that a class method is
	being invoked. </p>
<p>	Note that the body of our
	<tt class="literal">Circle.radiansToDegrees()</tt> method uses the
	class field <tt class="literal">PI</tt>. A class method can use any
	class fields and class methods of its own class (or of any other
	class). But it cannot use any instance fields or instance
	methods because class methods are not associated with
	an instance of the class. In other words, although the
	<tt class="literal">radiansToDegrees()</tt> method is defined in the
	<tt class="literal">Circle</tt> class, it does not use 
	any <tt class="literal">Circle</tt> objects. The instance fields and
	instance methods of the class are associated with
	<tt class="literal">Circle</tt> objects, not with the class itself. Since a class method is not associated with an instance of
	its class, it cannot use any instance methods or fields. </p>
<p>	As we discussed earlier, a class field is essentially a
	global variable. In
	a similar way, a class method is a global method, or global
	function. Although <tt class="literal">radiansToDegrees()</tt> does
	not operate on <tt class="literal">Circle</tt> objects, it is defined
	within the <tt class="literal">Circle</tt> class because it is a
	utility method that is sometimes useful when working with circles. In
	many non-object-oriented programming languages, 
	all methods, or functions,
	are global. You can write complex Java programs using
	only class methods. This is not object-oriented
	programming, however, and does not take advantage of the
	power of the Java language. To do true object-oriented
	programming, we need to add instance fields and instance
	methods to our repertoire. </p>
<h3 class="sect2">3.1.3. Instance Fields</h3>
<p>
<a name="INDEX-424"></a>

	Any field declared without the <tt class="literal">static</tt>
	modifier is an <em class="emphasis">instance</em><em class="emphasis">field</em>&#8202;:
</p>
<blockquote>
<pre class="programlisting">public double r;    // The radius of the circle</pre>
</blockquote>
<p>
	Instance fields are associated with instances of the class,
	rather than with the class itself. Thus, every
	<tt class="literal">Circle</tt> object we create has its own copy of
	the <tt class="literal">double</tt> field <tt class="literal">r</tt>. In
	our example, <tt class="literal">r</tt> represents the
	radius of a circle. Thus, each <tt class="literal">Circle</tt> object
	can have a radius independent of all other
	<tt class="literal">Circle</tt> objects. </p>
<p>	Inside a class definition, instance fields are referred to by
	name alone. You can see an example of this if you look at the
	method body of the <tt class="literal">circumference()</tt> instance
	method. In code outside the class, the
	name of an instance method must be prepended by a reference to the
	object that contains it. For example, if we have a
	<tt class="literal">Circle</tt> object named <tt class="literal">c</tt>,
	we can refer to its instance field <tt class="literal">r</tt> as
	<tt class="literal">c.r</tt>: 
</p>
<blockquote>
<pre class="programlisting">Circle c = new Circle(); // Create a new Circle object; store it in variable c
c.r = 2.0;               // Assign a value to its instance field r
Circle d = new Circle(); // Create a different Circle object
d.r = c.r * 2;           // Make this one twice as big</pre>
</blockquote>
<p>	Instance fields are key to object-oriented programming. Instance fields define an object; the values
	of those fields make one object distinct from another. </p>
<h3 class="sect2">3.1.4. Instance Methods</h3>
<p>
<a name="INDEX-425"></a>

	Any method not declared with the
	<tt class="literal">static</tt> keyword is an instance method. An
	<em class="emphasis">instance</em><em class="emphasis">method</em> operates on an instance of a class (an object) 
	instead of
	operating on the class itself. It is with instance methods that
	object-oriented programming starts to get interesting. The <tt class="literal">Circle</tt> class defined in <a href="#javanut3-ch-3-ex-firstcircle">Example 3-1</a> contains two instance
	methods, <tt class="literal">area()</tt> and
	<tt class="literal">circumference()</tt>, that compute and return the
	area and circumference of the circle represented by a given
	<tt class="literal">Circle</tt> object. </p>
<p>	To use an instance method from outside the class in which it
	is defined, we must prepend a reference to the instance that is
	to be operated on. For example:
</p>
<blockquote>
<pre class="programlisting">Circle c = new Circle();   // Create a Circle object; store in variable c
c.r = 2.0;                 // Set an instance field of the object
double a = c.area();       // Invoke an instance method of the object</pre>
</blockquote>
<p>
	If you're new to object-oriented programming, that last line of
	code may look a little strange. I did not write: 
</p>
<blockquote>
<pre class="programlisting">a = area(c);</pre>
</blockquote>
<p>
	Instead, I wrote:
</p>
<blockquote>
<pre class="programlisting">a = c.area();</pre>
</blockquote>
<p>
	This is why it is called object-oriented programming; the
	object is the focus here, not the function call. This small
	syntactic difference is perhaps the single most important
	feature of the object-oriented paradigm. </p>
<p>	The point here is that we don't have to pass an argument to
	<tt class="literal">c.area()</tt>. The object we are operating on,
	<tt class="literal">c</tt>, is implicit in the syntax. Take a look at
	<a href="#javanut3-ch-3-ex-firstcircle">Example 3-1</a> again. You'll
	notice the same thing in the signature of the
	<tt class="literal">area()</tt> method: it doesn't have a
	parameter. Now look at
	the body of the <tt class="literal">area()</tt> method: it
	uses the instance field <tt class="literal">r</tt>. Because the
	<tt class="literal">area()</tt> method is part of the same class that
	defines this instance field, the method can use the unqualified
	name <tt class="literal">r</tt>. It is understood that this
	refers to the radius of whatever <tt class="literal">Circle</tt> 
	instance invokes the method. </p>
<p>	Another important thing to notice about the bodies of the
	<tt class="literal">area()</tt> and <tt class="literal">circumference()</tt>
	methods is that they both use the class field
	<tt class="literal">PI</tt>. We saw earlier that class methods can
	use only class fields and class methods, not
	instance fields or methods. Instance methods are not
	restricted in this way: they can use any member of a class,
	whether it is declared <tt class="literal">static</tt> or not. </p>
<h3 class="sect3">3.1.4.1. How instance methods work</h3>
<p>	  Consider this line of code again:
</p>
<blockquote>
<pre class="programlisting">a = c.area();</pre>
</blockquote>
<p>
	  What's going on here?  How can a method that has no parameters
	  know what data to operate on?  In fact, the
	  <tt class="literal">area()</tt> method does have a parameter. All instance methods are implemented with an implicit
	  parameter not shown in the method signature. The
	  implicit argument is named
	  <tt class="literal">this</tt>; it holds a reference to the
	  object through which the method is invoked. In our example,
	  that object is a <tt class="literal">Circle</tt>. </p>
<p>	  The implicit <tt class="literal">this</tt> parameter is not shown in
	  method signatures because it is usually not
	  needed; whenever a Java method accesses the fields in its
	  class, it is implied that it is accessing fields in the object
	  referred to by the <tt class="literal">this</tt> parameter. The same
	  is true when an instance method invokes another instance method
	  in the same class. I said earlier that to invoke an instance
	  method you must prepend a reference to the object to be
	  operated on. When an instance method is invoked within
	  another instance method in the same class, however, you
	  don't need to specify an object. In this case, 
	  it is implicit that the method is
	  being invoked on the <tt class="literal">this</tt> object. </p>
<p>	  You can use the <tt class="literal">this</tt> keyword explicitly when
	  you want to make it clear that a method is accessing its own
	  fields and/or methods. For example, we can rewrite the
	  <tt class="literal">area()</tt> method to use <tt class="literal">this</tt> 
	  explicitly to refer to instance fields:
</p>
<blockquote>
<pre class="programlisting">public double area() { 
  return Circle.PI * this.r * this.r; 
}</pre>
</blockquote>
<p>
	  This code also uses the class name explicitly to refer to
	  class field <tt class="literal">PI</tt>. In a method this simple,
	  it is not necessary to be explicit. In more complicated
	  cases, however, you may find that it increases the clarity of
	  your code to use an explicit <tt class="literal">this</tt> where it
	  is not strictly required. </p>
<p>	  There are some cases in which the <tt class="literal">this</tt> keyword
	  <em class="emphasis">is</em> required, however. For example, 
	  when a method parameter
	  or local variable in a method has the same name as one of
	  the fields of the class, you must use
	  <tt class="literal">this</tt> to refer to the field, since the field
	  name used alone refers to the method parameter or local
	  variable. For example, we can add the following method to
	  the <tt class="literal">Circle</tt> class:
</p>
<blockquote>
<pre class="programlisting">public void setRadius(double r) {
  this.r = r;      // Assign the argument (r) to the field (this.r)
                   // Note that we cannot just say r = r
}</pre>
</blockquote>
<p>
</p>
<p>	  Finally, note that while instance methods can use the 
	  <tt class="literal">this</tt> keyword, class methods cannot. This
	  is because class methods are not associated with objects. </p>
<h3 class="sect3">3.1.4.2. Instance methods or class methods?</h3>
<p>	  Instance methods are one of the key features of
	  object-oriented programming. That doesn't mean, however, that
	  you should shun class methods. There are many cases in which
	  is is perfectly reasonable to define class methods. When
	  working with the <tt class="literal">Circle</tt> class, for example,
	  you might find there are many times you want to
	  compute the area of a circle with a given radius, but
	  don't want to bother creating a
	  <tt class="literal">Circle</tt> object to represent that circle. In
	  this case, a class method is more convenient:
</p>
<blockquote>
<pre class="programlisting">public static double area(double r) { return PI * r * r; }</pre>
</blockquote>
<p>
	  It is
	  perfectly legal for a class to define more than one method
	  with the same name, as long as the methods have different
	  parameters. Since this version of the
	  <tt class="literal">area()</tt> method is a class method, it does
	  not have an implicit <tt class="literal">this</tt> parameter and
	  must have a parameter that specifies the radius of the circle. This parameter keeps it distinct from the instance method of
	  the same name. </p>
<p>	  As another example of the choice between instance methods and
	  class methods, consider defining a method named
	  <tt class="literal">bigger()</tt> that examines two
	  <tt class="literal">Circle</tt> objects and returns whichever
	  has the larger radius. We can write
	  <tt class="literal">bigger()</tt> as an instance method as follows:
</p>
<blockquote>
<pre class="programlisting">// Compare the implicit "this" circle to the "that" circle passed
// explicitly as an argument and return the bigger one. 
public Circle bigger(Circle that) {
  if (this.r &gt; that.r) return this;
  else return that;
}</pre>
</blockquote>
<p>
</p>
<p>	  We can also implement <tt class="literal">bigger()</tt> as a class
	  method as follows:
</p>
<blockquote>
<pre class="programlisting">// Compare circle a to circle b and return the one with the larger radius
public static Circle bigger(Circle a, Circle b) {
  if (a.r &gt; b.r) return a;
  else return b;
}</pre>
</blockquote>
<p>
</p>
<p>	  Given two <tt class="literal">Circle</tt> objects,
	  <tt class="literal">x</tt> and <tt class="literal">y</tt>, we can use
	  either the instance method or the class method to determine
	  which is bigger. The invocation syntax differs significantly
	  for the two methods, however:
</p>
<blockquote>
<pre class="programlisting">Circle biggest = x.bigger(y);          // Instance method: also y.bigger(x)
Circle biggest = Circle.bigger(x, y);  // Static method</pre>
</blockquote>
<p>
</p>
<p>	  Neither option is the correct choice. The
	  instance method is more formally object-oriented, but its
	  invocation syntax suffers from a kind of asymmetry. In a case
	  like this, the choice between an instance method and a class
	  method is simply a design decision. Depending on the circumstances,
	  one or the other


 will likely be the more natural choice. </p>
<h3 class="sect2">3.1.5. A Mystery Solved</h3>
<p>	As we saw in <a href="ch01_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch01_01.htm">Chapter 1, "Introduction"</a> and <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_01.htm">Chapter 2, "Java Syntax

from the Ground Up"</a>, the way to display textual output to
	the terminal in Java is with a method named
	<tt class="literal">System.out.println()</tt>. Those chapters
	never explained why this method has such an long, awkward
	name or what those two periods are doing in it. Now that you
	understand class and instance fields and class and 
	instance methods, it is easier to understand what is going
	on. Here's the story: <tt class="literal">System</tt> is a class. It has
	a class field named <tt class="literal">out</tt>. The field
	<tt class="literal">System.out</tt> refers to an object. The object
	<tt class="literal">System.out</tt> has an instance method named
	<tt class="literal">println()</tt>. Mystery solved!  If you want to
	explore this in more detail, you can look up the
	<tt class="literal">java.lang.System</tt> class in <a href="ch12_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch12_01.htm">Chapter 12, "The java.lang Package"</a>. The class synopsis there tells you
	that the field <tt class="literal">out</tt> is of type
	<tt class="literal">java.io.PrintStream</tt>, which you can look
	up in <a href="ch11_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch11_01.htm">Chapter 11, "The java.io Package"</a>.
<a name="INDEX-426"></a><a name="INDEX-427"></a><a name="INDEX-428"></a>
</p>
















<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch02_14.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch02_14.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch03_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/ch03_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">2.14. Differences Between C and Java</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">3.2. Creating and Initializing Objects</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
