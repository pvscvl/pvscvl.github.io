<html>
<head>
<title>Servlet Basics (Java Enterprise in a Nutshell)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David Flanagan, Jim Farley, William Crawford and Kristopher Magnusson">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-483-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Servlet Basics">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm" alt="Java Enterprise in a Nutshell"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch05_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch05_01.htm">Chapter 5: Java Servlets</a></td><td align="right" valign="top" width="172"><a href="ch05_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch05_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY --><h2 class="sect1">5.2. Servlet Basics</h2>
<p>
<a name="INDEX-1132"></a><a name="INDEX-1133"></a><a name="INDEX-1134"></a>The Servlet API consists of two packages, <tt class="literal">javax.servlet</tt> and <tt class="literal">javax.servlet.http</tt>.  The <tt class="literal">javax</tt> is there because servlets are a standard extension to Java, rather than a mandatory part of the API.  This means that while servlets are official Java, Java virtual machine developers are not required to include the classes for them in their Java development and execution environments.  </p>
<p>
<a name="INDEX-1135"></a>At one point, servlets were slated to become part of Version 1.2 of the Java 2 platform, and the API was even included with some Java SDK beta releases.  However, since the Servlet API is evolving much faster than the core Java SDK, Sun decided to keep distribution<a name="INDEX-"></a><a name="INDEX-1136"></a>
 separate.  This has led to the revival of the Java Servlet
  Development Kit (JSDK), which is currently available from Sun at
  <a href="../../../../../../../java.sun.com/products/servlet/">http://java.sun.com/products/servlet/</a>. The JSDK
  includes the necessary servlet classes and a small
  <em class="emphasis">servletrunner</em> application for development and
  testing.  As of this writing, the latest available implementation is
  JSDK 2.1, based on Version 2.1 of the Servlet API. </p>
<p>The examples in this chapter were developed using Sun's Java Web
  Server 1.1.3, unofficially considered the reference implementation
  for servlets. As of this writing, a number of other products,
  including O'Reilly's WebSite Pro and the W3C's JigSaw, have
  incorporated servlet support.  Various third-party vendors,
  including Live Software, New Atlanta, and IBM, have released add-on
  servlet modules for most other major web server platforms, including
  the Netscape server family, Apache, and Microsoft IIS.  I'm not
  going to discuss how to load servlets on each server, since the
  various implementations differ in this regard.  What's important is
  that the servlets themselves are the same for each platform.</p>
<p>
<a name="INDEX-1137"></a><a name="INDEX-1138"></a><a name="INDEX-1139"></a><a name="INDEX-1140"></a>The three core elements of the Servlet API are the
  <tt class="literal">javax.servlet.Servlet</tt> interface, the
  <tt class="literal">javax.servlet.GenericServlet</tt> class, and the
  <tt class="literal">javax.servlet. http.HttpServlet</tt> class.  Normally, you create a servlet by subclassing one of the two classes, although if you are adding servlet capability to an existing object, you may find it easier to implement the interface.</p>
<p>The <tt class="literal">GenericServlet</tt> class is used for servlets that do not implement any particular communication protocol. Here's a basic servlet that demonstrates servlet structure by printing a short message:</p>
<blockquote>
<pre class="programlisting">
import javax.servlet.*;
import java.io.*;


public class BasicServlet extends GenericServlet {

  public void service(ServletRequest req, ServletResponse resp)
    throws ServletException, IOException {

    resp.setContentType("text/plain"); 
    PrintWriter out = resp.getWriter();

    out.println("Hello.");
  }
}</pre>
</blockquote>
<p>
<a name="INDEX-1141"></a><a name="INDEX-1142"></a><a name="INDEX-1143"></a><a name="INDEX-1144"></a><tt class="literal">BasicServlet</tt> extends the
  <tt class="literal">GenericServlet</tt> class and implements one method:
  <tt class="literal">service()</tt>.  Whenever a server wants to use the
  servlet, it calls this <tt class="literal">service()</tt> method, passing
  <tt class="literal">ServletRequest</tt> and
  <tt class="literal">ServletResponse</tt> objects (we'll look at
  these in more detail shortly).  The servlet tells the server what
  type of response to expect, gets a <tt class="literal">PrintWriter</tt>
  from the response object, and transmits its output.</p>
<p>
<a name="INDEX-1145"></a><a name="INDEX-1146"></a>The <tt class="literal">GenericServlet</tt> class can also implement a
  <em class="emphasis">filtering servlet</em> that takes output from an
  unspecified source and performs some kind of alteration.  For
  example, a filter servlet might be used to prepend a header, scan
  servlet output or raw HTML files for <tt class="literal">&lt;DATE&gt;</tt>
  tags and insert the current date, or remove
  <tt class="literal">&lt;BLINK&gt;</tt> tags.  A more advanced filtering
  servlet might insert content from a database into HTML templates.
  We'll talk a little more about filtering later in this chapter.  </p>
<p>
<a name="INDEX-1147"></a><a name="INDEX-1148"></a>Although most servlets today work with web servers, there's no
  requirement for that in <tt class="literal">GenericServlet</tt>: the class
  implements just that, a generic servlet. As we'll see in a moment,
  the <tt class="literal">HttpServlet</tt> class is a subclass of
  <tt class="literal">GenericServlet</tt> that is designed to work with the
  HTTP protocol.  It is entirely possible to develop other subclasses
  of <tt class="literal">GenericServlet</tt> that work with other server
  types. For example, a Java-based FTP server might use servlets to
  return files and directory listings or perform other tasks.</p>
<a name="ch05-pgfid-347743"></a>
<h3 class="sect2">5.2.1. HTTP Servlets</h3>
<p>
<a name="INDEX-1149"></a><a name="INDEX-1150"></a><a name="INDEX-1151"></a><a name="INDEX-1152"></a>The <tt class="literal">HttpServlet</tt> class is an extension of <tt class="literal">GenericServlet</tt> that includes methods for handling HTTP-specific data.  <tt class="literal">HttpServlet</tt> defines a number of methods, such as <tt class="literal">doGet()</tt>, <tt class="literal">doPost()</tt>, and <tt class="literal">doPut()</tt>, to handle particular types of HTTP requests (GET, POST, and so on). These methods are called by the default implementation of the <tt class="literal">service()</tt> method, which figures out what kind of request is being made and then invokes the appropriate method. Here's a simple <tt class="literal">HttpServlet</tt>:</p>
<blockquote>
<pre class="programlisting">
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class HelloWorldServlet extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {

    resp.setContentType("text/html");
    PrintWriter out = resp.getWriter();

    out.println("&lt;HTML&gt;");
    out.println("&lt;HEAD&gt;&lt;TITLE&gt;Have you seen this before?&lt;/TITLE&gt;&lt;/HEAD&gt;");
    out.println("&lt;BODY&gt;&lt;H1&gt;Hello, World!&lt;/H1&gt;&lt;H6&gt;Again.&lt;/H6&gt;&lt;/BODY&gt;&lt;/HTML&gt;");
  }
}</pre>
</blockquote>
<p>
<a name="INDEX-1153"></a><tt class="literal">HelloWorldServlet</tt> demonstrates many essential servlet concepts.  The first thing to notice is that <tt class="literal">HelloWorldServlet</tt> extends <tt class="literal">HttpServlet--</tt>standard practice for an HTTP servlet. <tt class="literal">HelloWorldServlet</tt> defines one method, <tt class="literal">doGet()</tt>, which is called whenever anyone requests a URL that points to this servlet.<a href="#FOOTNOTE-2">[2]</a> The <tt class="literal">doGet()</tt> method is actually called by the default <tt class="literal">service()</tt> method of <tt class="literal">HttpServlet</tt>. The <tt class="literal">service()</tt> method is called by the web server when a request is made of <tt class="literal">HelloWorldServlet</tt>; the method determines what kind of HTTP request is being made and dispatches the request to the appropriate <a name="INDEX-"></a><a name="INDEX-1154"></a><tt class="literal">doXXX()</tt> method (in this case, <tt class="literal">doGet()</tt>). <tt class="literal">doGet()</tt> is passed two objects, <tt class="literal">HttpServletRequest</tt> and <tt class="literal">HttpServletResponse</tt>, that contain information about the request and provide a mechanism for the servlet to produce output, respectively.</p>
<blockquote class="footnote">
<a name="FOOTNOTE-2"></a>
<p>[2] In a standard Java Web Server installation, with the servlet installed in the standard <em class="filename">servlets</em> directory, this URL is <a href="../../../../../../../site/servlet/HelloWorldServlet">http://site:8080/servlet/HelloWorldServlet</a>. Note that the name of the directory (<em class="emphasis">servlets</em>) is unrelated to the use of "servlet" in the URL.</p>
</blockquote>
<p>The <tt class="literal">doGet()</tt> method itself does three things.  First, it sets the output type to "text/html", which indicates that the servlet produces standard HTML as its output.  Second, it calls the <tt class="literal">getWriter()</tt> method of the <tt class="literal">HttpServletResponse</tt> parameter to get a <tt class="literal">java.io.PrintWriter</tt> that points to the client.  Finally, it uses the stream to send some HTML back to the client.  This isn't really a whole lot different from the <tt class="literal">BasicServlet</tt> example, but it gives us all the tools we'll need later on for more complex web applications.</p>
<p>
<a name="INDEX-1155"></a><a name="INDEX-1156"></a>If you define a <tt class="literal">doGet()</tt> method for a servlet, you may also want to override the <tt class="literal">getLastModified()</tt> method of <tt class="literal">HttpServlet</tt>.  The server calls <tt class="literal">getLastModified()</tt> to find out if the content delivered by a servlet has changed. The default implementation of this method returns a negative number, which tells the server that the servlet doesn't know when its content was last updated, so the server is forced to call <tt class="literal">doGet()</tt> and return the servlet's output.  If you have a servlet that changes its display data infrequently (such as a servlet that verifies uptime on several server machines once every 15 minutes), you should implement <tt class="literal">getLastModified()</tt> to allow browsers to cache responses. <tt class="literal">getLastModified()</tt> should return a long value that represents the time the content was last modified as the number of milliseconds since midnight, January 1, 1970, GMT.</p>
<p>
<a name="INDEX-1157"></a><a name="INDEX-1158"></a>A servlet should also implement <tt class="literal">getServletInfo()</tt>, which returns a string that contains information about the servlet, such as name, author, and version (just like <tt class="literal">getAppletInfo()</tt> in applets).  This method is called by the web server and generally used for logging purposes.</p>
<a name="ch05-pgfid-347790"></a>
<h3 class="sect2">5.2.2. Forms and Interaction</h3>
<p>
<a name="INDEX-1159"></a><a name="INDEX-1160"></a>The problem with creating a servlet like <tt class="literal">HelloWorldServlet</tt> is that it doesn't do anything we can't already do with HTML.  If we are going to bother with a servlet at all, we should do something dynamic and interactive with it.  In many cases, this means processing the results of an HTML form.  To<a name="INDEX-"></a>
 make our example less impersonal, let's have it greet the user by name.  The HTML form that calls the servlet using a GET request might look like this:</p>
<blockquote>
<pre class="programlisting">
&lt;HTML&gt;
&lt;HEAD&gt;&lt;TITLE&gt;Greetings Form&lt;/TITLE&gt;&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;FORM METHOD=GET ACTION="/servlet/HelloServlet"&gt;
What is your name?
&lt;INPUT TYPE=TEXT NAME=username SIZE=20&gt;
&lt;INPUT TYPE=SUBMIT VALUE="Introduce Yourself"&gt;
&lt;/FORM&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</pre>
</blockquote>
<p>
<a name="INDEX-1161"></a>This form submits a form variable named <tt class="literal">username</tt> to the URL <a href="../../../../../../../ext.rlab.cs.nyu.edu/servlet/HelloServlet">/servlet/HelloServlet</a>.  How does the web server know to load this particular servlet? Most servlet implementations, including the Java Web Server, allow you to place unpackaged servlets into a particular directory, and access them with a URI of <a href="../../../../../../../ext.rlab.cs.nyu.edu/servlet/ServletName">/servlet/ServletName</a>.   This is similar to the way most web servers support CGI programs.</p>
<p>The <tt class="literal">HelloServlet</tt> itself does little more than create an output stream, read the <tt class="literal">username</tt> form variable, and print out a nice greeting for the user.  Here's the code:</p>
<blockquote>
<pre class="programlisting">
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class HelloServlet extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {

    resp.setContentType("text/html");
    PrintWriter out = resp.getWriter();

    out.println("&lt;HTML&gt;");
    out.println("&lt;HEAD&gt;&lt;TITLE&gt;Finally, interaction!&lt;/TITLE&gt;&lt;/HEAD&gt;");
    out.println("&lt;BODY&gt;&lt;H1&gt;Hello, " + req.getParameter("username") + "!&lt;/H1&gt;");
    out.println("&lt;/BODY&gt;&lt;/HTML&gt;");
  }
}</pre>
</blockquote>

<p>
<a name="INDEX-1162"></a><a name="INDEX-1163"></a>
All we've done differently here is use the <tt class="literal">getParameter()</tt> method of <tt class="literal">HttpServletRequest</tt> to retrieve the value of a form variable.<a href="#FOOTNOTE-3">[3]</a><a name="INDEX-1164"></a>

When a server calls a servlet, it can also pass a set of request parameters.  With HTTP servlets, these parameters come from the HTTP request itself, in this case in the guise of URL-encoded form variables. Note that a <tt class="literal">GenericServlet</tt> running in a web server also has access to these parameters using the simpler <tt class="literal">SerlvetRequest</tt> object. When the <tt class="literal">HelloServlet</tt> runs, it inserts the value of the <tt class="literal">username</tt> form variable into the HTML output, as shown in <a href="#ch05-pgfid-548571">Figure 5-2</a>.</p>
<blockquote class="footnote">
<a name="FOOTNOTE-3"></a>
<p>[3] In the Java Web Server 1.1, the
<tt class="literal">getParameter()</tt> method was deprecated in favor of
<tt class="literal">getParameterValues()</tt>, which returns a
<tt class="literal">String</tt> array rather than a single string.  However,
after an extensive write-in campaign, Sun took
<tt class="literal">getParameter()</tt> off the deprecated list for Version
2.0 of the Servlet API, so you can safely use this method in your
servlets.</p>
</blockquote>
<a name="ch05-pgfid-548571"></a>
<div class="figure">
<img alt="figure" src="figs/Jent.0502.gif" webstripperlinkwas="figs/Jent.0502.gif"></div>
<h4 class="objtitle">Figure 5-2. Output from HelloServlet</h4>
<a name="ch05-pgfid-347859"></a>
<h3 class="sect2">5.2.3. POST, HEAD, and Other Requests</h3>
<p>
<a name="INDEX-1165"></a><a name="INDEX-1166"></a><a name="INDEX-1167"></a><a name="INDEX-1168"></a>As I mentioned before, <tt class="literal">doGet()</tt> is just one of a
collection of enabling methods for HTTP request
types. <tt class="literal">doPost()</tt> is the corresponding method for
POST requests. The POST request is designed for posting information to
the server, although in practice it is also used for long
parameterized requests and larger forms, to get around limitations on
the length of URLs. </p>
<p>
<a name="INDEX-1169"></a><a name="INDEX-1170"></a>If your servlet is performing database updates, charging a credit
card, or doing anything that takes an explicit client action, you
should make sure this activity is happening in a
<tt class="literal">doPost()</tt> method.  That's because POST requests are
not <em class="emphasis">idempotent</em>, which means that they are not
safely repeatable, and web browsers treat them specially.  For
example, a browser cannot bookmark or, in some cases, reload a POST
request. On the other hand, GET requests are idempotent, so they can
safely be bookmarked, and a browser is free to issue the request
repeatedly without necessarily consulting the user. You can see why
you don't want to charge a credit card in a GET method!</p>
<p>
<a name="INDEX-1171"></a>To create a servlet that can handle POST requests, all you have to do
  is override the default <tt class="literal">doPost()</tt> method from
  <tt class="literal">HttpServlet</tt> and implement the necessary
  functionality in it. If necessary, your application can implement
  different code in <tt class="literal">doPost()</tt> and
  <tt class="literal">doGet()</tt>.  For instance, the
  <tt class="literal">doGet()</tt> method might display a postable data
  entry form that the <tt class="literal">doPost()</tt> method processes.
  <tt class="literal">doPost()</tt> can even call <tt class="literal">doGet()</tt>
  at the end to display the form again. </p>
<p>
<a name="INDEX-1172"></a><a name="INDEX-1173"></a><a name="INDEX-1174"></a><a name="INDEX-1175"></a><a name="INDEX-1176"></a>The less common HTTP request types, such as HEAD, PUT, TRACE, and DELETE, are handled by other <tt class="literal">doXXX()</tt> dispatch methods.  A HEAD request returns HTTP headers only, PUT and DELETE allow clients to create and remove resources from the web server, and TRACE returns the request headers to the client.  Since most servlet programmers don't need to worry about these requests, the <tt class="literal">HttpServlet</tt> class includes a default implementation of each corresponding <tt class="literal">doXXX()</tt> method that either informs the client that the request is unsupported or provides a minimal implementation.  You can provide your own versions of these methods, but the details of implementing PUT or DELETE functionality go rather beyond our scope.</p>
<a name="ch05-pgfid-347869"></a>
<h3 class="sect2">5.2.4. Servlet Responses</h3>
<p>
<a name="INDEX-1177"></a><a name="INDEX-1178"></a><a name="INDEX-1179"></a>In order to do anything useful, a servlet must send a response to each
request that is made of it.  In the case of an HTTP servlet, the
response can include three components: a status code, any number of
HTTP headers, and a response body. </p>
<p>
<a name="INDEX-1180"></a><a name="INDEX-1181"></a><a name="INDEX-1182"></a><a name="INDEX-1183"></a>
The <tt class="literal">ServletResponse</tt> and
<tt class="literal">HttpServletResponse</tt> interfaces include all the
methods needed to create and manipulate a servlet's output.  We've
already seen that you specify the MIME type for the data returned by a
servlet using the <tt class="literal">setContentType()</tt> method of the
response object passed into the servlet. With an HTTP servlet, the
MIME type is generally "text/html," although some servlets return
binary data: a servlet that loads a GIF file from a database and sends
it to the web browser should set a content type of "image/gif" while a
servlet that returns an Adobe Acrobat file should set it to
"application/pdf".</p>
<p>
<a name="INDEX-1184"></a><a name="INDEX-1185"></a><a name="INDEX-1186"></a><a name="INDEX-1187"></a><tt class="literal">ServletResponse</tt> and <tt class="literal">HttpServletResponse</tt> each define two methods for producing output streams, <tt class="literal">getOutputStream()</tt> and <tt class="literal">getWriter()</tt>.  The former returns a <tt class="literal">ServletOutputStream</tt>, which can be used for textual or binary data.  The latter returns a <tt class="literal">java.io.PrintWriter </tt>object, which is used only for textual output.  The <tt class="literal">getWriter()</tt> method examines the content-type to determine which charset  to use, so <tt class="literal">setContentType()</tt> should be called before <tt class="literal">getWriter()</tt>.</p>
<p>
<a name="INDEX-1188"></a><a name="INDEX-1189"></a><a name="INDEX-1190"></a><a name="INDEX-1191"></a><a name="INDEX-1192"></a><a name="INDEX-1193"></a><a name="INDEX-1194"></a><a name="INDEX-1195"></a><a name="INDEX-1196"></a><a name="INDEX-1197"></a><a name="INDEX-1198"></a><tt class="literal">HttpServletResponse</tt> also includes a number of
  methods for handling HTTP responses. Most of these allow you to
  manipulate the HTTP header fields. For example,
  <tt class="literal">setHeader()</tt>, <tt class="literal">setIntHeader()</tt>,
  and <tt class="literal">setDateHeader()</tt> allow you to set the value of
  a specified HTTP header, while <tt class="literal">containsHeader()</tt>
  indicates whether a certain header has already been set. You can use
  either the <tt class="literal">setStatus()</tt> or
  <tt class="literal">sendError()</tt> method to specify the status code
  sent back to the server. <tt class="literal">HttpServletResponse</tt>
  defines a long list of integer constants that represent specific
  status codes (we'll see some of these shortly). You typically don't
  need to worry about setting a status code, as the default code is
  200 ("OK"), meaning that the servlet sent a normal response.
  However, a servlet that is part of a complex application structure
  (such as the <tt class="literal">file</tt> servlet included in the Java
  Web Server that handles the dispatching of HTML pages) may need to
  use a variety of status codes. Finally, the
  <tt class="literal">sendRedirect()</tt> method allows you to issue a page
  redirect. Calling this method sets the <tt class="literal">Location</tt>
  header to the specified location and uses the appropriate status
  code for a redirect.</p>
<a name="ch05-pgfid-347879"></a>
<h3 class="sect2">5.2.5. Servlet Requests</h3>
<p>
<a name="INDEX-1199"></a><a name="INDEX-1200"></a>When a servlet is asked to handle a request, it typically needs specific information about the request so that it can process the request appropriately.  We've already seen how a servlet can retrieve the value of a form variable and use that value in its output.  A servlet may also need access to information about the environment in which it is running. For example, a servlet may need to find out about the actual user who is accessing the servlet, for authentication purposes. <a name="INDEX-"></a>
</p>
<p>
<a name="INDEX-1201"></a><a name="INDEX-1202"></a>The <tt class="literal">ServletRequest</tt> and <tt class="literal">HttpServletRequest</tt> interfaces provide access to this kind of information.  When a servlet is asked to handle a request, the server passes it a request object that implements one of these interfaces. With this object, the servlet can find out about the actual request (e.g., protocol, URL, type), access parts of the raw request (e.g., headers, input stream), and get any client-specific request parameters (e.g., <a name="INDEX-"></a><a name="INDEX-1203"></a><a name="INDEX-1204"></a><a name="INDEX-1205"></a><a name="INDEX-1206"></a><a name="INDEX-1207"></a><a name="INDEX-1208"></a><a name="INDEX-1209"></a><a name="INDEX-1210"></a><a name="INDEX-1211"></a><a name="INDEX-1212"></a>

form variables, extra path information).  For instance, the <tt class="literal">getProtocol()</tt> method returns the protocol used by the request, while <tt class="literal">getRemoteHost()</tt> returns the name of the client host. The interfaces also provide methods that let a servlet get information about the server (e.g., <tt class="literal">getServername()</tt>, <tt class="literal">getServerPort()</tt>). As we saw earlier, the <tt class="literal">getParameter()</tt> method provides access to request parameters such as form variables.  There is also the <tt class="literal">getParameterValues()</tt> method, which returns an array of strings that contains all the values for a particular parameter.  This array generally contains only one string, but some HTML form elements (as well as non-HTTP oriented services) do allow multiple selections or options, so the method always returns an array, even if it has a length of one.</p>
<p>
<a name="INDEX-1213"></a><a name="INDEX-1214"></a><a name="INDEX-1215"></a><a name="INDEX-1216"></a><a name="INDEX-1217"></a><a name="INDEX-1218"></a><a name="INDEX-1219"></a><tt class="literal">HttpServletRequest</tt> adds a few more methods for handling HTTP-specific request data.  For instance, <tt class="literal">getHeaderNames()</tt> returns an enumeration of the names of all the HTTP headers submitted with a request, while <tt class="literal">getHeader()</tt> returns a particular header value.  Other methods exist to handle cookies and sessions, as we'll discuss later.</p>
<p>
<a href="#ch05-pgfid-546277">Example 5-1</a> shows a servlet that restricts access to users who are connecting via the HTTPS protocol, using Digest style authentication, and coming from a government site (a domain ending in <em class="emphasis">.gov</em>).</p>
<a name="ch05-pgfid-546277"></a>
<div class="example">
<h4 class="objtitle">Example 5-1. Checking Request Information to Restrict
Servlet Access</h4>
<blockquote>
<pre class="programlisting">
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class SecureRequestServlet extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {

    resp.setContentType("text/html");
    PrintWriter out = resp.getWriter();

    out.println("&lt;HTML&gt;");
    out.println("&lt;HEAD&gt;&lt;TITLE&gt;Semi-Secure Request&lt;/TITLE&gt;&lt;/HEAD&gt;");
    out.println("&lt;BODY&gt;");
    
    String remoteHost = req.getRemoteHost();
    String scheme = req.getScheme();
    String authType = req.getAuthType();
    
    if((remoteHost == null) || (scheme == null) || (authType == null)) {
      out.println("Request Information Was Not Available.");
      return;
    }

    if(scheme.equalsIgnoreCase("https") &amp;&amp; remoteHost.endsWith(".gov") 
       &amp;&amp; authType.equals("Digest")) {
      out.println("Special, secret information.");
    } 
    else {
      out.println("You are not authorized to view this data.");
    }

    out.println("&lt;/BODY&gt;&lt;/HTML&gt;");
  }
}</pre>
</blockquote>
</div>
<a name="ch05-pgfid-347965"></a>
<h3 class="sect2">5.2.6. Error Handling</h3>
<p>
<a name="INDEX-1220"></a><a name="INDEX-1221"></a><a name="INDEX-1222"></a>Sometimes things just go wrong.  When that happens, it's nice to have a clean way out.  The Servlet API gives you two ways of to deal with errors: you can manually send an error message back to the client or you can throw a <tt class="literal">ServletException</tt>. The easiest way to handle an error is simply to write an error message to the servlet's output stream.  This is the appropriate technique to use when the error is part of a servlet's normal operation, such as when a user forgets to fill in a required form field.</p>
<a name="ch05-pgfid-347969"></a>
<h3 class="sect3">5.2.6.1. Status codes</h3>
<p>
<a name="INDEX-1223"></a><a name="INDEX-1224"></a><a name="INDEX-1225"></a><a name="INDEX-1226"></a>When an error is a standard HTTP error, you should use
the <tt class="literal">sendError()</tt> method of
<tt class="literal">HttpServletResponse</tt> to tell the server to send a
standard error status code. <tt class="literal">HttpServletResponse</tt>
defines integer constants for all the major HTTP status codes. Table
5-1 lists the most common status codes.  For example, if a servlet
cannot find a file the user has requested, it can send a 404
("File Not Found") error and let the browser display it in
its usual manner. In this case, we can replace the typical
<tt class="literal">setContentType()</tt> and <tt class="literal">getWriter()</tt>
calls with something like this:</p>
<blockquote>
<pre class="programlisting">
response.sendError(HttpServletResponse.SC_NOT_FOUND);</pre>
</blockquote>
<p>If you want to specify your own error message (in addition to the web server's default message for a particular error code), you can call <tt class="literal">sendError()</tt> with an extra <tt class="literal">String</tt> parameter:<a name="INDEX-1227"></a><a name="INDEX-1228"></a>
</p>
<blockquote>
<pre class="programlisting">response.sendError(HttpServletResponse.SC_NOT_FOUND, 
                   "It's dark. I couldn't find anything.");</pre>
</blockquote>
<a name="ch05-pgfid-548612"></a>
<h4 class="objtitle">Table 5-1. Some Common HTTP Error Codes </h4>
<table border="1">
<tr>
<th>Mnemonic</th><th>Code</th><th>Default</th><th>Meaning</th>
</tr>
<tr>
<th>Content</th><th></th><th>Message</th><th></th>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_OK</tt>
</p>
</td><td>
<p>200</p>
</td><td>
<p>OK</p>
</td><td>
<p>The client's request succeeded, and the server's response contains the requested data. This is the default status code.</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_NO_CONTENT</tt>
</p>
</td><td>
<p>204</p>
</td><td>
<p>No Content</p>
</td><td>
<p>The request succeeded, but there is no new response body to return.  A servlet may find this code useful when it accepts data from a form, but wants the browser view to stay at the form.  It avoids the "Document contains no data" error message.</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_MOVED_ PERMANENTLY</tt>
</p>
</td><td>
<p>301</p>
</td><td>
<p>Moved Permanently</p>
</td><td>
<p>The requested resource has permanently moved to a new location. Any future reference should use the new location given by the <tt class="literal">Location</tt> header.  Most browsers automatically access the new location.</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_MOVED_ TEMPORARILY</tt>
</p>
</td><td>
<p>302</p>
</td><td>
<p>Moved Temporarily</p>
</td><td>
<p>The requested resource has temporarily moved to another location, but future references should still use the original URL to access the resource.  The temporary new location is given by the <tt class="literal">Location</tt> header.  Most browsers automatically access the new location.</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_ UNAUTHORIZED</tt>
</p>
</td><td>
<p>401</p>
</td><td>
<p>Unauthorized</p>
</td><td>
<p>The request lacked proper authorization.  Used in conjunction with the <tt class="literal">WWW-Authenticate</tt> and <tt class="literal">Authorization</tt> headers.</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_NOT_FOUND</tt>
</p>
</td><td>
<p>404</p>
</td><td>
<p>Not Found</p>
</td><td>
<p>The requested resource is not available.</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_INTERNAL_ SERVER_ERROR</tt>
</p>
</td><td>
<p>500</p>
</td><td>
<p>Internal Server Error</p>
</td><td>
<p>An error occurred inside the server that prevented it from fulfilling the request.</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_NOT_ IMPLEMENTED</tt>
</p>
</td><td>
<p>501</p>
</td><td>
<p>Not Implemented</p>
</td><td>
<p>The server does not support the functionality needed to fulfill the request.</p>
</td>
</tr>
<tr>
<td>
<p>
<tt class="literal">SC_SERVICE_ UNAVAILABLE</tt>
</p>
</td><td>
<p>503</p>
</td><td>
<p>Service Unavailable</p>
</td><td>
<p>The server is temporarily unavailable, but service should be restored in the future. If the server knows when it will be available again, a <tt class="literal">Retry-After</tt> header may also be supplied.</p>
</td>
</tr>
</table>
<a name="ch05-pgfid-347989"></a>
<h3 class="sect3">5.2.6.2. Servlet exceptions</h3>
<p>
<a name="INDEX-1229"></a><a name="INDEX-1230"></a><a name="INDEX-1231"></a>The Servlet API includes two <tt class="literal">Exception</tt> subclasses,
  <tt class="literal">ServletException</tt> and its derivative,
  <tt class="literal">UnavailableException</tt>.  A servlet throws a
  <tt class="literal">ServletException</tt> to indicate a general servlet
  problem. 


When a server catches this exception, it can handle the exception however it sees fit. </p>
<p>
<a name="INDEX-1232"></a><tt class="literal">UnavailableException</tt> is a bit more useful, however. When a servlet throws this exception, it is notifying the server that it is unavailable to service requests.  You can throw an <tt class="literal">UnavailableException</tt> when some factor beyond your servlet's control prevents it from dealing with requests. To throw an exception that indicates permanent unavailability, use something like this:</p>
<blockquote>
<pre class="programlisting">throw new UnavailableException(this, "This is why you can't use the servlet.");</pre>
</blockquote>
<p>
<tt class="literal">UnavailableException</tt> has a second constructor to use if the servlet is going to be temporarily unavailable. With this constructor, you specify how many seconds the servlet is going to be unavailable, as follows:</p>
<blockquote>
<pre class="programlisting">
throw new UnavailableException(120, this, "Try back in two minutes");</pre>
</blockquote>
<p>One caveat: the servlet specification does not mandate that servers actually try again after the specified interval.  If you choose to rely on this capability, you should test it first. </p>
<a name="ch05-pgfid-348003"></a>
<h3 class="sect3">5.2.6.3. A file serving servlet</h3>
<p>
<a name="INDEX-1233"></a><a name="INDEX-1234"></a><a name="INDEX-1235"></a><a href="#ch05-pgfid-546508">Example 5-2</a> demonstrates both of these error-handling techniques, along with another method for reading data from the server.  <tt class="literal">FileServlet</tt> reads a pathname from a form parameter and returns the associated file.  Note that this servlet is designed only to return HTML files. If the file cannot be found, the servlet sends the browser a 404 error.  If the servlet lacks sufficient access privileges to load the file, it sends an <tt class="literal">UnavailableException</tt> instead.  Keep in mind that this servlet exists as a teaching exercise: you should not deploy it on your web server. (For one thing, any security exception renders the servlet permanently unavailable, and for another, it can serve files from the root of your hard drive.)</p>
<a name="ch05-pgfid-546508"></a>
<div class="example">
<h4 class="objtitle">Example 5-2. Serving Files </h4>
<blockquote>
<pre class="programlisting">
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class FileServlet extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {
  
    File r; 
    FileReader fr;
    BufferedReader br;
    try {
      r = new File(req.getParameter("filename"));
      fr = new FileReader(r);
      br = new BufferedReader(fr);
      if(!r.isFile()) {  // Must be a directory or something else
        resp.sendError(resp.SC_NOT_FOUND);
        return;
      }
    } 
    catch (FileNotFoundException e) {
      resp.sendError(resp.SC_NOT_FOUND);
      return;
    }
    catch (SecurityException se) { // Be unavailable permanently
      throw(new UnavailableException(this, 
        "Servlet lacks appropriate privileges."));
    } 

    resp.setContentType("text/html");
    PrintWriter out = resp.getWriter();
    String text;
    while( (text = br.readLine()) != null)
      out.println(text);
    
    br.close();
  }
}</pre>
</blockquote>
</div>
<a name="INDEX-1236"></a>
<a name="ch05-pgfid-348087"></a>
<h3 class="sect2">5.2.7. Security</h3>
<p>
<a name="INDEX-1237"></a><a name="INDEX-1238"></a>Servlets don't generally handle their own security
arrangements. Instead, they typically rely on the capabilities of
the web server to limit access to them.  The security capabilities of
most web servers are limited to basic on-or-off access to specific
resources, controlled by username and password (or digital
certificate), with possible encryption-in-transmission using SSL.
Most servers are limited to basic authentication, which transmits
passwords more or less in the clear, while some (including JWS)<a name="INDEX-1239"></a><a name="INDEX-1240"></a><a name="INDEX-1241"></a><a name="INDEX-1242"></a><a name="INDEX-1243"></a><a name="INDEX-1244"></a>
support the more advanced digest authentication protocol, which works
by transmitting a hash of the user's password and a
server-generated value, rather than the password itself.  Both of
these approaches look the same to the user; the familiar "Enter username and password" window pops up in the web browser. </p>
<p>
<a name="INDEX-1245"></a><a name="INDEX-1246"></a><a name="INDEX-1247"></a><a name="INDEX-1248"></a><tt class="literal">The HttpServletRequest</tt> interface includes a pair of
basic methods for retrieving standard HTTP user authentication
information from the web server. If your web server is equipped to
limit access, a servlet can retrieve the username with
<tt class="literal">getRemoteUser()</tt> and the authentication method
(basic, digest, or SSL) with <tt class="literal">getAuthType()</tt>. Consult
your server documentation for details on using authentication to
protect server resources.</p>
<p>Why are these methods useful? Consider a web application that
uses the web server's authentication support to restrict access
to authorized users, but needs to control access among that set of
users.  The username returned by <tt class="literal">getRemoteUser()</tt>
can be used to look up specific privileges in an access control
database.  This is similar to what we did in <a href="#ch05-pgfid-546277">Example 5-1</a>, except
access is now controlled by username, instead of hostname.</p>

<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch05_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch05_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch05_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">5.1. The Servlet Life Cycle</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">5.3. Servlet Chaining</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
