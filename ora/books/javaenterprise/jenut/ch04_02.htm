<html>
<head>
<title>Creating CORBA Objects (Java Enterprise in a Nutshell)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David Flanagan, Jim Farley, William Crawford and Kristopher Magnusson">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-483-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Creating CORBA Objects">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm" alt="Java Enterprise in a Nutshell"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch04_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch04_01.htm">Chapter 4: Java IDL</a></td><td align="right" valign="top" width="172"><a href="ch04_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch04_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY --><h2 class="sect1">4.2. Creating CORBA Objects</h2>
<p>
<a name="INDEX-916"></a><a name="INDEX-917"></a><a name="INDEX-918"></a>
Now that you understand the various parts of the CORBA architecture,
  let's walk through the creation of CORBA objects using Java
  IDL. In order to distribute a Java object over the network using
  CORBA, you have to define your own CORBA-enabled interface and it
  implementation. This involves doing the following:</p>
<ul>
<li>
<p>Writing an interface in the CORBA Interface Definition Language</p>
</li>
<li>
<p>Generating a Java base interface, plus a Java stub and skeleton class, using an IDL-to-Java compiler</p>
</li>
<li>
<p>Writing a server-side implementation of the Java interface in Java</p>
</li>
</ul>
<a name="ch04-pgfid-974222"></a>
<h3 class="sect2">4.2.1. An IDL Primer</h3>
<p>This section provides a quick overview of writing a CORBA interface in IDL. A full reference on IDL syntax is provided in <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch10_01.htm">Chapter 10, "IDL Reference"</a>, if you need more details.</p>
<p>
<a name="INDEX-919"></a><a name="INDEX-920"></a>
The syntax of both Java and IDL were modeled to some extent on C++, so there are a lot of similarities between the two in terms of syntax. Interfaces in IDL are declared much like classes in C++ and, thus, classes or interfaces in Java. The major differences between IDL and Java are:
<a name="INDEX-921"></a><a name="INDEX-922"></a>
</p>
<ul>
<li>
<p>
<a name="INDEX-923"></a><a name="INDEX-924"></a>
IDL is a declaration language. In IDL, you declare only the names and types for interfaces, data members, methods, method parameters, etc. Method implementations are created in the implementation language you choose (in this case Java), after you've used an IDL compiler to convert your IDL interface to your target language.</p>
</li>
<li>
<p>
<a name="INDEX-925"></a><a name="INDEX-926"></a>
IDL, like C++, includes non-class data structure definitions, like structs, unions, and enumerations. </p>
</li>
<li>
<p>
<a name="INDEX-927"></a><a name="INDEX-928"></a><a name="INDEX-929"></a><a name="INDEX-930"></a><a name="INDEX-931"></a>
Method parameters in IDL include modifiers that specify whether they are input, output, or input/output variables. In Java, all primitive data types are passed by value, and all object data types are passed by reference.</p>
</li>
<li>
<p>
<a name="INDEX-932"></a><a name="INDEX-933"></a><a name="INDEX-934"></a><a name="INDEX-935"></a>

An IDL file can include multiple public interfaces. Java allows multiple inner classes within a single public class definition and multiple nonpublic classes per file, but only a single public class can be defined in a given Java file.</p>
</li>
<li>
<p>
<a name="INDEX-936"></a><a name="INDEX-937"></a><a name="INDEX-938"></a><a name="INDEX-939"></a>
Modules, which are similar to Java packages, can be nested within other modules in the same IDL file, and interfaces in multiple distinct modules can be defined in the same IDL file. In Java, you can define a class only within a single package in a single Java file.</p>
</li>
</ul>
<a name="ch04-pgfid-967492"></a>
<h3 class="sect3">4.2.1.1. Modules</h3>
<p>
<a name="INDEX-940"></a><a name="INDEX-941"></a>
Modules are declared in IDL using the <tt class="literal">module</tt> keyword, followed by a name for the module and an opening brace that starts the module scope. Everything defined within the scope of this module (interfaces, constants, other modules) falls within the module and is referenced in other IDL modules using the syntax <em class="replaceable">modulename</em><tt class="literal">::x</tt>. Suppose that you want all your classes to be contained in a module called <tt class="literal">corba</tt>, which is part of a larger module called <tt class="literal">jen</tt> (an acronym for the title of this book). In IDL this is declared as follows:</p>
<blockquote>
<pre class="programlisting">
// IDL
module jen {
  module corba {
    interface NeatExample ...
  };
};</pre>
</blockquote>
<p>If you want to reference the <tt class="literal">NeatExample</tt> interface in other IDL files, use the syntax <tt class="literal">jen::corba::NeatExample</tt>, which may look familiar to readers who have done C++ programming. Java programmers should note the semicolons following the closing braces on the module definitions, which are required in IDL but not in Java. A semicolon is also required after the close of an interface definition.
<a name="INDEX-942"></a>
</p>
<a name="ch04-pgfid-967500"></a>
<h3 class="sect3">4.2.1.2. Interfaces</h3>
<p>
<a name="INDEX-943"></a><a name="INDEX-944"></a>
Interfaces declared in IDL are mapped into classes or interfaces in Java. As I mentioned before, IDL is used only to declare modules, interfaces, and their methods. Methods on IDL interfaces are always left abstract, to be defined in the programming language you use to implement the interfaces. </p>
<p>
<a name="INDEX-945"></a>
The declaration of an interface includes an interface header and an interface body. The header specifies the name of the interface and the interfaces it inherits from (if any). Here is an IDL interface header:</p>
<blockquote>
<pre class="programlisting">
interface PrintServer : Server { ...</pre>
</blockquote>
<p>This header starts the declaration of an interface called <tt class="literal">PrintServer</tt> that inherits all the methods and data members from the <tt class="literal">Server</tt> interface. An IDL interface can inherit from multiple interfaces; simply separate the interface names with commas in the inheritance part of the header.</p>
<a name="ch04-pgfid-967505"></a>
<h3 class="sect3">4.2.1.3. Data members and methods</h3>
<p>
<a name="INDEX-946"></a><a name="INDEX-947"></a><a name="INDEX-948"></a><a name="INDEX-949"></a><a name="INDEX-950"></a>
The interface body declares all the data members (or attributes) and methods of an interface. Data members are declared using the <tt class="literal">attribute</tt> keyword. At a minimum, the declaration includes a name and a type (see <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch10_01.htm">Chapter 10, "IDL Reference"</a> for a complete list of the basic data types available in IDL and the mapping to Java types). The declaration can optionally specify whether the attribute is read-only or not, using the <tt class="literal">readonly</tt> keyword. By default,
 every attribute you declare is readable and writable (for Java, this means that the IDL compiler generates public read and write methods for it). Here is an example declaration for a read-only <tt class="literal">string</tt> attribute:</p>
<blockquote>
<pre class="programlisting">
readonly attribute string myString;</pre>
</blockquote>
<p>You declare a method by specifying its name, return type, and parameters,
<a name="INDEX-951"></a>
 at a minimum. You can also optionally declare exceptions the method might raise, the invocation semantics of the method, and the context for the method call (see <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch10_01.htm">Chapter 10, "IDL Reference"</a> for more details). Here is the declaration for a simple method that returns a <tt class="literal">string</tt>:</p>
<blockquote>
<pre class="programlisting">
string parseString(in string buffer);</pre>
</blockquote>
<p>This declares a method called <tt class="literal">parseString()</tt> that accepts a single <tt class="literal">string</tt> argument and returns a <tt class="literal">string</tt> value.</p>
<a name="ch04-pgfid-969722"></a>
<h3 class="sect3">4.2.1.4. A complete IDL example</h3>
<p>
<a name="INDEX-952"></a>
Now let's tie all these basic elements together. Here's a complete IDL example that declares a module within another module, which itself contains several interfaces:</p>
<blockquote>
<pre class="programlisting">
module OS {
  module services {
    interface Server {
      readonly attribute string serverName;
      boolean init(in string sName);
    };

    interface Printable {
      boolean print(in string header);
    };

    interface PrintServer : Server {
      boolean printThis(in Printable p);
    };
  };
};</pre>
</blockquote>
<p>The first interface, <tt class="literal">Server</tt>, has a single read-only <tt class="literal">string</tt> attribute and an <tt class="literal">init()</tt> method that accepts a <tt class="literal">string</tt> and returns a <tt class="literal">boolean</tt>. The <tt class="literal">Printable</tt> interface has a single <tt class="literal">print()</tt> method that accepts a string header. Finally, the <tt class="literal">PrintServer</tt> interface extends the <tt class="literal">Server</tt> interface (hence inheriting all its methods and attributes) and adds a <tt class="literal">printThis()</tt> method that accepts a <tt class="literal">Printable</tt> object and returns a <tt class="literal">boolean</tt>. In all cases, we've declared our method arguments as input-only (i.e., pass-by-value), using the <tt class="literal">in</tt> keyword.</p>
<a name="ch04-pgfid-967508"></a>
<h3 class="sect2">4.2.2. Turning IDL Into Java</h3>
<p>
<a name="INDEX-953"></a><a name="INDEX-954"></a><a name="INDEX-955"></a><a name="INDEX-956"></a>
Once you've described your remote interfaces in IDL, you need to generate Java classes that act as a starting point for implementing those remote interfaces in Java using an IDL-to-Java compiler. Every standard IDL-to-Java compiler generates the following Java classes from an IDL interface:</p>
<ul>
<li>
<p>A Java interface with the same name as the IDL interface. This can act as the basis for a Java implementation of the interface (but you have to write it, since IDL doesn't provide any details about method implementations).</p>
</li>
<li>
<p>
<a name="INDEX-957"></a><a name="INDEX-958"></a>
A <em class="emphasis">helper</em> class whose name is the name of the IDL interface with "Helper" appended to it (e.g., <tt class="literal">ServerHelper</tt>). The primary purpose of this class is to provide a static <tt class="literal">narrow()</tt> method that can safely cast CORBA <tt class="literal">Object</tt> references to the Java interface type. The helper class also provides other useful static methods, such as <tt class="literal">read()</tt> and <tt class="literal">write()</tt> methods that allow you to read and write an object of the corresponding type using I/O streams.</p>
</li>
<li>
<p>
<a name="INDEX-959"></a><a name="INDEX-960"></a>
A <em class="emphasis">holder</em> class whose name is the name of the IDL interface with "Holder" appended to it (e.g., <tt class="literal">ServerHolder</tt>). This class is used when objects with this interface are used as <tt class="literal">out</tt> or <tt class="literal">inout</tt> arguments in remote CORBA methods. Instead of being passed directly into the remote method, the object is wrapped with its holder before being passed. When a remote method has parameters that are declared as <tt class="literal">out</tt> or <tt class="literal">inout</tt>, the method has to be able to update the argument it is passed and return the updated value. The only way to guarantee this, even for primitive Java data types, is to force <tt class="literal">out</tt> and <tt class="literal">inout</tt> arguments to be wrapped in Java holder classes, which are filled with the output value of the argument when the method returns.</p>
</li>
</ul>
<p>
<a name="INDEX-961"></a>
The <em class="emphasis">idltojava</em> tool provided by Sun<a href="#FOOTNOTE-3">[3]</a> can also generate two other classes:</p>
<blockquote class="footnote">
<a name="FOOTNOTE-3"></a>
<p>[3]<a name="INDEX-962"></a>
Although Java IDL is a standard part of Java 1.2, Sun still offers only the early-access version of its <em class="emphasis">idltojava</em> compiler, which you have to download separately from <a href="../../../../../../../developer.java.sun.com/developer/earlyAccess/jdk12/idltojava.html">http://developer.java.sun.com/developer/earlyAccess/jdk12/idltojava.html</a><tt class="literal">.</tt>
</p>
</blockquote>
<ul>
<li>
<p>
<a name="INDEX-963"></a><a name="INDEX-964"></a><a name="INDEX-965"></a>
A client <em class="emphasis">stub</em> class, called<tt class="literal"> _</tt><em class="replaceable">interface-name</em><tt class="literal">Stub</tt>, that acts as a client-side implementation of the interface and knows how to convert method requests into ORB requests that are forwarded to the actual remote object. The stub class for an interface named <tt class="literal">Server</tt> is called <tt class="literal">_ServerStub</tt>.</p>
</li>
<li>
<p>A server <em class="emphasis">skeleton</em> class, called <tt class="literal">_</tt><em class="replaceable">interface-name</em><tt class="literal">ImplBase</tt>, that is a base class for a server-side implementation of the interface. The base class can accept requests for the object from the ORB and channel return values back through the ORB to the remote client. The skeleton class for an interface named <tt class="literal">Server</tt> is called <tt class="literal">_ServerImplBase</tt>.</p>
</li>
</ul>
<p>So, in addition to generating a Java mapping of the IDL interface and some helper classes for the Java interface, the <em class="emphasis">idltojava</em> compiler also creates subclasses that act as an interface between a CORBA client and the ORB and between the server-side implementation and the ORB. <a href="ch12_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch12_01.htm">Chapter 12, "Java IDL Tools"</a>, provides a complete reference for Sun's <em class="emphasis">idltojava</em> compiler. We use this IDL-to-Java tool in the examples in this chapter. Remember, though, that any Java mapping of the CORBA standard should include its own IDL-to-Java compiler to generate these Java classes from the IDL interfaces you write. In addition, the Java that these tools generate should be compliant with the standard IDL mapping for Java, published by the OMG in the CORBA standard.</p>
<a name="ch04-pgfid-967517"></a>
<h3 class="sect3">4.2.2.1. A simple server class</h3>
<p>
<a name="INDEX-966"></a><a name="INDEX-967"></a>

The IDL interface shown in <a href="#ch04-34009">Example 4-1</a> is the IDL
equivalent of the Java class we defined in <a href="ch03_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch03_02.htm">Example 4-3</a> in the RMI
chapter. The interface, named <tt class="literal">ThisOrThatServer</tt>,
declares two methods, <tt class="literal">doThis()</tt> and
<tt class="literal">doThat()</tt>. As in the earlier RMI example, each
method accepts a string that specifies what to do and returns a string
that indicates what was done. Since this is IDL, the string data type
is <tt class="literal">string</tt>, and the parameters are declared as
<tt class="literal">in</tt> arguments, since we want them to be passed into
the remote method by value.</p>
<a name="ch04-34009"></a>
<div class="example">
<h4 class="objtitle">Example 4-1. A ThisOrThatServer Declared in IDL</h4>
<blockquote>
<pre class="programlisting">
    interface ThisOrThatServer {
      string doThis(in string what);
      string doThat(in string what);
    };</pre>
</blockquote>
</div>
<p>We can run the <em class="emphasis">idltojava</em> compiler on this IDL interface using the following command line (Windows version):</p>
<blockquote>
<pre class="programlisting">
D:\&gt;idltojava -fno-cpp ThisOrThatServer.idl</pre>
</blockquote>
<p>This command creates the five Java classes I just described: a Java version of the interface, a helper class, a holder class, a client stub, and a server skeleton. I had to use the <tt class="literal">-fno-cpp</tt> option on my machine because I don't have a C preprocessor installed for <em class="emphasis">idltojava</em> to use; this option tells the IDL compiler to use an alternate parsing scheme while it converts the IDL to Java (see <a href="ch12_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch12_01.htm">Chapter 12, "Java IDL Tools"</a> for complete details on the command-line arguments for <em class="emphasis">idltojava</em>). </p>
<p>
<a name="INDEX-968"></a><a name="INDEX-969"></a>
The compiler creates the Java interface shown in <a href="#ch04-34441">Example 4-2</a>, in a file named <em class="filename">ThisOrThatServer.java</em>. The mapping is fairly straightforward for this simple example. The interface declaration is mapped directly to a Java interface declaration, with the interface extending the <tt class="literal">org.omg.CORBA.Object</tt> interface. If we had included any module definitions in our IDL specification, they would have been mapped into a <tt class="literal">package</tt> statement at the beginning of the Java file. The IDL <tt class="literal">string</tt> type is converted into the Java <tt class="literal">String</tt> type, and, since they don't require any special handling in a remote method call, the <tt class="literal">in</tt> method parameters in IDL are mapped into regular Java input arguments.</p>
<a name="ch04-34441"></a>
<div class="example">
<h4 class="objtitle">Example 4-2. Java Interface for ThisOrThatServer</h4>
<blockquote>
<pre class="programlisting">
/*
 * File: ./THISORTHATSERVER.JAVA
 * From: THISORTHATSERVER.IDL
 * Date: Thu Apr 15 21:42:40 1999
 *   By: C:\JDK12~1.1\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

public interface ThisOrThatServer
    extends org.omg.CORBA.Object {
    String doThis(String what)
;
    String doThat(String what)
;
}</pre>
</blockquote>
</div>
<p>You might notice that the IDL compiler has put the semicolons following the method declarations on separate lines. To my knowledge, there's no good reason for this; it's just a quirk of the <em class="emphasis">idltojava</em> tool provided by Sun.</p>
<a name="ch04-pgfid-969903"></a>
<h3 class="sect3">4.2.2.2. The helper class</h3>
<p>
<a name="INDEX-970"></a>
The compiler also generates a helper class, called
<tt class="literal">ThisOrThatServerHelper</tt>, as shown in <a href="#ch04-28638">Example 4-3</a>. As I mentioned earlier, the helper
class has methods that let you read and write
<tt class="literal">ThisOrThatServer</tt> objects to and from CORBA I/O
streams, get the <tt class="literal">TypeCode</tt> for a
<tt class="literal">ThisOrThatServer</tt> object, 


and, most importantly, safely narrow a CORBA <tt class="literal">Object</tt> reference into a <tt class="literal">ThisOrThatServer</tt> reference. </p>
<a name="ch04-28638"></a>
<div class="example">
<h4 class="objtitle">Example 4-3. Helper Class for the ThisOrThatServer </h4>
<blockquote>
<pre class="programlisting">
/*
 * File: ./THISORTHATSERVERHELPER.JAVA
 * From: THISORTHATSERVER.IDL
 * Date: Thu Apr 15 21:42:40 1999
 *   By: C:\JDK12~1.1\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

public class ThisOrThatServerHelper {
    // It is useless to have instances of this class
    private ThisOrThatServerHelper() { }

    public static void write(org.omg.CORBA.portable.OutputStream out, 
                             ThisOrThatServer that) {
        out.write_Object(that);
    }
    public static ThisOrThatServer 
      read(org.omg.CORBA.portable.InputStream in) {
        return ThisOrThatServerHelper.narrow(in.read_Object());
    }
   public static ThisOrThatServer extract(org.omg.CORBA.Any a) {
     org.omg.CORBA.portable.InputStream in = a.create_input_stream();
     return read(in);
   }
   public static void insert(org.omg.CORBA.Any a, ThisOrThatServer that) {
     org.omg.CORBA.portable.OutputStream out = a.create_output_stream();
     write(out, that);
     a.read_value(out.create_input_stream(), type());
   }
   private static org.omg.CORBA.TypeCode _tc;
   synchronized public static org.omg.CORBA.TypeCode type() {
          if (_tc == null)
             _tc = org.omg.CORBA.ORB.init().create_interface_tc(id(), 
                   "ThisOrThatServer");
      return _tc;
   }
   public static String id() {
       return "IDL:ThisOrThatServer:1.0";
   }
   public static ThisOrThatServer narrow(org.omg.CORBA.Object that)
            throws org.omg.CORBA.BAD_PARAM {
        if (that == null)
            return null;
        if (that instanceof ThisOrThatServer)
            return (ThisOrThatServer) that;
        if (!that._is_a(id())) {
            throw new org.omg.CORBA.BAD_PARAM();
        }
        org.omg.CORBA.portable.Delegate dup = 
          ((org.omg.CORBA.portable.ObjectImpl)that)._get_delegate();
        ThisOrThatServer result = new _ThisOrThatServerStub(dup);
        return result;
   }
}</pre>
</blockquote>
</div>
<p>
<a name="INDEX-971"></a><a name="INDEX-972"></a><a name="INDEX-973"></a>
In the implementation of the <tt class="literal">narrow()</tt> method, we
  can see how the helper class converts a CORBA
  <tt class="literal">Object</tt> reference to a reference to a specific
  type. First, the <tt class="literal">narrow()</tt> method checks to see if
  the <tt class="literal">Object</tt> parameter is already a
  <tt class="literal">ThisOrThatServer</tt> object (using the Java
  <tt class="literal">instanceof</tt> operator), then it checks to see if
  the object passed in is a <tt class="literal">null</tt> pointer. If
  neither case is true, the <tt class="literal">Object</tt> should
contain a <em class="emphasis">delegate</em> of a
<tt class="literal">ThisOrThatServer</tt> object. Every CORBA stub for a
remote object contains an internal <tt class="literal">Delegate</tt> object
(from the <tt class="literal">org.omg.CORBA.portable</tt> package) that's
used by the stub to invoke remote requests. If the object's
delegate is a <tt class="literal">ThisOrThatServer</tt> (checked using the
objects's <tt class="literal">_is_a()</tt> method), the delegate is
used to create a new <tt class="literal">ThisOrThatServer</tt>
stub. We'll take a look at the
<tt class="literal">ThisOrThatServer</tt> stub class in a bit. If the
object doesn't contain a delegate, the <tt class="literal">is_a()</tt>
method returns <tt class="literal">false</tt>, and the
<tt class="literal">narrow()</tt> method throws a
<tt class="literal">BAD_PARAM</tt> exception.</p>

<a name="ch04-pgfid-967702"></a>
<h3 class="sect3">4.2.2.3. The holder class</h3>

<a name="INDEX-974"></a>
<p>
<a name="INDEX-975"></a><a name="INDEX-976"></a><a name="INDEX-977"></a>

The compiler generates a holder class for the
<tt class="literal">ThisOrThatServer</tt> class, as shown in <a href="#ch04-19260">Example 4-4</a>. The holder class, called
<tt class="literal">ThisOrThatServerHolder</tt>, is a wrapper used when
<tt class="literal">ThisOrThatServer</tt> objects are called for as
<tt class="literal">out</tt> or <tt class="literal">inout</tt> arguments in an IDL
method. All holder classes implement the <tt class="literal">Streamable</tt>
interface from the <tt class="literal">org.omg.CORBA.portable</tt>
package. An ORB knows to pass <tt class="literal">Streamable</tt> objects in
method calls using the <tt class="literal">_read()</tt> and
<tt class="literal">_write()</tt> methods of the
<tt class="literal">Streamable</tt> object; these methods handle whatever
serialization the object needs.
</p>

<a name="ch04-19260"></a>
<div class="example">
<h4 class="objtitle">Example 4-4. Holder Class for the ThisOrThatServer</h4>
<blockquote>
<pre class="programlisting">
/*
 * File: ./THISORTHATSERVERHOLDER.JAVA
 * From: THISORTHATSERVER.IDL
 * Date: Thu Apr 15 21:42:40 1999
 *   By: C:\JDK12~1.1\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

public final class ThisOrThatServerHolder
     implements org.omg.CORBA.portable.Streamable{
    //  instance variable 
    public ThisOrThatServer value;
    //  constructors 
    public ThisOrThatServerHolder() {
        this(null);
    }
    public ThisOrThatServerHolder(ThisOrThatServer __arg) {
        value = __arg;
    }

    public void _write(org.omg.CORBA.portable.OutputStream out) {
        ThisOrThatServerHelper.write(out, value);
    }

    public void _read(org.omg.CORBA.portable.InputStream in) {
        value = ThisOrThatServerHelper.read(in);
    }

    public org.omg.CORBA.TypeCode _type() {
        return ThisOrThatServerHelper.type();
    }
}</pre>
</blockquote>
</div>
<p>
<a name="INDEX-978"></a><a name="INDEX-979"></a>
A holder contains a single instance of a CORBA object (a
<tt class="literal">ThisOrThatServer</tt>, in this example). When a holder
object is passed into a remote method call as an
<tt class="literal">inout</tt> argument, its <tt class="literal">_write()</tt>
method is invoked. This method takes the object contained by the
holder class, serializes it, and streams it through the ORB to the
remote object server. When the remote method call returns, the
holder's <tt class="literal">_read()</tt> method is invoked to read
the (possibly updated) object from the remote object server, and the
holder object replaces its internal value with the updated object. </p>
<p>
<a name="INDEX-980"></a><a name="INDEX-981"></a>
As an example of using the holder class, let's define another IDL interface that includes a method that uses a <tt class="literal">ThisOrThatServer</tt> as an <tt class="literal">inout</tt> parameter:</p>
<blockquote>
<pre class="programlisting">
// IDL
interface ServerManager {
  boolean updateServer(inout ThisOrThatServer server);
};</pre>
</blockquote>
<p>The Java interface generated from this IDL interface uses the holder class for the <tt class="literal">ThisOrThatServer</tt> as the type for the corresponding Java method parameter:</p>
<blockquote>
<pre class="programlisting">
// Java
public interface ServerManager
    extends org.omg.CORBA.Object {
    boolean updateServer(ThisOrThatServerHolder server)
;
}</pre>
</blockquote>
<p>
<a name="INDEX-982"></a>
The <tt class="literal">ThisOrThatServerHolder</tt> class has public constructors that let you create a holder from an existing <tt class="literal">ThisOrThatServer</tt> object, so that you can easily pass the object into this kind of method.</p>
<a name="ch04-pgfid-971029"></a>
<h3 class="sect3">4.2.2.4. The client and server stubs</h3>
<p>
<a name="INDEX-983"></a><a name="INDEX-984"></a><a name="INDEX-985"></a>

The <em class="emphasis">idltojava</em> compiler generates two more classes
from our interface definition: a client stub
(<tt class="literal">_ThisOrThatServerStub</tt>) and a base class for a
server implementation
(<tt class="literal">_ThisOrThatServerImplBase</tt>). The client stub, shown
in <a href="#ch04-13696">Example 4-5</a>, implements the generated
<tt class="literal">ThisOrThatServer</tt> Java interface and acts as a
client-side proxy for a remote <tt class="literal">ThisOrThatServer</tt>
object. The stub has implementations of the
<tt class="literal">doThis()</tt> and <tt class="literal">doThat()</tt> methods
from the interface. Each implementation just generates a request to
the ORB to make a remote method call on the server-side object that
this stub is a proxy for. The method arguments are bundled up and
passed along with the request to the ORB. I'm not going to go
into the details of the stub's method implementations because
you shouldn't have to worry much about them, but it is
enlightening to look at the source code to see how your remote objects
do what they do in detail, using the core CORBA functions. </p>
<a name="ch04-13696"></a>
<div class="example">
<h4 class="objtitle">Example 4-5. ThisOrThatServer Stub Class Generated by IDL Compiler </h4>
<blockquote>
<pre class="programlisting">
/*
 * File: ./_THISORTHATSERVERSTUB.JAVA
 * From: THISORTHATSERVER.IDL
 * Date: Thu Apr 15 21:42:40 1999
 *   By: C:\JDK12~1.1\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

public class _ThisOrThatServerStub
        extends org.omg.CORBA.portable.ObjectImpl
        implements ThisOrThatServer {

    public _ThisOrThatServerStub(org.omg.CORBA.portable.Delegate d) {
          super();
          _set_delegate(d);
    }

    private static final String _type_ids[] = {
        "IDL:ThisOrThatServer:1.0"
    };

    public String[] _ids() { return (String[]) _type_ids.clone(); }

    //  IDL operations
    //      Implementation of ::ThisOrThatServer::doThis
    public String doThis(String what)
 {
           org.omg.CORBA.Request r = _request("doThis");
           r.set_return_type(org.omg.CORBA.ORB.init().get_primitive_tc(
               org.omg.CORBA.TCKind.tk_string));
           org.omg.CORBA.Any _what = r.add_in_arg();
           _what.insert_string(what);
           r.invoke();
           String __result;
           __result = r.return_value().extract_string();
           return __result;
   }
    //      Implementation of ::ThisOrThatServer::doThat
    public String doThat(String what)
 {
           org.omg.CORBA.Request r = _request("doThat");
           r.set_return_type(org.omg.CORBA.ORB.init().get_primitive_tc(
               org.omg.CORBA.TCKind.tk_string));
           org.omg.CORBA.Any _what = r.add_in_arg();
           _what.insert_string(what);
           r.invoke();
           String __result;
           __result = r.return_value().extract_string();
           return __result;
   }
};</pre>
</blockquote>
</div>
<p>
<a name="INDEX-986"></a><a name="INDEX-987"></a>
When a Java client gets a reference to a remote <tt class="literal">ThisOrThatServer</tt> object, it is given one of these stub objects. The client can make method calls on the stub object, and the stub converts these calls into corresponding requests to the ORB to invoke the methods on the remote object and send back the results. </p>
<p>
<a name="INDEX-988"></a><a name="INDEX-989"></a>
The base class for the server implementation, shown in <a href="#ch04-10046">Example 4-6</a>, accepts requests that are intended for the server implementation from the ORB. The base class converts a request into a method call on the server object and then takes the result of the call and gives it back to the ORB to send to the client stub. All this work is done in the server skeleton's <tt class="literal">invoke()</tt> method. The <tt class="literal">invoke()</tt> method figures out which method is being called, unpacks the method arguments (if any) from the request, and calls the method directly on itself. </p>
<p>Note that the server skeleton doesn't have implementations of the <tt class="literal">doThis()</tt> or <tt class="literal">doThat()</tt> methods declared in the interface. The <em class="emphasis">idltojava</em> compiler doesn't do everything for you; you still need to create a server implementation for your interface.
<a name="INDEX-990"></a>
</p>
<a name="ch04-10046"></a>
<div class="example">
<h4 class="objtitle">Example 4-6. Implementation Base Class for ThisOrThatServer </h4>
<blockquote>
<pre class="programlisting">
/*
 * File: ./_THISORTHATSERVERIMPLBASE.JAVA
 * From: THISORTHATSERVER.IDL
 * Date: Thu Apr 15 21:42:40 1999
 *   By: C:\JDK12~1.1\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

public abstract class _ThisOrThatServerImplBase extends 
    org.omg.CORBA.DynamicImplementation implements ThisOrThatServer {
    // Constructor
    public _ThisOrThatServerImplBase() {
         super();
    }
    // Type strings for this class and its superclasses
    private static final String _type_ids[] = {
        "IDL:ThisOrThatServer:1.0"
    };

    public String[] _ids() { return (String[]) _type_ids.clone(); }

    private static java.util.Dictionary _methods = new java.util.Hashtable();
    static {
      _methods.put("doThis", new java.lang.Integer(0));
      _methods.put("doThat", new java.lang.Integer(1));
     }
    // DSI Dispatch call
    public void invoke(org.omg.CORBA.ServerRequest r) {
       switch (((java.lang.Integer) _methods.get(r.op_name())).intValue()) {
           case 0: // ThisOrThatServer.doThis
              {
              org.omg.CORBA.NVList _list = _orb().create_list(0);
              org.omg.CORBA.Any _what = _orb().create_any();
              _what.type(org.omg.CORBA.ORB.init().get_primitive_tc(
                  org.omg.CORBA.TCKind.tk_string));
              _list.add_value("what", _what, org.omg.CORBA.ARG_IN.value);
              r.params(_list);
              String what;
              what = _what.extract_string();
              String ___result;
                            ___result = this.doThis(what);
              org.omg.CORBA.Any __result = _orb().create_any();
              __result.insert_string(___result);
              r.result(__result);
              }
              break;
           case 1: // ThisOrThatServer.doThat
              {
              org.omg.CORBA.NVList _list = _orb().create_list(0);
              org.omg.CORBA.Any _what = _orb().create_any();
              _what.type(org.omg.CORBA.ORB.init().get_primitive_tc(
                  org.omg.CORBA.TCKind.tk_string));
              _list.add_value("what", _what, org.omg.CORBA.ARG_IN.value);
              r.params(_list);
              String what;
              what = _what.extract_string();
              String ___result;
                            ___result = this.doThat(what);
              org.omg.CORBA.Any __result = _orb().create_any();
              __result.insert_string(___result);
              r.result(__result);
              }
              break;
            default:
              throw new org.omg.CORBA.BAD_OPERATION(0, 
                  org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
       }
 }
}</pre>
</blockquote>
</div>
<a name="ch04-pgfid-968022"></a>
<h3 class="sect2">4.2.3. Writing the Implementation</h3>
<p>
<a name="INDEX-991"></a>
So, we've written an IDL interface and generated the Java interface and support classes for it, including the client stub and the server skeleton. Now we need to create concrete server-side implementations of all of the methods on your interface. We do this by subclassing from the <tt class="literal">_</tt><em class="replaceable">xxx</em><tt class="literal">ImplBase</tt> class generated by the <em class="emphasis">idltojava</em> compiler. For our example, we need to subclass <tt class="literal">_ThisOrThatServerImplBase</tt> and implement the <tt class="literal">doThis()</tt> and <tt class="literal">doThat()</tt> methods. The <tt class="literal">ThisOrThatServerImpl</tt> class in <a href="#ch04-13020">Example 4-7</a> does just that. Note that we've mimicked the method implementations from the RMI example in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch03_01.htm">Chapter 3, "Remote Method Invocation"</a>. The only real difference is that this <tt class="literal">ThisOrThatServerImpl</tt> class extends <tt class="literal">_ThisOrThatServerImplBase</tt>, while the one in <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch03_01.htm">Chapter 3, "Remote Method Invocation"</a> extends the <tt class="literal">UnicastRemoteObject</tt>. </p>
<a name="ch04-13020"></a>
<div class="example">
<h4 class="objtitle">Example 4-7. Server-Side Implementation of ThisOrThatServer Interface</h4>
<blockquote>
<pre class="programlisting">
public class ThisOrThatServerImpl extends _ThisOrThatServerImplBase {

  public ThisOrThatServerImpl() {}

  // Remotely-accessible methods
  public String doThis(String what) {
    return doSomething("this", what);
  }

  public String doThat(String what) {
    return doSomething("that", what);
  }

  // Non-remote methods
  private String doSomething(String todo, String what) {
    String result = todo + " " + what + " is done.";
    System.out.println("Did " + todo + " to " + what);
    return result;
  }
}</pre>
</blockquote>
</div>
<a name="INDEX-992"></a>
<a name="INDEX-993"></a>

<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch04_01.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch04_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch04_03.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">4.1. The CORBA Architecture</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">4.3. Putting It in the Public Eye</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
