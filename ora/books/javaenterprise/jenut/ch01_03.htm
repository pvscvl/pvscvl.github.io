<html>
<head>
<title>The Java Enterprise APIs (Java Enterprise in a Nutshell)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="David Flanagan, Jim Farley, William Crawford and Kristopher Magnusson">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-483-5E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="The Java Enterprise APIs">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm" alt="Java Enterprise in a Nutshell"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch01_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch01_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch01_01.htm">Chapter 1: Introduction</a></td><td align="right" valign="top" width="172"><a href="ch01_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch01_04.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY --><h2 class="sect1">1.3. The Java Enterprise APIs</h2>
<p>      The Java Enterprise APIs provide support for a number of the most
<a name="INDEX-16"></a>
      commonly used distributed computing technologies and network
<a name="INDEX-17"></a><a name="INDEX-18"></a>
      services.  These APIs are described in the sections that follow.
      The APIs are building blocks for distributed applications.  At the
      end of the chapter, I'll present some enterprise computing
scenarios
      that illustrate how these separate APIs can be used together to
      produce an enterprise application.
    </p>
<h3 class="sect2">1.3.1. JDBC: Working with Databases</h3>
<p>
<a name="INDEX-19"></a><a name="INDEX-20"></a><a name="INDEX-21"></a><a name="INDEX-22"></a><a name="INDEX-23"></a>

JDBC ( Java Database Connectivity) is the Java Enterprise API for
working with relational database systems.  JDBC allows a Java program
to send SQL query and update statements to a database server and to
retrieve and iterate through query results returned by the server.
JDBC also allows you to get meta-information about the database and
its tables from the database server.</p>
<p>	The JDBC API is independent of vendor-specific APIs defined by
	particular database systems.  The JDBC architecture relies
	upon a <tt class="literal">Driver</tt> class that hides the details
	of communicating with a database server.  Each database server
	product requires a custom <tt class="literal">Driver</tt>
	implementation to allow Java programs
	<a name="INDEX-24"></a><a name="INDEX-25"></a> to communicate with it.  Major
	database vendors have made JDBC drivers available for their
	products.  In addition, a "bridge" driver exists
	to enable Java programs to communicate with databases through
	existing ODBC drivers.
      </p>
<p>	The JDBC API is found in the <tt class="literal">java.sql</tt><a name="INDEX-26"></a>

	package, which was introduced in Java 1.1.  Version 1.2 of
        the Java 2
<a name="INDEX-27"></a>
	platform adds a number of new classes to this package to
	support advanced database features.  Java 1.2 also provides
	additional features in the <tt class="literal">javax.sql</tt><a name="INDEX-28"></a>
	standard extension package.  <tt class="literal">javax.sql</tt>
	includes classes for treating database query results as
	JavaBeans, for pooling database connections, and for obtaining
	database connection information from a name service.
	The extension package also supports scrollable result sets,
	batch updates, and the storage of Java objects in databases.
      </p>
<p>	The JDBC API is simple and well-designed.  Programmers who are
	familiar with SQL and database programming in general should find
<a name="INDEX-29"></a>
	it very easy to work with databases in Java.  See <a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch02_01.htm">Chapter 2, "JDBC"</a>, for details on JDBC, and <a href="ch08_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch08_01.htm">Chapter 8, "SQL Reference"</a>, for a quick reference to
	SQL.
      </p>
<h3 class="sect2">1.3.2. RMI: Remote Method Invocation</h3>
<p>
<em class="emphasis">Remote method invocation</em> is a programming model that provides a
<a name="INDEX-30"></a><a name="INDEX-31"></a>

	high-level, generic approach to distributed computing.
<a name="INDEX-32"></a><a name="INDEX-33"></a>

	This model extends the object-oriented programming paradigm to
	distributed client-server programming; it allows a client to
	communicate with a server by invoking methods on remote objects
	that reside on the server.  You invoke remote methods using the
	same syntax you would use to invoke methods of a normal
	local object.  This model for distributed computing 
	can be implemented in a number of ways.  One of those ways is
	the Java Remote Method Invocation (RMI) API.  RMI is implemented
	in the <tt class="literal">java.rmi</tt> package and its subpackages,
<a name="INDEX-34"></a><a name="INDEX-35"></a>
	which were introduced 
	in Java 1.1 and have been enhanced for Version 1.2 of 
        the Java 2 platform.
      </p>
<p>	The Java RMI implementation is full-featured, but still simple
	and easy to use.  It gains much of its simplicity by being
	built on top of a network-centric and dynamically extensible
	platform, of course.  But it also gains simplicity by
	requiring both client and server to be implemented in Java.
<a name="INDEX-36"></a>
	This requirement ensures that both client and server share a
	common set of data types and have access to the object
	serialization and deserialization features of the
<a name="INDEX-37"></a><a name="INDEX-38"></a><a name="INDEX-39"></a><a name="INDEX-40"></a><a name="INDEX-41"></a><tt class="literal">java.io</tt> package, for example.  On the other
	hand, this means that RMI cannot be used with
	distributed objects written in languages other than Java, such
	as objects that exist on legacy servers.<a href="#FOOTNOTE-1">[1]</a>
	It also means that
	servers written using RMI can be used only by clients written
	in Java.  In practice, RMI is an excellent distributed object
	solution for situations where it is clear that clients and
	servers will always be written in Java.  Fortunately, there
	are many such situations.
      </p>
<blockquote class="footnote">
<a name="FOOTNOTE-1"></a>
<p>[1]One way to work
	around this restriction is to use native methods to
	create Java wrappers that interface directly with the legacy
	objects that are written in other languages.</p>
</blockquote>
<p>
<a name="INDEX-42"></a><a name="INDEX-43"></a>
	The <tt class="literal">java.rmi</tt> package makes it easy to
	create networked, object-oriented programs.  Programmers who
	have spent time writing networked applications using
	lower-level technologies are usually amazed by the power of
	RMI.  By making RMI so easy, <tt class="literal">java.rmi</tt>
	points the way to future applications and systems that consist
	of loose groups of objects interacting with each other over a
	network. These objects may act both as clients, by calling
	methods of other objects, and as servers, by exposing their
	own methods to other objects.  
	See <a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch03_01.htm">Chapter 3, "Remote Method Invocation"</a>,
        for a tutorial on using RMI.
      </p>
<h3 class="sect2">1.3.3. Java IDL: CORBA Distributed Objects</h3>
<p>	As we've just seen, RMI is a distributed object solution that
	works well when both client and server are written in Java.  It
	does not work, however, in heterogenous environments where
	clients and servers may be written in arbitrary languages.  For
	environments like these, the Java 2 platform includes a
<a name="INDEX-44"></a><a name="INDEX-45"></a><a name="INDEX-46"></a>
	CORBA-based solution for remote method invocation on distributed
	objects.
      </p>
<p> 
	CORBA (Common Object Request Broker Architecture) is a
	widely used standard defined by the Object Management Group (OMG).
<a name="INDEX-47"></a><a name="INDEX-48"></a><a name="INDEX-49"></a>

	This standard is implemented as a core part of
	the Java 2 platform in the <tt class="literal">org.omg.CORBA</tt> package
	and its subpackages.  The implementation includes an Object Request
	Broker (ORB) that a Java application can use to communicate, as both a
	client and a server, with other ORBs, and thus with other CORBA
	objects.
      </p>
<p>	The interfaces to remote CORBA objects are described in a
	platform- and language-independent way with the Interface
	Description Language (IDL).  Sun provides an IDL compiler
	(in "early access" release at the time of this writing)
	that translates an IDL
	description of a remote interface into the Java stub classes
	needed for implementing the IDL interface in Java or for connecting
	to a remote implementation of the interface from your Java code.
      </p>
<p>	A number of Java
	implementations of the CORBA standard are available from various
	vendors.  This book documents Sun's implementation, known as
<a name="INDEX-50"></a>
	Java IDL.  It is covered in detail in <a href="ch04_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch04_01.htm">Chapter 4, "Java IDL"</a>.  The syntax of the IDL language itself is
	summarized in <a href="ch10_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch10_01.htm">Chapter 10, "IDL Reference"</a>.
      </p>
<h3 class="sect2">1.3.4. JNDI: Accessing Naming and Directory Services</h3>
<p>
<a name="INDEX-51"></a><a name="INDEX-52"></a><a name="INDEX-53"></a><a name="INDEX-54"></a><a name="INDEX-55"></a><a name="INDEX-56"></a>
        JNDI ( Java Naming and Directory Interface) is the Java
	Enterprise API for working with networked naming and directory
	services.  It allows Java programs to use name servers and
	directory servers to look up objects or data by name and search
	for objects or data according to a set of specified attribute
	values.  JNDI is implemented in the
	<tt class="literal">javax.naming</tt> package and its subpackages
	as a standard extension to
	the Java 2 platform.
      </p>
<p>
<a name="INDEX-57"></a>

	The JNDI API is not specific to any particular name or
	directory server protocol.  Instead, it is a generic API that
	is general enough to work with any name or directory server.
	To support a particular protocol, you plug a service provider for
	that protocol into a JNDI installation.  Service providers
	have been implemented for the most common protocols, such as NIS, LDAP,
	and Novell's NDS.  Service providers have also been written to
	interact with the RMI and CORBA object registries.
	JNDI is covered in detail in <a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch06_01.htm">Chapter 6, "JNDI"</a>.
      </p>
<h3 class="sect2">1.3.5. Enterprise JavaBeans</h3>
<p>
<a name="INDEX-58"></a><a name="INDEX-59"></a><a name="INDEX-60"></a><a name="INDEX-61"></a><a name="INDEX-62"></a>
	Enterprise JavaBeans do for server-side enterprise programs what
	JavaBeans do for client-side GUIs.  Enterprise JavaBeans (EJB)
	is a component model for units of business logic and business
	data.  Thin client programming models that take business logic
	out of the client and put it on a server or in a middle tier
	have many advantages in enterprise applications.  However, the
	task of writing this middleware has always been complicated by
	the fact that business logic must be mixed in with code for
	handling transactions, security, networking, and so on.
      </p>
<p>
<a name="INDEX-63"></a><a name="INDEX-64"></a><a name="INDEX-65"></a><a name="INDEX-66"></a>

	The EJB model separates high-level business logic from low-level
	housekeeping chores.  A bean in the EJB model is an RMI remote
	object that implements business logic or represents business
	data.  The difference between an enterprise bean and a
	run-of-the-mill RMI remote object is that EJB components run within
	an EJB container, which in turn runs within an EJB server. The
	container and server may provide features such as 
	transaction management, resource pooling, 
        lifecycle management, security, name services,
	distribution services, and so on.  With all these services
	provided by the container and server, enterprise beans (and
	enterprise bean programmers) are free to focus purely on
	business logic. The particular set of services provided by an
	EJB server is implementation-dependent.  The EJB specification
	is strongest in the areas of
transaction management and resource pooling, so these are
	features that are expected in all EJB server implementations.
<a name="INDEX-67"></a>
</p>
<p>	The EJB specification is a document that specifies the contracts
	to be maintained and conventions to be followed by EJB servers,
	containers, and beans.  Writing EJB components is easy: you simply
	write code to implement your business logic, taking care to
	follow the rules and conventions imposed by the EJB model.
      </p>
<p>
<a name="INDEX-68"></a>
	Unlike the other Java Enterprise APIs, EJB is not really an API;
	it is a framework for component-based enterprise computing.  The
	key to understanding Enterprise JavaBeans lies in the
	interactions among beans, containers, and the EJB server.  These
	interactions are described in detail in <a href="ch07_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch07_01.htm">Chapter 7, "Enterprise JavaBeans"</a>.  There is,
	of course, an API associated with the EJB application
	framework, in the form of the <tt class="literal">javax.ejb</tt> and
	<tt class="literal">javax.ejb.deployment</tt> packages.  You'll
<a name="INDEX-69"></a><a name="INDEX-70"></a>
	find complete API quick-reference information for these packages
	in <a href="part3.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/part3.htm">Part 3, "API Quick Reference"</a>.
      </p>
<h3 class="sect2">1.3.6. Servlets</h3>
<p>	A <em class="emphasis">servlet</em> is a piece of Java code that runs
<a name="INDEX-71"></a>
	within a server to provide a service to a client. The name
	servlet is a takeoff on applet--a servlet is
	a server-side applet. The Java Servlet API provides a generic
<a name="INDEX-72"></a>
	mechanism for extending the functionality of any kind of server
	that uses a protocol based on requests and responses.
      </p>
<p> 
	Right now, servlets are used primarily by web servers.
<a name="INDEX-73"></a>
	On the growing number of web servers that support them, servlets
	are a Java-based replacement for CGI scripts.  They can also
	replace competing technologies, such as Microsoft's Active Server Pages (ASP) or Netscape's Server-Side
	JavaScript.  The advantage of servlets over these other
	technologies is that servlets are portable among operating
	systems and among servers.  Servlets are persistent between
	invocations, which gives them major performance benefits over
	CGI programs.  Servlets also have full access to the rest of the
	Java platform, so features such as database access are automatically
	supported.  
      </p>
<p>	The Servlet API differs from many other Java Enterprise APIs in
	that it is not a Java layer on top of an existing network
	service or protocol.  Instead, servlets are a Java-specific
	enhancement to the world of enterprise computing.  With the
	advent of the Internet and the World Wide Web, many enterprises
	are interested in taking advantage of web browsers--a
<a name="INDEX-74"></a><a name="INDEX-75"></a>
	universally available thin-client that can run on any desktop.
	Under this model, the web server becomes enterprise middleware
	and is responsible for running applications for clients.
	Servlets are a perfect fit here.  The user makes a request to
	the web server, the web server invokes the appropriate servlet, and
	the servlet uses JNDI, JDBC, and other Java Enterprise APIs to
	fulfill the request, returning the result to the
	user, usually in the form of HTML-formatted text.
      </p>
<p>	The Servlet API is a standard extension to the Java 2
<a name="INDEX-76"></a><a name="INDEX-77"></a>
	platform, implemented in the <tt class="literal">javax.servlet</tt>
	and <tt class="literal">javax.servlet.http</tt> packages.  The
	<tt class="literal">javax.servlet</tt> package defines classes that
	represent generic client requests and server responses, while the
	<tt class="literal">javax.servlet.http</tt> package provides
	specific support for the HTTP protocol, including classes for
<a name="INDEX-78"></a><a name="INDEX-79"></a><a name="INDEX-80"></a>
	tracking multiple client requests that are all part of a
	single client session.  See <a href="ch05_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch05_01.htm">Chapter 5, "Java Servlets"</a>, for details on servlet
	programming.  
      </p>
<h3 class="sect2">1.3.7. JMS: Enterprise Messaging</h3>
<p>	JMS ( Java Message Service) is the Java Enterprise API for
<a name="INDEX-81"></a><a name="INDEX-82"></a>
	working with networked messaging services and for writing
	message-oriented middleware (fondly referred to as MOM).
<a name="INDEX-83"></a><a name="INDEX-84"></a>
</p>
<p>	The word "message" means 
	different things in different contexts.
	In the context of JMS, a message is chunk of data that is sent
	from one system to another.  The data serves as a kind of event
<a name="INDEX-85"></a>
	notification and is almost always intended to be read by a
	computer program, not by a human.  In a nondistributed system,
	an <tt class="literal">Event</tt> object notifies the program
<a name="INDEX-86"></a>
	that some important event (such as the user clicking a mouse button)
	has occurred.  In a distributed system, a message serves a
	similar purpose: it notifies some part of the system that an
	interesting event has occurred.  So you can think of a 
	networked message service as a distributed event notification system.
      </p>
<p>	Like JNDI and JDBC, JMS is an API layered on top of existing,
	vendor-specific messaging services.  In order to use JMS in your
<a name="INDEX-87"></a>
	applications, you need to obtain a JMS provider
	implementation that supports your particular message server.  
      </p>
<p>	Although JMS is an important part of the Java Enterprise APIs,
	its use is not nearly as universal as APIs such as JDBC and
	JNDI, so this book does not contain a tutorial chapter on JMS.  
	<a href="ch21_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch21_01.htm">Chapter 21, "The javax.jms Package"</a>, does contain a complete API
	quick reference for the <tt class="literal">javax.jms</tt> package, however.
      </p>
<h3 class="sect2">1.3.8. JTA: Managing Distributed Transactions</h3>
<p>
<a name="INDEX-88"></a><a name="INDEX-89"></a>
	The JTA, or Java Transaction API, is a Java Enterprise API for
	managing distributed transactions.  Distributed transactions are
	one of the things that make distributed systems more complicated
	than nondistributed programs.  To understand distributed
	transactions, you must first understand simple, nondistributed
	transactions.  
      </p>
<p>	A <em class="emphasis">transaction</em> is a group of 
	several operations that must behave
	<em class="emphasis">atomically</em>--as if they constituted a
<a name="INDEX-90"></a>
	single, indivisible operation.  Consider 
	a banking application that allows a user to transfer
	money from a checking account to a savings account.  If the
	two account balances are
	stored in a database, the application must perform two database
	updates to handle a transfer: 
	it must subtract money from the checking account and
	add money to the savings account.  These two operations must 
	behave atomically.  To see why, imagine what would happen if the
	database server crashed after money had been subtracted from the
	checking account but before it had been added to the savings
	account.  The customer would lose money!
      </p>
<p>	To make multiple operations atomic, we use transactions.  In our
	banking example, we first begin a
	transaction, then perform the two database updates.  While these
	updates are in progress, no other threads can see
	the updated account balances.  If both updates complete 
	successfully, we
	end the transaction by <em class="emphasis">committing</em> it.
<a name="INDEX-91"></a><a name="INDEX-92"></a>
	This makes the updated account balances available to any
	other clients of the database.  On the other hand, if either of
	the database updates fails, we 
	<em class="emphasis">roll back</em> the transaction, 
	reverting the accounts to their original balances.  
	Other clients are
	again given access to the database, and they see no
	changes in the account balances.
	The JDBC API supports transactions on databases.
<a name="INDEX-93"></a>
	The database server is required to do some complex work to
	support transactions, but for the application
	programmer, the API is easy: simply begin a transaction,
	perform the desired operations, and then either 
	commit or rollback the
	transaction.  
      </p>
<p>	Distributed transactions are, unfortunately, quite a bit more
	complex than the simple transactions just described.  Imagine,
	for example, a program that transfers money from an account
	stored in one database to another account stored in a
	different database running on a different server.  In this case,
	there are two different servers involved in the transaction, so
	the process of committing or rolling back the transaction must
	be externally coordinated.  Distributed transactions are
<a name="INDEX-94"></a><a name="INDEX-95"></a>
	performed using a complex procedure known as the <em class="emphasis">two-phase
	commit protocol</em>; the details of the protocol are not important
	here.  What is important is that we could write our account 
	transfer code so that it
	implements the two-phase commit protocol itself, coordinating
	the entire distributed transaction with the two database
	servers.  This would be tedious and error-prone, however.  In
	practice, distributed transactions are coordinated by a
	specialized distributed transaction service.
      </p>
<p>	This brings us, finally, to the JTA.  The JTA is a Java API for
	working with transaction services.  It defines a Java binding for
<a name="INDEX-96"></a>
	the standard XA API for distributed transactions (XA is a
	standard defined by the Open Group).  Using the JTA, we can
	write a program that communicates with a distributed transaction
	service and uses that service to coordinate a distributed
	transaction that involves a transfer of money between database
	records in two different databases.
      </p>
<p>	Unfortunately, however, using the JTA in this way is still
	complex and error-prone.  Modern enterprise applications are
<a name="INDEX-97"></a>
	typically designed to run within some kind of application
	server, such as an Enterprise JavaBeans server.  The server
	uses JTA to handle distributed transactions transparently for
	the application.  Under this model, JTA becomes a low-level API
	used by server implementors, not by typical enterprise
	programmers.  Therefore, this book doesn't include a tutorial
	chapter on JTA. It does, however, contain 
	a complete API quick reference
	for the <tt class="literal">javax.transaction</tt> and
<a name="INDEX-98"></a><a name="INDEX-99"></a><tt class="literal">javax.transactions.xa</tt> packages (see <a href="ch28_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch28_01.htm">Chapter 28, "The javax.transaction Package"</a> and <a href="ch29_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch29_01.htm">Chapter 29, "The javax.transaction.xa Package"</a>).
<a name="INDEX-100"></a>
</p>

<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch01_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch01_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/ch01_04.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">1.2. Enterprise Computing Demystified</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">1.4. Enterprise Computing Scenarios</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="../dist/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
