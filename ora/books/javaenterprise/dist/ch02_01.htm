<html>
<head>
<title>Networking in Java (Java Distributed Computing)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Jim Farley">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-206-9E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Networking in Java">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm" alt="Java Distributed Computing"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch01_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm">Java Distributed Computing</a></td><td align="right" valign="top" width="172"><a href="ch02_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch02_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->

<h1 class="chapter">Chapter 2.  Networking in Java</h1>
<div class="htmltoc">
<h4 class="tochead">Contents:</h4>
<p>
<a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch02_01.htm">Sockets and Streams</a>
<br>
<a href="ch02_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch02_02.htm">URLs, URLConnections, and ContentHandlers</a>
<br>
<a href="ch02_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch02_03.htm">The ClassLoader</a>
<br>
</p>
</div>



<p>We saw in <a href="ch01_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch01_01.htm">Chapter 1, "Introduction"</a> how the socket and stream
classes in the <tt class="literal">java.net</tt> and
<tt class="literal">java.io</tt> packages could be used to do basic
networking between agents. In this chapter we take a more detailed
look at the networking support in Java, as the foundation for
distributed systems. The topics we'll cover include:
</p>

<ul>
<li>
<p>Sockets for low-level network connections</p>
</li>
<li>
<p>Streams for formatted data and messaging protocols</p>
</li>
<li>
<p>
<tt class="literal">URL</tt>, <tt class="literal">URLConnection</tt>, and
<tt class="literal">ContentHandler</tt> classes
</p>
</li>
<li>
<p>The <tt class="literal">ClassLoader</tt> as an object distribution scheme</p>
</li>
</ul>

<p>We'll look at these topics in increasing pecking order from the
networking perspective. Sockets first, since they are the most
primitive communication object in the Java API; then streams, which
let you impose some order on the data flowing over these sockets;
next, the classes associated with the HTTP protocol, namely, the
<tt class="literal">URL</tt>, <tt class="literal">URLConnection</tt>, and
<tt class="literal">ContentHandler</tt> classes; finally, the
<tt class="literal">ClassLoader</tt>, which, when coupled with the
others, offers the ability to transmit actual Java classes over the
wire.
</p>




<h2 class="sect1">2.1. Sockets and Streams</h2>

<p>
<a name="INDEX-124"></a>The
<tt class="literal">java.net</tt><a name="INDEX-125"></a> package provides an object-oriented
framework for the creation and use of <a name="INDEX-126"></a><a name="INDEX-127"></a>Internet Protocol (IP)<a href="#FOOTNOTE-1">[1]</a> sockets. In this section,
we'll take a look at these classes and what they offer.
</p>
<blockquote class="footnote">
<a name="FOOTNOTE-1"></a>
<p>[1]The Internet Protocol is the predominant networking protocol
today, being the protocol in use on the Internet and on most
corporate WANs and LANs.</p> </blockquote>

<a name="JDP-CH-2-SECT-1.1"></a>
<h3 class="sect2">2.1.1. IP Addressing</h3>

<p>
<a name="INDEX-128"></a><a name="INDEX-129"></a><a name="INDEX-130"></a> Before
communicating with another party, you must first know how to address
your messages so they can be delivered correctly. Notice that I
didn't say that you need to know where the other party is
located--once a scheme for encoding a location is established, I
simply need to know my party's encoded address to communicate.
On IP networks, the addressing scheme in use is based on hosts and
port numbers.
</p>

<p>
<a name="INDEX-131"></a><a name="INDEX-132"></a>A
given host computer on an IP network has a hostname and a numeric
address. Either of these, in their fully qualified forms, is a unique
identifier for a host on the network. The JavaSoft home page, for
example, resides on a host named
<em class="emphasis">www.javasoft.com</em>, which currently has the IP
address <em class="emphasis">204.160.241.98</em>. Either of these addresses
can be used to locate the machine on an IP network. The textual name
for the machine is called its <a name="INDEX-133"></a><a name="INDEX-134"></a>Domain Name Services (DNS) name, which
can be thought of as a kind of alias for the numeric IP address.
</p>

<p>In the Java API, the
<tt class="literal">InetAddress</tt><a name="INDEX-135"></a> class represents an IP address. You can
query an <tt class="literal">InetAddress</tt> for the name of the host
using its
<tt class="literal">getHostName()</tt><a name="INDEX-136"></a> method, and for its numeric address using
<tt class="literal">getAddress()</tt><a name="INDEX-137"></a> . Notice that, even though we can uniquely
specify a host with its IP address, we do not necessarily know its
physical location. I look at the web pages on
<em class="emphasis">www.javasoft.com</em> regularly, but I don't
know where the machine is (though I could guess that it's in
California somewhere). Conversely, even if I knew where the machine
was physically, it wouldn't do me a bit of good if I
didn't know its IP address (unless someone was kind enough to
label the machine with it, or left a terminal window open on the
server's console for me to get its IP address directly).
</p>

<p>Now, you typically don't want to communicate with a given
host, but rather with one or many agent processes running on the host.
<a name="INDEX-138"></a>To engage in
network communications, each process must associate itself with a port
on the host, identified by a number. HTTP servers, for example,
typically attach themselves to port 80 on their host machine. When you
ask to connect to <em class="emphasis">http://www.javasoft.com/</em> from
your web browser, the browser automatically assumes the default port
and attempts to connect to the process running on
<em class="emphasis">www.javasoft.com</em> listening to port 80. If this
process is an HTTP server process that understands the commands that
the browser is sending, the browser and the server will commence
communications.  </p>

<p>This host/port scheme is the basis of the IP addressing protocol, and
is supported directly in the Java API. All network connections are
specified using an <tt class="literal">Inet-Address</tt> and a port
number. The Java environment does the hard work of initiating the IP
protocol communications and creating Java objects that represent
these network connections.
</p>


<a name="JDP-CH-2-SECT-1.2"></a>
<h3 class="sect2">2.1.2. Your Basic Socket</h3>

<p>
<a name="INDEX-139"></a>At the
core of Java's networking support are the
<tt class="literal">Socket</tt><a name="INDEX-140"></a><a name="INDEX-141"></a><a name="INDEX-142"></a> and <tt class="literal">DatagramSocket</tt>
classes in <tt class="literal">java.net</tt>. These classes define
channels for communication between processes over an IP network. A
new socket is created by specifying a host, either by name or with an
<tt class="literal">InetAddress</tt> object, and a port number on the
host. There are two basic flavors of network sockets on IP networks:
those that use the <a name="INDEX-143"></a><a name="INDEX-144"></a>Transmission Control Protocol
(TCP) and those that use the <a name="INDEX-145"></a><a name="INDEX-146"></a>User Datagram Protocol (UDP). TCP is
a reliable protocol in which data packets are guaranteed to be
delivered, and delivered in order. If a packet expected at the
receiving end of a TCP socket doesn't arrive in a set period of
time, then it is assumed lost, and the packet is requested from the
sender again. The receiver doesn't move on to the next packet
until the first is received. UDP, on the other hand, makes no
guarantees about delivery of packets, or the order in which packets
are delivered. The sender transmits a UDP packet, and it either makes
it to the receiver or it doesn't. TCP sockets are used in the
large majority of IP applications. UDP sockets are typically used in
bandwidth-limited applications, where the overhead associated with
resending packets is not tolerable. A good example of this is
real-time network audio applications. If you are delivering packets
of audio information over the network to be played in real-time, then
there is no point in resending a late packet. By the time it gets
delivered it will be useless, since the audio track must play
continuously and sequentially, without backtracking.
</p>

<p>The <tt class="literal">Socket</tt> class is used for creating TCP
connections over an IP network. A <tt class="literal">Socket</tt> is
typically created using an <tt class="literal">InetAddress</tt> to
specify the remote host, and a port number to which the host can
connect. A process on the remote host must be listening on that port
number for incoming connection requests. In Java, this can be done
using a
<tt class="literal">ServerSocket</tt><a name="INDEX-147"></a>:
</p>

<blockquote>
<pre class="programlisting">// Listen to port 5000 on the local host for socket connection requests
ServerSocket s = new ServerSocket(5000);
while (true) {
    // Wait for a connection request from a client
    Socket clientConn = s.accept();
    InputStream in = clientConn.getInputStream();
    OutputStream out = clientConn.getOutputStream();
    // Now we have input and output streams connected to our client, do
    // something with them...</pre>
</blockquote>

<p>On client side, the code simply creates a socket to the remote host
on the specified port (5000, in this case):
</p>

<blockquote>
<pre class="programlisting">// Create the socket
InetAddress addr = InetAddress.getByName("our.remote.host");
Socket s = new Socket(addr, 5000);
InputStream in = s.getInputStream();
OutputStream out = s.getOutputStream();
// We've got input/output streams to the remote process,
// now do something with them...</pre>
</blockquote>

<p>UDP socket connections are created and used through the
<tt class="literal">DatagramSocket</tt> and
<tt class="literal">DatagramPacket</tt> classes. A
<tt class="literal">DatagramSocket</tt> sends and receives data using UDP
packets, represented as <tt class="literal">DatagramPacket</tt> objects.
Before two agents can talk to each other over a UDP connection, they
both have to have a <tt class="literal">DatagramSocket</tt> connected to
a port on their local machines. This is done by simply creating a
<tt class="literal">DatagramSocket</tt> object:
</p>

<blockquote>
<pre class="programlisting">DatagramSocket udpSocket = new DatagramSocket(5000);</pre>
</blockquote>

<p>In this example we are connecting a UDP socket to a specific port
(5000) on the local host. If we don't particularly care which
port is used, then we can construct the
<tt class="literal">DatagramSocket</tt> without specifying the port. An
unused port on the local host will be used, and we can find out which
one by asking the new socket for its port number:
</p>

<blockquote>
<pre class="programlisting">DatagramSocket udpSocket = new DatagramSocket();
int portNo = udpSocket.getLocalPort();</pre>
</blockquote>

<p>In order for two agents to send data to each other over a UDP socket,
they must know the host name and port number of each other's
socket connection. So they will either have preordained ports for
each other and will create <tt class="literal">DatagramSockets</tt> using
these port numbers, or they will create a socket on a random local
port and transmit their port numbers to each other over another
connection.<a name="INDEX-148"></a>
</p>

<p>Data is sent over a <tt class="literal">DatagramSocket</tt> using
<tt class="literal">DatagramPacket</tt><a name="INDEX-149"></a> objects. Each
<tt class="literal">DatagramPacket</tt> contains a data buffer, the
address of the remote host to send the data to, and the port number
the remote agent is listening to. So to send a buffer of data to a
process listening to port 5000 on host
<em class="emphasis">my.host.com</em>, we would do something like this:
</p>

<blockquote>
<pre class="programlisting">byte[] dataBuf = {'h', 'i', ' ', 't', 'h', 'e', 'r', 'e'};
InetAddress addr = InetAddress.getByName("my.host.com");
DatagramPacket p = 
    new DatagramPacket(dataBuf, dataBuf.length, addr, 5000);
udpSocket.send(p);</pre>
</blockquote>

<p>The remote process can receive the data in the form of a
<tt class="literal">DatagramPacket</tt> by calling the
<tt class="literal">receive()</tt> method on its
<tt class="literal">DatagramSocket</tt>. The received
<tt class="literal">DatagramPacket</tt> will have the host address and
port of the sender filled in as a side-effect of the call.
</p>

<p>Note that in all of the examples, we would have to catch the
appropriate exceptions and handle them. Sending a
<tt class="literal">DatagramPacket</tt>, for example, can generate an
<tt class="literal">IOException</tt> if the network transmission fails
for some reason. A robust networked program will catch this exception
and behave appropriately, perhaps by resending the packet if the
application warrants, or perhaps by simply noting the lost packet and
continuing.<a name="INDEX-150"></a><a name="INDEX-151"></a><a name="INDEX-152"></a>
</p>


<a name="JDP-CH-2-SECT-1.3"></a>
<h3 class="sect2">2.1.3. Multicast Sockets</h3>

<p>
<a name="INDEX-153"></a><a name="INDEX-154"></a><a name="INDEX-155"></a>
There is a subset of the IP protocol that supports
<em class="emphasis">multicasting</em><a name="INDEX-156"></a><a name="INDEX-157"></a><a name="INDEX-158"></a><a name="INDEX-159"></a> .
Multicasting can be thought of as broadcasting data over a network
connection to many connected agents, as opposed to unicasting packets
between two agents on a normal connection. Multicasting is done using
UDP packets that are broadcast out on a multicast IP address. Any
agent "listening in" to that IP address will receive the
data packets that are broadcast. The analogy to radio and television
broadcasting is no accident--the very first practical uses of
multicast IP were for broadcasting audio and video over the Internet
from special events.<a href="#FOOTNOTE-2">[2]</a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-2"></a>
<p>[2]For more information on the
history of the multicast backbone (MBONE) and its current state,
visit <a href="../../../../../../../www.mbone.com/.">http://www.mbone.com/.</a>
</p> </blockquote>

<p>Java supports multicast IP through the
<tt class="literal">java.net.MulticastSocket</tt><a name="INDEX-160"></a> class, which is an extension of the
<tt class="literal">DatagramSocket</tt> class. Joining a multicast group
is done almost the same way that you would establish a UDP connection
between two agents. Each agent that wants to listen on the multicast
address creates a <tt class="literal">MulticastSocket</tt> and then joins
the multicast session by calling the
<tt class="literal">joinGroup()</tt><a name="INDEX-161"></a>
method on the <tt class="literal">MulticastSocket</tt>:
</p>

<blockquote>
<pre class="programlisting">MulticastSocket ms = new MulticastSocket();
InetAddress sessAddr = InetAddress.getByName("224.2.76.24");
ms.joinGroup(sessAddr);</pre>
</blockquote>

<p>Once the connection to the multicast session is established, the
agent can read data being broadcast on the multicast
"channel":
</p>

<blockquote>
<pre class="programlisting">byte[] audioBuf = new byte[1024];
DatagramPacket dp = new DatagramPacket(audioBuf, 1024);
ms.receive(dp);
// Play the data on a fictitious audio device
myAudioDevice.play(dp.getData());</pre>
</blockquote>

<p>Data can also be sent out on the multicast channel to all the other
listening agents using the
<tt class="literal">send()</tt><a name="INDEX-162"></a> method on the
<tt class="literal">MulticastSocket</tt>.
</p>

<p>Once the broadcast is over, or we simply want to stop listening, we
can disconnect from the session using the <tt class="literal">leaveGroup()
</tt><a name="INDEX-163"></a>
method:
</p>

<blockquote>
<pre class="programlisting">ms.leaveGroup(sessAddr);</pre>
</blockquote>

<p>Multicasting is useful when we want to connect many agents together
on a common communication channel. Shared audio and video channels
are the most obvious uses, but multicasting can also be applied in
collaborative tools like shared whiteboards, or between application
servers performing synchronization tasks, like load balancing.
However, since multicast IP is based on UDP, you have to be willing
to accept the possibility of losing some data along the way, and
dealing with it gracefully. Also, since clients can join a multicast
session asynchronously, they have to be ready to synchronize
themselves with the current state of the multicast session when they
join.<a name="INDEX-164"></a><a name="INDEX-165"></a><a name="INDEX-166"></a>
</p>


<a name="JDP-CH-2-SECT-1.4"></a>
<h3 class="sect2">2.1.4. Streams, Readers, and Writers for Input and Output</h3>

<p>
<a name="INDEX-167"></a><a name="INDEX-168"></a><a name="INDEX-169"></a><a name="INDEX-170"></a><a name="INDEX-171"></a>
Once we make a connection between two processes over the network, we
need a simple, easy way to send and receive data in different formats
over the connection. Java provides this through the stream classes in
the <tt class="literal">java.io</tt><a name="INDEX-172"></a>
package. Included in the <tt class="literal">java.io</tt> package are the
<tt class="literal">InputStream</tt> and
<tt class="literal">OutputStream</tt> classes and their subclasses for
byte-based I/O, and the <tt class="literal">Reader</tt> and
<tt class="literal">Writer</tt> classes and their subclasses for
character-based I/O. The <tt class="literal">InputStream</tt> and
<tt class="literal">OutputStream</tt> classes handle data as bytes, with
basic methods for reading and writing bytes and byte arrays. Their
subclasses can connect to various sources and destinations (files,
string buffers), and provide methods for directly sending and
receiving basic Java data types, like floating-point values. The
<tt class="literal">Reader</tt> and <tt class="literal">Writer</tt> classes
transmit data in the form of 16-bit Unicode characters, which
provides a platform-independent way to send and receive textual data.
Like the <tt class="literal">InputStream</tt> and
<tt class="literal">OutputStream</tt> subclasses, the subclasses of
<tt class="literal">Reader</tt> and <tt class="literal">Writer</tt>
specialize in terms of their source and destination types.
</p>

<p>A <tt class="literal">Socket</tt>, once it's created, can be
queried for its input/output streams using
<tt class="literal">getInputStream()</tt><a name="INDEX-173"></a><a name="INDEX-174"></a> and
<tt class="literal">getOutputStream()</tt>. These methods return
in-stances of <tt class="literal">InputStream</tt> and
<tt class="literal">OutputStream</tt>, respectively. If you need to
exchange mostly character-based data between two agents in your
distributed system, then you can wrap the
<tt class="literal">InputStream</tt> with an
<tt class="literal">InputStreamReader</tt><a name="INDEX-175"></a><a name="INDEX-176"></a>(a subclass of
<tt class="literal">Reader</tt>), or the
<tt class="literal">OutputStream</tt> with an
<tt class="literal">OutputStreamWriter</tt> (a subclass of
<tt class="literal">Writer</tt>).
</p>

<p>Another way to create an interprocess communication link is to use
the <tt class="literal">java.lang.Runtime</tt><a name="INDEX-177"></a> interface to execute a process, then
obtain the input and output streams from the returned
<tt class="literal">Process</tt> object, as shown in <a href="#JDP-CH-2-EX-2">Example 2-1</a>. You would do this if you had a local subtask
that needed to run in a separate process, but with which you still
needed to exchange messages.
</p>

<a name="JDP-CH-2-EX-2"></a>
<div class="example">
<h4 class="objtitle">Example 2-1. Interprocess I/O Using Runtime-Executed Processes</h4>
<blockquote>
<pre class="programlisting">Runtime r = Runtime.getRuntime();
Process p = r.exec("/bin/ls /tmp");
InputStream in = p.getInputStream();
OutputStream out = p.getOutputStream();</pre>
</blockquote>
</div>

<p>From the abstract I/O classes, the <tt class="literal">java.io</tt>
package offers several specializations which vary the format of the
data transmitted over the stream, as well as the type of data
source/receiver at the ends of the stream. The
<tt class="literal">InputStream</tt>, <tt class="literal">OutputStream</tt>,
<tt class="literal">Reader</tt>, and <tt class="literal">Writer</tt> classes
provide basic interfaces for data I/O (<tt class="literal">read()</tt>
and <tt class="literal">write()</tt> methods that just transfer bytes,
byte arrays, characters and character arrays). To define data types
and communication protocols on top of these base classes, Java offers
the <tt class="literal">FilterInputStream</tt><a name="INDEX-178"></a><a name="INDEX-179"></a> and
<tt class="literal">FilterOutputStream</tt> classes for
<a name="INDEX-180"></a> byte-oriented I/O, and the
<tt class="literal">FilterReader</tt><a name="INDEX-181"></a><a name="INDEX-182"></a> and <tt class="literal">FilterWriter</tt> for
<a name="INDEX-183"></a>
character-based I/O. Subclasses of these offer a higher level of
control and structure to the data transfers. A
<tt class="literal">BufferedInputStream</tt><a name="INDEX-184"></a><a name="INDEX-185"></a> or <tt class="literal">BufferedReader</tt>
uses a memory buffer for efficient reading of data. The overhead
associated with data read requests is minimized by performing large
data reads into a buffer, and offering data to the caller from the
local buffer until it's been exhausted. This feature can be
used to minimize the latency associated with slow source devices and
communication media. The
<tt class="literal">BufferedOutputStream</tt><a name="INDEX-186"></a><a name="INDEX-187"></a> or <tt class="literal">BufferedWriter</tt>
performs the same service on outgoing data. A
<tt class="literal">PushbackInputStream</tt><a name="INDEX-188"></a><a name="INDEX-189"></a> or <tt class="literal">PushbackReader</tt>
provides a buffer for pushing back data onto the incoming data
stream. This is useful in parsing applications, where the next branch
in the parse tree is determined by peeking at the next few bytes or
characters in the stream, and then letting the subparser operate on
the data. The other interesting subclasses of
<tt class="literal">FilterInputStream</tt> and
<tt class="literal">FilterOutputStream</tt> are the
<tt class="literal">DataInputStream</tt><a name="INDEX-190"></a><a name="INDEX-191"></a> and <tt class="literal">DataOutputStream</tt>
classes. These classes read and write Java data primitives in a
portable binary format. There aren't similar subclasses of
<tt class="literal">FilterReader</tt> and
<tt class="literal">FilterWriter</tt>, since <tt class="literal">Readers</tt>
and <tt class="literal">Writers</tt> only transfer character data, and
the serialized form of Java data types are represented in
bytes.<a name="INDEX-192"></a>
</p>

<p>Besides being useful in their own right for manipulating and
formatting input/output data streams, the subclasses of
<tt class="literal">FilterInputStream</tt>,
<tt class="literal">FilterOutputStream</tt>,
<tt class="literal">FilterReader</tt>, and
<tt class="literal">FilterWriter</tt> are also well suited for further
specialization to define application-specific data stream protocols.
Each of the stream classes offers a constructor method, which accepts
an <tt class="literal">InputStream</tt> or
<tt class="literal">OutputStream</tt> as an argument. Likewise, the
<tt class="literal">FilterReader</tt> class has a constructor that
accepts a <tt class="literal">Reader</tt>, and
<tt class="literal">FilterWriter</tt> has a constructor that accepts a
<tt class="literal">Writer</tt> object. In each case, the constructor
argument is taken as the source or sink of the stream that is to be
filtered, which enables the construction of stream filter
"pipelines." So defining a special-purpose data protocol
is simply a matter of subclassing from an appropriate I/O class, and
wrapping an existing data source or sink with the new filter.
</p>

<p>For example, if we wanted to read an <a name="INDEX-193"></a><a name="INDEX-194"></a>XDR-formatted<a href="#FOOTNOTE-3">[3]</a> data stream, we could write a
subclass of <tt class="literal">FilterInputStream</tt> that would offer
the same methods to read Java primitive data types as
<tt class="literal">DataInputStream</tt>, but would be implemented to
parse the XDR format, rather than the portable binary format of the
<tt class="literal">DataInputStream</tt>. <a href="#JDP-CH-2-EX-3">Example 2-2</a>
shows a skeleton for the input version of this kind of stream; <a href="#JDP-CH-2-EX-3">Example 2-2</a> shows a sample application using the stream.
The application first connects to a host and port, where presumably
another process is waiting to accept this connection. The remote
process uses XDR-formatted data to communicate, so we wrap the input
stream from the socket connection with our
<tt class="literal">XDRInputStream</tt> and begin reading data.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-3"></a>
<p>[3]XDR
is the binary format underlying Remote Procedure Call (RPC) data
connections.</p> </blockquote>

<a name="JDP-CH-2-EX-3"></a>
<div class="example">
<h4 class="objtitle">Example 2-2. An InputStream Subclass for Reading XDR-Formatted Data</h4>
<blockquote>
<pre class="programlisting">package dcj.examples;

import java.io.*;
import java.net.*;

class XDRInputStream extends FilterInputStream {
  public XDRInputStream(InputStream in) {
    super(in);
  }

  // Overridden methods from FilterInputStream, implemented
  // to read XDR-formatted data

  public boolean readBoolean() throws IOException;
  public byte    readByte() throws IOException;
  public int     readUnsignedByte() thows IOException;
  public float   readFloat() thows IOException;
  // Other readXXX() methods omitted in this example...

  // We'll assume this stream doesn't support mark/reset operations

  public boolean markSupported() { return false; }
}</pre>
</blockquote>
</div>

<a name="JDP-CH-2-EX-4"></a>
<div class="example">
<h4 class="objtitle">Example 2-3. Example XDRInputStream Client</h4>
<blockquote>
<pre class="programlisting">import dcj.examples.XDRInputStream;
import java.io.*;

class XDRInputExample
{
  public static void main(String argv[])
    {
      String host = argv[0];

      // Default port is 5001
      int port = 5001;

      try
        {
          port = Integer.parseInt(argv[1]);
        }
      catch (NumberFormatException e)
        {
          System.out.println("Bad port number given, using default "
                             + port);
        }

      // Try connecting to specified host and port
      Socket serverConn = null;
      try { serverConn = new Socket(host, port); }
      catch (UnknownHostException e)
        {
          System.out.println("Bad host name given.");
          System.exit(1);
        }

      // Wrap an XDR stream around the input stream
      XDRInputStream xin = new XDRInputStream(serverConn.getInputStream());

      // Start reading expected data from XDR-formatted stream
      int numVals = xin.readInt();
      float val1 = xin.readFloat();
      ...
    }
}</pre>
</blockquote>
</div>

<a name="INDEX-195"></a>
<a name="INDEX-196"></a>
<a name="INDEX-197"></a>
<a name="INDEX-198"></a>
<a name="INDEX-199"></a>
<a name="INDEX-200"></a>

<p>The classes in the <tt class="literal">java.io</tt> package also offer
the ability to specialize the sources and destinations of
data.<tt class="literal"></tt><a href="#JDP-CH-2-TABLE-2">Table 2-1</a> summarizes
the various stream, writer, and reader classes in
<tt class="literal">java.io</tt>, and the types of sources and
destinations that they can access. The purpose and use of the file,
byte-array, and string classes are fairly obvious, and we won't
spend any time going into detail about them here, since we'll
see them being used in some of the examples later in the book. The
stream classes that allow communication between threads deserve some
explanation, though.
</p>

<a name="JDP-CH-2-TABLE-2"></a>
<h4 class="objtitle">Table 2-1. Source and Destination Types Supported by java.io</h4>
<table border="1">




<tr>
<th>
<p>Source/Destination Type</p>
</th>
<th>
<p>Input/OutputStream </p>

<p>Class</p>
</th>
<th>
<p>Reader/Writer </p>

<p>Class</p>
</th>
</tr>

<tr>
<td>
<p>Remote or local process</p>
</td>
<td>
<blockquote>
<pre class="programlisting">InputStream
OutputStream</pre>
</blockquote>

<p>(created from <tt class="literal">Socket</tt> or </p>

<p>from <tt class="literal">Process</tt>)</p>
</td>
<td>
<blockquote>
<pre class="programlisting">InputStreamReader
OutputStreamWriter</pre>
</blockquote>

<p>(wrappers around </p>

<p>
<tt class="literal">InputStream</tt> or </p>

<p>
<tt class="literal">OutputStream</tt> objects)</p>
</td>
</tr>
<tr>
<td>
<p>Disk files</p>
</td>
<td>
<blockquote>
<pre class="programlisting">FileInputStream
FileOutputStream</pre>
</blockquote>
</td>
<td>
<blockquote>
<pre class="programlisting">FileReader
FileWriter</pre>
</blockquote>
</td>
</tr>
<tr>
<td>
<p>In-memory data buffers</p>
</td>
<td>
<a name="INDEX-201"></a>
<a name="INDEX-202"></a>
<a name="INDEX-203"></a>
<a name="INDEX-204"></a>
<blockquote>
<pre class="programlisting">ByteArrayInputStream
ByteArrayOutputStream</pre>
</blockquote>
</td>
<td>
<blockquote>
<pre class="programlisting">CharArrayReader
CharArrayWriter</pre>
</blockquote>
</td>
</tr>
<tr>
<td>
<p>In-memory string buffers</p>
</td>
<td>
<blockquote>
<pre class="programlisting">StringBufferInputStream</pre>
</blockquote>

<a name="INDEX-205"></a>
<a name="INDEX-206"></a>
<a name="INDEX-207"></a>

<p>(input only)</p>

<p>(deprecated in JDK 1.1, use <tt class="literal">StringReader</tt> instead)</p>
</td>
<td>
<blockquote>
<pre class="programlisting">StringReader
StringWriter</pre>
</blockquote>
</td>
</tr>
<tr>
<td>
<p>Threads within same process</p>
</td>
<td>
<blockquote>
<pre class="programlisting">PipedInputStream
PipedOutputStream</pre>
</blockquote>
</td>
<td>
<blockquote>
<pre class="programlisting">PipedReader
PipedWriter</pre>
</blockquote>
</td>
</tr>

</table>

<p>The <tt class="literal">PipedInputStream</tt><a name="INDEX-208"></a><a name="INDEX-209"></a><a name="INDEX-210"></a> and
<tt class="literal">PipedOutputStream</tt> classes access data from each
other. That is, a <tt class="literal">PipedInputStream</tt> reads data
from a <tt class="literal">PipedOutputStream</tt>, and a
<tt class="literal">PipedOutputStream</tt> writes data to a
<tt class="literal">PipedInputStream</tt>. This class design allows the
developer to establish data pipes between threads in the same
process. <a href="#ch02-42531">Example 2-4</a> and <a href="#ch02-22768">Example 2-5</a> show client and server classes that use piped
streams to transfer information, and <a href="#JDP-CH-2-EX-7">Example 2-6</a>
shows an application of these classes.
<a name="INDEX-211"></a><a name="INDEX-212"></a>
</p>

<a name="ch02-42531"></a>
<div class="example">
<h4 class="objtitle">Example 2-4. A Piped Client</h4>
<blockquote>
<pre class="programlisting">package dcj.examples;

import java.lang.*;
import java.net.*;
import java.io.*;
import java.util.*;

public class PipedClient extends Thread
{
  PipedInputStream pin;
  PipedOutputStream pout;

  public PipedClient(PipedInputStream in, PipedOutputStream out)
  {
    pin = in;
    pout = out;
  }

  public void run()
  {
    // Wrap a data stream around the input and output streams
    DataInputStream din = new DataInputStream(pin);
    DataOutputStream dout = new DataOutputStream(pout);

    // Say hello to the server...
    try
      {
        System.out.println("PipedClient: Writing greeting to server...");
        dout.writeChars("hello from PipedClient\n");
      }
    catch (IOException e)
      {
        System.out.println("PipedClient: Couldn't get response.");
        System.exit(1);
      }

    // See if it says hello back...
    try
      {
        System.out.println("PipedClient: Reading response from server...");
        String response = din.readLine();
        System.out.println("PipedClient: Server said: \"" 
                           + response + "\"");
      }
    catch (IOException e)
      {
        System.out.println("PipedClient: Failed to connect to peer.");
      }

    stop();
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-213"></a>
<a name="INDEX-214"></a>

<p>The example shows two threads, a client and a server, talking to each
other over piped streams. The <tt class="literal">PipedClient</tt> class
accepts a <tt class="literal">PipedInputStream</tt> and
<tt class="literal">PipedOutputStream</tt> as constructor arguments; the
<tt class="literal">PipedServer</tt> class does the same. Both are
extensions of the <tt class="literal">Thread</tt> class. The client
attempts to send a "hello" message to the server over its
output stream, then listens for a response on its input stream. The
server listens for the "hello" from the client on its
input stream, then sends a response back on its output stream. The
<tt class="literal">PipedStreamExample</tt> class sets up the stream
connections for the threads by creating two pairs of piped streams.
It then creates a <tt class="literal">PipedClient</tt> and a
<tt class="literal">PipedServer</tt>, sends each the input stream from
one pair and the output stream from the other, and tells each of them
to start their threads. The important feature of this example is that
the piped streams are connected to each other within the same
process, and are not connected to any remote hosts.
<a name="INDEX-215"></a><a name="INDEX-216"></a>
</p>

<a name="ch02-22768"></a>
<div class="example">
<h4 class="objtitle">Example 2-5. A Piped Server</h4>
<blockquote>
<pre class="programlisting">package dcj.examples;

import java.lang.*;
import java.net.*;
import java.io.*;

public class PipedServer extends Thread
{
  PipedInputStream pin;
  PipedOutputStream pout;

  public PipedServer(PipedInputStream in, PipedOutputStream out)
  {
    pin = in;
    pout = out;
  }

  public void run()
  {
    // Wrap a data stream around the input and output streams
    DataInputStream din = new DataInputStream(pin);
    DataOutputStream dout = new DataOutputStream(pout);

    // Wait for the client to say hello...
    try
      {
        System.out.println("PipedServer: Reading from client...");
        String clientHello = din.readLine();
        System.out.println("PipedServer: Client said: \""
                           + clientHello + "\"");
      }
    catch (IOException e)
      {
        System.out.println("PipedServer: Couldn't get hello from client.");
        stop();
      }

    // ...and say hello back.
    try
      {
        System.out.println("PipedServer: Writing response to client...");
        dout.writeChars("hello I am the server.\n");
      }
    catch (IOException e)
      {
        System.out.println("PipedServer: Failed to connect to client.");
      }
    stop();
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-217"></a>
<a name="INDEX-218"></a>

<a name="JDP-CH-2-EX-7"></a>
<div class="example">
<h4 class="objtitle">Example 2-6. Piped Stream Application</h4>
<blockquote>
<pre class="programlisting">package dcj.examples;

import java.net.*;
import java.io.*;
import java.lang.*;

import dcj.examples.PipedClient;
import dcj.examples.PipedServer;

class PipedStreamExample {
  public static void main(String argv[]) {
    // Make two pairs of connected piped streams
    PipedInputStream pinc = null;
    PipedInputStream pins = null;
    PipedOutputStream poutc = null;
    PipedOutputStream pouts = null;
    
    try {
      pinc = new PipedInputStream();
      pins = new PipedInputStream();
      poutc = new PipedOutputStream(pins);
      pouts = new PipedOutputStream(pinc);
    }
    catch (IOException e) {
      System.out.println(
        "PipedStreamExample: Failed to build piped streams.");
      System.exit(1);
    }

    // Make the client and server threads, connected by the streams
    PipedClient pc = new PipedClient(pinc, poutc);
    PipedServer ps = new PipedServer(pins, pouts);

    // Start the threads
    System.out.println("Starting server...");
    ps.start();
    System.out.println("Starting client...");
    pc.start();

    // Wait for threads to end
    try {
      ps.join();
      pc.join();
    }
    catch (InterruptedException e) {}

    System.exit(0);
  }
}</pre>
</blockquote>
</div>

<p>
<tt class="literal"></tt><a name="INDEX-219"></a><a name="INDEX-220"></a><a name="INDEX-221"></a> Note that a similar scenario could be
set up using the <tt class="literal">PipedReader</tt> and
<tt class="literal">PipedWriter</tt> classes, if you knew the two threads
were going to exchange character <a name="INDEX-222"></a><a name="INDEX-223"></a><a name="INDEX-224"></a><a name="INDEX-225"></a><a name="INDEX-226"></a> arrays.<a name="INDEX-227"></a>
</p>









<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_03.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch01_03.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch02_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch02_02.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">1.3. What Does Java Provide?</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">2.2. URLs, URLConnections, and ContentHandlers</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
