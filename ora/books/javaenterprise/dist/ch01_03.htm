<html>
<head>
<title>What Does Java Provide? (Java Distributed Computing)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Jim Farley">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-206-9E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="What Does Java Provide?">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm" alt="Java Distributed Computing"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch01_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch01_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch01_01.htm">Chapter 1: Introduction</a></td><td align="right" valign="top" width="172"><a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch02_01.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">1.3. What Does Java Provide?</h2>

<p>
<a name="INDEX-36"></a><a name="INDEX-37"></a>The original design motivations behind
Java and its predecessor, Oak, were concerned mainly with
reliability, simplicity, and architecture neutrality. Subsequently,
as the potential for Java as an "Internet programming
language" was seen by its developers at Sun Microsystems,
support for networking, security, and multithreaded operations was
incorporated or improved. All of these features of the Java language
and environment also make for a very powerful distributed application
development environment. This is, of course, no accident. The
requirements for developing an Internet-based application overlap to
a great extent with those of distributed application development.
</p>

<p>In this section, we review some of the features of Java that are of
particular interest in distributed applications, and how they help to
address some of the issues described in the previous section.
</p>

<a name="JDP-CH-1-SECT-3.1"></a>
<h3 class="sect2">1.3.1. Object-Oriented Environment</h3>

<p>
<a name="INDEX-38"></a>
Java is a "pure" object-oriented language, in the sense
that the smallest programmatic building block is a class. A data
structure or function cannot exist or be accessed at runtime except
as an element of a class definition. This results in a well-defined,
structured programming environment in which all domain concepts and
operations are mapped into class representations and transactions
between them. This is advantageous for systems development in
general, but also has benefits specifically for you as the
distributed system developer. An object, as an instance of a class,
can be thought of as a computing agent. Its level of sophistication
as an autonomous agent is determined by the complexity of its methods
and data representations, as well as its role within the object model
of the system, and the runtime object community defining the
distributed system. Distributing a system implemented in Java,
therefore, can be thought of as simply distributing its objects in a
reasonable way, and establishing networked communication links
between them using Java's built-in network support. If you have
the luxury of designing a distributed system from the ground up, then
your object model and class hierarchy can be specified with
distribution issues incorporated.
</p>


<a name="JDP-CH-1-SECT-3.2"></a>
<h3 class="sect2">1.3.2. Abstract Interfaces</h3>

<p>Java's support for <a name="INDEX-39"></a><a name="INDEX-40"></a><a name="INDEX-41"></a><a name="INDEX-42"></a> abstract object interfaces is
another valuable tool for developing distributed systems. An
interface describes the operations, messages, and queries a class of
objects is capable of servicing, without providing any information
about how these abilities are implemented. If a class is declared as
implementing a specified interface, then the class has to implement
the methods specified in the interface. The advantage of
implementation-neutral interfaces is that other agents in the system
can be implemented to talk to the specified interface without knowing
how the interface is actually implemented in a class. By insulating
the class implementation from those using the interface, we can
change the implementation as needed. If a class needs to be moved to
a remote host, then the local implementation of the interface can act
as a surrogate or stub, forwarding calls to the interface over the
network to the remote class.
</p>

<p>Abstract interfaces are a powerful part of the Java language and are
used to implement critical elements of the Java API. The platform
independence of the Abstract Windowing Toolkit (AWT) is accomplished
using abstract component interfaces that are implemented on each
platform using the native windowing system (the X Window System,
Macintosh, Windows, etc.). Certain key packages in the core Java API,
such as the <tt class="literal">java.security</tt> package, also make use
of interfaces to allow for specialized implementations by third-party
vendors. The Java Remote Method Invocation (RMI) package uses
abstract interfaces to define local stubs for remote objects. The
concept of abstract interfaces is also common in other distributed
object systems such as CORBA, in which interfaces defined in
Interface Definition Language (IDL) define the object model of a
CORBA system.<a href="#FOOTNOTE-2">[2]</a> The
Inter-Language Unification system (ILU), developed at Xerox PARC,
also depends upon an implementation-neutral interface language called
Interface Specification Language (ISL).<a href="#FOOTNOTE-3">[3]</a><a name="INDEX-43"></a><a name="INDEX-44"></a><a name="INDEX-45"></a><a name="INDEX-46"></a>
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-2"></a>
<p>[2]More information about CORBA and IDL
can be obtained from the Object Management Group at <a href="../../../../../../../www.omg.org/">http://www.omg.org/</a>.</p> </blockquote>
<blockquote class="footnote"> <a name="FOOTNOTE-3"></a>
<p>[3]See the ILU
home page at <a href="../../../../../../../ext.rlab.cs.nyu.edu/~jsr/oreilly/WebStripper/protected.html">ftp://ftp.parc.xerox.com/pub/ilu/ilu.html</a>.</p>
</blockquote>


<a name="JDP-CH-1-SECT-3.3"></a>
<h3 class="sect2">1.3.3. Platform Independence</h3>

<p>
<a name="INDEX-47"></a><a name="INDEX-48"></a>Code written in
Java can be compiled into platform-independent bytecodes using
Sun's Java compiler, or any of the many third-party Java
compilers now on the market. These bytecodes run on the
<a name="INDEX-49"></a><a name="INDEX-50"></a>Java Virtual Machine, a virtual hardware
architecture which is implemented in software running on a
"real" machine and its operating system. Java bytecodes
can be run on any platform with a Java Virtual Machine. At the time
of this writing, a Java VM is available for most major Unix variants,
OS/2, Windows95 and NT, MacOS, and a variety of other operating
systems.
</p>

<p>This is a major boon for you, since it allows virtually any available
PC or workstation to be home to an agent in a distributed system.
Once the elements of the system have been specified using Java
classes and compiled into Java bytecodes, they can migrate without
recompilation to any of the hosts available. This makes for easy
data- and load-balancing across the network. There is even support in
the Java API for downloading a class definition (its bytecodes)
through a network connection, creating an instance of the class, and
incorporating the new object into the running process. This is
possible because Java bytecodes are runnable on the Java Virtual
Machine, which is guaranteed to be underneath any Java application or
applet.
</p>


<a name="JDP-CH-1-SECT-3.4"></a>
<h3 class="sect2">1.3.4. Fault Tolerance Through Exception Handling</h3>

<p>
<a name="INDEX-51"></a><a name="INDEX-52"></a><a name="INDEX-53"></a>Java supports throwing and catching
errors and exceptions, both system-defined and application-defined.
Any method can throw an exception; it is the calling method's
responsibility to handle the exception, or propagate the exception up
the calling chain. Handling an exception is a matter of wrapping any
potential exception-causing code with a
<tt class="literal">try/catch/finally</tt><a name="INDEX-54"></a><a name="INDEX-55"></a><a name="INDEX-56"></a> statement, where each
<tt class="literal">catch</tt> clause handles a particular type of
exception. If a method chooses to ignore particular exceptions, then
it must declare that it throws the exceptions it is ignoring. When a
called method generates an exception, it will be propagated up the
calling chain to be handled by a <tt class="literal">catch</tt> clause in
a calling method, or, if not, to result in a stack dump and exit from
the Java process. After all is said and done, whether the
<tt class="literal">try</tt> block runs to completion without a problem,
or an exception gets thrown, the code in the
<tt class="literal">finally</tt> block is always called. So you can use
the <tt class="literal">finally</tt> block to clean up any resources you
created in the <tt class="literal">try</tt> block, for example, and be
sure that the cleanup will take place whether an exception is thrown
or not.
</p>

<p>An agent can be written to handle the exceptions that can be thrown
by each method it calls. Additionally, since any subclass of
<tt class="literal">java.io.Throwable</tt><a name="INDEX-57"></a> can be declared in a method's
<tt class="literal">throws</tt> clause, an application can define its own
types of exceptions to indicate specific abnormalities. Since an
exception is represented as an object in the Java environment, these
application-specific exceptions can carry with them data and methods
that can be used to characterize, diagnose, and potentially recover
from <a name="INDEX-58"></a><a name="INDEX-59"></a><a name="INDEX-60"></a> them.
</p>


<a name="JDP-CH-1-SECT-3.5"></a>
<h3 class="sect2">1.3.5. Network Support</h3>

<p>The Java API includes multilevel support for <a name="INDEX-61"></a><a name="INDEX-62"></a> network communications. Low-level sockets
can be established between agents, and data communication protocols
can be layered on top of the socket connection. The
<tt class="literal">java.io</tt><a name="INDEX-63"></a> package contains several stream classes
intended for filtering and preprocessing input and output data
streams. APIs built on top of the basic networking support in Java
provide higher-level networking capabilities, such as distributed
objects, remote connections to database servers, directory services,
etc.
</p>

<p>While the majority of this book will be concerned with the use of
distributed object schemes like RMI, along with other higher-level
networking APIs, it's also important to get a feeling for the
basic networking capabilities included in the core Java API. <a href="#JDP-CH-1-FIG-2">Figure 1-1</a> shows a simple network application involving a
client and a server; the client sends commands to the server, the
server executes the commands and sends responses back to the client.
To demonstrate the network support in Java and how it can be
exploited for distributed applications, Examples <a href="#JDP-CH-1-EX-1">Example 1-1</a> through <a href="#JDP-CH-1-EX-4">Example 1-4</a> show an
implementation of this simple client-server system using sockets and
input/output streams. The implementation includes the following
elements:
</p>

<ul>
<li>
<p>A set of command objects that represent our command protocol between
the client and the server
</p>
</li>
<li>
<p>A subclass of <tt class="literal">java.io.DataInputStream</tt><a name="INDEX-64"></a> that understands our protocol
</p>
</li>
<li>
<p>A client that can send commands in the right format to the server,
and a server that can accept client connections, read commands using
our specialized stream, and send responses back
</p>
</li>
</ul>
<a name="JDP-CH-1-FIG-2"></a>
<div class="figure">
<img alt="figure" src="figs/jdc_0101.gif" webstripperlinkwas="figs/jdc_0101.gif"></div>
<h4 class="objtitle">Figure 1-1. A simple client/server system</h4>


<p>The client connects to the server over a socket, then sends commands
to the server over the socket. The server uses the specialized
<tt class="literal">DataInputStream</tt> to read the commands from the
socket. The input stream automatically creates the right command
object based on the type of message from the client (e.g., a
"GET" message will be converted into a
<tt class="literal">GetCmd</tt> object). The server then executes the
command and sends the result to the client over the socket.
</p>

<p>
<a href="#JDP-CH-1-EX-1">Example 1-1</a> shows a set of classes that represent
the commands a client can send to our server. The
<tt class="literal">SimpleCmd</tt><a name="INDEX-65"></a> class simply holds a single
<tt class="literal">String</tt> argument and has an abstract
<tt class="literal">Do()</tt> method that subclasses will implement to do
the right thing for the particular command they represent. Our
protocol consists of three basic commands: "GET,"
"HEAD," and "POST,"<a href="#FOOTNOTE-4">[4]</a> along
with a command to close the connection, "DONE." The
<tt class="literal">GetCmd</tt><a name="INDEX-66"></a><a name="INDEX-67"></a><a name="INDEX-68"></a><a name="INDEX-69"></a>, <tt class="literal">HeadCmd</tt>,
<tt class="literal">PostCmd</tt>, and <tt class="literal">DoneCmd</tt>
classes derived from <tt class="literal">SimpleCmd</tt> represent these
commands.
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-4"></a>
<p>[4]Sound
familiar? These commands are the heart of the HTTP protocol, which in
turn is the heart of the World Wide Web.</p> </blockquote>

<a name="JDP-CH-1-EX-1"></a>
<div class="example">
<h4 class="objtitle">Example 1-1. Commands for the Client-Server System</h4>
<blockquote>
<pre class="programlisting">package dcj.examples;

import java.lang.*;

abstract class SimpleCmd
{
  protected String arg;

  public SimpleCmd(String inArg) {
    arg = inArg;
  }

  public abstract String Do();
}

class GetCmd extends SimpleCmd
{
  public GetCmd(String s) { super(s); }

  public String Do() {
    String result = arg + " Gotten\n";
    return result;
  }
}

public class HeadCmd extends SimpleCmd
{
  public HeadCmd(String s) { super(s); }
  public String Do() {
    String result = "Head \"" + arg + "\" processed.\n";
    return result;
  }
}

class PostCmd extends SimpleCmd
{
  public PostCmd(String s) { super(s); }

  public String Do() {
    String result = arg + " Posted\n";
    return result;
  }
}

class DoneCmd extends SimpleCmd
{
  public DoneCmd() { super(""); };
  public String Do() {
    String result = "All done.\n";
    return result;
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-70"></a>
<a name="INDEX-71"></a>
<a name="INDEX-72"></a>
<a name="INDEX-73"></a>
<a name="INDEX-74"></a>

<p>The classes in <a href="#JDP-CH-1-EX-1">Example 1-1</a> represent the
communication protocol for our client-server application, and the
<tt class="literal">SimpleCmdInputStream</tt><a name="INDEX-75"></a> class in <a href="#JDP-CH-1-EX-2">Example 1-2</a>
acts as the communication link that understands this protocol. The
<tt class="literal">SimpleCmdInputStream</tt> is a subclass of
<tt class="literal">java.io.DataInputStream</tt> that adds a
<tt class="literal">readCommand()</tt> method to its interface. This
method parses the data coming in over the stream, determines which
command is being sent, and constructs the corresponding command class
from <a href="#JDP-CH-1-EX-1">Example 1-1</a>.
</p>

<a name="JDP-CH-1-EX-2"></a>
<div class="example">
<h4 class="objtitle">Example 1-2. A Specialized DataInputStream</h4>
<blockquote>
<pre class="programlisting">package dcj.examples;

import java.lang.*;
import java.io.*;
import java.net.*;

public class SimpleCmdInputStream extends DataInputStream
{
  public SimpleCmdInputStream(InputStream in) {
    super(in);
  }

  public String readString() throws IOException {
    StringBuffer strBuf = new StringBuffer();
    boolean hitSpace = false;
    while (!hitSpace) {
      char c = readChar();
      hitSpace = Character.isSpace(c);
      if (!hitSpace)
        strBuf.append(c);
    }

    String str = new String(strBuf);
    return str;
  }

  public SimpleCmd readCommand() throws IOException {
    SimpleCmd cmd;
    String commStr = readString();
    if (commStr.compareTo("HEAD") == 0)
      cmd = new HeadCmd(readString());
    else if (commStr.compareTo("GET") == 0)
      cmd = new GetCmd(readString());
    else if (commStr.compareTo("POST") == 0)
      cmd = new PostCmd(readString());
    else if (commStr.compareTo("DONE") == 0)
      cmd = new DoneCmd();
    else
      throw new IOException("Unknown command.");

    return cmd;
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-76"></a>


<p>Finally, the <tt class="literal">SimpleClient</tt><a name="INDEX-77"></a><a name="INDEX-78"></a> in <a href="#JDP-CH-1-EX-3">Example 1-3</a> and <tt class="literal">SimpleServer</tt> in <a href="#JDP-CH-1-EX-4">Example 1-4</a> serve as the client and server agents in our
distributed system. Our <tt class="literal">SimpleClient</tt> is very
simple indeed. In its constructor, it opens a socket to a server on a
given host and port number. Its <tt class="literal">main()</tt> method
makes a <tt class="literal">SimpleClient</tt> object using command-line
arguments that specify the host and port to connect to, then calls
the <tt class="literal">sendCommands()</tt> method on the client. This
method just sends a few commands in the right format to the server
over the <tt class="literal">OutputStream</tt> from the socket
connection.
</p>

<p>Notice that the client's socket is closed in its
<tt class="literal">finalize()</tt><a name="INDEX-79"></a> method. This
method will only get called after all references to the client are
gone, and the system garbage-collector runs to mark the object as
finalizable. If it's important that the socket be closed
immediately after the client is done with it, you may want to close
the socket explicitly at the end of the
<tt class="literal">sendCommands()</tt> method.
</p>

<a name="JDP-CH-1-EX-3"></a>
<div class="example">
<h4 class="objtitle">Example 1-3. A Simple Client</h4>
<blockquote>
<pre class="programlisting">package dcj.examples;

import java.lang.*;
import java.net.*;
import java.io.*;

public class SimpleClient
{
  // Our socket connection to the server
  protected Socket serverConn;

  // The input command stream from the server
  protected SimpleCmdInputStream inStream;

  public SimpleClient(String host, int port)
      throws IllegalArgumentException {
    try {
      System.out.println("Trying to connect to " + host + " " + port);
      serverConn = new Socket(host, port);
    }
    catch (UnknownHostException e) {
      throw new IllegalArgumentException("Bad host name given.");
    }
    catch (IOException e) {
      System.out.println("SimpleClient: " + e);
      System.exit(1);
    }

    System.out.println("Made server connection.");
  }

  public static void main(String argv[]) {
    if (argv.length &lt; 2) {
      System.out.println("Usage: java SimpleClient [host] [port]");
      System.exit(1);
    }
    
    String host = argv[0];
    int port = 3000;
    try {
      port = Integer.parseInt(argv[1]);
    }
    catch (NumberFormatException e) {}
    
    SimpleClient client = new SimpleClient(host, port);
    client.sendCommands();
  }
  
  public void sendCommands() {
    try {
      OutputStreamWriter wout =
        new OutputStreamWriter(serverConn.getOutputStream());
      BufferedReader rin = new BufferedReader(
        new InputStreamReader(serverConn.getInputStream()));

      // Send a GET command...
      wout.write("GET goodies ");
      // ...and receive the results
      String result = rin.readLine();
      System.out.println("Server says: \"" + result + "\"");

      // Now try a POST command
      wout.write("POST goodies ");
      // ...and receive the results
      result = rin.readLine();
      System.out.println("Server says: \"" + result + "\"");

      // All done, tell the server so
      wout.writeChars("DONE ");
      result = rin.readLine();
      System.out.println("Server says: \"" + result + "\"");
    }
    catch (IOException e) {
      System.out.println("SimpleClient: " + e); 
      System.exit(1);
    }
  }

  public synchronized void finalize() {
    System.out.println("Closing down SimpleClient...");
    try { serverConn.close(); }
    catch (IOException e) {
      System.out.println("SimpleClient: " + e);
      System.exit(1);
    }
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-80"></a>
<a name="INDEX-81"></a>

<p>The <tt class="literal">SimpleServer</tt><a name="INDEX-82"></a><a name="INDEX-83"></a> class has a constructor that
binds itself to a given port, and a <tt class="literal">listen()</tt>
method that continually checks that port for client connections. Its
<tt class="literal">main()</tt> method creates a
<tt class="literal">SimpleServer</tt> for a port specified with
command-line arguments, then calls the server's
<tt class="literal">listen()</tt> method. The
<tt class="literal">listen()</tt><a name="INDEX-84"></a> method loops
continuously, waiting for a client to connect to its port. When a
client connects, the server creates a <tt class="literal">Socket</tt> to
the client, then calls its <tt class="literal">serviceClient()</tt>
method to parse the client's commands and act on them. The
<tt class="literal">serviceClient()</tt> takes the
<tt class="literal">InputStream</tt> from the client socket, and wraps
our <tt class="literal">SimpleCmdInputStream</tt> around it. Then the
method loops, calling the <tt class="literal">readCommand()</tt> method
on the stream to get the client's commands. If the client sends
a DONE command, then the loop stops and the method returns. Until
then, each command is read from the stream, and the
<tt class="literal">Do()</tt> method is called on each. The string returned
from the <tt class="literal">Do()</tt> call is returned to the client over
the <tt class="literal">OutputStream</tt> from the client socket.
</p>

<a name="JDP-CH-1-EX-4"></a>
<div class="example">
<h4 class="objtitle">Example 1-4. A Simple Server</h4>
<blockquote>
<pre class="programlisting">package dcj.examples;

import java.net.*;
import java.io.*;
import java.lang.*;

// A generic server that listens on a port and connects to any clients it
// finds. Made to extend Thread, so that an application can have multiple
// server threads servicing several ports, if necessary.

public class SimpleServer
{
  protected int portNo = 3000; // Port to listen to for clients
  protected ServerSocket clientConnect;

  public SimpleServer(int port) throws IllegalArgumentException {
    if (port &lt;= 0)
      throw new IllegalArgumentException(
                  "Bad port number given to SimpleServer constructor.");

    // Try making a ServerSocket to the given port
    System.out.println("Connecting server socket to port...");
    try { clientConnect = new ServerSocket(port); }
    catch (IOException e) {
      System.out.println("Failed to connect to port " + port);
      System.exit(1);
    }

    // Made the connection, so set the local port number
    this.portNo = port;
  }

  public static void main(String argv[]) {
    int port = 3000;
    if (argv.length &gt; 0) {
      int tmp = port;
      try {
        tmp = Integer.parseInt(argv[0]);
      }
      catch (NumberFormatException e) {}

      port = tmp;
    }
    
    SimpleServer server = new SimpleServer(port);
    System.out.println("SimpleServer running on port " + port + "...");
    server.listen();
  }

  public void listen() {
    // Listen to port for client connection requests.
    try {
      System.out.println("Waiting for clients...");
      while (true) {
        Socket clientReq = clientConnect.accept();
        System.out.println("Got a client...");
        serviceClient(clientReq);
      }
    }
    catch (IOException e) {
      System.out.println("IO exception while listening for clients.");
      System.exit(1);
    }
  }

  public void serviceClient(Socket clientConn) {
    SimpleCmdInputStream inStream = null;
    DataOutputStream outStream = null;
    try {
      inStream = new SimpleCmdInputStream(clientConn.getInputStream());
      outStream = new DataOutputStream(clientConn.getOutputStream());
    }
    catch (IOException e) {
      System.out.println("SimpleServer: Error getting I/O streams.");
    }
    
    SimpleCmd cmd = null;
    System.out.println("Attempting to read commands...");
    while (cmd == null ||
           !(cmd instanceOf DomeCmd)) {
      try { cmd = inStream.readCommand(); }
      catch (IOException e) {
        System.out.println("SimpleServer: " + e);
        System.exit(1);
      }

      if (cmd != null) {
        String result = cmd.Do();
        try { outStream.writeBytes(result); }
        catch (IOException e) {
          System.out.println("SimpleServer: " + e);
          System.exit(1);
        }
      }
    }
  }
  
  public synchronized void finalize() {
    System.out.println("Shutting down SimpleServer running on port "
                       + portNo);
  }
}</pre>
</blockquote>
</div>
<a name="INDEX-85"></a>
<a name="INDEX-86"></a>

<p>We could easily adapt this simple communication scheme to other
applications with different protocols. We would just need to define
new subclasses of <tt class="literal">SimpleCmd</tt>, and update our
<tt class="literal">SimpleCmdInputStream</tt> to parse them correctly. If
we wanted to get exotic, we could expand our communication scheme to
implement a "meta-protocol" between agents in the system.
The first piece of information passed between two agents when they
establish a socket connection would be the protocol they want to use
to communicate with each other. Using the class download capabilities
mentioned in the previous section, we could actually load a subclass
of <tt class="literal">java.io.InputStream</tt> over the newly created
socket, create an instance of the class, and attach it to the socket
itself. We won't indulge ourselves in this exotic exercise in
this chapter, however.
</p>

<p>What all of this demonstrates is that Java's network support
provides a quick way to develop the communication elements of a basic
distributed system. Java's other core features, such as
platform-independent bytecodes, facilitate the development of more
complex network transactions, such as agents dynamically building a
protocol for talking to each other by exchanging class definitions.
The core Java API also includes built-in support for sharing Java
objects between remote agents, with its RMI package. Objects that
implement the
<tt class="literal">java.io.Serializable</tt><a name="INDEX-87"></a> interface can be converted to byte
streams and transmitted over a network connection to a remote Java
process, where they can be "reconstituted" into copies of
the original objects. Other packages are available for using CORBA to
distribute objects within a Java distributed application. We'll
discuss both methods for distributed Java objects in later
chapters.<a name="INDEX-88"></a><a name="INDEX-89"></a>
</p>


<a name="JDP-CH-1-SECT-3.6"></a>
<h3 class="sect2">1.3.6. Security</h3>

<p>
<a name="INDEX-90"></a><a name="INDEX-91"></a>Java
provides two dimensions of security for distributed systems: a secure
local runtime environment, and the ability to engage in secure remote
transactions.
</p>

<a name="JDP-CH-1-SECT-3.6.1"></a>
<h3 class="sect3">1.3.6.1. Runtime environment</h3>

<p>
<a name="INDEX-92"></a>At the same time that Java facilitates
the distribution of system elements across the network, it makes it
easy for the recipient of these system elements to verify that they
can't compromise the security of the local environment. If Java
code is run in the context of an applet, then the Java Virtual
Machine places rather severe restrictions on its operation and
capabilities. It's allowed virtually no access to the local
file system, very restricted network access (e.g., it can only open a
network connection back to the server it was loaded from), no access
to local code or libraries outside of the Java environment, and
restricted thread manipulation capabilities, among other things. In
addition, any class definitions loaded over the network, whether from
a Java applet or a Java application, are subjected to a stringent
bytecode verification process, in which the syntax and operations of
the bytecodes are checked for incorrect or potentially malicious
behavior.
</p>



<a name="JDP-CH-1-SECT-3.6.2"></a>
<h3 class="sect3">1.3.6.2. Secure remote transactions</h3>

<p>
<a name="INDEX-93"></a><a name="INDEX-94"></a><a name="INDEX-95"></a><a name="INDEX-96"></a><a name="INDEX-97"></a><a name="INDEX-98"></a>In <a href="#JDP-CH-1-SECT-3.5">Section 1.3.5, "Network Support"</a>, we demonstrated how Java
simplifies the creation, manipulation, and extension of network
communications sockets. This capability of the environment makes it
easy to add user authentication and data encryption to establish
secure network links, assuming that the basic encryption and
authentication algorithms already exist. Suppose, for example, that
we wanted to use public key encryption to establish secure,
authenticated connections to named agents on remote machines. We can
extend the <tt class="literal">BufferedInputStream</tt> and
<tt class="literal">BufferedOutputStream</tt><a name="INDEX-99"></a><a name="INDEX-100"></a> classes in <tt class="literal">java.io
</tt>to authenticate and decrypt incoming data, and to sign and
encrypt outgoing data. <a href="#JDP-CH-1-EX-5">Example 1-5</a> displays the
encrypted input stream.
<a name="INDEX-101"></a>
</p>

<a name="JDP-CH-1-EX-5"></a>
<div class="example">
<h4 class="objtitle">Example 1-5. Encrypted Input Stream</h4>
<blockquote>
<pre class="programlisting">import java.io.*;

public abstract class EncryptedInputStream extends BufferedInputStream
{
    public EncryptedInputStream(InputStream in);
        // Assumes the key ID and signature will be embedded
        // in the incoming data
    public EncryptedInputStream(InputStream in, String id);
        // Will only allow communication once identified
        // entity is authenticated with a public key

    // Protected methods
    public int decrypt(int) throws SecurityException;
    public int decrypt(byte[] b) throws SecurityException;
    public int decrypt(byte[] b, int off, int len) 
        throws SecurityException;
    
    // Public methods
    public int read() throws IOException, SecurityException
    {
        return decrypt(super.read());
    }

    public int read(byte[] b) throws IOException, SecurityException
    {
        super.read(b);
        return decrypt(b);
    }

    public int read(byte[] b, int off, int len)
        throws IOException, SecurityException
    {
        super.read(b, off, len);
        return decrypt(b, off, len);
    }
}</pre>
</blockquote>
</div>

<a name="INDEX-102"></a>
<a name="INDEX-103"></a>

<p>Of course, the example is greatly simplified by the fact that we
haven't actually implemented the
<tt class="literal">EncryptedInputStream.decrypt()</tt> methods, which
are at the heart of the matter, since they actually detect key IDs
and signatures, look up public keys on some key list in memory or on
disk, and decrypt the incoming data stream once the agent at the
other end has been authenticated. We've also avoided the issues
of data expansion or compression caused by encryption. When an
<tt class="literal">EncryptedInputStream</tt> is asked to read
<em class="emphasis">n</em> bytes of data, the intention is typically to
read <em class="emphasis">n</em> decrypted bytes. Any change in data size
would have to be made opaque by the <tt class="literal">decrypt()</tt>
methods.
</p>

<p>Once we establish an encrypted communications stream with the remote
agent, we can layer any kind of data protocol we like on top of it.
For example, our simple GET/HEAD/POST messaging scheme from an
earlier example could be carried out securely by simply putting an
encrypted input/output stream pair underneath:
</p>

<blockquote>
<pre class="programlisting">public SecureClientServer
{
    public SecureClientServer(String host, int port) 
        throws SecurityException
    {
        Socket comm = new Socket(host, port);
        InputStream rawIn = comm.getInputStream();
        EncryptedInputStream secureIn = 
            new EncryptedInputStream(rawIn);
        SimpleMessageInputStream msgIn =
            new SimpleMessageInputStream(secureIn);

        // Start reading and processing commands from the 
        // (now encrypted) input stream
        while (true)
        {
            try {
                SimpleCmd cmd = msgIn.readCommand();
                cmd.Do();
            }
            catch (IOException e) {}
    // Remainder of class implementation omitted
    ...
}</pre>
</blockquote>

<p>Of course, this assumes that the agent at the other end of the socket
has been suitably augmented to encrypt and decrypt streams.<a name="INDEX-104"></a><a name="INDEX-105"></a><a name="INDEX-106"></a><a name="INDEX-107"></a><a name="INDEX-108"></a>
</p>

<p>These examples have simply alluded to how the basic network
capabilities of Java could be extended to support secure network
communications. The
<tt class="literal">java.se-curity</tt><a name="INDEX-109"></a> package provides a
framework for implementing the authentication and encryption
algorithms needed to complete our secure input stream example. The
authentication process could be implemented using the
<tt class="literal">KeyPair</tt> and <tt class="literal">Signature</tt>
classes, for example. We'll discuss the
<tt class="literal">java.security</tt> API in more detail in a later
chapter.<a name="INDEX-110"></a><a name="INDEX-111"></a>
</p>



<a name="JDP-CH-1-SECT-3.7"></a>
<h3 class="sect2">1.3.7. Multithreading Support</h3>

<p>
<a name="INDEX-112"></a><a name="INDEX-113"></a>The ability to generate multithreaded
agents is a fundamental feature of Java. Any class that you create
can extend the
<tt class="literal">java.lang.Thread</tt><a name="INDEX-114"></a> class by providing its own
implementation of a <tt class="literal">run()</tt><a name="INDEX-115"></a> method. When the thread is
started, this <tt class="literal">run()</tt> method will be called and
your class can do its work within a separate thread of control. This
is one way to delegate tasks to threads in a given agent; another is
to have your workhorse classes derive from
<tt class="literal">java.lang.Runnable</tt><a name="INDEX-116"></a>, and allocate them as needed to
threads or thread groups. Any class implementing the
<tt class="literal">Runnable</tt> interface (which essentially means
providing a <tt class="literal">run()</tt> method that represents the
body of work to be done in the thread) can be wrapped with a thread
by simply creating a new <tt class="literal">Thread</tt> with the
<tt class="literal">Runnable</tt> object as the
argument.<tt class="literal"></tt><a name="INDEX-117"></a>
</p>

<p>
<a name="INDEX-118"></a><a name="INDEX-119"></a>Java also lets you tweak the performance
of a given agent through control and manipulation of its threads.
Threads are assigned priorities that are publicly pollable and
settable, giving you (or even some intelligent agent) the ability to
suggest how processing time is allocated to threads by the Virtual
Machine. Threads can also be made to yield to other threads, to sleep
for some period of time, to suspend indefinitely, or to go away
altogether. These kinds of operations become important, for example,
in asynchronous systems, in which a thread is tasked with client
polling and spawns new threads to service client<a name="INDEX-120"></a><a name="INDEX-121"></a> requests.<a name="INDEX-122"></a><a name="INDEX-123"></a>
</p>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch01_02.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch01_02.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch02_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch02_01.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">1.2. Requirements for Developing Distributed Applications</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">2. Networking in Java</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
