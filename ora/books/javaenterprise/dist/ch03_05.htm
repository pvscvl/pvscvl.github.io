<html>
<head>
<title>CORBA (Java Distributed Computing)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Jim Farley">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-206-9E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="CORBA">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm" alt="Java Distributed Computing"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch03_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch03_04.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch03_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch03_01.htm">Chapter 3: Distributing Objects</a></td><td align="right" valign="top" width="172"><a href="ch03_06.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch03_06.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">3.5. CORBA</h2>

<p>
<a name="INDEX-348"></a>CORBA,
<a name="INDEX-349"></a><a name="INDEX-350"></a> the Common
Object Request Broker Adapter, is a distributed object standard
developed by members of the <a name="INDEX-351"></a><a name="INDEX-352"></a>Object Management Group (OMG)
and their corporate members and sponsors. The first versions of the
CORBA standard were developed long before Java was publicized by Sun
(the OMG was formed in 1989, the CORBA 1.1 specification was released
in 1991, and the first pre-release versions of Java and the HotJava
browser were made public in the 1994-1995 timeframe). CORBA is meant
to be a generic framework for building systems involving distributed
objects. The framework is meant to be platform- and
language-independent, in the sense that client stub interfaces to the
objects, and the server implementations of these object interfaces,
can be specified in any programming language. The stubs and skeletons
for the objects must conform to the specifications of the CORBA
standard in order for any CORBA client to access your CORBA objects.
</p>

<p>The CORBA framework for distributing objects consists of the
following elements:
</p>

<ul>
<li>
<p>An <a name="INDEX-353"></a><a name="INDEX-354"></a>Object Request Broker
(ORB), which provides clients and servers of distributed objects with
the means to make and receive requests of each other. ORBs can also
provide object services, such as a Naming Service that lets clients
look-up objects by name, or Security Services that provide for secure
inter-object communications.
</p>
</li>
<li>
<p>Methods for specifying the interfaces that objects in the system
support. These interfaces specify the operations that can be
requested of the object, and any data variables available on the
object. CORBA offers two ways to specify object interfaces: an
Interface Definition Language (IDL) for static interface definitions,
and a <a name="INDEX-355"></a><a name="INDEX-356"></a>Dynamic Invocation
Interface (DII), which lets clients access interfaces as first-class
objects from an Interface Repository. The DII is analogous in some
ways to the Java Reflection API, which was introduced in JDK 1.1.
</p>
</li>
<li>
<p>A binary protocol for communication between ORBs, called the Internet
Inter-ORB Protocol (<a name="INDEX-357"></a><a name="INDEX-358"></a><a name="INDEX-359"></a>IIOP).
</p>
</li>
</ul>

<p>An earlier version of the CORBA standard did not include a low-level
binary specification for the inter-ORB network protocol. Instead, it
described the protocol in terms of more generic features that a
"compliant" system had to implement. This turned out to
be a stumbling block, since vendors were implementing CORBA object
servers that couldn't talk to each other, even though they all
followed the "standard." The binary protocol for the IIOP
was specified in the 2.0 release of the CORBA standard, which closed
this hole in the standard.
</p>

<a name="JDP-CH-3-SECT-5.1"></a>
<h3 class="sect2">3.5.1. The Object Request Broker (ORB)</h3>

<p>
<a name="INDEX-360"></a><a name="INDEX-361"></a>The Object Request Broker is at the
core of the CORBA model for distributed objects. It fills the Object
Manager role that we described earlier in the generic description of
distributed object systems. Both the client and the server of CORBA
objects use an ORB to talk to each other, so instead of a single
Object Manager (as described in our generic distributed object
system), CORBA has an object manager on both the client and server
side of a distributed object. This lets any agent in a CORBA system
act as both a client and a server of remote objects.
</p>

<p>On the client side of an object request, the ORB is responsible for
accepting client requests for a remote object, finding the
implementation of the object in the distributed system, accepting a
client-side reference to the remote object, routing client method
calls through the object reference to the remote object
implementation, and accepting any results for the client. On the
server side, the ORB lets object servers register new objects. When a
client requests an object, the server ORB receives the request from
the client ORB, and uses the object's skeleton interface to
invoke the object's activation method. The server ORB generates
an object reference for the new object, and sends this reference back
to the client. The client ORB converts the reference into a
language-specific form (a Java stub object, in our case), and the
client uses this reference to invoke methods on the remote object.
When the client invokes a method on a remote object, the server ORB
receives the request and calls the method on the object
implementation through its skeleton interface. Any return values are
marshaled by the server ORB and sent back to the client ORB, where
they are unmarshaled and delivered to the client program. So ORBs
really provide the backbone of the CORBA distributed object
system.<a name="INDEX-362"></a>
</p>


<a name="JDP-CH-3-SECT-5.2"></a>
<h3 class="sect2">3.5.2. The Interface Definition Language (IDL)</h3>

<p>Distributed objects in a CORBA application are described in the
<a name="INDEX-363"></a><a name="INDEX-364"></a><a name="INDEX-365"></a>Interface
Definition Language (IDL). The IDL provides a platform- and
implementation-independent way to define what kinds of operations an
object is capable of performing. <a href="#JDP-CH-3-EX-3">Example 3-3</a> shows
an IDL interface for a simplified bank account server. The IDL
specification indicates that the
<tt class="literal">BankServer</tt><a name="INDEX-366"></a><a name="INDEX-367"></a> object will have three
methods: one to verify a PIN number against an account, one to get
specifics about an account, and one to process a transaction against
an account.
</p>

<a name="JDP-CH-3-EX-3"></a>
<div class="example">
<h4 class="objtitle">Example 3-3. A Basic IDL Interface</h4>
<blockquote>
<pre class="programlisting">module Examples {
  interface BankServer {
    boolean verifyPIN(in long acctNo, in long pin);
    void getAcctSpecifics(in long acctNo, in string customerName,
                          out double balance, out boolean isChecking);
    boolean processTransaction(in Transaction t, in long acctNo);
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-368"></a>
<a name="INDEX-369"></a>

<p>The IDL language shares a lot of the syntax of C++ in terms of
defining interfaces and their methods. Since we're talking
about distributed objects, however, IDL forces you to specify
additional information about your object's interface, like
which method arguments are input-only, output-only, or two-way data
transfers. This is done using additional keywords on method
arguments, before their type specifications. These keywords are
<tt class="literal">in</tt><a name="INDEX-370"></a><a name="INDEX-371"></a><a name="INDEX-372"></a>, <tt class="literal">out</tt>, and
<tt class="literal">inout</tt>. In the <tt class="literal">BankServer</tt>
interface, the two arguments to the <tt class="literal">verifyPIN()</tt>
method are declared as <tt class="literal">in</tt> parameters, since they
are only used as input to the method and don't need to be read
back when the method returns. The
<tt class="literal">getAcctSpecifics()</tt> method has two
<tt class="literal">in</tt> parameters and two <tt class="literal">out</tt>
parameters. The two <tt class="literal">out</tt> arguments are read back
from the server when the method returns as output values. An
<tt class="literal">inout</tt> argument is both fed to the method as an
input parameter, and read back when the method returns as an output
value. When the IDL interface is compiled into a client stub and a
server skeleton, the input/output specifiers on method arguments are
used to generate the code to marshal and unmarshal the method
arguments correctly.<a name="INDEX-373"></a><a name="INDEX-374"></a><a name="INDEX-375"></a>
</p>


<a name="JDP-CH-3-SECT-5.3"></a>
<h3 class="sect2">3.5.3. Server Implementations</h3>

<p>
<em class="emphasis"></em><a name="INDEX-376"></a><a name="INDEX-377"></a><a name="INDEX-378"></a>Once an IDL interface for a distributed
object has been written, it can be translated into a client stub and
a server skeleton. IDL translators exist for C, C++, Smalltalk, Ada,
Java, and other common languages. The stub and skeleton don't
have to be compiled into the same programming language--this is
a principle feature of the CORBA architecture. The client could be a
Java applet, for example, and use a stub in the form of a Java class
definition. The server could implement the same object interface in
C++ using an object skeleton defined as a C++ class definition.
</p>

<p>The first step in creating a server-side implementation of an object
is to compile its IDL interface into both a native-language interface
( Java, in our case), and an implementation skeleton. The native
interface is simply a mapping of the IDL specification into our
implementation language. It acts as the basis for both the server
skeleton and the client stub, which will also be specified in the
implementation language. The server-side skeleton acts as the base
class for implementations of the object interface, and includes
CORBA-specific methods that the server ORB can use to map client
requests to method calls on the object implementation. You provide an
implementation of the object by deriving from the skeleton and
writing the implementations for the methods on the object interface.
Later we'll see an example of creating a server implementation
when we distribute our <tt class="literal">Solver</tt> class using CORBA.
</p>

<p>Once you've defined an implementation for the object, you need
to register the object implementation with the server ORB and,
optionally, with a
<a name="INDEX-379"></a><a name="INDEX-380"></a><a name="INDEX-381"></a><a name="INDEX-382"></a>CORBA
Naming Service, so that clients can find the object on the network
and get references to it. You create an ORB from within your server
process by creating an instance of an ORB interface. In Java, this is
done by creating an instance of the
<tt class="literal">org.omg.CORBA.ORB</tt> object. The interface to the
Naming Service might also be provided in the form of a Java class
that you create by requesting a reference to a Naming Service object
from the ORB object. Once you have access to the Naming Service
interface, you can create an instance of your object implementation
and register it. Clients can then connect to your object through
their own ORBs and Naming Services, assuming that they know your host
name and the name that you used to register the object.<a href="#FOOTNOTE-1">[1]</a><em class="emphasis"></em><a name="INDEX-383"></a><a name="INDEX-384"></a><a name="INDEX-385"></a>
</p>
<blockquote class="footnote">
<a name="FOOTNOTE-1"></a>
<p>[1]Clients can also access your CORBA objects without knowing this
information, if they have obtained an encoded reference to your
objects. This topic is beyond the scope of our discussion here,
however.</p> </blockquote>


<a name="JDP-CH-3-SECT-5.4"></a>
<h3 class="sect2">3.5.4. Client Stubs</h3>

<p>
<em class="emphasis"></em><a name="INDEX-386"></a><a name="INDEX-387"></a><a name="INDEX-388"></a>The client uses a stub to access the data
and methods on the remote instance of the object. A stub is generated
using an IDL compiler, the same way that the server implementation
skeleton was generated. Like the skeleton, the stub contains
CORBA-specific methods that the client ORB can use to marshal method
arguments to be sent to the server, and to unmarshal return values
and output parameters. When a client requests a remote object
reference, it's given the reference in the form of an instance
of the stub interface.
</p>

<p>A client can get a reference to a remote object by creating an ORB
that is connected to the remote server hosting the object, and then
asking the ORB to find the object on the remote server. The ORB
initialization process will typically include arguments that let you
specify, as a client, which remote host and port to talk to for
remote object transactions. Note that the CORBA standard
doesn't include host and port number parameters in the required
initialization interface, but several vendors extend the
initialization parameters to include these options. Once the ORB has
been created, you can use the ORB's Naming Service to ask for a
remote object by name. The name would have to match the name used by
the server when it registered the object implementation. The client
ORB makes a connection to the server ORB and asks for the named
object. If it's found, the client ORB creates a reference to
the object as an instance of the stub generated from the IDL
interface. The client can then call methods on the stub interface,
which are routed by the client ORB to the server ORB, where the
method calls are executed on the actual server object implementation.
</p>


<a name="JDP-CH-3-SECT-5.5"></a>
<h3 class="sect2">3.5.5. A CORBA Solver</h3>

<p>
<tt class="literal"></tt><a name="INDEX-389"></a><a name="INDEX-390"></a>Now let's see how we would
both serve and use our <tt class="literal">Solver</tt> class in a CORBA
environment. For our example we are going to use the JavaIDL package
provided by Sun as our CORBA implementation. It provides an
IDL-to-Java compiler, a basic ORB implementation, and a basic Naming
Service implementation. Since a standard IDL-to-Java mapping has been
submitted to the OMG by a group of the most prominent CORBA software
vendors, almost all of the details about using CORBA in a Java
environment will apply to any other CORBA implementation in Java.
</p>

<a name="JDP-CH-3-SECT-5.5.1"></a>
<h3 class="sect3">3.5.5.1. The IDL interface</h3>

<p>
<a name="INDEX-391"></a><a name="INDEX-392"></a><a name="INDEX-393"></a>First, we need an IDL version of the
class, which is shown in <a href="#JDP-CH-3-EX-4">Example 3-4</a>. This IDL
interface represents some, but not all, of the functionality that I
originally expressed in terms of the Java interface in <a href="ch03_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch03_04.htm">Example 3-1</a>. It also includes an IDL specification for the
<tt class="literal">ProblemSet</tt> interface in <a href="ch03_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch03_04.htm">Example 3-2</a>.
</p>

<a name="JDP-CH-3-EX-4"></a>
<div class="example">
<h4 class="objtitle">Example 3-4. IDL Solver Interface</h4>
<blockquote>
<pre class="programlisting">module DCJ {
  module examples {

    interface ProblemSet {
      double getValue();
      void setValue(in double v);
      double getSolution();
      void setSolution(in double s);
    };

    interface Solver {
      // Solve the current problem set
      boolean solveCurrent();

      // Solve the given problem set
      boolean solve(inout ProblemSet s, in long numIters);

      // Get/set current problem
      ProblemSet getProblem();
      void setProblem(inout ProblemSet p);

      // Get/set current iteration setting
      unsigned long getIterations();
      void setIterations(in unsigned long i);
    };
  };
};</pre>
</blockquote>
</div>

<p>You can see that there are some subtle differences between the IDL
and Java interfaces for our classes. All the method arguments in the
IDL interface are preceded by <tt class="literal">in</tt>,
<tt class="literal">out</tt>, or <tt class="literal">inout</tt>, which
indicates whether the argument is write-only, read- only, or
read/write, respectively (from the perspective of the client). Since
the purpose of IDL is strictly to define an interface to an object,
there's no need to specify constructors for the object. Notice
that we had to change the name of no-argument
<tt class="literal">solve()</tt> method to be
<tt class="literal">solveCurrent()</tt> in the IDL interface. IDL
doesn't support overloading the names of methods, so we had to
give one of our <tt class="literal">solve()</tt> methods a more
descriptive name. The rest of the methods declared in the IDL
interface directly correspond to methods on the original Java
interface.<a name="INDEX-394"></a><a name="INDEX-395"></a><a name="INDEX-396"></a>
</p>



<a name="JDP-CH-3-SECT-5.5.2"></a>
<h3 class="sect3">3.5.5.2. The client stubs</h3>

<p>
<em class="emphasis"></em><a name="INDEX-397"></a><a name="INDEX-398"></a><a name="INDEX-399"></a>Now that we have our IDL interface,
we can run it through our IDL-to-Java compiler (called, predicatably
enough, <tt class="literal">idltojava</tt>) to generate a base Java
interface, along with a Java stub for the client and a Java skeleton
for the class implementation. Using JavaIDL,<a href="#FOOTNOTE-2">[2]</a> the base
interface and client stub are created by simply executing this
command:
</p>
<blockquote class="footnote"> <a name="FOOTNOTE-2"></a>
<p>[2]The
CORBA examples shown in this chapter were compiled and tested using
the early-access release of JavaIDL.</p> </blockquote>

<blockquote>
<pre class="programlisting">myhost% idltojava -fclient Solver.idl</pre>
</blockquote>

<p>Other CORBA implementations will have their own toolset and
command-line arguments for compiling the IDL interfaces for your
application. The Java base interface for the
<tt class="literal">Solver</tt> generated by the IDL-to-Java compiler is
shown in <a href="#JDP-CH-3-EX-5">Example 3-5</a>. Since we also included an
interface for the <tt class="literal">ProblemSet</tt> object in our IDL
file, the compiler also generated a base Java interface for it, shown
in <a href="#JDP-CH-3-EX-6">Example 3-6</a>.
</p>

<a name="JDP-CH-3-EX-5"></a>
<div class="example">
<h4 class="objtitle">Example 3-5. CORBA-Generated Solver Base Interface</h4>
<blockquote>
<pre class="programlisting">/*
 * File: ./DCJ/examples/Solver.java
 * From: Solver.idl
 *   By: idltojava JavaIDL Wed Mar 5 17:02:26 1997
 */

package DCJ.examples;
public interface Solver
    extends org.omg.CORBA.Object {
    boolean solveCurrent();
    boolean solve(DCJ.examples.ProblemSetHolder s, int numIters);
    DCJ.examples.ProblemSet getProblem();
    void setProblem(DCJ.examples.ProblemSetHolder p);
    int getIterations();
    void setIterations(int i);
}</pre>
</blockquote>
</div>

<p>Here are some important things to note about the
<tt class="literal">Solver</tt> base class in <a href="#JDP-CH-3-EX-5">Example 3-5</a>:
</p>

<ul>
<li>
<p>Our module definitions from the IDL file have been converted into a
package specification in the base Java interface. In the IDL, we
declared that the <tt class="literal">ProblemSet</tt> and
<tt class="literal">Solver</tt> interfaces were contained within the
<tt class="literal">examples</tt> module, which was further contained
within the <tt class="literal">DCJ</tt> module. In the generated Java
code, the classes are kept in the <tt class="literal">DCJ.examples</tt>
package.
</p>
</li>
<li>
<p>Where we've declared
<tt class="literal">inout</tt><a name="INDEX-400"></a> method arguments that are objects, the
<tt class="command">idltojava</tt> compiler has put "holder"
types into the Java base class. For each interface defined in IDL,
the IDL-to-Java compiler not only generates a Java base class for the
interface, it also generates "holder" Java classes for
the object. The "holder" class name is just the interface
name with an appended "Holder" (e.g.,
<tt class="literal">SolverHolder</tt>,
<tt class="literal">ProblemSetHolder</tt>). The holder classes act as
streamable versions of the main class; the ORB uses these holder
classes to transmit instances of the interface as remote method
arguments. You can access the actual class by using the
<tt class="literal">value</tt> attribute on the
<tt class="literal">Holder</tt> objects. (For example,
<tt class="literal">SolverHolder.value</tt> is a reference to the actual
<tt class="literal">Solver</tt> object.)
</p>
</li>
</ul>
<a name="JDP-CH-3-EX-6"></a>
<div class="example">
<h4 class="objtitle">Example 3-6. CORBA-Generated ProblemSet Base Interface</h4>
<blockquote>
<pre class="programlisting">/*
 * File: ./DCJ/examples/ProblemSet.java
 * From: Solver.idl
 *   By: idltojava JavaIDL Wed Mar 5 17:02:26 1997
 */

package DCJ.examples;
public interface ProblemSet
    extends org.omg.CORBA.Object {
    double getValue();
    void setValue(double v);
    double getSolution();
    void setSolution(double s);
}</pre>
</blockquote>
</div>

<p>The compiler also generated the client stubs for the interfaces in
our IDL file. In each case, the generated client stub implements the
Java base interface for the object. The client stubs also extend the
<tt class="literal">org.omg.CORBA.portable.Object-Impl</tt> class, which
provides the interface used by the client ORB to marshal and
unmarshal remote method arguments, among other things. The start of
the generated client stub for the <tt class="literal">Solver</tt> looks
like this:
</p>

<blockquote>
<pre class="programlisting">public class _SolverStub
    extends org.omg.CORBA.portable.ObjectImpl
    implements dcj.examples.Solver {
        ...</pre>
</blockquote>

<p>We'll leave out the remainder of the client stub definitions,
since they primarily include low-level details about the interface
between the stub and the ORB that we won't be concerned with
here. When you're developing systems using CORBA, you should
never have to be concerned with the internal details of the client
stub or the server skeleton anyway. The IDL-to-Java compiler does the
right thing with your IDL definitions, and all the client needs to
know is the base Java interface for the remote
object.<em class="emphasis"></em><a name="INDEX-401"></a><a name="INDEX-402"></a><a name="INDEX-403"></a>
</p>



<a name="JDP-CH-3-SECT-5.5.3"></a>
<h3 class="sect3">3.5.5.3. The server skeleton and implementation</h3>

<p>
<em class="emphasis"></em><a name="INDEX-404"></a><a name="INDEX-405"></a><a name="INDEX-406"></a>The same IDL <tt class="literal">Solver</tt>
interface can be used to generate a skeleton for a server
implementation of a class. This is done by invoking the following:
</p>

<blockquote>
<pre class="programlisting">myhost% idltojava -fserver Solver.idl</pre>
</blockquote>

<p>This will regenerate the Java base interface, but will also generate
a skeleton for our object implementation. Like the client stub, our
server skeleton contains mostly code related to the ORB/skeleton
interface, details that you won't need to be concerned with
most of the time. The only aspect we'll mention is that the
server skeleton also implements the base Java interface, as well as
the <tt class="literal">org.omg.CORBA.portable.ObjectImpl</tt> class. It
also implements the interface
<tt class="literal">org.omg.CORBA.portable.Skeleton</tt>, which the
server ORB will be looking for when invoking methods on the object
implementation:
</p>

<blockquote>
<pre class="programlisting">public abstract class _SolverImplBase
    extends org.omg.CORBA.portable.ObjectImpl
    implements DCJ.examples.Solver, org.omg.CORBA.portable.Skeleton {</pre>
</blockquote>

<p>Note that the <tt class="literal">_SolverImplBase</tt> class is declared
<tt class="literal">abstract</tt> by the compiler, since it doesn't
implement any of the methods that we declared in our IDL interface.
Again, since the <tt class="literal">ProblemSet</tt> interface was defined
in the same IDL file, a Java skeleton for the
<tt class="literal">ProblemSet</tt> was also generated.
</p>

<p>The last step in setting up our remote object for business is to
extend the <tt class="literal">_Sol-verImplBase</tt> class and the
<tt class="literal">_ProblemSetImplBase</tt> class, and implement the
methods defined in their base interfaces. Our implementation of the
<tt class="literal">Solver</tt> interface is shown in <a href="#JDP-CH-3-EX-5">Example 3-5</a>. The <tt class="literal">CORBASolverImpl</tt>
provides implementations of all of the methods from the base
<tt class="literal">Solver</tt> interface in <a href="#JDP-CH-3-EX-5">Example 3-5</a>, including the ever-critical
<tt class="literal">solve()</tt> method. In this case, our
<tt class="literal">Solver</tt> simply performs a square-root operation
on the problem value. Our implementation of the
<tt class="literal">ProblemSet</tt> interface is shown in <a href="#JDP-CH-3-EX-8">Example 3-8</a>.
</p>

<a name="JDP-CH-3-EX-7"></a>
<div class="example">
<h4 class="objtitle">Example 3-7. Java Implementation of the Solver Interface</h4>
<blockquote>
<pre class="programlisting">package DCJ.examples;

import java.lang.*;
import java.io.*;
import org.omg.CORBA.*;
import org.omg.CosNaming.*;

public class CORBASolverImpl extends _SolverImplBase {

  protected int numIterations = 1; // not used for this Solver...
  protected ProblemSetHolder currProblem = null;

  // Constructors
  public CORBASolverImpl() { super(); }
  public CORBASolverImpl(int numIter) {
    super();
    numIterations = numIter;
  }


  public ProblemSet getProblem() {
    return currProblem.value;
  }

  public void setProblem(ProblemSetHolder ph) {
    currProblem = ph;
  }

  public int getIterations() {
    return numIterations;
  }

  public void setIterations(int i) {
    numIterations = i; 
  }

  public boolean solveCurrent() {
    System.out.println("Solving current problem...");
    return solve(currProblem, numIterations);
  }

  public boolean solve(ProblemSetHolder sh, int numIters) {
    ProblemSet s = sh.value;
    boolean success = true;

    if (s == null) {
      System.out.println("No problem to solve.");
      return false;
    }

    System.out.println("Problem value = " + s.getValue());

    // Solve problem here...
    try {
      s.setSolution(Math.sqrt(s.getValue()));
    }
    catch (ArithmeticException e) {
      System.out.println("Badly-formed problem.");
      success = false;
    }

    System.out.println("Problem solution = " + s.getSolution());

    return success;
  }

  public static void main(String argv[]) {
    
    try {
      // create and initialize the ORB
      System.out.println("Initializing ORB...");
      ORB orb = ORB.init(argv, null);
 
      // Create a Solver and register it with the ORB
      System.out.println("Connecting solver to ORB...");
      CORBASolverImpl solver = new CORBASolverImpl();
      orb.connect(solver);
 
      // Get the naming service from the ORB
      System.out.println("Getting reference to Naming Service...");
      org.omg.CORBA.Object ncObj = 
        orb.resolve_initial_references("NameService");
      NamingContext ncRef = NamingContextHelper.narrow(ncObj);
 
      // Bind the Solver object to a name
      System.out.println("Registering Solver with Naming Service...");
      NameComponent comp = new NameComponent("Solver", "");
      NameComponent path[] = {comp};
      ncRef.rebind(path, solver);
 
      // Wait for client requests
      System.out.println("Waiting for clients...");
      java.lang.Object dummySync = new java.lang.Object();
      synchronized (dummySync) {
        dummySync.wait();
      }
    }
    catch (Exception e) {
      System.err.println(e);
      e.printStackTrace(System.out);
    }
  }
}</pre>
</blockquote>
</div>

<a name="JDP-CH-3-EX-8"></a>
<div class="example">
<h4 class="objtitle">Example 3-8. Java Implementation of the ProblemSet Interface</h4>
<blockquote>
<pre class="programlisting">package DCJ.examples;

public class ProblemSetImpl extends _ProblemSetImplBase {
  protected double value;
  protected double solution;

  public double getValue() { return value; }
  public void setValue(double v) { value = v; }
  public double getSolution() { return solution; }
  public void setSolution(double s) { solution = s; }
}</pre>
</blockquote>
</div>

<p>In addition to implementations for the <tt class="literal">Solver</tt>
interface methods, our <tt class="literal">CORBASolverImpl</tt> class
also includes a <tt class="literal">main()</tt> routine that creates a
<tt class="literal">Solver</tt> instance and registers it with a local
ORB. The registration routine first creates a local server ORB:
</p>

<blockquote>
<pre class="programlisting">ORB orb = ORB.init(argv, null);</pre>
</blockquote>

<p>The command-line arguments to the main routine are passed into the
ORB initialization routine so that it can parse any ORB-specific
parameters that the user may provide. Next, the routine creates an
instance of our <tt class="literal">Solver</tt> implementation, and
connects the object to the ORB:
</p>

<blockquote>
<pre class="programlisting">CORBASolverImpl solver = new CORBASolverImpl();
orb.connect(solver);</pre>
</blockquote>

<p>The next step is to get a reference to the ORB's naming service
and register the object under a name:
</p>

<blockquote>
<pre class="programlisting">org.omg.CORBA.Object ncObj = 
    orb.resolve_initial_references("NameService");
NamingContext ncRef = NamingContextHelper.narrow(ncObj);
    ...
NameComponent comp = new NameComponent("Solver", "");
NameComponent path[] = {comp};
ncRef.rebind(path, solver);</pre>
</blockquote>

<p>The <tt class="literal">NameComponent</tt> that we create is the thing
that tells the naming service what the name of the object is supposed
to be on this ORB. Finally, we need to keep the server process alive
while we wait for clients to invoke methods on our
<tt class="literal">Solver</tt>. If the <tt class="literal">main()</tt>
routine exits, then the surrounding process will exit and the ORB
object we created will be destroyed. So to keep the
<tt class="literal">main()</tt> routine from exiting, we enter an
infinite wait:
</p>

<blockquote>
<pre class="programlisting">java.lang.Object dummySync = new java.lang.Object();
synchronized (dummySync) {
    dummySync.wait();
}</pre>
</blockquote>

<a name="INDEX-407"></a>
<a name="INDEX-408"></a>
<a name="INDEX-409"></a>



<a name="JDP-CH-3-SECT-5.5.4"></a>
<h3 class="sect3">3.5.5.4. The Solver client</h3>

<p>OK, we've got our client stubs and server skeletons generated,
we've written Java implementations for the interfaces, and our
<tt class="literal">Solver</tt> implementation includes a
<tt class="literal">main()</tt> routine that registers a
<tt class="literal">Solver</tt> object with a server ORB. Now all we need
is a client to use the <tt class="literal">Solver</tt>. <a href="#JDP-CH-3-EX-9">Example 3-9</a> shows a simple client. All it does is create a
client ORB, get a reference to the ORB's naming service, and
ask it for a reference to the <tt class="literal">Solver</tt> by asking
for it by name. The initial reference that we get from the ORB is a
generic CORBA <tt class="literal">Object</tt>, which needs to be
"narrowed" to get a reference to the actual
<tt class="literal">Solver</tt> object reference using the
<tt class="literal">SolverHelper.narrow()</tt> method. We had to do the
same thing when getting a reference to the
<tt class="literal">NamingContext</tt> from the ORB. The
<tt class="literal">SolverHelper</tt> interface is generated
automatically by the <tt class="literal">idltojava</tt> compiler from the
<tt class="literal">Solver</tt>'s IDL interface. Once the client
has a <tt class="literal">Solver</tt> stub reference, it creates a
problem and asks the <tt class="literal">Solver</tt> to solve it. If
we're successful, the remote <tt class="literal">Solver</tt> object
will receive our request, solve the problem, and return the results
to the client.
</p>

<a name="JDP-CH-3-EX-9"></a>
<div class="example">
<h4 class="objtitle">Example 3-9. A Client for the Remote Solver</h4>
<blockquote>
<pre class="programlisting">package DCJ.examples;

import org.omg.CORBA.*;
import org.omg.CosNaming.*;

public class CORBASolverClient {
  public static void main(String argv[]) {
    try {
      // Create an ORB
      ORB orb = ORB.init(argv, null);

      // Get a reference to the Naming Service
      org.omg.CORBA.Object obj =
        orb.resolve_initial_references("NameService");
      NamingContext nc = NamingContextHelper.narrow(obj);

      // Get a reference to the Solver on the remote host
      NameComponent comp = new NameComponent("Solver", "");
      NameComponent path[] = {comp};
      org.omg.CORBA.Object sobj = nc.resolve(path);
      Solver solver = SolverHelper.narrow(sobj);

      // Make a problem and ask the solver to solve it
      ProblemSet s = new ProblemSetImpl();
      s.setValue(173.39);
      solver.solve(new ProblemSetHolder(s), 1);

      // Print out solution
      System.out.println("Problem = " + s.getValue());
      System.out.println("Solution = " + s.getSolution());
    }
    catch (Exception e) {
      System.out.println(e) ;
      e.printStackTrace(System.out);
    }
  }
}</pre>
</blockquote>
</div>



<a name="JDP-CH-3-SECT-5.5.5"></a>
<h3 class="sect3">3.5.5.5. Pulling it all together</h3>

<p>At this point, we've got all the Java code for our CORBA Solver
and the sample client. To see the system in practice, we have to
compile all of the Java code using the <tt class="literal">javac</tt>
compiler, and copy the bytecodes to both the server and client hosts.
Both hosts will also need to have a Java CORBA implementation
available in the form of its class files. On the object
implementation server, we need to have a CORBA
<a name="INDEX-410"></a><a name="INDEX-411"></a><a name="INDEX-412"></a><a name="INDEX-413"></a>Naming
Service running, which listens to a port for object requests. In the
JavaIDL system, we start the Naming Service with a command like the
following:
</p>

<blockquote>
<pre class="programlisting">objhost% nameserv -ORBInitialPort 1050</pre>
</blockquote>

<p>This starts the Naming Service process listening to port 1050 on the
host. Next, we need to run our server implementation process to
register one of our Solver objects with an ORB on the server. We can
run our server process with this command:
</p>

<blockquote>
<pre class="programlisting">objhost% java DCJ.examples.CORBASolverImpl -ORBInitialPort 1050</pre>
</blockquote>

<p>The <tt class="literal">ORBInitialPort</tt> command-line argument is
provided for initialization of the server ORB. When the arguments are
passed into the ORB's initialization routine, the ORB start-up
routine will parse out this argument, and will know that the ORB
needs to work with the Naming Service running on port 1050.
</p>

<p>Now all we need to do is run our client:</p>

<blockquote>
<pre class="programlisting">client% java DCJ.examples.CORBASolverClient -ORBInitialHost objhost \ 
    -ORBInitialPort 1050</pre>
</blockquote>

<p>The <tt class="literal">ORBInitialHost</tt> and
<tt class="literal">ORBInitialPort</tt> arguments are passed into the
client's ORB initialization call. The ORB will use these
arguments to connect itself to the specified remote host and port for
naming services. When the client asks the Naming Service for a
reference to the object named "Solver," it gets a
reference to the <tt class="literal">Solver</tt> object being served by
the server process. The remote <tt class="literal">Solver</tt> solves our
problem and returns the results, which our client prints out for us:
</p>

<blockquote>
<pre class="programlisting">Problem = 173.39
Solution = 13.1678</pre>
</blockquote>

<a name="INDEX-414"></a>
<a name="INDEX-415"></a>
<a name="INDEX-416"></a>





<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch03_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch03_04.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch03_06.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch03_06.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">3.4. Distributed Object Schemes for Java</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">3.6. Java RMI</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
