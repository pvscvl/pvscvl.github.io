<html>
<head>
<title>Message Passing with Java Events (Java Distributed Computing)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css" webstripperlinkwas="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="Jim Farley">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="1-56592-206-9E" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Message Passing with Java Events">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"><img src="gifs/smbanner.gif" webstripperlinkwas="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home"></a>
<map name="banner-map"><map name="banner-map"> <area shape="rect" coords="0,0,466,65" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm" alt="Java Distributed Computing"> <area shape="rect" coords="467,0,514,18" href="jobjects/fsearch.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/jobjects/fsearch.htm" alt="Search this book"> </map>
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch06_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch06_05.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="ch06_01.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch06_01.htm">Chapter 6: Message-Passing Systems</a></td><td align="right" valign="top" width="172"><a href="ch06_07.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch06_07.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- SECTION BODY -->
<h2 class="sect1">6.6. Message Passing with Java Events</h2>

<p>
<a name="INDEX-934"></a><a name="INDEX-935"></a>During the course of this
chapter, we've built up our own message-handling framework from
scratch, relying on basic sockets, I/O streams, and object
serialization to implement a protocol for sending, receiving, and
handling messages. In this section, we'll look at merging a
message-passing framework with the Java event model that's used
in the AWT package for handling GUI events. The advantage of using
events is the possibility of integrating your distributed system with
other systems based on the Java event model, including AWT-based
applications or applets.
</p>

<a name="JDP-CH-6-SECT-6.1"></a>
<h3 class="sect2">6.6.1. Event Model Overview</h3>

<p>
<a name="INDEX-936"></a>The event model included in the Java
API (version 1.1 and later) is generic enough to build event-handling
protocols for general applications, not just GUI-related ones. The
Java event model is based on <tt class="literal">EventObject</tt>s that
are created by various event sources and handled by classes that
implement an <tt class="literal">EventListener</tt> interface.
</p>

<p>Different types of events are defined by creating subclasses of the
<tt class="literal">EventObject</tt> class. The
<tt class="literal">EventObject</tt><a name="INDEX-937"></a> class only contains a source
<tt class="literal">Object</tt>. Subclasses of
<tt class="literal">EventObject</tt> can add additional data to represent
event specifics. For example, the AWT package defines a
<tt class="literal">KeyEvent</tt> subclass that represents keyboard
events. The <tt class="literal">KeyEvent</tt> class contains data fields
that specify which key was pressed to generate the event.
</p>

<p>The Java event model is called a
<em class="emphasis">delegation</em><a name="INDEX-938"></a><a name="INDEX-939"></a> model; events are generated by a
source of some kind, and <tt class="literal">EventListener</tt>s register
themselves with the event source to handle specific types of events.
When an event arrives, the event source delegates the handling of the
event to the <tt class="literal">EventListener</tt>s registered with it.
The Java AWT package uses this event model by defining various GUI
components that are sources of user events. User events are modeled
as subclasses of <tt class="literal">EventObject</tt>. Various types of
<tt class="literal">EventListener</tt>s are registered with the GUI
components to receive specific user event types, like mouse events,
keyboard events, etc.
</p>


<a name="JDP-CH-6-SECT-6.2"></a>
<h3 class="sect2">6.6.2. Distributed Events</h3>

<p>
<a name="INDEX-940"></a><a name="INDEX-941"></a>
In our case, we want to send and receive events over a network
between distributed agents. For each node in our distributed system,
we'll need to receive messages in the form of events from one
or many remote agents, and we'll need to send messages to other
agents. One model to use in building this event-based message-passing
system is to follow the lead of our previous message-handler
examples, and have event "<a name="INDEX-942"></a> transceivers" at each node in the
system. For the local node, these event transceivers would act as
both sources of events and as event handlers or listeners, passing
local events to remote agents.
</p>

<p>Along these lines, we have the
<tt class="literal">EventTransceiver</tt><a name="INDEX-943"></a> class shown in <a href="#JDP-CH-6-EX-14">Example 6-13</a>. This class connects itself to a single remote
agent to exchange events with it. This limited form of an event
transceiver will be sufficient to implement an event-based version of
our chess-playing example. We'll leave it to the reader to
extend this class to handle multiple remote agents.
</p>

<a name="JDP-CH-6-EX-14"></a>
<div class="example">
<h4 class="objtitle">Example 6-13. An Event Transceiver</h4>
<blockquote>
<pre class="programlisting">package dcj.util.message;

import java.util.*;
import java.net.*;
import java.io.*;

public class EventTransceiver implements EventHandler extends Thread {
  // A hashtable of handlers for specific events
  private Hashtable handlers = new Hashtable();
  // A list of handlers that want all events
  private Vector globalHandlers = new Vector();

  // Our connection to a remote agent
  InputStream evIn = null;
  OutputStream evOut = null;

  public EventTransceiver(String host, int port) {
    try {
      InetAddress a = InetAddress.getByName(host);
      connect(a, port);
    }
    catch (Exception e) {}
  }

  public EventTransceiver(InetAddress a, int port) {
    connect(a, port);
  }

  void connect(InetAddress a, int port) {
    try {
      Socket s = new Socket(a, port);
      evIn = s.getInputStream();
      evOut = s.getOutputStream();
    }
    catch (Exception e) {
      evIn = null;
      evOut = null;
    }
  }
  
  public EventTransceiver(InputStream in, OutputStream out) {
    setStreams(in, out);
  }

  void setStreams(InputStream in, OutputStream out) {
    evIn = in;
    evOut = out;
  }

  public void sendEvent(EventObject ev) throws IOException {
    ObjectOutputStream oout = new ObjectOutputStream(evOut);
    oout.writeObject(ev);
  }

  EventObject receiveEvent() throws IOException {
    ObjectInputStream oin = new ObjectInputStream(evIn);
    EventObject ev = null;
    try {
      ev = (EventObject)oin.readObject();
    }
    catch (ClassCastException e) {
      System.out.println("Non-event object sent to EventTransceiver");
    }
    catch (ClassNotFoundException e2) {
      System.out.println(
        "Unresolvable object type sent to EventTransceiver");
    }

    return ev;
  }

  void distributeEvent(EventObject ev) {
    // Send event to all "global" handlers
    Enumeration e = globalHandlers.elements();
    while (e.hasMoreElements()){
      EventHandler h = (EventHandler)e.nextElement();
      h.handleEvent(ev);
    }

    // Send event to handlers targeting the event's class
    Class evClass = ev.getClass();
    Vector evHandlers = (Vector)handlers.get(evClass);
    e = evHandlers.elements();
    while (e.hasMoreElements()) {
      EventHandler h = (EventHandler)e.nextElement();
      h.handleEvent(ev);
    }
  }

  // No default behavior for handling events...
  public void handleEvent(EventObject e) {}

  // Register a handler that wants all events.
  public void addHandler(EventHandler eh) {
    if (!globalHandlers.contains(eh)) {
      globalHandlers.addElement(eh);
    }
  }

  // Register a handler for a specific type of event
  public void addHandler(EventHandler eh, EventObject e) {
    Class eClass = e.getClass();
    addHandler(eh, eClass);
  }

  public void addHandler(EventHandler eh, Class ec) {
    Vector evHandlers = (Vector)handlers.get(ec);
    if (evHandlers == null) {
      evHandlers = new Vector();
      handlers.put(ec, evHandlers);
    }
    if (!evHandlers.contains(eh)) {
      evHandlers.addElement(eh);
    }
  }

  // Remove a handler from all lists
  public void removeHandler(EventHandler eh) {
    globalHandlers.removeElement(eh);
    Enumeration ecList = handlers.keys();
    while (ecList.hasMoreElements()) {
      Vector evHandlers =
        (Vector)handlers.get(ecList.nextElement());
      if (evHandlers != null) {
        evHandlers.removeElement(eh);
      }
    }
  }

  // Remove a handler for a specific event type
  public void removeHandler(EventHandler eh, EventObject e) {
    removeHandler(eh, e.getClass());
  }

  public void removeHandler(EventHandler eh, Class ec) {
    Vector evHandlers = (Vector)handlers.get(ec);
    if (evHandlers != null) {
      evHandlers.removeElement(eh);
    }
  }

  // If run as an independent thread, just loop listening
  // for events from the remote agent, and distribute them
  // to registered handlers
  public void run() {
    try {
      while (true) {
        EventObject e = receiveEvent();
        if (e != null)
          distributeEvent(e);
      }
    }
    // Treat an IOException as termination of the event
    // input stream, and let this handler thread die
    catch (IOException e) {}
  }
}</pre>
</blockquote>
</div>

<p>The <tt class="literal">EventTransceiver</tt> class extends an
<tt class="literal">EventHandler</tt><a name="INDEX-944"></a> interface, which is an
extension of the <tt class="literal">java.util.EventListener</tt>
interface that adds a
<tt class="literal">handleEvent()</tt><a name="INDEX-945"></a>
method (see <a href="#JDP-CH-6-EX-15">Example 6-14</a>). The
<tt class="literal">EventTransceiver</tt> maintains its connection to a
remote agent as an I/O stream pair. It has two constructors that take
arguments specifying a remote agent to which to connect: one uses a
hostname and port number, the other uses an
<tt class="literal">InetAddress</tt> and port number. These two
constructors use the host and port information to open a socket to
the remote agent and get the <tt class="literal">InputStream</tt> and
<tt class="literal">OutputStream</tt> from the socket. A third
constructor accepts an <tt class="literal">InputStream</tt> and
<tt class="literal">OutputStream</tt> that are preconnected to a source
and destination for events, respectively.
</p>

<a name="JDP-CH-6-EX-15"></a>
<div class="example">
<h4 class="objtitle">Example 6-14. EventHandler Interface</h4>
<blockquote>
<pre class="programlisting">package dcj.util.message;

import java.util.EventListener;
import java.util.EventObject;

public interface EventHandler extends EventListener {
  public void handleEvent(EventObject e);
}</pre>
</blockquote>
</div>

<p>The <tt class="literal">EventTransceiver</tt> interface includes
<tt class="literal">addHandler()</tt><a name="INDEX-946"></a>
methods that let you attach <tt class="literal">EventHandler</tt>s to
this event source. You can register a handler for any events, or you
can register a handler for a specific type of event by providing a
second argument that's either an instance of an
<tt class="literal">EventObject</tt> subclass, or the
<tt class="literal">Class</tt> object for the subclass itself. The
<tt class="literal">EventTransceiver</tt> keeps the registered handlers
in a hashtable of <tt class="literal">Vector</tt>s that hold the
<tt class="literal">EventHandler</tt>s; the sets of handlers are hashed by
the <tt class="literal">EventObject</tt> subclass under which they were
registered. Handlers can be removed from the transceiver using the
corresponding
<tt class="literal">removeHandler()</tt><a name="INDEX-947"></a>
methods. The
<tt class="literal">distributeEvent()</tt><a name="INDEX-948"></a>
method takes an <tt class="literal">EventObject</tt> instance and passes
it to the registered handlers. First it calls the
<tt class="literal">handleEvent()</tt> method on any handlers registered
to receive all events. Then it looks up the handlers registered for
the specific type of event by getting the <tt class="literal">Class</tt>
of the <tt class="literal">EventObject</tt>, and getting the
<tt class="literal">Vector</tt> of <tt class="literal">EventHandler</tt>s
from its table of handlers. It passes the
<tt class="literal">EventObject</tt> to the
<tt class="literal">handleEvent()</tt> method of any handlers it finds.
</p>

<p>The <tt class="literal">EventTransceiver</tt> has a
<tt class="literal">sendEvent()</tt><a name="INDEX-949"></a><a name="INDEX-950"></a> method for
sending an <tt class="literal">Event-Object</tt> directly to its remote
agent, and a <tt class="literal">receiveEvent()</tt> method that does a
blocking read on the <tt class="literal">InputStream</tt> (using an
<tt class="literal">ObjectInputStream</tt> wrapper) for an
<tt class="literal">EventObject</tt> from the remote agent. The
<tt class="literal">EventTransceiver</tt> also extends
<tt class="literal">Thread</tt>, and in its <tt class="literal">run()</tt>
method it performs an infinite loop, reading events from its
<tt class="literal">InputStream</tt> using its
<tt class="literal">receiveEvent()</tt> method and distributing them by
calling its own <tt class="literal">distributeEvent()</tt>
method.<a name="INDEX-951"></a><a name="INDEX-952"></a>
</p>

<p>Using the <tt class="literal">EventTransceiver</tt> class, implementing
our <a name="INDEX-953"></a>
chess-playing server is just a matter of subclassing a
<tt class="literal">ChessEventServer</tt><a name="INDEX-954"></a> class, as shown in <a href="#JDP-CH-6-EX-16">Example 6-15</a>. The <tt class="literal">ChessEventServer</tt>
maintains its own <tt class="literal">ChessPlayer</tt> object, and it
mediates a game between its player and a remote player, much like the
message-passing <tt class="literal">ChessServer</tt> in <a href="ch06_04.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch06_04.htm">Example 6-5</a>. In its constructors, the
<tt class="literal">ChessEventServer</tt> registers with itself to
receive <tt class="literal">ChessMoveEvent</tt> and
<tt class="literal">ChessConcedeEvent</tt> events.
</p>

<a name="JDP-CH-6-EX-16"></a>
<div class="example">
<h4 class="objtitle">Example 6-15. An Event-Based Chess Server</h4>
<blockquote>
<pre class="programlisting">package dcj.examples.message;

import dcj.util.message.*;
import java.util.*;
import java.net.*;
import java.io.IOException;

public class ChessEventServer extends EventTransceiver {
  ChessPlayer player = new ChessPlayer();

  public ChessEventServer(String host, int port) {
    super(host, port);
    register();
  }

  public ChessEventServer(InetAddress host, int port) {
    super(host, port);
    register();
  }

  void register() {
    // Add ourselves to this handler's list for
    // chess-related events
    try {
      addHandler(this, Class.forName("ChessMoveEvent"));
      addHandler(this, Class.forName("ChessConcedeEvent"));
    }
    catch (ClassNotFoundException nfe) {}
  }

  public void handleEvent(EventObject e) {
    try {
      if (e instanceof ChessMoveEvent) {
        ChessMoveEvent cm = (ChessMoveEvent)e;
        ChessMove m = cm.getMove();
        switch (cm.getType()) {
          case ChessMoveEvent.SUBMIT:
            if (player.acceptMove(m)) {
              ChessMoveEvent conf = new ChessMoveEvent(m, player);
              conf.setConfirm();
              sendEvent(conf);

              ChessMove next = player.nextMove();
              if (next != null) {
                ChessMoveEvent submit = new ChessMoveEvent(next, player);
                sendEvent(submit);
              }
              else {
                sendEvent(new ChessConcedeEvent(player));
              }
            }
            else {
              ChessMoveEvent reject = new ChessMoveEvent(m, player);
              reject.setReject();
              sendEvent(reject);
            }
          break;

          case ChessMoveEvent.REJECT:
            ChessMove next = player.nextMove();
            if (next != null) {
              sendEvent(new ChessMoveEvent(next, player));
            }
            else {
              sendEvent(new ChessConcedeEvent(player));
            }
          break;

          case ChessMoveEvent.CONFIRM:
            player.moveAccepted(m);
          break;
        }
      }
      // If we get a concede message, the other player has
      // given up and we win...
      else if (e instanceof ChessConcedeEvent) {
        player.conceded();
      }
    }
    catch (IOException ioe) {
      System.out.println("IO error while handling event.");
      ioe.printStackTrace();
    }
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-955"></a>

<p>Both of these <tt class="literal">EventObject</tt> subclasses are shown
in <a href="#JDP-CH-6-EX-17">Example 6-16</a>. Everything else is done in the
<tt class="literal">ChessEventServer</tt>.<tt class="literal">handleEvent()</tt>
method. When it receives a
<tt class="literal">ChessMoveEvent</tt><a name="INDEX-956"></a> from the remote agent, it checks
the type of move event (SUBMIT, CONFIRM, or REJECT), and calls the
appropriate method on the local player. If necessary, it takes output
from the local player and sends it off to the remote player as a
<tt class="literal">ChessMoveEvent</tt> or
<tt class="literal">ChessConcedeEvent</tt>, calling its
<tt class="literal">sendEvent()</tt> method to transmit the event to the
remote agent. If a <tt class="literal">ChessConcedeEvent</tt> comes in,
then it tells the local player that it won the game by calling its
<tt class="literal">conceded()</tt> method.
</p>

<a name="JDP-CH-6-EX-17"></a>
<div class="example">
<h4 class="objtitle">Example 6-16. Chess-Specific EventObjects</h4>
<blockquote>
<pre class="programlisting">package dcj.examples.message;

import java.util.EventObject;

public class ChessMoveEvent extends EventObject {
  ChessMove move;
  int type;

  public final static int SUBMIT = 0;
  public final static int CONFIRM = 1;
  public final static int REJECT = 2;

  public ChessMoveEvent(ChessMove subject, ChessPlayer src) {
    super(src);
    move = subject;
    type = SUBMIT;
  }

  public int getType() { return type; }

  // Set the type of the move event
  public void setConfirm() { type = CONFIRM; }
  public void setReject() { type = REJECT; }
  public void setSubmit() { type = SUBMIT; }

  // Get and set the move
  public ChessMove getMove() { return move; }
  public void setMove(ChessMove m) { move = m; }
}

public class ChessConcedeEvent extends EventObject {
  // Just a placeholder class, no data or methods needed
  public ChessConcedeEvent(ChessPlayer src) {
    super(src);
  }
}</pre>
</blockquote>
</div>

<a name="INDEX-957"></a>
<a name="INDEX-958"></a>
<a name="INDEX-959"></a>
<a name="INDEX-960"></a>


<a name="JDP-CH-6-SECT-6.3"></a>
<h3 class="sect2">6.6.3. Pros and Cons</h3>

<p>In terms of the overall utility of the system, this event-based
message-passing system is about equivalent to the framework we
developed earlier in the chapter. What it offers, however, is the
possibility of integrating our distributed event-handling system with
AWT-based applications to create distributed user interfaces of a
sort. Since our <tt class="literal">EventTransceiver</tt> is written to
handle events in the form of Java <tt class="literal">EventObject</tt>,
there's no reason it can't send and receive <a name="INDEX-961"></a>
AWT events from user interfaces between agents on the network, as
long as they are <tt class="literal">Serializable</tt>. <a href="#JDP-CH-6-FIG-2">Figure 6-2</a>, for example, demonstrates an AWT button with
a listener (the <a name="INDEX-962"></a><tt class="literal">SurrogateActionListener</tt>) attached that sends
action events from the button through the
<tt class="literal">EventTransceiver</tt> to a remote agent, where the
action is processed. The listener would need to implement the
<tt class="literal">java.awt.ActionListener</tt> interface, as well as
our <tt class="literal">EventHandler</tt> interface, as shown in <a href="#JDP-CH-6-EX-18">Example 6-17</a>.
</p>

<a name="JDP-CH-6-FIG-2"></a>
<div class="figure">
<img alt="figure" src="figs/jdc_0602.gif" webstripperlinkwas="figs/jdc_0602.gif"></div>
<h4 class="objtitle">Figure 6-2. Distributing AWT events to remote handlers</h4>

<a name="JDP-CH-6-EX-18"></a>
<div class="example">
<h4 class="objtitle">Example 6-17. A Surrogate AWT ActionListener</h4>
<blockquote>
<pre class="programlisting">import java.awt.event.*;
import dcj.util.message;

public class SurrogateActionListener implements ActionListener, 
                                                EventHandler {

  private EventTransceiver xceiver;

  public SurrogateActionListener(EventTransceiver t) {
    xceiver = t;
    // Register as handler for global events
    xceiver.addHandler(this);
  }

  public void actionPerformed(ActionEvent e) {
    // A local action event has been generated - send it
    // to the remote agent
    xceiver.sendEvent(e);
  }

  public void handleEvent(EventObject) {
    // Do something with events from the transceiver...
  }
}</pre>
</blockquote>
</div>

<p>We could attach this listener to a local AWT interface element like a
<tt class="literal">Button</tt>, and when the <tt class="literal">Button</tt>
generates an action event, it will be passed to the
<tt class="literal">sendEvent()</tt> method on the
<tt class="literal">EventTransceiver</tt> to a remote agent. The remote
agent may then do something in reaction to the button event, and
perhaps generate an event in response. The event will be received by
the local <tt class="literal">EventTransceiver</tt> and, since the
<tt class="literal">SurrogateActionListener</tt> registers itself with
its <tt class="literal">EventTransceiver</tt> as a handler for any
events, the transceiver will call the
<tt class="literal">SurrogateActionListener</tt>'s
<tt class="literal">handleEvent()</tt> method, which can act on the event
from the remote agent (change the button's color, put some text
on the screen, etc.).
</p>

<p>Using the <tt class="literal">SurrogateActionListener</tt>, we would only
need to create an <tt class="literal">EventTransceiver</tt> as we did
before, then construct a
<tt class="literal">SurrogateActionListener</tt>, passing the
<tt class="literal">EventTransceiver</tt> into its constructor. We would
then register the listener as an <tt class="literal">ActionListener</tt>
on the AWT Button by calling the <tt class="literal">Button</tt>'s
<tt class="literal">addActionListener()</tt> method. This would establish
the event-passing link from the button, through the surrogate
listener to the transceiver, and finally to the remote event
handler.<a name="INDEX-963"></a>
</p>

<p>Although this approach is interesting and potentially useful, you
have to be careful what kinds of events you're trying to route
over the network. The <tt class="literal">Event-Object</tt> is going to
be serialized by the <tt class="literal">EventTransceiver</tt> and sent
over the network to the remote transceiver. If the
<tt class="literal">EventObject</tt> subclass keeps a non-transient
reference to other local objects, like one of the AWT components,
then these objects and any objects they reference, etc., down the
whole reference tree, will be serialized and transmitted, too. This
would result in an <tt class="literal">IOException</tt> if any of the
objects in the tree aren't <tt class="literal">Serializable</tt>.
If serialization succeeds, you might end up sending an unexpectedly
large amount of data over the wire.<a name="INDEX-964"></a>
</p>

<p>Be aware that the only state information that the remote event
handler has to interpret the event is contained in the
<tt class="literal">EventObject</tt> itself. Since the remote handler
doesn't have direct access to the actual interface components
(unless they were serialized within the
<tt class="literal">EventObject</tt>), it can't directly query them
for their state. So a little more care has to be taken in ensuring
that each <tt class="literal">Event-Object</tt> contains all of the
information the handler needs to deal with the event.<a name="INDEX-965"></a><a name="INDEX-966"></a>
</p>




<!-- BOTTOM NAV BAR -->

<hr width="515" align="left">
<div class="navbar">
<table width="515" border="0">
<tr>
<td align="left" valign="top" width="172"><a href="ch06_05.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch06_05.htm"><img src="../gifs/txtpreva.gif" webstripperlinkwas="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="171"><a href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"><img src="../gifs/txthome.gif" webstripperlinkwas="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="172"><a href="ch06_07.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/ch06_07.htm"><img src="../gifs/txtnexta.gif" webstripperlinkwas="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="172">6.5. Adaptable Protocols</td><td align="center" valign="top" width="171"><a href="index/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index/index.htm"><img src="../gifs/index.gif" webstripperlinkwas="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="172">6.7. Using Remote Objects</td>
</tr>
</table>
</div>
<hr width="515" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" webstripperlinkwas="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/copyrght.htm">Copyright &copy; 2001</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <map name="library-map"> <area shape="rect" coords="-8,-5,72,97" href="../index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/index.htm"> <area shape="rect" coords="75,2,150,109" href="../jenut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jenut/index.htm"> <area shape="rect" coords="154,0,225,99" href="../jnut/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jnut/index.htm"> <area shape="rect" coords="228,3,298,112" href="../jfc/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/jfc/index.htm"> <area shape="rect" coords="306,1,373,124" href="../ebeans/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/ebeans/index.htm"> <area shape="rect" coords="380,2,446,115" href="../servlet/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/servlet/index.htm"> <area shape="rect" coords="452,1,524,101" href="../security/index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/security/index.htm"> <area shape="rect" coords="528,2,610,102" href="index.htm" webstripperlinkwas="http://ext.rlab.cs.nyu.edu/~jsr/oreilly/dist/index.htm"> </map>
</map>

<!-- END OF BODY -->

</body>
</html>
