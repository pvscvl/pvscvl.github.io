<HTML
><HEAD
>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:38:04Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Perl Cookbook"><LINK
REL="prev"
HREF="ch07_23.htm"
TITLE="7.22. Program: lockarea"><LINK
REL="next"
HREF="ch08_02.htm"
TITLE="8.1. Reading Lines with Continuation Characters"></HEAD
><BODY
BGCOLOR="#FFFFFF"><img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Perl Cookbook"><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map><div class="navbar"><p>
<TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch07_23.htm"
TITLE="7.22. Program: lockarea"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.22. Program: lockarea"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.1. Reading Lines with Continuation Characters"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.1. Reading Lines with Continuation Characters"
BORDER="0"></A
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch08-11143"
>8. File Contents</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch08-23799"
TITLE="8.0. Introduction"
>Introduction</A
><BR><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.1. Reading Lines with Continuation Characters"
>Reading Lines with Continuation Characters</A
><BR><A
CLASS="sect1"
HREF="ch08_03.htm"
TITLE="8.2. Counting Lines (or Paragraphs or Records) in a File"
>Counting Lines (or Paragraphs or Records) in a File</A
><BR><A
CLASS="sect1"
HREF="ch08_04.htm"
TITLE="8.3. Processing Every Word in a File"
>Processing Every Word in a File</A
><BR><A
CLASS="sect1"
HREF="ch08_05.htm"
TITLE="8.4. Reading a File Backwards by Line or Paragraph"
>Reading a File Backwards by Line or Paragraph</A
><BR><A
CLASS="sect1"
HREF="ch08_06.htm"
TITLE="8.5. Trailing a Growing File"
>Trailing a Growing File</A
><BR><A
CLASS="sect1"
HREF="ch08_07.htm"
TITLE="8.6. Picking a Random Line from a File"
>Picking a Random Line from a File</A
><BR><A
CLASS="sect1"
HREF="ch08_08.htm"
TITLE="8.7. Randomizing All Lines"
>Randomizing All Lines</A
><BR><A
CLASS="sect1"
HREF="ch08_09.htm"
TITLE="8.8. Reading a Particular Line in a File"
>Reading a Particular Line in a File</A
><BR><A
CLASS="sect1"
HREF="ch08_10.htm"
TITLE="8.9. Processing Variable-Length Text Fields"
>Processing Variable-Length Text Fields</A
><BR><A
CLASS="sect1"
HREF="ch08_11.htm"
TITLE="8.10. Removing the Last Line of a File"
>Removing the Last Line of a File</A
><BR><A
CLASS="sect1"
HREF="ch08_12.htm"
TITLE="8.11. Processing Binary Files"
>Processing Binary Files</A
><BR><A
CLASS="sect1"
HREF="ch08_13.htm"
TITLE="8.12. Using Random-Access I/O"
>Using Random-Access I/O</A
><BR><A
CLASS="sect1"
HREF="ch08_14.htm"
TITLE="8.13. Updating a Random-Access File"
>Updating a Random-Access File</A
><BR><A
CLASS="sect1"
HREF="ch08_15.htm"
TITLE="8.14. Reading a String from a Binary File"
>Reading a String from a Binary File</A
><BR><A
CLASS="sect1"
HREF="ch08_16.htm"
TITLE="8.15. Reading Fixed-Length Records"
>Reading Fixed-Length Records</A
><BR><A
CLASS="sect1"
HREF="ch08_17.htm"
TITLE="8.16. Reading Configuration Files"
>Reading Configuration Files</A
><BR><A
CLASS="sect1"
HREF="ch08_18.htm"
TITLE="8.17. Testing a File for Trustworthiness"
>Testing a File for Trustworthiness</A
><BR><A
CLASS="sect1"
HREF="ch08_19.htm"
TITLE="8.18. Program: tailwtmp"
>Program: tailwtmp</A
><BR><A
CLASS="sect1"
HREF="ch08_20.htm"
TITLE="8.19. Program: tctee"
>Program: tctee</A
><BR><A
CLASS="sect1"
HREF="ch08_21.htm"
TITLE="8.20. Program: laston"
>Program: laston</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>The most brilliant decision in all of Unix was the choice of a single character for the newline sequence.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Mike O'Dell, only half jokingly </P
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch08-23799"
>8.0. Introduction</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-1000004574-0"
></A
>Before the Unix Revolution, every kind of data source and destination was inherently different. Getting two programs merely to understand each other required heavy wizardry and the occasional sacrifice of a virgin stack of punch cards to an itinerant mainframe repairman. This computational Tower of Babel made programmers dream of quitting the field to take up a less painful hobby, like autoflagellation.</P
><P
CLASS="para"
>These days, such cruel and unusual programming is largely behind us. Modern operating systems work hard to provide the illusion that I/O devices, network connections, process control information, other programs, the system console, and even users' terminals are all abstract streams of bytes called <EM
CLASS="emphasis"
>files</EM
>. This lets you easily write programs that don't care where their input came from or where their output goes.</P
><P
CLASS="para"
>Because programs read and write via byte streams of simple text, every program can communicate with every other program. It is difficult to overstate the power and elegance of this approach. No longer dependent upon troglodyte gnomes with secret tomes of JCL (or COM) incantations, users can now create custom tools from smaller ones by using simple command-line I/O redirection, pipelines, and backticks.</P
><P
CLASS="para"
>Treating files as unstructured byte streams necessarily governs what you can do with them. You can read and write sequential, fixed-size blocks of data at any location in the file, increasing its size if you write past the current end. Perl uses the standard C I/O library to implement reading and writing of variable-length records like lines, paragraphs, and words.</P
><P
CLASS="para"
>What can't you do to an unstructured file? Because you can't insert or delete bytes anywhere but at end of file, you can't change the length of, insert, or delete records. An exception is the last record, which you can delete by truncating the file to the end of the previous record. For other modifications, you need to use a temporary file or work with a copy of the file in memory. If you need to do this a lot, a database system may be a better solution than a raw file (see <A
CLASS="xref"
HREF="ch14_01.htm"
TITLE="Database Access"
>Chapter 14, <CITE
CLASS="chapter"
>Database Access</CITE
></A
>).</P
><P
CLASS="para"
>The most common files are text files, and the most common operations on text files are reading and writing lines. <A
CLASS="indexterm"
NAME="ch08-idx-1000004596-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-1000004596-1"
></A
>Use <CODE
CLASS="literal"
>&lt;FH&gt;</CODE
> (or the internal function implementing it, <CODE
CLASS="literal"
>readline</CODE
>) to read lines, and use <CODE
CLASS="literal"
>print</CODE
> to write them. These functions can also be used to read or write any record that has a specific record separator. Lines are simply records that end in <CODE
CLASS="literal"
>&quot;\n&quot;</CODE
>.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>&lt;FH&gt;</CODE
> operator returns <CODE
CLASS="literal"
>undef</CODE
> on error or when end of the file is reached, so use it in loops like this:</P
><PRE
CLASS="programlisting"
>while (defined ($line = &lt;DATAFILE&gt;)) {
    chomp $line;
    $size = length $line;
    print &quot;$size\n&quot;;                # output size of line
}</PRE
><P
CLASS="para"
>Because this is a common operation and that's a lot to type, Perl gives it a shorthand notation. This shorthand reads lines into <CODE
CLASS="literal"
>$_</CODE
> instead of <CODE
CLASS="literal"
>$line</CODE
>. Many other string operations use <CODE
CLASS="literal"
>$_</CODE
> as a default value to operate on, so this is more useful than it may appear at first:</P
><PRE
CLASS="programlisting"
>while (&lt;DATAFILE&gt;) {
    chomp;
    print length, &quot;\n&quot;;             # output size of line
}</PRE
><P
CLASS="para"
>Call <CODE
CLASS="literal"
>&lt;FH&gt;</CODE
> in scalar context to read the next line. Call it in list context to read all remaining lines:</P
><PRE
CLASS="programlisting"
>@lines = &lt;DATAFILE&gt;;</PRE
><P
CLASS="para"
>Each time <CODE
CLASS="literal"
>&lt;FH&gt;</CODE
> reads a record from a filehandle, it increments the special variable <CODE
CLASS="literal"
>$.</CODE
> (the "current input record number"). This variable is only reset when <CODE
CLASS="literal"
>close</CODE
> is called explicitly, which means that it's not reset when you reopen an already opened filehandle.</P
><P
CLASS="para"
>Another special variable is <CODE
CLASS="literal"
>$/</CODE
><A
CLASS="indexterm"
NAME="ch08-idx-1000004604-0"
></A
>, the input record separator. It is set to <CODE
CLASS="literal"
>&quot;\n&quot;</CODE
>, the default end-of-line marker. You can set it to any string you like, for instance <CODE
CLASS="literal"
>&quot;\0&quot;</CODE
> to read null-terminated records. Read paragraphs by setting <CODE
CLASS="literal"
>$/</CODE
> to the empty string, <CODE
CLASS="literal"
>&quot;&quot;</CODE
>. This is almost like setting <CODE
CLASS="literal"
>$/</CODE
> to <CODE
CLASS="literal"
>&quot;\n\n&quot;</CODE
>, in that blank lines function as record separators, but <CODE
CLASS="literal"
>&quot;&quot;</CODE
> treats two or more consecutive empty lines as a single record separator, whereas <CODE
CLASS="literal"
>&quot;\n\n&quot;</CODE
> returns empty records when more than two consecutive empty lines are read. Undefine <CODE
CLASS="literal"
>$/</CODE
> to read the rest of the file as one scalar:</P
><PRE
CLASS="programlisting"
>undef $/;
$whole_file = &lt;FILE&gt;;               # 'slurp' mode</PRE
><P
CLASS="para"
>The<A
CLASS="indexterm"
NAME="ch08-idx-1000004605-0"
></A
> <B
CLASS="emphasis.bold"
>-0</B
> option to Perl lets you set <CODE
CLASS="literal"
>$/</CODE
> from the command line:</P
><PRE
CLASS="programlisting"
>% perl -040 -e '$word = &lt;&gt;; print &quot;First word is $word\n&quot;;'</PRE
><P
CLASS="para"
>The digits after <B
CLASS="emphasis.bold"
>-0</B
> are the octal value of the single character that <CODE
CLASS="literal"
>$/</CODE
> is to be set to. If you specify an illegal value (e.g., with <B
CLASS="emphasis.bold"
>-0777</B
>) Perl will set <CODE
CLASS="literal"
>$/</CODE
> to <CODE
CLASS="literal"
>undef</CODE
>. If you specify <B
CLASS="emphasis.bold"
>-00</B
>, Perl will set <CODE
CLASS="literal"
>$/</CODE
> to <CODE
CLASS="literal"
>&quot;&quot;</CODE
>. The limit of a single octal value means you can't set <CODE
CLASS="literal"
>$/</CODE
> to a multibyte string, for instance, <CODE
CLASS="literal"
>&quot;%%\n&quot;</CODE
> to read <EM
CLASS="emphasis"
>fortune</EM
> files. Instead, you must use a <CODE
CLASS="literal"
>BEGIN</CODE
> block:</P
><PRE
CLASS="programlisting"
>% perl -ne 'BEGIN { $/=&quot;%%\n&quot; } chomp; print if /Unix/i' fortune.dat</PRE
><P
CLASS="para"
>Use <CODE
CLASS="literal"
>print</CODE
> to write a line or any other data. The <CODE
CLASS="literal"
>print</CODE
> function writes its arguments one after another and doesn't automatically add a line or record terminator by default.</P
><PRE
CLASS="programlisting"
>print HANDLE &quot;One&quot;, &quot;two&quot;, &quot;three&quot;; # &quot;Onetwothree&quot;
print &quot;Baa baa black sheep.\n&quot;;     # Sent to default output handle</PRE
><P
CLASS="para"
>There is no comma between the filehandle and the data to print. If you put a comma in there, Perl gives the error message <CODE
CLASS="literal"
>&quot;No</CODE
> <CODE
CLASS="literal"
>comma</CODE
> <CODE
CLASS="literal"
>allowed</CODE
> <CODE
CLASS="literal"
>after</CODE
> <CODE
CLASS="literal"
>filehandle&quot;</CODE
>. The default output handle is STDOUT. Change it with the <CODE
CLASS="literal"
>select</CODE
> function. (See the introduction to <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="File Access"
>Chapter 7, <CITE
CLASS="chapter"
>File Access</CITE
></A
>.)</P
><P
CLASS="para"
>All systems use the virtual <CODE
CLASS="literal"
>&quot;\n&quot;</CODE
> to represent a line terminator, called a <EM
CLASS="emphasis"
>newline</EM
>. There is no such thing as a newline character. It is an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve. Sometimes, this changes the number of characters in the strings you read and write. The conspiracy is revealed in <A
CLASS="xref"
HREF="ch08_12.htm"
TITLE="Processing Binary Files"
>Recipe 8.11</A
>.</P
><P
CLASS="para"
>Use the <CODE
CLASS="literal"
>read</CODE
><A
CLASS="indexterm"
NAME="ch08-idx-1000004606-0"
></A
> function to read a <A
CLASS="indexterm"
NAME="ch08-idx-1000004763-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-1000004763-1"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-1000004763-2"
></A
>fixed-length record. It takes three arguments: a filehandle, a scalar variable, and the number of bytes to read. It returns <CODE
CLASS="literal"
>undef</CODE
> if an error occurred or else the number of bytes read. To write a fixed-length record, just use <CODE
CLASS="literal"
>print</CODE
>.</P
><PRE
CLASS="programlisting"
>$rv = read(HANDLE, $buffer, 4096)
        or die &quot;Couldn't read from HANDLE : $!\n&quot;;
# $rv is the number of bytes read,
# $buffer holds the data read</PRE
><P
CLASS="para"
>The <CODE
CLASS="literal"
>truncate</CODE
><A
CLASS="indexterm"
NAME="ch08-idx-1000004607-0"
></A
> function changes the length of a file, which can be specified as a filehandle or as a filename. It returns true if the file was successfully truncated, false otherwise:</P
><PRE
CLASS="programlisting"
>truncate(HANDLE, $length)
    or die &quot;Couldn't truncate: $!\n&quot;;
truncate(&quot;/tmp/$$.pid&quot;, $length)
    or die &quot;Couldn't truncate: $!\n&quot;;</PRE
><P
CLASS="para"
>Each filehandle keeps track of where it is in the file. Reads and writes occur from this point, unless you've specified the <CODE
CLASS="literal"
>O_APPEND</CODE
> flag (see <A
CLASS="xref"
HREF="ch07_02.htm"
TITLE="Opening a File"
>Recipe 7.1</A
>). Fetch the file position for a filehandle with <CODE
CLASS="literal"
>tell</CODE
><A
CLASS="indexterm"
NAME="ch08-idx-1000004608-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-1000004608-1"
></A
>, and set it with <CODE
CLASS="literal"
>seek</CODE
>. Because the stdio library rewrites data to preserve the illusion that <CODE
CLASS="literal"
>&quot;\n&quot;</CODE
> is the line terminator, you cannot portably <CODE
CLASS="literal"
>seek</CODE
> to offsets calculated by counting characters. Instead, only <CODE
CLASS="literal"
>seek</CODE
> to offsets returned by <CODE
CLASS="literal"
>tell</CODE
>.</P
><PRE
CLASS="programlisting"
>$pos = tell(DATAFILE);
print &quot;I'm $pos bytes from the start of DATAFILE.\n&quot;;</PRE
><P
CLASS="para"
>The <CODE
CLASS="literal"
>seek</CODE
> function takes three arguments: the filehandle, the offset (in bytes) to go to, and a numeric argument indicating how to interpret the offset. 0 indicates an offset from the start of the file (the kind of value returned by <CODE
CLASS="literal"
>tell</CODE
>); 1, an offset from the current location (a negative number means move backwards in the file, a positive number means move forward); and 2, an offset from end of file.</P
><PRE
CLASS="programlisting"
>seek(LOGFILE, 0, 2)         or die &quot;Couldn't seek to the end: $!\n&quot;;
seek(DATAFILE, $pos, 0)     or die &quot;Couldn't seek to $pos: $!\n&quot;;
seek(OUT, -20, 1)           or die &quot;Couldn't seek back 20 bytes: $!\n&quot;;</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch08-idx-1000004609-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-1000004609-1"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-1000004609-2"
></A
>So far we've been describing buffered I/O. That is, <CODE
CLASS="literal"
>&lt;FH&gt;</CODE
>, <CODE
CLASS="literal"
>print</CODE
>, <CODE
CLASS="literal"
>read</CODE
>, <CODE
CLASS="literal"
>seek</CODE
>, and <CODE
CLASS="literal"
>tell</CODE
> are all operations that use buffers for speed. Perl also provides unbuffered I/O operations: <CODE
CLASS="literal"
>sysread</CODE
>, <CODE
CLASS="literal"
>syswrite</CODE
>, and <CODE
CLASS="literal"
>sysseek</CODE
>, all discussed in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="File Access"
>Chapter 7</A
>.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>sysread</CODE
><A
CLASS="indexterm"
NAME="ch08-idx-1000004610-0"
></A
><A
CLASS="indexterm"
NAME="ch08-idx-1000004610-1"
></A
> and <CODE
CLASS="literal"
>syswrite</CODE
> functions are different from their <CODE
CLASS="literal"
>&lt;FH&gt;</CODE
> and <CODE
CLASS="literal"
>print</CODE
> counterparts. They both take a filehandle to act on, a scalar variable to either read into or write out from, and the number of bytes to read or write. They can also take an optional fourth argument, the offset in the scalar variable to start reading or writing at:</P
><PRE
CLASS="programlisting"
>$written = syswrite(DATAFILE, $mystring, length($mystring));
die &quot;syswrite failed: $!\n&quot; unless $written == length($mystring);
$read = sysread(INFILE, $block, 256, 5);
warn &quot;only read $read bytes, not 256&quot; if 256 != $read;</PRE
><P
CLASS="para"
>The <CODE
CLASS="literal"
>syswrite</CODE
> call sends the contents of <CODE
CLASS="literal"
>$mystring</CODE
> to <CODE
CLASS="literal"
>DATAFILE</CODE
>. The <CODE
CLASS="literal"
>sysread</CODE
> call reads 256 bytes from <CODE
CLASS="literal"
>INFILE</CODE
> and stores them 5 characters into <CODE
CLASS="literal"
>$block</CODE
>, leaving its first 5 characters intact. Both <CODE
CLASS="literal"
>sysread</CODE
> and <CODE
CLASS="literal"
>syswrite</CODE
> return the number of bytes transferred, which could be different than the amount of data you were attempting to transfer. Maybe the file didn't have all the data you thought it did, so you got a short read. Maybe the filesystem that the file lives on filled up. Maybe your process was interrupted part of the way through the write. Stdio takes care of finishing the transfer in cases of interruption, but if you use the <CODE
CLASS="literal"
>sysread</CODE
> and <CODE
CLASS="literal"
>syswrite</CODE
> calls, you must do it yourself. See <A
CLASS="xref"
HREF="ch09_04.htm"
TITLE="Copying or Moving a File"
>Recipe 9.3</A
> for an example of this.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>sysseek</CODE
><A
CLASS="indexterm"
NAME="ch08-idx-1000004611-0"
></A
> function doubles as an unbuffered replacement for both <CODE
CLASS="literal"
>seek</CODE
> and <CODE
CLASS="literal"
>tell</CODE
>. It takes the same arguments as <CODE
CLASS="literal"
>seek</CODE
>, but it returns either the new position if successful or <CODE
CLASS="literal"
>undef</CODE
> on error. To find the current position within the file:</P
><PRE
CLASS="programlisting"
>$pos = sysseek(HANDLE, 0, 1);       # don't change position
die &quot;Couldn't sysseek: $!\n&quot; unless defined $pos;</PRE
><P
CLASS="para"
>These are the basic operations available to you. The art and craft of programming lies in using these basic operations to solve complex problems like finding the number of lines in a file, reversing the order of lines in a file, randomly selecting a line from a file, building an index for a file, and so on.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch07_23.htm"
TITLE="7.22. Program: lockarea"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.22. Program: lockarea"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch08_02.htm"
TITLE="8.1. Reading Lines with Continuation Characters"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.1. Reading Lines with Continuation Characters"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
>7.22. Program: lockarea</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="index"
HREF="index/index.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
>8.1. Reading Lines with Continuation Characters</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><FONT
SIZE="-1"
></DIV<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="../prog/index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm"></map> </BODY
></HTML
>
