<HTML
><HEAD
>
<TITLE>Recipe 3.11. Program: hopdelta (Perl Cookbook)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:30:48Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch03_01.htm"
TITLE="3. Dates and Times"><LINK
REL="prev"
HREF="ch03_11.htm"
TITLE="3.10. Short Sleeps"><LINK
REL="next"
HREF="ch04_01.htm"
TITLE="4. Arrays"></HEAD
><BODY
BGCOLOR="#FFFFFF"><img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Perl Cookbook"><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map><div class="navbar"><p>
<TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch03_11.htm"
TITLE="3.10. Short Sleeps"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 3.10. Short Sleeps"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch03_01.htm"
TITLE="3. Dates and Times"
></A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="chapter"
HREF="ch04_01.htm"
TITLE="4. Arrays"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4. Arrays"
BORDER="0"></A
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch03-10311"
>3.11. Program: hopdelta</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch03-idx-1000006363-0"
></A
><A
CLASS="indexterm"
NAME="ch03-idx-1000006363-1"
></A
><A
CLASS="indexterm"
NAME="ch03-idx-1000006363-2"
></A
>Have you ever wondered why it took so long for someone's mail to get to you? With postal mail, you can't trace how long each intervening post office let your letter gather dust in their back office. But with electronic mail, you can. The message carries in its header <CODE
CLASS="literal"
>Received:</CODE
><A
CLASS="indexterm"
NAME="ch03-idx-1000006369-0"
></A
> lines showing when each intervening mail transport agent along the way got the message.</P
><P
CLASS="para"
>The dates in the headers are hard to read. You have to read them backwards, bottom to top. They are written in many varied formats, depending on the whim of each transport agent. Worst of all, each date is written in its own local time zone. It's hard to eyeball <CODE
CLASS="literal"
>&quot;Tue,</CODE
> <CODE
CLASS="literal"
>26</CODE
> <CODE
CLASS="literal"
>May</CODE
> <CODE
CLASS="literal"
>1998</CODE
> <CODE
CLASS="literal"
>23:57:38</CODE
> <CODE
CLASS="literal"
>-0400&quot;</CODE
> and <CODE
CLASS="literal"
>&quot;Wed,</CODE
> <CODE
CLASS="literal"
>27</CODE
> <CODE
CLASS="literal"
>May</CODE
> <CODE
CLASS="literal"
>1998</CODE
> <CODE
CLASS="literal"
>05:04:03</CODE
> <CODE
CLASS="literal"
>+0100&quot;</CODE
> and realize these two dates are only 6 minutes and 25 seconds apart. <CODE
CLASS="literal"
></CODE
><A
CLASS="indexterm"
NAME="ch03-idx-1000006371-0"
></A
></P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>ParseDate</CODE
><A
CLASS="indexterm"
NAME="ch03-idx-1000006379-0"
></A
><A
CLASS="indexterm"
NAME="ch03-idx-1000006379-1"
></A
><A
CLASS="indexterm"
NAME="ch03-idx-1000006379-2"
></A
> and <CODE
CLASS="literal"
>DateCalc</CODE
> functions in the Date::Manip module from CPAN can help this:</P
><PRE
CLASS="programlisting"
>use Date::Manip qw(ParseDate DateCalc);
$d1 = ParseDate(&quot;Tue, 26 May 1998 23:57:38 -0400&quot;);
$d2 = ParseDate(&quot;Wed, 27 May 1998 05:04:03 +0100&quot;);
print DateCalc($d1, $d2);
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>+0:0:0:0:0:6:25</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
>That's a nice format for a program to read, but it's still not what the casual reader wants to see. The <EM
CLASS="emphasis"
>hopdelta</EM
> program, shown in <A
CLASS="xref"
HREF="ch03_12.htm"
TITLE="hopdelta"
>Example 3.1</A
>, takes a mailer header and tries to analyze the deltas (difference) between each hop (mail stop). Its output is shown in the local time zone.</P
><DIV
CLASS="example"
><H4
CLASS="example"
><A
CLASS="title"
NAME="ch03-29485"
>Example 3.1: hopdelta</A
></H4
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
# hopdelta - feed mail header, produce lines
#            showing delay at each hop.
use strict;
use Date::Manip qw (ParseDate UnixDate);

# print header; this should really use format/write due to
# printf complexities
printf &quot;%-20.20s %-20.20s %-20.20s   %s\n&quot;, 
        &quot;Sender&quot;, &quot;Recipient&quot;, &quot;Time&quot;, &quot;Delta&quot;;

$/ = '';                # paragraph mode
$_ = &lt;&gt;;                # read header
s/\n\s+/ /g;            # join continuation lines

# calculate when and where this started
my($start_from) = /^From.*\@([^\s&gt;]*)/m;
my($start_date) = /^Date:\s+(.*)/m;
my $then = getdate($start_date);
printf &quot;%-20.20s %-20.20s %s\n&quot;, 'Start', $start_from, fmtdate($then);

my $prevfrom = $start_from;

# now process the headers lines from the bottom up
for (reverse split(/\n/)) {
    my ($delta, $now, $from, $by, $when);
    next unless /^Received:/;
    s/\bon (.*?) (id.*)/; $1/s;         # qmail header, I think
    unless (($when) = /;\s+(.*)$/) {    # where the date falls
        warn &quot;bad received line: $_&quot;;
        next;
    }
    ($from) = /from\s+(\S+)/;           
    ($from) = /\((.*?)\)/ unless $from; # some put it here
    $from =~ s/\)$//;                   # someone was too greedy
    ($by)   = /by\s+(\S+\.\S+)/;        # who sent it on this hop

    # now random mungings to get their string parsable
    for ($when) {
        s/ (for|via) .*$//;
        s/([+-]\d\d\d\d) \(\S+\)/$1/;
        s/id \S+;\s*//;
    }
    next unless $now = getdate($when);          # convert to Epoch
    $delta = $now - $then;

    printf &quot;%-20.20s %-20.20s %s  &quot;, $from, $by, fmtdate($now);
    $prevfrom = $by;
    puttime($delta);
    $then = $now;               
}

exit;

# convert random date strings into Epoch seconds
sub getdate {
    my $string     =  shift;
    $string        =~ s/\s+\(.*\)\s*$//;        # remove nonstd tz
    my $date       =  ParseDate($string);
    my $epoch_secs =  UnixDate($date,&quot;%s&quot;);
    return $epoch_secs;
}

# convert Epoch seconds into a particular date string
sub fmtdate {
    my $epoch = shift;
    my($sec,$min,$hour,$mday,$mon,$year) = localtime($epoch);
    return sprintf &quot;%02d:%02d:%02d %04d/%02d/%02d&quot;,
        $hour, $min, $sec,
        $year + 1900, $mon + 1, $mday,
}

# take seconds and print in pleasant-to-read format
sub puttime {
    my($seconds) = shift;
    my($days, $hours, $minutes);

    $days    = pull_count($seconds, 24 * 60 * 60);
    $hours   = pull_count($seconds, 60 * 60);
    $minutes = pull_count($seconds, 60);

    put_field('s', $seconds);
    put_field('m', $minutes);
    put_field('h', $hours);
    put_field('d', $days);

    print &quot;\n&quot;;
}

# usage: $count = pull_count(seconds, amount)
# remove from seconds the amount quantity, altering caller's version.
# return the integral number of those amounts so removed.
sub pull_count {
    my($answer) = int($_[0] / $_[1]);
    $_[0] -= $answer * $_[1];
    return $answer;
}

# usage: put_field(char, number)
# output number field in 3-place decimal format, with trailing char
# suppress output unless char is 's' for seconds
sub put_field {
    my ($char, $number) = @_;
    printf &quot; %3d%s&quot;, $number, $char if $number || $char eq 's';
}</PRE
></DIV
><PRE
CLASS="programlisting"
><CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Sender               Recipient            Time                   Delta</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Start                wall.org             09:17:12 1998/05/23</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>wall.org             mail.brainstorm.net  09:20:56 1998/05/23    44s   3m</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>mail.brainstorm.net  jhereg.perl.com      09:20:58 1998/05/23     2s</I
></CODE
></B
></CODE
> 
<A
CLASS="indexterm"
NAME="ch03-idx-1000006365-0"
></A
><A
CLASS="indexterm"
NAME="ch03-idx-1000006365-1"
></A
><A
CLASS="indexterm"
NAME="ch03-idx-1000006365-2"
></A
><A
CLASS="indexterm"
NAME="ch03-idx-1000006216-0"
></A
></PRE
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch03_11.htm"
TITLE="3.10. Short Sleeps"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 3.10. Short Sleeps"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="chapter"
HREF="ch04_01.htm"
TITLE="4. Arrays"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4. Arrays"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
>3.10. Short Sleeps</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="index"
HREF="index/index.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
>4. Arrays</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><FONT
SIZE="-1"
></DIV<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="../prog/index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm"></map> </BODY
></HTML
>
