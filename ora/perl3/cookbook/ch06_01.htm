<HTML
><HEAD
>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:33:04Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Perl Cookbook"><LINK
REL="prev"
HREF="ch05_17.htm"
TITLE="5.16. Program: dutree"><LINK
REL="next"
HREF="ch06_02.htm"
TITLE="6.1. Copying and Substituting Simultaneously"></HEAD
><BODY
BGCOLOR="#FFFFFF"><img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Perl Cookbook"><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map><div class="navbar"><p>
<TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch05_17.htm"
TITLE="5.16. Program: dutree"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.16. Program: dutree"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch06_02.htm"
TITLE="6.1. Copying and Substituting Simultaneously"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.1. Copying and Substituting Simultaneously"
BORDER="0"></A
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch06-32612"
>6. Pattern Matching</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch06-35940"
TITLE="6.0. Introduction"
>Introduction</A
><BR><A
CLASS="sect1"
HREF="ch06_02.htm"
TITLE="6.1. Copying and Substituting Simultaneously"
>Copying and Substituting Simultaneously</A
><BR><A
CLASS="sect1"
HREF="ch06_03.htm"
TITLE="6.2. Matching Letters"
>Matching Letters</A
><BR><A
CLASS="sect1"
HREF="ch06_04.htm"
TITLE="6.3. Matching Words"
>Matching Words</A
><BR><A
CLASS="sect1"
HREF="ch06_05.htm"
TITLE="6.4.  Commenting Regular Expressions"
> Commenting Regular Expressions</A
><BR><A
CLASS="sect1"
HREF="ch06_06.htm"
TITLE="6.5. Finding the Nth Occurrence of a Match"
>Finding the N<SUP
CLASS="superscript"
>th</SUP
> Occurrence of a Match</A
><BR><A
CLASS="sect1"
HREF="ch06_07.htm"
TITLE="6.6. Matching Multiple Lines"
>Matching Multiple Lines</A
><BR><A
CLASS="sect1"
HREF="ch06_08.htm"
TITLE="6.7. Reading Records with a Pattern Separator"
>Reading Records with a Pattern Separator</A
><BR><A
CLASS="sect1"
HREF="ch06_09.htm"
TITLE="6.8. Extracting a Range of Lines"
>Extracting a Range of Lines</A
><BR><A
CLASS="sect1"
HREF="ch06_10.htm"
TITLE="6.9. Matching Shell Globs as Regular Expressions"
>Matching Shell Globs as Regular Expressions</A
><BR><A
CLASS="sect1"
HREF="ch06_11.htm"
TITLE="6.10. Speeding Up Interpolated Matches"
>Speeding Up Interpolated Matches</A
><BR><A
CLASS="sect1"
HREF="ch06_12.htm"
TITLE="6.11. Testing for a Valid Pattern"
>Testing for a Valid Pattern</A
><BR><A
CLASS="sect1"
HREF="ch06_13.htm"
TITLE="6.12. Honoring Locale Settings in Regular Expressions"
>Honoring Locale Settings in Regular Expressions</A
><BR><A
CLASS="sect1"
HREF="ch06_14.htm"
TITLE="6.13. Approximate Matching"
>Approximate Matching</A
><BR><A
CLASS="sect1"
HREF="ch06_15.htm"
TITLE="6.14. Matching from Where the Last Pattern Left Off"
>Matching from Where the Last Pattern Left Off</A
><BR><A
CLASS="sect1"
HREF="ch06_16.htm"
TITLE="6.15. Greedy and Non-Greedy Matches"
>Greedy and Non-Greedy Matches</A
><BR><A
CLASS="sect1"
HREF="ch06_17.htm"
TITLE="6.16. Detecting Duplicate Words"
>Detecting Duplicate Words</A
><BR><A
CLASS="sect1"
HREF="ch06_18.htm"
TITLE="6.17. Expressing AND, OR, and NOT in a Single Pattern"
>Expressing AND, OR, and NOT in a Single Pattern</A
><BR><A
CLASS="sect1"
HREF="ch06_19.htm"
TITLE="6.18. Matching Multiple-Byte Characters"
>Matching Multiple-Byte Characters</A
><BR><A
CLASS="sect1"
HREF="ch06_20.htm"
TITLE="6.19. Matching a Valid Mail Address"
>Matching a Valid Mail Address</A
><BR><A
CLASS="sect1"
HREF="ch06_21.htm"
TITLE="6.20. Matching Abbreviations"
>Matching Abbreviations</A
><BR><A
CLASS="sect1"
HREF="ch06_22.htm"
TITLE="6.21. Program: urlify"
>Program: urlify</A
><BR><A
CLASS="sect1"
HREF="ch06_23.htm"
TITLE="6.22. Program: tcgrep"
>Program: tcgrep</A
><BR><A
CLASS="sect1"
HREF="ch06_24.htm"
TITLE="6.23. Regular Expression Grabbag"
>Regular Expression Grabbag</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>[Art is] pattern informed by sensibility.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Sir Herbert Read <CITE
CLASS="citetitle"
>The Meaning of Art</CITE
></P
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch06-35940"
>6.0. Introduction</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-1000007453-0"
></A
>Although most modern programming languages offer primitive pattern matching tools, usually through an extra library, Perl's patterns are integrated directly into the language core. Perl's patterns boast features not found in pattern matching in other languages, features that encourage a whole different way of looking at data. Just as chess players see patterns in the board positions that their pieces control, Perl adepts look at data in terms of patterns. These patterns, expressed in the punctuation-intensive language of regular expressions,[<A
CLASS="footnote"
HREF="#ch06-pgfId-1000006582"
>1</A
>] provide access to powerful algorithms normally available only to computer science scholars.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch06-pgfId-1000006582"
>[1]</A
> To be honest, <EM
CLASS="emphasis"
>regular expressions</EM
> in the classic sense of the word do not by definition contain backreferences, the way Perl's patterns do.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>"If this pattern matching thing is so powerful and so fantastic," you may be saying, "why don't you have a hundred different recipes on regular expressions in this chapter?" Regular expressions are the natural solution to many problems involving numbers, strings, dates, web documents, mail addresses, and almost everything else in this book ;  we used pattern matching over 100 times in other chapters. This chapter mostly presents recipes in which pattern matching forms part of the questions, not just part of the answers.</P
><P
CLASS="para"
>Perl's extensive and ingrained support for regular expressions means that you not only have features available that you won't find in any other language, but you have new ways of using them, too. Programmers new to Perl often look for functions like these:</P
><PRE
CLASS="programlisting"
>match( $string, $pattern );
subst( $string, $pattern, $replacement );</PRE
><P
CLASS="para"
>But matching and substituting are such common tasks that they merit their own syntax:</P
><PRE
CLASS="programlisting"
>$meadow =~ m/sheep/;   # True if $meadow contains &quot;sheep&quot;
$meadow !~ m/sheep/;   # True if $meadow doesn't contain &quot;sheep&quot;
$meadow =~ s/old/new/; # Replace &quot;old&quot; with &quot;new&quot; in $meadow</PRE
><P
CLASS="para"
>Pattern matching isn't like direct string comparison, even at its simplest. It's more like string searching with mutant wildcards on steroids. Without anchors, the position where the match occurs can float freely throughout the string. Any of the following lines would also be matched by the expression <CODE
CLASS="literal"
>$meadow</CODE
> <CODE
CLASS="literal"
>=~</CODE
> <CODE
CLASS="literal"
>/ovine/</CODE
>, giving false positives when looking for lost sheep:</P
><PRE
CLASS="programlisting"
>Fine bovines demand fine toreadors.
Muskoxen are a polar ovibovine species.
Grooviness went out of fashion decades ago.</PRE
><P
CLASS="para"
>Sometimes they're right in front of you but they still don't match:</P
><PRE
CLASS="programlisting"
>Ovines are found typically in oviaries.</PRE
><P
CLASS="para"
>The problem is that while you are probably thinking in some human language, the pattern matching engine most assuredly is not. When the engine is presented with the pattern <CODE
CLASS="literal"
>/ovine/</CODE
> and a string to match this against, it searches the string for an <CODE
CLASS="literal"
>&quot;o&quot;</CODE
> that is immediately followed by a <CODE
CLASS="literal"
>&quot;v&quot;</CODE
>, then by an <CODE
CLASS="literal"
>&quot;i&quot;</CODE
>, then by an <CODE
CLASS="literal"
>&quot;n&quot;</CODE
>, and then finally by an <CODE
CLASS="literal"
>&quot;e&quot;</CODE
>. What comes before or after that sequence doesn't matter.</P
><P
CLASS="para"
>As you find your patterns matching some strings you don't want them to match and not matching other strings that you do want them to match, you start embellishing. If you're really looking for nothing but sheep, you probably want to match more like this:</P
><PRE
CLASS="programlisting"
>if ($meadow =~ /\bovines?\b/i) { print &quot;Here be sheep!&quot; }</PRE
><P
CLASS="para"
>Don't be tricked by the phantom cow lurking in that string. That's not a bovine. It's an ovine with a <CODE
CLASS="literal"
>\b</CODE
> in front, which matches at a word boundary only. The <CODE
CLASS="literal"
>s?</CODE
> indicates an optional <CODE
CLASS="literal"
>&quot;s&quot;</CODE
> so we can find one or more ovines. The trailing <CODE
CLASS="literal"
>/i</CODE
> makes whole pattern match case insensitive.</P
><P
CLASS="para"
>As you see, some characters or sequences of characters have special meaning to the pattern-matching engine. These metacharacters let you <EM
CLASS="emphasis"
>anchor</EM
> the pattern to the start or end of the string, give alternatives for parts of a pattern, allow repetition and wildcarding, and remember part of the matching substring for use later in the pattern or in subsequent code.</P
><P
CLASS="para"
>Learning the syntax of pattern matching isn't as daunting as it might appear. Sure, there are a lot of symbols, but each has a reason for existing. Regular expressions aren't random jumbles of punctuation &nbsp;-  they're carefully thought out jumbles of punctuation! If you forget one, you can always look it up. Summary tables are included in <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A>, <EM
CLASS="emphasis"
>Mastering Regular Expressions</EM
>, and the <I
CLASS="filename"
>perlre  </I
>(1) and <I
CLASS="filename"
>perlop  </I
>(1) manpages included with every Perl installation.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-chap06_the_0"
>The Tricky Bits</A
></H3
><P
CLASS="para"
>Much trickier than the syntax of regular expressions is their sneaky semantics. The three aspects of pattern-matching behavior that seem to cause folks the most trouble are greed, eagerness, and backtracking (and also how these three interact with each other).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-1000007459-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007459-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007459-2"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007459-3"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007459-4"
></A
>Greed is the principle that if a quantifier (like <CODE
CLASS="literal"
>*</CODE
>) can match a varying number of times, it will prefer to match as long a substring as it can. This is explained in <A
CLASS="xref"
HREF="ch06_16.htm"
TITLE="Greedy and Non-Greedy Matches"
>Recipe 6.15</A
>.</P
><P
CLASS="para"
>Eagerness is the notion that the leftmost match wins. The engine is very eager to return you a match as quickly as possible, sometimes even before you are expecting it. Consider the match <CODE
CLASS="literal"
>&quot;Fred&quot;</CODE
> <CODE
CLASS="literal"
>=~</CODE
> <CODE
CLASS="literal"
>/x*/</CODE
>. If asked to explain this in plain language, you might say "Does the string <CODE
CLASS="literal"
>&quot;Fred&quot;</CODE
> contain any <CODE
CLASS="literal"
>x </CODE
>'s?" If so, you might be surprised to learn that it seems to. That's because <CODE
CLASS="literal"
>/x*/</CODE
> doesn't truly mean "any <CODE
CLASS="literal"
>x</CODE
>'s", unless your idea of "any" includes nothing at all. Formally, it means <EM
CLASS="emphasis"
>zero or more</EM
> of them, and in this case, zero sufficed for the eager matcher.</P
><P
CLASS="para"
>A more illustrative example of eagerness would be the following:</P
><PRE
CLASS="programlisting"
>$string = &quot;good food&quot;;
$string =~ s/o*/e/;</PRE
><P
CLASS="para"
>Can you guess which of the following is in <CODE
CLASS="literal"
>$string</CODE
> after that substitution?</P
><PRE
CLASS="programlisting"
><CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>good food</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>geod food</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>geed food</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>geed feed</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>ged food</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>ged fed</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>egood food</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
>The answer is the last one because the earliest point at which zero or more occurrences of <CODE
CLASS="literal"
>&quot;o&quot;</CODE
> could be found was right at the beginning of the string. Surprised? Regular expressions can do that to you.</P
><P
CLASS="para"
>Can you guess what adding <CODE
CLASS="literal"
>/g</CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000007466-0"
></A
> modifier to make the substitution global will do? Think of it this way: that string has many places where zero or more instances of <CODE
CLASS="literal"
>&quot;o&quot;</CODE
> occur &nbsp;-  eight, to be precise. The answer is <CODE
CLASS="literal"
>&quot;egeede</CODE
> <CODE
CLASS="literal"
>efeede&quot;</CODE
>.</P
><P
CLASS="para"
>Here's another example of where greed takes a back seat to eagerness:</P
><PRE
CLASS="programlisting"
>% echo ababacaca | perl -ne 'print &quot;$&amp;\n&quot; if /(a|ba|b)+(a|ac)+/'
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>ababa</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
>That's because Perl uses what's called a traditional NFA,[<A
CLASS="footnote"
HREF="#ch06-pgfId-1000000612"
>2</A
>] a <A
CLASS="indexterm"
NAME="ch06-idx-1000007467-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007467-1"
></A
>non-deterministic finite automaton. This kind of matching engine is not guaranteed to return the longest <EM
CLASS="emphasis"
>overall</EM
> match, just the longest, leftmost match. You might think of Perl's greed as being left-to-right directed, not globally greedy.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch06-pgfId-1000000612"
>[2]</A
> As opposed to a POSIX-style NFA. See <EM
CLASS="emphasis"
>Mastering Regular Expressions</EM
> for the differences.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>But it doesn't have to be that way. Here's an example using <EM
CLASS="emphasis"
>awk</EM
>, a language that Perl borrows a lot from:</P
><PRE
CLASS="programlisting"
>% echo ababacaca | 
    awk 'match($0,/(a|ba|b)+(a|ac)+/) { print substr($0, RSTART, RLENGTH) }'
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>ababacaca</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
>Choosing how to implement pattern matching depends mainly on two factors: are the expressions nonregular (do they use backreferences), and what needs to be returned (yes/no, range of whole match, ranges of subexpressions). Tools like <EM
CLASS="emphasis"
>awk</EM
>, <EM
CLASS="emphasis"
>egrep</EM
>, and <EM
CLASS="emphasis"
>lex</EM
> use regular expressions and only need a yes/no answer or the range of the whole match. This is exactly what <A
CLASS="indexterm"
NAME="ch06-idx-1000008226-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000008226-1"
></A
>DFAs can support, and because DFAs are faster and simpler, these tools have traditionally used DFA implementations. Pattern matching within programs and libraries, such as <EM
CLASS="emphasis"
>ed</EM
>, <EM
CLASS="emphasis"
>regex</EM
>, and <EM
CLASS="emphasis"
>perl</EM
>, is another kettle of fish; typically, we need to support nonregular expressions and we need to know what parts of the string were matched by various parts of the pattern. This is a much harder problem with potentially exponential run times. The natural algorithm for this problem is an NFA, and therein lies both a problem and an opportunity. The problem is that NFAs are slow. The opportunity is that significant performance gains can be made by rewriting the patterns to exploit how the particular NFA implementation runs. This is a major part of Jeffrey Friedl's book, <EM
CLASS="emphasis"
>Mastering Regular Expressions</EM
>.<A
CLASS="indexterm"
NAME="ch06-idx-1000007479-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007479-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007479-2"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007479-3"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007479-4"
></A
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-1000007477-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007477-1"
></A
>The last and most powerful of the three tricky bits in pattern matching is backtracking. For a pattern to match, the entire regular expression must match, not just part of it. So if the beginning of a pattern containing a quantifier succeeds in a way that causes later parts in the pattern to fail, the matching engine backs up and tries to find another match for the beginning part &nbsp;-  that's why it's called backtracking. Essentially, it means that the engine is going to try different possibilities, systematically investigating alternate matches until it finds one that works. In some pattern matching implementations, you keep backtracking in case other submatches make the overall match longer. Perl's matcher doesn't do that; as soon as one possibility works, it uses that &nbsp;-  until and unless something later on in the pattern fails, forcing a backtrack to retry another possible way of matching. This is discussed in <A
CLASS="xref"
HREF="ch06_17.htm"
TITLE="Detecting Duplicate Words"
>Recipe 6.16</A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-chap06_pattern_matching_0"
>Pattern-Matching Modifiers</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-1000010775-0"
></A
>Pattern-matching modifiers are a lot easier to list and learn than the different metacharacters. Here's a brief summary of them:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/i</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Ignore alphabetic case (locale-aware)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/x</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Ignore most whitespace in pattern and permit comments</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/g</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Global &nbsp;-  match/substitute as often as possible</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/gc</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Don't reset search position on failed match</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/s</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Let <CODE
CLASS="literal"
>. </CODE
>match newline; also, ignore deprecated <CODE
CLASS="literal"
>$*</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/m</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Let <CODE
CLASS="literal"
>^ </CODE
>and <CODE
CLASS="literal"
>$</CODE
> match next to embedded <CODE
CLASS="literal"
>\n</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/o</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Compile pattern once only</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/e</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Righthand side of a <CODE
CLASS="literal"
>s/// </CODE
>is code to <CODE
CLASS="literal"
>eval</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>/ee</CODE
></P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Righthand side of a <CODE
CLASS="literal"
>s/// </CODE
>is a string to <CODE
CLASS="literal"
>eval</CODE
>, then run as code, and its return value <CODE
CLASS="literal"
>eval</CODE
>'led again.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><CODE
CLASS="literal"
>/i</CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000010475-0"
></A
> and <CODE
CLASS="literal"
>/g</CODE
> are the most commonly used modifiers. The pattern <CODE
CLASS="literal"
>/ram/i</CODE
> matches <CODE
CLASS="literal"
>&quot;ram&quot;</CODE
>, <CODE
CLASS="literal"
>&quot;RAM&quot;</CODE
>, <CODE
CLASS="literal"
>&quot;Ram&quot;</CODE
>, and so forth. Backreferences will be checked case-insensitively if this modifier is on; see <A
CLASS="xref"
HREF="ch06_17.htm"
TITLE="Detecting Duplicate Words"
>Recipe 6.16</A
> for an example. This comparison can be made aware of the user's current locale settings if the <CODE
CLASS="literal"
>use</CODE
> <CODE
CLASS="literal"
>locale</CODE
> pragma has been invoked. As currently implemented, <CODE
CLASS="literal"
>/i</CODE
> slows down a pattern match because it disables several performance optimizations.</P
><P
CLASS="para"
><CODE
CLASS="literal"
></CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000007495-0"
></A
>The <CODE
CLASS="literal"
>/g</CODE
> modifier is used with <CODE
CLASS="literal"
>s///</CODE
> to replace every match, not just the first one. <CODE
CLASS="literal"
>/g</CODE
> is also used with <CODE
CLASS="literal"
>m//</CODE
> in loops to find (but not replace) every matching occurrence:</P
><PRE
CLASS="programlisting"
>while (m/(\d+)/g) {
    print &quot;Found number $1\n&quot;;
}</PRE
><P
CLASS="para"
>Used in list context, <CODE
CLASS="literal"
>/g</CODE
> pulls out all matches:</P
><PRE
CLASS="programlisting"
>@numbers = m/(\d+)/g;</PRE
><P
CLASS="para"
>That finds only non-overlapping matches. You have to be much sneakier to get overlapping ones by making a zero-width look-ahead with the <CODE
CLASS="literal"
>(?=...)</CODE
> construct. Because it's zero-width, the match engine hasn't advanced at all. Within the look-ahead, capturing parentheses are used to grab the thing anyway. Although we've saved something, Perl notices we haven't made any forward progress on the <CODE
CLASS="literal"
>/g</CODE
> so bumps us forward one character position.</P
><P
CLASS="para"
>This shows the difference:</P
><PRE
CLASS="programlisting"
>$digits = &quot;123456789&quot;;
@nonlap = $digits =~ /(\d\d\d)/g;
@yeslap = $digits =~ /(?=(\d\d\d))/g;
print &quot;Non-overlapping:  @nonlap\n&quot;;
print &quot;Overlapping:      @yeslap\n&quot;;
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Non-overlapping:  123 456 789</I
></CODE
></B
></CODE
>
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>Overlapping:      123 234 345 456 567 678 789</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
><CODE
CLASS="literal"
></CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000007500-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007500-1"
></A
>The <CODE
CLASS="literal"
>/s</CODE
> and <CODE
CLASS="literal"
>/m</CODE
> modifiers are used when matching strings with embedded newlines. <CODE
CLASS="literal"
>/s</CODE
> makes dot match <CODE
CLASS="literal"
>&quot;\n&quot;</CODE
>, something it doesn't normally do; it also makes the match ignore the value of the old, deprecated <CODE
CLASS="literal"
>$*</CODE
> variable. <CODE
CLASS="literal"
>/m</CODE
> makes <CODE
CLASS="literal"
>^</CODE
> and <CODE
CLASS="literal"
>$</CODE
> match after and before <CODE
CLASS="literal"
>&quot;\n&quot;</CODE
> respectively. They are useful with paragraph slurping mode as explained in the introduction to <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="File Contents"
>Chapter 8, <CITE
CLASS="chapter"
>File Contents</CITE
></A
>, and in <A
CLASS="xref"
HREF="ch06_07.htm"
TITLE="Matching Multiple Lines"
>Recipe 6.6</A
>.</P
><P
CLASS="para"
><CODE
CLASS="literal"
></CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000010974-0"
></A
>The <CODE
CLASS="literal"
>/e</CODE
> switch is used so that the right-hand part is run as code and its return value is used as the replacement string. <CODE
CLASS="literal"
>s/(\d+)/sprintf(&quot;%#x&quot;,</CODE
> <CODE
CLASS="literal"
>$1)/ge</CODE
> would convert all numbers into hex, changing, for example, <CODE
CLASS="literal"
>2581</CODE
> into <CODE
CLASS="literal"
>0xb23</CODE
>.</P
><P
CLASS="para"
><CODE
CLASS="literal"
></CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000011003-0"
></A
>Because different countries have different ideas of what constitutes an alphabet, the POSIX standard provides systems (and thus programs) with a standard way of representing alphabets, character set ordering, and so on. Perl gives you access to some of these through the <CODE
CLASS="literal"
>use</CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000008502-0"
></A
> <CODE
CLASS="literal"
>locale</CODE
> pragma; see the <CODE
CLASS="literal"
>perllocale</CODE
> manpage for more information. When <CODE
CLASS="literal"
>use</CODE
> <CODE
CLASS="literal"
>locale</CODE
> is in effect, the <CODE
CLASS="literal"
>\w</CODE
> character class includes accented and other exotic characters. The case-changing <CODE
CLASS="literal"
>\u</CODE
>, <CODE
CLASS="literal"
>\U</CODE
>, <CODE
CLASS="literal"
>\l</CODE
>, and <CODE
CLASS="literal"
>\L</CODE
> (and the corresponding <CODE
CLASS="literal"
>uc</CODE
>, <CODE
CLASS="literal"
>ucfirst</CODE
>, etc. functions) escapes also respect <CODE
CLASS="literal"
>use</CODE
> <CODE
CLASS="literal"
>locale</CODE
>, so <IMG
SRC="../chars/sigma.gif"
ALT="[sigma]"> will be turned into <IMG
SRC="../chars/ssigma.gif"
ALT="[Sigma]"> with <CODE
CLASS="literal"
>\u</CODE
> if the locale says it should. <A
CLASS="indexterm"
NAME="ch06-idx-1000008503-0"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-chap06_special_0"
>Special Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch06-idx-1000007510-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007510-1"
></A
>Perl sets special variables as the result of certain kinds of matches: <CODE
CLASS="literal"
>$1</CODE
>, <CODE
CLASS="literal"
>$2</CODE
>, <CODE
CLASS="literal"
>$3</CODE
>, and so on <EM
CLASS="emphasis"
>ad infinitum</EM
> (Perl doesn't stop at <CODE
CLASS="literal"
>$9</CODE
>) are set when a pattern contains back-references (parentheses around part of the pattern). Each left parenthesis as you read left to right in the pattern begins filling a new, numbered variable. The variable <CODE
CLASS="literal"
>$+</CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000007511-0"
></A
> contains the contents of the last backreference of the last successful match. This helps you tell which of several alternate matches was found (for example, if <CODE
CLASS="literal"
>/(x.*y)|(y.*z)/</CODE
> matches, <CODE
CLASS="literal"
>$+</CODE
> contains whichever of <CODE
CLASS="literal"
>$1</CODE
> or <CODE
CLASS="literal"
>$2</CODE
> got filled). <CODE
CLASS="literal"
>$&amp;</CODE
> contains the complete text matched in the last successful pattern match. <CODE
CLASS="literal"
>$'</CODE
><A
CLASS="indexterm"
NAME="ch06-idx-1000007512-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007512-1"
></A
> and <CODE
CLASS="literal"
>$`</CODE
> are the strings before and after the successful match, respectively:</P
><PRE
CLASS="programlisting"
>$string = &quot;And little lambs eat ivy&quot;;
$string =~ /l[^s]*s/;
print &quot;<CODE
CLASS="literal"
>($`)</CODE
> ($&amp;) <CODE
CLASS="literal"
>($')\n</CODE
>&quot;;
<CODE
CLASS="userinput"
><B
><CODE
CLASS="replaceable"
><I
>(And ) (little lambs) ( eat ivy)</I
></CODE
></B
></CODE
></PRE
><P
CLASS="para"
><CODE
CLASS="literal"
>$`</CODE
>, <CODE
CLASS="literal"
>$&amp;</CODE
>, and <CODE
CLASS="literal"
>$'</CODE
> are tempting, but dangerous. Their very presence anywhere in a program slows down every pattern match because the engine must populate these variables for every match. This is true even if you use one of these variables only once, or, for that matter, if you never actually use them at all but merely mention them. As of release 5.005, <CODE
CLASS="literal"
>$&amp;</CODE
> is no longer as expensive.</P
><P
CLASS="para"
>All this power may make patterns seem omnipotent. Surprisingly enough, this is not (quite) the case. Regular expressions are fundamentally incapable of doing some things. For some of those, special modules lend a hand. Regular expressions are unable to deal with balanced input, that is, anything that's arbitrarily nested, like matching parentheses, matching HTML tags, etc. For that, you have to build up a real parser, like the HTML::Parser recipes in <A
CLASS="xref"
HREF="ch20_01.htm"
TITLE="Web Automation"
>Chapter 20, <CITE
CLASS="chapter"
>Web Automation</CITE
></A
>. Another thing Perl patterns can't do yet is fuzzy matches; <A
CLASS="xref"
HREF="ch06_14.htm"
TITLE="Approximate Matching"
>Recipe 6.13</A
> shows how to use a module to work around that.</P
><P
CLASS="para"
>To learn far more about regular expressions than you ever thought existed, check out <EM
CLASS="emphasis"
>Mastering Regular Expressions</EM
>, written by Jeffrey Friedl and published by O'Reilly &amp; Associates. This book is dedicated to explaining regular expressions from a practical perspective. It not only covers general regular expressions and Perl patterns well, it also compares and contrasts these with those used in other popular languages.</P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch05_17.htm"
TITLE="5.16. Program: dutree"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.16. Program: dutree"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch06_02.htm"
TITLE="6.1. Copying and Substituting Simultaneously"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.1. Copying and Substituting Simultaneously"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
>5.16. Program: dutree</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="index"
HREF="index/index.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
>6.1. Copying and Substituting Simultaneously</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><FONT
SIZE="-1"
></DIV<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="../prog/index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm"></map> </BODY
></HTML
>
