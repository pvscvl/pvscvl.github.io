<HTML
><HEAD
>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:42:10Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Perl Cookbook"><LINK
REL="prev"
HREF="ch12_20.htm"
TITLE="12.19. Program: Finding Versions and Descriptions of Installed Modules"><LINK
REL="next"
HREF="ch13_02.htm"
TITLE="13.1. Constructing an Object"></HEAD
><BODY
BGCOLOR="#FFFFFF"><img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Perl Cookbook"><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map><div class="navbar"><p>
<TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch12_20.htm"
TITLE="12.19. Program: Finding Versions and Descriptions of Installed Modules"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 12.19. Program: Finding Versions and Descriptions of Installed Modules"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch13_02.htm"
TITLE="13.1. Constructing an Object"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 13.1. Constructing an Object"
BORDER="0"></A
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch13-15948"
>13. Classes, Objects, and Ties</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch13-31898"
TITLE="13.0. Introduction"
>Introduction</A
><BR><A
CLASS="sect1"
HREF="ch13_02.htm"
TITLE="13.1. Constructing an Object"
>Constructing an Object</A
><BR><A
CLASS="sect1"
HREF="ch13_03.htm"
TITLE="13.2. Destroying an Object"
>Destroying an Object</A
><BR><A
CLASS="sect1"
HREF="ch13_04.htm"
TITLE="13.3. Managing Instance Data"
>Managing Instance Data</A
><BR><A
CLASS="sect1"
HREF="ch13_05.htm"
TITLE="13.4. Managing Class Data"
>Managing Class Data</A
><BR><A
CLASS="sect1"
HREF="ch13_06.htm"
TITLE="13.5. Using Classes as Structs"
>Using Classes as Structs</A
><BR><A
CLASS="sect1"
HREF="ch13_07.htm"
TITLE="13.6. Cloning Objects"
>Cloning Objects</A
><BR><A
CLASS="sect1"
HREF="ch13_08.htm"
TITLE="13.7. Calling Methods Indirectly"
>Calling Methods Indirectly</A
><BR><A
CLASS="sect1"
HREF="ch13_09.htm"
TITLE="13.8. Determining Subclass Membership"
>Determining Subclass Membership</A
><BR><A
CLASS="sect1"
HREF="ch13_10.htm"
TITLE="13.9. Writing an Inheritable Class"
>Writing an Inheritable Class</A
><BR><A
CLASS="sect1"
HREF="ch13_11.htm"
TITLE="13.10. Accessing Overridden Methods"
>Accessing Overridden Methods</A
><BR><A
CLASS="sect1"
HREF="ch13_12.htm"
TITLE="13.11. Generating Attribute Methods Using AUTOLOAD"
>Generating Attribute Methods Using AUTOLOAD</A
><BR><A
CLASS="sect1"
HREF="ch13_13.htm"
TITLE="13.12. Solving the Data Inheritance Problem"
>Solving the Data Inheritance Problem</A
><BR><A
CLASS="sect1"
HREF="ch13_14.htm"
TITLE="13.13. Coping with Circular Data Structures"
>Coping with Circular Data Structures</A
><BR><A
CLASS="sect1"
HREF="ch13_15.htm"
TITLE="13.14. Overloading Operators"
>Overloading Operators</A
><BR><A
CLASS="sect1"
HREF="ch13_16.htm"
TITLE="13.15. Creating Magic Variables with tie"
>Creating Magic Variables with tie</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>All the world over, I will back the masses against the classes.</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;William E. Gladstone <CITE
CLASS="citetitle"
>Speech at Liverpool, 28 June 1886 </CITE
></P
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch13-31898"
>13.0. Introduction</A
></H2
><P
CLASS="para"
>Along with references and modules, release 5.000 of Perl added objects. As usual, Perl doesn't try to enforce one true style but embraces many. This helps more people do their job the way they want to do it.</P
><P
CLASS="para"
>You don't have to use objects to write programs, unlike Java, where programs are instances of objects. If you want to, though, you can write Perl programs that use nearly every weapon in the object-oriented arsenal. Perl supports classes and objects, single and multiple inheritance, instance methods and class methods, access to overridden methods, constructors and destructors, operator overloading, proxy methods through autoloading, delegation, a rooted hierarchy for all objects, and two levels of garbage collection.</P
><P
CLASS="para"
>You can use as many or as few object-oriented techniques as you want and need. Ties are the only parts of Perl where you must use object orientation. And even then, only the module implementor need be aware of this; the casual user gets to remain blissfully unaware of the internal mechanics. Ties, discussed in <A
CLASS="xref"
HREF="ch13_16.htm"
TITLE="Creating Magic Variables with tie"
>Recipe 13.15</A
>, let you transparently intercept access to a variable. For example, you can use ties to make a hash that allows lookups by key or value.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-chap13_under_0"
>Under the Hood</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-1000004418-0"
></A
>If you ask ten people what object orientation is, you'll get ten different answers. People bandy about terms like abstraction and encapsulation, trying to isolate the basic units of object-oriented programming languages and give them big names to write papers and books about. Not all object-oriented languages offer the same features, yet they are still deemed object-oriented. This, of course, produces more papers and books.</P
><P
CLASS="para"
>We'll follow the nomenclature used in Perl's documentation, the <I
CLASS="filename"
>perlobj </I
>(1) manpage, and Chapter 5 of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>, "Libraries, Modules, and Classes." An <EM
CLASS="emphasis"
>object</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004419-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004419-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004419-2"
></A
> is a variable that belongs to a <EM
CLASS="emphasis"
>class</EM
>. <EM
CLASS="emphasis"
>Methods</EM
> are functions associated with a class or object. In Perl, a class is a package  &nbsp;-   and usually a module. An object is a reference to something that's been <EM
CLASS="emphasis"
>blessed</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004420-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004420-1"
></A
> into a class. Blessing associates a referent with a class. This is done with the <CODE
CLASS="literal"
>bless</CODE
> function, which takes one or two arguments. The first is a reference to the thing to bless, and the optional second argument is the package to bless it into.</P
><PRE
CLASS="programlisting"
>$object = {};                       # hash reference
bless($object, &quot;Data::Encoder&quot;);    # bless $object into Data::Encoder class
bless($object);                     # bless $object into current package</PRE
><P
CLASS="para"
>The class name is the package name (<CODE
CLASS="literal"
>Data::Encoder</CODE
> in the example above). Because classes are modules (usually), the code for the <CODE
CLASS="literal"
>Data::Encoder</CODE
> class resides in the file <EM
CLASS="emphasis"
>Data/Encoder.pm</EM
>. As with traditional modules, the directory structure is purely for convenience; it implies nothing about inheritance, variable sharing, or anything else. Unlike a traditional module, though, an object module seldom if ever uses the Exporter. Access should be through method calls only, not imported functions or variables.</P
><P
CLASS="para"
>Once an object has been blessed, calling the <CODE
CLASS="literal"
>ref</CODE
><A
CLASS="indexterm"
NAME="ch13-idx-1000004421-0"
></A
> function on its reference returns the name of its class instead of the fundamental type of referent:</P
><PRE
CLASS="programlisting"
>$obj = [3,5];
print ref($obj), &quot; &quot;, $obj-&gt;[1], &quot;\n&quot;;
bless($obj, &quot;Human::Cannibal&quot;);
print ref($obj), &quot; &quot;, $obj-&gt;[1], &quot;\n&quot;;

<B
CLASS="emphasis.bold"
>ARRAY 5</B
>
<B
CLASS="emphasis.bold"
>Human::Cannibal 5</B
></PRE
><P
CLASS="para"
>As you can see, you can still dereference a reference once it has been blessed. Most frequently, objects are implemented as blessed hash references. You may use any kind of reference you want, but hash references are the most flexible. They let you have arbitrarily named data fields in an object.</P
><PRE
CLASS="programlisting"
>$obj-&gt;{Stomach} = &quot;Empty&quot;;   # directly accessing an object's contents
$obj-&gt;{NAME}    = &quot;Thag&quot;;        # uppercase field name to make it stand out (optional)</PRE
><P
CLASS="para"
>Although Perl permits it, it's considered poor form for any code outside the class to directly access the contents of an object. The point of objects, everyone agrees, is to give you a nominally opaque handle to <EM
CLASS="emphasis"
>something</EM
> that you access through designated methods only. This lets the maintainer of the class change its implementation without needing to change all application code that uses the class.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-chap13_methods_0"
>Methods</A
></H3
><P
CLASS="para"
>To call a method, use <CODE
CLASS="literal"
>-&gt;</CODE
><A
CLASS="indexterm"
NAME="ch13-idx-1000004426-0"
></A
>. Here, we call the <CODE
CLASS="literal"
>encode()</CODE
> method of <CODE
CLASS="literal"
>$object</CODE
> with the argument <CODE
CLASS="literal"
>&quot;data&quot;</CODE
> and store the return value in <CODE
CLASS="literal"
>$encoded </CODE
>:</P
><PRE
CLASS="programlisting"
>$encoded = $object-&gt;encode(&quot;data&quot;);</PRE
><P
CLASS="para"
>This is an <EM
CLASS="emphasis"
>object method</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004427-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004427-1"
></A
>, because we call the method on an object. We can also have <EM
CLASS="emphasis"
>class methods</EM
>, methods called on class names.</P
><PRE
CLASS="programlisting"
>$encoded = Data::Encoder-&gt;encode(&quot;data&quot;);</PRE
><P
CLASS="para"
>Invoking a method calls the function in the corresponding class, implicitly passing as the initial argument either a reference for object methods or a string for class methods. <A
CLASS="xref"
HREF="ch13_08.htm"
TITLE="Calling Methods Indirectly"
>Recipe 13.7</A
> shows how to make method calls where the method is determined at runtime.</P
><P
CLASS="para"
>Most classes provide <EM
CLASS="emphasis"
>constructor</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004428-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004428-1"
></A
> methods, which return new objects. Unlike some object-oriented languages, constructor methods in Perl are not specially named. In fact, you can name them anything you like. C++ programmers have a penchant for calling their constructors in Perl <CODE
CLASS="literal"
>new</CODE
><A
CLASS="indexterm"
NAME="ch13-idx-1000004429-0"
></A
>. We recommend that you name your constructors whatever makes sense in the context of the problem you're solving. For example, constructors in the Tk extension to Perl are named after the widgets they create. A less common approach is to export a function with the same name as the class; see <A
CLASS="xref"
HREF="ch13_15.htm"
TITLE="Example: Overloaded StrNum Class"
>"Example: Overloaded StrNum Class</A
>" in <A
CLASS="xref"
HREF="ch13_15.htm"
TITLE="Overloading Operators"
>Recipe 13.14</A
> for an example.</P
><P
CLASS="para"
>A typical constructor looks like this:</P
><PRE
CLASS="programlisting"
>sub new {
    my $class = shift;
    my $self  = {};         # allocate new hash for object
    bless($self, $class);
    return $self;
}</PRE
><P
CLASS="para"
>Call the constructor with:</P
><PRE
CLASS="programlisting"
>$object = Class-&gt;new();</PRE
><P
CLASS="para"
>If there isn't any inheritance or other monkey business working behind the scenes, this is effectively the same as:</P
><PRE
CLASS="programlisting"
>$object = Class::new(&quot;Class&quot;);</PRE
><P
CLASS="para"
>The <CODE
CLASS="literal"
>new()</CODE
> function's first argument here is the class name to bless the new reference into. A constructor should pass that string as the second argument to <CODE
CLASS="literal"
>bless()</CODE
>.</P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch13_02.htm"
TITLE="Constructing an Object"
>Recipe 13.1</A
> also talks about functions that return blessed references. Constructors don't have to be class methods, and writing object methods that return new objects have a number of uses, as discussed in <A
CLASS="xref"
HREF="ch13_07.htm"
TITLE="Cloning Objects"
>Recipe 13.6</A
>.</P
><P
CLASS="para"
>A <EM
CLASS="emphasis"
>destructor</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004430-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004430-1"
></A
> is a subroutine that runs when an object's referent is garbage collected. Unlike constructors, you have no choice in naming it. You must name your destructor method <CODE
CLASS="literal"
>DESTROY</CODE
>. This method, if it exists, will be called for all objects immediately prior to memory deallocation. Destructors, described in <A
CLASS="xref"
HREF="ch13_03.htm"
TITLE="Destroying an Object"
>Recipe 13.2</A
>, are optional.</P
><P
CLASS="para"
>Some languages syntactically allow the compiler to restrict access to a class's methods. Perl does not  &nbsp;-   it allows code to call any method of an object. The author of a class should document clearly the <EM
CLASS="emphasis"
>public</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004431-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004431-1"
></A
> methods (those which may be used), and the user of a class should avoid undocumented (implicitly <EM
CLASS="emphasis"
>private</EM
>) methods.</P
><P
CLASS="para"
>Perl doesn't distinguish between methods that can be called on a class (<EM
CLASS="emphasis"
>class methods</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004432-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004432-1"
></A
>) and methods that can be called on an object (<EM
CLASS="emphasis"
>instance methods</EM
>). If you want a particular method to be called as a class method only, do something like this:</P
><PRE
CLASS="programlisting"
>sub class_only_method {
    my $class = shift;
    die &quot;class method called on object&quot; if ref $class;
    # more code here
} </PRE
><P
CLASS="para"
>If you want to allow a particular method to be called as an instance method only, do something like this:</P
><PRE
CLASS="programlisting"
>sub instance_only_method {
    my $self = shift;
    die &quot;instance method called on class&quot; unless ref $self;
    # more code here
} </PRE
><P
CLASS="para"
>If your code calls an undefined method on an object, Perl won't complain at compile time; the program will instead trigger an exception at run time. Likewise, the compiler can't catch situations where you pass a non-prime value to a method expecting a prime number. Methods are just function calls whose package is determined at run time. Like all indirect functions, they have no <A
CLASS="indexterm"
NAME="ch13-idx-1000004434-0"
></A
>prototype checking &nbsp;-   because that happens at compile time. Even if method calls were aware of prototypes, in Perl the compiler is unable to automatically check the precise types or ranges of arguments to functions. Perl prototypes are used to <EM
CLASS="emphasis"
>coerce</EM
> a function argument's context, not to check ranges. <A
CLASS="xref"
HREF="ch10_12.htm"
TITLE="Prototyping Functions"
>Recipe 10.11</A
> details Perl's strange perspective on prototypes.</P
><P
CLASS="para"
>You can prevent Perl from triggering an exception for undefined methods by using the <A
CLASS="indexterm"
NAME="ch13-idx-1000004588-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004588-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004588-2"
></A
>AUTOLOAD mechanism to catch calls to nonexistent methods. We show an application of this in <A
CLASS="xref"
HREF="ch13_12.htm"
TITLE="Generating Attribute Methods Using AUTOLOAD"
>Recipe 13.11</A
>.<A
CLASS="indexterm"
NAME="ch13-idx-1000004423-0"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-chap13_inheritance_0"
>Inheritance</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-1000004436-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004436-1"
></A
>Inheritance defines a hierarchy of classes. Calls to methods not defined in a class search this hierarchy for a method of that name. The first method found is used. Inheritance means allowing one class to piggy-back on top of another so you don't have to write the same code again and again. This is a form of software reuse, and therefore related to Laziness, the principal virtue of a programmer.</P
><P
CLASS="para"
>Some languages provide special syntax for inheritance. In Perl, each class (package) can put its list of <EM
CLASS="emphasis"
>superclasses</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004437-0"
></A
> (parents in the hierarchy) into the package global (not a <CODE
CLASS="literal"
>my</CODE
>) variable <CODE
CLASS="literal"
>@ISA</CODE
><A
CLASS="indexterm"
NAME="ch13-idx-1000004438-0"
></A
>. This list is searched at runtime when a call is made to a method not defined in the object's class. If the first package listed in <CODE
CLASS="literal"
>@ISA</CODE
> doesn't have the method but that package has its own <CODE
CLASS="literal"
>@ISA</CODE
>, Perl looks first in <EM
CLASS="emphasis"
>that</EM
> package's own <CODE
CLASS="literal"
>@ISA</CODE
>, recursively, before going on.</P
><P
CLASS="para"
>If the inheritance search fails, the same check is run again, this time looking for a method named <CODE
CLASS="literal"
>AUTOLOAD</CODE
>. The lookup sequence for <CODE
CLASS="literal"
>$ob-&gt;meth()</CODE
>, where <CODE
CLASS="literal"
>$ob</CODE
> is of class P, is:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-179"
></A
>P::meth</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-181"
></A
>All packages S in <CODE
CLASS="literal"
>@P::ISA</CODE
>, recursively, for any <CODE
CLASS="literal"
>S::meth()</CODE
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-183"
></A
>UNIVERSAL::meth</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-185"
></A
>The <CODE
CLASS="literal"
>P::AUTOLOAD</CODE
> subroutine</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-187"
></A
>All packages S in <CODE
CLASS="literal"
>@P::ISA</CODE
>, recursively, for any <CODE
CLASS="literal"
>S::AUTOLOAD()</CODE
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="listitem"
NAME="ch13-pgfId-189"
></A
>The <CODE
CLASS="literal"
>UNIVERSAL::AUTOLOAD</CODE
> subroutine</P
></LI
></UL
><P
CLASS="para"
>Most classes have just one item in their <CODE
CLASS="literal"
>@ISA</CODE
> array, a situation called <EM
CLASS="emphasis"
>single inheritance</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004439-0"
></A
>. Classes with more than one element in <CODE
CLASS="literal"
>@ISA</CODE
> represent <EM
CLASS="emphasis"
>multiple inheritance</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004440-0"
></A
>. The benefits of multiple inheritance are widely contested, but it is supported by Perl.</P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch13_10.htm"
TITLE="Writing an Inheritable Class"
>Recipe 13.9</A
> talks about the basics of inheritance and designing a class so it can be easily subclassed. In <A
CLASS="xref"
HREF="ch13_11.htm"
TITLE="Accessing Overridden Methods"
>Recipe 13.10</A
> we show how a subclass can call overridden methods in its superclasses.</P
><P
CLASS="para"
>Perl doesn't support inheritance of data values. A class can, but should not, touch another's data directly. This violates the envelope and ruins the abstraction. If you follow the advice in Recipes <A
CLASS="xref"
HREF="ch13_11.htm"
TITLE="Accessing Overridden Methods"
>Recipe 13.10</A
> and <A
CLASS="xref"
HREF="ch13_13.htm"
TITLE="Solving the Data Inheritance Problem"
>Recipe 13.12</A
>, this won't be much of an issue.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-chap13_a_0"
>A Warning on Indirect Object Notation</A
></H3
><P
CLASS="para"
>The <EM
CLASS="emphasis"
>indirect</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004441-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004441-1"
></A
> notation for method calls:</P
><PRE
CLASS="programlisting"
>$lector = new Human::Cannibal;
feed $lector &quot;Zak&quot;;
move $lector &quot;New York&quot;;</PRE
><P
CLASS="para"
>is an alternative syntax for:</P
><PRE
CLASS="programlisting"
>$lector = Human::Cannibal-&gt;<CODE
CLASS="literal"
>new();</CODE
>
$lector-&gt;feed(&quot;Zak&quot;);
$lector-&gt;move(&quot;New York&quot;);</PRE
><P
CLASS="para"
>This indirect object notation is appealing to English speakers and familiar to C++ programmers (who use <CODE
CLASS="literal"
>new</CODE
> this way). Do not be seduced. It has two grave problems. One is that it follows the same quirky rules as the filehandle slot in <CODE
CLASS="literal"
>print</CODE
> and <CODE
CLASS="literal"
>printf</CODE
>:</P
><PRE
CLASS="programlisting"
>printf STDERR &quot;stuff here\n&quot;;</PRE
><P
CLASS="para"
>This slot, if filled, must contain a bare symbol, a block, or a scalar variable name; it can't be any old scalar expression. This can lead to horribly confusing precedence problems, as in these next two lines:</P
><PRE
CLASS="programlisting"
>move $obj-&gt;{FIELD};                 # probably wrong
move $ary[$i];                      # probably wrong</PRE
><P
CLASS="para"
>Surprisingly, those actually parse as:</P
><PRE
CLASS="programlisting"
>$obj-&gt;move-&gt;{FIELD};                # Surprise!
$ary-&gt;move-&gt;[$i];                   # Surprise!</PRE
><P
CLASS="para"
>rather than as you might have expected:</P
><PRE
CLASS="programlisting"
>$obj-&gt;{FIELD}-&gt;<CODE
CLASS="literal"
>move()</CODE
>;              # Nope, you wish
$ary[$i]-&gt;<CODE
CLASS="literal"
>move;</CODE
>                     # Nope, you wish</PRE
><P
CLASS="para"
>The second problem is that Perl must guess at compile time whether <CODE
CLASS="literal"
>name</CODE
> and <CODE
CLASS="literal"
>move</CODE
> are functions or methods. Usually Perl gets it right, but when it doesn't, you get a function call compiled as a method, or vice versa. This can introduce incredibly subtle bugs that are hard to unravel. The infix arrow notation using <CODE
CLASS="literal"
>-&gt;</CODE
> doesn't suffer from either of these disturbing ambiguities, so we recommend you use it exclusively.<EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004443-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004443-1"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-chap13_some_0"
>Some Notes on Object Terminology</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch13-idx-1000004451-0"
></A
>In the object-oriented world, many words describe only a few concepts. If you've programmed in another object-oriented language, you might like to know how familiar terms and concepts map onto Perl.</P
><P
CLASS="para"
>For example, it's common to call objects <EM
CLASS="emphasis"
>instances</EM
> of a class and those objects' methods <EM
CLASS="emphasis"
>instance methods</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004457-0"
></A
>. Data fields peculiar to each object are often called <EM
CLASS="emphasis"
>instance data</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004458-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004458-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004458-2"
></A
> or <EM
CLASS="emphasis"
>object attributes</EM
>, and data fields common to all members of that class are <EM
CLASS="emphasis"
>class data</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004459-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004459-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004459-2"
></A
>, <EM
CLASS="emphasis"
>class attributes</EM
>, or <EM
CLASS="emphasis"
>static data members</EM
>.</P
><P
CLASS="para"
>Also, <EM
CLASS="emphasis"
>base class</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004460-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004460-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004460-2"
></A
>, <EM
CLASS="emphasis"
>generic class</EM
>, and <EM
CLASS="emphasis"
>superclass</EM
> all describe the same notion (a parent or similar ancestor in the inheritance hierarchy), whereas <EM
CLASS="emphasis"
>derived class</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004461-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004461-1"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004461-2"
></A
>, <EM
CLASS="emphasis"
>specific class</EM
>, and <EM
CLASS="emphasis"
>subclass</EM
> describe the opposite relationship (a child or descendent in the inheritance hierarchy).</P
><P
CLASS="para"
>C++ programmers have <EM
CLASS="emphasis"
>static methods</EM
>, <EM
CLASS="emphasis"
>virtual methods</EM
>, and <EM
CLASS="emphasis"
>instance methods</EM
>, but Perl only has <EM
CLASS="emphasis"
>class methods</EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004462-0"
></A
><A
CLASS="indexterm"
NAME="ch13-idx-1000004462-1"
></A
> and <EM
CLASS="emphasis"
>object methods</EM
>. Actually, Perl only has methods. Whether a method acts as a class or object method is determined solely by actual usage. You could call a class method (one expecting a string argument) on an object (one expecting a reference), or vice versa, but you shouldn't expect reasonable results if you do.</P
><P
CLASS="para"
>A C++ programmer thinks about global (class) constructors and destructors. These correspond to module initialization code and per-module <CODE
CLASS="literal"
>END{}</CODE
> blocks respectively.</P
><P
CLASS="para"
>From the C++ perspective, all methods in Perl are virtual. This is why their arguments are never checked for function prototypes as regular built-in and user-defined functions can be. Prototypes are checked by the compiler at compile time. You can't determine until run time the function that a method has called.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-chap13_philosophical_0"
>Philosophical Aside</A
></H3
><P
CLASS="para"
>In its OO programming, Perl gives you a lot of freedom: the ability to do things more than one way (you can bless any data type to make an object), to inspect and modify classes you didn't write (adding functions to their packages), and to use these to write tangled pits of misery  &nbsp;-   if that's really what you want to do.</P
><P
CLASS="para"
>Less flexible programming languages are usually more restrictive. Many are fanatically devoted to enforced privacy, compile-time type checking, complex function signatures, and a smorgasbord of other features. Perl doesn't provide these things with objects because it doesn't provide them anywhere else, either. Keep this in mind if you find Perl's object-oriented implementation weird. You only think it's weird because you're used to another language's philosophy. Perl's treatment of OO is perfectly sensible  &nbsp;-   if you think in Perl. For every problem that you can't solve by writing Perl as though it were Java or C++, there is a native Perl solution that works perfectly. The absolutely paranoid programmer can even have complete privacy: the <I
CLASS="filename"
>perltoot </I
>(1) manpage describes how to bless closures to produce objects that are as private as those in C++ (and more so).</P
><P
CLASS="para"
>Perl's objects are not wrong; they're differently right.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch13-chap13_suggested_0"
>See Also</A
></H3
><P
CLASS="para"
>The general literature on object-oriented programming rarely refers directly to Perl. The documentation that came with Perl is a good place to begin learning about object-oriented programming, particularly the object tutorial <I
CLASS="filename"
>perltoot </I
>(1). For a reference, read <I
CLASS="filename"
>perlobj </I
>(1) and Chapter 5 of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>. You might need it when you read <I
CLASS="filename"
>perlbot</I
> (1), which is full of object-oriented tricks.</P
><P
CLASS="para"
>Chapters <A
CLASS="olink"
HREF="../advprog/ch07_01.htm"
>7</A
> and <A
CLASS="olink"
HREF="../advprog/ch08_01.htm"
>8</A
> of <EM
CLASS="emphasis"
>Advanced Perl Programming </EM
>includes a discussion of object-oriented programming in Perl for those who have encountered objects before.<EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch13-idx-1000004453-0"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch12_20.htm"
TITLE="12.19. Program: Finding Versions and Descriptions of Installed Modules"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 12.19. Program: Finding Versions and Descriptions of Installed Modules"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch13_02.htm"
TITLE="13.1. Constructing an Object"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 13.1. Constructing an Object"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
>12.19. Program: Finding Versions and Descriptions of Installed Modules</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="index"
HREF="index/index.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
>13.1. Constructing an Object</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><FONT
SIZE="-1"
></DIV<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="../prog/index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm"></map> </BODY
></HTML
>
