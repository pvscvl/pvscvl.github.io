<HTML
><HEAD
>
<TITLE>Recipe 6.7. Reading Records with a Pattern Separator (Perl Cookbook)</TITLE>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:34:06Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. Pattern Matching"><LINK
REL="prev"
HREF="ch06_07.htm"
TITLE="6.6. Matching Multiple Lines"><LINK
REL="next"
HREF="ch06_09.htm"
TITLE="6.8. Extracting a Range of Lines"></HEAD
><BODY
BGCOLOR="#FFFFFF"><img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Perl Cookbook"><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map><div class="navbar"><p>
<TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch06_07.htm"
TITLE="6.6. Matching Multiple Lines"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.6. Matching Multiple Lines"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch06_01.htm"
TITLE="6. Pattern Matching"
></A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch06_09.htm"
TITLE="6.8. Extracting a Range of Lines"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.8. Extracting a Range of Lines"
BORDER="0"></A
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch06-chap06_reading_0"
>6.7. Reading Records with a Pattern Separator</A
></H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-pgfId-865"
>Problem <A
CLASS="indexterm"
NAME="ch06-idx-1000007592-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007592-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007592-2"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007592-3"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007592-4"
></A
></A
></H3
><P
CLASS="para"
>You want to read in records separated by a pattern, but Perl doesn't allow its input record separator variable to be a regular expression.</P
><P
CLASS="para"
>Many problems, most obviously those involving the parsing of complex file formats, become a lot simpler when you are easily able to extract records that might be separated by a number of different strings.<A
CLASS="indexterm"
NAME="ch06-idx-1000007766-0"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-pgfId-873"
>Solution</A
></H3
><P
CLASS="para"
>Read the whole file and use <CODE
CLASS="literal"
>split</CODE
>: <A
CLASS="indexterm"
NAME="ch06-idx-1000007598-0"
></A
></P
><PRE
CLASS="programlisting"
>undef $/;
@chunks = split(/pattern/, &lt;FILEHANDLE&gt;);</PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-pgfId-883"
>Discussion</A
></H3
><P
CLASS="para"
>Perl's record separator must be a fixed string, not a pattern. (After all, <EM
CLASS="emphasis"
>awk</EM
> has to be better at <EM
CLASS="emphasis"
>something</EM
>.) To sidestep this limitation, undefine the input record separator entirely so that the next line-read operation gets the rest of the file. This is sometimes called <I
CLASS="firstterm"
>slurp</I
> mode, because it slurps in the whole file as one big string. Then <CODE
CLASS="literal"
>split</CODE
> that huge string using the record separating pattern as the first argument.</P
><P
CLASS="para"
>Here's an example, where the input stream is a text file that includes lines consisting of <CODE
CLASS="literal"
>&quot;.Se&quot;</CODE
>, <CODE
CLASS="literal"
>&quot;.Ch&quot;</CODE
>, and <CODE
CLASS="literal"
>&quot;.Ss&quot;</CODE
>, which are special codes in the <EM
CLASS="emphasis"
>troff</EM
> macro set that this book was developed under. These lines are the separators, and we want to find text that falls between them.</P
><PRE
CLASS="programlisting"
># .Ch, .Se and .Ss divide chunks of STDIN
{
    local $/ = undef;
    @chunks = split(/^\.(Ch|Se|Ss)$/m, &lt;&gt;);
}
print &quot;I read &quot;, scalar(@chunks), &quot; chunks.\n&quot;;</PRE
><P
CLASS="para"
>We create a localized version of <CODE
CLASS="literal"
>$/</CODE
> so its previous value gets restored after the block finishes. By using <CODE
CLASS="literal"
>split</CODE
> with parentheses in the pattern, captured separators are also returned. This way the data elements in the return list alternate with elements containing <CODE
CLASS="literal"
>&quot;Se&quot;</CODE
>, <CODE
CLASS="literal"
>&quot;Ch&quot;</CODE
>, or <CODE
CLASS="literal"
>&quot;Ss&quot;</CODE
>.</P
><P
CLASS="para"
>If you didn't want delimiters returned but still needed parentheses, you could use non-capturing parentheses in the pattern: <CODE
CLASS="literal"
>/^\.(?:Ch|Se|Ss)$/m </CODE
>.</P
><P
CLASS="para"
>If you just want to split <EM
CLASS="emphasis"
>before</EM
> a pattern but include the pattern in the return, use a look-ahead assertion: <CODE
CLASS="literal"
>/^(?=\.(?:Ch|Se|Ss))/m </CODE
>. That way each chunk starts with the pattern.</P
><P
CLASS="para"
>Be aware that this uses a lot of memory if the file is large. However, with today's machines and your typical text files, this is less often an issue now than it once was. Just don't try it on a 200-MB logfile unless you have plenty of virtual memory to use to swap out to disk with! Even if you do have enough swap space, you'll likely end up thrashing.<A
CLASS="indexterm"
NAME="ch06-idx-1000007594-0"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007594-1"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007594-2"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007594-3"
></A
><A
CLASS="indexterm"
NAME="ch06-idx-1000007594-4"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch06-pgfId-911"
>See Also</A
></H3
><P
CLASS="para"
>The <CODE
CLASS="literal"
>$/</CODE
> variable in <I
CLASS="filename"
>perlvar  </I
>(1) and in the <A
CLASS="olink"
HREF="../prog/ch02_09.htm"
>"Special Variables"</A
> section of <A
CLASS="olink"
HREF="../prog/ch02_01.htm"
>Chapter 2</A
> of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>; the <CODE
CLASS="literal"
>split</CODE
> function in <I
CLASS="filename"
>perlfunc </I
>(1) and <A
CLASS="olink"
HREF="../prog/ch03_01.htm"
>Chapter 3</A
> of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>; we talk more about the special variable <CODE
CLASS="literal"
>$/</CODE
> in <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="File Contents"
>Chapter 8</A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch06_07.htm"
TITLE="6.6. Matching Multiple Lines"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.6. Matching Multiple Lines"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch06_09.htm"
TITLE="6.8. Extracting a Range of Lines"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.8. Extracting a Range of Lines"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
>6.6. Matching Multiple Lines</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="index"
HREF="index/index.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
>6.8. Extracting a Range of Lines</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><FONT
SIZE="-1"
></DIV<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="../prog/index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm"></map> </BODY
></HTML
>
