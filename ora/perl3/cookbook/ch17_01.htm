<HTML
><HEAD
>
<META
NAME="DC.title"
CONTENT="Perl Cookbook"><META
NAME="DC.creator"
CONTENT="Tom Christiansen &amp; Nathan Torkington"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:44:20Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-243-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Perl Cookbook"><LINK
REL="prev"
HREF="ch16_23.htm"
TITLE="16.22. Program: sigrand"><LINK
REL="next"
HREF="ch17_02.htm"
TITLE="17.1. Writing a TCP Client"></HEAD
><BODY
BGCOLOR="#FFFFFF"><img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Perl Cookbook"><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map><div class="navbar"><p>
<TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch16_23.htm"
TITLE="16.22. Program: sigrand"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 16.22. Program: sigrand"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch17_02.htm"
TITLE="17.1. Writing a TCP Client"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 17.1. Writing a TCP Client"
BORDER="0"></A
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="chapter"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="ch17-14176"
>17. Sockets</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#ch17-35785"
TITLE="17.0. Introduction"
>Introduction</A
><BR><A
CLASS="sect1"
HREF="ch17_02.htm"
TITLE="17.1. Writing a TCP Client"
>Writing a TCP Client</A
><BR><A
CLASS="sect1"
HREF="ch17_03.htm"
TITLE="17.2. Writing a TCP Server"
>Writing a TCP Server</A
><BR><A
CLASS="sect1"
HREF="ch17_04.htm"
TITLE="17.3. Communicating over TCP"
>Communicating over TCP</A
><BR><A
CLASS="sect1"
HREF="ch17_05.htm"
TITLE="17.4. Setting Up a UDP Client"
>Setting Up a UDP Client</A
><BR><A
CLASS="sect1"
HREF="ch17_06.htm"
TITLE="17.5. Setting Up a UDP Server"
>Setting Up a UDP Server</A
><BR><A
CLASS="sect1"
HREF="ch17_07.htm"
TITLE="17.6. Using UNIX Domain Sockets"
>Using UNIX Domain Sockets</A
><BR><A
CLASS="sect1"
HREF="ch17_08.htm"
TITLE="17.7. Identifying the Other End of a Socket"
>Identifying the Other End of a Socket</A
><BR><A
CLASS="sect1"
HREF="ch17_09.htm"
TITLE="17.8. Finding Your Own Name and Address"
>Finding Your Own Name and Address</A
><BR><A
CLASS="sect1"
HREF="ch17_10.htm"
TITLE="17.9. Closing a Socket After Forking"
>Closing a Socket After Forking</A
><BR><A
CLASS="sect1"
HREF="ch17_11.htm"
TITLE="17.10. Writing Bidirectional Clients"
>Writing Bidirectional Clients</A
><BR><A
CLASS="sect1"
HREF="ch17_12.htm"
TITLE="17.11. Forking Servers"
>Forking Servers</A
><BR><A
CLASS="sect1"
HREF="ch17_13.htm"
TITLE="17.12. Pre-Forking Servers"
>Pre-Forking Servers</A
><BR><A
CLASS="sect1"
HREF="ch17_14.htm"
TITLE="17.13. Non-Forking Servers"
>Non-Forking Servers</A
><BR><A
CLASS="sect1"
HREF="ch17_15.htm"
TITLE="17.14. Writing a Multi-Homed Server"
>Writing a Multi-Homed Server</A
><BR><A
CLASS="sect1"
HREF="ch17_16.htm"
TITLE="17.15. Making a Daemon Server"
>Making a Daemon Server</A
><BR><A
CLASS="sect1"
HREF="ch17_17.htm"
TITLE="17.16. Restarting a Server on Demand"
>Restarting a Server on Demand</A
><BR><A
CLASS="sect1"
HREF="ch17_18.htm"
TITLE="17.17. Program: backsniff"
>Program: backsniff</A
><BR><A
CLASS="sect1"
HREF="ch17_19.htm"
TITLE="17.18. Program: fwdport"
>Program: fwdport</A
></P
><P
></P
></DIV
><DIV
CLASS="epigraph"
ALIGN="right"
><P
CLASS="para"
ALIGN="right"
><I
>Glendower: I can call spirits from the vasty deep.Hotspur:Why so can I, or so can any man,But will they come when you do call for them?</I
></P
><P
CLASS="attribution"
ALIGN="right"
>-&nbsp;Shakespeare <CITE
CLASS="citetitle"
> King Henry IV Part I, Act III Scene 1</CITE
></P
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch17-35785"
>17.0. Introduction</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch17-idx-1000004654-0"
></A
>Sockets are endpoints for communication. Some types of sockets provide reliable communications. Others offer few guarantees, but consume low system overhead. Socket communication can be used to let processes talk on just one machine or over the Internet.</P
><P
CLASS="para"
>In this chapter we consider the two most commonly used types of sockets: <EM
CLASS="emphasis"
>streams</EM
><A
CLASS="indexterm"
NAME="ch17-idx-1000004824-0"
></A
> and <EM
CLASS="emphasis"
>datagrams</EM
><A
CLASS="indexterm"
NAME="ch17-idx-1000004656-0"
></A
>. Streams provide a bidirectional, sequenced, and reliable channel of communication&nbsp;- similar to pipes. <EM
CLASS="emphasis"
>Datagram</EM
> sockets do not guarantee sequenced, reliable delivery, but they do guarantee that message boundaries will be preserved when read. Your system may support other types of sockets as well; consult your <I
CLASS="filename"
>socket </I
>(2) manpage or equivalent documentation for details.</P
><P
CLASS="para"
>We also consider both the Internet and Unix <A
CLASS="indexterm"
NAME="ch17-idx-1000004657-0"
></A
><A
CLASS="indexterm"
NAME="ch17-idx-1000004657-1"
></A
><A
CLASS="indexterm"
NAME="ch17-idx-1000004657-2"
></A
><A
CLASS="indexterm"
NAME="ch17-idx-1000004657-3"
></A
>domains. The Internet domain gives sockets two-part names: a host (an IP address in a particular format) and a port number. In the Unix domain, sockets are named using files (e.g., <EM
CLASS="emphasis"
>/tmp/mysock</EM
>).</P
><P
CLASS="para"
>In addition to domains and types, sockets also have a <EM
CLASS="emphasis"
>protocol</EM
><A
CLASS="indexterm"
NAME="ch17-idx-1000004658-0"
></A
> associated with them. Protocols are not very important to the casual programmer, as there is rarely more than one protocol for a given domain and type of socket.</P
><P
CLASS="para"
>Domains and types are normally identified by numeric constants (available through functions exported by the Socket and IO::Socket modules). Stream sockets have the type <A
CLASS="indexterm"
NAME="ch17-idx-1000004659-0"
></A
>SOCK_STREAM, and datagram sockets have the type SOCK_DGRAM. The Internet domain is <A
CLASS="indexterm"
NAME="ch17-idx-1000004660-0"
></A
>PF_INET, and the Unix domain PF_UNIX. (POSIX uses PF_LOCAL instead of PF_UNIX, but PF_UNIX will almost always be an acceptable constant simply because of the preponderance of existing software that uses it.) You should use these symbolic names instead of numbers because the numbers may change (and historically, have).</P
><P
CLASS="para"
>Protocols have names like <CODE
CLASS="literal"
>tcp</CODE
> and <CODE
CLASS="literal"
>udp</CODE
>, which correspond to numbers that the operating system uses. The <CODE
CLASS="literal"
>getprotobyname</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004661-0"
></A
> function (built into Perl) returns the number when given a protocol name. Pass protocol number <CODE
CLASS="literal"
>0</CODE
> to socket functions to have the system select an appropriate default.</P
><P
CLASS="para"
>Perl has built-in functions to create and manipulate sockets; these functions largely mimic their C counterparts. While this is good for providing low-level, direct access to every part of the system, most of us prefer something more convenient. That's what the IO::Socket::INET and IO::Socket::UNIX classes are for&nbsp;- they provide a high-level interface to otherwise intricate system calls.</P
><P
CLASS="para"
>Let's look at the built-in functions first. They all return <CODE
CLASS="literal"
>undef</CODE
> and set <CODE
CLASS="literal"
>$!</CODE
> if an error occurs. The <CODE
CLASS="literal"
>socket</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004662-0"
></A
> function makes a socket, <CODE
CLASS="literal"
>bind</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004664-0"
></A
> gives a socket a local name, <CODE
CLASS="literal"
>connect</CODE
> connects a local socket to a (possibly remote) one, <CODE
CLASS="literal"
>listen</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004663-0"
></A
> readies a socket for connections from other sockets, and <CODE
CLASS="literal"
>accept</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004665-0"
></A
> receives the connections one by one. You can communicate over a stream socket with <CODE
CLASS="literal"
>print</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004666-0"
></A
> and <A
CLASS="indexterm"
NAME="ch17-idx-1000004669-0"
></A
><A
CLASS="indexterm"
NAME="ch17-idx-1000004669-1"
></A
>&lt; &gt; as well as with <CODE
CLASS="literal"
>syswrite</CODE
> and <CODE
CLASS="literal"
>sysread</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004667-0"
></A
><A
CLASS="indexterm"
NAME="ch17-idx-1000004667-1"
></A
>, or over a datagram socket with <CODE
CLASS="literal"
>send</CODE
> and <CODE
CLASS="literal"
>recv</CODE
>. (Perl does not currently support <EM
CLASS="emphasis"
>sendmsg</EM
>(2).)</P
><P
CLASS="para"
>A typical server calls <CODE
CLASS="literal"
>socket</CODE
>, <CODE
CLASS="literal"
>bind</CODE
>, and <CODE
CLASS="literal"
>listen</CODE
>, then loops in a blocking <CODE
CLASS="literal"
>accept</CODE
> call that waits for incoming connections (see <A
CLASS="xref"
HREF="ch17_03.htm"
TITLE="Writing a TCP Server"
>Recipe 17.2</A
> and <A
CLASS="xref"
HREF="ch17_06.htm"
TITLE="Setting Up a UDP Server"
>Recipe 17.5</A
>). A typical client calls <CODE
CLASS="literal"
>socket</CODE
> and <CODE
CLASS="literal"
>connect</CODE
> (see <A
CLASS="xref"
HREF="ch17_02.htm"
TITLE="Writing a TCP Client"
>Recipe 17.1</A
> and <A
CLASS="xref"
HREF="ch17_05.htm"
TITLE="Setting Up a UDP Client"
>Recipe 17.4</A
>). Datagram clients are special. They don't have to <CODE
CLASS="literal"
>connect</CODE
> to send data because they can specify the destination as an argument to <CODE
CLASS="literal"
>send</CODE
>.</P
><P
CLASS="para"
>When you <CODE
CLASS="literal"
>bind</CODE
> , <CODE
CLASS="literal"
>connect</CODE
>, or <CODE
CLASS="literal"
>send</CODE
> to a specific destination, you must supply a socket name. An Internet domain socket name is a host (an IP address packed with <CODE
CLASS="literal"
>inet_aton</CODE
>) and a port (a number), packed into a C-style structure with <CODE
CLASS="literal"
>sockaddr_in</CODE
>:</P
><PRE
CLASS="programlisting"
>use Socket;

$packed_ip   = inet_aton(&quot;208.146.240.1&quot;);
$socket_name = sockaddr_in($port, $packed_ip);</PRE
><P
CLASS="para"
>A Unix domain socket name is a filename packed into a C structure with <CODE
CLASS="literal"
>sockaddr_un</CODE
>:</P
><PRE
CLASS="programlisting"
>use Socket;

$socket_name = sockaddr_un(&quot;/tmp/mysock&quot;);</PRE
><P
CLASS="para"
>To take a packed socket name and turn it back into a filename or host and port, call <CODE
CLASS="literal"
>sockaddr_un</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004677-0"
></A
><A
CLASS="indexterm"
NAME="ch17-idx-1000004677-1"
></A
> or <CODE
CLASS="literal"
>sockaddr_in</CODE
> in list context:</P
><PRE
CLASS="programlisting"
>($port, $packed_ip) = sockaddr_in($socket_name);    # for PF_INET sockets
($filename)         = sockaddr_un($socket_name);    # for PF_UNIX sockets</PRE
><P
CLASS="para"
>Use <CODE
CLASS="literal"
>inet_ntoa</CODE
><A
CLASS="indexterm"
NAME="ch17-idx-1000004678-0"
></A
> to turn a packed <A
CLASS="indexterm"
NAME="ch17-idx-1000004906-0"
></A
>IP address back into an ASCII string. It stands for "numbers to ASCII" and <CODE
CLASS="literal"
>inet_aton</CODE
> stands for "ASCII to numbers."</P
><PRE
CLASS="programlisting"
>$ip_address = inet_ntoa($packed_ip);
$packed_ip  = inet_aton(&quot;204.148.40.9&quot;);
$packed_ip  = inet_aton(&quot;www.oreilly.com&quot;);</PRE
><P
CLASS="para"
>Most recipes use Internet domain sockets in their examples, but nearly everything that applies to the Internet domain also applies to the Unix domain. <A
CLASS="xref"
HREF="ch17_07.htm"
TITLE="Using UNIX Domain Sockets"
>Recipe 17.6</A
> explains the differences and pitfalls.</P
><P
CLASS="para"
>Sockets are the basis of network services. We provide three ways to write servers: one where a child process is created for each incoming connection (<A
CLASS="xref"
HREF="ch17_12.htm"
TITLE="Forking Servers"
>Recipe 17.11</A
>), one where the server forks in advance (<A
CLASS="xref"
HREF="ch17_13.htm"
TITLE="Pre-Forking Servers"
>Recipe 17.12</A
>), and one where the server process doesn't fork at all (<A
CLASS="xref"
HREF="ch17_14.htm"
TITLE="Non-Forking Servers"
>Recipe 17.13</A
>).</P
><P
CLASS="para"
>Some servers need to listen to many IP addresses at once, which we demonstrate in <A
CLASS="xref"
HREF="ch17_15.htm"
TITLE="Writing a Multi-Homed Server"
>Recipe 17.14</A
>. Well-behaved servers clean up and restart when they get a HUP signal; <A
CLASS="xref"
HREF="ch17_17.htm"
TITLE="Restarting a Server on Demand"
>Recipe 17.16</A
> shows how to implement that behavior in Perl. We also show how to put a name to both ends of a connection; see <A
CLASS="xref"
HREF="ch17_08.htm"
TITLE="Identifying the Other End of a Socket"
>Recipe 17.7</A
> and <A
CLASS="xref"
HREF="ch17_09.htm"
TITLE="Finding Your Own Name and Address"
>Recipe 17.8</A
>.</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>Unix Network Programming</EM
> and the three-volume <EM
CLASS="emphasis"
>TCP/IP Illustrated</EM
> by W. Richard Stevens are indispensable for the serious socket programmer. If you want to learn the basics about sockets, it's hard to beat the original and classic reference, <CITE
CLASS="citetitle"
>An Advanced 4.4BSD Interprocess Communication Tutorial.</CITE
> It's written for C, but almost everything is directly applicable to Perl. It's available in <EM
CLASS="emphasis"
>/usr/share/doc</EM
> on most BSD-derived Unix systems. We also recommend you look at <CITE
CLASS="citetitle"
>The Unix Programming Frequently Asked Questions List</CITE
> (Gierth and Horgan), and <CITE
CLASS="citetitle"
>Programming UNIX Sockets in C&nbsp;- Frequently Asked Questions </CITE
>(Metcalf and Gierth), both of which are posted periodically to the <A
CLASS="systemitem.newsgroup"
HREF="news:comp.unix.answers"
>comp.unix.answers</A
> newsgroup.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><TABLE
WIDTH="684"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch16_23.htm"
TITLE="16.22. Program: sigrand"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 16.22. Program: sigrand"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="book"
HREF="index.htm"
TITLE="Perl Cookbook"
><IMG
SRC="../gifs/txthome.gif"
ALT="Perl Cookbook"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="sect1"
HREF="ch17_02.htm"
TITLE="17.1. Writing a TCP Client"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 17.1. Writing a TCP Client"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="228"
>16.22. Program: sigrand</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="228"
><A
CLASS="index"
HREF="index/index.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="228"
>17.1. Writing a TCP Client</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="684"
TITLE="footer"><FONT
SIZE="-1"
></DIV<!-- LIBRARY NAV BAR --> <img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p> <a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font> </p> <map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="../prog/index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm"></map> </BODY
></HTML
>
