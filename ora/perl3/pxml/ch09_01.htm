<html><head><title>RSS, SOAP, and Other XML Applications  (Perl and XML)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Erik T. Ray and Jason McIntosh" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="059600205XL" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Perl and XML" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Perl &amp; XML" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch08_04.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch09_02.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>




<h1 class="chapter">Chapter 9. RSS, SOAP, and Other XML Applications </h1>
<div class="htmltoc"><h4 class="tochead">Contents:</h4>
  <p> <a href="#perlxml-CHP-9-SECT-1">XML Modules</a><br />
<a href="ch09_02.htm">XML::RSS </a><br />
<a href="ch09_03.htm">XML Programming Tools </a><br />
<a href="ch09_04.htm">SOAP::Lite </a><br /></p></div>


<p>In the next couple of chapters, we'll cover, at long
last, what happens when we pull together all the abstract tools and
strategies we've discussed and start having XML
dance for us. This is the land of the XML application, where parsers
all have a bone to pick, picking up documents with a goal in mind. No
longer satisfied with picking out the elements and attributes and
calling it a day, these higher-level tools look for meaning in all
that structure, according to directives that have been programmed
into it.
</p>

<p>When we say XML application, we are specifically referring to
XML-based document formats, not the computer programs (applications
of another sort) that do stuff with them. You may run across
statements such as "GreenMonkeyML is an XML
application that provides semantic markup for green
monkeys." Visiting the project's
home page at <em class="emphasis">http://www.greenmonkey-markup.com</em>, we might
encounter documentation describing how this specific format works,
example documents, suggested uses for it, a DTD or schema used to
validate GreenMonkeyML documents, and maybe an online validation
tool. This content would all fit into the definition of an XML
application.
</p>

<p>This chapter looks at XML applications that already have a strong
presence in the Perl world, by way of publicly available Perl modules
that know how to handle them.
</p>


<div class="sect1"><a name="perlxml-CHP-9-SECT-1" /></a>
<h2 class="sect1">9.1. XML Modules</h2>

<p>The term <em class="emphasis">XML
modules</em><a name="INDEX-720" /></a>
narrows us down from the Perl modules on CPAN that send mail, process
images, and play games, but it still leaves us with a very broad
cross section. So far in this book, we have exhaustively covered Perl
extensions that can perform general XML processing, but none that
perform more targeted functions based on general processing. In the
end, they hand you a plate of XML chunklets, free of any inherent
meaning, and leave it to you to decide what happens next. In many of
the examples we've provided so far in this book, we
have written programs that do exactly this: invoke an XML parser to
chew up a document and then cook up something interesting out of the
elements and attributes we get back.
</p>

<p>However, the modules we're thinking about here give
you more than the generic parse-and-process module family by building
on one of the parsers and abstracting the processing in a specific
direction. They then provide an API that, while it might still
contain hooks into the raw XML, concentrates on methods and routines
particular to the XML application that they implement.
</p>

<p>We can divide these XML application-mangling Perl modules into three
types. We'll examine an example of each in this
chapter, and in the next chapter, we'll try to make
some for ourselves.
</p>

<dl>
<a name="INDEX-721" /></a><dt><i>XML application helpers </i></dt>
<dd>
<p>Helper modules are the humblest of the lot. In practice, they are
often little more than wrappers around raw XML processors, but
sometimes that's all you need. If you find yourself
writing several programs that need to read from and write to a
specific XML-based document format, a helper module can provide
common methods, freeing the programmer from worrying about the
application's exact document format or its
well-formedness in generated output. The module will take care of all
that.
</p>
</dd>


<dt><i>Programming helpers that use XML </i></dt>
<dd>
<p>This small but growing category describes Perl extensions that use
XML to do cool stuff in your program, even if your
program's input or output has little to do with XML.
Currently, the most prominent examples involve the terrifying,
DBI-like powers of <tt class="literal">XML::SAX</tt>, the whole PerlSAX2
family, and individual tools like the
<tt class="literal">XML::Generator::DBI</tt> module, which crossbreeds
existing Perl modules for database manipulation and SAX processing.
</p>
</dd>


<dt><i>Full-on applications that use XML </i></dt>
<dd>
<p>Finally, we have software that uses XML, but has so many layers of
abstraction between its intended purpose and the underlying XML that
calling it an XML application is like calling Microsoft Word a C
application. For example, working with <tt class="literal">SOAP::Lite</tt>
involves documents that are barely human-readable and exist only in
memory until they're shot over the Internet via
HTTP; the role of XML in SOAP is completely transparent.
</p>
</dd>

</dl>

</div>








<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch08_04.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch09_02.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">8.4. Optimized Tree Processing</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">9.2. XML::RSS </td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="../prog/index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="../cookbook/index.htm"><area shape="rect" coords="617,0,690,135" href="index.htm"></map>

</body></html>