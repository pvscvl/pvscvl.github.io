<html><head><title>Stream-Based Versus Tree-Based Processing (Perl and XML)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Erik T. Ray and Jason McIntosh" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="059600205XL" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Perl and XML" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Perl &amp; XML" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch03_02.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch03_04.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>



<h2 class="sect1">3.3. Stream-Based Versus Tree-Based Processing</h2>

<p>Remember<a name="INDEX-230" /> the<a name="INDEX-231" /> Perl mantra<a name="INDEX-232" />,
"There's more than one way to do
it<a name="INDEX-233" />"? It is also true
when working with XML. Depending on how you want to work and what
kind of resources you have, many options are available. One developer
may prefer a low-maintenance parsing job and is prepared to be loose
and sloppy with memory to get it. Another will need to squeeze out
faster and leaner performance at the expense of more complex code.
XML processing tasks vary widely, so you should be free to choose the
shortest path to a solution.
</p>

<p>There are a lot of different XML processing strategies. Most fall
into two categories: stream-based and tree-based. With the
<em class="emphasis">stream-based strategy</em>, the parser continuously
alerts a program to patterns in the XML. The parser functions like a
pipeline, taking XML markup on one end and pumping out processed
nuggets of data to your program. We call this pipeline an
<em class="emphasis">event stream</em><a name="INDEX-234" /> because each chunk of data sent to the
program signals something new and interesting in the XML stream. For
example, the beginning of a new element is a significant event. So is
the discovery of a processing instruction in the markup. With each
update, your program does something new -- perhaps translating the
data and sending it to another place, testing it for some specific
content, or sticking it onto a growing heap of data.
</p>

<p>With the <em class="emphasis">tree-based strategy</em>, the parser keeps
the data to itself until the very end, when it presents a complete
model of the document to your program. Instead of a pipeline,
it's like a camera that takes a picture and
transmits the replica to you. The model is usually in a much more
convenient state than raw XML. For example, nested elements may be
represented in native Perl structures like lists or hashes, as we saw
in an earlier example. Even more useful are trees of blessed objects
with methods that help navigate the structure from one place to
another. The whole point to this strategy is that your program can
pull out any data it needs, in any order.
</p>

<p>Why would you prefer one over the other? Each has strong and weak
points. Event streams are fast and often have a much slimmer memory
footprint, but at the expense of greater code complexity and
impermanent data. Tree building, on the other hand, lets the data
stick around for as long as you need it, and your code is usually
simple because you don't need special tricks to do
things like backwards searching. However, trees wither when it comes
to economical use of processor time and memory.
</p>

<p>All of this is relative, of course. Small documents
don't cause much hardship to a typical computer,
especially since CPU cycles and megabytes are getting cheaper every
day. Maybe the convenience of a persistent data structure will
outweigh any drawbacks. On the other hand, when working with
Godzilla-sized documents like books, or huge numbers of documents all
at once, you'll definitely notice the crunch. Then
the agility of event stream processors will start to look better.
It's impossible to give you any hard-and-fast rules,
so we'll leave the decision up to you.
</p>

<p>An interesting thing to note about the stream-based and tree-based
strategies is that one is the basis for the other.
That's right, an event stream drives the process of
building a tree data structure. Thus, most low-level parsers are
event streams because you can always write a tree building layer on
top. This is how <tt class="literal">XML::Parser</tt> and most other
parsers work.
</p>

<p>In a related, more recent, and very cool development, XML event
streams can also turn any kind of document into some form of XML by
writing stream-based parsers that generate XML events from whatever
data structures lurk in that document type.
</p>

<p>There's a lot more to say about event streams and
tree builders -- so much, in fact, that we've
devoted two whole chapters to the topics. <a href="ch04_01.htm">Chapter 4, "Event Streams"</a> takes a deep plunge into the theory behind
event streams with lots of examples for making useful programs out of
them. <a href="ch06_01.htm">Chapter 6, "Tree Processing"</a> takes you deeper into the forest
with lots of tree-based examples. After that, <a href="ch08_01.htm">Chapter 8, "Beyond Trees: XPath, XSLT, and More"</a> shows you<a name="INDEX-235" /> unusual<a name="INDEX-236" /> hybrids that
provide<a name="INDEX-237" /> the best of both worlds.
</p>



<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch03_02.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch03_04.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">3.2. XML::Parser</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">3.4. Putting Parsers to Work</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="../prog/index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="../cookbook/index.htm"><area shape="rect" coords="617,0,690,135" href="index.htm"></map>

</body></html>