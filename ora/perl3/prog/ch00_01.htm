<html>
<head>
<title>Preface (Programming Perl)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Preface">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home">
<map name="banner-map"><AREA SHAPE="rect" coords="1,-2,616,66" HREF="index.htm" ALT="Programming Perl"><AREA SHAPE="rect" coords="629,-11,726,25" HREF="jobjects/fsearch.htm" ALT="Search this book">
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="684" border="0">
<tr>
<td align="left" valign="top" width="228"></td><td align="center" valign="top" width="228"><a href="index.htm"></a></td><td align="right" valign="top" width="228"><a href="ch00_02.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>


<h1 class="chapter">Preface</h1>


<h2 class="sect1">0.1. The Pursuit of Happiness</h2>

<p>Perl is a language for getting your job done.</p>

<p>Of course, if your job is programming, you can get your job done with
any "complete" computer language, theoretically speaking.  But we know
from experience that computer languages differ not so much in what
they make <em class="emphasis">possible</em>, but in what they make
<em class="emphasis">easy</em>.  At one extreme, the so-called
fourth-generation languages make it easy to do some things, but nearly
impossible to do other things.  At the other extreme, so-called
industrial-strength languages make it equally difficult to do almost
everything.</p>

<p>Perl is different.  In a nutshell, Perl is designed to make the easy
jobs easy, without making the hard jobs impossible.</p>

<p>And what are these "easy jobs" that ought to be easy?  The ones you do
every day, of course.  You want a language that makes it easy to
manipulate numbers and text, files and directories, computers and
networks, and especially programs.  It should be easy to run external
programs and scan their output for interesting tidbits.  It should be
easy to send those same tidbits off to other programs that can do
special things with them.  It should be easy to develop, modify, and
debug your own programs too.  And, of course, it should be easy to
compile and run your programs, and do it portably, on any modern
operating system.</p>

<p>Perl does all that, and a whole lot more.</p>

<p>
<a name="INDEX-1"></a>
Initially designed as a glue language for Unix, Perl has long since
spread to most other operating systems.  Because it runs nearly
everywhere, Perl is one of the most portable programming environments
available today.  To program C or C++ portably, you have to put in all
those strange <tt class="literal">#ifdef</tt> markings for different operating systems.  To
program Java portably, you have to understand the idiosyncrasies of
each new Java implementation.  To program a shell script portably, you
have to remember the syntax for each operating system's version of each
command and somehow find the common factor that (you hope) works
everywhere.  And to program Visual Basic portably, you just need a
more flexible definition of the word "portable". <tt class="literal">:-)</tt>
</p>

<p>Perl happily avoids such problems while retaining many of the
benefits of these other languages, with some additional magic of its
own.  Perl's magic comes from many sources:  the utility of its feature
set, the inventiveness of the Perl community, and the exuberance of the
open source movement in general.  But much of this magic is simply
hybrid vigor; Perl has a mixed heritage and has always viewed
diversity as a strength rather than a weakness.  Perl is a "give me
your tired, your poor" language.  If you feel like a huddled
mass longing to be free, Perl is for you.</p>

<p>Perl reaches out across cultures.  Much of the explosive growth of Perl
has been fueled by the hankerings of former Unix systems programmers
who wanted to take along with them as much of the "old country" as they
could.  For them, Perl is the portable distillation of Unix culture, an
oasis in the desert of "can't get there from here".  On the other
hand, it also works in the other direction:  Windows-based web
designers are often delighted to discover that they can take their Perl
programs and run them unchanged on the company's Unix server.</p>

<p>Although Perl is especially popular with systems programmers and web
developers, that's just because they discovered it first; Perl appeals
to a much broader audience.  From its small start as a text-processing
language, Perl has grown into a sophisticated, general-purpose
programming language with a rich software development environment
complete with debuggers, profilers, cross-referencers, compilers,
libraries, syntax-directed editors, and all the rest of
the trappings of a "real" programming language--if you want them.  But
those are all about making hard things possible, and lots of languages
can do that.  Perl is unique in that it never lost its vision for
keeping easy things easy.</p>

<p>Because Perl is both powerful and accessible, it is being used daily in
every imaginable field, from aerospace engineering to molecular
biology, from mathematics to linguistics, from graphics to document
processing, from database manipulation to network
management.  Perl is used by people who are desperate to analyze or
convert lots of data quickly, whether you're talking DNA sequences, web
pages, or pork belly futures.  Indeed, one of the jokes in the Perl
community is that the next big stock market crash will probably be
triggered by a bug in someone's Perl script.  (On the brighter side, any
unemployed stock analysts will still have a marketable skill, so to
speak.)</p>

<p>There are many reasons for the success of Perl.  Perl was a successful
open source project long before the open source movement got its name.
Perl is free, and will always be free.  You can use Perl however you
see fit, subject only to a very liberal licensing policy.  If you are
in business and want to use Perl, go right ahead.  You can embed Perl
in the commercial applications you write without fee or restriction.
And if you have a problem that the Perl community can't fix, you have
the ultimate backstop: the source code itself.  The Perl community is
not in the business of renting you their trade secrets in the guise of
"upgrades".  The Perl community will never "go out of business" and
leave you with an orphaned product.</p>

<p>It certainly helps that Perl is free software.  But that's not enough
to explain the Perl phenomenon since many freeware packages fail to
thrive.  Perl is not just free; it's also fun.  People feel like they
can be creative in Perl because they have freedom of expression: they
get to choose what to optimize for, whether that's computer speed or
programmer speed, verbosity or conciseness, readability or
maintainability or reusability or portability or learnability or
teachability.  You can even optimize for obscurity, if you're entering
an Obfuscated Perl Contest.</p>

<p>Perl can give you all these degrees of freedom because it's a language
with a split personality.  It's simultaneously a very simple language
and a very rich language.  Perl has taken good ideas from nearly
everywhere and installed them into an easy-to-use mental framework.
To those who merely like it, Perl is the <em class="emphasis">Practical Extraction and
Report Language</em>.  To those who love it, Perl is the <em class="emphasis">Pathologically
Eclectic Rubbish Lister</em>.  And to the minimalists in the crowd, Perl
seems like a pointless exercise in redundancy.  But that's okay.  The
world needs a few reductionists (mainly as physicists).  Reductionists
like to take things apart.  The rest of us are just trying to get it
together.</p>

<p>There are many ways in which Perl is a simple language.  You don't have
to know many special incantations to compile a Perl program--you can
just execute it like a batch file or shell script.  The types and
structures used by Perl are easy to use and understand.  Perl doesn't
impose arbitrary limitations on your data--your strings and arrays can
grow as large as they like (as long as you have memory), and they're
designed to scale well as they grow.  Instead of forcing you to learn
new syntax and semantics, Perl borrows heavily from other languages you
may already be familiar with (such as C, and <em class="emphasis">awk</em>, and BASIC, and
Python, and English, and Greek).  In fact, just about any programmer
can read a well-written piece of Perl code and have some idea of what
it does.</p>

<p>Most important, you don't have to know everything there is to know about
Perl before you can write useful programs.  You can learn Perl "small
end first".  You can program in Perl Baby-Talk, and we promise not to
laugh.  Or more precisely, we promise not to laugh any more than we'd
giggle at a child's creative way of putting things.  Many of the ideas
in Perl are borrowed from natural language, and one of the best ideas is
that it's okay to use a subset of the language as long as you get your
point across.  Any level of language proficiency is acceptable in Perl
culture.  We won't send the language police after you.  A Perl script is
"correct" if it gets the job done before your boss fires you.</p>

<p>Though simple in many ways, Perl is also a rich language, and there is
much to learn about it.  That's the price of making hard things
possible.  Although it will take some time for you to absorb all that
Perl can do, you will be glad that you have access to the extensive
capabilities of Perl when the time comes that you need them.</p>

<p>Because of its heritage, Perl was a rich language even when it was
"just" a data-reduction language, designed for navigating files,
scanning large amounts of text, creating and obtaining dynamic data, and
printing easily formatted reports based on that data.  But somewhere
along the line, Perl started to blossom.  It also became a language for
filesystem manipulation, process management, database administration,
client-server programming, secure programming, web-based information
management, and even for object-oriented and functional programming.
These capabilities were not just slapped onto the side of Perl--each new
capability works synergistically with the others because Perl was
designed to be a glue language from the start.</p>

<p>
<a name="INDEX-2"></a>
But Perl can glue together more than its own features.  Perl is designed
to be modularly extensible.  Perl allows you to rapidly design, program,
debug, and deploy applications, and it also allows you to easily extend
the functionality of these applications as the need arises.  You can
embed Perl in other languages, and you can embed other languages in
Perl.  Through the module importation mechanism, you can use these
external definitions as if they were built-in features of Perl.
Object-oriented external libraries retain their object-orientedness in
Perl.</p>

<p>
<a name="INDEX-3"></a>
Perl helps you in other ways, too.  Unlike strictly interpreted
languages such as command files or shell scripts, which compile and
execute a program one command at a time, Perl first compiles your whole
program quickly into an intermediate format.  Like any other compiler,
it performs various optimizations and gives you instant feedback on
everything from syntax and semantic errors to library binding mishaps.
Once Perl's compiler frontend is happy with your program, it passes off
the intermediate code to the interpreter to execute (or optionally to
any of several modular back ends that can emit C or bytecode).  This
all sounds complicated, but the compiler and interpreter are quite
efficient, and most of us find that the typical compile-run-fix cycle
is measured in mere seconds.  Together with Perl's many fail-soft
characteristics, this quick turnaround capability makes Perl a language
in which you really can do rapid prototyping.  Then later, as your
program matures, you can tighten the screws on yourself and make
yourself program with less flair but more discipline.  Perl helps you
with that, too, if you ask nicely.</p>

<p>
<a name="INDEX-4"></a>
Perl also helps you to write programs more securely.  In addition to
all the typical security interfaces provided by other languages,
Perl also guards against accidental security errors through a unique
data-tracing mechanism that automatically determines which data came
from insecure sources and prevents dangerous operations before they can
happen.  Finally, Perl lets you set up specially protected compartments
in which you can safely execute Perl code of dubious origin, disallowing
dangerous operations.</p>

<p>But, paradoxically, the way in which Perl helps you the most has almost
nothing to do with Perl and everything to do with the people who use
Perl.  Perl folks are, frankly, some of the most helpful folks on
earth.  If there's a religious quality to the Perl movement, then this
is at the heart of it.  Larry wanted the Perl community to function
like a little bit of heaven, and by and large he seems to have gotten
his wish, so far.  Please do your part to keep it that way.</p>

<p>Whether you are learning Perl because you want to save the world, or
just because you are curious, or because your boss told you to, this
handbook will lead you through both the basics and the intricacies.  And
although we don't intend to teach you how to program, the perceptive
reader will pick up some of the art, and a little of the science, of
programming.  We will encourage you to develop the three great virtues of
a programmer: <em class="emphasis">laziness</em>, <em class="emphasis">impatience</em>, and <em class="emphasis">hubris</em>.  Along the
way, we hope you find the book mildly amusing in some spots (and wildly
amusing in others).  And if none of this is enough to keep you awake,
just keep reminding yourself that learning Perl will increase the value
of your resume.  So keep reading.</p>



















































































<!-- BOTTOM NAV BAR -->

<hr width="684" align="left">
<div class="navbar">
<table width="684" border="0">
<tr>
<td align="left" valign="top" width="228"></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="228"><a href="ch00_02.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="228"></td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="228">0.2. What's New in This Edition</td>
</tr>
</table>
</div>
<hr width="684" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="../cookbook/index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm">
</map>

<!-- END OF BODY -->

</body>
</html>
