<html>
<head>
<title>Staying in Control (Programming Perl)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Staying in Control">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home">
<map name="banner-map"><AREA SHAPE="rect" coords="1,-2,616,66" HREF="index.htm" ALT="Programming Perl"><AREA SHAPE="rect" coords="629,-11,726,25" HREF="jobjects/fsearch.htm" ALT="Search this book">
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="684" border="0">
<tr>
<td align="left" valign="top" width="228"><a href="ch05_08.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="228"><a href="ch05_01.htm"></a></td><td align="right" valign="top" width="228"><a href="ch05_10.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>



<h2 class="sect1">5.9. Staying in Control</h2>

<p>As any good manager knows, you shouldn't micromanage your employees.
Just tell them what you want, and let them figure out the best way of
doing it.  Similarly, it's often best to think of a regular expression
as a kind of specification: "Here's what I want; go find a string that
fits the bill."</p>

<p>
<a name="INDEX-1674"></a>
On the other hand, the best managers also understand the job their
employees are trying to do.  The same is true of pattern matching in
Perl.  The more thoroughly you understand of how Perl goes about the
task of matching any particular pattern, the more wisely you'll be able
to make use of Perl's pattern matching capabilities.</p>

<p>One of the most important things to understand about Perl's pattern-matching
is when <em class="emphasis">not</em> to use it.</p>


<h3 class="sect2">5.9.1. Letting Perl Do the Work</h3>

<p>
<a name="INDEX-1675"></a>
When people of a certain temperament first learn regular expressions,
they're often tempted to see everything as a problem in pattern
matching.  And while that may even be true in the larger sense,
pattern matching is about more than just evaluating regular
expressions.  It's partly about looking for your car keys where you
dropped them, not just under the streetlamp where you can see better.
In real life, we all know that it's a lot more efficient to look in
the right places than the wrong ones.</p>

<p>Similarly, you should use Perl's control flow to decide which patterns
to execute, and which ones to skip.  A regular expression is pretty
smart, but it's smart like a horse.  It can get distracted if it sees
too much at once.  So sometimes you have to put blinders onto it.  For
example, you'll recall our earlier example of alternation:
<blockquote>
<pre class="programlisting">/Gandalf|Saruman|Radagast/</pre>
</blockquote>
<a name="INDEX-1676"></a><a name="INDEX-1677"></a><a name="INDEX-1678"></a>
That works as advertised, but not as well as it might, because it
searches every position in the string for every name before it moves
on to the next position.  Astute readers of <em class="emphasis">The Lord of the
Rings</em> will recall that, of the three wizards named above,
Gandalf is mentioned much more frequently than Saruman, and Saruman is
mentioned much more frequently than Radagast.  So it's generally more
efficient to use Perl's logical operators to do the alternation:
<blockquote>
<pre class="programlisting">/Gandalf/ || /Saruman/ || /Radagast/</pre>
</blockquote>

This is yet another way of defeating the "leftmost" policy of the
Engine.  It only searches for <tt class="literal">Saruman</tt> if
<tt class="literal">Gandalf</tt> was nowhere to be seen.  And it only
searches for <tt class="literal">Radagast</tt> if <tt class="literal">Saruman</tt>
is also absent.</p>

<p>Not only does this change the order in which things are searched, but
it sometimes allows the regular expression optimizer to work better.  It's
generally easier to optimize searching for a single string than for
several strings simultaneously.  Similarly, anchored searches can often
be optimized if they're not too complicated.</p>

<p>
<a name="INDEX-1679"></a><a name="INDEX-1680"></a>
You don't have to limit your control of the control flow to the
<tt class="literal">||</tt> operator.  Often you can control things at the
statement level.  You should always think about weeding out the common
cases first.  Suppose you're writing a loop to process a

configuration
file.  Many configuration files are mostly comments.  It's often best
to discard comments and blank lines early before doing any heavy-duty
processing, even if the heavy duty processing would throw out the
comments and blank lines in the course of things:
<blockquote>
<pre class="programlisting">while (&lt;CONF&gt;) {
    next if /^#/;
    next if /^\s*(#|$)/;
    chomp;
    munchabunch($_);
}</pre>
</blockquote>

Even if you're not trying to be efficient, you often need to alternate
ordinary Perl expressions with regular expressions simply because you
want to take some action that is not possible (or very difficult) from
within the regular expression, such as printing things out.  Here's a
useful number classifier:
<blockquote>
<pre class="programlisting">warn "has nondigits"        if     /\D/;
warn "not a natural number" unless /^\d+$/;             # rejects -3
warn "not an integer"       unless /^-?\d+$/;           # rejects +3
warn "not an integer"       unless /^[+-]?\d+$/;
warn "not a decimal number" unless /^-?\d+\.?\d*$/;     # rejects .2
warn "not a decimal number" unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;
warn "not a C float"
       unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;</pre>
</blockquote>

We could stretch this section out a lot longer, but really, that sort
of thing is what this whole book is about.  You'll see many more
examples of the interplay of Perl code and pattern matching as we go
along.  In particular, see the later section <a href="ch05_10.htm">Section 5.10.3, "Programmatic Patterns"</a>.
(It's okay to read the intervening material first, of course.)</p>





<a name="ch05-sect-vi"></a>
<h3 class="sect2">5.9.2. Variable Interpolation</h3>

<p>
<a name="INDEX-1681"></a><a name="INDEX-1682"></a>
Using Perl's control flow mechanisms to control regular expression
matching has its limits.  The main difficulty is that it's an "all or
nothing" approach; either you run the pattern, or you don't.
Sometimes you know the general outlines of the pattern you want, but
you'd like to have the capability of parameterizing it.  Variable
interpolation provides that capability, much like parameterizing a
subroutine lets you have more influence over its behavior than just
deciding whether to call it or not.  (More about subroutines in the
next chapter).</p>

<p>One nice use of interpolation is to provide a little abstraction, along
with a little readability.  With regular expressions you may certainly
write things concisely:
<blockquote>
<pre class="programlisting">if ($num =~ /^[-+]?\d+\.?\d*$/) { ... }</pre>
</blockquote>
But what you mean is more apparent when you write:
<blockquote>
<pre class="programlisting">$sign = '[-+]?';
$digits = '\d+';
$decimal = '\.?';
$more_digits = '\d*';
$number = "$sign$digits$decimal$more_digits";
...
if ($num =~ /^$number$/o) { ... }</pre>
</blockquote>
<a name="INDEX-1683"></a>
We'll cover this use of interpolation more under "Generated patterns"
later in this chapter.  We'll just point out that we used the <tt class="literal">/o</tt>
modifier to suppress recompilation because we don't expect <tt class="literal">$number</tt> to
change its value over the course of the program.</p>

<p>
<a name="INDEX-1684"></a>
Another cute trick is to turn your tests inside out and use
the variable string to pattern-match against a set of known strings:
<blockquote>
<pre class="programlisting">chomp($answer = &lt;STDIN&gt;);
if    ("SEND"  =~ /^\Q$answer/i) { print "Action is send\n"  }
elsif ("STOP"  =~ /^\Q$answer/i) { print "Action is stop\n"  }
elsif ("ABORT" =~ /^\Q$answer/i) { print "Action is abort\n" }
elsif ("LIST"  =~ /^\Q$answer/i) { print "Action is list\n"  }
elsif ("EDIT"  =~ /^\Q$answer/i) { print "Action is edit\n"  }</pre>
</blockquote>

This lets your user perform the "send" action by typing any of <tt class="literal">S</tt>,
<tt class="literal">SE</tt>, <tt class="literal">SEN</tt>, or <tt class="literal">SEND</tt> (in any mixture of upper- and lowercase).  To
"stop", they'd have to type at least <tt class="literal">ST</tt> (or <tt class="literal">St</tt>, or <tt class="literal">sT</tt>, or <tt class="literal">st</tt>).</p>


<h3 class="sect3">5.9.2.1. When backslashes happen</h3>

<p>
<a name="INDEX-1685"></a>
When you think of double-quote interpolation, you usually think of both
variable and backslash interpolation.  But as we mentioned earlier, for
regular expressions there are two passes, and the interpolation pass
defers most of the backslash interpretation to the regular expression
parser (which we discuss later).  Ordinarily, you don't
notice the difference, because Perl takes pains to hide the
difference.  (One sequence that's obviously different is the <tt class="literal">\b</tt>
metasymbol, which turns into a word boundary assertion--outside of
character classes, anyway.  Inside a character class where assertions
make no sense, it reverts to being a backspace, as it is normally.)</p>

<p>It's actually fairly important that the regex parser handle the
backslashes.  Suppose you're searching for tab characters in a pattern
with a <tt class="literal">/x</tt> modifier:
<blockquote>
<pre class="programlisting">($col1, $col2) = /(.*?) \t+ (.*?)/x;</pre>
</blockquote>

If Perl didn't defer the interpretation of <tt class="literal">\t</tt> to the regex parser,
the <tt class="literal">\t</tt> would have turned into whitespace, which the regex parser
would have ignorantly ignored because of the <tt class="literal">/x</tt>.  But Perl is
not so ignoble, or tricky.</p>

<p>You can trick yourself though.  Suppose you abstracted out the column
separator, like this:
<blockquote>
<pre class="programlisting">$colsep = "\t+";                         # (double quotes)
($col1, $col2) = /(.*?) $colsep (.*?)/x;</pre>
</blockquote>

Now you've just blown it, because the <tt class="literal">\t</tt> turns into
a real tab before it gets to the regex parser, which will think you
said <tt class="literal">/(.*?)+(.*?)/</tt> after it discards the
whitespace.  Oops.  To fix, avoid <tt class="literal">/x</tt>, or use single
quotes.  Or better, use <tt class="literal">qr//</tt>.  (See the next
section.)</p>

<p>
<a name="INDEX-1686"></a><a name="INDEX-1687"></a><a name="INDEX-1688"></a>
The only double-quote escapes that are processed as such are the six
translation escapes: <tt class="literal">\U</tt>, <tt class="literal">\u</tt>,
<tt class="literal">\L</tt>, <tt class="literal">\l</tt>, <tt class="literal">\Q</tt>,
and <tt class="literal">\E</tt>.  If you ever look into the inner workings
of the Perl regular expression compiler, you'll find code for handling
escapes like <tt class="literal">\t</tt> for tab, <tt class="literal">\n</tt> for
newline, and so on.  But you won't find code for those six translation
escapes.  (We only listed them in
<a href="ch05_03.htm">Table 5-7</a>
because people expect to find them there.)  If you somehow manage to
sneak any of them into the pattern without going through double-quotish
evaluation, they won't be recognized.</p>

<p>
<a name="INDEX-1689"></a><a name="INDEX-1690"></a>
How could they find their way in?  Well, you can defeat interpolation
by using single quotes as your pattern delimiter.  In <tt class="literal">m'...'</tt>,
<tt class="literal">qr'...'</tt>, and <tt class="literal">s'...'...'</tt>, the single quotes suppress variable
interpolation and the processing of translation escapes, just as they
would in a single-quoted string.  Saying <tt class="literal">m'\ufrodo'</tt> won't find a
capitalized version of poor frodo.  However, since the "normal"
backslash characters aren't really processed on that level anyway,
<tt class="literal">m'\t\d'</tt> still matches a real tab followed by any digit.</p>

<p>Another way to defeat interpolation is through interpolation itself.
If you say:
<blockquote>
<pre class="programlisting">$var = '\U';
/${var}frodo/;</pre>
</blockquote>

poor frodo remains uncapitalized.  Perl won't redo the interpolation
pass for you just because you interpolated something that looks like
it might want to be reinterpolated.  You can't expect that to work any
more than you'd expect this double interpolation to work:
<blockquote>
<pre class="programlisting">$hobbit = 'Frodo';
$var = '$hobbit';           # (single quotes)
/$var/;                     # means m'$hobbit', not m'Frodo'.</pre>
</blockquote>
<a name="INDEX-1691"></a>
</p>

<p>Here's another example that shows how most backslashes are interpreted
by the regex parser, not by variable interpolation.  Imagine you have a
simple little <em class="emphasis">grep</em>-style program written in Perl:<a href="#FOOTNOTE-10">[10]</a>
<blockquote>
<pre class="programlisting">#!/usr/bin/perl
$pattern = shift;
while (&lt;&gt;) {
    print if /$pattern/o;
}</pre>
</blockquote>

If you name that program <em class="emphasis">pgrep</em> and call it this way:
<blockquote>
<pre class="programlisting">% <tt class="userinput"><b>pgrep '\t\d' *.c</b></tt>
</pre>
</blockquote>

then you'll find that it prints out all lines of all your C source
files in which a digit follows a tab.  You didn't have to do anything
special to get Perl to realize that <tt class="literal">\t</tt> was a tab.
If Perl's patterns <em class="emphasis">were</em> just double-quote
interpolated, you would have; fortunately, they aren't.  They're
recognized directly by the regex parser.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-10"></a>
<p>[10] If you
didn't know what a <em class="emphasis">grep</em> program was before, you will now.  No system
should be without <em class="emphasis">grep</em>--we believe <em class="emphasis">grep</em> is the most useful small
program ever invented.  (It logically follows that we don't believe
Perl is a small program.)</p>

</blockquote>

<p>
<a name="INDEX-1692"></a>
The real <em class="emphasis">grep</em> program has a <span class="option">-i</span> switch that turns off
case-sensitive matching.  You don't have to add such a switch to your
<em class="emphasis">pgrep</em> program; it can already handle that without modification.  You
just pass it a slightly fancier pattern, with an embedded <tt class="literal">/i</tt>
modifier:
<blockquote>
<pre class="programlisting">% <tt class="userinput"><b>pgrep '(?i)ring' LotR*.pod</b></tt>
</pre>
</blockquote>

That now searches for any of "Ring", "ring", "RING", and so on.
You don't see this feature too much in literal patterns, since you can
always just write <tt class="literal">/ring/i</tt>.  But for patterns passed in on the
command line, in web search forms, or embedded in configuration files,
it can be a lifesaver.  (Speaking of rings.)</p>




<h3 class="sect3">5.9.2.2. The qr// quote regex operator</h3>

<p>
<a name="INDEX-1693"></a>
Variables that interpolate into patterns necessarily do so at run
time, not compile time.  This slows down execution because Perl
has to check whether you've changed the contents of the variable;
if so, it would have to recompile the regular expression.
As mentioned in "Pattern-Matching Operators", if you promise never
to change the pattern, you can use the <tt class="literal">/o</tt> option to interpolate
and compile only once:
<blockquote>
<pre class="programlisting">print if /$pattern/o;</pre>
</blockquote>

Although that works fine in our <em class="emphasis">pgrep</em> program, in the general
case, it doesn't.  Imagine you have a slew of patterns, and you
want to match each of them in a loop, perhaps like this:
<blockquote>
<pre class="programlisting">foreach $item (@data) {
    foreach $pat (@patterns) {
        if ($item =~ /$pat/) { ... }
    }
}</pre>
</blockquote>

You couldn't write <tt class="literal">/$pat/o</tt> because the meaning of <tt class="literal">$pat</tt>
varies each time through the inner loop.</p>

<p>The solution to this is the <tt class="literal">qr/</tt><em class="replaceable">PATTERN</em><tt class="literal">/imosx</tt> operator.  This
operator quotes--and compiles--its <em class="replaceable">PATTERN</em> as a regular expression.
<em class="replaceable">PATTERN</em> is interpolated the same way as in
<tt class="literal">m/</tt><em class="replaceable">PATTERN</em><tt class="literal">/</tt>.  If
<tt class="literal">'</tt> is used as the delimiter, no interpolation of variables (or
the six translation escapes) is done.  The operator returns a Perl value that
may be used instead of the equivalent literal in a corresponding
pattern match or substitute.  
For example:
<blockquote>
<pre class="programlisting">$regex = qr/my.STRING/is;
s/$regex/something else/;</pre>
</blockquote>

is equivalent to:
<blockquote>
<pre class="programlisting">s/my.STRING/something else/is;</pre>
</blockquote>

So for our nested loop problem above, preprocess your pattern first
using a separate loop:
<blockquote>
<pre class="programlisting">@regexes = ();
foreach $pat (@patterns) {
    push @regexes, qr/$pat/;
}</pre>
</blockquote>

Or all at once using Perl's <tt class="literal">map</tt> operator:
<blockquote>
<pre class="programlisting">@regexes = map { qr/$_/ } @patterns;</pre>
</blockquote>

And then change the loop to use those precompiled regexes:
<blockquote>
<pre class="programlisting">foreach $item (@data) {
    foreach $re (@regexes) {
        if ($item =~ /$re/) { ... }
    }
}</pre>
</blockquote>

Now when you run the match, Perl doesn't have to create a compiled
regular expression on each <tt class="literal">if</tt> test, because it sees that it
already has one.</p>

<p>The result of a <tt class="literal">qr//</tt> may even be interpolated into a larger
match, as though it were a simple string:
<blockquote>
<pre class="programlisting">$regex = qr/$pattern/;
$string =~ /foo${regex}bar/;   # interpolate into larger patterns</pre>
</blockquote>

This time, Perl does recompile the pattern, but you could always chain
several <tt class="literal">qr//</tt> operators together into one.</p>

<p>The reason this works is because the <tt class="literal">qr//</tt> operator
returns a special kind of object that has a stringification overload
as described in <a href="ch13_01.htm">Chapter 13, "Overloading"</a>.  If you print
out the return value, you'll see the equivalent string:
<blockquote>
<pre class="programlisting">$re = qr/my.STRING/is;
print $re;                  # prints (?si-xm:my.STRING)</pre>
</blockquote>

The <tt class="literal">/s</tt> and <tt class="literal">/i</tt> modifiers were enabled in the pattern because
they were supplied to <tt class="literal">qr//</tt>.  The <tt class="literal">/x</tt> and <tt class="literal">/m</tt>, however,
are disabled because they were not.</p>

<p>Any time you interpolate strings of unknown provenance into a pattern,
you should be prepared to handle any exceptions thrown by the regex
compiler, in case someone fed you a string containing untamable beasties:
<blockquote>
<pre class="programlisting">$re = qr/$pat/is;                      # might escape and eat you
$re = eval { qr/$pat/is } || warn ...  # caught it in an outer cage</pre>
</blockquote>

For more on the <tt class="literal">eval</tt> operator, see <a href="ch29_01.htm">Chapter 29, "Functions"</a>.</p>

<a name="INDEX-1694"></a><a name="INDEX-1695"></a>







<h3 class="sect2">5.9.3. The Regex Compiler</h3>

<p>
<a name="INDEX-1696"></a><a name="INDEX-1697"></a>
After the variable interpolation pass has had its way with the string, the
regex parser finally gets a shot at trying to understand your regular
expression.  There's not actually a great deal that can go wrong at
this point, apart from messing up the parentheses, or using a sequence
of metacharacters that doesn't mean anything.  The parser does a
recursive-descent analysis of your regular expression and, if it
parses, turns it into a form suitable for interpretation by the
Engine (see the next section).  Most of the interesting stuff that goes on
in the parser involves optimizing your regular expression to run as
fast as possible.  We're not going to explain that part.  It's a trade
secret.  (Rumors that looking at the regular expression code will drive
you insane are greatly exaggerated.  We hope.)</p>

<p>But you might like to know what the parser actually thought of your
regular expression, and if you ask it politely, it will tell you.  By
saying <tt class="literal">use re "debug"</tt>, you can examine how the regex parser
processes your pattern.  (You can also see the same information by
using the <span class="option">-Dr</span> command-line switch, which is available to you if your
Perl was compiled with the <span class="option">-DDEBUGGING</span> flag during installation.)
<blockquote>
<pre class="programlisting">#!/usr/bin/perl
use re "debug";
"Smeagol" =~ /^Sm(.*)g[aeiou]l$/;</pre>
</blockquote>

The output is below.  You can see that prior to execution Perl
compiles the regex and assigns meaning to the components of the
pattern: <tt class="literal">BOL</tt> for the beginning of line
(<tt class="literal">^</tt>), <tt class="literal">REG_ANY</tt> for the dot, and so
on:
<blockquote>
<pre class="programlisting">Compiling REx `^Sm(.*)g[aeiou]l$'
size 24 first at 2
rarest char l at 0
rarest char S at 0
   1: BOL(2)
   2: EXACT &lt;Sm&gt;(4)
   4: OPEN1(6)
   6:   STAR(8)
   7:     REG_ANY(0)
   8: CLOSE1(10)
  10: EXACT &lt;g&gt;(12)
  12: ANYOF[aeiou](21)
  21: EXACT &lt;l&gt;(23)
  23: EOL(24)
  24: END(0)
anchored `Sm' at 0 floating `l'$ at 4..2147483647
     (checking anchored) anchored(BOL) minlen 5 
Omitting $` $&amp; $' support.</pre>
</blockquote>

Some of the lines summarize the conclusions of the regex optimizer.  It
knows that the string must start with "<tt class="literal">Sm</tt>", and that therefore
there's no reason to do the ordinary left-to-right scan.  It knows that
the string must end with an "<tt class="literal">l</tt>", so it can reject out of hand any
string that doesn't.  It knows that the string must be at least five
characters long, so it can ignore any string shorter than that right
off the bat.  It also knows what the rarest character in each constant
string is, which can help in searching "studied" strings.  (See
<tt class="literal">study</tt> in <a href="ch29_01.htm">Chapter 29, "Functions"</a>.)</p>

<p>It then goes on to trace how it executes the pattern:
<blockquote>
<pre class="programlisting">EXECUTING...
 
Guessing start of match, REx `^Sm(.*)g[aeiou]l$' against `Smeagol'...
Guessed: match at offset 0
Matching REx `^Sm(.*)g[aeiou]l$' against `Smeagol'
  Setting an EVAL scope, savestack=3
   0 &lt;&gt; &lt;Smeagol&gt;         |  1:  BOL
   0 &lt;&gt; &lt;Smeagol&gt;         |  2:  EXACT &lt;Sm&gt;
   2 &lt;Sm&gt; &lt;eagol&gt;         |  4:  OPEN1
   2 &lt;Sm&gt; &lt;eagol&gt;         |  6:  STAR
                           REG_ANY can match 5 times out of 32767...
  Setting an EVAL scope, savestack=3
   7 &lt;Smeagol&gt; &lt;&gt;         |  8:    CLOSE1
   7 &lt;Smeagol&gt; &lt;&gt;         | 10:    EXACT &lt;g&gt;
                              failed...
   6 &lt;Smeago&gt; &lt;l&gt;         |  8:    CLOSE1
   6 &lt;Smeago&gt; &lt;l&gt;         | 10:    EXACT &lt;g&gt;
                              failed...
   5 &lt;Smeag&gt; &lt;ol&gt;         |  8:    CLOSE1
   5 &lt;Smeag&gt; &lt;ol&gt;         | 10:    EXACT &lt;g&gt;
                              failed...
   4 &lt;Smea&gt; &lt;gol&gt;         |  8:    CLOSE1
   4 &lt;Smea&gt; &lt;gol&gt;         | 10:    EXACT &lt;g&gt;
   5 &lt;Smeag&gt; &lt;ol&gt;         | 12:    ANYOF[aeiou]
   6 &lt;Smeago&gt; &lt;l&gt;         | 21:    EXACT &lt;l&gt;
   7 &lt;Smeagol&gt; &lt;&gt;         | 23:    EOL
   7 &lt;Smeagol&gt; &lt;&gt;         | 24:    END
Match successful!
Freeing REx: `^Sm(.*)g[aeiou]l$'</pre>
</blockquote>
If you follow the stream of whitespace down the middle of
<tt class="literal">Smeagol</tt>, you can actually see how the Engine
overshoots to let the <tt class="literal">.*</tt> be as greedy as possible,
then backtracks on that until it finds a way for the rest of the
pattern to match.  But that's what the next section is about.</p>





<a name="ch05-sect-engine"></a>
<h3 class="sect2">5.9.4. The Little Engine That /Could(n't)?/</h3>

<a name="INDEX-1698"></a><a name="INDEX-1699"></a><a name="INDEX-1700"></a><a name="INDEX-1701"></a><a name="INDEX-1702"></a><a name="INDEX-1703"></a>
<p>And now we'd like to tell you the story of the Little Regex Engine that
says, "I think I can.  I think I can.  I think I can."</p>

<p>In this section, we lay out the rules used by Perl's regular expression
engine to match your pattern against a string.  The Engine is
extremely persistent and hardworking.  It's quite capable of working
even after you think it should quit.  The Engine doesn't give up until
it's certain there's no way to match the pattern against the string.
The Rules below explain how the Engine "thinks it can" for as
long as possible, until it <em class="emphasis">knows</em> it can or can't.  The problem for our
Engine is that its task is not merely to pull a train over a hill.  It
has to search a (potentially) very complicated space of possibilities,
keeping track of where it has been and where it hasn't.</p>

<p>
<a name="INDEX-1704"></a>
The Engine uses a nondeterministic finite-state automaton (NFA, not to
be confused with NFL, a nondeterministic football league) to find a
match.  That just means that it keeps track of what it has tried and
what it hasn't, and when something doesn't pan out, it backs up and
tries something else.  This is known as <em class="emphasis">backtracking</em>.  (Er, sorry,
we didn't invent these terms.  Really.)  The Engine is capable of
trying a million subpatterns at one spot, then giving up on all those,
backing up to within one choice of the beginning, and trying the
million subpatterns again at a different spot.  The Engine is not
terribly intelligent; just persistent, and thorough.  If you're cagey,
you can give the Engine an efficient pattern that doesn't let it do a
lot of silly backtracking.</p>

<p>When someone trots out a phrase like "Regexes choose the leftmost,
longest match", that means that Perl generally prefers the leftmost
match over longest match.  But the Engine doesn't realize it's
"preferring" anything, and it's not really thinking at all, just
gutting it out.  The overall preferences are an emergent behavior
resulting from many individual and unrelated choices.  Here are those
choices:<a href="#FOOTNOTE-11">[11]</a>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-11"></a>
<p>[11] Some of these choices may be skipped if the regex
optimizer has any say, which is equivalent to the Little Engine
simply jumping through the hill via quantum tunneling.  But for this
discussion we're pretending the optimizer doesn't exist.</p>

</blockquote>

<dl>
<dt>
<b>Rule 1</b>
</dt>
<dd>
<p>
<a name="INDEX-1705"></a>
The Engine tries to match as far left in the string as it can, such
that the entire regular expression matches under Rule&nbsp;2.</p>

<p>The Engine starts just before the first character and tries to match
the entire pattern starting there.  The entire pattern matches if and
only if the Engine reaches the end of the pattern before it runs off
the end of the string.  If it matches, it quits immediately--it
doesn't keep looking for a "better" match, even though the pattern
might match in many different ways.</p>

<p>If it is unable to match the pattern at the first position in the
string, it admits temporary defeat and moves to the next position in
the string, between the first and second characters, and tries all the
possibilities again.  If it succeeds, it stops.  If it fails, it
continues on down the string.  The pattern match as a whole doesn't
fail until it has tried to match the entire regular expression at every
position in the string, including after the last character.</p>

<p>A string of <em class="emphasis">n</em> characters actually provides
<em class="emphasis">n</em><tt class="literal">+ 1</tt> positions to match at.
That's because the beginnings and the ends of matches are
<em class="emphasis">between</em> the characters of the string.  This rule
sometimes surprises people when they write a pattern like
<tt class="literal">/x*/</tt> that can match zero or more
"<tt class="literal">x</tt>" characters. If you try that pattern on a string
like "<tt class="literal">fox</tt>", it won't find the
"<tt class="literal">x</tt>".  Instead, it will immediately match the null
string before the "<tt class="literal">f</tt>" and never look further.  If
you want it to match one or more <tt class="literal">x</tt> characters, you
need to use <tt class="literal">/x+/</tt> instead.  See the quantifiers
under Rule&nbsp;5.</p>

<p>A corollary to this rule is that any pattern matching the null string
is guaranteed to match at the leftmost position in the string (in the
absence of any zero-width assertions to the contrary).</p>
</dd>


<dt>
<b>Rule 2</b>
</dt>
<dd>
<p>When the Engine encounters a set of alternatives (separated by <tt class="literal">|</tt>
symbols), either at the top level or at the current "cluster" level, it
tries them left-to-right, stopping on the first successful match that
allows successful completion of the entire pattern.</p>

<p>
<a name="INDEX-1706"></a>
A set of alternatives matches a string if any of the alternatives match
under Rule&nbsp;3.  If none of the alternatives matches, it backtracks to
the Rule that invoked this Rule, which is usually Rule&nbsp;1, but could be
Rule&nbsp;4 or 6, if we're within a cluster.  That rule will then look for a
new position at which to apply Rule&nbsp;2.</p>

<p>If there's only one alternative, then either it matches or it doesn't,
and Rule&nbsp;2 still applies.  (There's no such thing as zero alternatives,
because a null string always matches.)</p>
</dd>


<dt>
<b>Rule 3</b>
</dt>
<dd>
<p>Any particular alternative matches if every <em class="emphasis">item</em> listed in the alternative
matches sequentially according to Rules&nbsp;4 and 5 (such that the entire
regular expression can be satisfied).</p>

<p>An item consists of either an <em class="emphasis">assertion</em>, which is covered in Rule&nbsp;4,
or a <em class="emphasis">quantified atom</em>, covered by Rule&nbsp;5.  Items that have choices on
how to match are given a "pecking order" from left to right.  If the
items cannot be matched in order, the Engine backtracks to the next
alternative under Rule&nbsp;2.</p>

<p>
<a name="INDEX-1707"></a>
Items that must be matched sequentially aren't separated in the regular
expression by anything syntactic--they're merely juxtaposed in the
order they must match. When you ask to match <tt class="literal">/^foo/</tt>, you're actually
asking for four items to be matched one after the other.  The first is
a zero-width assertion, matched under Rule&nbsp;4, and the other three are
ordinary characters that must match themselves, one after the other,
under Rule&nbsp;5.</p>

<p>The left-to-right pecking order means that in a pattern like:
<blockquote>
<pre class="programlisting">/x*y*/</pre>
</blockquote>
<tt class="literal">x*</tt> gets to pick one way to match, and then <tt class="literal">y*</tt> tries all its ways. If that fails, then <tt class="literal">x*</tt> gets to pick its second choice, and make <tt class="literal">y*</tt>
try all of its ways again.  And so on.  The items to the right "vary
faster", to borrow a phrase from multi-dimensional arrays.</p>
</dd>


<dt>
<b>Rule 4</b>
</dt>
<dd>
<p>
<a name="INDEX-1708"></a>
If an assertion does not match at the current position, the Engine
backtracks to Rule&nbsp;3 and retries higher-pecking-order items with
different choices.</p>

<p>
<a name="INDEX-1709"></a><a name="INDEX-1710"></a>
Some assertions are fancier than others.  Perl supports many regex
extensions, some of which are zero-width assertions.  For example, the
positive lookahead <tt class="literal">(?=...)</tt> and the negative lookahead <tt class="literal">(?!...)</tt> don't actually match any characters, but merely assert that the regular
expression represented by <tt class="literal">...</tt> would (or would not) match at this
point, were we to attempt it, hypothetically speaking.<a href="#FOOTNOTE-12">[12]</a><a name="INDEX-1711"></a><a name="INDEX-1712"></a><a name="INDEX-1713"></a>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-12"></a>
<p>[12]In actual
fact, the Engine <em class="emphasis">does</em> attempt it.  The Engine goes back to Rule&nbsp;2 to
test the subpattern, and then wipes out any record of how much string
was eaten, returning only the success or failure of the subpattern as
the value of the assertion.  (It does, however, remember any captured
substrings.)</p>

</blockquote>
</dd>


<dt>
<b>Rule 5</b>
</dt>
<dd>
<p>A quantified atom matches only if the atom itself matches some number
of times that is allowed by the quantifier.  (The atom itself is matched
according to Rule&nbsp;6.)</p>

<p>Different quantifiers require different numbers of matches, and most
of them allow a range of numbers of matches.  Multiple matches must
all match in a row; that is, they must be adjacent within the string.
An unquantified atom is assumed to have a quantifier requiring exactly
one match (that is, <tt class="literal">/x/</tt> is the same as
<tt class="literal">/x{1}/</tt>).  If no match can be found at the current
position for any allowed quantity of the atom in question, the Engine
backtracks to Rule&nbsp;3 and retries higher-pecking-order items with
different choices.</p>

<p>The quantifiers are <tt class="literal">*</tt>, <tt class="literal">+</tt>, <tt class="literal">?</tt>, <tt class="literal">*?</tt>, <tt class="literal">+?</tt>, <tt class="literal">??</tt>, and the various
brace forms.  If you use the <tt class="literal">{</tt><em class="replaceable">COUNT</em><tt class="literal">}</tt> form, then there is no
choice, and the atom must match exactly that number of times or not at
all.  Otherwise, the atom can match over a range of quantities, and
the Engine keeps track of all the choices so that it can backtrack if
necessary.  But then the question arises as to which of these choices
to try first.  One could start with the maximal number of matches and
work down, or the minimal number of matches and work up.</p>

<p>
<a name="INDEX-1714"></a><a name="INDEX-1715"></a><a name="INDEX-1716"></a>
The traditional quantifiers (without a trailing question mark) specify
<em class="emphasis">greedy</em> matching; that is, they attempt to match as many characters
as possible.  To find the greediest match, the Engine has to be a
little bit careful.  Bad guesses are potentially rather expensive, so
the Engine doesn't actually count down from the maximum value, which
after all could be Very Large and cause millions of bad guesses.  What
the Engine actually does is a little bit smarter: it first counts <em class="emphasis">up</em>
to find out how many matching atoms (in a row) are really there in the
string, and then it uses <em class="emphasis">that</em> actual maximum as its first choice.
(It also remembers all the shorter choices in case the longest one
doesn't pan out.)  It then (at long last) tries to match the rest of
the pattern, assuming the longest choice to be the best.  If the
longest choice fails to produce a match for the rest of the pattern, it
backtracks and tries the next longest.</p>

<p>If you say <tt class="literal">/.*foo/</tt>, for example, it will try to match the maximal
number of "any" characters (represented by the dot) clear out to the
end of the line before it ever tries looking for "<tt class="literal">foo</tt>"; and then
when the "<tt class="literal">foo</tt>" doesn't match there (and it can't, because there's
not enough room for it at the end of the string), the Engine will back
off one character at a time until it finds a "<tt class="literal">foo</tt>".  If there is
more than one "<tt class="literal">foo</tt>" in the line, it'll stop on the last one, since
that will really be the <em class="emphasis">first</em> one it encounters as it backtracks. When the entire pattern succeeds using some particular length of <tt class="literal">.*</tt>,
the Engine knows it can throw away all the other shorter choices for
<tt class="literal">.*</tt> (the ones it would have used had the current "<tt class="literal">foo</tt>" not panned out).</p>

<p>By placing a question mark after any greedy quantifier, you turn it into
a frugal quantifier that chooses the smallest quantity for the first try.
So if you say <tt class="literal">/.*?foo/</tt>, the <tt class="literal">.*?</tt> first tries to match 0
characters, then 1 character, then 2, and so on until it can match the
"<tt class="literal">foo</tt>".  Instead of backtracking backward, it backtracks forward, so
to speak, and ends up finding the first "<tt class="literal">foo</tt>" on the line instead of
the last.</p>
</dd>


<dt>
<b>Rule 6</b>
</dt>
<dd>
<p>
<a name="INDEX-1717"></a>
Each atom matches according to the designated semantics of its type. If the atom doesn't match (or does match, but doesn't allow a match of
the rest of the pattern), the Engine backtracks to Rule&nbsp;5 and tries the
next choice for the atom's quantity.</p>

<p>Atoms match according to the following types:</p>

<ul>
<li>
<p>
<a name="INDEX-1718"></a><a name="INDEX-1719"></a>
A regular expression in parentheses, <tt class="literal">(...)</tt>, matches whatever the
regular expression (represented by <tt class="literal">...</tt>) matches according to
Rule&nbsp;2.  Parentheses therefore serve as a clustering operator for
quantification.  Bare parentheses also have the side effect of capturing
the matched substring for later use in a <em class="emphasis">backreference</em>.  This side
effect can be suppressed by using <tt class="literal">(?:...)</tt> instead, which has only
the clustering semantics--it doesn't store anything in <tt class="literal">$1</tt>, <tt class="literal">$2</tt>,
and so on.  Other forms of parenthetical atoms (and assertions) are
possible--see the rest of this chapter.</p>
</li>
<li>
<p>A dot matches any character, except maybe newline.</p>
</li>
<li>
<p>
<a name="INDEX-1720"></a><a name="INDEX-1721"></a><a name="INDEX-1722"></a><a name="INDEX-1723"></a><a name="INDEX-1724"></a><a name="INDEX-1725"></a>
A list of characters in square brackets (a <em class="emphasis">character class</em>)matches any one of the characters specified by the list.</p>
</li>
<li>
<p>
<a name="INDEX-1726"></a><a name="INDEX-1727"></a><a name="INDEX-1728"></a>
A backslashed letter matches either a particular character or a character
from a set of characters, as listed in
<a href="ch05_03.htm">Table 5-7</a>.</p>
</li>
<li>
<p>Any other backslashed character matches that character.</p>
</li>
<li>
<p>
<a name="INDEX-1729"></a>
Any character not mentioned above matches itself.</p>
</li>
</ul>
</dd>

</dl>

<p>That all sounds rather complicated, but the upshot of it is that, for
each set of choices given by a quantifier or alternation, the Engine
has a knob it can twiddle.  It will twiddle those knobs until the
entire pattern matches.  The Rules just say in which order the
Engine is allowed to twiddle those knobs.  Saying the Engine prefers
the leftmost match merely means it twiddles the start position knob the
slowest.  And backtracking is just the process of untwiddling the knob
you just twiddled in order to try twiddling a knob higher in the pecking
order, that is, one that varies slower.</p>

<p>Here's a more concrete example, a program that detects when
two consecutive words share a common ending and beginning:
<blockquote>
<pre class="programlisting">$a = 'nobody';
$b = 'bodysnatcher';
if ("$a $b" =~ /^(\w+)(\w+) \2(\w+)$/) {
    print "$2 overlaps in $1-$2-$3\n";
}</pre>
</blockquote>

This prints:
<blockquote>
<pre class="programlisting">body overlaps in no-body-snatcher</pre>
</blockquote>

You might think that <tt class="literal">$1</tt> would first grab up all of "<tt class="literal">nobody</tt>" due to
greediness.  And in fact, it does--at first.  But once it's done so,
there aren't any further characters to put in <tt class="literal">$2</tt>, which needs characters
put into it because of the <tt class="literal">+</tt> quantifier.  So the Engine backs up and <tt class="literal">$1</tt>
begrudgingly gives up one character to <tt class="literal">$2</tt>.  This time the space
character matches successfully, but then it sees <tt class="literal">\2</tt>, which
represents a measly "<tt class="literal">y</tt>".  The next character in the string is not a
"<tt class="literal">y</tt>", but a "<tt class="literal">b</tt>".  This makes the Engine back up all the way and
try several more times, eventually forcing <tt class="literal">$1</tt> to surrender the body to
<tt class="literal">$2</tt>.  Habeas corpus, as it were.</p>

<p>Actually, that won't quite work out if the overlap is itself the
product of a doubling, as in the two words "<tt class="literal">rococo</tt>" and
"<tt class="literal">cocoon</tt>".  The algorithm above would have decided that the
overlapping string, <tt class="literal">$2</tt>, must be just "<tt class="literal">co</tt>" rather than "<tt class="literal">coco</tt>".
But we don't want a "<tt class="literal">rocococoon</tt>"; we want a "<tt class="literal">rococoon</tt>".  Here's
one of those places you can outsmart the Engine.  Adding a minimal
matching quantifier to the <tt class="literal">$1</tt> part gives the much better pattern
<tt class="literal">/^(\w+?)(\w+) \2(\w+)$/</tt>, which does exactly what we want.</p>

<p>For a much more detailed discussion of the pros and cons of various
kinds of regular expression engines, see Jeffrey Friedl's book,
<em class="emphasis">Mastering Regular Expressions</em>.  Perl's regular expression Engine
works very well for many of the everyday problems you want to solve
with Perl, and it even works okay for those not-so-everyday problems,
if you give it a little respect and understanding.</p>

<a name="INDEX-1730"></a><a name="INDEX-1731"></a><a name="INDEX-1732"></a>



<!-- BOTTOM NAV BAR -->

<hr width="684" align="left">
<div class="navbar">
<table width="684" border="0">
<tr>
<td align="left" valign="top" width="228"><a href="ch05_08.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="228"><a href="ch05_10.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="228">5.8. Alternation</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="228">5.10. Fancy Patterns</td>
</tr>
</table>
</div>
<hr width="684" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="../cookbook/index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm">
</map>

<!-- END OF BODY -->

</body>
</html>
