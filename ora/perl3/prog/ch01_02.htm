<html>
<head>
<title>Natural and Artificial Languages (Programming Perl)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Natural and Artificial Languages">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home">
<map name="banner-map"><AREA SHAPE="rect" coords="1,-2,616,66" HREF="index.htm" ALT="Programming Perl"><AREA SHAPE="rect" coords="629,-11,726,25" HREF="jobjects/fsearch.htm" ALT="Search this book">
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="684" border="0">
<tr>
<td align="left" valign="top" width="228"><a href="ch01_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="228"><a href="ch01_01.htm"></a></td><td align="right" valign="top" width="228"><a href="ch01_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>



<h2 class="sect1">1.2. Natural and Artificial Languages</h2>

<a name="INDEX-21"></a><a name="INDEX-22"></a><a name="INDEX-23"></a>
<p>Languages were first invented by humans, for the benefit of humans.
In the annals of computer science, this fact has occasionally been
forgotten.<a href="#FOOTNOTE-2">[2]</a> Since Perl was designed (loosely speaking)
by an occasional linguist, it was designed to work smoothly in the
same ways that natural language works smoothly.  Naturally, there
are many aspects to this, since natural language works well at many
levels simultaneously.  We could enumerate many of these linguistic
principles here, but the most important principle of language design
is that easy things should be easy, and hard things should
be possible.  (Actually, that's two principles.)  They may seem
obvious to you, but many computer languages fail at one or the other.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-2"></a>
<p>[2] More precisely, this fact has occasionally been
remembered.</p>

</blockquote>

<p>Natural languages are good at both because people are continually trying
to express both easy things and hard things, so the language evolves to
handle both.  Perl was designed first of all to evolve, and indeed it
has evolved.  Many people have contributed to the evolution of Perl over
the years.  We often joke that a camel is a horse designed by a
committee, but if you think about it, the camel is pretty well adapted
for life in the desert.  The camel has evolved to be relatively
self-sufficient.  (On the other hand, the camel has not evolved
to smell good.  Neither has Perl.)  This is one of the many strange
reasons we picked the camel to be Perl's mascot, but it doesn't have
much to do with linguistics.</p>

<p>Now when someone utters the word "linguistics", many folks focus in on one
of two things.  Either they think of words, or they think of sentences.
But words and sentences are just two handy ways to "chunk" speech.
Either may be broken down into smaller units of meaning or combined
into larger units of meaning.  And the meaning of any unit depends
heavily on the syntactic, semantic, and pragmatic context in which the
unit is located.  Natural language has words of various sorts: nouns and
verbs and such.  If someone says "dog" in isolation, you think of it as a noun,
but you can also use the word in other ways.  That is, a noun can function
as a verb, an adjective, or an adverb when the context demands it.  If
you dog a dog during the dog days of summer, you'll be a dog tired
dogcatcher.<a href="#FOOTNOTE-3">[3]</a>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-3"></a>
<p>[3] And you're probably dog tired of all this
linguistics claptrap. But we'd like you to understand why Perl is
different from the typical computer language, doggone it!</p>

</blockquote>

<p>Perl also evaluates words differently in various contexts.  We will see
how it does that later.  Just remember that Perl is trying to understand
what you're saying, like any good listener does.  Perl works pretty hard
to try to keep up its end of the bargain.  Just say what you mean, and
Perl will usually "get it".  (Unless you're talking nonsense, of
course--the Perl parser understands Perl a lot better than either
English or Swahili.)</p>

<p>
<a name="INDEX-24"></a>
But back to nouns.  A noun can name a particular object, or it can name
a class of objects generically without specifying which one is
currently being referred to.  Most computer languages make this
distinction, only we call the particular one a value and the generic
one a variable.  A value just exists somewhere, who knows where, but a
variable gets associated with one or more values over its lifetime.  So
whoever is interpreting the variable has to keep track of that
association.  That interpreter may be in your brain or in your
computer.
<a name="INDEX-25"></a><a name="INDEX-26"></a><a name="INDEX-27"></a>
</p>


<h3 class="sect2">1.2.1. Variable Syntax</h3>

<a name="INDEX-28"></a><a name="INDEX-29"></a><a name="INDEX-30"></a>
<p>A variable is just a handy place to keep something, a place with a name,
so you know where to find your special something when you come back
looking for it later.  As in real life, there are various kinds of
places to store things, some of them rather private, and some of them
out in public.  Some places are temporary, and other places are more
permanent.  Computer scientists love to talk about the "scope" of
variables, but that's all they mean by it.  Perl has various handy ways
of dealing with scoping issues, which you'll be happy to learn later
when the time is right.  Which is not yet.  (Look up the adjectives
<tt class="literal">local</tt>, <tt class="literal">my</tt>, and <tt class="literal">our</tt> in <a href="ch29_01.htm">Chapter 29, "Functions"</a>, when you get curious, or see
"Scoped Declarations" in
<a href="ch04_01.htm">Chapter 4, "Statements and Declarations"</a>.)</p>

<p>
<a name="INDEX-31"></a><a name="INDEX-32"></a><a name="INDEX-33"></a><a name="INDEX-34"></a><a name="INDEX-35"></a>
But a more immediately useful way of classifying variables is by what
sort of data they can hold.  As in English, Perl's primary type
distinction is between singular and plural data.  Strings and numbers
are singular pieces of data, while lists of strings or numbers are
plural. (And when we get to object-oriented programming, you'll find
that the typical object looks singular from the outside but plural from
the inside, like a class of students.)  We call a singular variable a
<em class="emphasis">scalar</em>, and a plural variable an <em class="emphasis">array</em>.  Since a string can be
stored in a scalar variable, we might write a slightly longer (and
commented) version of our first example like this:
<blockquote>
<pre class="programlisting">$phrase = "Howdy, world!\n";          # Set a variable.
print $phrase;                        # Print the variable.</pre>
</blockquote>

Note that we did not have to predefine what kind of variable <tt class="literal">$phrase</tt>
is.  The <tt class="literal">$</tt> character tells Perl that <tt class="literal">phrase</tt> is a scalar variable,
that is, one containing a singular value.  An array variable, by
contrast, would start with an <tt class="literal">@</tt> character.  (It may help you to
remember that a <tt class="literal">$</tt> is a stylized "s", for "scalar", while <tt class="literal">@</tt> is a
stylized "a", for "array".)
<a name="INDEX-36"></a><a name="INDEX-37"></a>
</p>

<p>
<a name="INDEX-38"></a><a name="INDEX-39"></a><a name="INDEX-40"></a><a name="INDEX-41"></a>
Perl has some other variable types, with unlikely names like "hash",
"handle", and "typeglob".  Like scalars and arrays, these types of
variables are also preceded by funny characters.  For completeness, 
here are all the funny characters you'll encounter:</p>

<a name="perl3-tab-funny"></a>
<table border="1">

<tr>
<th>Type</th>
<th>Character</th>
<th>Example</th>
<th>Is a name for:</th>
</tr>




<tr>
<td>Scalar</td>
<td><tt class="literal">$</tt></td>
<td><tt class="literal">$cents</tt></td>
<td>An individual value (number or string)</td>
</tr>

<tr>
<td>Array</td>
<td><tt class="literal">@</tt></td>
<td><tt class="literal">@large</tt></td>
<td>A list of values, keyed by number</td>
</tr>

<tr>
<td>Hash</td>
<td><tt class="literal">%</tt></td>
<td><tt class="literal">%interest</tt></td>
<td>A group of values, keyed by string<a name="INDEX-42"></a></td>
</tr>

<tr>
<td>Subroutine</td>
<td><tt class="literal">&amp;</tt></td>
<td><tt class="literal">&amp;how</tt></td>
<td>A callable chunk of Perl code<a name="INDEX-43"></a><a name="INDEX-44"></a></td>
</tr>

<tr>
<td>Typeglob</td>
<td><tt class="literal">*</tt></td>
<td><tt class="literal">*struck</tt></td>
<td>Everything named <tt class="literal">struck</tt><a name="INDEX-45"></a><a name="INDEX-46"></a></td>
</tr>


</table>
<p>Some language purists
point to these funny characters as a reason to abhor Perl.  This is
superficial.  These characters have many benefits, not least of which
is that variables can be interpolated into strings with no additional
syntax.  Perl scripts are also easy to read (for people who have
bothered to learn Perl!) because the nouns stand out from verbs.  And
new verbs can be added to the language without breaking old scripts.
(We told you Perl was designed to evolve.)  And the noun analogy is not
frivolous--there is ample precedent in English and other languages for
requiring grammatical noun markers.  It's how we think!  (We think.)</p>


<h3 class="sect3">1.2.1.1. Singularities</h3>

<a name="INDEX-47"></a><a name="INDEX-48"></a>
<p>
<a name="INDEX-49"></a>
From our earlier example, you can see that scalars may be assigned a new value
with the <tt class="literal">=</tt> operator, just as in many other computer languages. Scalar
variables can be assigned any form of scalar value: integers,
floating-point numbers, strings, and even esoteric things like
references to other variables, or to objects. There are many ways of
generating these values for assignment.</p>

<p>
<a name="INDEX-50"></a><a name="INDEX-51"></a><a name="INDEX-52"></a><a name="INDEX-53"></a><a name="INDEX-54"></a><a name="INDEX-55"></a><a name="INDEX-56"></a><a name="INDEX-57"></a><a name="INDEX-58"></a>
As in the Unix<a href="#FOOTNOTE-4">[4]</a>shell, you can use different quoting mechanisms to
make different kinds of values.  Double quotation marks (double quotes)
do <em class="emphasis">variable interpolation</em><a href="#FOOTNOTE-5">[5]</a> and
<em class="emphasis">backslash interpolation</em> (such as turning
<tt class="literal">\n</tt> into a newline) while single quotes suppress
interpolation.  And backquotes (the ones leaning to
the left) will execute an external program and return the output of the
program, so you can capture it as a single string containing all the
lines of output.
<blockquote>
<pre class="programlisting">$answer = 42;                # an integer
$pi = 3.14159265;            # a "real" number
$avocados = 6.02e23;         # scientific notation
$pet = "Camel";              # string
$sign = "I love my $pet";    # string with interpolation
$cost = 'It costs $100';     # string without interpolation
$thence = $whence;           # another variable's value
$salsa = $moles * $avocados; # a gastrochemical expression
$exit = system("vi $file");  # numeric status of a command
$cwd = `pwd`;                # string output from a command</pre>
</blockquote>
<a name="INDEX-59"></a><a name="INDEX-60"></a><a name="INDEX-61"></a><a name="INDEX-62"></a>

And while we haven't covered fancy values yet, we should point out that
scalars may also hold references to other data structures, including
subroutines and objects.
<blockquote>
<pre class="programlisting">$ary = \@myarray;            # reference to a named array
$hsh = \%myhash;             # reference to a named hash
$sub = \&amp;mysub;              # reference to a named subroutine

$ary = [1,2,3,4,5];          # reference to an unnamed array
$hsh = {Na =&gt; 19, Cl =&gt; 35}; # reference to an unnamed hash
$sub = sub { print $state }; # reference to an unnamed subroutine

$fido = new Camel "Amelia";  # reference to an object</pre>
</blockquote>
<a name="INDEX-63"></a>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-4"></a>
<p>[4]Here and elsewhere, when we say Unix, we mean
any operating system resembling Unix, including BSD, Linux, and, of course,
Unix.</p>

</blockquote>
<blockquote class="footnote">

<a name="FOOTNOTE-5"></a>
<p>[5]Sometimes
called "substitution" by
shell programmers, but we prefer to reserve that word for something
else in Perl.  So please call it interpolation.  We're using the term
in the textual sense ("this passage is a Gnostic interpolation") rather
than in the mathematical sense ("this point on the graph is an
interpolation between two other points").</p>

</blockquote>

<p>
<a name="INDEX-64"></a><a name="INDEX-65"></a><a name="INDEX-66"></a><a name="INDEX-67"></a><a name="INDEX-68"></a><a name="INDEX-69"></a><a name="INDEX-70"></a>
If you use a variable that has never been assigned a value, the
uninitialized variable automatically springs into existence as needed.
Following the principle of least surprise, the variable is created with a null
value, either <tt class="literal">""</tt> or <tt class="literal">0</tt>.  Depending on where you use them, variables
will be interpreted automatically as strings, as numbers, or as "true"
and "false" values (commonly called Boolean values).  Remember
how important context is in human languages.  In Perl, various operators
expect certain kinds of singular values as parameters, so we will speak
of those operators as "providing" or "supplying" a scalar context to those
parameters. Sometimes we'll be more specific, and say it supplies a
numeric context, a string context, or a Boolean context to those
parameters.  (Later we'll also talk about list context, which is the
opposite of scalar context.)  Perl will automatically convert the data
into the form required by the current context, within reason.  For
example, suppose you said this:
<blockquote>
<pre class="programlisting">$camels = '123';
print $camels + 1, "\n";</pre>
</blockquote>

The original value of <tt class="literal">$camels</tt> is a string, but it is converted to a
number to add <tt class="literal">1</tt> to it, and then converted back to a string to be
printed out as <tt class="literal">124</tt>.  The newline, represented by <tt class="literal">"\n"</tt>, is also in
string context, but since it's already a string, no conversion is
necessary.  But notice that we had to use double quotes there--using
single quotes to say <tt class="literal">'\n'</tt> would result in a two-character string
consisting of a backslash followed by an "<tt class="literal">n</tt>", which is not a newline
by anybody's definition.</p>

<p>
<a name="INDEX-71"></a><a name="INDEX-72"></a><a name="INDEX-73"></a><a name="INDEX-74"></a>
So, in a sense, double quotes and single quotes are yet another way of
specifying context.  The interpretation of the innards of a quoted
string depends on which quotes you use.  (Later, we'll see some other
operators that work like quotes syntactically but use the string in
some special way, such as for pattern matching or substitution.  These
all work like double-quoted strings too.  The <em class="emphasis">double-quote</em> context is
the "interpolative" context of Perl, and is supplied by many operators
that don't happen to resemble double quotes.)</p>

<p>Similarly, a reference behaves as a reference when you give it a
"dereference" context, but otherwise acts like a simple scalar value.
For example, we might say:
<blockquote>
<pre class="programlisting">$fido = new Camel "Amelia";
if (not $fido) { die "dead camel"; }
$fido-&gt;saddle();</pre>
</blockquote>

Here we create a reference to a Camel object and put it into the
variable <tt class="literal">$fido</tt>.  On the next line, we test <tt class="literal">$fido</tt> as a scalar Boolean
to see if it is "true", and we throw an exception (that is, we
complain) if it is not true, which in this case would mean that the
<tt class="literal">new Camel</tt> constructor failed to make a proper Camel object.  But on
the last line, we treat <tt class="literal">$fido</tt> as a reference by asking it to look up
the <tt class="literal">saddle()</tt> method for the object held in <tt class="literal">$fido</tt>, which happens
to be a Camel, so Perl looks up the <tt class="literal">saddle()</tt> method for Camel
objects.  More about that later.  For now, just remember that context
is important in Perl because that's how Perl knows what you want
without your having to say it explicitly, as many other computer
languages force you to do.</p>




<h3 class="sect3">1.2.1.2. Pluralities</h3>

<a name="INDEX-75"></a><a name="INDEX-76"></a><a name="INDEX-77"></a><a name="INDEX-78"></a><a name="INDEX-79"></a>
<p>Some kinds of variables hold multiple values that are logically
tied together.  Perl has two types of multivalued variables: arrays
and hashes.  In many ways, these behave like scalars--they spring into
existence with nothing in them when needed, for instance.  But they
are different from scalars in that, when you assign to them, they
supply a <em class="emphasis">list</em> context to the right side of the assignment rather
than a scalar context.</p>

<p>
<a name="INDEX-80"></a><a name="INDEX-81"></a>
Arrays and hashes also differ from each other.
You'd use an array when you want to look something up by number.  You'd
use a hash when you want to look something up by name.  The two concepts
are complementary.  You'll often see people using an array to translate
month numbers into month names, and a corresponding hash to translate
month names back into month numbers.  (Though hashes aren't limited to
holding only numbers.  You could have a hash that translates month names
to birthstone names, for instance.)</p>


<h3 class="sect4">1.2.1.2.1. Arrays.</h3>

<p>
<a name="INDEX-82"></a>
An <em class="emphasis">array</em> is an ordered list of scalars, accessed<a href="#FOOTNOTE-6">[6]</a> by
the scalar's position in the list.  The list may contain numbers, or
strings, or a mixture of both.  (It might also contain
references to subarrays or subhashes.)
To assign a list value to an array, you simply group the values
together (with a set of parentheses):
<blockquote>
<pre class="programlisting">@home = ("couch", "chair", "table", "stove");</pre>
</blockquote>

Conversely, if you use <tt class="literal">@home</tt> in a list context, such as on the right
side of a list assignment, you get back out the same list you put in. So
you could set four scalar variables from the array like this:
<blockquote>
<pre class="programlisting">($potato, $lift, $tennis, $pipe) = @home;</pre>
</blockquote>

These are called list assignments.  They logically happen in parallel,
so you can swap two variables by saying:
<blockquote>
<pre class="programlisting">($alpha,$omega) = ($omega,$alpha);</pre>
</blockquote>
<a name="INDEX-83"></a><a name="INDEX-84"></a>
As in C, arrays are zero-based, so while you would talk about the first
through fourth elements of the array, you would get to them with
subscripts 0 through 3.<a href="#FOOTNOTE-7">[7]</a> Array subscripts are enclosed in square
brackets [like this], so if you want to select an individual array
element, you would refer to it as <tt class="literal">$home[</tt><em class="replaceable">n</em><tt class="literal">]</tt>, where <em class="replaceable">n</em> is the
subscript (one less than the element number) you want.  See the example
that follows.  Since the element you are dealing with is a scalar, you always
precede it with a <tt class="literal">$</tt>.
<a name="INDEX-85"></a>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-6"></a>
<p>[6] Or keyed,
or indexed, or subscripted, or looked up.  Take your pick.</p>

</blockquote>
<blockquote class="footnote">

<a name="FOOTNOTE-7"></a>
<p>[7] If this seems odd to you, just think
of the subscript as an offset, that is, the count of how many array
elements come before it.  Obviously, the first element doesn't have any
elements before it, and so has an offset of 0.  This is how computers
think.  (We think.)</p>

</blockquote>

<p>If you want to assign to one array element at a time, you could write
the earlier assignment as:
<blockquote>
<pre class="programlisting">$home[0] = "couch";
$home[1] = "chair";
$home[2] = "table";
$home[3] = "stove";</pre>
</blockquote>
<a name="INDEX-86"></a>
Since arrays are ordered, you
can do various useful operations on them, such as the stack operations <tt class="literal">push</tt> and <tt class="literal">pop</tt>.  A
stack is, after all, just an ordered list, with a beginning and an end.
Especially an end.  Perl regards the end of your array as the top of a
stack.  (Although most Perl programmers think of an array as horizontal,
with the top of the stack on the right.)</p>



<h3 class="sect4">1.2.1.2.2. Hashes.</h3>

<p>
<a name="INDEX-87"></a><a name="INDEX-88"></a><a name="INDEX-89"></a><a name="INDEX-90"></a>
A <em class="emphasis">hash</em> is an unordered set of scalars,
accessed<a href="#FOOTNOTE-8">[8]</a> by some string value
that is associated with each scalar.  For this reason hashes are often
called <em class="emphasis">associative arrays</em>.  But that's too long
for lazy typists to type, and we talk about them so often that we
decided to name them something short and snappy.  The other reason we
picked the name "hash" is to emphasize the fact that they're
disordered.  (They are, coincidentally, implemented internally using a
hash-table lookup, which is why hashes are so fast, and stay so fast
no matter how many values you put into them.)  You can't
<tt class="literal">push</tt> or <tt class="literal">pop</tt> a hash though,
because it doesn't make sense.  A hash has no beginning or end.
Nevertheless, hashes are extremely powerful and useful.  Until you
start thinking in terms of hashes, you aren't really thinking in Perl.
<a href="ch01_02.htm">Figure 1-1</a> shows the ordered elements
of an array and the unordered (but named) elements of a hash.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-8"></a>
<p>[8] Or keyed, or indexed, or subscripted, or
looked up.  Take your pick.</p>

</blockquote>

<a name="perl3-fig-array-and-hash"></a>
<div class="figure">
<img src="figs/perl3_0101.gif">
</div>
<h4 class="objtitle">Figure 1.1. An array and a hash</h4>
<p>
<a name="INDEX-91"></a><a name="INDEX-92"></a><a name="INDEX-93"></a><a name="INDEX-94"></a>
Since the keys to a hash are not automatically implied by their
position, you must supply the key as well as the value when populating a
hash. You can still assign a list to it like an ordinary array, but each
<em class="emphasis">pair</em> of items in the list will be interpreted as a key and a value.
Since we're dealing with pairs of items, hashes use the funny character
<tt class="literal">%</tt> to mark hash names.  (If you look carefully at the <tt class="literal">%</tt> character,
you can see the key and the value with a slash between them.  It may
help to squint.)</p>

<p>Suppose you wanted to translate abbreviated day names to the
corresponding full names.  You could write the following list
assignment:
<blockquote>
<pre class="programlisting">%longday = ("Sun", "Sunday", "Mon", "Monday", "Tue", "Tuesday",
            "Wed", "Wednesday", "Thu", "Thursday", "Fri",
            "Friday", "Sat", "Saturday");</pre>
</blockquote>
<a name="INDEX-95"></a><a name="INDEX-96"></a><a name="INDEX-97"></a>
But that's rather difficult to read, so Perl provides the
<tt class="literal">=&gt;</tt> (equals sign, greater-than sign) sequence as an
alternative separator to the comma.  Using this syntactic sugar
(and some creative formatting), it is much easier to see which strings

are the keys and which strings are the associated values.
<blockquote>
<pre class="programlisting">%longday = (
    "Sun" =&gt; "Sunday",
    "Mon" =&gt; "Monday",
    "Tue" =&gt; "Tuesday",
    "Wed" =&gt; "Wednesday",
    "Thu" =&gt; "Thursday",
    "Fri" =&gt; "Friday",
    "Sat" =&gt; "Saturday",
);</pre>
</blockquote>
<a name="INDEX-98"></a><a name="INDEX-99"></a><a name="INDEX-100"></a>
Not only can you assign a list to a hash, as we did above, but if you
mention a hash in list context, it'll convert the hash back to a list of
key/value pairs, in a weird order.  This is occasionally useful.  More
often people extract a list of just the keys, using the (aptly named)
<tt class="literal">keys</tt> function. The key list is also unordered, but can easily be
sorted if desired, using the (aptly named) <tt class="literal">sort</tt> function.  Then you
can use the ordered keys to pull out the corresponding values in the
order you want.</p>

<p>
<a name="INDEX-101"></a><a name="INDEX-102"></a><a name="INDEX-103"></a><a name="INDEX-104"></a><a name="INDEX-105"></a>
Because hashes are a fancy kind of array, you select an individual hash
element by enclosing the key in braces (those fancy brackets also
known as "curlies").  So, for example, if you want to find out the
value associated with <tt class="literal">Wed</tt> in the hash above, you would use
<tt class="literal">$longday{"Wed"}</tt>.  Note again that you are dealing with a scalar
value, so you use <tt class="literal">$</tt> on the front, not <tt class="literal">%</tt>, which would indicate
the entire hash.</p>

<p>Linguistically, the relationship encoded in a hash is genitive or
possessive, like the word "of" in English, or like "'s".  The wife <em class="emphasis">of</em>
Adam is Eve, so we write:
<blockquote>
<pre class="programlisting">$wife{"Adam"} = "Eve";</pre>
</blockquote>
</p>





<h3 class="sect3">1.2.1.3. Complexities</h3>

<p>Arrays and hashes are lovely, simple, flat data structures.
Unfortunately, the world does not always cooperate with our attempts to
oversimplify.  Sometimes you need to build not-so-lovely,
not-so-simple, not-so-flat data structures.  Perl lets you do this by
pretending that complicated values are really simple ones.  To put it
the other way around, Perl lets you manipulate simple scalar references
that happen to refer to complicated arrays and hashes.  We do this all
the time in natural language when we use a simple singular noun like
"government" to represent an entity that is completely convoluted and
inscrutable.  Among other things.</p>

<p>To extend our previous example, suppose we want to switch from talking
about Adam's wife to Jacob's wife.  Now, as it happens, Jacob had four
wives.  (Don't try this at home.)  In trying to represent this in Perl,
we find ourselves in the odd situation where we'd like to pretend that
Jacob's four wives were really one wife.  (Don't try this at home,
either.)  You might think you could write it like this:
<blockquote>
<pre class="programlisting">$wife{"Jacob"} = ("Leah", "Rachel", "Bilhah", "Zilpah");        # WRONG</pre>
</blockquote>
<a name="INDEX-106"></a><a name="INDEX-107"></a><a name="INDEX-108"></a><a name="INDEX-109"></a><a name="INDEX-110"></a>
But that wouldn't do what you want, because even parentheses and commas
are not powerful enough to turn a list into a scalar in Perl.
(Parentheses are used for syntactic grouping, and commas for syntactic
separation.)  Rather, you need to tell Perl explicitly that you
want to pretend that a list is a scalar.  It turns out that square
brackets are powerful enough to do that:
<blockquote>
<pre class="programlisting">$wife{"Jacob"} = ["Leah", "Rachel", "Bilhah", "Zilpah"];        # ok</pre>
</blockquote>

That statement creates an unnamed array and puts a reference to it into
the hash element <tt class="literal">$wife{"Jacob"}</tt>.  So we have a named hash
containing an unnamed array.  This is how Perl deals with both
multidimensional arrays and nested data structures.  As with ordinary
arrays and hashes, you can also assign individual elements, like this:
<blockquote>
<pre class="programlisting">$wife{"Jacob"}[0] = "Leah";
$wife{"Jacob"}[1] = "Rachel";
$wife{"Jacob"}[2] = "Bilhah";
$wife{"Jacob"}[3] = "Zilpah";</pre>
</blockquote>
<a name="INDEX-111"></a><a name="INDEX-112"></a><a name="INDEX-113"></a><a name="INDEX-114"></a>
You can see how that looks like a multidimensional array with one
string subscript and one numeric subscript.  To see something that
looks more tree-structured, like a nested data structure, suppose we
wanted to list not only Jacob's wives but all the sons of each of his
wives.  In this case we want to treat a hash as a scalar.  We can use
braces for that.  (Inside each hash value we'll use square brackets to
represent arrays, just as we did earlier.  But now we have an array in a
hash in a hash.)
<blockquote>
<pre class="programlisting">$kids_of_wife{"Jacob"} = {
    "Leah"   =&gt; ["Reuben", "Simeon", "Levi", "Judah", "Issachar", "Zebulun"],
    "Rachel" =&gt; ["Joseph", "Benjamin"],
    "Bilhah" =&gt; ["Dan", "Naphtali"],
    "Zilpah" =&gt; ["Gad", "Asher"],
};</pre>
</blockquote>

That would be more or less equivalent to saying:
<blockquote>
<pre class="programlisting">$kids_of_wife{"Jacob"}{"Leah"}[0]   = "Reuben";
$kids_of_wife{"Jacob"}{"Leah"}[1]   = "Simeon";
$kids_of_wife{"Jacob"}{"Leah"}[2]   = "Levi";
$kids_of_wife{"Jacob"}{"Leah"}[3]   = "Judah";
$kids_of_wife{"Jacob"}{"Leah"}[4]   = "Issachar";
$kids_of_wife{"Jacob"}{"Leah"}[5]   = "Zebulun";
$kids_of_wife{"Jacob"}{"Rachel"}[0] = "Joseph";
$kids_of_wife{"Jacob"}{"Rachel"}[1] = "Benjamin";
$kids_of_wife{"Jacob"}{"Bilhah"}[0] = "Dan";
$kids_of_wife{"Jacob"}{"Bilhah"}[1] = "Naphtali";
$kids_of_wife{"Jacob"}{"Zilpah"}[0] = "Gad";
$kids_of_wife{"Jacob"}{"Zilpah"}[1] = "Asher";</pre>
</blockquote>

You can see from this that adding a level to a nested
data structure it is like adding another dimension to a
multidimensional array.  Perl lets you think of it either way, but
the internal representation is the same.</p>

<p>
<a name="INDEX-115"></a><a name="INDEX-116"></a><a name="INDEX-117"></a><a name="INDEX-118"></a><a name="INDEX-119"></a>
The important point here is that Perl lets you pretend that
a complex data structure is a simple scalar.  On this simple kind of
encapsulation, Perl's entire object-oriented structure is built.
When we earlier invoked the <tt class="literal">Camel</tt> constructor like this:
<blockquote>
<pre class="programlisting">$fido = new Camel "Amelia";</pre>
</blockquote>

we created a <tt class="literal">Camel</tt> object that is represented by
the scalar <tt class="literal">$fido</tt>.  But the inside of the
<tt class="literal">Camel</tt> is more complicated.  As well-behaved
object-oriented programmers, we're not supposed to care about the
insides of <tt class="literal">Camel</tt>s (unless we happen to be the
people implementing the methods of the <tt class="literal">Camel</tt>
class).  But generally, an object like a <tt class="literal">Camel</tt>
would consist of a hash containing the particular
<tt class="literal">Camel</tt>'s attributes, such as its name
("<tt class="literal">Amelia</tt>" in this case, not
"<tt class="literal">fido</tt>"), and the number of humps (which we didn't
specify, but probably defaults to 1; check the front cover).</p>




<h3 class="sect3">1.2.1.4. Simplicities</h3>

<p>
<a name="INDEX-120"></a>

If your head isn't spinning a bit from reading that last section, then
you have an unusual head.  People don't generally like to deal with
complex data structures, whether governmental or genealogical.  So in
our natural languages, we have many ways of sweeping complexity under
the carpet.  Many of these fall into the category of
<em class="emphasis">topicalization</em>, which is just a fancy linguistics
term for agreeing with someone about what you're going to talk about
(and by exclusion, what you're probably not going to talk about).  This 
happens on many levels in language.  On a high level, we divide
ourselves up into various subcultures that are interested in various
subtopics and establish sublanguages that talk primarily about those
subtopics.  The lingo of the doctor's office ("indissoluable
asphyxiant") is different from the lingo of the chocolate factory
("everlasting gobstopper").  Most of us automatically switch contexts
as we go from one lingo to another.</p>

<p>On a conversational level, the context switch has to be more explicit,
so our language gives us many ways of saying what we're about to say.
We put titles on our books and headers on our sections.  On our
sentences, we put quaint phrases like "In regard to your recent query"
or "For all X".  Usually, though, we just say things like, "You know
that dangley thingy that hangs down in the back of your throat?"</p>

<p>
<a name="INDEX-121"></a><a name="INDEX-122"></a><a name="INDEX-123"></a>
Perl also has several ways of topicalizing.  One important topicalizer
is the <tt class="literal">package</tt> declaration.  Suppose you want to talk about
<tt class="literal">Camel</tt>s in Perl.  You'd likely start off your <tt class="literal">Camel</tt> module by saying:
<blockquote>
<pre class="programlisting">package Camel;</pre>
</blockquote>
<a name="INDEX-124"></a><a name="INDEX-125"></a>
This has several notable effects.  One of them is that Perl will
assume from this point on that any unspecified verbs or nouns
are about <tt class="literal">Camel</tt>s.  It does this by automatically prefixing any global
name with the module name "<tt class="literal">Camel::</tt>".  So if you say:
<blockquote>
<pre class="programlisting">package Camel;
$fido = &amp;fetch();</pre>
</blockquote>

then the real name of <tt class="literal">$fido</tt> is <tt class="literal">$Camel::fido</tt> (and the real name of
<tt class="literal">&amp;fetch</tt> is <tt class="literal">&amp;Camel::fetch</tt>, but we're not talking
about verbs yet).  This means that if some other module says:
<blockquote>
<pre class="programlisting">package Dog;
$fido = &amp;fetch();</pre>
</blockquote>

Perl won't get confused, because the real name of this
<tt class="literal">$fido</tt> is <tt class="literal">$Dog::fido</tt>, not
<tt class="literal">$Camel::fido</tt>.  A computer scientist would say that
a package establishes a <em class="emphasis">namespace</em>.  You can have
as many namespaces as you like, but since you're only in one of them
at a time, you can pretend that the other namespaces don't exist.
That's how namespaces simplify reality for you.  Simplification is
based on pretending.

(Of course, so is oversimplification, which is
what we're doing in this chapter.)</p>

<p>
<a name="INDEX-126"></a><a name="INDEX-127"></a>
Now it's important to keep your nouns straight, but it's just as
important to keep your verbs straight.  It's nice that
<tt class="literal">&amp;Camel::fetch</tt> is not confused with
<tt class="literal">&amp;Dog::fetch</tt> within the <tt class="literal">Camel</tt>
and <tt class="literal">Dog</tt> namespaces, but the really nice thing about
packages is that they classify your verbs so that <em class="emphasis">other</em>
packages can use them.  When we said:
<blockquote>
<pre class="programlisting">$fido = new Camel "Amelia";</pre>
</blockquote>

we were actually invoking the <tt class="literal">&amp;new</tt> verb in the 
<tt class="literal">Camel</tt> package, which has the full name of 
<tt class="literal">&amp;Camel::new</tt>.  And when we said:
<blockquote>
<pre class="programlisting">$fido-&gt;saddle();</pre>
</blockquote>

we were invoking the <tt class="literal">&amp;Camel::saddle</tt> routine,
because <tt class="literal">$fido</tt> remembers that it is pointing to a
<tt class="literal">Camel</tt>.  This is how object-oriented programming
works.</p>

<p>
<a name="INDEX-128"></a><a name="INDEX-129"></a>
When you say <tt class="literal">package Camel</tt>, you're starting a new package.  But
sometimes you just want to borrow the nouns and verbs of an existing
package.  Perl lets you do that with a <tt class="literal">use</tt> declaration, which not only
borrows verbs from another package, but also
checks that the module you name is loaded in from disk.  In fact, you
<em class="emphasis">must</em> say something like:
<blockquote>
<pre class="programlisting">use Camel;</pre>
</blockquote>

before you say:
<blockquote>
<pre class="programlisting">$fido = new Camel "Amelia";</pre>
</blockquote>

because otherwise Perl wouldn't know what a <tt class="literal">Camel</tt> is.</p>

<p>
<a name="INDEX-130"></a><a name="INDEX-131"></a><a name="INDEX-132"></a>
The interesting thing is that you yourself don't really need to know
what a <tt class="literal">Camel</tt> is, provided you can get someone else
to write the <tt class="literal">Camel</tt> module for you.  Even better
would be if someone had <em class="emphasis">already</em> written the
<tt class="literal">Camel</tt> module for you.  It could be argued that the
most powerful thing about Perl is not Perl itself, but CPAN
(Comprehensive Perl Archive Network), which contains myriads of
modules that accomplish many different tasks that you don't have to
know how to do.  You just have to download it and know how to say:
<blockquote>
<pre class="programlisting">use Some::Cool::Module;</pre>
</blockquote>

and then use the verbs from that module in a manner appropriate to the
topic under discussion.</p>

<p>
<a name="INDEX-133"></a><a name="INDEX-134"></a>
So, like topicalization in a natural language, topicalization in Perl
"warps" the language that you'll use from there to the end of the
program.  In fact, some of the built-in modules don't actually
introduce verbs at all, but simply warp the Perl

language

in various useful ways.  These special modules we call
<em class="emphasis">pragmas</em>.  For

instance, you'll often see people
use the pragma <tt class="literal">strict</tt>, like this:
<blockquote>
<pre class="programlisting">use strict;</pre>
</blockquote>
<a name="INDEX-135"></a><a name="INDEX-136"></a><a name="INDEX-137"></a>
What the <tt class="literal">strict</tt> module does is tighten up some of
the rules so that you have to be more explicit about various things
that Perl would otherwise guess about, such as how you want your
variables to be scoped.  Making things explicit is helpful when you're
working on large projects. By default Perl is optimized for small
projects, but with the <tt class="literal">strict</tt> pragma, Perl is also
good for large projects that need to be more maintainable.  Since you
can add the <tt class="literal">strict</tt> pragma at any time, Perl is also
good for evolving small projects into large ones, even when you didn't
expect that to happen.  Which is usually.</p>







<h3 class="sect2">1.2.2. Verbs</h3>

<p>
<a name="INDEX-138"></a><a name="INDEX-139"></a><a name="INDEX-140"></a><a name="INDEX-141"></a>
As is typical of your typical imperative computer language, many of
the verbs in Perl are commands: they tell the Perl interpreter to do
something.  On the other hand, as is typical of a natural language,
the meanings of Perl verbs tend to mush off in various directions
depending on the context.  A statement starting with a verb is
generally purely imperative and evaluated entirely for its side
effects.  (We sometimes call these verbs
<em class="emphasis">procedures</em>, especially when they're
user-defined.)  A frequently seen built-in command (in fact, you've
seen it already) is the <tt class="literal">print</tt> command:
<blockquote>
<pre class="programlisting">print "Adam's wife is $wife{'Adam'}.\n";</pre>
</blockquote>

This has the side effect of producing the desired output:
<blockquote>
<pre class="programlisting">Adam's wife is Eve.</pre>
</blockquote>
<a name="INDEX-142"></a><a name="INDEX-143"></a>
</p>

<p>But there are other "moods" besides the imperative mood.  Some verbs
are for asking questions and are useful in conditionals such as
<tt class="literal">if</tt> statements.  Other verbs translate their input
parameters into return values, just as a recipe tells you how to turn
raw ingredients into something (hopefully) edible.  We tend to call
these verbs <em class="emphasis">functions</em>, in deference to
generations of mathematicians who don't know what the word
"functional" means in normal English.</p>

<p>An example of a built-in function would be the exponential function:
<blockquote>
<pre class="programlisting">$e = exp(1);   # 2.718281828459 or thereabouts</pre>
</blockquote>
<a name="INDEX-144"></a><a name="INDEX-145"></a><a name="INDEX-146"></a><a name="INDEX-147"></a><a name="INDEX-148"></a>
But Perl doesn't make a hard distinction between procedures and
functions.  You'll find the terms used interchangeably.  Verbs are
also sometimes called operators (when built-in), or subroutines (when
user-defined).<a href="#FOOTNOTE-9">[9]</a> But call them
whatever you like--they all return a value, which may or may not
be a meaningful value, which you may or may not choose to ignore.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-9"></a>
<p>[9] Historically, Perl required you to put
an ampersand character (<tt class="literal">&amp;</tt>) on any calls to
user-defined subroutines (see <tt class="literal">$fido = &amp;fetch();</tt>
earlier).  But with Perl version 5, the ampersand became optional, so
that user-defined verbs can now be called with the same syntax as
built-in verbs (<tt class="literal">$fido = fetch();</tt>).  We still use
the ampersand when talking about the <em class="emphasis">name</em> of the
routine, such as when we take a reference to it (<tt class="literal">$fetcher =
\&amp;fetch;</tt>).  Linguistically speaking, you can think of
the ampersand form <tt class="literal">&amp;fetch</tt> as an infinitive, "to
fetch", or the similar form "do fetch".  But we rarely say "do fetch"
when we can just say "fetch".  That's the real reason we dropped the
mandatory ampersand in Perl 5.</p>

</blockquote>

<p>As we go on, you'll see additional examples of how Perl behaves like a
natural language.  But there are other ways to look at Perl too.  We've
already sneakily introduced some notions from mathematical language,
such as subscripts, addition, and the exponential function.  But Perl
is also a control language, a glue language, a prototyping language, a
text-processing language, a list-processing language, and an
object-oriented language.  Among other things.</p>

<p>But Perl is also just a plain old computer language.  And that's how
we'll look at it next.</p>



<!-- BOTTOM NAV BAR -->

<hr width="684" align="left">
<div class="navbar">
<table width="684" border="0">
<tr>
<td align="left" valign="top" width="228"><a href="ch01_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="228"><a href="ch01_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="228">1.1. Getting Started</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="228">1.3. An Average Example</td>
</tr>
</table>
</div>
<hr width="684" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="../cookbook/index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm">
</map>

<!-- END OF BODY -->

</body>
</html>
