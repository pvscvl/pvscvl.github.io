<html>
<head>
<title>Fancy Patterns (Programming Perl)</title>

<!-- STYLESHEET -->

<link rel="stylesheet" type="text/css" href="../style/style1.css">

<!-- METADATA -->



<!--Dublin Core Metadata-->

<meta name="DC.Creator" content="">
<meta name="DC.Date" content="">
<meta name="DC.Format" content="text/xml" scheme="MIME">
<meta name="DC.Generator" content="XSLT stylesheet, xt by James Clark">
<meta name="DC.Identifier" content="">
<meta name="DC.Language" content="en-US">
<meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc.">
<meta name="DC.Source" content="" scheme="ISBN">
<meta name="DC.Subject.Keyword" content="">
<meta name="DC.Title" content="Fancy Patterns">
<meta name="DC.Type" content="Text.Monograph">

</head>

<body>

<!-- START OF BODY -->



<!-- TOP BANNER -->

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home">
<map name="banner-map"><AREA SHAPE="rect" coords="1,-2,616,66" HREF="index.htm" ALT="Programming Perl"><AREA SHAPE="rect" coords="629,-11,726,25" HREF="jobjects/fsearch.htm" ALT="Search this book">
</map>

<!-- TOP NAV BAR -->

<div class="navbar">
<table width="684" border="0">
<tr>
<td align="left" valign="top" width="228"><a href="ch05_09.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="228"><a href="ch05_01.htm"></a></td><td align="right" valign="top" width="228"><a href="ch06_01.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
</table>
</div>



<h2 class="sect1">5.10. Fancy Patterns</h2>

<a name="ch05-sect-la"></a>
<h3 class="sect2">5.10.1. Lookaround Assertions</h3>

<a name="INDEX-1733"></a><a name="INDEX-1734"></a><a name="INDEX-1735"></a><a name="INDEX-1736"></a><a name="INDEX-1737"></a><a name="INDEX-1738"></a><a name="INDEX-1739"></a>
<p>
<a name="INDEX-1740"></a><a name="INDEX-1741"></a><a name="INDEX-1742"></a>
Sometimes you just need to sneak a peek.  There are four regex
extensions that help you do just that, and we call them <em class="emphasis">lookaround</em>
assertions because they let you scout around in a hypothetical sort of
way, without committing to matching any characters.  What these
assertions assert is that some pattern would (or would not) match if we
were to try it.  The Engine works it all out for us by actually trying
to match the hypothetical pattern, and then pretending that it didn't
match (if it did).</p>

<p>When the Engine peeks ahead from its current position in the string, we
call it a <em class="emphasis">lookahead</em> assertion.  If it peeks backward, we call it a
<em class="emphasis">lookbehind</em> assertion.  The lookahead patterns can be any regular expression,
but the lookbehind patterns may only be fixed width, since they have to know
where to start the hypothetical match from.</p>

<p>While these four extensions are all zero-width assertions, and hence do
not consume characters (at least, not officially), you can in fact
capture substrings within them if you supply extra levels of capturing
parentheses.</p>

<dl>
<dt>
<b><tt class="literal">(?=</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>
<em class="emphasis">(positive lookahead)</em></b>
</dt>
<dd>
<p> When the Engine encounters
<tt class="literal">(?=</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>,
it looks ahead in the string to ensure that
<em class="replaceable">PATTERN</em> occurs.  If you'll recall, in our
earlier duplicate word remover, we had to write a loop because the
pattern ate too much each time through:
<blockquote>
<pre class="programlisting">$_ = "Paris in THE THE THE THE spring.";

# remove duplicate words (and triplicate (and quadruplicate...))
1 while s/\b(\w+) \1\b/$1/gi;</pre>
</blockquote>

Whenever you hear the phrase "ate too much", you should always think
"lookahead assertion".  (Well, almost always.)  By peeking ahead
instead of gobbling up the second word, you can write a one-pass
duplicate word remover like this:
<blockquote>
<pre class="programlisting">s/ \b(\w+) \s (?= \1\b ) //gxi;</pre>
</blockquote>
<a name="INDEX-1743"></a><a name="INDEX-1744"></a>
Of course, this isn't quite right, since it will mess up valid phrases like
"The clothes you DON DON't fit."</p>
</dd>


<dt>
<b><tt class="literal">(?!</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>
<em class="emphasis">(negative lookahead)</em></b>
</dt>
<dd>
<p> When the Engine encounters
<tt class="literal">(?!</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>,
it looks ahead in the string to ensure that
<em class="replaceable">PATTERN</em> does <em class="emphasis">not</em>
occur.  To fix our previous example, we can add a negative lookahead
assertion after the positive assertion to weed out the case of
contractions:
<blockquote>
<pre class="programlisting">s/ \b(\w+) \s (?= \1\b (?! '\w))//xgi;</pre>
</blockquote>
<a name="INDEX-1745"></a><a name="INDEX-1746"></a>
That final <tt class="literal">\w</tt> is necessary to avoid confusing
contractions with words at the ends of single-quoted strings.  We can
take this one step further, since earlier in this chapter we
intentionally used "that that particular", and we'd like our program
to not "fix" that for us.  So we can add an alternative to the
negative lookahead in order to pre-unfix that "that", (thereby
demonstrating that any pair of parentheses can be used to cluster
alternatives):
<blockquote>
<pre class="programlisting">s/ \b(\w+) \s (?= \1\b (?! '\w | \s particular))//gix;</pre>
</blockquote>

Now we know that that particular phrase is safe.  Unfortunately, the
Gettysburg Address is still broken.  So we add another exception:
<blockquote>
<pre class="programlisting">s/ \b(\w+) \s (?= \1\b (?! '\w | \s particular | \s nation))//igx;</pre>
</blockquote>

This is just starting to get out of hand.  So let's do an Official List
of Exceptions, using a cute interpolation trick with the <tt class="literal">$"</tt>
variable to separate the alternatives with the <tt class="literal">|</tt> character:
<blockquote>
<pre class="programlisting">@thatthat = qw(particular nation);
local $" = '|';
s/ \b(\w+) \s (?= \1\b (?! '\w | \s (?: @thatthat )))//xig;</pre>
</blockquote>
</p>
</dd>


<dt>
<b><tt class="literal">(?&lt;=</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt> <em class="emphasis">(positive lookbehind)</em></b>
</dt>
<dd>
<p>When the Engine encounters <tt class="literal">(?&lt;=</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>, it looks
backward in the string to ensure that <em class="replaceable">PATTERN</em> already occurred.</p>

<p>Our example still has a problem.  Although it now lets Honest Abe say things
like "that that nation", it also allows "Paris, in the the nation of
France".  We can add a positive lookbehind assertion in front of our
exception list to make sure that we apply our <tt class="literal">@thatthat</tt> exceptions
only to a real "that that".
<blockquote>
<pre class="programlisting">s/ \b(\w+) \s (?= \1\b (?! '\w | (?&lt;= that) \s (?: @thatthat )))//ixg;</pre>
</blockquote>

Yes, it's getting terribly complicated, but that's why this section is
called "Fancy Patterns", after all.  If you need to complicate the
pattern any more than we've done so far, judicious use of comments and
<tt class="literal">qr//</tt> will help keep you sane.  Or at least saner.</p>
</dd>


<dt>
<b><tt class="literal">(?&lt;!</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt> <em class="emphasis">(negative lookbehind)</em></b>
</dt>
<dd>
<p>When the Engine encounters <tt class="literal">(?&lt;!</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>, it looks
backward in the string to ensure that <em class="replaceable">PATTERN</em> did not occur.</p>

<p>Let's go for a really simple example this time.  How about the easy
version of that old spelling rule, "I before E except after C"?  In Perl,
you spell it:
<blockquote>
<pre class="programlisting">s/(?&lt;!c)ei/ie/g</pre>
</blockquote>

You'll have to weigh for yourself whether you want to handle any of
the exceptions.  (For example, "weird" is spelled weird, especially when
you spell it "wierd".)</p>
</dd>

</dl>

<a name="INDEX-1747"></a>






<h3 class="sect2">5.10.2. Nonbacktracking Subpatterns</h3>

<a name="INDEX-1748"></a>
<p>
<a name="INDEX-1749"></a><a name="INDEX-1750"></a>
As described in "The Little Engine That /Could(n't)?/", the Engine
often backtracks as it proceeds through the pattern.  You can block
the Engine from backtracking back through a particular set of choices
by creating a <em class="emphasis">nonbacktracking subpattern</em>.  A
nonbacktracking subpattern looks like
<tt class="literal">(?&gt;</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>,
and it works exactly like a simple
<tt class="literal">(?:</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>,
except that once <em class="replaceable">PATTERN</em> has found a match,
it suppresses backtracking on any of the quantifiers or alternatives
inside the subpattern.  (Hence, it is meaningless to use this on a
<em class="replaceable">PATTERN</em> that doesn't contain quantifiers or
alternatives.)  The only way to get it to change its mind is to
backtrack to something before the subpattern and reenter the
subpattern from the left.</p>

<p>It's like going into a car dealership.  After a certain
amount of haggling over the price, you deliver an ultimatum: "Here's my
best offer; take it or leave it."  If they don't take it, you don't go
back to haggling again.  Instead, you backtrack clear out the door.
Maybe you go to another dealership, and start haggling again.  You're
allowed to haggle again, but only because you reentered the
nonbacktracking pattern again in a different context.</p>

<p>For devotees of Prolog or SNOBOL, you can think of this as a scoped
cut or fence operator.</p>

<p>Consider how in <tt class="literal">"aaab" =~ /(?:a*)ab/</tt>, the
<tt class="literal">a*</tt> first matches three <tt class="literal">a</tt>'s, but
then gives up one of them because the last <tt class="literal">a</tt> is
needed later.  The subgroup sacrifices some of what it wants in order
for the whole match to succeed.  (Which is like letting the car
salesman talk you into giving him more of your money because you're
afraid to walk away from the deal.)  In contrast, the subpattern in
<tt class="literal">"aaab" =~ /(?&gt;a*)ab/</tt> will never give up
what it grabs, even though this behavior causes the whole match to
fail.  (As the song says, you have to know when to hold 'em, when to
fold 'em, and when to walk away.)</p>

<p>Although
<tt class="literal">(?&gt;</tt><em class="replaceable">PATTERN</em><tt class="literal">)</tt>
is useful for changing the behavior of a pattern, it's mostly used for
speeding up the failure of certain matches that you know will fail
anyway (unless they succeed outright).  The Engine can take a
spectacularly long time to fail, particular with nested quantifiers.
The following pattern will succeed almost instantly:
<blockquote>
<pre class="programlisting">$_ = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab";
/a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*[b]/;</pre>
</blockquote>

But success is not the problem.  Failure is.  If you remove that final
"<tt class="literal">b</tt>" from the string, the pattern will probably run for many, many
years before failing.  Many, many millennia.  Actually, billions and
billions of years.<a href="#FOOTNOTE-13">[13]</a> You can see by inspection that the pattern can't
succeed if there's no "<tt class="literal">b</tt>" on the end of the string, but the regex
optimizer is not smart enough (as of this writing) to figure out that
<tt class="literal">/[b]/</tt> is equivalent to <tt class="literal">/b/</tt>.  But if you give it a hint, you can get
it to fail quickly while still letting it succeed where it can:
<blockquote>
<pre class="programlisting">/(?&gt;a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*)[b]/;</pre>
</blockquote>

For a (hopefully) more realistic example, imagine a program that's
supposed to read in a paragraph at a time and show just the lines that
are continued, where contination lines are specified with trailing

backslashes.  Here's a sample from Perl's
<em class="emphasis">Makefile</em> that uses this line-continuation
convention:
<blockquote>
<pre class="programlisting"># Files to be built with variable substitution before miniperl
# is available.
sh = Makefile.SH cflags.SH config_h.SH makeaperl.SH makedepend.SH \
        makedir.SH myconfig.SH writemain.SH</pre>
</blockquote>
You could write your simple program this way:
<blockquote>
<pre class="programlisting">#!/usr/bin/perl -00p
while ( /( (.+) ( (?&lt;=\\) \n .* )+ ) /gx) {
    print "GOT $.: $1\n\n";
}</pre>
</blockquote>
That works, but it's really quite slow.  That's because the Engine
backtracks a character at a time from the end of the line, shrinking
what's in <tt class="literal">$1</tt>.  This is pointless.  And writing it without
the extraneous captures doesn't help much.  Using:
<blockquote>
<pre class="programlisting">(.+(?:(?&lt;=\\)\n.*)+)</pre>
</blockquote>
for a pattern is somewhat faster, but not much.  This is where a
nonbacktracking subpattern helps a lot.  The pattern:
<blockquote>
<pre class="programlisting">((?&gt;.+)(?:(?&lt;=\\)\n.*)+)</pre>
</blockquote>
does the same thing, but more than an order of magnitude faster
because it doesn't waste time backtracking in search of something
that isn't there.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-13"></a>
<p>[13] Actually, it's more on the order of
septillions and septillions.  We don't know exactly how long it would
take.  We didn't care to wait around watching it not fail.  In any
event, your computer is likely to crash before the heat death of the
universe, and this regular expression takes longer than either of
those.</p>

</blockquote>

<p>You'll never get a success with <tt class="literal">(?&gt;...)</tt>
that you wouldn't get with <tt class="literal">(?:...)</tt> or even a
simple <tt class="literal">(...)</tt>.  But if you're going to fail,
it's best to fail quickly and get on with your life.</p>





<a name="ch05-sect-pp"></a>
<h3 class="sect2">5.10.3. Programmatic Patterns</h3>

<p>
<a name="INDEX-1751"></a><a name="INDEX-1752"></a><a name="INDEX-1753"></a><a name="INDEX-1754"></a>
Most Perl programs tend to follow an imperative (also called
procedural) programming style, like a series of discrete commands laid
out in a readily observable order: "Preheat oven, mix, glaze, heat,
cool, serve to aliens."  Sometimes into this mix you toss a few
dollops of functional programming ("Use a little more glaze than you
think you need, even after taking this into account, recursively"),
or sprinkle it with bits of object-oriented techniques ("but please hold
the anchovy objects").  Often it's a combination of all of these.</p>

<p>
<a name="INDEX-1755"></a>
But the regular expression Engine takes a completely different
approach to problem solving, more of a declarative approach.  You
describe goals in the language of regular expressions, and the
Engine implements whatever logic is needed to solve your goals.
Logic programming languages (such as Prolog) don't always get as
much exposure as the other three styles, but they're more common
than you'd think.  Perl couldn't even be built without <em class="emphasis">make</em>(1)
or <em class="emphasis">yacc</em>(1), both of which could be considered, if not purely
declarative languages, at least hybrids that blend imperative and
logic programming together.</p>

<p>You can do this sort of thing in Perl, too, by blending goal
declarations and imperative code together more miscibly than we've
done so far, drawing upon the strengths of both. You can programmatically
build up the string you'll eventually present to the regex Engine,
in a sense creating a program that writes a new program on the fly.</p>

<p>
<a name="INDEX-1756"></a>
You can also supply ordinary Perl expressions as the replacement part
of <tt class="literal">s///</tt> via the <tt class="literal">/e</tt> modifier.  This allows you to dynamically
generate the replacement string by executing a bit of code every time
the pattern matches.</p>

<p>
<a name="INDEX-1757"></a>
Even more elaborately, you can interject bits of code wherever you'd like
in a middle of a pattern using the <tt class="literal">(?{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt> extension,
and that code will be executed every time the Engine encounters
that code as it advances and recedes in its intricate backtracking
dance.</p>

<p>Finally, you can use <tt class="literal">s///ee</tt> or <tt class="literal">(??{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt> to add another
level of indirection: the <em class="emphasis">results</em> of executing those code snippets
will themselves be re-evaluated for further use, creating bits of
program and pattern on the fly, just in time.</p>


<h3 class="sect3">5.10.3.1. Generated patterns</h3>

<p>
<a name="INDEX-1758"></a><a name="INDEX-1759"></a>
It has been said<a href="#FOOTNOTE-14">[14]</a> that programs that write programs are the
happiest programs in the world.  In Jeffrey Friedl's book, <em class="citetitle">Mastering
Regular Expressions</em>, the final tour de force demonstrates how to write
a program that produces a regular expression to determine whether a
string conforms to the RFC 822 standard; that is, whether it contains a
standards-compliant, valid mail header.  The pattern produced is several
thousand characters long, and about as easy to read as a crash dump in
pure binary.  But Perl's pattern matcher doesn't care about that; it
just compiles up the pattern without a hitch and, even more
interestingly, executes the match very quickly--much more quickly, in fact,
than many short patterns with complex backtracking requirements.</p>
<blockquote class="footnote">

<a name="FOOTNOTE-14"></a>
<p>[14] By Andrew Hume, the famous Unix
philosopher.</p>

</blockquote>

<p>That's a very complicated example.  Earlier we showed you a very simple
example of the same technique when we built up a <tt class="literal">$number</tt> pattern out
of its components (see the section <a href="ch05_09.htm">Section 5.9.2, "Variable Interpolation"</a>).  But to show you the
power of this programmatic approach to producing a pattern, let's work
out a problem of medium complexity.</p>

<p>Suppose you wanted to pull out all the words with a certain
vowel-consonant sequence; for example, "audio" and "eerie" both follow
a VVCVV pattern.  Although describing what counts as a consonant or a
vowel is easy, you wouldn't ever want to type that in more than once.
Even for our simple VVCVV case, you'd need to type in a pattern that
looked something like this:
<blockquote>
<pre class="programlisting">^[aeiouy][aeiouy][cbdfghjklmnpqrstvwxzy][aeiouy][aeiouy]$</pre>
</blockquote>

A more general-purpose program would accept a string like "<tt class="literal">VVCVV</tt>"
and programmatically generate that pattern for you.  For even more
flexibility, it could accept a word like "<tt class="literal">audio</tt>" as input and use
that as a template to infer "<tt class="literal">VVCVV</tt>", and from that, the long pattern
above.  It sounds complicated, but really isn't, because we'll let
the program generate the pattern for us.  Here's a simple <em class="emphasis">cvmap</em>
program that does all of that:
<blockquote>
<pre class="programlisting">#!/usr/bin/perl
$vowels = 'aeiouy';
$cons   = 'cbdfghjklmnpqrstvwxzy';
%map = (C =&gt; $cons, V =&gt; $vowels);  # init map for C and V

for $class ($vowels, $cons) {       # now for each type
    for (split //, $class) {        # get each letter of that type
        $map{$_} .= $class;         # and map the letter back to the type
    }
}

for $char (split //, shift) {       # for each letter in template word
    $pat .= "[$map{$char}]";        # add appropriate character class
}

$re = qr/^${pat}$/i;                # compile the pattern
print "REGEX is $re\n";             # debugging output
@ARGV = ('/usr/dict/words')         # pick a default dictionary
    if -t &amp;&amp; !@ARGV;

while (&lt;&gt;) {                        # and now blaze through the input
    print if /$re/;                 # printing any line that matches
}</pre>
</blockquote>

The <tt class="literal">%map</tt> variable holds all the interesting bits.  Its keys are each
letter of the alphabet, and the corresponding value is all the letters
of its type.  We throw in C and V, too, so you can specify either
"<tt class="literal">VVCVV</tt>" or "<tt class="literal">audio</tt>", and still get out "<tt class="literal">eerie</tt>".  Each character in the
argument supplied to the program is used to pull out the right
character class to add to the pattern.  Once the pattern is created and
compiled up with <tt class="literal">qr//</tt>, the match (even a very long one) will run
quickly.  Here's why you might get if you run this program on
"fortuitously":
<blockquote>
<pre class="programlisting">% <tt class="userinput"><b>cvmap fortuitously /usr/dict/wordses</b></tt>
REGEX is (?i-xsm:^[cbdfghjklmnpqrstvwxzy][aeiouy][cbdfghjklmnpqrstvwxzy][cbd
fghjklmnpqrstvwxzy][aeiouy][aeiouy][cbdfghjklmnpqrstvwxzy][aeiouy][aeiouy][c
bdfghjklmnpqrstvwxzy][cbdfghjklmnpqrstvwxzy][aeiouycbdfghjklmnpqrstvwxzy]$)
carriageable
circuitously
fortuitously
languorously
marriageable
milquetoasts
sesquiquarta
sesquiquinta
villainously</pre>
</blockquote>
Looking at that <tt class="literal">REGEX</tt>, you can see just how much villainous
typing you saved by programming languorously, albeit circuitously.</p>




<h3 class="sect3">5.10.3.2. Substitution evaluations</h3>

<p>
<a name="INDEX-1760"></a><a name="INDEX-1761"></a><a name="INDEX-1762"></a><a name="INDEX-1763"></a>
When the <tt class="literal">/e</tt> modifier ("e" is for expression evaluation) is used on
an <tt class="literal">s/</tt><em class="replaceable">PATTERN</em><tt class="literal">/</tt><em class="replaceable">CODE</em><tt class="literal">/e</tt> expression, the replacement portion is
interpreted as a Perl expression, not just as a double-quoted string.
It's like an embedded <tt class="literal">do {</tt><em class="replaceable">CODE</em><tt class="literal">}</tt>.  Even though it looks like
a string, it's really just a code block that gets compiled up at the
same time as rest of your program, long before the substitution
actually happens.</p>

<p>You can use the <tt class="literal">/e</tt> modifier to build replacement
strings with fancier logic than double-quote interpolation allows.
This shows the difference:
<blockquote>
<pre class="programlisting">s/(\d+)/$1 * 2/;     # Replaces "42" with "42 * 2"
s/(\d+)/$1 * 2/e;    # Replaces "42" with "84"</pre>
</blockquote>
And this converts Celsius temperatures into Fahrenheit:
<blockquote>
<pre class="programlisting">$_ = "Preheat oven to 233C.\n";
s/\b(\d+\.?\d*)C\b/int($1 * 1.8 + 32) . "F"/e;   # convert to 451F</pre>
</blockquote>
Applications of this technique are limitless.  Here's a filter that
modifies its files in place (like an editor) by adding 100
to every number that starts a line (and that is followed by a
colon, which we only peek at, but don't actually match, or replace):
<blockquote>
<pre class="programlisting">% <tt class="userinput"><b>perl -pi -e 's/^(\d+)(?=:)/100 + $1/e' filename</b></tt>
</pre>
</blockquote>
Now and then, you want to do more than just use the string you matched
in another computation.  Sometimes you want that string to
<em class="emphasis">be</em> a computation, whose own evaluation you'll use
for the replacement value.  Each additional <tt class="literal">/e</tt>
modifier after the first wraps an <tt class="literal">eval</tt> around the
code to execute.  The following two lines do the same thing, but the
first one is easier to read:
<blockquote>
<pre class="programlisting">s/<em class="replaceable">PATTERN</em>/<em class="replaceable">CODE</em>/ee
s/<em class="replaceable">PATTERN</em>/eval(<em class="replaceable">CODE</em>)/e</pre>
</blockquote>
You could use this technique to replace mentions of simple scalar variables
with their values:
<blockquote>
<pre class="programlisting">s/(\$\w+)/$1/eeg;       # Interpolate most scalars' values</pre>
</blockquote>
Because it's really an <tt class="literal">eval</tt>, the
<tt class="literal">/ee</tt> even finds lexical variables.  A slightly more
elaborate example calculates a replacement for simple arithmetical
expressions on (nonnegative) integers:
<blockquote>
<pre class="programlisting">$_ = "I have 4 + 19 dollars and 8/2 cents.\n";
s{ (
        \d+ \s*         # find an integer
        [+*/-]          # and an arithmetical operator
        \s* \d+         # and another integer
   )
}{ $1 }eegx;            # then expand $1 and run that code
print;                  # "I have 23 dollars and 4 cents."</pre>
</blockquote>

Like any other <tt class="literal">eval</tt><em class="replaceable">STRING</em>, compile-time errors (like syntax
problems) and run-time exceptions (like dividing by zero) are trapped.
If so, the <tt class="literal">$@</tt> (<tt class="literal">$EVAL_ERROR</tt>)
variable says what went wrong.</p>



<a name="ch05-sect-mt"></a>
<h3 class="sect3">5.10.3.3. Match-time code evaluation</h3>

<p>
<a name="INDEX-1764"></a><a name="INDEX-1765"></a>
In most programs that use regular expressions, the surrounding
program's run-time control structure drives the logical execution flow.
You write <tt class="literal">if</tt> or <tt class="literal">while</tt> loops, or
make function or method calls, that wind up calling a pattern-matching
operation now and then.  Even with <tt class="literal">s///e</tt>, it's the
substitution operator that is in control, executing the replacement
code only after a successful match.</p>

<p>With <em class="emphasis">code subpatterns</em>, the normal relationship
between regular expression and program code is inverted.  As the
Engine is applying its Rules to your pattern at match time, it may
come across a regex extension of the form <tt class="literal">(?{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt>.  When
triggered, this subpattern doesn't do any matching or any looking
about.  It's a zero-width assertion that always "succeeds", evaluated
only for its side effects.  Whenever the Engine needs to progress over
the code subpattern as it executes the pattern, it runs that code.
<blockquote>
<pre class="programlisting">"glyph" =~ /.+ (?{ print "hi" }) ./x;  # Prints "hi" twice.</pre>
</blockquote>

As the Engine tries to match <tt class="literal">glyph</tt> against this pattern,
it first lets the <tt class="literal">.+</tt> eat up all five letters.  Then it prints "<tt class="literal">hi</tt>".
When it finds that final dot, all five letters have been eaten, so it
needs to backtrack back to the <tt class="literal">.+</tt> and make it give up one of the
letters.  Then it moves forward through the pattern again, stopping
to print "<tt class="literal">hi</tt>" again before assigning <tt class="literal">h</tt> to the final dot and completing
the match successfully.</p>

<p>The braces around the <em class="replaceable">CODE</em> fragment are
intended to remind you that it is a block of Perl code, and it
certainly behaves like a block in the lexical sense.  That is, if you
use <tt class="literal">my</tt> to declare a lexically scoped variable in
it, it is private to the block.  But if you use
<tt class="literal">local</tt> to localize a dynamically scoped variable, it
may not do what you expect.  A
<tt class="literal">(?{</tt>&nbsp;<em class="replaceable">CODE</em><tt class="literal">})</tt> subpattern creates an implicit dynamic scope
that is valid throughout the rest of the pattern, until it either
succeeds or backtracks through the code subpattern.  One way to think
of it is that the block doesn't actually return when it gets to the
end.  Instead, it makes an invisible recursive call to the Engine to
try to match the rest of the pattern.  Only when that recursive call
is finished does it return from the block, delocalizing the localized
variables.<a href="#FOOTNOTE-15">[15]</a>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-15"></a>
<p>[15] People who are familiar with recursive
descent parsers may find this behavior confusing because such
compilers return from a recursive function call whenever they figure
something out.  The Engine doesn't do that--when it figures something
out, it goes <em class="emphasis">deeper</em> into recursion (even when
exiting a parenthetical group!).  A recursive descent parser is at a
minimum of recursion when it succeeds at the end, but the Engine is at
a local <em class="emphasis">maximum</em> of recursion when it succeeds at
the end of the pattern.  You might find it helpful to dangle the
pattern from its left end and think of it as a skinny representation
of a call graph tree. If you can get that picture into your head, the
dynamic scoping of local variables will make more sense.  (And if you
can't, you're no worse off than before.)</p>

</blockquote>

<p>In the next example, we initialize <tt class="literal">$i</tt> to <tt class="literal">0</tt> by including a code
subpattern at the beginning of the pattern. Then we match any number of
characters with <tt class="literal">.*</tt>--but we place another code subpattern in between
the <tt class="literal">.</tt> and the <tt class="literal">*</tt> so we can count how many times <tt class="literal">.</tt> matches.
<blockquote>
<pre class="programlisting">$_ = 'lothlorien';
m/  (?{ $i = 0 })                    # Set $i to 0
    (.    (?{ $i++ })    )*          # Update $i, even after backtracking
    lori                             # Forces a backtrack
 /x;</pre>
</blockquote>

The Engine merrily goes along, setting <tt class="literal">$i</tt> to
<tt class="literal">0</tt> and letting the <tt class="literal">.*</tt> gobble up
all 10 characters in the string.  When it encounters the literal
<tt class="literal">lori</tt> in the pattern, it backtracks and gives up
those four characters from the <tt class="literal">.*</tt>.  After the
match, <tt class="literal">$i</tt> will still be <tt class="literal">10</tt>.</p>

<p>If you wanted <tt class="literal">$i</tt> to reflect how many characters the <tt class="literal">.*</tt> actually
ended up with, you could make use of the dynamic scope within the pattern:
<blockquote>
<pre class="programlisting">$_ = 'lothlorien';
m/  (?{ $i = 0 })
    (. (?{ local $i = $i + 1; }) )*  # Update $i, backtracking-safe.
    lori
    (?{ $result = $i })              # Copy to non-localized location.
 /x;</pre>
</blockquote>

Here, we use <tt class="literal">local</tt> to ensure that <tt class="literal">$i</tt> contains the number of
characters matched by <tt class="literal">.*</tt>, regardless of backtracking.  <tt class="literal">$i</tt> will
be forgotten after the regular expression ends, so the code
subpattern, <tt class="literal">(?{ $result = $i })</tt>, ensures that the count will
live on in <tt class="literal">$result</tt>.</p>

<p>The special variable <tt class="literal">$^R</tt> (described in <a href="ch28_01.htm">Chapter 28, "Special Names"</a>)
holds the result of the last <tt class="literal">(?{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt> that was
executed as part of a successful match.</p>

<p>You can use a <tt class="literal">(?{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt> extension as the <em class="replaceable">COND</em> of a 
<tt class="literal">(?(</tt><em class="replaceable">COND</em><tt class="literal">)</tt><em class="replaceable">IFTRUE</em><tt class="literal">|</tt><em class="replaceable">IFFALSE</em><tt class="literal">)</tt>.  If you do this, <tt class="literal">$^R</tt> will not
be set, and you may omit the parentheses around the conditional:
<blockquote>
<pre class="programlisting">"glyph" =~ /.+(?(?{ $foo{bar} gt "symbol" }).|signet)./;</pre>
</blockquote>

Here, we test whether <tt class="literal">$foo{bar}</tt> is greater than <tt class="literal">symbol</tt>.  If so, we
include <tt class="literal">.</tt> in the pattern, and if not, we include <tt class="literal">signet</tt> in the
pattern.  Stretched out a bit, it might be construed as more readable:
<blockquote>
<pre class="programlisting">"glyph" =~ m{
    .+                              # some anythings
    (?(?{                           # if 
            $foo{bar} gt "symbol"   # this is true
        })
            .                       # match another anything
        |                           # else
            signet                  # match signet
    )
    .                               # and one more anything
}x;</pre>
</blockquote>

When <tt class="literal">use re 'eval'</tt> is in effect, a regex is allowed
to contain <tt class="literal">(?{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt> subpatterns even if the regular expression
interpolates variables:
<blockquote>
<pre class="programlisting">/(.*?) (?{length($1) &lt; 3 &amp;&amp; warn}) $suffix/;  # Error without use re 'eval'</pre>
</blockquote>

This is normally disallowed since it is a potential security risk.
Even though the pattern above may be innocuous because <tt class="literal">$suffix</tt> is
innocuous, the regex parser can't tell which parts of the string were
interpolated and which ones weren't, so it just disallows code
subpatterns entirely if there were any interpolations.</p>

<p>If the pattern is obtained from tainted data, even <tt class="literal">use re
'eval'</tt> won't allow the pattern match to proceed.</p>

<p>When <tt class="literal">use re 'taint'</tt> is in effect and a tainted
string is the target of a regex, the captured subpatterns (either in
the numbered variables or in the list of values returned by
<tt class="literal">m//</tt> in list context) are tainted.  This is useful
when regex operations on tainted data are meant not to extract safe
substrings, but merely to perform other transformations.  See
<a href="ch23_01.htm">Chapter 23, "Security"</a>, for more on tainting.  For the purpose
of this pragma, precompiled regular expressions (usually obtained from
<tt class="literal">qr//</tt>) are not considered to be interpolated:
<blockquote>
<pre class="programlisting">/foo${pat}bar/</pre>
</blockquote>

This is allowed if <tt class="literal">$pat</tt> is a precompiled regular expression, even
if <tt class="literal">$pat</tt> contains <tt class="literal">(?{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt> subpatterns.</p>

<p>Earlier we showed you a bit of what <tt class="literal">use</tt><tt class="literal">re</tt><tt class="literal">'debug'</tt> prints out.  A more
primitive debugging solution is to use <tt class="literal">(?{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt> subpatterns to
print out what's been matched so far during the match:
<blockquote>
<pre class="programlisting">"abcdef" =~ / .+ (?{print "Matched so far: $&amp;\n"}) bcdef $/x;</pre>
</blockquote>

This prints:
<blockquote>
<pre class="programlisting">Matched so far: abcdef
Matched so far: abcde
Matched so far: abcd
Matched so far: abc
Matched so far: ab
Matched so far: a</pre>
</blockquote>

showing the <tt class="literal">.+</tt> grabbing all the letters and giving them up one
by one as the Engine backtracks.</p>




<h3 class="sect3">5.10.3.4. Match-time pattern interpolation</h3>

<p>
<a name="INDEX-1766"></a><a name="INDEX-1767"></a><a name="INDEX-1768"></a>
You can build parts of your pattern from within the pattern itself.
The
<tt class="literal">(??{</tt>&nbsp;<em class="replaceable">CODE</em>&nbsp;<tt class="literal">})</tt>
extension allows you to insert code that evaluates to a valid pattern.
It's like saying <tt class="literal">/$pattern/</tt>, except that you can
generate <tt class="literal">$pattern</tt> at run time--more specifically,
at match time.  For instance:
<blockquote>
<pre class="programlisting">/\w (??{ if ($threshold &gt; 1) { "red" } else { "blue" } }) \d/x;</pre>
</blockquote>

This is equivalent to <tt class="literal">/\wred\d/</tt> if
<tt class="literal">$threshold</tt> is greater than 1, and
<tt class="literal">/\wblue\d/</tt> otherwise.</p>

<p>
<a name="INDEX-1769"></a>
You can include backreferences inside the evaluated code to derive
patterns from just-matched substrings (even if they will later become
unmatched through backtracking).  For instance, this matches all
strings that read the same backward as forward (known as
palindromedaries, phrases with a hump in the middle):
<blockquote>
<pre class="programlisting">/^ (.+) .? (??{quotemeta reverse $1}) $/xi;</pre>
</blockquote>

You can balance parentheses like so:
<blockquote>
<pre class="programlisting">$text =~ /( \(+ ) (.*?) (??{ '\)' x length $1 })/x;</pre>
</blockquote>
This matches strings of the form <tt class="literal">(shazam!)</tt> and
<tt class="literal">(((shazam!)))</tt>, sticking <tt class="literal">shazam!</tt>
into <tt class="literal">$2</tt>.  Unfortunately, it doesn't notice whether
the parentheses in the middle are balanced.  For that we need
recursion.</p>

<p>
<a name="INDEX-1770"></a><a name="INDEX-1771"></a>
Fortunately, you can do recursive patterns too.  You can have a
compiled pattern that uses <tt class="literal">(??{</tt><em class="replaceable">CODE</em><tt class="literal">})</tt> to refer to
itself.  Recursive matching is pretty irregular, as regular

expressions go.  Any text on regular expressions will tell you that a
standard regex can't match nested parentheses correctly.  And that's
correct.  It's also correct that Perl's regexes aren't standard.  The
following pattern<a href="#FOOTNOTE-16">[16]</a> matches a
set of nested parentheses, however deep they go:
<blockquote>
<pre class="programlisting">$np = qr{
           \(
           (?:
              (?&gt; [^()]+ )    # Non-parens without backtracking
            |
              (??{ $np })     # Group with matching parens
           )*
           \)
        }x;</pre>
</blockquote>

You could use it like this to match a function call:
<blockquote>
<pre class="programlisting">$funpat = qr/\w+$np/;
'myfunfun(1,(2*(3+4)),5)' =~ /^$funpat$/;   # Matches!</pre>
</blockquote>
</p>
<blockquote class="footnote">

<a name="FOOTNOTE-16"></a>
<p>[16]Note that you can't declare the
variable in the same statement in which you're going to use it.  You
can always declare it earlier, of course.</p>

</blockquote>




<h3 class="sect3">5.10.3.5. Conditional interpolation</h3>

<p>
<a name="INDEX-1772"></a><a name="INDEX-1773"></a><a name="INDEX-1774"></a>
The
<tt class="literal">(?(</tt><em class="replaceable">COND</em><tt class="literal">)</tt><em class="replaceable">IFTRUE</em><tt class="literal">|</tt><em class="replaceable">IFFALSE</em><tt class="literal">)</tt>
regex extension is similar to Perl's <tt class="literal">?:</tt> operator.
If <em class="replaceable">COND</em> is true, the
<em class="replaceable">IFTRUE</em> pattern is used; otherwise, the
<em class="replaceable">IFFALSE</em> pattern is used.  The
<em class="replaceable">COND</em> can be a backreference (expressed as a
bare integer, without the <tt class="literal">\</tt> or
<tt class="literal">$</tt>), a lookaround assertion, or a code subpattern.
(See <a href="ch05_10.htm">Section 5.10.1, "Lookaround Assertions"</a> and <a href="ch05_10.htm">Section 5.10.3.3, "Match-time code evaluation"</a> earlier in this chapter.)</p>

<p>If the <em class="replaceable">COND</em> is an integer, it is treated as
a backreference.  For instance, consider:
<blockquote>
<pre class="programlisting">#!/usr/bin/perl
$x = 'Perl is free.';
$y = 'ManagerWare costs $99.95.';

foreach ($x, $y) {
    /^(\w+) (?:is|(costs)) (?(2)(\$\d+)|\w+)/;  # Either (\$\d+) or \w+
    if ($3) {
        print "$1 costs money.\n";         # ManagerWare costs money.
    } else {
        print "$1 doesn't cost money.\n";  # Perl doesn't cost money.
    }
}</pre>
</blockquote>

Here, the <em class="replaceable">COND</em> is <tt class="literal">(2)</tt>,
which is true if a second backreference exists.  If that's the case,
<tt class="literal">(\$\d+)</tt> is included in the pattern at that point
(creating the <tt class="literal">$3</tt> backreference); otherwise,
<tt class="literal">\w+</tt> is used.</p>

<p>If the <em class="replaceable">COND</em> is a lookaround or code
subpattern, the truth of the assertion is used to determine whether to
include <em class="replaceable">IFTRUE</em> or
<em class="replaceable">IFFALSE</em>:
<blockquote>
<pre class="programlisting">/[ATGC]+(?(?&lt;=AA)G|C)$/;</pre>
</blockquote>

This uses a lookbehind assertion as the
<em class="replaceable">COND</em> to match a DNA sequence that ends in
either <tt class="literal">AAG</tt>, or some other base combination and
<tt class="literal">C</tt>.</p>

<p>You can omit the
<tt class="literal">|</tt><em class="replaceable">IFFALSE</em> alternative.
If you do, the <em class="replaceable">IFTRUE</em> pattern will be
included in the pattern as usual if the
<em class="replaceable">COND</em> is true, but if the condition isn't
true, the Engine will move on to the next portion of the pattern.</p>







<h3 class="sect2">5.10.4. Defining Your Own Assertions</h3>

<p>
<a name="INDEX-1775"></a><a name="INDEX-1776"></a><a name="INDEX-1777"></a>
You can't change how Perl's Engine works, but if you're sufficiently
warped, you can change how it sees your pattern.  Since Perl interprets
your pattern similarly to double-quoted strings, you can use the wonder
of overloaded string constants to see to it that text sequences of your
choosing are automatically translated into other text sequences.</p>

<p>
<a name="INDEX-1778"></a>
In the example below, we specify two transformations to occur when
Perl encounters a pattern.  First, we define <tt class="literal">\tag</tt>
so that when it appears in a pattern, it's automatically translated to
<tt class="literal">(?:&lt;.*?&gt;)</tt>, which matches most HTML and XML tags.
Second, we "redefine" the <tt class="literal">\w</tt> metasymbol so that it
handles only English letters.</p>

<p>We'll define a package called <tt class="literal">Tagger</tt> that hides the
overloading from our main program.  Once we do that, we'll be able to
say:
<blockquote>
<pre class="programlisting">use Tagger;
$_ = '&lt;I&gt;camel&lt;/I&gt;';
print "Tagged camel found" if /\tag\w+\tag/;</pre>
</blockquote>

Here's <em class="emphasis">Tagger.pm</em>, couched in the form of a Perl
module (see <a href="ch11_01.htm">Chapter 11, "Modules"</a>):
<blockquote>
<pre class="programlisting">package Tagger;
use overload;

sub import { overload::constant 'qr' =&gt; \&amp;convert }

sub convert {
    my $re = shift;
    $re =~ s/ \\tag  /&lt;.*?&gt;/xg;
    $re =~ s/ \\w    /[A-Za-z]/xg;
    return $re;
}

1;</pre>
</blockquote>
The <tt class="literal">Tagger</tt> module is handed the pattern immediately before
interpolation, so you can bypass the overloading by bypassing interpolation,
as follows:
<blockquote>
<pre class="programlisting">$re = '\tag\w+\tag';   # This string begins with \t, a tab
print if /$re/;        # Matches a tab, followed by an "a"...</pre>
</blockquote>

If you wanted the interpolated variable to be customized, call
the <tt class="literal">convert</tt> function directly:
<blockquote>
<pre class="programlisting">$re = '\tag\w+\tag';         # This string begins with \t, a tab
$re = Tagger::convert $re;   # expand \tag and \w
print if /$re/;              # $re becomes &lt;.*?&gt;[A-Za-z]+&lt;.*?&gt;</pre>
</blockquote>

Now if you're still wondering what those <tt class="literal">sub</tt>
thingies are there in the <tt class="literal">Tagger</tt> module, you'll
find out soon enough because that's what our next chapter is all
about.
<a name="INDEX-1779"></a>
</p>



<!-- BOTTOM NAV BAR -->

<hr width="684" align="left">
<div class="navbar">
<table width="684" border="0">
<tr>
<td align="left" valign="top" width="228"><a href="ch05_09.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0"></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0"></a></td><td align="right" valign="top" width="228"><a href="ch06_01.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0"></a></td>
</tr>
<tr>
<td align="left" valign="top" width="228">5.9. Staying in Control</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0"></a></td><td align="right" valign="top" width="228">6. Subroutines</td>
</tr>
</table>
</div>
<hr width="684" align="left">

<!-- LIBRARY NAV BAR -->

<img src="../gifs/smnavbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links"><p>
<font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font>
</p>
<map name="library-map"> <area shape="rect" coords="1,0,85,94" href="../index.htm"><area shape="rect" coords="86,1,178,103" href="../lwp/index.htm"><area shape="rect" coords="180,0,265,103" href="../lperl/index.htm"><area shape="rect" coords="267,0,353,105" href="../perlnut/index.htm"><area shape="rect" coords="354,1,446,115" href="index.htm"><area shape="rect" coords="448,0,526,132" href="../tk/index.htm"><area shape="rect" coords="528,1,615,119" href="../cookbook/index.htm"><area shape="rect" coords="617,0,690,135" href="../pxml/index.htm">
</map>

<!-- END OF BODY -->

</body>
</html>
