<html><head><title>XSLT Elements (XML in a Nutshell, 2nd Edition)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Elliotte Rusty Harold and W. Scott Means" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0-596-00292-0" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="XML in a Nutshell, 2nd Edition" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="XML in a Nutshell" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch23_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch23_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>



<h2 class="sect1">23.2. XSLT Elements</h2>

<p>XSLT <a name="xmlnut2-IDXTERM-2235" />defines 37 elements, which break down into
3 overlapping categories:
</p>

<ul><li>
<p>Two root elements:</p>

<blockquote><pre class="code">xsl:stylesheet
xsl:transform</pre></blockquote>
</li>

<li>
<p>12 top-level elements. These elements may appear as immediate
children of the root and are the following:
</p>
<blockquote><pre class="code">xsl:attribute-set          xsl:decimal-format
xsl:import                 xsl:include
xsl:key                    xsl:namespace-alias
xsl:output                 xsl:param
xsl:preserve-space         xsl:strip-space
xsl:template               xsl:variable</pre></blockquote>
</li>

<li>
<p>23 instruction elements. These elements appear in the content of
elements that contain templates. Here we don't mean
the <tt class="literal">xsl:template</tt> element. We mean the content of
that and several other elements, such as
<tt class="literal">xsl:for-each</tt> and <tt class="literal">xsl:message</tt>,
which are composed of literal result elements, character data, and
XSLT instructions that are processed to produce part of the result
tree. These elements are as follows:
</p>

<blockquote><pre class="code">xsl:apply-imports          xsl:apply-templates
xsl:attribute              xsl:call-template
xsl:choose                 xsl:comment
xsl:copy                   xsl:copy-of
xsl:element                xsl:fallback
xsl:for-each               xsl:if
xsl:message                xsl:number
xsl:otherwise              xsl:param
xsl:processing-instruction xsl:sort
xsl:text                   xsl:value-of
xsl:variable               xsl:with-param
xsl:when</pre></blockquote>
</li>
</ul>

<p>Most XSLT processors also provide various nonstandard extension
elements and allow you to write your own extension elements in
languages such as Java and JavaScript.
</p>

<p>Elements in this section are arranged alphabetically from
<tt class="literal">xsl:apply-imports</tt> to
<tt class="literal">xsl:with-param</tt>. Each element begins with a
synopsis in the following form:
</p>

<blockquote><pre class="code">&lt;xsl:elementName
   attribute1 = "allowed attribute values"
   attribute2 = "allowed attribute values"
&gt;
  &lt;!-- Content model --&gt;
&lt;/xsl:elementName&gt;</pre></blockquote>

<p>Most attribute values are one of the following types:</p>

<dl>
<dt><i>expression</i></dt>
<dd>
An XPath expression. In cases where the expression is expected to
return a value of a particular type, such as node-set or number, it
is prefixed with the type and a hyphen, for example,
<tt class="literal">node-set-expression</tt> or
<tt class="literal">number-expression</tt>. However, XPath is weakly typed,
and in most cases, any supplied type will be converted to the
requested type. For instance, an attribute that should contain a
string might in fact contain a number or a node-set. The processor
automatically converts this number or set to a string, according to
the rules given in the last chapter for XPath's
<tt class="literal">string( )</tt> function. The only exception to this
rule is <tt class="literal">node-set-expression</tt>. XSLT does not convert
other types to node-sets automatically. If an attribute requires a
<tt class="literal">node-set-expression</tt>, then it is an error to set
its value to another type of expression such as a boolean or string.
</p>
</dd>


<dt><i>QualifiedName</i></dt>
<dd>
An XML name, such as <tt class="literal">set</tt> or
<tt class="literal">mathml:set</tt>. If the name is in a nondefault
namespace, then it has a prefix.
</p>
</dd>


<dt><i>PrefixedName</i></dt>
<dd>
An XML name that must have a prefix such as
<tt class="literal">mathml:set</tt> but not <tt class="literal">set</tt>.
</p>
</dd>


<dt><i>pattern</i></dt>
<dd>
An XSLT pattern; that is, a group of one or more XPath location-path
expressions separated by <tt class="literal">|</tt>. in which each location
step uses only the child or attribute axis. The initial step may be
an <tt class="literal">id( )</tt> or <tt class="literal">key( )</tt> function
call with a literal argument.
</p>
</dd>


<dt><i>langcode</i></dt>
<dd>
An RFC 1766 language code, such as <tt class="literal">en</tt> or
<tt class="literal">fr-CA</tt>.
</p>
</dd>


<dt><i>string</i></dt>
<dd>
A literal string of text.</p>
</dd>


<dt><i>char</i></dt>
<dd>
A single Unicode character.</p>
</dd>


<dt><i>enumerated type</i></dt>
<dd>
One value in a finite list of values. The values shown here are
separated by vertical bars, as in an enumerated content model in an
<tt class="literal">ATTLIST</tt> declaration.
</p>
</dd>


<dt><i>URI</i></dt>
<dd>
A relative or absolute URI reference. In practice, these are normally
URLs. Relative URIs are relative to the location of the stylesheet
itself.
</p>
</dd>

</dl>

<p>Some attributes that contain strings--whether those strings are
literals, expressions, names, or something else--can be given as
attribute value templates. This is an XPath expression enclosed in
curly braces, which is evaluated to provide the final value of the
attribute. When this is the case, it is indicated in the description
of each attribute.
</p>

<p>Potentially nonempty elements have content models given in a comment
in the form they might appear in an <tt class="literal">ELEMENT</tt>
declaration. If an element can contain a template, we use the word
"template" to stand in for all the
possible elements that may <a name="IXTR3-244" />appear.
</p>

<a name="ch23-6-fm2xml" /><a name="IXT-23-240613" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:apply-imports</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240613" />&lt;xsl:apply-imports /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:apply-imports</tt> instruction processes the
current node using only templates that were imported into the
stylesheet with <tt class="literal">xsl:import</tt>. A template rule that
overrides a template rule in an imported stylesheet can invoke the
overridden template rule with <tt class="literal">xsl:apply-imports</tt>.
</p></div>

<a name="ch23-7-fm2xml" /><a name="IXT-23-240614" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:apply-templates</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240614" />&lt;xsl:apply-templates
  select = "<tt><em class="replaceable"><tt>node-set-expression</tt></em></tt>"
  mode   = "<tt><em class="replaceable"><tt>QualifiedName</tt></em></tt>"&gt;
  &lt;! --  (xsl:sort | xsl:with-param)*  -- &gt;
&lt;/xsl:apply-templates&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:apply-templates</tt> instruction tells the
processor to search for and apply the highest-priority template in
the stylesheet that matches each node identified by the
<tt class="literal">select</tt> attribute.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">select</tt>, optional</dt>
<dd>
This is an XPath expression that returns a node-set. Each node in
this set will be processed further. If the <tt class="literal">select</tt>
attribute is omitted, then all child nodes of the context node should
be processed.
</p>
</dd>


<dt><tt class="literal">mode</tt>, optional</dt>
<dd>
If the <tt class="literal">mode</tt> attribute is present, then only
templates that have a matching <tt class="literal">mode</tt> attribute will
be applied. If the <tt class="literal">mode</tt> attribute is absent, then
only templates without a <tt class="literal">mode</tt> attribute will be
applied.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>The <tt class="literal">xsl:apply-templates</tt> element may have
<tt class="literal">xsl:sort</tt> child elements to specify the order in
which the selected nodes will be processed. Without any
<tt class="literal">xsl:sort</tt> children, the default is to process nodes
in document order.
</p>

<p>The <tt class="literal">xsl:apply-templates</tt> element may have
<tt class="literal">xsl:with-param</tt> child elements to pass parameter
values to the matched templates.
</p>

</div>

<a name="ch23-10-fm2xml" /><a name="IXT-23-240615" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:attribute</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xsl:attribute
  name      = "<tt><em class="replaceable"><tt>QualifiedName</tt></em></tt>"
  namespace = "<tt><em class="replaceable"><tt>URI</tt></em></tt>"&gt;
  &lt;! --  template for the attribute value  -- &gt;
&lt;/xsl:attribute&gt;
</pre></td><td align="right" /></tr></table><a name="IXT-23-240615" />The
<tt class="literal">xsl:attribute</tt> instruction adds an attribute to an
element in the result tree. This element can be a child of an
<tt class="literal">xsl:attribute-set</tt> element, an
<tt class="literal">xsl:element</tt> instruction, or a literal result
element. In each case, all <tt class="literal">xsl:attribute</tt> elements
must precede all literal result elements and other instructions that
insert content into the output element.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, required, attribute value template</dt>
<dd>
The name of the attribute this instruction creates.</p>
</dd>


<dt><tt class="literal">namespace</tt>, optional, attribute value template</dt>
<dd>
The namespace URI of the attribute. If a nonempty namespace URI is
specified, then the processor will pick an appropriate prefix for the
attribute, probably but not necessarily the one used in the
<tt class="literal">name</tt> attribute.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>The contents of this element are a template whose instantiation only
produces text nodes. The value of the attribute added to the result
tree is determined by instantiating the template.
</p>

</div>

<a name="ch23-13-fm2xml" /><a name="IXT-23-240616" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:attribute-set</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xsl:attribute-set
  name = "<tt><em class="replaceable"><tt>QualifiedName</tt></em></tt>"
  use-attribute-sets = "<tt><em class="replaceable"><tt>QualifiedNames</tt></em></tt>"&gt;
  &lt;! --  xsl:attribute*  -- &gt;
&lt;/xsl:attribute-set&gt;
</pre></td><td align="right" /></tr></table><a name="IXT-23-240616" />The <tt class="literal">xsl:attribute-set</tt>
top-level element defines a collection of attributes that can be
applied to elements elsewhere in the stylesheet. For instance, you
could define an attribute set that includes the necessary attributes
to create a simple XLink, and then you could attach the set to each
simple XLink element.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, required</dt>
<dd>
The <tt class="literal">name</tt> attribute gives a name for the set, by
which <tt class="literal">xsl:element</tt> and other
<tt class="literal">xsl:attribute-set</tt> elements can load this attribute
set.
</p>
</dd>


<dt><tt class="literal">use-attribute-sets</tt><em class="emphasis">,</em></tt> optional</dt>
<dd>
The <tt class="literal">use-attribute-sets</tt> attribute adds attributes
from a different attribute set into this attribute set. More than one
attribute set can be loaded by separating multiple names with
whitespace. The attributes defined in all loaded sets and all
attributes defined by child <tt class="literal">xsl:attribute</tt> elements
are merged so that no attribute appears in the set more than once. It
is an error if an attribute set uses itself directly or indirectly.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>This element contains zero or more <tt class="literal">xsl:attribute</tt>
elements. Each such element adds one attribute to the set.
</p>

</div>

<a name="ch23-16-fm2xml" /><a name="IXT-23-240617" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:call-template</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xsl:call-template
   name = "<tt><em class="replaceable"><tt>QualifiedName</tt></em></tt>"&gt;
   &lt;! --  xsl:with-param*  -- &gt;
&lt;/xsl:call-template&gt;
</pre></td><td align="right" /></tr></table><a name="IXT-23-240617" />The <tt class="literal">xsl:call-template</tt>
instruction invokes a template by name. The current node and context
node list are the same for the called template as for the calling
template. Templates may be called recursively; an
<tt class="literal">xsl:template</tt> element may contain an
<tt class="literal">xsl:call-template</tt> element that calls that very
<tt class="literal">xsl:template</tt> element. This technique is useful for
doing things you'd accomplish with loops in a
traditional procedural programming language.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, required</dt>
<dd>
The name of the <tt class="literal">xsl:template</tt> element to call.</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>This element contains zero or more <tt class="literal">xsl:with-param</tt>
elements that pass parameters to the named template.
</p>

</div>

<a name="ch23-19-fm2xml" /><a name="IXT-23-240618" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:choose</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240618" />&lt;xsl:choose&gt;
  &lt;! --  (xsl:when+, xsl:otherwise?)  -- &gt;
&lt;/xsl:choose&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:choose</tt> element selects zero or one of a
sequence of alternatives.
</p>
<h4 class="refsect1">Contents</h4>


<p>This element contains one or more <tt class="literal">xsl:when</tt>
elements, each of which has a test condition. The contents are output
for the first <tt class="literal">xsl:when</tt> child whose test condition
is true.
</p>

<p>The <tt class="literal">xsl:choose</tt> element may have an optional
<tt class="literal">xsl:otherwise</tt> element whose contents are output
only if none of the test conditions in any of the
<tt class="literal">xsl:when</tt> elements is true.
</p>

<p>If no <tt class="literal">xsl:otherwise</tt> element exists and none of the
test conditions in any of the <tt class="literal">xsl:when</tt> child
elements is true, then this element will not produce output.
</p>

</div>

<a name="ch23-21-fm2xml" /><a name="IXT-23-240619" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:comment</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240619" />&lt;xsl:comment&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:comment&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:comment</tt> instruction inserts a comment into
the result tree.
</p>
<h4 class="refsect1">Contents</h4>


<p>The content of <tt class="literal">xsl:comment</tt> is a template that will
be instantiated to form the text of the comment inserted into the
result tree. The result of instantiating this template must only be
text nodes that do not contain the double hyphen
(<tt class="literal">--</tt>) (since comments cannot contain the double
hyphen).
</p>

</div>

<a name="ch23-23-fm2xml" /><a name="IXT-23-240620" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:copy</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240620" />&lt;xsl:copy
  use-attribute-sets = "<em class="replaceable"><tt>QualifiedName1 QualifiedName2...</tt></em>"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:copy&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:copy</tt> element copies the current node from
the source document into the output document. It copies the node
itself and any namespace nodes the node possesses. However, it does
not copy the node's children or attributes.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">use-attribute-sets</tt><em class="emphasis">,</em></tt> optional</dt>
<dd>
A whitespace-separated list of <tt class="literal">xsl:attribute-set</tt>
names. These attribute sets are merged, and all attributes in the
merged set are added to the copied element. The
<tt class="literal">use-attribute-sets</tt> attribute can be used only when
the copied node is an element node.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>If the current node is an element node, attributes can be added via
<tt class="literal">xsl:attribute</tt> children. If the current node is the
root node or an element node (a node that can have children), then
<tt class="literal">xsl:copy</tt> may contain a template that specifies the
content of the element inserted into the result tree. All
<tt class="literal">xsl:attribute</tt> elements must precede the output
template.
</p>

</div>

<a name="ch23-26-fm2xml" /><a name="IXT-23-240621" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:copy-of</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240621" />&lt;xsl:copy-of
   select = "<tt><em class="replaceable"><tt>expression</tt></em></tt>" /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:copy-of</tt> instruction inserts whatever is
identified by the <tt class="literal">select</tt> attribute into the output
document. This instruction copies the specific nodes identified by
the expression, as well as all those nodes'
children, attributes, namespaces, and descendants. This is how it
differs from <tt class="literal">xsl:copy</tt>: if the expression selects
something other than a node-set or a result-tree fragment, such as a
number, then the expression is converted to its string value and the
string is output.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">select</tt>, required</dt>
<dd>
An XPath expression identifying the object to copy into the result
tree.
</p>
</dd>

</dl>

</div>

<a name="ch23-28-fm2xml" /><a name="IXT-23-240622" /><a name="IXT-23-240623" /><a name="IXT-23-240624" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:decimal-format</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240622" />&lt;xsl:decimal-format
   name               = "<em class="replaceable"><tt>QualifiedName</tt></em>"&gt;
   decimal-separator  = "<em class="replaceable"><tt>char</tt></em>"
   grouping-separator = "<em class="replaceable"><tt>char</tt></em>"
   infinity           = "<em class="replaceable"><tt>string</tt></em>"
   minus-sign         = "<em class="replaceable"><tt>char</tt></em>"
   NaN                = "<em class="replaceable"><tt>string</tt></em>"
   percent            = "<em class="replaceable"><tt>char</tt></em>"
   per-mille          = "<em class="replaceable"><tt>char</tt></em>"
   zero-digit         = "<em class="replaceable"><tt>char</tt></em>"
   digit              = "<em class="replaceable"><tt>char</tt></em>"
   pattern-separator  = "<em class="replaceable"><tt>char</tt></em>" /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:decimal-format</tt> <a name="IXT-23-240623" />top-level element defines a
pattern by which the <tt class="literal">format-number(
)</tt><a name="IXT-23-240624" /> function can convert floating point
numbers into text strings. The defaults work well for English, but
details may change for other languages and locales, such as French or
Chinese.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, optional</dt>
<dd>
The string by which the <tt class="literal">format-number( )</tt> function
identifies the <tt class="literal">xsl:decimal-format</tt> element to use.
If this attribute is omitted, then this element establishes the
default decimal format used by the <tt class="literal">format-number(
)</tt> function.
</p>
</dd>


<dt><tt class="literal">decimal-separator</tt><em class="emphasis">,</em></tt> optional</dt>
<dd>
The character that separates the integer part from the fractional
point in a floating point number. This character is a period (decimal
point) in English and a comma in French. It may be something else in
other languages.
</p>
</dd>


<dt><tt class="literal">grouping-separator</tt><em class="emphasis">,</em></tt> optional</dt>
<dd>
The character that separates groups of digits (e.g., the comma that
separates every three digits in English).
</p>
</dd>


<dt><tt class="literal">infinity</tt>, optional</dt>
<dd>
The string that represents IEEE 754 infinity;
<tt class="literal">Infinity</tt> by default.
</p>
</dd>


<dt><tt class="literal">minus-sign</tt><em class="emphasis">,</em></tt> optional</dt>
<dd>
The character prefixed to negative numbers; a hyphen by default.</p>
</dd>


<dt><tt class="literal">NaN</tt>, optional</dt>
<dd>
The string that represents IEEE 754 Not a Number;
<tt class="literal">NaN</tt> by default.
</p>
</dd>


<dt><tt class="literal">percent</tt>, optional</dt>
<dd>
The character that represents a percent; <tt class="literal">%</tt> by
default.
</p>
</dd>


<dt><tt class="literal">per-mille</tt>, optional</dt>
<dd>
The character that represents a per mille;
<tt class="literal"><img src="figs/U2030.gif" alt="Figure " /></tt> by default.
</p>
</dd>


<dt><tt class="literal">zero-digit</tt><em class="emphasis">,</em></tt> optional</dt>
<dd>
The character that represents zero; <tt class="literal">0</tt> by default.
Digits 1 through 9 will be represented by the nine subsequent Unicode
values after this one. For instance, setting
<tt class="literal">zero-digit</tt> to <tt class="literal">A</tt> would set 1 to
<tt class="literal">B</tt>, 2 to <tt class="literal">C</tt>, 3 to
<tt class="literal">D</tt>, and so on. This is also the character used to
represent 0 in format patterns.
</p>
</dd>


<dt><tt class="literal">digit</tt>, optional</dt>
<dd>
The character that represents a digit in a format pattern;
<tt class="literal">#</tt> by default.
</p>
</dd>


<dt><tt class="literal">pattern-separator</tt><em class="emphasis">,</em></tt> optional</dt>
<dd>
The character that separates positive and negative subpatterns in a
format pattern; <tt class="literal">;</tt> by default.
</p>
</dd>

</dl>

</div>

<a name="ch23-30-fm2xml" /><a name="IXT-23-240625" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:element</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240625" />&lt;xsl:element
  name               = "<tt><em class="replaceable"><tt>QualifiedName</tt></em></tt>"
  namespace          = "<tt><em class="replaceable"><tt>URI</tt></em></tt>"
  use-attribute-sets = "<tt><em class="replaceable"><tt>QualifiedName1 QualifiedName2...</tt></em></tt>"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:element&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:element</tt> instruction inserts an element
into the result tree. The element's name is given by
the <tt class="literal">name</tt> attribute. The element's
namespace URI, if any, is given by the optional
<tt class="literal">namespace</tt> attribute. Attributes can be added via
<tt class="literal">xsl:attribute</tt> children or by referencing an
<tt class="literal">xsl:attribute-set</tt> declared elsewhere in the
stylesheet from the <tt class="literal">use-attribute-sets</tt> attribute.
Finally, the element's contents are determined by
instantiating the template contained in the
<tt class="literal">xsl:element</tt> element's content.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, required, attribute value template</dt>
<dd>
The name of the element this instruction creates.</p>
</dd>


<dt><tt class="literal">namespace</tt>, optional, attribute value template</dt>
<dd>
The namespace URI of the element this instruction creates. If this
attribute is omitted, then the namespace is determined by matching
the name's prefix (or lack thereof) to the namespace
declarations in scope at this point in the stylesheet.
</p>
</dd>


<dt><tt class="literal">use-attribute-sets</tt><em class="emphasis">,</em></tt> optional</dt>
<dd>
A whitespace-separated list of names of
<tt class="literal">xsl:attribute-set</tt> elements declared as top-level
elements elsewhere in the stylesheet. These attribute sets are
merged, and all attributes in the merged set are added to the
element.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>The contents of this element are a template. Once instantiated, this
template forms the content of the element inserted into the result
tree.
</p>

</div>

<a name="ch23-33-fm2xml" /><a name="IXT-23-240626" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:fallback</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240626" />&lt;xsl:fallback&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:fallback&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:fallback</tt> instruction normally appears as a
child of an extension element. If the processor does not recognize
the extension element, then it instantiates the contents of all the
element's <tt class="literal">xsl:fallback</tt> children
in order. If the processor does recognize the element in which the
<tt class="literal">xsl:fallback</tt> element appears, then the contents of
the <tt class="literal">xsl:fallback</tt> element will not be output.
</p>
<h4 class="refsect1">Contents</h4>


<p>The contents of this element are a template that is instantiated and
output if and only if the XSLT processor does not recognize the
<tt class="literal">xsl:fallback</tt> element's parent
element.
</p>

</div>

<a name="ch23-35-fm2xml" /><a name="IXT-23-240627" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:for-each</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240627" />&lt;xsl:for-each
   select = "<em class="replaceable"><tt>node-set-expression</tt></em>"&gt;
   &lt;! --  (xsl:sort*, template)  -- &gt;
&lt;/xsl:for-each&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:for-each</tt> instruction iterates over the
nodes identified by its <tt class="literal">select</tt> attribute and
applies templates to each one.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">select</tt>, required</dt>
<dd>
An XPath node-set expression identifying which nodes to iterate over.</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>Normally, the selected nodes are processed in the order in which they
appear in the document. However, nodes can be sorted using
<tt class="literal">xsl:sort</tt> child elements. The first such element is
the primary sort key; the second is the secondary sort key; and so
on.
</p>

<p>The <tt class="literal">xsl:for-each</tt> element must also contain a
template that is instantiated once for each member of the node-set
returned by the node-set expression in the <tt class="literal">select</tt>
attribute.
</p>

</div>

<a name="ch23-38-fm2xml" /><a name="IXT-23-240628" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:if</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240628" />&lt;xsl:if
  test = "<tt><em class="replaceable"><tt>boolean-expression</tt></em></tt>"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:if&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:if</tt> instruction contains a template that is
instantiated if and only if the XPath expression contained in its
<tt class="literal">test</tt> attribute is <tt class="literal">true</tt>. There
is no <tt class="literal">xsl:else</tt> or <tt class="literal">xsl:else-if</tt>
element. For these purposes, use <tt class="literal">xsl:choose</tt>
instead.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">test</tt>, required</dt>
<dd>
An XPath expression returning a Boolean. If this expression is
<tt class="literal">true</tt>, the contents of the
<tt class="literal">xsl:if</tt> element are instantiated. If
it's <tt class="literal">false</tt>,
they're not.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>A template is instantiated if the <tt class="literal">test</tt> attribute
evaluates to <tt class="literal">true</tt>.
</p>

</div>

<a name="ch23-41-fm2xml" /><a name="IXT-23-240629" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:import</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240629" />&lt;xsl:import
  href = "<em class="replaceable"><tt>URI</tt></em>" /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:import</tt> top-level element imports the XSLT
stylesheet found at the URI given by the <tt class="literal">href</tt>
attribute. Source documents are processed using the combination of
templates in the imported and importing stylesheets. In the event of
a conflict between templates in the two stylesheets, the ones in the
importing stylesheet take precedence. In the event of a conflict
between imported stylesheets, the last one imported takes precedence.
</p><p>All <tt class="literal">xsl:import</tt> elements must be immediate children
of the root <tt class="literal">xsl:stylesheet</tt> element. Furthermore,
they must appear before all other top-level elements.
</p><p>An imported stylesheet may itself import another stylesheet. A
stylesheet may not import a stylesheet that was already imported,
directly or indirectly. That is, it's an error if A
imports B, which imports A, thus creating a circular reference.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">href</tt>, required</dt>
<dd>
The relative or absolute URI of the stylesheet to import. Relative
URIs are resolved relative to the base URI of the importing
stylesheet.
</p>
</dd>

</dl>

</div>

<a name="ch23-43-fm2xml" /><a name="IXT-23-240630" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:include</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240630" />&lt;xsl:include
   href = "<tt><em class="replaceable"><tt>URI</tt></em></tt>" /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:include</tt> top-level element copies the
contents of the <tt class="literal">xsl:stylesheet</tt> or
<tt class="literal">xsl:transform</tt> element found at the URI given by
the <tt class="literal">href</tt> attribute. Unlike
<tt class="literal">xsl:import</tt>, whether a template or other rule comes
from the including or the included stylesheet has absolutely no
effect on the precedence of the various rules.
</p><p>An included stylesheet may include another stylesheet. A stylesheet
may not include a stylesheet that was already included, directly or
indirectly; it is an error if A includes B, which includes A.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">href</tt>, required</dt>
<dd>
The relative or absolute URI of the stylesheet to include. Relative
URIs are resolved relative to the including
stylesheet's base URI.
</p>
</dd>

</dl>

</div>

<a name="ch23-45-fm2xml" /><a name="IXT-23-240631" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:key</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240631" />&lt;xsl:key
   name  = "<em class="replaceable"><tt>QualifiedName</tt></em>"
   match = "<em class="replaceable"><tt>pattern</tt></em>"
   use   = "<em class="replaceable"><tt>expression</tt></em>" /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:key</tt> top-level element defines one or more
keys that can be referenced from elsewhere in the stylesheet using
the <tt class="literal">key( )</tt> function. Each key has a name, a string
value, and a node.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, required</dt>
<dd>
The key's name.</p>
</dd>


<dt><tt class="literal">match</tt>, required</dt>
<dd>
An XSLT match pattern, like that used by
<tt class="literal">xsl:template</tt>, specifying which nodes have this
key. If this pattern matches more than one node in the source
document, then a single <tt class="literal">xsl:key</tt> element may define
many keys, all with the same name and possibly the same value, but
with different nodes.
</p>
</dd>


<dt><tt class="literal">use</tt>, required</dt>
<dd>
An XPath expression that is converted to a string to give the value
of keys defined by this element. The expression is evaluated with
respect to each key's node. If
<tt class="literal">match</tt> identifies multiple nodes, then
<tt class="literal">use</tt> may produce different values for each key.
</p>
</dd>

</dl>

</div>

<a name="ch23-47-fm2xml" /><a name="IXT-23-240632" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:message</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240632" />&lt;xsl:message
  terminate = "yes" | "no"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:message&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:message</tt> instruction sends a message to the
XSLT processor. Which messages the processor understands and what it
does with messages it does understand is processor dependent.
Printing debugging information on <tt class="literal">stderr</tt> or
<tt class="literal">stdout</tt> is one common use of
<tt class="literal">xsl:message</tt>.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">terminate</tt>, optional</dt>
<dd>
If the attribute is present and has the value <tt class="literal">yes</tt>,
then the XSLT processor should halt after the message is delivered
and acted on.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>An <tt class="literal">xsl:message</tt> element's content
is a template instantiated to create an <em class="emphasis">XML
fragment</em>. The result is then delivered to the XSLT
processor as the message.
</p>

<a name="ch23-50-fm2xml" /><blockquote><b>WARNING:</b> 
The XSLT specification does not define <em class="emphasis">XML
fragment,</em> and various XSLT processors interpret it
differently. It may be a result tree fragment or an XML fragment, as
defined by the now moribund XML Fragment Interchange working draft.
It may be something else. Clarification from the W3C is necessary.
</p>
</blockquote>

</div>

<a name="ch23-51-fm2xml" /><a name="IXT-23-240633" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:namespace-alias</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240633" />&lt;xsl:namespace-alias
   stylesheet-prefix = "<em class="replaceable"><tt>prefix</tt></em>"
   result-prefix     = "<em class="replaceable"><tt>prefix</tt></em>" /&gt;
</pre></td><td align="right" /></tr></table>The top-level <tt class="literal">xsl:namespace-alias</tt> element declares
that one namespace URI in the stylesheet should be replaced by a
different namespace URI in the result tree. Aliasing is particularly
useful when you're transforming XSLT into XSLT using
XSLT; consequently, which names belong to the input, which belong to
the output, and which belong to the stylesheet is not obvious.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">stylesheet-prefix</tt>, required</dt>
<dd>
The prefix used inside the stylesheet itself. May be set to
<tt class="literal">#default</tt> to indicate that the nonprefixed default
namespace should be used.
</p>
</dd>


<dt><tt class="literal">result-prefix</tt>, required</dt>
<dd>
The prefix used in the result tree. May be set to
<tt class="literal">#default</tt> to indicate that the nonprefixed default
namespace should be used.
</p>
</dd>

</dl>

</div>

<a name="ch23-53-fm2xml" /><a name="IXT-23-240634" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:number</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240634" />&lt;xsl:number
   value  = "<em class="replaceable"><tt>number-expression</tt></em>"
   count  = "<em class="replaceable"><tt>pattern</tt></em>"
   from   = "<em class="replaceable"><tt>pattern</tt></em>"
   level  = "single" | "multiple" | "any"
   format = "<em class="replaceable"><tt>letter or digit</tt></em>"
   lang   = "<em class="replaceable"><tt>langcode</tt></em>"
   letter-value = "alphabetic" | "traditional"
   grouping-separator = "<em class="replaceable"><tt>char</tt></em>"
   grouping-size = "<em class="replaceable"><tt>number</tt></em>" /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:number</tt> instruction inserts a formatted
integer into the result tree.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">value</tt>, optional</dt>
<dd>
This XPath expression returns the number to be formatted. If
necessary, the result of the expression is rounded to the nearest
integer. The <tt class="literal">value</tt> attribute is often omitted, in
which case the number is calculated from the position of the current
node in the source document. The position is calculated as specified
by the <tt class="literal">level</tt>, <tt class="literal">count</tt>, and
<tt class="literal">from</tt> attributes.
</p>
</dd>


<dt><tt class="literal">level</tt>, optional</dt>
<dd>
This attribute specifies which levels of the source tree should be
considered in determining the position of the current node. It can be
set to <tt class="literal">single</tt> to count the preceding siblings of
the current node's ancestor that match the
<tt class="literal">count</tt> pattern. It can be set to
<tt class="literal">any</tt> to count all nodes in the document that match
the <tt class="literal">count</tt> pattern and precede the current node. It
can be set to <tt class="literal">multiple</tt> to produce hierarchical
sequences of numbers such as 2.7.3, where each number in the sequence
is calculated from the preceding sibling's ancestor
node that matches the <tt class="literal">count</tt> pattern. The default
is <tt class="literal">single</tt>.
</p>
</dd>


<dt><tt class="literal">count</tt>, optional</dt>
<dd>
This attribute contains a pattern that specifies which nodes should
be counted at those levels. The default is to count all nodes with
the same node type (element, text, attribute, etc.) and name as the
current node.
</p>
</dd>


<dt><tt class="literal">from</tt>, optional</dt>
<dd>
This attribute contains a pattern identifying the node from which
counting starts; that is, it identifies a node that serves as a
cutoff point. Any nodes that precede this node are not counted, even
if they match the <tt class="literal">count</tt> pattern.
</p>
</dd>


<dt><tt class="literal">format</tt>, optional, attribute value template</dt>
<dd>
This attribute determines how the list is numbered. Format tokens and
sequences they produce include the following:
</p>

<dl>
<dt><i>1</i></dt>
<dd>
1, 2, 3, 4, 5, 6, . . . </p>
</dd>


<dt><i>01</i></dt>
<dd>
01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, . . . </p>
</dd>


<dt><i>A</i></dt>
<dd>
A, B, C, D, . . . ,Z, AA, AB, AC, . . . </p>
</dd>


<dt><i>a</i></dt>
<dd>
a, b, c, d, . . . ,z, aa, ab, ac, . . . </p>
</dd>


<dt><i>i</i></dt>
<dd>
i, ii, iii, iv, v, vi, vii, viii, ix, x, xi, . . . </p>
</dd>


<dt><i>I</i></dt>
<dd>
I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, . . . </p>

<p>You can also change the starting point; for instance, setting the
format token to 5 would create the sequence 5, 6, 7, 8, 9, . . .
</p>
</dd>

</dl>
</dd>


<dt><tt class="literal">lang</tt>, optional, attribute value template</dt>
<dd>
This is the RFC 1766 language code describing the language in which
the number should be formatted (e.g., <tt class="literal">en</tt> or
<tt class="literal">fr</tt>).
</p>
</dd>


<dt><tt class="literal">letter-value</tt>, optional, attribute value template</dt>
<dd>
The default is <tt class="literal">traditional</tt>. However, you can set
this attribute to <tt class="literal">alphabetic</tt> to indicate that a
<tt class="literal">format</tt> of <tt class="literal">I</tt> should start the
sequence I, J, K, L, M, N, . . . rather than I, II, III, IV, V, VI, .
. .
</p>
</dd>


<dt><tt class="literal">grouping-separator</tt>, optional, attribute value template</dt>
<dd>
This is the character that separates groups of digits. For instance,
in English the comma customarily separates every three digits, as in
2,987,667,342. In French a space is used instead, so this number
would be formatted as 2 987 667 342.
</p>
</dd>


<dt><tt class="literal">grouping-size</tt>, optional, attribute value template</dt>
<dd>
This is the number of digits in each group. In most languages,
including English, digits are divided into groups of three. However,
a few languages use groups of four.
</p>
</dd>

</dl>

</div>

<a name="ch23-55-fm2xml" /><a name="IXT-23-240635" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:otherwise</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240635" />&lt;xsl:otherwise&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:otherwise&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:otherwise</tt> element only appears as the last
child element of an <tt class="literal">xsl:choose</tt> element. It serves
as the default result if no <tt class="literal">xsl:when</tt> element in
the same <tt class="literal">xsl:choose</tt> element is instantiated.
</p>
<h4 class="refsect1">Contents</h4>


<p>The contents are a template that is instantiated if and only if none
of the <tt class="literal">xsl:choose</tt> element's
<tt class="literal">xsl:when</tt> sibling elements is
<tt class="literal">true</tt>.
</p>

</div>

<a name="ch23-57-fm2xml" /><a name="IXT-23-240636" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:output</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240636" />&lt;xsl:output
  method                 = "xml" | "html" | "text" | "<tt><em class="replaceable"><tt>PrefixedName</tt></em></tt>"
  version                = "<tt><em class="replaceable"><tt>NMTOKEN</tt></em></tt>"
  encoding               = "<tt><em class="replaceable"><tt>encoding_name</tt></em></tt>"
  omit-xml-declaration   = "yes" | "no"
  standalone             = "yes" | "no"
  doctype-public         = "<tt><em class="replaceable"><tt>PUBLIC_ID</tt></em></tt>"
  doctype-system         = "<tt><em class="replaceable"><tt>SYSTEM_ID</em></tt>"  cdata-section-elements = "<tt><em class="replaceable">element_name_1</em></tt> <tt><em class="replaceable">element_name_2</tt></em></tt>..."
  indent                 = "yes" | "no"
  media-type             = "<tt><em class="replaceable"><tt>string</tt></em></tt>" /&gt;
</pre></td><td align="right" /></tr></table>The top-level <tt class="literal">xsl:output</tt> element helps determine
the exact formatting of the XML document produced when the result
tree is stored in a file, written onto a stream, or otherwise
serialized into a sequence of bytes. It has no effect on the
production of the result tree itself.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">method</tt>, optional</dt>
<dd>
The default method is <tt class="literal">xml</tt>, which simply means that
the serialized output document will be a well-formed external parsed
entity or XML document. If <tt class="literal">method</tt> is set to
<tt class="literal">html</tt> or if the <tt class="literal">method</tt> attribute
is not present and the root element of the output tree is
<tt class="literal">html</tt>, in any combination of case, then the
processor attempts to generate HTML that is more compatible with
existing browsers. For example, empty-element tags like
<tt class="literal">&lt;br/&gt;</tt> are converted to
<tt class="literal">&lt;br&gt;</tt>. The <tt class="literal">text</tt> method
outputs only the contents of the text nodes in the output tree. It
strips all markup. XSLT processors may also recognize and support
other values that are indicated by prefixed names such as
<tt class="literal">saxon:xhtml</tt> and
<tt class="literal">jd:canonical-xml</tt>.
</p>
</dd>


<dt><tt class="literal">version</tt> , optional</dt>
<dd>
This is a name token that identifies the output
method's version. In practice, this has no effect on
the output.
</p>
</dd>


<dt><tt class="literal">encoding</tt>, optional</dt>
<dd>
This is the name of the encoding the outputter should use, such as
ISO-8859-1 or UTF-16.
</p>
</dd>


<dt><tt class="literal">omit-xml-declaration</tt>, optional</dt>
<dd>
If this attribute has the value <tt class="literal">yes</tt>, then no XML
declaration is included. If it has the value <tt class="literal">no</tt> or
is not present, then an XML declaration is included.
</p>
</dd>


<dt><tt class="literal">standalone</tt>, optional</dt>
<dd>
This attribute sets the <tt class="literal">standalone</tt>
attribute's value in the XML declaration. Like that
attribute, it must have the value <tt class="literal">yes</tt> or
<tt class="literal">no</tt>.
</p>
</dd>


<dt><tt class="literal">doctype-public</tt>, optional</dt>
<dd>
This attribute sets the public identifier used in the document type
declaration.
</p>
</dd>


<dt><tt class="literal">doctype-system</tt>, optional</dt>
<dd>
This attribute sets the system identifier used in the document type
declaration.
</p>
</dd>


<dt><tt class="literal">cdata-section-elements</tt>, optional</dt>
<dd>
This is a whitespace-separated list of qualified element names in the
result tree whose contents should be emitted using CDATA sections
rather than character references.
</p>
</dd>


<dt><tt class="literal">indent</tt>, optional</dt>
<dd>
If this attribute has the value <tt class="literal">yes</tt>, then the
processor is allowed (but not required) to insert extra whitespace to
attempt to "pretty-print" the
output tree. The default is <tt class="literal">no</tt>.
</p>
</dd>


<dt><tt class="literal">media-type</tt>, optional</dt>
<dd>
This is the output's MIME media type, such as
<tt class="literal">text/html</tt> or <tt class="literal">text/xml</tt>.
</p>
</dd>

</dl>

</div>

<a name="ch23-59-fm2xml" /><a name="IXT-23-240637" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:param</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240637" />&lt;xsl:param
  name   = "<tt><em class="replaceable"><tt>QualifiedName</tt></em></tt>"
  select = "<tt><em class="replaceable"><tt>expression</tt></em></tt>"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:param&gt;
</pre></td><td align="right" /></tr></table>Inside an <tt class="literal">xsl:template</tt> element, an
<tt class="literal">xsl:param</tt> element receives a named argument passed
to the template by <tt class="literal">xsl:with-param</tt>. It also
provides a default value that's used when the caller
does not provide a value for the parameter. A top-level
<tt class="literal">xsl:param</tt> element provides a default value for
multiple templates. If an <tt class="literal">xsl:apply-templates</tt> or
<tt class="literal">xsl:call-template</tt> passes in a parameter value
using <tt class="literal">xsl:with-param</tt> when the template is invoked,
then this value overrides any default value the
<tt class="literal">xsl:param</tt> element may have. The parameter can be
dereferenced using the form
<tt class="literal">$</tt><em class="emphasis">name</em></tt> in expressions.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, required</dt>
<dd>
The parameter's name.</p>
</dd>


<dt><tt class="literal">select</tt>, optional</dt>
<dd>
An XPath expression that is evaluated to produce the
parameter's value. If <tt class="literal">xsl:param</tt>
has a <tt class="literal">select</tt> attribute, then it must be an empty
element. If a nonempty <tt class="literal">xsl:param</tt> element does not
have a <tt class="literal">select</tt> attribute, then the value is taken
from the element's contents. If an empty
<tt class="literal">xsl:param</tt> element does not have a
<tt class="literal">select</tt> attribute, then the value is the empty
string.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>An <tt class="literal">xsl:param</tt> element's content is
a template that is instantiated to produce a result-tree fragment.
This result-tree fragment then becomes the
parameter's value. A nonempty
<tt class="literal">xsl:param</tt> element must not have a
<tt class="literal">select</tt> attribute.
</p>

</div>

<a name="ch23-62-fm2xml" /><a name="IXT-23-240638" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:preserve-space</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240638" />&lt;xsl:preserve-space
   elements="<tt><em class="replaceable"><tt>QualifiedName_1 QualifiedName_2...</tt></em></tt>" /&gt;
</pre></td><td align="right" /></tr></table>The top-level <tt class="literal">xsl:preserve-space</tt> element specifies
which elements in the source document will not have whitespace
stripped from them before they are transformed. Whitespace stripping
removes text nodes that contain only whitespace (the space character,
the tab character, the carriage return, and the linefeed). By
default, whitespace is preserved in an element unless its name is
listed in the <tt class="literal">elements</tt> attribute of an
<tt class="literal">xsl:strip-space</tt> element. This element allows you
to override the list given in <tt class="literal">xsl:strip-space</tt>; if
an element is listed in both <tt class="literal">xsl:strip-space</tt> and
<tt class="literal">xsl:preserve-space</tt>, then its whitespace is
preserved.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">elements</tt>, required</dt>
<dd>
A whitespace-separated list of elements in which space should be
preserved. Besides element names, the <tt class="literal">elements</tt>
attribute can contain an asterisk to indicate that whitespace should
be preserved in all elements or contain a namespace prefix followed
by a colon and an asterisk to indicate that whitespace should be
preserved in all elements in the given namespace.
</p>
</dd>

</dl>

</div>

<a name="ch23-64-fm2xml" /><a name="IXT-23-240639" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:processing-instruction</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240639" />&lt;xsl:processing-instruction
  name = "<em class="replaceable"><tt>target</tt></em>"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:processing-instruction&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:processing-instruction</tt> element inserts a
processing instruction into the result tree.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, required, attribute value template</dt>
<dd>
The processing instruction's target.</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>The <tt class="literal">xsl:processing-instruction</tt>
element's contents are a template that is
instantiated to produce the processing-instruction data. This
template may include XSLT instructions, provided that the result of
instantiating this template is text that does not contain the
two-character string <tt class="literal">?&gt;</tt>.
</p>

</div>

<a name="ch23-67-fm2xml" /><a name="IXT-23-240640" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:sort</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240640" />&lt;xsl:sort
   select     = "<tt><em class="replaceable"><tt>string-expression</tt></em></tt>"
   data-type  = "text" | "number" | "<tt><em class="replaceable"><tt>PrefixedName</tt></em></tt>"
   lang       = "<tt><em class="replaceable"><tt>langcode</tt></em></tt>"
   order      = "ascending" | "descending"
   case-order = "upper-first" | "lower-first" /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:sort</tt> instruction appears as a child of
either <tt class="literal">xsl:apply-templates</tt> or
<tt class="literal">xsl:for-each</tt>. It changes the order in which
templates are applied to the context node list from document order to
another order, such as alphabetic. You can perform multiple key sorts
(e.g., sort first by last name, then by first name, then by middle
name) using multiple <tt class="literal">xsl:sort</tt> elements in
descending order of the keys' importance.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">select</tt>, optional</dt>
<dd>
This is the key to sort by. If <tt class="literal">select</tt> is omitted,
then the sort key is set to the value of the current node.
</p>
</dd>


<dt><tt class="literal">data-type</tt>, optional, attribute value template</dt>
<dd>
By default, sorting is purely alphabetic. However, alphabetic sorting
leads to strange results with numbers. For instance, 10, 100, and
1000 all sort before 2, 3, and 4. You can specify numeric sorting by
setting the <tt class="literal">data-type</tt> attribute to
<tt class="literal">number</tt>.
</p>
</dd>


<dt><tt class="literal">lang</tt>, optional, attribute value template</dt>
<dd>
Sorting is language dependent. Setting the <tt class="literal">lang</tt>
attribute to an RFC 1766 language code changes the language. The
default language is system dependent.
</p>
</dd>


<dt><tt class="literal">order</tt>, optional, attribute value template</dt>
<dd>
This is the order by which strings are sorted. This order can be
either <tt class="literal">descending</tt> or <tt class="literal">ascending</tt>.
The default is ascending order.
</p>
</dd>


<dt><tt class="literal">case-order</tt>, optional, attribute value template</dt>
<dd>
The <tt class="literal">case-order</tt> attribute can be set to
<tt class="literal">upper-first</tt> or <tt class="literal">lower-first</tt> to
specify whether uppercase letters sort before lowercase letters, or
vice versa. The default depends on the language.
</p>
</dd>

</dl>

</div>

<a name="ch23-69-fm2xml" /><a name="IXT-23-240641" /><a name="IXT-23-240642" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:strip-space</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240641" />&lt;xsl:strip-space
   elements="<em class="replaceable"><tt>QualifiedName_1 QualifiedName_2...</tt></em>" /&gt;
</pre></td><td align="right" /></tr></table>The top-level <tt class="literal">xsl:strip-space</tt> element
<a name="IXT-23-240642" />specifies
which elements in the source document have whitespace stripped from
them before they are transformed. Whitespace stripping removes all
text nodes that contain only whitespace (the space character, the tab
character, the carriage return, and the linefeed). By default
whitespace is not stripped from an element unless its name is listed
in the <tt class="literal">elements</tt> attribute of an
<tt class="literal">xsl:strip-space</tt> element.
</p><p>This element does not trim leading or trailing whitespace or
otherwise normalize whitespace in elements that contain even a single
nonwhitespace character.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">elements</tt>, required</dt>
<dd>
A whitespace-separated list of elements in which space should be
stripped. Besides element names, the <tt class="literal">elements</tt>
attribute can contain an asterisk to indicate that whitespace should
be stripped in all elements or contain a namespace prefix followed by
a colon and asterisk to indicate that whitespace should be stripped
in all elements in the given namespace.
</p>
</dd>

</dl>

</div>

<a name="ch23-90464" /><a name="IXT-23-240643" /><a name="IXT-23-240644" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:stylesheet</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240643" />
<a name="IXT-23-240644" />&lt;xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  id = "<tt><em class="replaceable"><tt>ID</tt></em></tt>"
  extension-element-prefixes = "<tt><em class="replaceable"><tt>prefix1 prefix2...</tt></em></tt>"
  exclude-result-prefixes = "<tt><em class="replaceable"><tt>prefix1 prefix2...</tt></em></tt>"
  version = "1.0"&gt;
  &lt;! --  (xsl:import*, top-level-elements)  -- &gt;
&lt;/xsl:stylesheet&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:stylesheet</tt> element is the root element for
XSLT documents.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">xmlns:xsl</tt>, technically optional but de facto required</dt>
<dd>
A standard namespace declaration that maps the prefix
<tt class="literal">xsl</tt> to the namespace URI
<tt class="literal">http://www.w3.org/1999/XSL/Transform</tt>. The prefix
can be changed if necessary.
</p>
</dd>


<dt><tt class="literal">version</tt>, required</dt>
<dd>
Currently, always the value <tt class="literal">1.0</tt>. However, XSLT 2.0
may be released in 2003 with a concurrent updating of this number.
</p>
</dd>


<dt><tt class="literal">id</tt>, optional</dt>
<dd>
Any XML name that's unique within this
document's ID type attributes.
</p>
</dd>


<dt><tt class="literal">extension-element-prefixes</tt>, optional</dt>
<dd>
A whitespace-separated list of namespace prefixes used by this
document's extension elements.
</p>
</dd>


<dt><tt class="literal">exclude-result-prefixes</tt>, optional</dt>
<dd>
A whitespace-separated list of namespace prefixes whose declarations
should not be copied into the output document.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>Any <tt class="literal">xsl:import</tt> elements, followed by any other
top-level elements in any order.
</p>

</div>

<a name="ch23-73-fm2xml" /><a name="IXT-23-240645" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:template</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240645" />&lt;xsl:template
  match    = "<em class="replaceable"><tt>pattern</tt></em>"
  priority = "<em class="replaceable"><tt>number</tt></em>"
  name     = "<em class="replaceable"><tt>QualifiedName</tt></em>"
  mode     = "<em class="replaceable"><tt>QualifiedName</tt></em>"&gt;
  &lt;! --  (xsl:param*, template)  -- &gt;
&lt;/xsl:template&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:template</tt> top-level element is the key to
all of XSLT. A little confusingly, the
<tt class="literal">xsl:template</tt> element itself is not a template.
Rather, it contains a template. The entire
<tt class="literal">xsl:template</tt> element is called a
<em class="emphasis">template rule</em>. The <tt class="literal">match</tt>
attribute contains a pattern against which nodes are compared as
they're processed. If the pattern matches a node,
then the template (i.e., the contents of the template rule) is
instantiated and inserted into the output tree.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">match</tt>, optional</dt>
<dd>
A pattern against which nodes can be compared. This pattern is a
location path using only the child, attribute, and descendant-or-self
axes.
</p>
</dd>


<dt><tt class="literal">name</tt>, optional</dt>
<dd>
A name by which this template rule can be invoked from an
<tt class="literal">xsl:call-template</tt> element, rather than by node
matching.
</p>
</dd>


<dt><tt class="literal">priority</tt>, optional</dt>
<dd>
A number. If more than one template rule with the same import
precedence matches a given node, the one with the highest priority is
chosen. If this attribute is not present, then the template
rule's priority is calculated in the following way:
</p>


<ul><li><p>Template rules with match patterns composed of just an element or attribute name (e.g., <tt class="literal">person</tt> or <tt class="literal">@profession</tt>) have priority 0.</p></li>
<li><p>Template rules with match patterns composed of just a <tt class="literal">processing-instruction('</tt><tt><em class="replaceable"><tt>target</tt></em></tt><tt class="literal">')</tt> node test have priority 0.</p></li>
<li><p>Template rules with match patterns in the form <tt><em class="replaceable"><tt>prefix</tt></em></tt><tt class="literal">:*</tt> have priority -0.25.</p></li>
<li><p>Template rules with match patterns that just have a wildcard node test (<tt class="literal">*</tt>, <tt class="literal">@*</tt>, <tt class="literal">comment( )</tt>, <tt class="literal">node( )</tt>, <tt class="literal">text()</tt>, and <tt class="literal">processing-instruction( )</tt>) have priority -0.5. (This means that built-in template rules have priority -0.5. However, they are also imported before all other template rules, and thus never override any explicit template rule, regardless of priority.)</p></li>
<li><p>Template rules with any other patterns (<tt class="literal">person[name='Feynman']</tt>, <tt class="literal">people/person/@profession</tt>, <tt class="literal">person/text( )</tt>, etc.) have priority 0.5.</p></li>
<li><p>It is an error if two or more template rules match a node and have the same priority. However, in this case most XSLT processors choose the last template rule occurring in the stylesheet rather than signaling the error.</p></li>
</ul>
</dd>


<dt><tt class="literal">mode</tt>, optional</dt>
<dd>
If the <tt class="literal">xsl:template</tt> element has a mode, then this
template rule is matched only when the calling
instruction's <tt class="literal">mode</tt> attribute
matches this <tt class="literal">mode</tt> attribute's
value.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>The template that should be instantiated when this element is matched
or called by name.
</p>

</div>

<a name="ch23-76-fm2xml" /><a name="IXT-23-240646" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:text</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240646" />&lt;xsl:text
   disable-output-escaping = "yes" | "no"&gt;
   &lt;! --  #PCDATA  -- &gt;
&lt;/xsl:text&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:text</tt> instruction is used inside templates
to indicate that its contents should be output as text. Its contents
are pure text, not elements. If the contents are composed exclusively
of whitespace, then that whitespace is copied literally into the
output document, rather than being stripped as it would be by default
in most other elements.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">disable-output-escaping</tt>, optional</dt>
<dd>
Setting the <tt class="literal">disable-output-escaping</tt> attribute to
<tt class="literal">yes</tt> indicates that characters such as
<tt class="literal">&lt;</tt> and <tt class="literal">&amp;</tt>, which are
normally replaced by character or entity references such as
<tt class="literal">&amp;lt;</tt> or <tt class="literal">&amp;#x3C;</tt>, should
instead be output as the literal characters themselves. Note that the
<tt class="literal">xsl:text</tt> element's content in the
stylesheet must still be well-formed, and any <tt class="literal">&lt;</tt>
or <tt class="literal">&amp;</tt> characters must be written as
<tt class="literal">&amp;lt;</tt> or <tt class="literal">&amp;amp;</tt> or the
equivalent character references. However, when the output document is
serialized, these references are replaced by the actual represented
characters rather than references that represent them.
</p>
</dd>

</dl>

</div>

<a name="ch23-78-fm2xml" /><a name="IXT-23-240647" /><a name="IXT-23-240648" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:transform</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240647" /><a name="IXT-23-240648" />&lt;xsl:transform
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  id = "<tt><em class="replaceable"><tt>ID</tt></em></tt>"
  extension-element-prefixes = "<tt><em class="replaceable"><tt>prefix1 prefix2...</tt></em></tt>"
  exclude-result-prefixes = "<tt><em class="replaceable"><tt>prefix1 prefix2...</tt></em></tt>"
  version = "1.0"&gt;
  &lt;! --  (xsl:import*, top-level-elements)  -- &gt;
&lt;/xsl:transform&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:transform</tt> element is a seldom-used synonym
for the <tt class="literal">xsl:stylesheet</tt> root element. It has the
same attributes and contents as <tt class="literal">xsl:stylesheet</tt> and
is used in exactly the same way as <tt class="literal">xsl:stylesheet</tt>.
See the description of the <a href="ch23_02.htm">xsl:stylesheet</a><tt class="literal">"</tt> element
for the discussion of its attributes and content.
</p></div>

<a name="ch23-79-fm2xml" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:value-of</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xsl:value-of
   select = "<tt><em class="replaceable"><tt>expression</tt></em></tt>"
   disable-output-escaping = "yes" | "no" /&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:value-of</tt> element computes the string value
of an XPath expression and inserts it into the result tree. The
values of the seven different kinds of nodes are as follows:
</p><dl>
<dt><i>element</i></dt>
<dd>
The text content of the element after all entity references are
resolved and all tags, comments, and processing instructions are
stripped
</p>
</dd>


<dt><i>text</i></dt>
<dd>
The text of the node</p>
</dd>


<dt><i>attribute</i></dt>
<dd>
The normalized value of the attribute</p>
</dd>


<dt><i>root</i></dt>
<dd>
The value of the root element</p>
</dd>


<dt><i>processing instruction</i></dt>
<dd>
The processing instruction data (<tt class="literal">&lt;?</tt>,
<tt class="literal">?&gt;</tt>, and the target are not included)
</p>
</dd>


<dt><i>comment</i></dt>
<dd>
The text of the comment (<tt class="literal">&lt;!--</tt> and
<tt class="literal">--&gt;</tt> are not included)
</p>
</dd>


<dt><i>namespace</i></dt>
<dd>
The namespace URI</p>
</dd>

</dl><p>You can also take values of things that aren't
nodes. The value of a node-set is the value of the first node in the
set. The value of a string expression is the string. The value of a
number expression is the string form of the number. The value of a
Boolean expression is the string <tt class="literal">true</tt> if the
Boolean is true or the string <tt class="literal">false</tt> if the Boolean
is false.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">select</tt>, required</dt>
<dd>
This is the XPath expression whose value is inserted into the result
tree.
</p>
</dd>


<dt><tt class="literal">disable-output-escaping</tt>, optional</dt>
<dd>
If this attribute has the value <tt class="literal">yes</tt>, then when the
output document is serialized, characters such as
<tt class="literal">&lt;</tt> and <tt class="literal">&amp;</tt> in the value are
not replaced with entity or character references. This may result in
a malformed document.
</p>
</dd>

</dl>

</div>

<a name="ch23-81-fm2xml" /><a name="IXT-23-240649" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:variable</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240649" />&lt;xsl:variable
  name   = "<em class="replaceable"><tt>QualifiedName</tt></em>"
  select = "<em class="replaceable"><tt>expression</tt></em>"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:variable&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:variable</tt> element binds a name to a value
of any type (string, number, node-set, etc.). This variable can then
be dereferenced elsewhere using the form
<tt class="literal">$</tt><em class="emphasis">name</em> in an expression.
</p><a name="ch23-83-fm2xml" /><blockquote><b>TIP:</b> 
The word <em class="emphasis">variable</em> is a little misleading. Once
the value of an <tt class="literal">xsl:variable</tt> is set, it cannot be
changed. An <tt class="literal">xsl:variable</tt> is more like a named
constant than a traditional variable.
</p>
</blockquote><dl>
<dt><tt class="literal">name</tt>, required</dt>
<dd>
The variable's name.</p>
</dd>


<dt><tt class="literal">select</tt>, optional</dt>
<dd>
An XPath expression that sets the value of the variable. If
<tt class="literal">xsl:variable</tt> has a <tt class="literal">select</tt>
attribute, then it must be an empty element.
</p>
</dd>

</dl>
<h4 class="refsect1">Contents</h4>


<p>A template that is instantiated to produce the
variable's value as a result-tree fragment. If an
<tt class="literal">xsl:variable</tt> is not an empty element, it must not
have a <tt class="literal">select</tt> attribute. If
<tt class="literal">xsl:variable</tt> is empty and does not have a
<tt class="literal">select</tt> attribute, then its value is the empty
string.
</p>

</div>

<a name="ch23-85-fm2xml" /><a name="IXT-23-240650" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:when</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240650" />&lt;xsl:when
  test = "<em class="replaceable"><tt>boolean-expression</tt></em>"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:when&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:when</tt> element only appears as a child of an
<tt class="literal">xsl:choose</tt> element.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">test</tt>, required</dt>
<dd>
An XPath expression that evaluates to either true or false. The
<tt class="literal">xsl:when</tt> contents are inserted into the result
tree if and only if this is the first <tt class="literal">xsl:when</tt>
element in the <tt class="literal">xsl:choose</tt> element whose
<tt class="literal">test</tt> attribute evaluates to true.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>The template to be instantiated and inserted into the result tree if
the <tt class="literal">test</tt> attribute is true.
</p>

</div>

<a name="ch23-88-fm2xml" /><a name="IXT-23-240651" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xsl:with-param</b></font></td><td align="right"><i>
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
<a name="IXT-23-240651" />&lt;xsl:with-param
  name   = "<tt><em class="replaceable"><tt>QualifiedName</tt></em></tt>"
  select = "<tt><em class="replaceable"><tt>expression</tt></em></tt>"&gt;
  &lt;! --  template  -- &gt;
&lt;/xsl:with-param&gt;
</pre></td><td align="right" /></tr></table>The <tt class="literal">xsl:with-param</tt> element passes a named
parameter to a template that expects it. This can either be a child
of <tt class="literal">xsl:apply-templates</tt> or
<tt class="literal">xsl:call-template</tt>. An
<tt class="literal">xsl:template</tt> element receives the parameter via an
<tt class="literal">xsl:param</tt> element with the same name. If a
template expects to receive a particular parameter and
doesn't get it, then it can take the default from
the <tt class="literal">xsl:param</tt> element instead.
</p>
<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt>, required</dt>
<dd>
The name of the parameter.</p>
</dd>


<dt><tt class="literal">select</tt>, optional</dt>
<dd>
An XPath expression evaluated to form the value of the parameter. If
<tt class="literal">xsl:with-param</tt> has a <tt class="literal">select</tt>
attribute, then it must be an empty element. If
<tt class="literal">xsl:with-param</tt> does not have a
<tt class="literal">select</tt> attribute, then the value is taken from the
element's contents.
</p>
</dd>

</dl>


<h4 class="refsect1">Contents</h4>


<p>A template that is instantiated and passed as the
parameter's value. If
<tt class="literal">xsl:with-param</tt> is not an empty element, it must
not have a <tt class="literal">select</tt> attribute. If
<tt class="literal">xsl:with-param</tt> is empty and does not have a
<tt class="literal">select</tt> attribute, then its value is the empty
string.
</p>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch23_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch23_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">23. XSLT Reference</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">23.3. XSLT Functions</td></tr></table></div>
<hr width="684" align="left" />

<img src="../gifs/navbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
</map>

</body></html>