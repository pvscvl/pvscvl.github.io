<html><head><title>DOM Level 2 Modules (Java &amp; XML, 2nd Edition)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Brett McLaughlin" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="059600197L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Java &amp; XML, 2nd Edition" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Java and XML, 2nd Edition" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch06_02.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"></td><td align="right" valign="top" width="228"><a href="ch06_04.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>



<h2 class="sect1">6.3. DOM Level 2 Modules</h2>

<p><a name="INDEX-563" />Now that you've seen what the
DOM and the Level 2 core offering provide, I will talk about some
additions to DOM Level 2. These are the various modules that add
functionality to the core. They are useful from time to time, in
certain DOM applications.
</p>

<p>First, though, you must have a <a name="INDEX-564" /> <a name="INDEX-565" />DOM Level 2
<a name="INDEX-566" />parser available. If you are using a
parser that you have purchased or downloaded on your own, this is
pretty easy. For example, you can go to the Apache XML web site at
<a href="../../../../../../xml.apache.org/">http://xml.apache.org</a>, download
the latest version of Xerces, and you've got DOM Level 2.
However, if you're using a parser bundled with another
technology, things can get a little trickier. <a name="INDEX-567" />For
example, if you've got Jakarta's Tomcat servlet engine,
you will find <em class="emphasis">xml.jar</em> and
<em class="emphasis">parser.jar</em> in the <em class="emphasis">lib/</em> directory and in the Tomcat classpath.
This isn't so good, as these are DOM Level 1 implementations
and won't support many of the features I talk about in this
section; in that case, download a DOM Level 2 parser manually and
ensure that it is loaded <em class="emphasis">before</em> any DOM Level 1
parsers.
</p>
<blockquote><b>WARNING:</b> 

Beware of the newer versions of Tomcat. They do something ostensibly handy: load all <em class="emphasis">jar</em> files in the <em class="emphasis">lib/</em> directory at startup. Unfortunately, because this is done alphabetically, putting <em class="emphasis">xerces.jar</em> in the <em class="emphasis">lib/</em> directory means that <em class="emphasis">parser.jar</em>, a DOM Level 1 parser, will still be loaded first and you won't get DOM Level 2 support. A common trick to solve this problem is to rename the files: parser.jar becomes z_parser.jar, and xml.jar becomes z_xml.jar. This causes them to be loaded after Xerces, and then you will get DOM Level 2 support. This is the problem I mentioned earlier in the servlet example.
</p>
</blockquote>
<p>Once you've got a capable parser, you're ready to go.
Before diving into the new modules, though, I want to show you a
high-level overview of what these modules are all about.
</p>

<a name="javaxml2-CHP-6-SECT-3.1" /><div class="sect2">
<h3 class="sect2">6.3.1. Branching Out</h3>

<p>When the <a name="INDEX-568" />DOM Level 1 specification came out, it was a
single specification. It was defined basically as you read in <a href="ch05_01.htm">Chapter 5, "DOM"</a>, with a few minor exceptions. However, when
activity began on DOM Level 2, a whole slew of specifications
resulted, each called a module. If you take a look at the complete
set of DOM Level 2 specifications, you'll see six different
modules listed. Seems like a lot, doesn't it? I'm not
going to cover all of these modules; you'd be reading about DOM
for the next four or five chapters. However, I will give you the
rundown on the purpose of each module, summarized in <a href="ch06_03.htm">Table 6-1</a>. I've included the module's
specification, name, and purpose, which you'll need to use
shortly.
</p>

<a name="javaxml2-CHP-6-TABLE-1" /><h4 class="objtitle">Table 6-1. DOM specifications and purpose </h4><table border="1">




<tr>
<th>
<p>Specification</p>
</th>
<th>
<p>Module name</p>
</th>
<th>
<p>Summary of purpose</p>
</th>
</tr>


<tr>
<td>
<p>DOM Level 2 Core</p>
</td>
<td>
<p>XML</p>
</td>
<td>
<p>Extends the DOM Level 1 specification; deals with basic DOM
structures like Element, Attr, Document, etc.
</p>
</td>
</tr>
<tr>
<td>
<p>DOM Level 2 Views</p>
</td>
<td>
<p>Views</p>
</td>
<td>
<p>Provides a model for scripts to dynamically update a DOM structure.</p>
</td>
</tr>
<tr>
<td>
<p>DOM Level 2 Events</p>
</td>
<td>
<p>Events</p>
</td>
<td>
<p>Defines an event model for programs and scripts to use in working
with DOM.
</p>
</td>
</tr>
<tr>
<td>
<p>DOM Level 2 Style</p>
</td>
<td>
<p>CSS</p>
</td>
<td>
<p>Provides a model for CSS (Cascading Style Sheets) based on the DOM
Core and DOM Views specifications.
</p>
</td>
</tr>
<tr>
<td>
<p>DOM Level 2 Traversal and Range</p>
</td>
<td>
<p>Traversal/Range</p>
</td>
<td>
<p>Defines extensions to the DOM for traversing a document and
identifying the range of content within that document.
</p>
</td>
</tr>
<tr>
<td>
<p>DOM Level 2 HTML</p>
</td>
<td>
<p>HTML</p>
</td>
<td>
<p>Extends the DOM to provide interfaces for dealing with HTML
structures in a DOM format.
</p>
</td>
</tr>

</table><p>

<p>If views, events, CSS, HTML, and traversal were all in a single
specification, nothing would ever get done at the W3C! To facilitate
all of this moving along, and yet not hamstringing the DOM in the
process, the different concepts were broken up into separate
specifications.
</p>

<p>Once you figure out which specifications to use, you're almost
ready to roll. A DOM Level 2 parser is not required to support each
of these specifications; as a result, you need to verify that the
features you want to use are present in your <a name="INDEX-569" />XML parser. Happily, this is fairly
simple to accomplish. Remember the hasFeature( ) method I showed you
on the DOMImplementation class? Well, if you supply it a module name
and version, it will let you know if the module and feature requested
are supported. <a href="ch06_03.htm">Example 6-4</a> is a small program that
queries an XML parser's support for the DOM modules listed in
<a href="ch06_03.htm">Table 6-1</a>. You will need to change the name of
your vendor's DOMImplementation implementation class, but other
than that adjustment, it should work for any parser.
</p>

<a name="javaxml2-CHP-6-EX-4" /><div class="example">
<h4 class="objtitle">Example 6-4. Checking features on a DOM implementation </h4>
<blockquote><pre class="code">package javaxml2;

import org.w3c.dom.DOMImplementation;

public class DOMModuleChecker {

    /** Vendor DOMImplementation impl class */
    private String vendorImplementationClass =
        "org.apache.xerces.dom.DOMImplementationImpl";
        
    /** Modules to check */
    private String[] moduleNames =
        {"XML", "Views", "Events", "CSS", "Traversal", "Range", "HTML"};

    public DOMModuleChecker( ) {
    }

    public DOMModuleChecker(String vendorImplementationClass) {
        this.vendorImplementationClass = vendorImplementationClass;
    }
    
    public void check( ) throws Exception {
        DOMImplementation impl = 
            (DOMImplementation)Class.forName(vendorImplementationClass)
                                    .newInstance( );
        for (int i=0; i&lt;moduleNames.length; i++) {
            if (impl.hasFeature(moduleNames[i], "2.0")) {
                System.out.println("Support for " + moduleNames[i] +
                    " is included in this DOM implementation.");
            } else {
                System.out.println("Support for " + moduleNames[i] +
                    " is not included in this DOM implementation.");                
            }            
        }        
    }    

    public static void main(String[] args) {
        if ((args.length != 0) &amp;&amp; (args.length != 1)) {
            System.out.println("Usage: java javaxml2.DOMModuleChecker " +
                "[DOMImplementation impl class to query]");
            System.exit(-1);
        }
        
        try {
            DOMModuleChecker checker = null;
            if (args.length == 1) {
                checker = new DOMModuleChecker(args[1]);
            } else {
                checker = new DOMModuleChecker( );
            }
            checker.check( );
        } catch (Exception e) {
            e.printStackTrace( );
        }               
    }    
}</pre></blockquote>
</div>

<p>Running this program with <em class="emphasis">xerces.jar</em> in my classpath, I got the
following output:
</p>

<blockquote><pre class="code">C:\javaxml2\build&gt;java javaxml2.DOMModuleChecker
Support for XML is included in this DOM implementation.
Support for Views is not included in this DOM implementation.
Support for Events is included in this DOM implementation.
Support for CSS is not included in this DOM implementation.
Support for Traversal is included in this DOM implementation.
Support for Range is not included in this DOM implementation.
Support for HTML is not included in this DOM implementation.</pre></blockquote>

<p>By specifying the <tt class="literal">DOMImplementation</tt> implementation
class for your vendor, you can check the supported modules in your
own DOM parser. In the next few subsections, I will address a few of
the modules that I've found useful, and that you will want to
know about as well.
</p>

</div>
<a name="javaxml2-CHP-6-SECT-3.2" /><div class="sect2">
<h3 class="sect2">6.3.2. Traversal</h3>

<p><a name="INDEX-570" />
<a name="INDEX-571" />First up on the list is the DOM Level 2
Traversal module. This is intended to provide
<a name="INDEX-572" />tree-walking
capability, but also to allow you to refine the nature of that
behavior. In the earlier section on DOM mutation, I mentioned that
most of your DOM code will know something about the structure of a
DOM tree being worked with; this allows for quick traversal and
modification of both structure and content. However, for those times
when you do not know the structure of the document, the traversal
module comes into play.
</p>

<p>Consider the auction site again, and the items input by the user.
Most critical are the item name and the description. Since most
popular auction sites provide some sort of search, you would want to
provide the same in this fictional example. Just searching item
titles isn't going to cut it in the real world; instead, a set
of key words should be extracted from the item descriptions. I say
key words because you don't want a search on "adirondack
top" (which to a guitar lover obviously applies to the wood on
the top of a guitar) to return toys ("top") from a
particular mountain range ("Adirondack"). The best way to
do this in the format discussed so far is to extract words that are
formatted in a certain way. So the words in the description that are
bolded, or in italics, are perfect candidates. Of course, you could
grab all the nontextual child elements of the
<tt class="literal">description</tt> element. However, you'd have to
weed through links (the <tt class="literal">a</tt> element), image
references (<tt class="literal">img</tt>), and so forth. What you really
want is to specify a custom traversal. Good news; you're in the
right place.
</p>

<p>The whole of the traversal module is contained within the
<tt class="literal">org.w3c.dom.traversal</tt>
<a name="INDEX-573" />package.
Just as everything within core DOM begins with a
<tt class="literal">Document</tt> interface, everything in DOM Traversal
begins with the
<tt class="literal">org.w3c.dom.traversal.DocumentTraversal</tt> interface.
This interface provides two methods:
</p>

<blockquote><pre class="code">NodeIterator createNodeIterator(Node root, int whatToShow, NodeFilter filter,
                                boolean expandEntityReferences);
TreeWalker createTreeWalker(Node root, int whatToShow, NodeFilter filter,
                            boolean expandEntityReferences);</pre></blockquote>

<p>Most DOM implementations that support traversal choose to have their
<tt class="literal">org.w3c.dom.Document</tt> implementation class
implement the <tt class="literal">DocumentTraversal</tt> interface as well;
this is how it works in Xerces. In a nutshell, using a
<tt class="literal">NodeIterator</tt> provides a list view of the elements
it iterates over; the closest analogy is a standard Java
<tt class="literal">List</tt> (in the <tt class="literal">java.util</tt>
package). <tt class="literal">TreeWalker</tt> provides a tree view, which
you may be more used to in working with XML by now.
</p>

<a name="javaxml2-CHP-6-SECT-3.2.1" /><div class="sect3">
<h3 class="sect3">6.3.2.1. NodeIterator</h3>

<p><a name="INDEX-574" />
<a name="INDEX-575" />I
want to get past all the conceptualization and into the code sample I
referred to earlier. I want access to all content within the
description of an item from the auction site that is within a
specific set of formatting tags. To do this, I first need access to
the DOM tree itself. Since this doesn't fit into the servlet
approach (you probably wouldn't have a servlet building the
search phrases, you'd have some standalone class), I need a new
class, <tt class="literal">ItemSearcher</tt> (<a href="ch06_03.htm">Example 6-5</a>). This class takes any number of item files to
search through as arguments.<a name="INDEX-576" />
<a name="INDEX-577" />
</p>

<a name="javaxml2-CHP-6-EX-5" /><div class="example">
<h4 class="objtitle">Example 6-5. The ItemSearcher class </h4>
<blockquote><pre class="code">package javaxml2;

import java.io.File;

// DOM imports
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.DocumentTraversal;
import org.w3c.dom.traversal.NodeFilter;
import org.w3c.dom.traversal.NodeIterator;

// Vendor parser
import org.apache.xerces.parsers.DOMParser;

public class ItemSearcher {

    private String docNS = "http://www.oreilly.com/javaxml2";

    public void search(String filename) throws Exception {
        // Parse into a DOM tree
        File file = new File(filename);
        DOMParser parser = new DOMParser( );
        parser.parse(file.toURL().toString( ));
        Document doc = parser.getDocument( );

        // Get node to start iterating with
        Element root = doc.getDocumentElement( );
        NodeList descriptionElements = 
            root.getElementsByTagNameNS(docNS, "description");
        Element description = (Element)descriptionElements.item(0);

        // Get a NodeIterator
        NodeIterator i = ((DocumentTraversal)doc)
            .createNodeIterator(description, NodeFilter.SHOW_ALL, null, true);

        Node n;
        while ((n = i.nextNode( )) != null) {
            if (n.getNodeType( ) == Node.ELEMENT_NODE) {
                System.out.println("Encountered Element: '" + 
                    n.getNodeName( ) + "'");
            } else if (n.getNodeType( ) == Node.TEXT_NODE) {
                System.out.println("Encountered Text: '" + 
                    n.getNodeValue( ) + "'");
            }
        }
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("No item files to search through specified.");
            return;
        }

        try {
            ItemSearcher searcher = new ItemSearcher( );
            for (int i=0; i&lt;args.length; i++) {
                System.out.println("Processing file: " + args[i]);
                searcher.search(args[i]);
            }
        } catch (Exception e) {
            e.printStackTrace( );
        }
    }
}</pre></blockquote>
</div>

<p>As you can see, I've created a <tt class="literal">NodeIterator</tt>,
and supplied it the <tt class="literal">description</tt> element to start
with for iteration. The constant value passed as the filter instructs
the iterator to show all nodes. You could just as easily provide
values like <tt class="literal">Node.SHOW_ELEMENT</tt> and
<tt class="literal">Node.SHOW_TEXT</tt>, which would show only elements or
textual nodes, respectively. I haven't yet provided a
<tt class="literal">NodeFilter</tt> implementation (I'll get to that
next), and I allowed for entity reference expansion. What is nice
about all this is that the iterator, once created, doesn't have
just the child nodes of <tt class="literal">description</tt>. Instead, it
actually has <em class="emphasis">all</em> nodes under
<tt class="literal">description</tt>, even when nested multiple levels
deep. This is extremely handy for dealing with unknown XML structure!
</p>

<p>At this point, you still have all the nodes, which is not what you
want. I added some code (the last <tt class="literal">while</tt> loop) to
show you how to print out the element and text node results. You can
run the code as is, but it's not going to help much. Instead,
the code needs to provide a filter, so it only picks up elements with
the formatting desired: the text within an <tt class="literal">i</tt> or
<tt class="literal">b</tt> block. You can provide this customized behavior
by supplying a custom implementation of the
<tt class="literal">NodeFilter</tt><a name="INDEX-578" /> <a name="INDEX-579" />
<a name="INDEX-580" />
interface, which defines only a single method:
</p>

<blockquote><pre class="code">public short acceptNode(Node n);</pre></blockquote>

<p>This method should return <tt class="literal">NodeFilter.FILTER_SKIP</tt>,
<tt class="literal">NodeFilter.FILTER_REJECT</tt>, or
<tt class="literal">NodeFilter.FILTER_ACCEPT</tt>. The first skips the
examined node, but continues to iterate over its children; the second
rejects the examined node and its children (only applicable in
<tt class="literal">TreeWalker</tt>); and the third accepts and passes on
the examined node. It behaves a lot like SAX, in that you can
intercept nodes as they are being iterated and decide if they should
be passed on to the calling method. Add the following nonpublic class
to the <em class="filename">ItemSearcher.java</em> source
file:<a name="INDEX-581" />
<a name="INDEX-582" />
</p>

<blockquote><pre class="code">class FormattingNodeFilter implements NodeFilter {

    public short acceptNode(Node n) {
        if (n.getNodeType( ) == Node.TEXT_NODE) {
            Node parent = n.getParentNode( );
            if ((parent.getNodeName( ).equalsIgnoreCase("b")) ||
                (parent.getNodeName( ).equalsIgnoreCase("i"))) {
                return FILTER_ACCEPT;
            }
        }
        // If we got here, not interested
        return FILTER_SKIP;
    }
}</pre></blockquote>

<p>This is just plain old DOM code, and shouldn't pose any
difficulty to you. First, the code only wants text nodes; the text of
the formatted elements is desired, not the elements themselves. Next,
the parent is determined, and since it's safe to assume that
<tt class="literal">Text</tt> nodes have <tt class="literal">Element</tt> node
parents, the code immediately invokes <tt class="literal">getNodeName(
)</tt>. If the element name is either "b" or
"i", the code has found search text, and returns
<tt class="literal">FILTER_ACCEPT</tt>. Otherwise,
<tt class="literal">FILTER_SKIP</tt> is returned.
</p>

<p>All that's left now is a change to the iterator creation call
instructing it to use the new filter implementation, and to the
output, both in the existing <tt class="literal">search(
)</tt><a name="INDEX-583" /> method
of the <tt class="literal">ItemSearcher</tt> class:
</p>

<blockquote><pre class="code">// Get a NodeIterator
NodeIterator i = ((DocumentTraversal)doc)
    .createNodeIterator(description, NodeFilter.SHOW_ALL, 
        <tt class="userinput"><b>new FormattingNodeFilter( )</b></tt>, true);

Node n;
while ((n = i.nextNode( )) != null) {
    <tt class="userinput"><b>System.out.println("Search phrase found: '" + n.getNodeValue( ) + "'");</b></tt>
}</pre></blockquote>

<a name="ch06-10-fm2xml" /><blockquote><b>NOTE:</b> 
Some astute readers will wonder what happens when a
<tt class="literal">NodeFilter</tt> implementation conflicts with the
constant supplied to the <tt class="literal">createNodeIterator( )</tt>
method (in this case that constant is
<tt class="literal">NodeFilter.SHOW_ALL</tt>). Actually, the short constant
filter is applied first, and then the resulting list of nodes is
passed to the filter implementation. If I had supplied the constant
<tt class="literal">NodeFilter.SHOW_ELEMENT</tt>, I would not have gotten
any search phrases, because my filter would not have received any
<tt class="literal">Text</tt> nodes to examine; just
<tt class="literal">Element</tt> nodes. Be careful to use the two together
in a way that makes sense. In the example, I could have safely used
<tt class="literal">NodeFilter.SHOW_TEXT</tt> also.
</p>
</blockquote>

<p>Now, the class is useful and ready to run. Executing it on the
<em class="emphasis">bourgOM.xml</em> file I explained in
the first section, I get the following results:
</p>

<blockquote><pre class="code">bmclaugh@GANDALF ~/javaxml2/build
$ java javaxml2.ItemSearcher ../ch06/xml/item-bourgOM.xml
Processing file: ../ch06/xml/item-bourgOM.xml
Search phrase found: 'beautiful'
Search phrase found: 'Sitka-topped'
Search phrase found: 'Indian Rosewood'
Search phrase found: 'huge sound'
Search phrase found: 'great action'
Search phrase found: 'fossilized ivory'
Search phrase found: 'ebony'
Search phrase found: 'great guitar'</pre></blockquote>

<p>This is perfect: all of the bolded and italicized phrases are now
ready to be added to a search facility. (Sorry; you'll have to
write that yourself!)
</p>

</div>

<a name="javaxml2-CHP-6-SECT-3.2.2" /><div class="sect3">
<h3 class="sect3">6.3.2.2. TreeWalker</h3>

<p>The <tt class="literal">TreeWalker</tt><a name="INDEX-584" />
<a name="INDEX-585" />
interface is almost exactly the same as the
<tt class="literal">NodeIterator</tt> interface; the only difference is
that you get a tree view instead of a list view. This is primarily
useful if you want to deal with only a certain type of node within a
tree; for instance, the tree with only elements or without any
comments. By using the constant filter value (such as
<tt class="literal">NodeFilter.SHOW_ELEMENT</tt>) and a filter
implementation (like one that passes on
<tt class="literal">FILTER_SKIP</tt> for all comments), you can essentially
get a view of a DOM tree without extraneous information. The
<tt class="literal">TreeWalker</tt> interface provides all the basic node
operations, such as <tt class="literal">firstChild( )</tt>,
<tt class="literal">parentNode( )</tt>, <tt class="literal">nextSibling( )</tt>,
and of course <tt class="literal">getCurrentNode( )</tt>, which tells you
where you are currently walking.
</p>

<p>I'm not going to give an example here. By now, you should see
that this is identical to dealing with a standard DOM tree, except
that you can filter out unwanted items by using the
<tt class="literal">NodeFilter</tt> constants. This is a great, simple way
to limit your view of XML documents to only information you are
interested in seeing. Use it well; it's a real asset, as is
<tt class="literal">NodeIterator</tt>! <a name="INDEX-586" /> <a name="INDEX-587" /> <a name="INDEX-588" /> <a name="INDEX-589" />You can also check out the complete
specification online at <a href="../../../../../../www.w3.org/TR/DOM-Level-2-Traversal-Range/">http://www.w3.org/TR/DOM-Level-2-Traversal-Range/</a>.<a name="INDEX-590" /> <a name="INDEX-591" />
</p>

</div>
</div>
<a name="javaxml2-CHP-6-SECT-3.3" /><div class="sect2">
<h3 class="sect2">6.3.3. Range</h3>

<p><a name="INDEX-592" /> <a name="INDEX-593" />The DOM Level 2 Range module is one of
the least commonly used modules, probably due to a lack of
understanding of DOM Range rather than any lack of usefulness. This
module provides a way to deal with a set of content within a
document. Once you've defined that range of content, you can
insert into it, copy it, delete parts of it, and manipulate it in
various ways. The most important thing to start with is realizing
that "range" in this sense refers to a number of pieces
of a DOM tree grouped together. It does <em class="emphasis">not</em>
refer to a set of allowed values, where a high and low or start and
end are defined. Therefore, DOM Range has nothing at all to do with
validation of data values. Get that, and you're already ahead
of the pack.
</p>

<p>Like traversal, working with <tt class="literal">Range</tt> involves a new
DOM
<a name="INDEX-594" />package:
<tt class="literal">org.w3c.dom.ranges</tt>. There are actually only two
interfaces and one exception within this class, so it won't
take you long to get your bearings. <a name="INDEX-595" />
<a name="INDEX-596" />First
is the analog to <tt class="literal">Document</tt> (and
<tt class="literal">DocumentTraversal</tt>): that's
<tt class="literal">org.w3c.dom.ranges.DocumentRange</tt>. Like the
<tt class="literal">DocumentTraversal</tt> class, Xerces'
<tt class="literal">Document</tt> implementation class implements
<tt class="literal">Range</tt>. And also like
<tt class="literal">DocumentTraversal</tt>, it has very few interesting
methods; in fact, only one:<a name="INDEX-597" />
</p>

<blockquote><pre class="code">public Range createRange( );</pre></blockquote>

<p>All other range operations operate upon the <tt class="literal">Range</tt>
class (rather, an implementation of the interface; but you get the
idea). Once you've got an instance of the
<tt class="literal">Range</tt> interface, you can set the starting and
ending points, and edit away. As an example, let's go back to
the
<tt class="literal">UpdateItemServlet</tt><a name="INDEX-598" />
<a name="INDEX-599" />.
I mentioned that it's a bit of a hassle to try and remove all
the children of the <tt class="literal">description</tt> element and then
set the new description text; that's because there is no way to
tell if a single <tt class="literal">Text</tt> node is within the
description, or if many elements and text nodes, as well as nested
nodes, exist within a description that is primarily HTML. I showed
you how to simply remove the old <tt class="literal">description</tt>
element and create a new one. However, DOM Range makes this
unnecessary. Take a look at this modification to the <tt class="literal">doPost(
)</tt><a name="INDEX-600" /> method
of that servlet:
</p>

<blockquote><pre class="code">            // Load document
            try {
                DOMParser parser = new DOMParser( );
                parser.parse(xmlFile.toURL().toString( ));
                doc = parser.getDocument( );

                Element root = doc.getDocumentElement( );
   
                // Name of item
                NodeList nameElements = 
                    root.getElementsByTagNameNS(docNS, "name");
                Element nameElement = (Element)nameElements.item(0);
                Text nameText = (Text)nameElement.getFirstChild( );
                nameText.setData(name);
            
                // Description of item
                NodeList descriptionElements = 
                    root.getElementsByTagNameNS(docNS, "description");
                Element descriptionElement = (Element)descriptionElements.item(0);

                // Remove and recreate description<tt class="userinput"><b>
                Range range = ((DocumentRange)doc).createRange( );
                range.setStartBefore(descriptionElement.getFirstChild( ));
                range.setEndAfter(descriptionElement.getLastChild( ));
                range.deleteContents( );
                Text descriptionText = doc.createTextNode(description);
                descriptionElement.appendChild(descriptionText);

                range.detach( );</b></tt>
            } catch (SAXException e) {
                // Print error
                PrintWriter out = res.getWriter( );
                res.setContentType("text/html");
                out.println("&lt;HTML&gt;&lt;BODY&gt;Error in reading XML: " +
                    e.getMessage( ) + ".&lt;/BODY&gt;&lt;/HTML&gt;");
                out.close( ); 
                return;
            }</pre></blockquote>

<p>To remove all the content, I first create a new
<tt class="literal">Range</tt>, using the <tt class="literal">DocumentRange</tt>
cast. You'll need to add import statements for the
<tt class="literal">DocumentRange</tt> and <tt class="literal">Range</tt> classes
to your servlet, too (they are both in the
<tt class="literal">org.w3c.dom.ranges</tt> package).
</p>

<a name="ch06-13-fm2xml" /><blockquote><b>NOTE:</b> 

In the first part of the DOM Level 2 Modules section, I showed you how to check which modules a parser implementation supports. I realize that Xerces reported that it did not support Range. However, running this code with Xerces 1.3.0, 1.3.1, and 1.4 all worked without a hitch. Strange, isn't it?
</p>
</blockquote>
<p>Once the range is ready, set the starting and ending points. Since I
want all content within the <tt class="literal">description</tt> element, I
start before the first child of that <tt class="literal">Element</tt> node
(using <tt class="literal">setStartBefore(
)</tt><a name="INDEX-601" />), and end after its last child (using
<tt class="literal">setEndAfter( )</tt><a name="INDEX-602" />). There are other, similar methods for this
task, <tt class="literal">setStartAfter( )</tt> and <tt class="literal">setEndBefore(
)</tt>. Once that's done, it's simple to call
<tt class="literal">deleteContents(
)</tt><a name="INDEX-603" />. Just like that, not a bit of content is
left. Then the servlet creates the new textual description and
appends it. Finally, I let the JVM know that it can release any
resources associated with the <tt class="literal">Range</tt> by calling
<tt class="literal">detach( )</tt>. While this step is commonly overlooked,
it can really help with lengthy bits of code that use the extra
resources.
</p>

<p>Another option is to use <tt class="literal">extractContents(
)</tt><a name="INDEX-604" /> instead of <tt class="literal">deleteContents(
)</tt>. This method removes the content, then returns the
content that has been removed. You could insert this as an archived
element, for example:
</p>

<blockquote><pre class="code">// Remove and recreate description
Range range = ((DocumentRange)doc).createRange( );
range.setStartBefore(descriptionElement.getFirstChild( ));
range.setEndAfter(descriptionElement.getLastChild( ));<tt class="userinput"><b>
Node oldContents = range.extractContents( );</b></tt>
Text descriptionText = doc.createTextNode(description);
descriptionElement.appendChild(descriptionText);

<tt class="userinput"><b>// Set this as content to some other, archival, element
archivalElement.appendChild(oldContents);</b></tt></pre></blockquote>
<p>Don't try this in your servlet; there is no archivalElement in
this code, and it is just for demonstration purposes. However, it
should be starting to sink in that the DOM Level 2 Range module can
really help you in editing documents' contents. It also
provides yet another way to get a handle on content when you
aren't sure of the structure of that content ahead of time.
</p>

<p>There's a lot more to ranges in DOM; check this out on your
own, along with all of the DOM modules covered in this chapter.
However, you should now have enough of an understanding of the basics
to get you going. Most importantly, realize that at any point in an
active Range instance, you can simply invoke range.insertNode(Node
newNode) and add new content, wherever you are in a document! It is
this robust editing quality of ranges that make them so attractive.
The next time you need to delete, copy, extract, or add content to a
structure that you know little about, think about using ranges. The
specification gives you information on all this and more, and is
located online at <a name="INDEX-605" />
<a name="INDEX-606" /><a href="../../../../../../www.w3.org/TR/DOM-Level-2-Traversal-Range/">http://www.w3.org/TR/DOM-Level-2-Traversal-Range/</a>.<a name="INDEX-607" /> <a name="INDEX-608" />
</p>

</div>
<a name="javaxml2-CHP-6-SECT-3.4" /><div class="sect2">
<h3 class="sect2">6.3.4. Events, Views, and Style</h3>

<p>Aside from the HTML module, which I'll talk about next, there
are three other DOM Level 2 modules: Events, Views, and Style.
I'm not going to cover these three in depth in this book,
largely because I believe that they are more useful for client
programming. So far, I've focused on server-side programming,
and I'm going to keep in that vein throughout the rest of the
book. These three modules are most often used on client software such
as IDEs, web pages, and the like. Still, I want to briefly touch on
each so you'll still be on top of the DOM heap at the next
alpha-geek soir&eacute;e.
</p>

<a name="javaxml2-CHP-6-SECT-3.4.1" /><div class="sect3">
<h3 class="sect3">6.3.4.1. Events</h3>

<p><a name="INDEX-609" />
<a name="INDEX-610" />The Events
module provides just what you are probably expecting: a means of
"listening" to a DOM document. The relevant classes are
in the org.w3c.dom.events
<a name="INDEX-611" />package,
and the class that gets things going is DocumentEvent. No surprise
here; compliant parsers (like Xerces) implement this interface in the
same class that implements org.w3c.dom.Document. The interface
defines only one method:
</p>
<blockquote><pre class="code">
public Event createEvent(String eventType);</pre></blockquote>

<p>The string passed in is the type of event; valid values in DOM Level
2 are "UIEvent", "MutationEvent", and
"MouseEvent". Each of these has a corresponding class:
<tt class="literal">UIEvent</tt>, <tt class="literal">MutationEvent</tt>, and
<tt class="literal">MouseEvent</tt>. You'll note, in looking at the
Xerces Javadoc, that they provide only the
<tt class="literal">MutationEvent</tt> interface, which is the only event
type Xerces supports. When an event is "fired" off, it
can be handled (or "caught") by an
<tt class="literal">EventListener</tt>.
</p>

<p>This is where the DOM core support comes in; a parser supporting DOM
events should have the <tt class="literal">org.w3c.dom.Node</tt> interface
implementing the <tt class="literal">org.w3c.dom.events.EventTarget</tt>
interface. So every node can be the target of an event. This means
that you have the following method available on those nodes:
</p>

<blockquote><pre class="code">public void addEventListener(String type, EventListener listener, 
                             boolean capture);</pre></blockquote>

<p>Here's the process. You create a new
<tt class="literal">EventListener</tt> (which is a custom class you would
write) implementation. You need to implement only a single method:
</p>

<blockquote><pre class="code">public void handleEvent(Event event);</pre></blockquote>

<p>Register that listener on any and all nodes you want to work with.
Code in here typically does some useful task, like emailing users
that their information has been changed (in some XML file),
revalidating the XML (think XML editors), or asking users if they are
sure they want to perform the action.
</p>

<p>At the same time, you'll want your code to trigger a new
<tt class="literal">Event</tt> on certain actions, like the user clicking
on a node in an IDE and entering new text, or deleting a selected
element. When the <tt class="literal">Event</tt> is triggered, it is passed
to the available <tt class="literal">EventListener</tt> instances, starting
with the active node and moving up. This is where your
listener's code executes, <em class="emphasis">if the event types are the
same</em>. Additionally, you can have the event stop
propagating at that point (once you've handled it), or bubble
up the event chain and possibly be handled by other registered
listeners.
</p>

<p>So there you have it; events in only a page! And you thought
specifications were hard to read. Seriously, this is some useful
stuff, and if you are working with client-side code, or software that
will be deployed standalone on user's desktops (like that XML
editor I keep talking about), this should be a part of your DOM
toolkit. Check out the full specification online at <a href="../../../../../../www.w3.org/TR/DOM-Level-2-Events/">http://www.w3.org/TR/DOM-Level-2-Events/</a>.
</p>

</div>

<a name="javaxml2-CHP-6-SECT-3.4.2" /><div class="sect3">
<h3 class="sect3">6.3.4.2. Views</h3>

<p><a name="INDEX-612" />
<a name="INDEX-613" />Next on the
list is DOM Level 2 Views. The reason I don't cover views in
much detail is that, really, there is very little to be said. From
every reading I can make of the (one-page!) specification, it's
simply a basis for future work, perhaps in vertical markets. The
specification defines only two interfaces, both in the
<tt class="literal">org.w3c.dom.views</tt>
<a name="INDEX-614" />package.
Here's the first:
</p>

<blockquote><pre class="code">package org.w3c.dom.views;

public interface AbstractView {
    public DocumentView getDocument( );

}</pre></blockquote>

<p>And here's the second:</p>

<blockquote><pre class="code">package org.w3c.dom.views;

public interface DocumentView {
    public AbstractView getDefaultView( );

}</pre></blockquote>

<p>Seems a bit cyclical, doesn't it? A single <em class="filename">source
document</em> (a DOM tree) can have multiple
<em class="filename">views</em> associated with it. In this case, view
refers to a presentation, like a styled document (after XSL or CSS
has been applied), or perhaps a version with Shockwave and one
without. By implementing the <tt class="literal">AbstractView</tt>
interface, you can define your own customized versions of displaying
a DOM tree. For example, consider this example subinterface:
</p>

<blockquote><pre class="code">package javaxml2;

import org.w3c.dom.views.AbstractView;

public interface StyledView implements AbstractView {

    public void setStylesheet(String stylesheetURI);

    public String getStylesheetURI( );    
}</pre></blockquote>

<p>I've left out the method implementations, but you can see how
this could be used to provide stylized views of a DOM tree.
Additionally, a compliant parser implementation would have the
<tt class="literal">org.w3c.dom.Document</tt> implementation implement
<tt class="literal">DocumentView</tt>, which allows you to query a document
for its default view. It's expected that in a later version of
the specification you will be able to register multiple views for a
document, and more closely tie a view or views to a document.
</p>

<p>Look for this to be fleshed out more as browsers like Netscape,
Mozilla, and Internet Explorer provide these sorts of views of XML.
Additionally, you can read the short specification and know as much
as I do by checking it out online at <a href="../../../../../../www.w3.org/TR/DOM-Level-2-Views/">http://www.w3.org/TR/DOM-Level-2-Views/</a>.
</p>

</div>

<a name="javaxml2-CHP-6-SECT-3.4.3" /><div class="sect3">
<h3 class="sect3">6.3.4.3. Style</h3>

<p><a name="INDEX-615" />
<a name="INDEX-616" />Finally, there
is the Style module, also referred to as simply CSS (Cascading Style
Sheets). You can check this specification out at <a href="../../../../../../www.w3.org/TR/DOM-Level-2-Style/">http://www.w3.org/TR/DOM-Level-2-Style/</a>. This
provides a binding for CSS stylesheets to be represented by DOM
constructs. Everything of interest is in the
<tt class="literal">org.w3c.dom.stylesheets</tt> and
<tt class="literal">org.w3c.dom.css</tt>
<a name="INDEX-617" />
<a name="INDEX-618" />packages.
The former contains generic base classes, and the latter provides
specific applications to Cascading Style Sheets. Both are primarily
used for showing a client a styled document.
</p>

<p>You use this module exactly like you use the core DOM interfaces: you
get a Style-compliant parser, parse a stylesheet, and use the CSS
language bindings. This is particularly handy when you want to parse
a CSS stylesheet and apply it to a DOM document. You're working
from the same basic set of concepts, if that makes sense to you (and
it should; when you can do two things with an API instead of one,
that's generally good!). Again, I only briefly touch on the
Style module, because it's accessible with the Javadoc in its
entirety. The classes are aptly named
(<tt class="literal">CSSValueList</tt>, <tt class="literal">Rect</tt>,
<tt class="literal">CSSDOMImplementation</tt>), and are close enough to
their XML DOM counterparts that I'm confident you'll have
no problem using them if you need to.<a name="INDEX-619" /> 
</p>

</div>
</div>
<a name="javaxml2-CHP-6-SECT-3.5" /><div class="sect2">
<h3 class="sect2">6.3.5. HTML</h3>

<p><a name="INDEX-620" />
<a name="INDEX-621" />For HTML, DOM provides a set of interfaces
that model the various HTML elements. For example, you can use the
<tt class="literal">HTMLDocument</tt> class, the
<tt class="literal">HTMLAnchorElement</tt>, and the
<tt class="literal">HTMLSelectElement</tt> (all in the
<tt class="literal">org.w3c.dom.html</tt>
<a name="INDEX-622" />package)
to represent their analogs in HTML (<tt class="literal">&lt;HTML&gt;</tt>,
<tt class="literal">&lt;A&gt;</tt>, and <tt class="literal">&lt;SELECT&gt;</tt>
in this case). All of these provide convenience methods like
<tt class="literal">setTitle( )</tt> (on <tt class="literal">HTMLDocument</tt>),
<tt class="literal">setHref( )</tt> (on
<tt class="literal">HTMLAnchorElement</tt>), and <tt class="literal">getOptions(
)</tt> (on <tt class="literal">HTMLSelectElement</tt>). All of these
extend core DOM structures like <tt class="literal">Document</tt> and
<tt class="literal">Element</tt>, and so can be used as any other DOM
<tt class="literal">Node</tt> could.
</p>

<p>However, it turns out that the HTML bindings are rarely used (at
least directly). It's not because they aren't useful;
instead, many tools have already been written to provide this sort of
access through even more user-friendly tools. XMLC, a project within
the Enhydra application server framework, is one such example
(located online at <a href="../../../../../../xmlc.enhydra.org/">http://xmlc.enhydra.org</a>), and
<a name="INDEX-623" />Cocoon, covered in
<a href="ch10_01.htm">Chapter 10, "Web Publishing Frameworks"</a>, is another. These allow developers to
work with HTML and web pages in a way that does not necessarily
require even basic DOM knowledge, making it more accessible to web
designers and newer Java developers. The end result of using these
tools is that the HTML DOM bindings are rarely needed. But if you
know about them, you can use them if you need to. Additionally, you
can use standard DOM functionality on well-formed HTML documents
(XHTML), treating elements as <tt class="literal">Element</tt> nodes and
attributes as <tt class="literal">Attr</tt> nodes. Even without the HTML
bindings, you can use DOM to work with HTML. Piece of cake.
</p>

</div>
<a name="javaxml2-CHP-6-SECT-3.6" /><div class="sect2">
<h3 class="sect2">6.3.6. Odds and Ends</h3>

<p>What's left in DOM Level 2 besides these modules and
namespace-awareness? Very little, and you've probably already
used most of it. The <tt class="literal">createDocument( )</tt> and
<tt class="literal">createDocumentType( )</tt> methods are new to the
<tt class="literal">DOMImplementation</tt> class, and you've used
both of them. Additionally, the <tt class="literal">getSystemId( )</tt> and
<tt class="literal">getPublicId( )</tt> methods used in the
<tt class="literal">DOMSerializer</tt> class on the
<tt class="literal">DocumentType</tt> interface are also DOM Level 2
additions. Other than that, there isn't much; a few new
<tt class="literal">DOMException</tt> error code constants, and
that's about it. You can see the complete list of changes
online at <a name="INDEX-624" />
<a name="INDEX-625" /><a href="../../../../../../www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/changes.html">http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/changes.html</a>.
The rest of the changes are the additional modules, one of which
I'll cover next.
</p>

</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch06_02.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch06_04.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">6.2. Namespaces</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">6.4. DOM Level 3</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
</map>

</body></html>