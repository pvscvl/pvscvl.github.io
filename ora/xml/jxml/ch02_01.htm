<html><head><title>Nuts and Bolts (Java &amp; XML, 2nd Edition)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Brett McLaughlin" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="059600197L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Java &amp; XML, 2nd Edition" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Java and XML, 2nd Edition" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch01_04.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"></td><td align="right" valign="top" width="228"><a href="ch02_02.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>




<h1 class="chapter">Chapter 2. Nuts and Bolts</h1>
<div class="htmltoc"><h4 class="tochead">Contents:</h4>
  <p> <a href="#javaxml2-CHP-2-SECT-1">The Basics</a><br />
<a href="ch02_02.htm">Constraints</a><br />
<a href="ch02_03.htm">Transformations</a><br />
<a href="ch02_04.htm">And More...</a><br />
<a href="ch02_05.htm">What's Next?</a><br /></p></div>

<p><a name="INDEX-65" /></a>With the
introductions behind us, let's get to it. Before heading
straight into Java, though, some basic structures must be laid down.
These address a fundamental understanding of the concepts in XML and
how the extensible markup language works. In other words, you need an
XML primer. If you are already an XML expert, skim through this
chapter to make sure you're comfortable with the topics
addressed. If you're completely new to XML, on the other hand,
this chapter can get you ready for the rest of the book without
hours, days, or weeks of study.
</p>

<a name="javaxml2-CHP-2-SIDEBAR-1" /></a><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">Where Did All the Chapters Go?</h4>
Readers of the first edition of<a name="INDEX-66" /></a> <em class="emphasis">Java
&amp; XML</em> may be a little confused. In that edition, there
were (count 'em!) three full chapters just on XML itself. When
I worked on the first edition over a year ago, I was faced with
writing a book that was part <a name="INDEX-67" /></a>XML, part Java, and couldn't
completely address either. There was no other reliable resource to
direct you to for additional help. Today, books like
<em class="emphasis">Learning XML</em> by Erik Ray (O'Reilly) and
<em class="emphasis"><a href="../xmlnut/index.htm">XML in a Nutshell</a></em> by Elliotte Rusty Harold and
W. Scott Means (O'Reilly) have rectified that problem.
It's now enough to give you a whirlwind tour of XML in this
chapter, and let you refer to one of those excellent books for more
detail on "pure" XML. As a result, I was able to condense
several chapters into this one, paving the way for new chapters on
Java, which I'm sure is what you want! Be prepared for some
radical departures from the first edition; now at least you know why.
<p></p>
</td></tr></table><p></blockquote>

<p>You can use this chapter as a glossary while you read the rest of the
book. I won't spend time in future chapters explaining XML
concepts, in order to deal strictly with Java and get to some more
advanced concepts. So if you hit something that completely befuddles
you, check this chapter for information. And if you are still a
little lost, I highly recommended that this book be read with a copy
of Elliotte Harold and Scott Means' excellent book <em class="emphasis">XML in a Nutshell</em> (O'Reilly) open. That
will give you all the information you need on XML concepts, and then
I can focus on Java ones.
</p>

<p>Finally, I'm big on examples. I'm going to load the rest
of the chapters as full of them as possible. I'd rather give
you too much information than barely engage you. To get started along
those lines, I'll introduce several XML and related documents
in this chapter to illustrate the concepts in this primer. You might
want to take the time to either type these into your editor or
download them from the book's web site (<a href="../../../../../../www.newInstance.com/">http://www.newInstance.com</a>), as they will be
used in this chapter and throughout the rest of the book. It will
save you time later on.
</p>

<div class="sect1"><a name="javaxml2-CHP-2-SECT-1" /></a>
<h2 class="sect1">2.1. The Basics</h2>

<p>It all begins with the <a name="INDEX-68" /></a>XML 1.0 Recommendation, which you
can read in its entirety at <a name="INDEX-69" /></a><a href="../../../../../../www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a>. <a href="ch02_01.htm">Example 2-1</a> shows a simple XML document that conforms to
this specification. It's a portion of the XML table of contents
for this book (I've only included part of it because it's
long!). The complete file is included with the samples for the book,
available online at <a href="../../../../../../www.oreilly.com/catalog/javaxml2">http://www.oreilly.com/catalog/javaxml2</a> and
<a href="../../../../../../www.newInstance.com/">http://www.newInstance.com</a>.
I'll use it to illustrate several important concepts.
</p>

<a name="javaxml2-CHP-2-EX-1" /></a><div class="example">
<h4 class="objtitle">Example 2-1. The contents.xml document </h4>
<blockquote><pre class="code">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE book SYSTEM "DTD/JavaXML.dtd"&gt;

&lt;!-- Java and XML Contents --&gt;
&lt;book xmlns="http://www.oreilly.com/javaxml2"
      xmlns:ora="http://www.oreilly.com"
&gt;
  &lt;title ora:series="Java"&gt;Java and XML&lt;/title&gt;

  &lt;!-- Chapter List --&gt;
  &lt;contents&gt;
    &lt;chapter title="Introduction" number="1"&gt;
      &lt;topic name="XML Matters" /&gt;
      &lt;topic name="What's Important" /&gt;
      &lt;topic name="The Essentials" /&gt;
      &lt;topic name="What&amp;apos;s Next?" /&gt;
    &lt;/chapter&gt;
    &lt;chapter title="Nuts and Bolts" number="2"&gt;
      &lt;topic name="The Basics" /&gt;
      &lt;topic name="Constraints" /&gt;
      &lt;topic name="Transformations" /&gt;
      &lt;topic name="And More..." /&gt;
      &lt;topic name="What&amp;apos;s Next?" /&gt;
    &lt;/chapter&gt;
    &lt;chapter title="SAX" number="3"&gt;
      &lt;topic name="Getting Prepared" /&gt;
      &lt;topic name="SAX Readers" /&gt;
      &lt;topic name="Content Handlers" /&gt;
      &lt;topic name="Gotcha!" /&gt;
      &lt;topic name="What&amp;apos;s Next?" /&gt;
    &lt;/chapter&gt; 
    &lt;chapter title="Advanced SAX" number="4"&gt;
      &lt;topic name="Properties and Features" /&gt;
      &lt;topic name="More Handlers" /&gt;
      &lt;topic name="Filters and Writers" /&gt;
      &lt;topic name="Even More Handlers" /&gt;
      &lt;topic name="Gotcha!" /&gt;
      &lt;topic name="What&amp;apos;s Next?" /&gt;
    &lt;/chapter&gt;
    &lt;chapter title="DOM" number="5"&gt;
      &lt;topic name="The Document Object Model" /&gt;
      &lt;topic name="Serialization" /&gt;
      &lt;topic name="Mutability" /&gt;
      &lt;topic name="Gotcha!" /&gt;
      &lt;topic name="What&amp;apos;s Next?" /&gt;
    &lt;/chapter&gt;           

    &lt;!-- And so on... --&gt;

  &lt;/contents&gt;

  &lt;ora:copyright&gt;&amp;OReillyCopyright;&lt;/ora:copyright&gt;
&lt;/book&gt;</pre></blockquote>
</div>

<a name="javaxml2-CHP-2-SECT-1.1" /></a><div class="sect2">
<h3 class="sect2">2.1.1. XML 1.0</h3>

<p>A lot of this specification describes what is mostly intuitive. If
you've done any HTML authoring, or SGML, you're already
familiar with the concept of elements (such as
<tt class="literal">contents</tt> and <tt class="literal">chapter</tt> in the
example) and attributes (such as <tt class="literal">title</tt> and
<tt class="literal">name</tt>). In XML, there's little more than
definition of how to use these items, and how a document must be
structured. XML spends more time defining tricky issues like
whitespace than introducing any concepts that you're not at
least somewhat familiar with.
</p>

<p>An <a name="INDEX-70" /></a>XML
document can be broken into two basic pieces: the
<a name="INDEX-71" /></a>header, which gives
an XML parser and XML applications information about how to handle
the document; and the content, which is the XML data itself. Although
this is a fairly loose division, it helps us differentiate the
instructions to applications within an XML document from the XML
content itself, and is an important distinction to understand. The
header is simply the XML declaration, in this format:
</p>

<blockquote><pre class="code">&lt;?xml version="1.0"?&gt;</pre></blockquote>

<p>The header can also include an encoding, and whether the document is
a standalone document or requires other documents to be referenced
for a complete understanding of its meaning:
</p>

<blockquote><pre class="code">&lt;?xml version="1.0" encoding="UTF8" standalone="no"?&gt;</pre></blockquote>

<p>The rest of the header is made up of items like the
<tt class="literal">DOCTYPE</tt> declaration:
</p>

<blockquote><pre class="code">&lt;!DOCTYPE Book SYSTEM "DTD/JavaXML.dtd"&gt;</pre></blockquote>

<p>In this case, I've referred to a file on my local system, in
the directory <em class="emphasis">DTD/</em> called
<em class="emphasis">JavaXML.dtd</em>. Any time you use a
relative or absolute file path or a URL, you want to use the
<tt class="literal">SYSTEM</tt><a name="INDEX-72" /></a> keyword. The other option is using the
<tt class="literal">PUBLIC</tt><a name="INDEX-73" /></a> keyword, and following it with a
<a name="INDEX-74" /></a>public
identifier. This means that the W3C or another consortium has defined
a standard DTD that is associated with that public identifier. As an
example, take the DTD statement for XHTML 1.0:
</p>

<blockquote><pre class="code">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</pre></blockquote>

<p>Here, a public identifier is supplied (the funny little string
starting with "-//"), followed by a system identifier
(the URL). If the public identifier cannot be resolved, the system
identifier is used instead.
</p>

<p>You may also see <a name="INDEX-75" /></a>processing instructions at the top
of a file, and they are generally considered part of a
document's header, rather than its content. They look like
this:
</p>

<blockquote><pre class="code">&lt;?xml-stylesheet href="XSL\JavaXML.html.xsl" type="text/xsl"?&gt;
&lt;?xml-stylesheet href="XSL\JavaXML.wml.xsl" type="text/xsl" 
                 media="wap"?&gt;
&lt;?cocoon-process type="xslt"?&gt;</pre></blockquote>

<p>Each is considered to have a
<em class="filename">target</em><a name="INDEX-76" /></a>
(the first word, like <tt class="literal">xml-stylesheet</tt> or
<tt class="literal">cocoon-process</tt>), and
<em class="filename">data</em><a name="INDEX-77" /></a> (the rest). More often
than not, the data is in the form of name-value pairs, which can
really help readability. This is only a good practice, though, and
not required, so don't depend on it.
</p>

<p>Other than that, the bulk of your XML document should be content; in
other words, elements, attributes, and data that you have put into
it.
</p>

<a name="javaxml2-CHP-2-SECT-1.1.1" /></a><div class="sect3">
<h3 class="sect3">2.1.1.1. The root element</h3>

<p>The <a name="INDEX-78" /></a> <a name="INDEX-79" /></a>root element is the highest-level
element in the XML document, and must be the first opening tag and
the last closing tag within the document. It provides a reference
point that enables an XML parser or XML-aware application to
recognize a beginning and end to an XML document. In our example, the
root element is <tt class="literal">book</tt>:
</p>

<blockquote><pre class="code">&lt;book xmlns="http://www.oreilly.com/javaxml2"
      xmlns:ora="http://www.oreilly.com"
&gt;
    &lt;!-- Document content --&gt;
&lt;/book&gt;</pre></blockquote>

<p>This tag and its matching closing tag surround all other data content
within the XML document. XML specifies that there may be only one
root element in a document. In other words, the root element must
enclose all other elements within the document. Aside from this
requirement, a root element does not differ from any other XML
element. It's important to understand this, because XML
documents can reference and include other XML documents. In these
cases, the root element of the referenced document becomes an
enclosed element in the referring document, and must be handled
normally by an XML parser. Defining root elements as standard XML
elements without special properties or behavior allows document
inclusion to work seamlessly.
</p>

</div>

<a name="javaxml2-CHP-2-SECT-1.1.2" /></a><div class="sect3">
<h3 class="sect3">2.1.1.2. Elements</h3>

<p>So far I have glossed over defining an actual
<a name="INDEX-80" /></a>
<a name="INDEX-81" /></a>element.
Let's take an in-depth look at elements, which are represented
by arbitrary names and must be enclosed in angle brackets. There are
several different variations of elements in the sample document, as
shown here:
</p>

<blockquote><pre class="code"> &lt;!-- Standard element opening tag --&gt;
 &lt;contents&gt;

  &lt;!-- Standard element with attribute --&gt;
  &lt;chapter title="Nuts and Bolts" number="2"&gt;

  &lt;!-- Element with textual data --&gt;
  &lt;title ora:series="Java"&gt;Java and XML&lt;/title&gt;

  &lt;!-- Empty element --&gt;
  &lt;sectionBreak /&gt;

 &lt;!-- Standard element closing tag --&gt;
 &lt;/contents&gt;</pre></blockquote>

<p>The first rule in creating <a name="INDEX-82" /></a>
<a name="INDEX-83" /></a>elements is that their names must
start with a letter or underscore, and then may contain any amount of
letters, numbers, underscores, hyphens, or periods. They may not
contain embedded spaces:
</p>

<blockquote><pre class="code">&lt;!-- Embedded spaces are not allowed --&gt;
&lt;my element name&gt;</pre></blockquote>

<p>XML <a name="INDEX-84" /></a> <a name="INDEX-85" /></a>element names are also
case-sensitive. Generally, using the same rules that govern Java
variable naming will result in sound XML element naming. Using an
element named <tt class="literal">tcbo</tt> to represent
<em class="filename">Telecommunications Business Object</em> is not a good
idea because it is cryptic, while an overly verbose tag name like
<tt class="literal">beginningOfNewChapter</tt> just clutters up a document.
Keep in mind that your XML documents will probably be seen by other
developers and content authors, so clear documentation through good
naming is essential.
</p>

<p>Every opened
<a name="INDEX-86" /></a>element must in turn be closed. There
are no exceptions to this rule as there are in many other markup
languages, like HTML. An ending element tag consists of the
<a name="INDEX-87" /></a>
<a name="INDEX-88" /></a>forward slash and then the element name:
<tt class="literal">&lt;/content&gt;</tt>. Between an
<a name="INDEX-89" /></a>
<a name="INDEX-90" /></a>
<a name="INDEX-91" /></a>opening and closing
tag, there can be any number of additional elements or textual data.
However, you cannot mix the order of <a name="INDEX-92" /></a>nested tags: the first opened element must
always be the last closed element. If any of the rules for XML syntax
are not followed in an <a name="INDEX-93" /></a>
<a name="INDEX-94" /></a>XML document, the document is not
<em class="filename">well-formed</em>. A well-formed document is one in
which all XML syntax rules are followed, and all elements and
attributes are correctly positioned. However, a well-formed document
is not necessarily
<em class="filename">valid</em>,<a name="INDEX-95" /></a><a name="INDEX-96" /></a> which
means that it follows the constraints set upon a document by its DTD
or schema. There is a significant difference between a well-formed
document and a valid one; the rules I discuss in this section ensure
that your document is well-formed, while the rules discussed in the
constraints section allow your document to be valid.
</p>

<p>As an example of a document that is not well-formed, consider this
XML fragment:
</p>

<blockquote><pre class="code">&lt;tag1&gt;
 &lt;tag2&gt;
&lt;/tag1&gt;
 &lt;/tag2&gt;</pre></blockquote>

<p>The order of nesting of tags is incorrect, as the opened
<tt class="literal">&lt;tag2&gt;</tt> is not followed by a closing
<tt class="literal">&lt;/tag2&gt;</tt> within the surrounding
<tt class="literal">tag1</tt> element. However, if these syntax errors are
corrected, there is still no guarantee that the document will be
valid.
</p>

<p>While this example of a document that is not well-formed may seem
trivial, remember that this would be acceptable HTML, and commonly
occurs in large tables within an HTML document. In other words, HTML
and many other markup languages do not require well-formed XML
documents. XML's strict adherence to ordering and nesting rules
allows data to be parsed and handled much more quickly than when
using markup languages without these constraints.
</p>

<p>The last rule I'll look at is the case of
<a name="INDEX-97" /></a>empty
elements. I already said that XML tags must always be paired; an
opening tag and a closing tag constitute a complete XML element.
There are cases where an element is used purely by itself, like a
flag stating a chapter is incomplete, or where an element has
attributes but no textual data, like an image declaration in HTML.
These would have to be represented as:
</p>

<blockquote><pre class="code">&lt;chapterIncomplete&gt;&lt;/chapterIncomplete&gt;
&lt;img src="/images/xml.gif"&gt;&lt;/img&gt;</pre></blockquote>

<p>This is obviously a bit silly, and adds clutter to what can often be
very large XML documents. The XML specification provides a means to
signify both an opening and closing element tag within one element:
</p>

<blockquote><pre class="code">&lt;chapterIncomplete /&gt;
&lt;img src="/images/xml.gif" /&gt;</pre></blockquote>

<a name="javaxml2-CHP-2-SIDEBAR-2" /></a><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">What's with the Space Before Your End-Slash, Brett?</h4>

<p><a name="INDEX-98" /></a>Well,
<a name="INDEX-99" /></a>let me tell you.
I've had the unfortunate pleasure of working with Java and XML
since late 1998, when things were rough, at best. And some web
browsers at that time (and some today, to be honest) would only
accept XHTML (HTML that is well-formed) in very specific formats.
Most notably, tags like <tt class="literal">&lt;br&gt;</tt> that are never
closed in HTML must be closed in XHTML, resulting in
<tt class="literal">&lt;br/&gt;</tt>. Some of these browsers would
completely ignore a tag like this; however, oddly enough, they would
happily process <tt class="literal">&lt;br /&gt;</tt> (note the space
before the end-slash). I got used to making my XML not only
well-formed, but consumable by these browsers. I've never had a
good reason to change these habits, so you get to see them in action
here.
</p>

<p>This nicely solves the problem of unnecessary clutter, and still
follows the rule that every XML element must have a matching end tag;
it simply consolidates both start and end tag into a single tag.
</p>
</td></tr></table><p></blockquote>

</div>

<a name="javaxml2-CHP-2-SECT-1.1.3" /></a><div class="sect3">
<h3 class="sect3">2.1.1.3. Attributes</h3>

<p>In addition to text contained within an element's tags, an
<a name="INDEX-100" /></a>
<a name="INDEX-101" /></a>element can also
have attributes. Attributes are included with their respective values
within the element's opening declaration (which can also be its
closing declaration!). For example, in the <tt class="literal">chapter</tt>
tag, the title of the chapter was part of what was noted in an
attribute:
</p>

<blockquote><pre class="code">&lt;chapter title="Advanced SAX" number="4"&gt;
  &lt;topic name="Properties and Features" /&gt;
  &lt;topic name="More Handlers" /&gt;
  &lt;topic name="Filters and Writers" /&gt;
  &lt;topic name="Even More Handlers" /&gt;
  &lt;topic name="Gotcha!" /&gt;
  &lt;topic name="What&amp;apos;s Next?" /&gt;
&lt;/chapter&gt;</pre></blockquote>

<p>In this example, <tt class="literal">title</tt> is the attribute name; the
value is the title of the chapter, "Advanced SAX."
Attribute names must follow the same rules as XML element names, and
attribute values must be within <a name="INDEX-102" /></a>
<a name="INDEX-103" /></a>quotation marks. Although both single and
double quotes are allowed, double quotes are a widely used standard
and result in XML documents that model Java programming practices.
Additionally, single and double quotation marks may be used in
attribute values; surrounding the value in double quotes allows
single quotes to be used as part of the value, and surrounding the
value in single quotes allows double quotes to be used as part of the
value. This is not good practice, though, as XML parsers and
processors often uniformly convert the quotes around an
attribute's value to all double (or all single) quotes,
possibly introducing unexpected results.
</p>

<p><a name="INDEX-104" /></a>
<a name="INDEX-105" /></a>In addition to learning how to use
attributes, there is an issue of when to use attributes. Because XML
allows such a variety of data formatting, it is rare that an
attribute cannot be represented by an element, or that an element
could not easily be converted to an attribute. Although there's
no specification or widely accepted standard for determining when to
use an attribute and when to use an element, there is a good rule of
thumb: use elements for multiple-valued data and attributes for
single-valued data. If data can have multiple values, or is very
lengthy, the data most likely belongs in an element. It can then be
treated primarily as textual data, and is easily searchable and
usable. Examples are the description of a book's chapters, or
URLs detailing related links from a site. However, if the data is
primarily represented as a single value, it is best represented by an
attribute. A good candidate for an attribute is the section of a
chapter; while the section item itself might be an element and have
its own title, the grouping of chapters within a section could be
easily represented by a <tt class="literal">section</tt> attribute within
the <tt class="literal">chapter</tt> element. This attribute would allow
easy grouping and indexing of chapters, but would never be directly
displayed to the user. Another good example of a piece of data that
could be represented in XML as an attribute is if a particular table
or chair is on layaway. This instruction could let an XML application
used to generate a brochure or flier know not to include items on
layaway in current stock; obviously this is a true or false value,
and has only a singular value at any time. Again, the application
client would never directly see this information, but the data would
be used in processing and handling the XML document. If after all of
this analysis you are still unsure, you can always play it safe and
use an element.
</p>

<p>You may have already come up with alternate ways to represent these
various examples, using different approaches. For example, rather
than using a <tt class="literal">title</tt> attribute, it might make sense
to nest <tt class="literal">title</tt> elements within a
<tt class="literal">chapter</tt> element. Perhaps an empty tag,
<tt class="literal">&lt;layaway /&gt;</tt>, might be more useful to mark
furniture on layaway. In XML, there is rarely only one way to perform
data representation, and often several good ways to accomplish the
same task. Most often the application and use of the data dictates
what makes the most sense. Rather than tell you how to write XML,
which would be difficult, I show you how to use XML so you gain
insight into how different data formats can be handled and used. This
gives you the knowledge to make your own decisions about formatting
XML documents.
</p>

</div>

<a name="javaxml2-CHP-2-SECT-1.1.4" /></a><div class="sect3">
<h3 class="sect3">2.1.1.4. Entity references and constants</h3>

<p><a name="INDEX-106" /></a>One item I have not discussed is
<a name="INDEX-107" /></a>escaping
characters, or referring to other <a name="INDEX-108" /></a>constant type data values. For
example, a common way to represent a path to an installation
directory is <tt class="literal">&lt;path-to-Cocoon&gt;</tt>. Here, the
user would replace the text with the appropriate choice of
installation directory. In this example, the chapter that discusses
web applications must give some details on installing and using
Apache Cocoon, and might need to represent this data within an
element:
</p>

<blockquote><pre class="code">&lt;topic&gt;
 &lt;heading&gt;Installing Cocoon&lt;/heading&gt;
 &lt;content&gt;
  Locate the Cocoon.properties file in the <tt class="userinput"><b>&lt;path-to-Cocoon&gt;</b></tt>/bin 
  directory.
 &lt;/content&gt;
&lt;/topic&gt;</pre></blockquote>

<p>The problem is that XML parsers attempt to handle this data as an XML
tag, and then generate an error because there is no closing tag. This
is a common problem, as any use of angle brackets results in this
behavior. <em class="filename">Entity
references</em><a name="INDEX-109" /></a> provide a way to overcome this
problem. An entity reference is a special data type in XML used to
refer to another piece of data. The entity reference consists of a
unique name, preceded by an ampersand and followed by a semicolon:
<tt class="literal">&amp;[entity name];</tt><a name="INDEX-110" /></a><a name="INDEX-111" /></a>. When an XML parser sees an entity
reference, the specified substitution value is inserted and no
processing of that value occurs. XML defines five entities to address
the problem discussed in the example:
<tt class="literal">&amp;lt;</tt><a name="INDEX-112" /></a> for the
less-than bracket, <tt class="literal">&amp;gt;</tt><a name="INDEX-113" /></a> for the greater-than bracket,
<tt class="literal">&amp;amp;</tt><a name="INDEX-114" /></a> for the ampersand sign itself,
<tt class="literal">&amp;quot;</tt><a name="INDEX-115" /></a> for a double quotation mark, and
<tt class="literal">&amp;apos;</tt><a name="INDEX-116" /></a> for a single quotation mark or
apostrophe. Using these special references, you can accurately
represent the installation directory reference as:
</p>

<blockquote><pre class="code">&lt;topic&gt;
 &lt;heading&gt;Installing Cocoon&lt;/heading&gt;
 &lt;content&gt;
  Locate the Cocoon.properties file in the 
  <tt class="userinput"><b>&amp;lt;path-to-Cocoon&amp;gt;</b></tt>/bin directory.
 &lt;/content&gt;
&lt;/topic&gt;</pre></blockquote>

<p>Once this document is parsed, the data is interpreted as
"&lt;path-to-Cocoon&gt;" and the document is still
considered well-formed.
</p>

<p>Also be aware that entity references are user-definable. This allows
a sort of shortcut markup; in the XML example I have been walking
through, I reference an external shared copyright text. Because the
copyright is used for multiple O'Reilly books, I don't
want to include the text within this XML document; however, if the
copyright is changed, the XML document should reflect the changes.
You may notice that the syntax used in the XML document looks like
the predefined XML entity references:
</p>

<blockquote><pre class="code">&lt;ora:copyright&gt;&amp;OReillyCopyright;&lt;/ora:copyright&gt;</pre></blockquote>

<p>Although you won't see how the XML parser is told what to
reference when it sees <tt class="literal">&amp;OReillyCopyright;</tt>
until the section on DTDs, you should see that there are more uses
for entity references than just representing difficult or unusual
characters within data.
</p>

</div>

<a name="javaxml2-CHP-2-SECT-1.1.5" /></a><div class="sect3">
<h3 class="sect3">2.1.1.5. Unparsed data</h3>

<p><a name="INDEX-117" /></a>The last XML construct to look at is the
<tt class="literal">CDATA</tt><a name="INDEX-118" /></a> section marker. A
<tt class="literal">CDATA</tt> section is used when a significant amount of
data should be passed on to the calling application without any XML
parsing. It is used when an unusually large number of characters
would have to be escaped using entity references, or when spacing
must be preserved. In an XML document, a <tt class="literal">CDATA</tt>
section looks like this:
</p>

<blockquote><pre class="code">&lt;unparsed-data&gt;
  &lt;![CDATA[Diagram:
       &lt;Step 1&gt;Install Cocoon to "/usr/lib/cocoon"
       &lt;Step 2&gt;Locate the correct properties file.
       &lt;Step 3&gt;Download Ant from "http://jakarta.apache.org"
                                  -----&gt; Use CVS for this &lt;----
  ]]&gt;
&lt;/unparsed-data&gt;</pre></blockquote>

<p>In this example, the information within the <tt class="literal">CDATA</tt>
section does not have to use entity references or other mechanisms to
alert the parser that reserved characters are being used; instead,
the XML parser passes them unchanged to the wrapping program or
application.
</p>

<p>At this point, you have seen the major components of XML documents.
Although each has only been briefly described, this should give you
enough information to recognize XML tags when you see them and know
their general purpose. With existing resources like
O'Reilly's <em class="emphasis">XML in a Nutshell</em> by your side, you are ready to look at some of
the more advanced XML specifications.
</p>

</div>
</div>
<a name="javaxml2-CHP-2-SECT-1.2" /></a><div class="sect2">
<h3 class="sect2">2.1.2. Namespaces</h3>

<p><a name="INDEX-119" /></a> <a name="INDEX-120" /></a>Although I will not delve too deeply into
<a name="INDEX-121" /></a>XML
<a name="INDEX-122" /></a>namespaces here,
note the use of a namespace in the root element of <a href="ch02_01.htm">Example 2-1</a>. An <em class="emphasis">XML namespace</em> is a
means of associating one or more elements in an XML document with a
particular URI. This effectively means that the element is identified
by both its name and its namespace URI. In this XML example, it may
be necessary later to include portions of other O'Reilly books.
Because each of these books may also have <tt class="literal">Chapter</tt>,
<tt class="literal">Heading</tt>, or <tt class="literal">Topic</tt> elements, the
document must be designed and constructed in a way to avoid namespace
collision problems with other documents. The XML namespaces
specification nicely solves this problem. Because the XML document
represents a specific book, and no other XML document should
represent the same book, using a namespace associated with a URI like
<a href="../../../../../../www.oreilly.com/javaxml2">http://www.oreilly.com/javaxml2</a>
can create a unique namespace. The namespace specification requires
that a unique URI be associated with a prefix to distinguish the
elements in the namespace from elements in other namespaces. A URL is
recommended, and supplied here:
</p>

<blockquote><pre class="code">&lt;book xmlns="http://www.oreilly.com/javaxml2"
      xmlns:ora="http://www.oreilly.com"
&gt;</pre></blockquote>

<p>In fact, I've defined two namespaces. The first is considered
the default namespace, because no prefix is supplied. Any element
without a prefix is associated with this namespace. As a result, all
of the elements in the XML document except the
<tt class="literal">copyright</tt> element, prefixed with
<tt class="literal">ora</tt>, are in this default namespace. The second
defines a prefix, which allows the tag
<tt class="literal">&lt;ora:copyright&gt;</tt> to be associated with this
second namespace.
</p>

<p>A final interesting (and somewhat confusing) point:
<a name="INDEX-123" /></a> <a name="INDEX-124" /></a>XML Schema, which
I will talk about more in a later section, requires the schema of an
XML document to be specified in a manner that looks very similar to a
set of namespace declarations; see <a href="ch02_01.htm">Example 2-2</a>.
</p>

<a name="javaxml2-CHP-2-EX-2" /></a><div class="example">
<h4 class="objtitle">Example 2-2. Referencing an XML Schema </h4>
<blockquote><pre class="code">&lt;?xml version="1.0"?&gt;
&lt;addressBook xmlns:xsi="http://www.w3.org/1999/XMLSchema/instance"
             xmlns="http://www.oreilly.com/catalog/javaxml"
             xsi:schemaLocation="http://www.oreilly.com/catalog/javaxml
                                 mySchema.xsd"
&gt;
  &lt;person&gt;
    &lt;name&gt;
      &lt;firstName&gt;Brett&lt;/firstName&gt;
      &lt;lastName&gt;McLaughlin&lt;/lastName&gt;
    &lt;/name&gt;
    &lt;email&gt;brettmclaughlin@earthlink.net&lt;/email&gt;
  &lt;/person&gt;
  &lt;person&gt;
    &lt;name&gt;
      &lt;firstName&gt;Eddie&lt;/firstName&gt;
      &lt;lastName&gt;Balucci&lt;/lastName&gt;
    &lt;/name&gt;
    &lt;email&gt;eddieb@freeworld.net&lt;/email&gt;
  &lt;/person&gt;
&lt;/addressBook&gt;</pre></blockquote>
</div>

<p>Several things happen here, and it is important to understand them
all. First, the XML Schema instance namespace is defined and
associated with a URL. This namespace, abbreviated
<tt class="literal">xsi</tt>, is used for specifying information in XML
documents about a schema, exactly as is being done here. Thus, the
first line makes the elements in the XML Schema instance available to
the document for use. The next line defines the namespace for the XML
document itself. Because the document does not use an explicit
namespace, like the one associated with <a href="../../../../../../www.oreilly.com/javaxml2">http://www.oreilly.com/javaxml2</a> in earlier
examples, the default namespace is declared. This means that all
elements without an explicit namespace and associated prefix (all of
them, in this example) will be associated with this default
namespace.
</p>

<p>With both the document and XML Schema instance namespaces defined
like this, we can then actually do what we want, which is to
associate a schema with this document. The
<tt class="literal">schemaLocation</tt><a name="INDEX-125" /></a> <a name="INDEX-126" /></a> attribute, which belongs to the XML
Schema instance namespace, is used to accomplish this. I've
prefaced this attribute with its namespace (<tt class="literal">xsi</tt>),
which was just defined. The argument to this attribute is actually
<em class="emphasis">two</em> URIs: the first specifies the namespace
associated with a schema, and the second the URI of the schema to
refer to. In the example, this results in the first URI being the
default namespace just declared, and the second a file on the local
filesystem called <em class="emphasis">mySchema.xsd</em>.
Like any other XML attribute, the entire pair is enclosed in a single
set of quotation marks. And as simple as that, you have referenced a
schema in your XML document!
</p>

<p>Seriously, it's not simple, and is to date one of the most
misunderstood portions of using namespaces and XML Schema. I look
more at the mechanics used here as we continue. For now, keep in mind
how namespaces allow elements from various groupings to be used, yet
remain identified as a part of them specific grouping.<a name="INDEX-127" /></a> <a name="INDEX-128" /></a>
</p>

</div>
</div>










<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch01_04.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch02_02.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">1.4. What's Next?</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">2.2. Constraints</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
      </map>

</body></html>
