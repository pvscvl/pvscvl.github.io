<html><head><title>Producer-Side Validation (SAX2)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="David Brownell" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596002378L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="SAX2" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="SAX2" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch02_03.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch02_05.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>



	<h2 class="sect1">2.4. Producer-Side Validation</h2>

	<p>
<a name="INDEX-206" />
<a name="INDEX-207" />
<a name="INDEX-208" />
<a name="INDEX-209" />
<a name="INDEX-210" />
<a name="INDEX-211" />

        All uses of SAX2 parsers will involve extending and 
	customizing the basic scenario we saw earlier.
	Our next example illustrates two basic configuration mechanisms:
	<em class="emphasis">error handling</em> options, which lets you use the
	appropriate policy when you see errors, and
	<em class="emphasis">parser configuration</em> through feature flags, which
	let you control some details of how the parser works.
	(Some event handlers are managed with a configuration mechanism
	that is quite similar to the feature flag mechanism.)
	The example also shows how SAX2 parsers expose the core XML
	notion of <em class="emphasis">DTD-based validation</em>.
	</p>

	<blockquote><table border="1" cellpadding="6"><tr><td>
	    <h4 class="objtitle">Validity and XML</h4>

	    <p>
<a name="INDEX-212" />
            Validation is particularly important when you
	    are interchanging documents that have been wholly
	    or partially authored by hand, but it can also be helpful
	    when working with XML that's generated by custom code.
	    When you validate an XML document, you ensure that it
	    meets certain rules needed to process them -- such as 
	    requiring a
	    <tt class="sgmltag-element">&lt;title&gt;</tt> element as the first child of
	    every <tt class="sgmltag-element">&lt;chapter&gt;</tt> element or prohibiting 
	    dangling internal cross-references. </p>

	    <p><a name="INDEX-213" />
            <a name="INDEX-214" />
            <a name="INDEX-215" />
<a name="INDEX-216" />
            Validation is done at several levels in most
	    applications. Lower levels tend to use
	    <em class="emphasis">rule-based logic</em>,
	    such as the DTD validation that's defined by XML 1.0.
	    The various types of XML schema provide different
	    kinds of rule-based sanity checks, which are
	    usually done before applications see the data.
	    (W3C's schemas also extract additional information items,
	     beyond the
	    XML data model of elements, attributes, and text. 
	    This information is called the "Post-Schema-Validation 
	    Infoset" or PSVI.)
	    Higher-level validation processes tend to involve
	    richer notions of data validity and tend to be expressed
	    as <em class="emphasis">procedural logic</em>.
	    For example, "business logic" often involves
	    ad hoc relationships, policies, and heuristics; it relies
	    on information not normally expressible by
	    DTD or schema-style rules.
	    Such logic is often captured in application-level methods.
	    As a rule, no single data validation technology is
	    sufficient for all purposes.
	    </p>

	    <p>Your development process should try to ensure
	    that you create only valid documents; you will likely
	    send XML to applications that don't handle invalid
	    data very well.
	    Safe operational practice involves validating all documents
	    received from other parties and accepting the small
	    costs involved.
	    (Use local copies of DTDs, or schemas, to avoid depending
	    on remote files that might disappear. Techniques to achieve this
	    are discussed in <a href="ch03_04.htm">Section 3.4, "The EntityResolver Interface"</a> in <a href="ch03_01.htm">Chapter 3, "Producing  SAX2 Events"</a>.)
	    The cost of rule-based validation is usually smaller than
	    routine system load variations for real applications; even in 
	    parsing speed benchmarks it's rarely high.
	    It's usually worth the cost since it can prevent someone
	    else's data from accidentally breaking your software.
	    Validation against a good DTD (or schema) provides a
	    useful base level of input data checking, but it will
	    rarely be sufficient.
	    </p>

	</td></tr></table><p></blockquote>

	<p>
        <a name="INDEX-217" />
        You will often tell XML parsers to validate XML as
	they produce events.
	Because SAX2 provides access to most of the data
	in XML documents, including declarations from DTDs,
	it also supports performing such validation 
	on the event consumer side, possibly with
	a cached DTD or schema.
	(The consumer side is the only place to perform procedural
	validation.)
	Such consumer-side validation can be important when you're trying
	to make your program output meet the constraints
	of a particular information interchange agreement; just add
	a streaming validation stage to your output processing.
	This approach can also be used for DOM revalidation and
	similar purposes.
	Here, we look at how to validate data that is already in
	the form of XML text.
	</p>

	<p>Keep in mind that some important DTD-related
	processing does not involve validation.
	Documents with DTDs can
	use entity substitution for document modularity and text portability,
	and can have attributes defaulted and normalized.
	Validation with DTDs only involves checking a set of rules.
	Disabling DTD validation turns off only the rule checks,
	not the processing for entities and attributes.
	</p>

	<a name="sax2-CHP-2-SECT-4.1" /><div class="sect2">
	    <h3 class="sect2">2.4.1. SAX2 Feature Flags</h3>

	    <p>
<a name="INDEX-218" />
<a name="INDEX-219" />
<a name="INDEX-220" />

            SAX2 exposes many parser behaviors, including DTD
	    validation, using a "feature flag" mechanism.
	    These flags are Boolean settings,
	    which may have values
	    or be unspecified.
	    Parsers can have up to four different modes for any feature flag.
	    For example, with the validation flag
	    SAX2 implies four kinds of XML parsers:
	    </p>

	    <dl>
		<dt><i>Optionally validating parsers</i></dt>
		    <dd><p>
<a name="INDEX-221" />
                    The feature flag is read/write and
		    can be either true or false.
		    If it's set to false, few nonfatal errors
		    will be reported and parsing will be a bit faster
		    (maybe 5 or 10 percent of the cost of parsing
		    XML, which is usually negligible to start with).
		    </p></dd>
		    
		<dt><i>Nonvalidating parsers</i></dt>
		    <dd><p>
<a name="INDEX-222" />
                    The feature flag is read-only and
		    always false. Some nonfatal errors might be
		    reported (the XML specification demands them in 
		    some cases).
		    </p></dd>
		    
		<dt><i>Always validating parsers</i></dt>
		    <dd><p>
<a name="INDEX-223" />
                    The feature flag is read-only and
		    always true. Validity errors are always
		    reported as nonfatal.
		    (By default, such errors are ignored; see <a href="ch02_04.htm">Section 2.4.2, "Handling Validity Errors"</a> later in this chapter.)
		    </p></dd>
		    
		<dt><i>Unknown validation behavior</i></dt>
		    <dd><p>
<a name="INDEX-224" />
                    The feature flag is not recognized,
		    so its value can't be determined.
		    (This mode is uncommon for the SAX2 validation flag,
		    but you'll see it with other feature flags.)
		    </p></dd>
		    
	    </dl>

	    <p>Later in this chapter, look at the feature
	    flags used to characterize namespace processing.
	    Those flags are not optional, so fewer potential
	    parser modes are possible.
	    All the standardized feature flags are detailed
	    in <a href="ch03_03.htm">Section 3.3.2, "XMLReader Feature Flags"</a> in <a href="ch03_01.htm">Chapter 3, "Producing  SAX2 Events"</a>.
	    </p>

	    <p>In SAX, URIs identify feature flags.
	    These are used purely as unique identifiers.
	    This is the same approach used in XML namespaces: don't
	    use these URIs to retrieve data, even if they
	    do look like URLs you could type into a browser. The URI
	    <a href="../../../../../../xml.org/sax/features/validation">http://xml.org/sax/features/validation</a>
	    identifies the flag-controlling validation.
	    </p>

   <blockquote><table border="1" cellpadding="6"><tr><td>
	<h4 class="objtitle">URIs = URLs + URNs</h4>
&nbsp;
	<p>
        
<a name="INDEX-225" />
        The use of URIs in XML namespaces has been
	confusing, and since SAX2 also uses URIs 
	to identify parser feature flags and properties, the same
	sort of confusion can show up.
	Think of URIs as names: you can talk about "Fred" even if
	he's not there, or about "Godot" even if he may not exist,
	and "the third house on the left" probably makes sense to
	someone standing at your side.
	</p>
&nbsp;
	<p>
<a name="INDEX-226" />
<a name="INDEX-227" />
<a name="INDEX-228" />
<a name="INDEX-229" />
<a name="INDEX-230" />
<a name="INDEX-231" />
<a name="INDEX-232" />
<a name="INDEX-233" />
<a name="INDEX-234" />
<a name="INDEX-235" />
        
        Classically, a <em class="emphasis">Universal Resource 
        Identifier</em> (URI),
	is either a <em class="emphasis">Universal Resource Locator</em> (URL) or a
	<em class="emphasis">Universal Resource Name</em> (URN).
	Both types of URIs are represented as strings.
	You're used to seeing URLs in web browsers; they serve
	as detailed addresses. They often look like
	<a href="../../../../../../www.example.com/">http://www.example.com/</a>
	but they may use other <em class="emphasis">URI schemes</em> --  for example, they may use <em class="emphasis">https:</em>,
	<em class="emphasis">ftp:</em> and <em class="emphasis">file:</em>. The scheme indicates the way to access the resource. URNs use URI schemes that start with <em class="emphasis">urn:</em>. You probably have not seen many URNs; one example is <em class="emphasis">urn:uuid:221ffe10-ae3c-11d1-b66c-00805f8a2676</em>. URN schemes (like <em class="emphasis">uuid</em> in this example) describe what the resource is, more than how to access it.
	</p>
&nbsp;
	<p><em class="emphasis">Filenames are never URIs</em>,
	but you can convert a filename into a URL (hence URI)
	that works on systems where the original filename was legal.
	Just to be confusing, there are also "relative URIs,"
	which often look like POSIX-style filenames.
	Like filenames, relative URIs should never be handed directly
	to a SAX parser or be used as namespace identifiers.
	</p>
&nbsp;
	<p>With XML namespaces and SAX2, the term URI is used
	to emphasize that the string is being used
	as a pure identifier: it's more like a URN than a URL, even when
	the URI is syntactically a URL.
	It's explicitly irrelevant whether any resource is actually
	associated with the URI.
	Don't assume you can fetch resources using those URIs.
	</p>
&nbsp;
    </td></tr></table><p></blockquote>
 


	    <p>To check how a given XML parser handles validation, use
	    code similar to <a href="ch02_04.htm">Example 2-5</a>.
	    Code for any other kind of parser feature will look much the same,
 	    as long as you
	    use the correct ID for the feature flag; you'll see
	    the same exception types working in the same way.
	    (The same is true for parser "properties," which you'll
	    see in <a href="ch03_03.htm">Section 3.3.1, "XMLReader Properties"</a> in <a href="ch03_01.htm">Chapter 3, "Producing  SAX2 Events"</a>.)
	    </p>

	    <a name="sax2-CHP-2-EX-5" /><div class="example">
		<h4 class="objtitle">Example 2-5. Checking for validation support</h4>

		<blockquote><pre class="code">
XMLReader       producer;
String          uri = "http://xml.org/sax/features/validation";

// ... get the parser

// Try getting and setting the flag
try {
    System.out.println ("Initial validation setting: "
	+ producer.getFeature (uri));
    // if we get here, validation behavior is known

    producer.setFeature (uri, true);
    // if we get here, the parser either validates by
    // default or is optionally validating

} catch (SAXNotSupportedException e) {
    // value not supported; parser is nonvalidating
    System.out.println ("Can't enable validation: "
	+ e.getMessage ());
    System.exit (1);

} catch (SAXNotRecognizedException e) {
    // feature not understood; parser has weak SAX2 support.
    // maybe it's a SAX1 parser inside a ParserAdapter
    System.out.println ("Doesn't understand validation: "
	+ e.getMessage ());
    System.exit (1);
}</pre></blockquote>

		</div>



	    <p>
<a name="INDEX-236" />
            As a rule, programs will probably set the validation
	    flag to true only when they really need reports of
	    validity errors.
	    (Why?  As we'll see in a moment, it's natural to ignore
	    reports of validity errors when they're not important,
	    so it doesn't much matter if you validate when you don't
	    need to.)
	    The skeleton program in <a href="ch02_02.htm">Example 2-1</a> really just needs a
	    <tt class="literal">setFeature()</tt> call and a small update
	    to the diagnostic message, to be sure it's always
	    validating.
	    (The diagnostics could be more precise using some more-specialized
 	    exceptions that we haven't discussed yet.)
	    </p>

	    <blockquote><pre class="code">
// Get an instance of the default XML parser class
try {
    producer = XMLReaderFactory.createXMLReader ();
    producer.setFeature (
	"http://xml.org/sax/features/validation",
	true);
} catch (SAXException e) {
    System.err.println (
	  "Can't get validating parser, check configuration: "
	+ e.getMessage ());
    return;
}</pre></blockquote>

	    <p>The validation feature flag is probably the most
	    widely used, with the possible exception of the flags
	    controlling namespace handling.
	    Most parsers leave validation off by default
	    to save some minor parsing overhead.
<a name="INDEX-237" />
<a name="INDEX-238" />
	    
</p>

	    </div>

	<a name="sax2-CHP-2-SECT-4.2" /><div class="sect2">
	    <h3 class="sect2">2.4.2. Handling Validity Errors</h3>

	    <p>
<a name="INDEX-239" />
<a name="INDEX-240" />
<a name="INDEX-241" />
<a name="INDEX-242" />
           

            If you modify the skeleton program to set the
	    parser's validation flag and then run it on a well-formed
	    but invalid document (perhaps one without a DTD), you will
	    probably be surprised to discover that it doesn't seem to
	    report any errors. That's exactly what should happen since
	    it's the default behavior specified by SAX.
	    To make validity errors cause anything interesting to happen,
	    you have to change how they're handled.
	    <em class="emphasis">If you don't change this handling, you won't
	    be able tell a validating parser apart from a
	    nonvalidating one!</em>
	    </p>

	    <p>
<a name="INDEX-243" />
            The simplest way to change the handling of validity
	    errors is to make them work just like well-formedness errors:
	    by aborting the parse.
	    This uses the <em class="emphasis">ErrorHandler</em> interface
	    that we look at later in this chapter, in <a href="ch02_05.htm">Section 2.5.2, "ErrorHandler Interface"</a>, but for now it's simpler to
	    focus on one method.
	    In terms of the skeleton program shown earlier,
	    such a change can be an update to just one line,
	    using an anonymous inner class to make the
	    code look simple. (Of course, avoid using anonymous
	    classes for anything complex; they can make code
	    hard to maintain.)
	    </p>

	    <blockquote><pre class="code">
// Get a consumer for all the parser events
consumer = new DefaultHandler () {
    public void error (SAXParseException e)
    throws SAXException
	{ throw e; }
    };</pre></blockquote>

	    <p>XML parsers call <tt class="literal">ErrorHandler.error()</tt>
	    whenever they find a validity error, or when they see certain
	    other nonfatal errors. In this
	    case, our custom handler adopts a policy that whenever it
	    sees such an error, it will abort the parse
	    by throwing the exception reported to it.
	    Later in this chapter we look at some alternative policies.
	    </p>
	    
	    <p>
<a name="INDEX-244" />
            When your callback detects serious application-level
	    errors, you can throw a <em class="emphasis">SAXException</em>
	    from any SAX event handler callback to abort parsing.
	    That doesn't have be done only from an <em class="emphasis">ErrorHandler</em>. For example, when input data is valid XML but doesn't meet essential semantic requirements of the application, report it using some kind of <em class="emphasis">SAXException</em>. If your code only knows how to process shipping invoices, then greeting cards should be rejected immediately.
<a name="INDEX-245" />
<a name="INDEX-246" />
<a name="INDEX-247" />
<a name="INDEX-248" />
<a name="INDEX-249" />
<a name="INDEX-250" />
    
</p>

	    </div>

    

<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch02_03.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch02_05.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">2.3. Basic ContentHandler Events</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">2.5. Exception Handling</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
</map>

</body></html>