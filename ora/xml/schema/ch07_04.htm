<html><head><title>Complex Content Models (XML Schema)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Eric van der Vlist" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596002521L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="XML Schema" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="XML Schema" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch07_03.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch07_05.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>



<h2 class="sect1">7.4. Complex Content Models</h2>

<p>Restricting or extending simple content models is useful, but XML is
not very useful without more complex models.
</p>

<a name="xmlschema-CHP-7-SECT-4.1" /><div class="sect2">
<h3 class="sect2">7.4.1. Creation of Complex Content</h3>

<p>Complex <a name="INDEX-530" />
<a name="INDEX-531" />contents are created by
defining the list (and order) of its elements and attributes. We have
already seen a couple of examples of complex content models, defined
as local complex types in <a href="ch01_01.htm">Chapter 1, "Schema Uses and Development"</a> and <a href="ch02_01.htm">Chapter 2, "Our First Schema"</a>: 
</p>

<blockquote><pre class="code">&lt;xs:element name="library"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="book" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>These examples show the basic structure of a complex type with
complex content definition: <a name="INDEX-532" />the <tt class="literal">xs:complexType</tt>
element is holding the definition. Here, this definition is local
(<tt class="literal">xs:complexType</tt> is not top-level since it is included
under <a name="INDEX-533" />an <tt class="literal">xs:element</tt>
element) and, thus, anonymous. Under <tt class="literal">xs:complexType</tt>, we
find the sequence of children <a name="INDEX-534" />elements (<tt class="literal">xs:sequence</tt>) and the list of attributes.
</p>

<a name="xmlschema-CHP-7-SECT-4.1.1" /><div class="sect3">
<h3 class="sect3">7.4.1.1. Compositors and particles</h3>

<p>In <a name="INDEX-535" /> <a name="INDEX-536" />these examples, the
<a name="INDEX-537" /><tt class="literal">xs:sequence</tt>
elements have a role as
"compositors" and the
<a name="INDEX-538" /><tt class="literal">xs:element</tt>
elements, which are included in <tt class="literal">xs:sequence</tt>, play a
role of "particle." This simple
scenario may be extended using other compositors and particles.
</p>

<p>W3C XML Schema defines three different compositors: <tt class="literal">xs:sequence</tt>, to define ordered lists of particles;
<a name="INDEX-539" /><tt class="literal">xs:choice</tt>, to
define a choice of one particle among several; and
<a name="INDEX-540" /><tt class="literal">xs:all</tt>, to
define nonordered list of particles. The <tt class="literal">xs:sequence</tt>
and <tt class="literal">xs:choice</tt> compositors can define their own
number of occurrences using
<tt class="literal">minOccurs</tt><a name="INDEX-541" /> and
<tt class="literal">maxOccurs</tt><a name="INDEX-542" /> attributes and they can be used as
particles (some important restrictions apply to <tt class="literal">xs:all</tt>, which cannot be used as a particle, as we
will see in the next section).
</p>

<p>The particles are <tt class="literal">xs:element</tt>, <tt class="literal">xs:sequence</tt>, <tt class="literal">xs:choice</tt>, plus <tt class="literal">xs:any</tt> and <tt class="literal">xs:group</tt>, which we
will see later in the section. The ability to include compositors
within compositors is key to defining complex structures, although it
is unfortunately subject to the allergy of W3C XML Schema for
"nondeterminism."
</p>

<p>To give an idea of the kind of structures that can be defined,
let's suppose that the names in our library may be
expressed in two different ways: either as a <tt class="literal">name</tt>
element, as we have shown up to now, or as three different elements
to define the first, middle, and last name (the middle name should be
optional). Names could then be expressed as one of the three
following combinations:
</p>

<blockquote><pre class="code">&lt;first-name&gt;
  Charles
&lt;/first-name&gt;
      &lt;middle-name&gt;
  M
&lt;/middle-name&gt;
       &lt;last-name&gt;
  Schulz
&lt;/last-name&gt;</pre></blockquote>

<p>or:                                          </p>

<blockquote><pre class="code">&lt;first-name&gt;
  Peppermint
&lt;/first-name&gt;
      &lt;last-name&gt;
  Patty
&lt;/last-name&gt;</pre></blockquote>

<p>or:                                          </p>

<blockquote><pre class="code">&lt;name&gt;
  Snoopy
&lt;/name&gt;</pre></blockquote>

<p>To describe this, we will replace the reference to the
<tt class="literal">name</tt> element with a choice between either a
<tt class="literal">name</tt> element or a sequence of
<tt class="literal">first-name</tt>, <tt class="literal">middle-name</tt>
(optional), and <tt class="literal">last-name</tt>. The definition of
author then becomes:
</p>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="name"/&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="first-name"/&gt;
          &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
          &lt;xs:element ref="last-name"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>The <tt class="literal">name</tt> element also appears in the
<tt class="literal">character</tt> element, and a copy/paste can be used to
replace it with the <tt class="literal">xs:choice</tt> structure, but we
would rather take this opportunity to introduce a new feature that is
very handy to manipulating reusable sets of elements.
</p>

</div>

<a name="xmlschema-CHP-7-SECT-4.1.2" /><div class="sect3">
<h3 class="sect3">7.4.1.2. Element and attribute groups</h3>

<p>Element <a name="INDEX-543" />
<a name="INDEX-544" />and
attribute
<a name="INDEX-545" />
<a name="INDEX-546" />groups are containers in which sets of
elements and attributes may be embedded and manipulated as a whole.
These simple and flexible structures are very convenient for defining
bits of <a name="INDEX-547" /> <a name="INDEX-548" />content
models that can be reused in multiple locations, such as the <tt class="literal">xs:choice</tt> structure that we created for our name.
</p>

<p>The first step is to define the element group. The definition needs
to be named and global (i.e., immediately under the <tt class="literal"><a href="ch15_01.htm">xs:schema</a></tt> element) and has the following form:
</p>

<blockquote><pre class="code">&lt;xs:group name="name"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="first-name"/&gt;
      &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
      &lt;xs:element ref="last-name"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;</pre></blockquote>

<p>These groups can then be used by reference as particles within
compositors:
</p>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
             
&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="qualification"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>Groups of attributes can be created in the same way using
<a name="INDEX-549" /><tt class="literal">xs:attributeGroup</tt>:
</p>

<blockquote><pre class="code">&lt;xs:attributeGroup name="bookAttributes"&gt;
  &lt;xs:attribute name="id" type="xs:ID"/&gt;
  &lt;xs:attribute name="available" type="xs:boolean"/&gt;
&lt;/xs:attributeGroup&gt;
             
&lt;xs:element name="book"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="isbn"/&gt;
      &lt;xs:element ref="title"/&gt;
      &lt;xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/&gt; 
      &lt;xs:element ref="character" minOccurs="0"
        maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attributeGroup ref="bookAttributes"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-7-SECT-4.1.3" /><div class="sect3">
<h3 class="sect3">7.4.1.3. Unique Particle Attribution Rule</h3>

<p>Let's <a name="INDEX-550" /> <a name="INDEX-551" />try a new example to illustrate one of
the most constraining limitations of W3C XML Schema. We may want to
describe all the pages of our books and to have a different
description using different elements, such as
<tt class="literal">odd-page</tt> and <tt class="literal">even-page</tt> for odd
and even pages that require a different pagination. We can try to
describe the new content model in the following group:
</p>

<blockquote><pre class="code">&lt;xs:group name="pages"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="odd-page"/&gt;
      &lt;xs:element ref="even-page"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:element ref="odd-page" minOccurs="0"/&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:group&gt;</pre></blockquote>

<p>This seems like a simple, smart way to describe the sequences of odd
and even pages: a sequence of odd and even pages eventually followed
by a last odd page. The model covers books with an odd or even number
of pages as well as tiny booklets with a single page. Neither XSV not
Xerces appear to enjoy it, though:
</p>

<blockquote><pre class="code">XSV:

vdv@evlist:~/w3c-xml-schema/user/examples/complex-types$ xsd -n first-ambigous.xsd 
first-ambigous.xml
using xsv (default)
&lt;?xml version='1.0'?&gt;
&lt;xsv docElt='{None}library' instanceAssessed='true' instanceErrors='0' 
rootType='[Anonymous]' schemaDocs='first-ambigous.xsd' schemaErrors='1' 
target='/home/vdv/w3c-xml-schema/user/examples/complex-types/first-ambigous.xml' 
validation='strict' version='XSV 1.203.2.20/1.106.2.11 of 2001/11/01 17:07:43' 
xmlns='http://www.w3.org/2000/05/xsv'&gt;
&lt;schemaDocAttempt URI='/home/vdv/w3c-xml-schema/user/examples/complex-types/first-
ambigous.xsd' 
outcome='success' source='command line'/&gt;
&lt;schemaError char='7' line='65' phase='instance' 
resource='file:///home/vdv/w3c-xml-schema/user/examples/complex-types/first-ambigous.
xsd'&gt;
non-deterministic content model for type None: {None}:odd-page/{None}:odd-page
&lt;/schemaError&gt;
&lt;/xsv&gt;

Xerces:

vdv@evlist:~/w3c-xml-schema/user/examples/complex-types$ xsd -n first-ambigous.xsd 
-p xerces-cvs first-ambigous.xml
using xerces-cvs
startDocument
[Error] first-ambigous.xml:2:10: Error: cos-nonambig: (,odd-page) 
and (,odd-page) violate the "Unique Particle Attribution" rule.
endDocument</pre></blockquote>

<p>Misled by the apparent flexibility of construction with compositors
and particles, we violated an ancient taboo known in SGML as
"<a name="INDEX-552" />ambiguous content
models," which was imported into
XML's DTDs as "<a name="INDEX-553" />nondeterministic content
models," and preserved by W3C XML Schema as the
"Unique Particle Attribution Rule."
</p>

<p>In <a name="INDEX-554" />practice, this rule adds a significant
amount of complexity to writing a W3C XML Schema, since it must be
matched after all the many features, which allow you to define,
redefine, derive, import, reference, and substitute complex types,
have been resolved by the schema processor. The Recommendation
recognizes that "given the presence of element
substitution groups and wildcards, the concise expression of this
constraint is difficult." When these features have
been resolved, the remaining constraint requires that a schema
processor should never have any doubt about which branch it is in
while doing the validation of an element and looking only at this
element. Applied to the previous example, which was as simple as
possible, there is a problem. When a schema processor meets the first
<tt class="literal">odd-page</tt> element, it has no way of knowing if the
page will be followed by an <tt class="literal">even-page</tt> element
without first looking ahead to the next element. This is a violation
of the Unique Particle Attribution Rule.
</p>

<p>This <a name="INDEX-555" />example, adapted from an
example describing a chess board, is one of the famous instances in
which the content model cannot be written in a
"deterministic" way. This is not
always the case, and many nondeterministic constructions describe
content models that may be rewritten in a deterministic fashion. We
should differentiate those that are fundamentally nondeterministic
from those that are only
"accidentally" nondeterministic.
Let's go back to our example with a
"name" sequence that can have two
different content models, and imagine that instead of using
<tt class="literal">first-name</tt>, we reused the name
<tt class="literal">name</tt>. The content model is now either
<tt class="literal">name</tt> or a sequence of <tt class="literal">name</tt>,
"middle-name," and
"last-name":
</p>

<blockquote><pre class="code">&lt;xs:group name="name"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="name"/&gt;
      &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
      &lt;xs:element ref="last-name"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;
             
&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>Here again, when the processor meets a <tt class="literal">name</tt>
element, it has no way of knowing (without looking ahead) if this
element matches the first or the second branch of the choice. In this
case, though, the content model may be simplified if we note that the
<tt class="literal">name</tt> element is common to both branches and that,
in fact, we now have a mandatory <tt class="literal">name</tt> element
followed by an optional sequence of an optional
<tt class="literal">middle-name</tt> and a mandatory
<tt class="literal">last-name</tt>. The content model can then be rewritten
in a deterministic way as:
</p>

<blockquote><pre class="code">&lt;xs:group name="name"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:sequence minOccurs="0"&gt;
      &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
      &lt;xs:element ref="last-name"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:group&gt;</pre></blockquote>

<p>This is a slippery path, though, which frequently depends on slight
nuances in the content model and leads to schemas that are very
difficult to maintain and may require nonsatisfactory compromises. If
the requirement for the content model we have just written is changed
and the <tt class="literal">name</tt> element in the second branch is no
longer mandatory, then we are in trouble. The new content model is as
follows:
</p>

<blockquote><pre class="code">&lt;xs:group name="name"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="name" minOccurs="0"/&gt;
      &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
      &lt;xs:element ref="last-name"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;</pre></blockquote>

<p>But this model is nondeterministic for the same reason that the
previous one was, and we need to reevaluate the different possible
combinations to find that the new content model can now be expressed
as:
</p>

<blockquote><pre class="code">&lt;xs:group name="name"&gt;
  &lt;xs:choice&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="name"/&gt;
      &lt;xs:sequence minOccurs="0"&gt;
        &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
        &lt;xs:element ref="last-name"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
      &lt;xs:element ref="last-name"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;</pre></blockquote>



<a name="ch07-4-fm2xml" /><blockquote><b>NOTE:</b> 
Formal theories and algorithms can rewrite nondeterministic content
models in a deterministic way when possible. Hopefully, W3C XML
Schema development tools will integrate some of these algorithms to
propose an alternative when a schema author creates nondeterministic
content models.
</p>

<p>Ambiguous content models were already a controversial issue in the
90s among the SGML community, and the restriction has been maintained
in XML DTDs under the name "nondeterministic content
models" despite the dissent of Tim
<a name="INDEX-556" />Bray, Jean
<a name="INDEX-557" />Paoli, and Peter
<a name="INDEX-558" />Sharpe, three
influential members of the XML Special Interest Group who wanted to
maintain a compatibility with SGML parsers. The motivation to
maintain the restriction in W3C XML Schema is to keep schema
processors simple to implement and to allow implementations through
<a name="INDEX-559" />
<a name="INDEX-560" />finite state machines (FSM). The
execution time of these automatons could grow exponentially when the
Unique Particle Attribution Rule is violated. This decision has been
heavily criticized by experts including Joe
<a name="INDEX-561" />English, James
<a name="INDEX-562" />Clark, and
Murata <a name="INDEX-563" />Makoto, who have proved that other simple
algorithms might be used that keep the processing time linear when
this rule is not met. This is also one of the main differences
between the descriptive powers of schema languages, such as RELAX,
TREX, and RELAX NG, which do not impose this rule, <a name="INDEX-564" />and <a name="INDEX-565" />W3C <a name="INDEX-566" />XML <a name="INDEX-567" /> <a name="INDEX-568" />Schema.
</p>
</blockquote>

</div>

<a name="xmlschema-CHP-7-SECT-4.1.4" /><div class="sect3">
<h3 class="sect3">7.4.1.4. Consistent Declaration Rule</h3>

<p>Although not related, strictly speaking, the Unique Particle
Attribution Rule and the <a name="INDEX-569" /> <a name="INDEX-570" />Consistent Declaration Rule are often
associated, since, in practice, when the Constant Declaration Rule is
violated, the Unique Particle Attribution Rule is often violated too.
This new rule is much easier to explain and understand, since it only
states that W3C XML Schema explicitly forbids choices between
elements with the same name and different types, such as in the
following:
</p>

<blockquote><pre class="code">&lt;xs:choice&gt;
  &lt;xs:element name="name" type="xs:string"/&gt;
  &lt;xs:element name="name"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="first-name"/&gt;
        &lt;xs:element ref="middle-name"/&gt;
        &lt;xs:element ref="last-name"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:choice&gt;</pre></blockquote>

<p>We will see a workaround using the <tt class="literal">xsi:type</tt>
attribute, which may be used by some applications, in <a href="ch11_01.htm">Chapter 11, "Referencing Schemas and Schema Datatypes in XML Documents"</a>. 
</p>

</div>

<a name="xmlschema-CHP-7-SECT-4.1.5" /><div class="sect3">
<h3 class="sect3">7.4.1.5. Limitations on unordered content models</h3>

<p>While useful, <a name="INDEX-571" /> <a name="INDEX-572" />unordered content models have their own
sets of limitations.
</p>

<a name="xmlschema-CHP-7-SECT-4.1.5.1" /><div class="sect4">
<h4 class="sect4">7.4.1.5.1. Limitations of <tt class="literal">xs:all</tt></h4>

<p>Unordered <a name="INDEX-573" />content models (i.e., content models that
do not impose any order on the children elements) not only increase
the risks of nondeterministic content models, but are also an
important complexity factor for schema processors. For the sake of
implementation simplicity, the Recommendation has imposed huge
limitations on the <tt class="literal">xs:all</tt> element, which makes
it hardly usable in practice. <tt class="literal">xs:all</tt> cannot be
used as a particle, but as a compositor only; <tt class="literal">xs:all</tt> cannot have a number of occurrences greater
than one; the particles included within <tt class="literal">xs:all</tt>
must be <tt class="literal">xs:element</tt>; and these particles must not
specify numbers of occurrences greater than one.
</p>

<p>To illustrate these limitations, let's imagine we
have decided to simplify the life of document producers and want to
create a vocabulary that doesn't care about the
relative order of children elements. With a simple vocabulary such as
the one defined in our first schema, this wouldn't
add a big burden to the applications handling our vocabulary. When
you think about it, there is no special reason to impose the
definition the title of a book after its ISBN number or the
definition of the list of authors before the list of characters.The
first content model that may be affected by this decision is the
content model of the <tt class="literal">book</tt> element:
</p>

<blockquote><pre class="code">&lt;xs:element name="book"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="isbn"/&gt;
      &lt;xs:element ref="title"/&gt;
      &lt;xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/&gt; 
      &lt;xs:element ref="character" minOccurs="0"
        maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
    &lt;xs:attribute ref="available"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>Unfortunately, here the <tt class="literal">xs:sequence</tt> cannot be
replaced by <tt class="literal">xs:all</tt>, since two of the children
elements (<tt class="literal">author</tt> and <tt class="literal">character</tt>)
have a maximum number of occurrences that is
"unbounded" and thus higher than
one. The second group of candidates includes the content models of
<tt class="literal">author</tt> and <tt class="literal">character</tt>, which are
relatively similar:
</p>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
                
&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="qualification"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>The good news here is that both <tt class="literal">author</tt> and
<tt class="literal">character</tt> match the criteria for <tt class="literal">xs:all</tt>, so we can write:
</p>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:all&gt;
      &lt;xs:element ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
                
&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:all&gt;
      &lt;xs:element ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="qualification"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>We can have two elements (<tt class="literal">author</tt> and
<tt class="literal">character</tt>) in which the order of children elements
is not significant. One may question, though, whether this is very
interesting since this independence is not consistent throughout the
schema. More importantly, we must note that we have lost a great deal
of flexibility and extensibility by using a <tt class="literal">xs:all</tt> compositor. Since the maximum number of
occurrences for each child element needs to be one, we can no longer,
for instance, change the number of occurrences of the
<tt class="literal">qualification</tt> element to accept several
qualifications in different languages. And since the particles used
in <tt class="literal">xs:all</tt> cannot be compositors or groups, we
can't extend the content model to accept both
<tt class="literal">name</tt> and the sequence
<tt class="literal">first-name</tt>, <tt class="literal">middle-name</tt>, and
<tt class="literal">last-name</tt> either.
</p>

<p>Since <tt class="literal">xs:all</tt> appears to be pretty ineffective
in general, there are a couple of workarounds that may be proposed
for people who would like to develop order-independent <a name="INDEX-574" />vocabularies.
</p>

</div>

<a name="xmlschema-CHP-7-SECT-4.1.5.2" /><div class="sect4">
<h4 class="sect4">7.4.1.5.2. Adapting the structure of your document</h4>

<p>The <a name="INDEX-575" />first <a name="INDEX-576" />workaround, which may be used
only if you are creating your own vocabulary from scratch, is to
adapt the structures of your document to the constraint of <tt class="literal">xs:all</tt>. In practice, this means that each time we
have to use a <tt class="literal">xs:choice</tt>, a <tt class="literal">xs:sequence</tt>, or include elements with more than one
occurrence, we will add a new element as a container. For instance,
we will create containers named <tt class="literal">authors</tt> and
<tt class="literal">characters</tt> that will encapsulate the multiple
occurrences of <tt class="literal">author</tt> and
<tt class="literal">character</tt>. The result is instance documents such
as:
</p>

<blockquote><pre class="code">&lt;?xml version="1.0"?&gt; 
&lt;library&gt;
  &lt;book id="b0836217462" available="true"&gt;
    &lt;title lang="en"&gt;
      Being a Dog Is a Full-Time Job
    &lt;/title&gt;
    &lt;isbn&gt;
      0836217462
    &lt;/isbn&gt;
    &lt;authors&gt;
      &lt;author id="CMS"&gt;
        &lt;born&gt;
          1922-11-26
        &lt;/born&gt;
        &lt;dead&gt;
          2000-02-12
        &lt;/dead&gt;
        &lt;name&gt;
          Charles M Schulz
        &lt;/name&gt;
      &lt;/author&gt;
    &lt;/authors&gt;
    &lt;characters&gt;
      &lt;character id="PP"&gt;
        &lt;name&gt;
          Peppermint Patty
        &lt;/name&gt;
        &lt;qualification&gt;
          bold, brash and tomboyish
        &lt;/qualification&gt;
        &lt;born&gt;
          1966-08-22
        &lt;/born&gt;
      &lt;/character&gt;
      &lt;character id="Snoopy"&gt;
        &lt;born&gt;
          1950-10-04
        &lt;/born&gt;
        &lt;name&gt;
          Snoopy
        &lt;/name&gt;
        &lt;qualification&gt;
          extroverted beagle
        &lt;/qualification&gt;
      &lt;/character&gt;
      &lt;character id="Schroeder"&gt;
        &lt;qualification&gt;
          brought classical music to the Peanuts strip
        &lt;/qualification&gt;
        &lt;name&gt;
          Schroeder
        &lt;/name&gt;
        &lt;born&gt;
          1951-05-30
        &lt;/born&gt;
      &lt;/character&gt;
      &lt;character id="Lucy"&gt;
        &lt;name&gt;
          Lucy
        &lt;/name&gt;
        &lt;born&gt;
          1952-03-03
        &lt;/born&gt;
        &lt;qualification&gt;
          bossy, crabby and selfish
        &lt;/qualification&gt;
      &lt;/character&gt;
    &lt;/characters&gt;
  &lt;/book&gt;
&lt;/library&gt;</pre></blockquote>

<p>This instance document defined by a full schema, which could be:</p>

<blockquote><pre class="code">&lt;?xml version="1.0"?&gt; 
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:element name="name" type="xs:token"/&gt;
  &lt;xs:element name="qualification" type="xs:token"/&gt;
  &lt;xs:element name="born" type="xs:date"/&gt;
  &lt;xs:element name="dead" type="xs:date"/&gt;
  &lt;xs:element name="isbn" type="xs:NMTOKEN"/&gt;
  &lt;xs:attribute name="id" type="xs:ID"/&gt;
  &lt;xs:attribute name="available" type="xs:boolean"/&gt;
  &lt;xs:attribute name="lang" type="xs:language"/&gt;
  &lt;xs:element name="title"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:token"&gt;
          &lt;xs:attribute ref="lang"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="library"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="book" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="authors"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="author"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:all&gt;
        &lt;xs:element ref="name"/&gt;
        &lt;xs:element ref="born"/&gt;
        &lt;xs:element ref="dead" minOccurs="0"/&gt;
      &lt;/xs:all&gt;
      &lt;xs:attribute ref="id"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="book"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:all&gt;
        &lt;xs:element ref="isbn"/&gt;
        &lt;xs:element ref="title"/&gt;
        &lt;xs:element ref="authors"/&gt;
        &lt;xs:element ref="characters"/&gt;
      &lt;/xs:all&gt;
      &lt;xs:attribute ref="id"/&gt;
      &lt;xs:attribute ref="available"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="characters"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt; 
        &lt;xs:element ref="character" minOccurs="0"
          maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="character"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:all&gt;
        &lt;xs:element ref="name"/&gt;
        &lt;xs:element ref="born"/&gt;
        &lt;xs:element ref="qualification"/&gt;
      &lt;/xs:all&gt;
      &lt;xs:attribute ref="id"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:schema&gt;</pre></blockquote>

<p>This adaptation of the instance document will be more painful if we
want to implement our alternative
"name" content model. Since we
cannot include a <tt class="literal">xs:choice</tt> in a <tt class="literal">xs:all</tt> compositor, we have to add a first level of
container, which is always the same, and a second level of container,
which contains only the choice that would lead to instance documents
such as:
</p>

<blockquote><pre class="code">&lt;?xml version="1.0"?&gt; 
&lt;library&gt;
  &lt;book id="b0836217462" available="true"&gt;
    &lt;title lang="en"&gt;
      Being a Dog Is a Full-Time Job
    &lt;/title&gt;
    &lt;isbn&gt;
      0836217462
    &lt;/isbn&gt;
    &lt;authors&gt;
      &lt;author id="CMS"&gt;
        &lt;born&gt;
          1922-11-26
        &lt;/born&gt;
        &lt;dead&gt;
          2000-02-12
        &lt;/dead&gt;
        &lt;name&gt;
          &lt;complex-name&gt;
            &lt;last-name&gt;
              Schulz
            &lt;/last-name&gt;
            &lt;first-name&gt;
              Charles
            &lt;/first-name&gt;
            &lt;middle-name&gt;
              M
            &lt;/middle-name&gt;
          &lt;/complex-name&gt;
        &lt;/name&gt;
      &lt;/author&gt;
    &lt;/authors&gt;
    &lt;characters&gt;
      &lt;character id="PP"&gt;
        &lt;name&gt;
          &lt;complex-name&gt;
            &lt;first-name&gt;
              Peppermint
            &lt;/first-name&gt;
            &lt;last-name&gt;
              Patty
            &lt;/last-name&gt;
          &lt;/complex-name&gt;
        &lt;/name&gt;
        &lt;qualification&gt;
          bold, brash and tomboyish
        &lt;/qualification&gt;
        &lt;born&gt;
          1966-08-22
        &lt;/born&gt;
      &lt;/character&gt;
      &lt;character id="Snoopy"&gt;
        &lt;born&gt;
          1950-10-04
        &lt;/born&gt;
        &lt;name&gt;
          &lt;simple-name&gt;
            Snoopy
          &lt;/simple-name&gt;
        &lt;/name&gt;
        &lt;qualification&gt;
          extroverted beagle
        &lt;/qualification&gt;
      &lt;/character&gt;
      &lt;character id="Schroeder"&gt;
        &lt;qualification&gt;
          brought classical music to the Peanuts strip
        &lt;/qualification&gt;
        &lt;name&gt;
          &lt;simple-name&gt;
            Schroeder
          &lt;/simple-name&gt;
        &lt;/name&gt;
        &lt;born&gt;
          1951-05-30
        &lt;/born&gt;
      &lt;/character&gt;
      &lt;character id="Lucy"&gt;
        &lt;name&gt;
          &lt;simple-name&gt;
            Lucy
          &lt;/simple-name&gt;
        &lt;/name&gt;
        &lt;born&gt;
          1952-03-03
        &lt;/born&gt;
        &lt;qualification&gt;
          bossy, crabby and selfish
        &lt;/qualification&gt;
      &lt;/character&gt;
    &lt;/characters&gt;
  &lt;/book&gt;
&lt;/library&gt;</pre></blockquote>

<p>The adaptation of the schema is then straightforward and could be
(keeping a flat design):
</p>

<blockquote><pre class="code">&lt;?xml version="1.0"?&gt; 
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:element name="simple-name" type="xs:token"/&gt;
  &lt;xs:element name="first-name" type="xs:token"/&gt;
  &lt;xs:element name="middle-name" type="xs:token"/&gt;
  &lt;xs:element name="last-name" type="xs:token"/&gt;
  &lt;xs:element name="qualification" type="xs:token"/&gt;
  &lt;xs:element name="born" type="xs:date"/&gt;
  &lt;xs:element name="dead" type="xs:date"/&gt;
  &lt;xs:element name="isbn" type="xs:NMTOKEN"/&gt;
  &lt;xs:attribute name="id" type="xs:ID"/&gt;
  &lt;xs:attribute name="available" type="xs:boolean"/&gt;
  &lt;xs:attribute name="lang" type="xs:language"/&gt;
  &lt;xs:element name="name"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:choice&gt;
        &lt;xs:element ref="simple-name"/&gt;
        &lt;xs:element ref="complex-name"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="complex-name"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:all&gt;
        &lt;xs:element ref="first-name"/&gt;
        &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
        &lt;xs:element ref="last-name"/&gt;
      &lt;/xs:all&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="title"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:token"&gt;
          &lt;xs:attribute ref="lang"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="library"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="book" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="authors"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="author"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:all&gt;
        &lt;xs:element ref="name"/&gt;
        &lt;xs:element ref="born"/&gt;
        &lt;xs:element ref="dead" minOccurs="0"/&gt;
      &lt;/xs:all&gt;
      &lt;xs:attribute ref="id"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="book"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:all&gt;
        &lt;xs:element ref="isbn"/&gt;
        &lt;xs:element ref="title"/&gt;
        &lt;xs:element ref="authors"/&gt;
        &lt;xs:element ref="characters"/&gt;
      &lt;/xs:all&gt;
      &lt;xs:attribute ref="id"/&gt;
      &lt;xs:attribute ref="available"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="characters"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt; 
        &lt;xs:element ref="character" minOccurs="0"
          maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="character"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:all&gt;
        &lt;xs:element ref="name"/&gt;
        &lt;xs:element ref="born"/&gt;
        &lt;xs:element ref="qualification"/&gt;
      &lt;/xs:all&gt;
      &lt;xs:attribute ref="id"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:schema&gt;</pre></blockquote>

<p>This process may be generalized and used for purposes other than
adapting instance documents to the constraints of <tt class="literal">xs:all</tt>. It is interesting to note that we have
"externalized" the complexity,
which was previously hidden from the instance document in the schema,
to bring the full structure of the content model into the instance
document itself. The choices and sequences (an element with multiple
occurrences is nothing more than an implicit sequence) are now
expressed through containers in the instance documents. Since the
structure is more apparent in the instance documents, it can be
considered more readable; some people find it a good practice to use
<a name="INDEX-577" />such
<a name="INDEX-578" />container. 
</p>

</div>

<a name="xmlschema-CHP-7-SECT-4.1.5.3" /><div class="sect4">
<h4 class="sect4">7.4.1.5.3. Using <tt class="literal">xs:choice</tt> instead of <tt class="literal">xs:all</tt></h4>

<p>When <a name="INDEX-579" />it <a name="INDEX-580" />is not possible or not practical to
adapt the structure of a document to the limitations of <tt class="literal">xs:all</tt>, another workaround that may be used is to
replace <tt class="literal">xs:all</tt> compositors by <tt class="literal">xs:choice</tt>, when possible. This trick is far less generic
than the adaptation of structures we just saw, and it may be
surprising that two compositors with a very different meaning could
be "interchanged." This applies
only when a loose control on the number of occurrences can be
applied, such as in a container that accepts both
<tt class="literal">author</tt> and <tt class="literal">character</tt> elements
in any order with any number of occurrences. Such a container can be
defined as:
</p>

<blockquote><pre class="code">&lt;xs:element name="persons"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="author"/&gt;
      &lt;xs:element ref="character"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>This definition has the same meaning as the following <tt class="literal">xs:all</tt> definition, which is forbidden:
</p>

<a name="INDEX-581" /><a name="INDEX-582" /><blockquote><pre class="code">&lt;xs:element name="persons"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:all&gt;
      &lt;xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/&gt; 
      &lt;xs:element ref="character" minOccurs="0"
        maxOccurs="unbounded"/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></blockquote>

</div>
</div>
</div>
<a name="xmlschema-CHP-7-SECT-4.2" /><div class="sect2">
<h3 class="sect2">7.4.2. Derivation of Complex Content</h3>

<p>Complex contents can also be derived, by extension or by restriction,
from complex types. Before we see the details of these mechanisms,
note that they are not symmetrical and their semantic is very
different. The derivation of a complex content by restriction is a
restriction of the set of matching instances. All the instance
structures that match the restricted complex type must also match the
base complex type. The derivation of a complex content by extension
of a complex type is an extension of the content model by addition of
new particles. A content that matches the base type does not
necessarily match the extended complex type. This also means that
there is no "roundtrip": in the
general case, neither a restricted complex type nor an extended type
can be extended or restricted back into its base type.
</p>

<a name="xmlschema-CHP-7-SECT-4.2.1" /><div class="sect3">
<h3 class="sect3">7.4.2.1. Derivation by extension</h3>

<p>Derivation <a name="INDEX-583" /> <a name="INDEX-584" />by
extension is similar to the extension of simple content complex
types. It is functionally very similar to joining groups of elements
and attributes to create a new complex type. The idea behind this
feature is to let people add new elements and attributes after those
already defined in the base type. This is virtually equivalent to
creating a sequence with the current content model followed by the
new content model. Let's go back to our library to
illustrate this. The content models of our elements
<tt class="literal">author</tt> and <tt class="literal">character</tt> are
relatively similar: <tt class="literal">author</tt> expects
<tt class="literal">name</tt>, <tt class="literal">born</tt>, and
<tt class="literal">dead</tt>, while <tt class="literal">character</tt> expects
<tt class="literal">name</tt>, <tt class="literal">born</tt>, and
<tt class="literal">qualification</tt>. If we want to use a derivation by
extension, we can first create a base type that contains the first
elements common to the content model of both elements:
</p>

<blockquote><pre class="code">&lt;xs:complexType name="basePerson"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:element ref="born"/&gt;
  &lt;/xs:sequence&gt;
  &lt;xs:attribute ref="id"/&gt;
&lt;/xs:complexType&gt;</pre></blockquote>

<p>It is then possible to use derivations by extension to append new
elements (<tt class="literal">dead</tt> for <tt class="literal">author</tt> and
<tt class="literal">qualification</tt> for <tt class="literal">character</tt>)
after those that have already been defined in the base type:
</p>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="basePerson"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="dead" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
             
&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="basePerson"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="qualification"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>Technically, the meaning of this derivation is equivalent to creating
a sequence containing the compositor used to define the base type as
well as the base type included in the <tt class="literal">xs:extension</tt>
element. Thus, the content models of these elements are similar to
the content models defined as:
</p>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="name"/&gt;
        &lt;xs:element ref="born"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="dead" minOccurs="0"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
             
&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="name"/&gt;
        &lt;xs:element ref="born"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="qualification"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>This equivalence clearly shows the feature of this derivation
mechanism. As stated in the introduction of complex content
derivation mechanisms, this is not an extension of the set of valid
instance structures. An element <tt class="literal">character</tt>, with
its mandatory <tt class="literal">qualification</tt>, cannot have a valid
<tt class="literal">basePerson</tt> content model but rather the merge of
two content models. This merge itself is subject to limitations: you
cannot choose the point where the new content model is inserted; this
addition is always done by appending the new compositor after the one
of the base type. In our example, if the common elements
<tt class="literal">name</tt> and <tt class="literal">born</tt> were not the
first two elements, we couldn't have used a
derivation by extension.
</p>

<p>Another caveat in derivations by extension is we
can't choose the compositor that is used to merge
the two content models. This means that when we derive content models
<a name="INDEX-585" />using <tt class="literal">xs:choice</tt>
as compositors, it is not the scope of the choices that is extended,
but rather the choices that are included in a <tt class="literal">xs:sequence</tt>. We could, for instance, extend the content
model of the element <tt class="literal">persons</tt>, which we just
created and which could be defined as a global complex type:
</p>

<blockquote><pre class="code">&lt;xs:complexType name="basePersons"&gt;
  &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
    &lt;xs:element ref="author"/&gt;
    &lt;xs:element ref="character"/&gt;
  &lt;/xs:choice&gt;
&lt;/xs:complexType&gt;</pre></blockquote>

<p>If we add a new element using a derivation by extension:</p>

<blockquote><pre class="code">&lt;xs:complexType name="persons"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="basePersons"&gt;
      &lt;xs:sequence&gt; 
        &lt;xs:element name="editor" type="xs:token" minOccurs="0"
          maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;</pre></blockquote>

<p>The result is a content type that is equivalent to:</p>

<blockquote><pre class="code">&lt;xs:complexType name="personsEquivalent"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="author"/&gt;
      &lt;xs:element ref="character"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:sequence&gt; 
      &lt;xs:element name="editor" type="xs:token" minOccurs="0"
        maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;</pre></blockquote>

<p>There is no way to obtain an extension of the <tt class="literal">xs:choice</tt> such as:
</p>

<blockquote><pre class="code">&lt;xs:complexType name="personsAsWeWouldHaveLiked"&gt;
  &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
    &lt;xs:element ref="author"/&gt;
    &lt;xs:element ref="character"/&gt;
    &lt;xs:element name="editor" type="xs:token"/&gt;
  &lt;/xs:choice&gt;
&lt;/xs:complexType&gt;</pre></blockquote>

<p>The situation with <tt class="literal">xs:all</tt> is even worse: the
restrictions on the composition of <tt class="literal">xs:all</tt> still
apply. This means you can't add any content to a
complex type defined with a <tt class="literal">xs:all</tt>--although you can still add new
attributes--and also you can only use a <tt class="literal">xs:all</tt> compositor in a derivation by extension if the
base type has an empty content <a name="INDEX-586" /> <a name="INDEX-587" />model. 
</p>

</div>

<a name="xmlschema-CHP-7-SECT-4.2.2" /><div class="sect3">
<h3 class="sect3">7.4.2.2. Derivation by restriction</h3>

<p>Whereas <a name="INDEX-588" /> <a name="INDEX-589" />derivation by extension is similar to
merging two content models through a <tt class="literal">xs:sequence</tt>
compositor, derivation by restriction is a restriction of the number
of instance structures matching the complex type. In this respect, it
is similar to the derivation by restriction of simple datatypes or
simple content complex types (even though we've seen
that a facet such as <tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt>
expanded the number of instance documents matching a simple type).
Note that this is the only similarity between derivations by
restriction of simple and complex datatypes. This is highly
confusing, since W3C XML Schema uses the same word and even the same
element name in both cases, but these words have a different meaning
and the content models of the <tt class="literal">xs:restriction</tt> elements
are different.
</p>

<p>Unlike simple type derivation, there are no facets to apply to
complex types, and the derivation is done by defining the full
content model of the derived datatype, which must be a logical
restriction of the base type. Any instance structure valid per the
derived datatype must also be valid per the base datatype. The W3C
XML Schema specification does not define the derivation by
restriction in these terms, but defines a formal algorithm to be
followed by schema processors, which is roughly equivalent.
</p>

<p>The derivation by restriction of a complex type is a declaration of
intention that the derived type is a subset of the base type. (Rather
than a derivation we've seen for simple types, this
declaration is needed for features allowing substitutions and
redefinitions of types, which we will see in <a href="ch08_01.htm">Chapter 8, "Creating Building Blocks"</a> and <a href="ch12_01.htm">Chapter 12, "Creating More Building Blocks Using Object-Oriented Features"</a> and which may
provide useful information used by some applications.) When we derive
simple types, we can take a base type without having to care about
the details of the facets that are already applied, and just add our
own set of facets. Here, on the contrary, we need to provide a full
definition of a content model, except for attributes that can be
declared as "prohibited" to be
excluded from the restriction, something we have seen for the
restriction of complex types with simple contents.
</p>

<p>Moving on, let's try to find a base from which we
can derive both the <tt class="literal">author</tt> and
<tt class="literal">character</tt> elements by restriction. This time, we
can be sure that such a complex type exists since all the complex
types can be derived from an abstract <tt class="literal">xs:anyType</tt>,
allowing any elements and attributes. In practice, however, we will
try to find the most restrictive base type that can accommodate our
needs. Since the <tt class="literal">name</tt> and <tt class="literal">born</tt>
elements are present in both <tt class="literal">author</tt> and
<tt class="literal">character</tt>, with the same number of occurrences, we
can keep them as they appear. We then have two elements
(<tt class="literal">dead</tt> and <tt class="literal">qualification</tt>, which
appear only in one of the two elements <tt class="literal">author</tt> and
<tt class="literal">character</tt>). Since both <tt class="literal">author</tt>
and <tt class="literal">character</tt> will need to be valid per the base
type, we will take both of them in the base type but make them
optional by giving them a <tt class="literal">minOccurs</tt> attribute
equal to 0. Our base type can then be:
</p>

<blockquote><pre class="code">&lt;xs:complexType name="person"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:element ref="born"/&gt;
    &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;xs:element ref="qualification" minOccurs="0"/&gt;
  &lt;/xs:sequence&gt;
  &lt;xs:attribute ref="id"/&gt;
&lt;/xs:complexType&gt;</pre></blockquote>

<p>The derivations are then done by defining the content model within a
<tt class="literal">xs:restriction</tt>  element (note that we have not
repeated the attribute declarations which are not modified):
</p>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="person"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="name"/&gt;
          &lt;xs:element ref="born"/&gt;
          &lt;xs:element ref="dead" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
             
&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="person"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="name"/&gt;
          &lt;xs:element ref="born"/&gt;
          &lt;xs:element ref="qualification"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>We see here that the syntax of a derivation by restriction is more
verbose than the syntax of the straight definition of the content
model. The purpose of this derivation is not to build modular
schemas, but rather to give applications that use this schema the
indication that there is some commonality between the content models,
and if they know how to handle the complex type
"person," they can handle the
elements <tt class="literal">author</tt> and <tt class="literal">character</tt>.
We will see W3C XML Schema features that rely on this derivation
method in <a href="ch08_01.htm">Chapter 8, "Creating Building Blocks"</a> and <a href="ch12_01.htm">Chapter 12, "Creating More Building Blocks Using Object-Oriented Features"</a>. 
</p>

<p>Changing the number of occurrences of particles is not the only
modification that can be done during a derivation by restriction.
Other operations that result in a reduction of the number of valid
instance structures are also possible, such as changing a simple type
to a more restrictive one or fixing values. The main constraint in
this mechanism is that each particle of the derived type must be an
explicit derivation of the corresponding particle of the base type.
The effect of this statement is to limit the
"depth" of the restrictions that
can be performed in a single step, and when we need to restrict
particles at a deeper level of imbrication, we may have to transform
local definitions into global ones. We will see a concrete example in
<a href="ch07_05.htm">Section 7.5.1, "Creating Mixed Content Models"</a>, which are similar in this
<a name="INDEX-590" />
<a name="INDEX-591" />respect.
</p>

</div>

<a name="xmlschema-CHP-7-SECT-4.2.3" /><div class="sect3">
<h3 class="sect3">7.4.2.3. Asymmetry of these two methods</h3>

<p>We <a name="INDEX-592" /> <a name="INDEX-593" />now
have all the elements we need to look back at the claim about the
asymmetry of these derivation methods. This lack of symmetry is not a
defect as such, but studying it is a good exercise to understanding
the meaning of these two derivation methods. Let's
examine the derivation by extension of <tt class="literal">basePerson</tt>
into the <tt class="literal">character</tt> element:
</p>

<blockquote><pre class="code">&lt;xs:complexType name="basePerson"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:element ref="born"/&gt;
  &lt;/xs:sequence&gt;
  &lt;xs:attribute ref="id"/&gt;
&lt;/xs:complexType&gt;
             
&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="basePerson"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="qualification"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>The content model of <tt class="literal">character</tt> contains a
mandatory <tt class="literal">qualification</tt> element. Valid characters
are not valid per <tt class="literal">basePerson</tt>; thus, there is no
hope to be able to derive character back into
<tt class="literal">basePerson</tt> by restriction, since all the instance
structures that are valid per the derived type must be valid per the
base type in a derivation by restriction.
</p>

<p>Let's look back at the derivation by restriction of
the <tt class="literal">person</tt> base type into a
<tt class="literal">character</tt> element:
</p>

<blockquote><pre class="code">&lt;xs:complexType name="person"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:element ref="born"/&gt;
    &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;xs:element ref="qualification" minOccurs="0"/&gt;
  &lt;/xs:sequence&gt;
  &lt;xs:attribute ref="id"/&gt;
&lt;/xs:complexType&gt;
             
&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="person"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="name"/&gt;
          &lt;xs:element ref="born"/&gt;
          &lt;xs:element ref="qualification"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>

<p>Again, it is not possible to derive the complex type of
<tt class="literal">character</tt> into <tt class="literal">person</tt>, since it
means changing the number of minimum occurrences of
<tt class="literal">qualification</tt> from 1 to 0 and adding an optional
<tt class="literal">dead</tt> element between <tt class="literal">born</tt> and
<tt class="literal">qualification</tt>. None of these operations are
possible during a derivation by extension, which can only append new
content after the content of the base type, and
can't update an existing particle (to change the
number of occurrences) nor insert a new particle between two
<a name="INDEX-594" />
<a name="INDEX-595" />existing
particles.
</p>

</div>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch07_03.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch07_05.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">7.3. Simple Content Models</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">7.5. Mixed Content Models</td></tr></table></div>
<hr width="684" align="left" />

<img src="../gifs/navbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
</map>

</body></html>