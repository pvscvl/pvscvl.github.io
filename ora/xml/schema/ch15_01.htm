<html><head><title>Elements Reference Guide (XML Schema)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Eric van der Vlist" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596002521L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="XML Schema" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="XML Schema" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch14_05.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch16_01.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>


<h1 class="chapter">Chapter 15. Elements Reference Guide</h1>
<div class="htmltoc"><h4 class="tochead">Contents:</h4><p>
<a href="ch15_01.htm">Datatypes</a><br /></p></div>

<p>This chapter provides a quick reference to all of the <a name="INDEX-1049" /> <a name="INDEX-1050" />elements W3C XML Schema uses to define
components of XML Schemas. Some elements can be defined simply, while
others require multiple entries reflecting usage in different
contexts. If an element name is followed by a parenthetical phrase,
you may want to examine following entries to determine which context
is most appropriate for your use.
</p>
<div class="sect1"><a name="xmlschema-CHP-15-SECT-1" />
<h2 class="sect1">15.1. Datatypes</h2>

<a name="ch15-27059" /><a name="INDEX-1051" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:all(outside a group)</b></font></td><td align="right"><i>Compositor describing an unordered group of elements.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:all
           id                 = xs:ID
           maxOccurs          = "1" : "1"
           minOccurs          = ( "0" | "1" ) : "1"
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, xs:element*)
&lt;/xs:all&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:complexType (local definition), xs:complexType
(global definition), xs:extension (complex content), xs:restriction
(complex content)
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:all</tt> is used to describe an unordered group of
elements whose number of occurences may be zero or one.
</p>


<h4 class="refsect1">Restrictions</h4>


<p><tt class="literal">xs:all</tt> is the only compositor that cannot be used
as a particle and needs to be used by itself to describe a complete
content model. Unlike <tt class="literal">xs:choice</tt> and
<tt class="literal">xs:sequence</tt>, <tt class="literal">xs:all</tt> cannot be
embedded within another compositor. It can, thus, only be embedded
directly into an <tt class="literal">xs:complexType</tt>,
<tt class="literal">xs:restriction</tt>, or
<tt class="literal">xs:extension</tt>; furthermore, its number of
occurrences may be only zero or one.
</p>

<p>The particles included in <tt class="literal">xs:all</tt> are also limited:
they can only be <tt class="literal">xs:element</tt> and their number of
occurrences can only be zero or one.
</p>

<p>Combining these two restrictions means <tt class="literal">xs:all</tt> may
only be used to describe content models in which a group of unordered
elements (mandatory or optional, but with a number of occurrences not
greater than one) are the only child elements.
</p>

<p>Situations describing unordered groups of optional elements that have
the same number of maximum occurrences can be described using
<tt class="literal">xs:choice</tt> or substitution groups, but other
content models (such as groups of unordered elements with arbitrary
and different maximum numbers of occurrences) cannot be described
with W3C XML Schema.
</p>

<p>Complex types defined using an <tt class="literal">xs:all</tt> compositor
cannot be derived by extension.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:all&gt;
      &lt;xs:element ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
             

&lt;xs:element name="full-name" substitutionGroup="name"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:all&gt;
      &lt;xs:element name="first" type="string32" minOccurs="0"/&gt;
      &lt;xs:element name="middle" type="string32" minOccurs="0"/&gt;
      &lt;xs:element name="last" type="string32"/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">maxOccurs</tt></dt>
<dd>
Maximum number of occurrences. Note that this value is fixed to one.</p>
</dd>


<dt><tt class="literal">minOccurs</tt></dt>
<dd>
Minimum number of occurrences. Note that this value can be only zero
or one.
</p>
</dd>

</dl>

</div>

<a name="ch15-77017" /><a name="INDEX-1052" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:all(within a group)</b></font></td><td align="right"><i>Compositor describing an unordered group of elements. The number of occurrences cannot be defined when xs:all is used within a group.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:all           
           id          = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, xs:element*)
&lt;/xs:all&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:group (definition)</p>
<h4 class="refsect1">Description</h4>


<p>Used within a group, <tt class="literal">xs:all</tt> has the same meaning
as when it is used directly under <tt class="literal">xs:complexType</tt>,
except that the <tt class="literal">minOccurs</tt> and
<tt class="literal">maxOccurs</tt> attributes have completely disappeared
(i.e., it cannot be marked as optional).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The restrictions that apply to <tt class="literal">xs:all</tt> apply to the
group embedding the <tt class="literal">xs:all</tt> compositor. This group
cannot have a number of occurrences greater than one and cannot be
used as a particle. It must be included directly under
<tt class="literal">xs:complexType</tt>, <tt class="literal">xs:restriction</tt>,
or <tt class="literal">xs:extension</tt>.
</p>

<p>All other restrictions of <tt class="literal">xs:all</tt> apply here.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:group name="authorSubElements"&gt;
  &lt;xs:all&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:element ref="born"/&gt;
    &lt;xs:element ref="dead" minOccurs="0"/&gt;
  &lt;/xs:all&gt;
&lt;/xs:group&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77024" /><a name="INDEX-1053" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:annotation</b></font></td><td align="right"><i>Informative data for human or electronic agents.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:annotation
           id          = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:appinfo | xs:documentation)*
&lt;/xs:annotation&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:all (outside a group), xs:all (within a
group), xs:any, xs:anyAttribute, xs:attribute (reference or local
definition), xs:attribute (global definition), xs:attributeGroup
(reference), xs:attributeGroup (global definition), xs:choice
(outside a group), xs:choice (within a group), xs:complexContent,
xs:complexType (local definition), xs:complexType (global
definition), xs:element (within xs:all), xs:element (reference or
local definition), xs:element (global definition), xs:enumeration,
xs:extension (complex content), xs:extension (simple content),
xs:field, xs:fractionDigits, xs:group (reference), xs:group
(definition), xs:import, xs:include, xs:key, xs:keyref, xs:length,
xs:list, xs:maxExclusive, xs:maxInclusive, xs:maxLength,
xs:minExclusive, xs:minInclusive, xs:minLength, xs:notation,
xs:pattern, xs:redefine, xs:restriction (complex content),
xs:restriction (simple type), xs:restriction (simple content),
xs:schema, xs:selector, xs:sequence (within a group), xs:sequence
(outside a group), xs:simpleContent, xs:simpleType (local
definition), xs:simpleType (global definition), xs:totalDigits,
xs:union, xs:unique, xs:whiteSpace
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:annotation</tt> is a container in which additional
information can be embedded, either for human consumption (with
<tt class="literal">xs:documentation</tt>) or for programs
(<tt class="literal">xs:appinfo</tt>). <tt class="literal">xs:annotation</tt> can
be added as a first element in almost any W3C XML Schema element. It
can also be included anywhere as a top-level element (directly under
<tt class="literal">xs:schema</tt>).
</p>


<h4 class="refsect1">Restrictions</h4>


<p><tt class="literal">xs:annotation</tt> cannot be included within itself.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="author" type="author"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation xml:lang="en"&gt;
      The author of a book.
    &lt;/xs:documentation&gt;
    &lt;xs:documentation xml:lang="fr"&gt;
      Designe l'auteur d'un livre.
    &lt;/xs:documentation&gt;
    &lt;xs:appinfo xmlns:sch="http://www.ascc.net/xml/schematron"&gt;
      &lt;sch:pattern name="Born before dead"&gt;
        &lt;sch:rule context="author"&gt; 
          &lt;sch:assert test="not(dead) or (dead &gt; born)"
            diagnostics="bornAfterDead"&gt;
            An author should die after her or his death.
          &lt;/sch:assert&gt;
          &lt;sch:diagnostics&gt;
            &lt;sch:diagnostic id="bornAfterDead"&gt; 
              Error, this author is born after her or his birth!
              Author=
              &lt;sch:value-of select="name"/&gt;
              Birth =
              &lt;sch:value-of select="born"/&gt;
              Death =
              &lt;sch:value-of select="dead"/&gt;
            &lt;/sch:diagnostic&gt;
          &lt;/sch:diagnostics&gt;
        &lt;/sch:rule&gt;
      &lt;/sch:pattern&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-41992" /><a name="INDEX-1054" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:any</b></font></td><td align="right"><i>Wildcard to replace any element.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:any
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs          = xs:nonNegativeInteger : "1"
           namespace          = ( ( "##any" | "##other" ) | list of ( xs:anyURI | (
                                   "##targetNamespace" | "##local" ) ) ) : "##any"
           processContents    = ( "skip" | "lax" | "strict" ) : "strict"
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:any&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:choice (outside a group), xs:choice (within a
group), xs:sequence (within a group), xs:sequence (outside a group)
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:any</tt> is a wildcard that allows the insertion of
any element belonging to a list of namespaces. This particle can be
used like <tt class="literal">xs:element</tt> within choices
(<tt class="literal">xs:choice</tt>) and sequences
(<tt class="literal">xs:sequence</tt>), and the number of occurrences of
the elements that are allowed can be controlled by its
<tt class="literal">minOccurs</tt> and <tt class="literal">maxOccurs</tt>
attributes.
</p>

<p>The list of permitted namespaces is specified though the
<tt class="literal">namespace</tt> attribute. The
<tt class="literal">namespace</tt> attribute expects a list of namespace
URIs. In this list, two values have a specific meaning:
<tt class="literal">##targetNamespace</tt> stands for the target namespace,
and <tt class="literal">##local</tt> stands for local elements (without
namespaces). These values can be mixed in the list with regular
namespaces URIs. The whole list may also be replaced by two other
special values: <tt class="literal">##any</tt> stands for any namespace at
all and is the default value for the <tt class="literal">namespace</tt>
attribute, and <tt class="literal">##other</tt> stands for any namespace
other than the target namespace. When <tt class="literal">##other</tt> is
used in a schema without a target namespace, all the namespaces are
allowed and only elements without namespaces are forbidden.
</p>

<p>The target namespace used to evaluate the special values
<tt class="literal">##targetNamespace</tt> and <tt class="literal">##other</tt>
is the target namespace (or lack of target namespace) of the schema
in which the <tt class="literal">xs:any</tt> wildcard is found. This
doesn't change when one schema is imported into
another.
</p>

<p>The behavior of the validator regarding the elements that will be
allowed and their children can be specified using the
<tt class="literal">processContent</tt> attribute. When
<tt class="literal">processContent</tt> is set to <tt class="literal">strict</tt>
(i.e., the default values), the schema processors must validate these
elements against their schemas and report an error if they are not
valid or if it hasn't been able to fetch the schemas
for their namespaces. When set to <tt class="literal">skip</tt>, the
processors do not attempt to validate these elements. When set to
<tt class="literal">lax</tt>, the validator validates the elements if it
can find a definition for them, and skips them if it
can't.
</p>

<p>When the <tt class="literal">processContent</tt> is <tt class="literal">skip</tt>
(or when it is <tt class="literal">lax</tt> and the schema processor
hasn't been able to locate a schema for an element,
which is equivalent), the processor skips any further validation of
the elements accepted that may have any content type. The processor
eventually includes attributes and subelements of any namespace
regardless of the value of the namespace attribute.
</p>

<p>When the <tt class="literal">processContent</tt> is
<tt class="literal">strict</tt> (or when it is <tt class="literal">lax</tt> and
the schema validator has found a schema for them, which is
equivalent), the elements that are accepted for the wildcard need to
be defined as global elements in the schema for this namespace or
have a valid datatype associated in the instance document through
<tt class="literal">xsi:type</tt> attribute.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Some combinations of specifications of namespaces that are useful to
define multi-namespaces open vocabularies are missing. These are the
cases of "any namespace known in the current
validation context" and its complementary
"any namespace not defined in the current validation
context."
</p>

<p>The usual restrictions for nondeterministic content models apply to
wildcards. While trying to track the risks of or reasons for a
nondeterministic content model, pay attention to the value of the
<tt class="literal">processContent</tt> attribute. Possible conflict may
occur with any element declared as global in one of the permitted
namespaces if <tt class="literal">processContent</tt> is
<tt class="literal">strict</tt>, and it may occur with any element (global
or local) if <tt class="literal">processContent</tt> is
<tt class="literal">skip</tt>.
</p>

<p>The behavior of the special value <tt class="literal">##other</tt> on
unqualified elements in schemas with target namespaces is
contradictory in the W3C XML Schema Recommentation and should be
clarified in a future addendum. The most likely interpretation is
unqualified elements are not allowed when <tt class="literal">##other</tt>
is specified in these schemas, even though a passage of the
Recommendation states the contrary.
</p>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">maxOccurs</tt></dt>
<dd>
Maximum number of elements permitted for this wildcard.</p>
</dd>


<dt><tt class="literal">minOccurs</tt></dt>
<dd>
Minimum number of elements permitted for this wildcard.</p>
</dd>


<dt><tt class="literal">namespace</tt></dt>
<dd>
Permitted namespaces.</p>
</dd>


<dt><tt class="literal">processContents</tt></dt>
<dd>
Type of validation required on the elements permitted for this
wildcard.
</p>
</dd>

</dl>

</div>

<a name="ch15-77046" /><a name="INDEX-1055" /><a name="INDEX-1056" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:anyAttribute</b></font></td><td align="right"><i>Wildcard to replace any attribute.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:anyAttribute
           id                 = xs:ID
           namespace          = ( ( "##any" | "##other" ) | list of ( xs:anyURI | (
                                   "##targetNamespace" | "##local" ) ) ) : "##any"
           processContents    = ( "skip" | "lax" | "strict" ) : "strict"
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:anyAttribute&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:attributeGroup (global definition),
xs:complexType (local definition), xs:complexType (global
definition), xs:extension (complex content), xs:extension (simple
content), xs:restriction (complex content), xs:restriction (simple
content)
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:anyAttribute</tt> is a wildcard that allows the
insertion of any attribute belonging to a list of namespaces. This
particle must be used wherever an attribute local declaration of
reference can be used (i.e., within <tt class="literal">complexType</tt> or
<tt class="literal">attributeGroup</tt> definitions).
</p>

<p>The list of permitted namespaces is specified though the
<tt class="literal">namespace</tt> attribute. The
<tt class="literal">namespace</tt> attribute expects a list of namespace
URIs. In this list, two values have a specific meaning:
<tt class="literal">##targetNamespace</tt> stands for the target namespace,
and <tt class="literal">##local</tt> stands for local attributes (without
namespaces). These values can be mixed in the list with regular
namespaces URIs. The whole list may also be replaced by two other
special values: <tt class="literal">##any</tt> stands for any namespace at
all and is the default value for the <tt class="literal">namespace</tt>
attribute and <tt class="literal">##other</tt> stands for any namespace
other than the target namespace. When <tt class="literal">##other</tt> is
used in a schema without a target namespace, all the namespaces are
allowed and only attributes without namespaces are forbidden.
</p>

<p>The target namespace used to evaluate the special values
<tt class="literal">##targetNamespace</tt> and <tt class="literal">##other</tt>
is the target namespace (or lack of target namespace) of the schema
in which the <tt class="literal">xs:anyAttribute</tt> wildcard is found.
This doesn't change when one schema is imported into
another.
</p>

<p>The behavior of the validator regarding the attributes that will be
allowed can be specified using the <tt class="literal">processContent</tt>
attribute. When <tt class="literal">processContent</tt> is set to
<tt class="literal">strict</tt> (i.e., the default values), the schema
processors must validate these attributes against their schemas and
report an error if they are not valid or if it
hasn't been able to fetch the schemas for their
namespaces. When set to <tt class="literal">skip</tt>, the processors do
not attempt to validate these attributes. When set to
<tt class="literal">lax</tt>, the validator validates the attributes if it
can find a definition for them, and skips them if it
can't.
</p>

<p>When the <tt class="literal">processContent</tt> is <tt class="literal">skip</tt>
(or when it is <tt class="literal">lax</tt> and the schema processor
hasn't been able to locate a schema for an
attribute, which is equivalent), the processor skips any further
validation of the accepted attributes that may belong to any
datatype.
</p>

<p>When the <tt class="literal">processContent</tt> is
<tt class="literal">strict</tt> (or when it is <tt class="literal">lax</tt> and
the schema validator has found a schema for them, which is
equivalent), the accepted attributes for the wildcard need to be
defined as global attributes in the schema for this namespace.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Some combinations of specifications of namespaces used to define
multi-namespace open vocabularies are missing. These include the
cases of "any namespace known in the current
validation context" and its complementary
"any namespace not defined in the current validation
context."
</p>

<p>The behavior of the special value <tt class="literal">##other</tt> on
unqualified attributes in schemas with target namespaces is
contradictory in the W3C XML Schema Recommentation and should be
clarified in a future addendum. The most likely interpretation is
that unqualified attributes are not allowed when
<tt class="literal">##other</tt> is specified in these schemas, even though
a passage of the Recommendation states the contrary.
</p>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">namespace</tt></dt>
<dd>
Permitted namespaces.</p>
</dd>


<dt><tt class="literal">processContents</tt></dt>
<dd>
Type of validation required on the elements permitted for this
<a name="INDEX-1056" />wildcard. 
</p>
</dd>

</dl>

</div>

<a name="ch15-77057" /><a name="INDEX-1057" /><a name="INDEX-1058" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:appinfo</b></font></td><td align="right"><i>Information for applications.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:appinfo
           source          = xs:anyURI
           &gt;
           Content: ({any})*
&lt;/xs:appinfo&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:annotation</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:appinfo</tt> is a container that embeds structured
information that can be used by applications. Its content model is
open and can accept any element from any namespace (with a
<tt class="literal">lax</tt> validation; W3C XML Schema elements included
here must be valid). <tt class="literal">xs:appinfo</tt> can be used to
include any kind of information, such as metadata, processing
directives, or even code snippets.
</p>

<p>Its content is similar to <tt class="literal">xs:documentation</tt> (which
is reserved for human-readable information), except for an
<tt class="literal">xml:lang</tt> attribute (which is allowed in
<tt class="literal">xs:documentation</tt> but forbidden for
<tt class="literal">xs:appinfo</tt>).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Foreign attributes cannot be included in
<tt class="literal">xs:appinfo</tt>.
</p>

<p>The <tt class="literal">source</tt> attribute is underspecified in the
Recommendation, which could lead to interoperability issues between
applications relying on <tt class="literal">xs:appinfo</tt> if they use
relative or shared URIs. For instance, one application may decide to
use the XSLT namespace in the <tt class="literal">source</tt> attribute to
indicate an XSLT snippet while another application could use the same
URI to indicate a set of parameters to pass to an XSLT
transformation.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="author" type="author"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:appinfo xmlns:dc="http://purl.org/dc/elements/1.1/"&gt;
      &lt;dc:creator&gt;
        Eric van der Vlist (mailto:vdv@dyomedea.com)
      &lt;/dc:creator&gt;
      &lt;dc:date&gt;
        2002-02-01
      &lt;/dc:date&gt;
      &lt;dc:subject&gt;
        author,person,book
      &lt;/dc:subject&gt;
      &lt;dc:description&gt;
        This element describes the author of a book.
      &lt;/dc:description&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
             

&lt;xs:element name="author" type="author"&gt;
  &lt;xs:annotation&gt; 
    &lt;xs:appinfo source="saf:meta-data-item"
      xmlns:sql="http://www.extensibility.com/saf/spec/safsample/sql-map.saf"
      &gt;
      &lt;sql:select&gt;
        select
        &lt;sql:elem&gt;
          name
        &lt;/sql:elem&gt;
        ,
        &lt;sql:elem&gt;
          birthdate
        &lt;/sql:elem&gt;
        ,
        &lt;sql:attr&gt;
          deathdate
        &lt;/sql:attr&gt;
        from tbl_author
      &lt;/sql:select&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;
             

&lt;xs:element name="book" type="book"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:appinfo xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
      &lt;xsl:template match="book"&gt;
        &lt;xsl:apply-templates select="title"/&gt;
        &lt;xsl:apply-templates select="isbn"/&gt;
        &lt;p&gt;
          Authors:
        &lt;/p&gt;
        &lt;ul&gt;
          &lt;xsl:apply-templates select="author"/&gt;
        &lt;/ul&gt;
        &lt;p&gt;
          Characters:
        &lt;/p&gt;
        &lt;ul&gt;
          &lt;xsl:apply-templates select="character"/&gt;
        &lt;/ul&gt;
      &lt;/xsl:template&gt;
    &lt;/xs:appinfo&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">source</tt></dt>
<dd>
Can be used to provide a link to the source of the information when a
snippet is included, or as a semantic attribute to qualify the type
of information that is <a name="INDEX-1058" />included. 
</p>
</dd>

</dl>

</div>

<a name="ch15-77064" /><a name="INDEX-1059" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:attribute(global definition)</b></font></td><td align="right"><i>Global attribute definition that can be referenced within the same schema by other schemas.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:attribute
           default        = xs:string
           fixed          = xs:string
           id             = xs:ID
           name           = xs:NCName
           type           = xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, xs:simpleType?)
&lt;/xs:attribute&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:schema</p>
<h4 class="refsect1">Description</h4>


<p>All the attributes defined at the top level of a schema (i.e.,
<tt class="literal">xs:attribute</tt>, which is included directly under the
<tt class="literal">xs:schema</tt> document element) are considered
globally defined.
</p>

<p>Globally defined attributes have a global scope: they can be
referenced through their qualified name everywhere in the schema in
which they are defined as well as in any schema that imports or
includes this schema.
</p>

<p>Attributes are identified by their qualified name, but the local name
is expected in the <tt class="literal">name</tt> attribute.
</p>

<p>The definition is done by assigning a simple datatype to the element.
This assignment can be done either by reference, using the
<tt class="literal">type</tt> attribute to refer to a simple datatype by
its qualified name, or "inline," by
embedding the definition of the simple type
(<tt class="literal">xs:simpleType</tt> element) within the
<tt class="literal">xs:attribute</tt> element.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>When a target namespace is defined, global attributes must be defined
as qualified, i.e., they must be prefixed in the instance documents.
Since most of the XML vocabularies do not prefix attributes except
when they are "foreign attributes"
immersed in elements from other namespaces, this means that global
attributes are seldom used when a target namespace is defined. To
work around this restriction, attribute groups
(<tt class="literal">xs:attributeGroup</tt>) can be used to embed
definitions of unqualified attributes that need to be included within
multiple complex type definitions.
</p>

<p>The identification of the global attributes by their qualified names
makes it impossible to globally define multiple attributes having the
same qualified name. When a schema must include multiple definitions
of attributes that have the same qualified names (and different
datatypes), all the definitions (except one) must be locally
declared. In this case, it is possible to use simple types or
attribute groups instead of global attributes to define reusable
content models.
</p>

<p>All the globally defined attributes must be qualified if a target
namespace is defined for the schema--they must all belong to the
target namespace. When no target namespace is defined, all the
attributes that are globally or locally defined must be unqualified.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:attribute name="id" type="xs:ID"/&gt;
  &lt;xs:attribute name="available" type="xs:boolean"/&gt;
  &lt;xs:attribute name="lang" type="xs:language"/&gt;
  .../...
&lt;/xs:schema&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">default</tt></dt>
<dd>
Default value. When specified, an attribute is added by the schema
processor (if it is missing from the instance document) and it is
given this value. The <tt class="literal">default</tt> and
<tt class="literal">fixed</tt> attributes are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">fixed</tt></dt>
<dd>
When specified, the value of the attribute is fixed and must be equal
to the value specified here. The <tt class="literal">default</tt> and
<tt class="literal">fixed</tt> attributes are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Local name of the attribute (without namespace prefix).</p>
</dd>


<dt><tt class="literal">type</tt></dt>
<dd>
Qualified name of a simple type of the attribute (must be omitted
when a simple type definition is embedded).
</p>
</dd>

</dl>

</div>

<a name="ch15-77079" /><a name="INDEX-1060" /><a name="INDEX-1061" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:attribute(reference or local definition)</b></font></td><td align="right"><i>Reference to a global attribute definition or local definition (local definitions cannot be referenced).
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:attribute
           default        = xs:string
           fixed          = xs:string
           form           = ( "qualified" | "unqualified" )
           id             = xs:ID
           name           = xs:NCName
           ref            = xs:QName
           type           = xs:QName
           use            = ( "prohibited" | "optional" | "required" ) : "optional"
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:simpleType?))
&lt;/xs:attribute&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:attributeGroup (global definition),
xs:complexType (local definition), xs:complexType (global
definition), xs:extension (complex content), xs:extension (simple
content), xs:restriction (complex content), xs:restriction (simple
content)
</p>
<h4 class="refsect1">Description</h4>


<p>This element serves two different purposes and has two different
content models for these two purposes: it can either be a reference
to a globally defined attribute or it can be a local attribute
definition. These options are mutually exclusive.
</p>

<p>When used as a reference to an attribute, the <tt class="literal">ref</tt>
attribute must contain the qualified name of the attribute (with its
namespace prefix).
</p>

<p>When used as a local definition, the definition is done by assigning
a simple datatype to the attribute. This assignment can be done
either by reference, using the <tt class="literal">type</tt> attribute to
refer to a simple datatype by its qualified name, or inline, by
embedding the definition of the simple type
(<tt class="literal">xs:simpleType</tt> element) within the
<tt class="literal">xs:attribute</tt> element.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Locally defined attributes cannot be referenced.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:complexType&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base="xs:string"&gt;
      &lt;xs:attribute ref="lang"/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
              .../...
       

&lt;xs:simpleContent&gt;
  &lt;xs:extension base="xs:string"&gt;
    &lt;xs:attribute name="lang" type="xs:language"/&gt;
  &lt;/xs:extension&gt;
&lt;/xs:simpleContent&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">default</tt></dt>
<dd>
Default value. When specified, an attribute is added by the schema
processor, if missing from the instance document, and is given this
value. The <tt class="literal">default</tt> and <tt class="literal">fixed</tt>
attributes are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">fixed</tt></dt>
<dd>
When specified, the value of the attribute is fixed and must be equal
to the value specified here. The <tt class="literal">default</tt> and
<tt class="literal">fixed</tt> attributes are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">form</tt></dt>
<dd>
Specifies if the attribute is qualified (i.e., must have a namespace
prefix in the instance document) or not. The default value for this
attribute is specified by the <tt class="literal">attributeFormDefault</tt>
attribute of the <tt class="literal">xs:schema</tt> document
element--local definition only.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Local name (without namespace prefix)--local definition only.</p>
</dd>


<dt><tt class="literal">ref</tt></dt>
<dd>
Qualified name of a globally defined attribute--reference only.</p>
</dd>


<dt><tt class="literal">type</tt></dt>
<dd>
Qualified name of a simple datatype--definition only.</p>
</dd>


<dt><tt class="literal">use</tt></dt>
<dd>
Possible usage of the attribute. Marking an attribute
"prohibited" is useful to exclude
attributes during derivations by <a name="INDEX-1061" />restriction. 
</p>
</dd>

</dl>

</div>

<a name="ch15-15622" /><a name="INDEX-1062" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:attributeGroup(global definition)</b></font></td><td align="right"><i>Global attributes group declaration that can be referenced within the same schema by other schemas.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:attributeGroup
           id            = xs:ID
           name          = xs:NCName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, ((xs:attribute | xs:attributeGroup)*,
                      xs:anyAttribute?))
&lt;/xs:attributeGroup&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:redefine, xs:schema</p>
<h4 class="refsect1">Description</h4>


<p>Attribute groups are global containers that embed groups of
attributes. They can be used to manipulate groups of several
attributes often used together, but also to provide global access to
attributes that cannot be globally defined because they are
unqualified or because several definitions cohabit in a single schema
(see the example).
</p>

<p>Attribute references or local definitions, attribute wildcards, and
attribute group references may be included within attribute group
definitions.
</p>

<p>Attribute groups may be redefined through
<tt class="literal">xs:redefine</tt> elements.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>None.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:attributeGroup name="bookAttributes"&gt;
  &lt;xs:attribute name="id" type="xs:ID"/&gt;
  &lt;xs:attribute name="available" type="xs:boolean"/&gt;
&lt;/xs:attributeGroup&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Name of the attribute group.</p>
</dd>

</dl>

</div>

<a name="ch15-77109" /><a name="INDEX-1063" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:attributeGroup(reference)</b></font></td><td align="right"><i>Reference to a global attributes group declaration.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:attributeGroup
           id           = xs:ID
           ref          = xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:attributeGroup&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:attributeGroup (global definition),
xs:complexType (local definition), xs:complexType (global
definition), xs:extension (complex content), xs:extension (simple
content), xs:restriction (complex content), xs:restriction (simple
content)
</p>
<h4 class="refsect1">Description</h4>


<p>Any non-top-level occurrence of <tt class="literal">xs:attribute</tt> is a
reference to an attribute group that acts like a replacement of the
group by the attributes (or attribute group references) embedded in
the group.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>None.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="book"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="isbn"/&gt;
      &lt;xs:element ref="title"/&gt;
      &lt;xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/&gt; 
      &lt;xs:element ref="character" minOccurs="0"
        maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attributeGroup ref="bookAttributes"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">ref</tt></dt>
<dd>
Qualified name of the attribute group to reference.</p>
</dd>

</dl>

</div>

<a name="ch15-61674" /><a name="INDEX-1064" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:choice(outside a group)</b></font></td><td align="right"><i>Compositor to define group of mutually exclusive elements or compositors.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:choice
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs          = xs:nonNegativeInteger : "1"
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:element | xs:group | xs:choice |
                     xs:sequence | xs:any)
          )*)
&lt;/xs:choice&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:choice (outside a group), xs:choice (within a
group), xs:complexType (local definition), xs:complexType (global
definition), xs:extension (complex content), xs:restriction (complex
content), xs:sequence (within a group), xs:sequence (outside a group)
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:choice</tt> is a compositor that defines a group of
mutually exclusive particles. Only one can be found in the instance
document per occurrence of the <tt class="literal">xs:choice</tt>
compositor. The number of occurrences of the compositor itself is
controlled by its <tt class="literal">minOccurs</tt> and
<tt class="literal">maxOccurs</tt> attributes, while the number of
occurrences of each particle within a single occurrence of
<tt class="literal">xs:choice</tt> can be controlled by the
<tt class="literal">minOccurs</tt> and <tt class="literal">maxOccurs</tt>
attributes of the particles.
</p>

<p>In addition to situations where simple choices are expressed (element
"a" or
"b" can be accepted here),
<tt class="literal">xs:choice</tt> is often used to work around the
limitations of <tt class="literal">xs:all</tt> and to define content models
where an unlimited number of elements can be found in any order (see
the example).
</p>

<p>When the particle used in a <tt class="literal">xs:choice</tt> compositor
is an element, a similar effect may be achieved using substitution
groups.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The <tt class="literal">xs:choice</tt> compositor may cause violations of
the Unique Particle Attribution and Consistent Declaration rules.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:choice&gt; 
  &lt;!-- Allows either "name" or the sequence "first-name",
  "middle-name"and"last-name". --&gt;
  &lt;xs:element ref="name"/&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element ref="first-name"/&gt;
    &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
    &lt;xs:element ref="last-name"/&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:choice&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">maxOccurs</tt></dt>
<dd>
Maximum number of occurrences of the choice compositor.</p>
</dd>


<dt><tt class="literal">minOccurs</tt></dt>
<dd>
Minimum number of occurrences of the choice compositor.</p>
</dd>

</dl>

</div>

<a name="ch15-77129" /><a name="INDEX-1065" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:choice(within a group)</b></font></td><td align="right"><i>Compositor to define group of mutually exclusive elements or compositors. The number of occurrences cannot be defined when xs:choice is used within a group.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:choice
           id          = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:element | xs:group | xs:choice |
                     xs:sequence | xs:any)
          )*)
&lt;/xs:choice&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:group (definition)</p>
<h4 class="refsect1">Description</h4>


<p>When embedded in a group definition, the <tt class="literal">xs:choice</tt>
compositor has the same function as other contexts, except that the
number of its occurrences is defined in the
<tt class="literal">xs:group</tt> reference instead of by the
<tt class="literal">minOccurs</tt> and <tt class="literal">maxOccurs</tt>
attributes of the <tt class="literal">xs:choice</tt> compositor.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The <tt class="literal">minOccurs</tt> and <tt class="literal">maxOccurs</tt>
attributes that are allowed in other contexts are forbidden.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:group name="author-or-character"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="author"/&gt;
    &lt;xs:element ref="character"/&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77136" /><a name="INDEX-1066" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:complexContent</b></font></td><td align="right"><i>Definition of a complex content by derivation of a complex type.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:complexContent
           id             = xs:ID
           mixed          = xs:boolean
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:restriction | xs:extension))
&lt;/xs:complexContent&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:complexType (local definition), xs:complexType
(global definition)
</p>
<h4 class="refsect1">Description</h4>


<p>This element allows you to define a complex content model by
derivation of a complex type. It is not a component by itself
(complex contents are not named), but rather the declaration of an
intention to define a complex content model by derivation.
</p>

<p>The derivation method is not defined by the
<tt class="literal">xs:complexContent</tt> element itself, but by the
choice of its child element (<tt class="literal">xs:restriction</tt> for a
derivation by restriction, or <tt class="literal">xs:extension</tt> for a
derivation by extension).
</p>

<p>This element can be used to define if the content model is mixed or
not--but this information can also be defined in the
<tt class="literal">xs:complexType</tt> parent element, which has also a
<tt class="literal">mixed</tt> attribute.
</p>

<p>The mixed nature of the content model defined by
<tt class="literal">xs:complexContent</tt> attribute is dependent on the
derivation method and on the base type. If the base type is mixed, it
can be restricted to become elements only; otherwise the mixed nature
of the base type cannot be changed.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>A base type whose elements cannot be extended to be mixed.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="basePerson"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="dead" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">mixed</tt></dt>
<dd>
When set to <tt class="literal">true</tt>, the content model is mixed; when
set to <tt class="literal">false</tt>, the content model is
"element only"; when not set, the
content model is determined by the <tt class="literal">mixed</tt> attribute
of the parent <tt class="literal">xs:complexType</tt> element.
</p>
</dd>

</dl>

</div>

<a name="ch15-74973" /><a name="INDEX-1067" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:complexType(global definition)</b></font></td><td align="right"><i>Global definition of a complex type that can be referenced within the same schema by other schemas.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:complexType
           abstract       = xs:boolean : "false"
           block          = ( "#all" | list of ( "extension" | "restriction" ) )
           final          = ( "#all" | list of ( "extension" | "restriction" ) )
           id             = xs:ID
           mixed          = xs:boolean : "false"
           name           = xs:NCName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:simpleContent | xs:complexContent | (,
                      (xs:group | xs:all | xs:choice | xs:sequence)?,
                      ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?
          ?))))
&lt;/xs:complexType&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:redefine, xs:schema</p>
<h4 class="refsect1">Description</h4>


<p>This component is used to create global complex types as direct
descriptions of their content model, or by derivation from simple
types or other complex types. The creation of a new complex type is
done by a compositor (<tt class="literal">xs:sequence</tt>,
<tt class="literal">xs:choice</tt>, or <tt class="literal">xs:all</tt>) that
describes the child elements, followed by a list of attributes (or
attribute groups or attribute wildcards). The derivation of a complex
type through existing simple or complex types is done by including an
<tt class="literal">xs:simpleContent</tt> (for simple contents) or an
<tt class="literal">xs:complexContent</tt> (for complex contents) element.
In both cases, when the content is not simple, the
<tt class="literal">mixed</tt> attribute defines if the content model is
mixed (i.e., allows both text and element nodes) or not.
</p>

<p>Several controls are provided through attributes. Complex types can
be declared "abstract," their
substitution can be "blocked," and
they can be "final" for derivation.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Constraints about keys (<tt class="literal">xs:key</tt>,
<tt class="literal">xs:unique</tt>, and <tt class="literal">xs:keyref</tt>)
cannot be defined at this level but need to be defined in the
<tt class="literal">xs:element</tt> element. This means that, while in many
cases referencing a global element definition or a global complex
type definition can be considered as equivalent to define modular
content models, complex types are no longer an option when these
constraints need to be included in the content model.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:complexType name="title"&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base="tokenWithLang"&gt;
      &lt;xs:attribute name="note" type="xs:token"/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">abstract</tt></dt>
<dd>
When set to <tt class="literal">true</tt>, this complex type cannot be used
directly in the instance documents and needs to be substituted using
a <tt class="literal">xsi:type</tt> attribute.
</p>
</dd>


<dt><tt class="literal">block</tt></dt>
<dd>
Controls whether a substitution (either through a
<tt class="literal">xsi:type</tt> or substitution groups) can be performed
to a complex type, which is an extension or a restriction of the
current complex type. This attribute can only block such
substitutions (it cannot "unblock"
them), which can also be blocked in the element definition. The
default value is defined by the <tt class="literal">blockDefault</tt>
attribute of <tt class="literal">xs:schema</tt>.
</p>
</dd>


<dt><tt class="literal">final</tt></dt>
<dd>
Controls whether the complex type can be further derived by extension
or restriction to create new complex types.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">mixed</tt></dt>
<dd>
Defines if the content model will be mixed.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Name of the complex type.</p>
</dd>

</dl>

</div>

<a name="ch15-77162" /><a name="INDEX-1068" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:complexType(local definition)</b></font></td><td align="right"><i>Complex type local definition (local definitions cannot be referenced).
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:complexType
           id             = xs:ID
           mixed          = xs:boolean : "false"
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:simpleContent | xs:complexContent | (,
                      (xs:group | xs:all | xs:choice | xs:sequence)?,
                      ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?
          ?))))
&lt;/xs:complexType&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:element (within xs:all), xs:element (reference
or local definition), xs:element (global definition)
</p>
<h4 class="refsect1">Description</h4>


<p>Complex type definition can be created several ways. It can be done
by derivation using an <tt class="literal">xs:simpleContent</tt> (for
simple content models) or an <tt class="literal">xs:complexContent</tt>
(for simple content model) element, or it can be described, using
<tt class="literal">xs:sequence</tt> (for an ordered sequence of elements),
an <tt class="literal">xs:choice</tt> (for an alternative beyond several
elements), <tt class="literal">xs:all</tt> (for a unordered list of
elements) or xs:group (to reference a group of elements), and
<tt class="literal">xs:attribute</tt>,
<tt class="literal">xs:attributeGroup</tt>, and
<tt class="literal">xs:anyAttribute</tt> to define the list of its
attributes.
</p>

<p>Complex types describe all the constraints on the element, character,
and attribute nodes that may be included within an element except
those described by <tt class="literal">xs:unique</tt>,
<tt class="literal">xs:key</tt>, and <tt class="literal">xs:keyref</tt>, which
are defined directly under the <tt class="literal">xs:element</tt> element
definitions.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Constraints defined by <tt class="literal">xs:unique</tt>,
<tt class="literal">xs:key</tt>, and <tt class="literal">xs:keyref</tt> are not
defined within complex types but directly under the
<tt class="literal">xs:element</tt> element definitions.
</p>

<p>Local definitions can neither be derived (by restriction or
extension) nor substituted. In addition, the derivation by
restriction of complex types and the redefinition by restriction of
element groups, including elements defined with local complex type
definitions, is limited since derivations by restriction need to
redefine the elements that are kept using explicit derivations.
</p>

<p>Unlike other components (<tt class="literal">xs:element</tt>,
<tt class="literal">xs:attribute</tt>, <tt class="literal">xs:group</tt>, and
<tt class="literal">xs:attributeGroup</tt>), local
<tt class="literal">xs:complexType</tt> components cannot be used to
reference global complex types. Reference to complex types is done
through <tt class="literal">xs:element</tt> type attributes and
<tt class="literal">xs:restriction</tt> and <tt class="literal">xs:extension</tt>
base attributes.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="title"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xs:string"&gt;
        &lt;xs:attribute ref="lang"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">mixed</tt></dt>
<dd>
Defines if the content type will be mixed.</p>
</dd>

</dl>

</div>

<a name="ch15-77171" /><a name="INDEX-1069" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:documentation</b></font></td><td align="right"><i>Human-targeted documentation.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:documentation
           source            = xs:anyURI
           xml:lang          = xml:lang
           &gt;
           Content: ({any})*
&lt;/xs:documentation&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:annotation</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:documentation</tt> is a container for human-readable
documentation in plain text or structured formats. Its content model
is open and can accept any element from any namespace (with a
<tt class="literal">lax</tt> validation only--W3C XML Schema elements
included here must be valid). <tt class="literal">xs:documentation</tt> can
be used to include any kind of information.
</p>

<p>Its content is similar to <tt class="literal">xs:appinfo</tt> (which is
reserved for application processable information), except that it has
<tt class="literal">xml:lang</tt> attribute; this is allowed in
<tt class="literal">xs:documentation</tt>, but forbidden for
<tt class="literal">xs:appinfo</tt>).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Foreign attributes cannot be included in
<tt class="literal">xs:documentation</tt>. The <tt class="literal">source</tt>
attribute is also underspecified in the Recommendation. This could
lead to interoperability issues between applications that rely on
<tt class="literal">xs:documentation</tt>.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="author" type="author"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation xml:lang="en"&gt;
      The author of a book.
    &lt;/xs:documentation&gt;
    &lt;xs:documentation xml:lang="fr"&gt;
      Designe l'auteur d'un livre.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">source</tt></dt>
<dd>
Can be used to provide a link to the source of the information when a
snippet is included, or it can be used as a
<tt class="literal">semantic</tt> attribute to qualify the type of
information included.
</p>
</dd>


<dt><tt class="literal">xml:lang</tt></dt>
<dd>
Language used for the documentation.</p>
</dd>

</dl>

</div>

<a name="ch15-60040" /><a name="INDEX-1070" /><a name="INDEX-1071" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:element(global definition)</b></font></td><td align="right"><i>Global element definition that can be referenced within the same schema by other schemas.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:element
           abstract          = xs:boolean : "false"
           block             = ( "#all" | list of ( "extension" | "restriction" |
                                  "substitution" ) )
           default           = xs:string
           final             = ( "#all" | list of ( "extension" | "restriction" ) )
           fixed             = xs:string
           id                = xs:ID
           name              = xs:NCName
           nillable          = xs:boolean : "false"
           substitutionGroup = xs:QName
           type              = xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:simpleType | xs:complexType)?, (xs:unique |
                     xs:key | xs:keyref)*)
&lt;/xs:element&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:schema</p>
<h4 class="refsect1">Description</h4>


<p>All the elements defined at the top level of a schema (i.e.,
<tt class="literal">xs:element</tt>, which is included directly under the
<tt class="literal">xs:schema</tt> document element) are considered
globally defined.
</p>

<p>Globally defined elements have a global scope: they can be referenced
through their qualified name everywhere in the schema in which they
are defined, as well as in any schema that imports or includes this
schema. They can also be used as document elements in instance
documents.
</p>

<p>Elements are identified by their qualified name, but the local name
is expected in the <tt class="literal">name</tt> attribute. The type
definition is performed by assigning a simple or complex datatype to
the element.
</p>

<p>This assignment can be done either by reference, using the
<tt class="literal">type</tt> attribute to refer to a simple or complex
datatype by its qualified name, or inline, by embedding the
definition of the simple (<tt class="literal">xs:simpleType</tt>) element
or the complex (<tt class="literal">xs:complexType</tt>) element that is
within the <tt class="literal">xs:element</tt> element.
</p>

<p>A default value may be defined using the <tt class="literal">default</tt>
attribute, but note that the semantics of default values for elements
are different than those of the default values for attributes. An
element is not created if it is absent from the instance document;
the default value is applied only if the element is present and
empty.
</p>

<p>Several control attributes are included in element definitions (see
the attributes <tt class="literal">abstract</tt>,
<tt class="literal">blocked</tt>, <tt class="literal">final</tt>,
<tt class="literal">fixed</tt>, and <tt class="literal">nillable</tt>) .
</p>

<p>Element definitions are also the place in which substitution groups
are defined using the <tt class="literal">substitutionGroup</tt> attribute
to refer to the head of the substitution group. Any global element
that is not <tt class="literal">final</tt> may be chosen as the head of a
substitution group. Any reference to the head of a substitution group
may be replaced in the instance documents by any of the members of
the substitution group (assuming these substitutions have not been
blocked through <tt class="literal">block</tt> attributes). The relation is
transitive, and if the head of a substitution
"A" is a member of another
substitution group "B," the members
of "A" are also considered members
of "B."
</p>


<h4 class="refsect1">Restrictions</h4>


<p>There is no feature that allows definition of global elements that
cannot be used as document elements. When this is needed, the
workaround is to define all the elements, save one, and use simple
and complex types or element groups instead of global elements to
define reusable content models, and then reference these types from a
single globally-defined element.
</p>

<p>The identification of the global elements by their qualified names
makes it impossible to globally define multiple elements that have
the same qualified name. When a schema must include multiple
definitions of elements that have the same qualified name (and
different datatypes), all the definitions except one must be locally
declared. It is possible to use simple and complex types or element
groups instead of global elements to define reusable content models.
</p>

<p>All globally defined elements must be qualified if a target namespace
has been defined for the schema; they must all belong to the target
namespace. When no target namespace is defined, all the elements that
are globally or locally defined must be unqualified.
</p>

<p>The default and fixed values are defined in attributes and,
therefore, can only apply to simple type elements.
</p>

<p>Elements cannot be directly redefined. To redefine an element, one
can either include it in a group and redefine the group, or use a
global complex type to define the element and redefine the complex
type.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="name" type="xs:string"/&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">abstract</tt></dt>
<dd>
Controls whether the element may be used directly in instance
documents. When set to <tt class="literal">true</tt>, the element may still
be used to define content models, but it must be substituted through
a substitution group in the instance document.
</p>
</dd>


<dt><tt class="literal">block</tt></dt>
<dd>
Controls whether the element can be subject to a type or substitution
group substitution. <tt class="literal">#all</tt> blocks any substitution,
<tt class="literal">substitution</tt> blocks any substitution through
substitution groups, and <tt class="literal">extension</tt> and
<tt class="literal">restriction</tt> block any substitution (both through
<tt class="literal">xsi:type</tt> and substitution groups) by elements or
types, derived respectively by extension or restriction from the type
of the element. Its default value is defined by the
<tt class="literal">blockDefault</tt> attribute of the parent
<tt class="literal">xs:schema</tt>.
</p>
</dd>


<dt><tt class="literal">default</tt></dt>
<dd>
Default value of the element. Defined in an attribute, element
default values must be simple contents. Also note that default values
apply only to elements that are present in the document and empty.
The <tt class="literal">fixed</tt> and <tt class="literal">default</tt>
attributes are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">final</tt></dt>
<dd>
Controls whether the element can be used as the head of a
substitution group for elements whose types are derived by extension
or restriction from the type of the element. Its default value is
defined by the <tt class="literal">finalDefault</tt> attribute of the
parent <tt class="literal">xs:schema</tt>.
</p>
</dd>


<dt><tt class="literal">fixed</tt></dt>
<dd>
A simple content element may be fixed to a specific value using this
attribute. This value is also used as a default value, and if the
element is empty, it is supplied to the application. The
<tt class="literal">fixed</tt> and <tt class="literal">default</tt> attributes
are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Local name of the element (without namespace prefix).</p>
</dd>


<dt><tt class="literal">nillable</tt></dt>
<dd>
When this attribute is set to <tt class="literal">true</tt>, the element
can be declared as nil using an <tt class="literal">xsi:nil</tt> attribute
in the instance documents.
</p>
</dd>


<dt><tt class="literal">substitutionGroup</tt></dt>
<dd>
Qualified name of the head of the substitution group to which this
element belongs.
</p>
</dd>


<dt><tt class="literal">type</tt></dt>
<dd>
Qualified name of a simple or complex type (must be omitted when a
simple or complex type definition is <a name="INDEX-1071" />embedded). 
</p>
</dd>

</dl>

</div>

<a name="ch15-77205" /><a name="INDEX-1072" /><a name="INDEX-1073" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:element(within xs:all)</b></font></td><td align="right"><i>Reference to a global element declaration or local definition (local definitions cannot be referenced). The number of occurrences can only be zero or one when xs:element is used within xs:all..
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:element
           block         = ( "#all" | list of ( "extension" | "restriction" |
                              "substitution" ) )
           default       = xs:string
           fixed         = xs:string
           form          = ( "qualified" | "unqualified" )
           id            = xs:ID
           maxOccurs     = ( "0" | "1" ) : "1"
           minOccurs     = ( "0" | "1" ) : "1"
           name          = xs:NCName
           nillable      = xs:boolean : "false"
           ref           = xs:QName
           type          = xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:simpleType | xs:complexType)?, (xs:unique |
                     xs:key | xs:keyref)*)
&lt;/xs:element&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:all (outside a group), xs:all (within a group)</p>
<h4 class="refsect1">Description</h4>


<p>This element serves two different purposes and has two different
content models for these purposes: it can either be a reference to a
globally defined element or to a local element definition. These
options are mutually exclusive.
</p>

<p>When used as a reference to an element, the <tt class="literal">ref</tt>
attribute must contain the qualified name of the element (with its
namespace prefix).
</p>

<p>When used as a local definition, the definition is done by assigning
a simple or complex datatype to the element. This assignment can be
done either by reference, using the <tt class="literal">type</tt> attribute
to refer to a simple or complex datatype by its qualified name, or
inline, by embedding the definition of the simple
(<tt class="literal">xs:simpleType</tt>) element or complex
(<tt class="literal">xs:complexType</tt>) element within the
<tt class="literal">xs:element</tt> element.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Local element definitions or references cannot have a number of
occurrences greater than one.
</p>

<p>The default and fixed values are defined in attributes and,
therefore, can only apply to simple type elements.
</p>

<p>The fact that W3C XML Schema cannot describe the exclusive
combinations of the attributes and elements of
<tt class="literal">xs:element</tt>, which can be summarized as:
</p>

<blockquote><pre class="code">ref attribute xor name attribute, type attribute xor xs:simpleType element, xor 
xs:complexType element</pre></blockquote>


<p>is an example that shows some of the restrictions of the language.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:all&gt;
  &lt;xs:element name="first" type="string32" minOccurs="0"/&gt;
  &lt;xs:element name="middle" type="string32" minOccurs="0"/&gt;
  &lt;xs:element name="last" type="string32"/&gt;
&lt;/xs:all&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">block</tt></dt>
<dd>
Controls whether the element can be subject to a type or substitution
group substitution. <tt class="literal">#all</tt> blocks any substitution,
<tt class="literal">substitution</tt> blocks any substitution through
substitution groups, and <tt class="literal">extension</tt> and
<tt class="literal">restriction</tt> block any substitution (both through
<tt class="literal">xsi:type</tt> and substitution groups) by elements or
types, derived respectively by extension or restriction from the type
of the element. Its default value is defined by the
<tt class="literal">blockDefault</tt> attribute of the parent
<tt class="literal">xs:schema</tt>.
</p>
</dd>


<dt><tt class="literal">default</tt></dt>
<dd>
Default value of the element. Defined in an attribute, element
default values must be simple contents. Also note that default values
apply only to elements that are present in the document and empty.
The <tt class="literal">fixed</tt> and <tt class="literal">default</tt>
attributes are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">fixed</tt></dt>
<dd>
A simple content element may be fixed to a specific value using this
attribute. This value is also used as a default value, and if the
element is empty, it is supplied to the application. The
<tt class="literal">fixed</tt> and <tt class="literal">default</tt> attributes
are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">form</tt></dt>
<dd>
Specifies whether the element must be qualified (i.e., belong to a
namespace) in the instance documents or not. The default value of
this attribute is determined by the <tt class="literal">xs:schema</tt>
<tt class="literal">elementFormDefault</tt> attribute.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">maxOccurs</tt></dt>
<dd>
Maximum number of occurrences of the element. Can take only the
values 0 or 1 within a <tt class="literal">xs:all</tt> compositor.
</p>
</dd>


<dt><tt class="literal">minOccurs</tt></dt>
<dd>
Minimum number of occurrences of the element. Can take only the
values 0 or 1 within a <tt class="literal">xs:all</tt> compositor.
</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Name of the element (mutually exclusive with the
<tt class="literal">ref</tt> attribute).
</p>
</dd>


<dt><tt class="literal">nillable</tt></dt>
<dd>
When this attribute is set to <tt class="literal">true</tt>, the element
can be declared as nil using an <tt class="literal">xsi:nil</tt> attribute
in the instance documents.
</p>
</dd>


<dt><tt class="literal">ref</tt></dt>
<dd>
Reference to a global element definition (mutually exclusive with the
<tt class="literal">name</tt>, <tt class="literal">block</tt>, and
<tt class="literal">type</tt> attributes and any embedded type definition.
</p>
</dd>


<dt><tt class="literal">type</tt></dt>
<dd>
Simple or complex type of the element (mutually exclusive with the
<tt class="literal">ref</tt> attribute and any embedded type <a name="INDEX-1073" />definition).
</p>
</dd>

</dl>

</div>

<a name="ch15-77232" /><a name="INDEX-1074" /><a name="INDEX-1075" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:element(reference or local definition)</b></font></td><td align="right"><i>Reference to a global element declaration or local definition (local definitions cannot be referenced).
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:element
           block         = ( "#all" | list of ( "extension" | "restriction" |
                              "substitution" ) )
           default       = xs:string
           fixed         = xs:string
           form          = ( "qualified" | "unqualified" )
           id            = xs:ID
           maxOccurs     = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs     = xs:nonNegativeInteger : "1"
           name          = xs:NCName
           nillable      = xs:boolean : "false"
           ref           = xs:QName
           type          = xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:simpleType | xs:complexType)?, (xs:unique |
                      xs:key | xs:keyref)*)
&lt;/xs:element&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:choice (outside a group), xs:choice (within a
group), xs:sequence (within a group), xs:sequence (outside a group)
</p>
<h4 class="refsect1">Description</h4>


<p>This element serves two different purposes and has two different
content models for these purposes: it can either be a reference to a
globally defined element or to a local element definition. These
options are mutually exclusive.
</p>

<p>When used as a reference to an element, the <tt class="literal">ref</tt>
attribute must contain the qualified name of the element (with its
namespace prefix).
</p>

<p>When used as a local definition, the definition is done by assigning
a simple or complex datatype to the element. This assignment can be
done either by reference, using the <tt class="literal">type</tt> attribute
to refer to a simple or complex datatype by its qualified name, or
inline, by embedding the definition of the simple
(<tt class="literal">xs:simpleType</tt>) element or complex
(<tt class="literal">xs:complexType</tt>) element within the
<tt class="literal">xs:element</tt> element.
</p>

<p>In all cases, the number of occurrences can be constrained using the
<tt class="literal">minOccurs</tt> and <tt class="literal">maxOccurs</tt>
attributes, whose default value is 1. The
<tt class="literal">maxOccurs</tt> attribute can take the value unbounded,
to define that an element may appear as many times as the author of
the document wishes.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The default and fixed values are defined in attributes and,
therefore, can only apply to simple type elements.
</p>

<p>The fact that W3C XML Schema cannot describe the exclusive
combinations of the attributes and elements of xs:element which could
be summarized as:
</p>

<blockquote><pre class="code">ref attribute xor name attribute, type attribute xor xs:simpleType element, xor 
xs:complexType element</pre></blockquote>


<p>is an example that shows some of the restrictions of the language.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:sequence&gt;
  &lt;xs:element name="book" maxOccurs="unbounded"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="isbn"/&gt;
        &lt;xs:element ref="title"/&gt; 
        &lt;xs:element ref="author" minOccurs="0"
          maxOccurs="unbounded"/&gt; 
        &lt;xs:element ref="character" minOccurs="0"
          maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute ref="id"/&gt;
      &lt;xs:attribute ref="available"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:sequence&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">block</tt></dt>
<dd>
Controls whether the element can be subject to a type or substitution
group substitution. <tt class="literal">#all</tt> blocks any substitution,
<tt class="literal">substitution</tt> blocks any substitution through
substitution groups, and <tt class="literal">extension</tt> and
<tt class="literal">restriction</tt> block any substitution (both through
<tt class="literal">xsi:type</tt> and substitution groups) by elements or
types, derived respectively by extension or restriction from the type
of the element. Its default value is defined by the
<tt class="literal">blockDefault</tt> attribute of the parent
<tt class="literal">xs:schema</tt>.
</p>
</dd>


<dt><tt class="literal">default</tt></dt>
<dd>
Default value of the element. Defined in an attribute, element
default values must be simple contents. Also note that default values
apply only to elements that are present in the document and empty.
The <tt class="literal">fixed</tt> and <tt class="literal">default</tt>
attributes are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">fixed</tt></dt>
<dd>
A simple content element may be fixed to a specific value using this
attribute. This value is also used as a default value, and if the
element is empty, it is supplied to the application. The
<tt class="literal">fixed</tt> and <tt class="literal">default</tt> attributes
are mutually exclusive.
</p>
</dd>


<dt><tt class="literal">form</tt></dt>
<dd>
Defines if the element is
"qualified" (i.e., belongs to the
target namespace) or "unqualified"
(i.e., doesn't belong to any namespace)--to be
used only for local element definitions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">maxOccurs</tt></dt>
<dd>
Maximum number of occurrences
("unbounded" means
"unlimited").
</p>
</dd>


<dt><tt class="literal">minOccurs</tt></dt>
<dd>
Minimum number of occurrences.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Local name (without namespace prefix)--to be use only for local
element definitions.
</p>
</dd>


<dt><tt class="literal">nillable</tt></dt>
<dd>
When this attribute is set to <tt class="literal">true</tt>, the element
can be declared as nil using an <tt class="literal">xsi:nil</tt> attribute
in the instance documents.
</p>
</dd>


<dt><tt class="literal">ref</tt></dt>
<dd>
Reference to a global element--to be used only for references.</p>
</dd>


<dt><tt class="literal">type</tt></dt>
<dd>
Reference to a simple or complex type--to be used only for local
element <a name="INDEX-1075" />definitions. 
</p>
</dd>

</dl>

</div>

<a name="ch15-77259" /><a name="INDEX-1076" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:enumeration</b></font></td><td align="right"><i>Facet to restrict a datatype to a finite set of values.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:enumeration
           id             = xs:ID
           value          = anySimpleType
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:enumeration&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for: xs:anyURI, xs:base64Binary, xs:byte,
xs:date, xs:dateTime, xs:decimal, xs:double, xs:duration,
xs:ENTITIES, xs:ENTITY, xs:float, xs:gDay, xs:gMonth, xs:gMonthDay,
xs:gYear, xs:gYearMonth, xs:hexBinary, xs:ID, xs:IDREF, xs:IDREFS,
xs:int, xs:integer, xs:language, xs:long, xs:Name, xs:NCName,
xs:negativeInteger, xs:NMTOKEN, xs:NMTOKENS, xs:nonNegativeInteger,
xs:nonPositiveInteger, xs:normalizedString, xs:NOTATION,
xs:positiveInteger, xs:QName, xs:short, xs:string, xs:time, xs:token,
xs:unsignedByte, xs:unsignedInt, xs:unsignedLong, xs:unsignedShort
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:enumeration</tt> is a facet that allows definition
of a list of possible values for the value space of a datatype by
enumerating all these values in separated
<tt class="literal">xs:enumeration</tt> elements in a single restriction
step (i.e., under a single <tt class="literal">rs:restriction</tt> parent
element). This is one of the two facets (with
<tt class="literal">xs:pattern</tt>) that are available for all the
datatypes (atomic, lists, or unions), but unlike
<tt class="literal">xs:pattern</tt>, <tt class="literal">xs:enumeration</tt> is
not available for <tt class="literal">xs:boolean</tt>.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The values of the <tt class="literal">xs:enumeration</tt> facets must
belong to the value space of the base datatype. When the base
datatype is already restricted by enumeration, the new enumeration
values must be a subset of the base datatype enumerations (even
though they may have different lexical representations that
correspond to the same logical values).
</p>

<p>This facet cannot be fixed (i.e., it remains available in all the
derived types).
</p>

<p>This facet is not available for <tt class="literal">xs:boolean</tt>.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="schemaRecommendations"&gt;
  &lt;xs:restriction base="xs:anyURI"&gt;
    &lt;xs:enumeration value="http://www.w3.org/TR/xmlschema-0/"/&gt;
    &lt;xs:enumeration value="http://www.w3.org/TR/xmlschema-1/"/&gt;
    &lt;xs:enumeration value="http://www.w3.org/TR/xmlschema-2/"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value to be added to the list of possible values for this datatype.</p>
</dd>

</dl>

</div>

<a name="ch15-41987" /><a name="INDEX-1077" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:extension(simple content)</b></font></td><td align="right"><i>Extension of a simple content model.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:extension
           base          = xs:QName
           id          = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, ((xs:attribute | xs:attributeGroup)*,                      xs:anyAttribute?))
&lt;/xs:extension&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:simpleContent</p>
<h4 class="refsect1">Description</h4>


<p>This element is used to extend either a simple type or a simple
content complex type into a simple content complex type (i.e., the
content model of an element with a text nodes and some attributes).
The type to extend is specified in the <tt class="literal">base</tt>
attribute, and the list of the attributes to add to the content model
is given as <tt class="literal">xs:attributes</tt>,
<tt class="literal">xs:attributeGroup</tt>, and
<tt class="literal">xs:anyAttribute</tt> embedded in the
<tt class="literal">xs:extension</tt> element.
</p>

<p>Such a derivation by extension of a simple type is the only way to
create a complex type simple content content model.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The definition of the base type cannot be embedded in the
<tt class="literal">xs:extension</tt> element, and the base type needs to
be a global type.
</p>

<p>The same element name (<tt class="literal">xs:extension</tt>) is used by
W3C XML Schema for the extension of simple content and complex
content complex types with a different content model.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="title"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="string255"&gt;
        &lt;xs:attribute ref="lang"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">base</tt></dt>
<dd>
Qualified name of the base type (simple type or simple content
complex type).
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77277" /><a name="INDEX-1078" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:extension(complex content)</b></font></td><td align="right"><i>Extension of a complex content model.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:extension
           base          = xs:QName
           id            = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (, (xs:group | xs:all | xs:choice |
                      xs:sequence)?, ((xs:attribute | xs:attributeGroup)*,
                      xs:anyAttribute?)))
&lt;/xs:extension&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:complexContent</p>
<h4 class="refsect1">Description</h4>


<p>Extension of a complex (or mixed) content complex type. This
derivation method can be applied to another complex content complex
base type, and allows the addition of elements and attributes to this
base type. The additional elements are added after the compositor
used in the base type.
</p>

<p>When new elements are added during a derivation by extension, the
resulting content model is equivalent to creating a sequence that
contains the compositor used to define the base type and the one
included in the <tt class="literal">xs:extension</tt> element.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Complex types that use a <tt class="literal">xs:all</tt> compositor cannot
be used as base types for derivations by extension, except when those
extensions add only attributes.
</p>

<p>New elements added to base types using a <tt class="literal">xs:choice</tt>
compositor are added in sequence after the
<tt class="literal">xs:choice</tt>, rather than as new choices.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="basePerson"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="qualification"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">base</tt></dt>
<dd>
Qualified name of the base type.</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77286" /><a name="INDEX-1079" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:field</b></font></td><td align="right"><i>Definition of the field to use for a uniqueness constraint.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:field
           id             = xs:ID
           xpath          = xs:token
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:field&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:key, xs:keyref, xs:unique</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:field</tt> is used to define the location of the
fields on which a uniqueness constraint or reference will be checked.
</p>

<p>The fields are elements or attributes that are identified by relative
XPath expressions (i.e., <tt class="literal">xpath</tt> attributes)
evaluated against the nodes selected by the
<tt class="literal">xs:selector</tt> element.
</p>

<p>Concatenated keys can be expressed defining multiple fields under a
<tt class="literal">xs:unique</tt>, <tt class="literal">xs:key</tt>, or
<tt class="literal">xs:keyref</tt> element.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The <tt class="literal">xpath</tt> attribute uses a simple subset of XPath
1.0. The motivation of the W3C XML Schema Working Group for defining
this subset is to simplify the work of the implementers of schema
processors, and also to define a subset that constraints the path to
stay within the scope of the current element.
</p>

<p>This subset is restricted to using only the child, attribute, self,
and descendant or self XPath axes through their abbreviated syntaxes
without including any test in any of the XPath location steps, and
without using any XPath functions. It is identical to the subset
defined for <tt class="literal">xs:selector</tt>, except that attributes
are allowed in <tt class="literal">xs:field</tt> and forbidden in
<tt class="literal">xs:selector</tt>.
</p>

<p>The formal extended BNF given in the W3C Recommendation is as follows:</p>

<blockquote><pre class="code">Field ::= Path ( '|' Path )* Path ::= ('.//')? ( Step '/' )* ( Step | '@' NameTest ) 
Step ::= '.' | NameTest NameTest ::= QName | '*' | NCName ':' '*'</pre></blockquote>


<p>When concatenated keys are defined, the node sets identified by each
field must have a single occurrence per iteration of locator. This
means that on structures such as:
</p>

<blockquote><pre class="code">&lt;sect num="1"&gt;
  &lt;sub-sect num="1"&gt; Sub section 1.1 &lt;/sub-sect&gt; 
  &lt;sub-sect num="2"&gt; Sub section 1.2 &lt;/sub-sect&gt; 
&lt;/sect&gt; 
&lt;sect num="1"&gt; 
  &lt;sub-sect num="3"&gt; Sub section 1.3 &lt;/sub-sect&gt; 
  &lt;sub-sect num="4"&gt; Sub section 1.4 &lt;/sub-sect&gt; 
&lt;/sect&gt;</pre></blockquote>


<p>multilevel concatenated keys over the <tt class="literal">num</tt>
attributes of <tt class="literal">sect</tt> and <tt class="literal">sub-sect</tt>
cannot be defined with W3C XML Schema. This is because the locator
would need to iterate on the <tt class="literal">sect</tt> element, and the
<tt class="literal">num</tt> attribute of the <tt class="literal">sub-sect</tt>
element then takes several values for each iteration.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="library"&gt;
  &lt;xs:complexType&gt;
    .../...
  &lt;/xs:complexType&gt;
  &lt;xs:unique name="book"&gt;
    &lt;xs:selector xpath="book"/&gt;
    &lt;xs:field xpath="isbn"/&gt;
  &lt;/xs:unique&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">xpath</tt></dt>
<dd>
Relative XPath expression identifying the field(s) composing the key,
key reference, or unique constraint.
</p>
</dd>

</dl>

</div>

<a name="ch15-77295" /><a name="INDEX-1080" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:fractionDigits</b></font></td><td align="right"><i>Facet to define the number of fractional digits of a numerical datatype.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:fractionDigits
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:fractionDigits&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for: xs:decimal</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:fractionDigits</tt> defines the maximum number of
fractional digits (i.e., digits that are after the decimal point) of
an <tt class="literal">xs:decimal</tt> datatype.
</p>

<p>This facet constrains the value space, which means that the number of
fractional digits is checked after the value is transformed to its
canonical form, and the trailing zeros are removed.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Within a restriction step, <tt class="literal">xs:fractionDigits</tt> is
dependent on <tt class="literal">xs:totalDigits</tt>, since using
inconsistent values leads to datatypes with empty value spaces.
</p>

<p><tt class="literal">xs:fractionDigits</tt> must restrict the value space of
its base type, and its value must be smaller than the value of
<tt class="literal">xs:fractionDigits</tt> of its base type if defined.
</p>

<p>It is possible to use <tt class="literal">xs:pattern</tt> to constrain the
number of fractional digits in the lexical space.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="fractionDigits"&gt;
  &lt;xs:restriction base="xs:decimal"&gt;
    &lt;xs:fractionDigits value="2"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">true</tt>, the value of the facet cannot be
modified during further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet.</p>
</dd>

</dl>

</div>

<a name="ch15-46099" /><a name="INDEX-1081" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:group(definition)</b></font></td><td align="right"><i>Global elements group declaration that can be referenced within the same schema by other schemas.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:group
           name               = xs:NCName
           &gt;
           Content: (xs:annotation?, (xs:all | xs:choice | xs:sequence))
&lt;/xs:group&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:redefine, xs:schema</p>
<h4 class="refsect1">Description</h4>


<p>Groups of elements can be globally defined and used as containers,
which can be referenced elsewhere in this schema or in other schemas.
These containers, which are almost free of semantics, are very
flexible and may be used as building blocks for the definition of
local or global complex types.
</p>

<p>Being global components, they can also be used to encapsulate element
definitions that cannot be made global, such as unqualified elements
in a schema with target namespaces, multiple elements with the same
name in a schema, elements that should not be used as document
elements, or elements that should be redefined through
<tt class="literal">xs:redefine</tt> in other schemas.
</p>

<p>Element groups can be redefined through
<tt class="literal">xs:redefine</tt>; the redefinition can be either a
restriction (similar to a complex type derivation by restriction) or
an extension. (This is more flexible than a complex type extension
since the location where the base group is included in the new group
can be chosen, while the new elements are always located after the
base type during a derivation by extension.)
</p>

<p>Any of the three compositors (<tt class="literal">xs:all</tt>,
<tt class="literal">xs:sequence</tt>, or <tt class="literal">xs:choice</tt>) may
be used to create an element group.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>When a group is created using a <tt class="literal">xs:all</tt> compositor,
this group inherits all the restrictions of
<tt class="literal">xs:all</tt>. In other words, including a
<tt class="literal">xs:all</tt> compositor in a group is not a workaround
to avoid the fundamental restrictions of <tt class="literal">xs:all</tt>!
</p>

<p>Group definition cannot be recursive.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:group name="name"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="first-name"/&gt;
      &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
      &lt;xs:element ref="last-name"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">name</tt></dt>
<dd>
Name of the group (unqualified).</p>
</dd>

</dl>

</div>

<a name="ch15-77313" /><a name="INDEX-1082" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:group(reference)</b></font></td><td align="right"><i>Reference to a global elements group declaration or local definition (local definitions cannot be referenced).
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:group
           id          = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs          = xs:nonNegativeInteger : "1"
           ref          = xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:group&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:choice (outside a group), xs:choice (within a
group), xs:complexType (local definition), xs:complexType (global
definition), xs:extension (complex content), xs:restriction (complex
content), xs:sequence (within a group), xs:sequence (outside a group)
</p>
<h4 class="refsect1">Description</h4>


<p>Used in a local context, <tt class="literal">xs:group</tt> is a reference
to an element group. The effect is a logical replacement of the group
reference by the group's content.
</p>

<p>When a group is being redefined (through
<tt class="literal">xs:redefine</tt>), a self reference (i.e., a reference
to the group being redefined) specifically means
"include the original content of the group at this
location."
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Groups cannot be recursive (i.e., a group cannot be referred to
either directly or indirectly within its definition).
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref="name"/&gt;
      &lt;xs:element ref="born"/&gt;
      &lt;xs:element ref="dead" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute ref="id"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">maxOccurs</tt></dt>
<dd>
Maximum number of occurrences of the group.</p>
</dd>


<dt><tt class="literal">minOccurs</tt></dt>
<dd>
Minimum number of occurrences of the group.</p>
</dd>


<dt><tt class="literal">ref</tt></dt>
<dd>
Qualified name of the group to include.</p>
</dd>

</dl>

</div>

<a name="ch15-77326" /><a name="INDEX-1083" /><a name="INDEX-1084" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:import</b></font></td><td align="right"><i>Import of a W3C XML Schema for another namespace.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:import
           id               = xs:ID
           namespace        = xs:anyURI
           schemaLocation   = xs:anyURI
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:import&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:schema</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:import</tt> identifies the location at which a W3C
XML Schema validator may find the definition corresponding to
namespaces other than the target namespace of the current schema.
</p>

<p>All the global definitions (elements, attributes, element and
attribute groups, simple and complex types) and unique and key
constraints of the imported schemas can be referenced using a
namespace prefix defined for the corresponding namespace URI.
</p>

<p>The schema locations indicated in <tt class="literal">xs:import</tt>
elements are only hints provided to the schema validators and may be
omitted. In this case, the Recommendation states that
"the schema author is leaving the identification of
that schema to the instance, application or user, via the mechanisms
described in Layer 3: Schema Document Access and
Web-interoperability."
</p>

<p><tt class="literal">xs:import</tt> may also be used to import components
with no target namespaces into schemas with target namespaces.
</p>


<h4 class="refsect1">Restrictions</h4>


<p><tt class="literal">xs:import</tt> must not be used to import component
definitions from the target namespace since two other elements are
available for this purpose (see <tt class="literal"><a href="ch15_01.htm">xs:include</a></tt> and <tt class="literal"><a href="ch15_01.htm">xs:redefine</a></tt>).
</p>

<p>Only global component definitions of the imported schemas can be
referenced (local definitions can never be referenced).
</p>

<p>The rules of scoping described for the <tt class="literal">xs:keyref</tt>
element also apply to references between constraints for elements
that belong to different namespaces (the root element of the
<tt class="literal">keyref</tt> constraint must be an ancestor or self
element of the root element for the unique or key constraint).
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:schema targetNamespace="http://dyomedea.com/ns/library"
  elementFormDefault="qualified" attributeFormDefault="unqualified"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:ppl="http://dyomedea.com/ns/people"
  xmlns:lib="http://dyomedea.com/ns/library"&gt; 
  &lt;xs:import namespace="http://dyomedea.com/ns/people"
    schemaLocation="simple-2-ns-ppl.xsd"/&gt;
  &lt;xs:element name="library"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="book" type="lib:bookType"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:complexType name="bookType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="isbn" type="xs:NMTOKEN"/&gt;
      &lt;xs:element name="title" type="xs:string"/&gt;
      &lt;xs:element name="authors"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="ppl:person"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
      &lt;xs:element name="characters"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="ppl:person" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="id" type="xs:ID" use="required"/&gt;
    &lt;xs:attribute name="available" type="xs:string" use="required"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">namespace</tt></dt>
<dd>
Namespace URI of the components to import. If this attribute is
missing, the imported components are expected to have no namespace.
When present, its value must be different than the target namespace
of the importing schema.
</p>
</dd>


<dt><tt class="literal">schemaLocation</tt></dt>
<dd>
Location of the schema to import. If this attribute is missing, the
validator might expect to get the information from the application,
or try to find it on the <a name="INDEX-1084" />Internet. 
</p>
</dd>

</dl>

</div>

<a name="ch15-77337" /><a name="INDEX-1085" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:include</b></font></td><td align="right"><i>Inclusion of a W3C XML Schema for the same target namespace.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:include
           id             = xs:ID
           schemaLocation = xs:anyURI
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:include&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:schema</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:include</tt> performs a straight inclusion of a
schema within another schema that describes the same target
namespace. It is possible, though, to include a schema that
doesn't specify a target namespace. The included
schema will be treated as adopting the target namespace of its
includer in a schema with a target namespace. This possibility, often
called "chameleon design," allows
reuse of "transparent" schemas in
the context of different namespaces.
</p>

<p>The effect of a schema inclusion is a merge between the two schemas
that are consolidated into a global schema. The schema that is
included doesn't need to be a complete schema by
itself.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>It is not possible to use <tt class="literal">xs:include</tt> to include a
schema describing another namespace. (<tt class="literal">xs:import</tt>
should be used in this case.)
</p>

<p>It is not possible to change the definitions of the included schemas.
(<tt class="literal">xs:redefine</tt> should be used in this case.)
</p>

<p>It is not possible to include a fragment of a schema. (General
purpose inclusion mechanisms such as <tt class="literal">XInclude</tt>
should be used in this case.)
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:include schemaLocation="simple-types.xsd"/&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">schemaLocation</tt></dt>
<dd>
Location of the schema to include.</p>
</dd>

</dl>

</div>

<a name="ch15-77346" /><a name="INDEX-1086" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:key</b></font></td><td align="right"><i>Definition of a key.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:key
           id            = xs:ID
           name          = xs:NCName
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:selector, xs:field+))
&lt;/xs:key&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:element (within xs:all), xs:element (reference
or local definition), xs:element (global definition)
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:key</tt> is used to define simple or compound keys
by unambiguously identifying each element of a selected list of
subelements within the scope of a root element.
</p>

<p><tt class="literal">xs:key</tt> is very similar to
<tt class="literal">xs:unique</tt>. Like the constraints defined with
<tt class="literal">xs:unique</tt>, keys defined with
<tt class="literal">xs:key</tt> are unique in the scope of their root
element and may be referenced by <tt class="literal">xs:keyref</tt>. The
only difference between <tt class="literal">xs:key</tt> and
<tt class="literal">xs:unique</tt> is the keys must be defined for each of
the elements in the selection list, while unique identifiers may be
undefined for elements in the selection list.
</p>

<p>The root element for the key is the element in which the key is
defined. The location of the root element must be carefully chosen
since the unicity of the key is checked only within the node elements
that are the key's children. Defining a root element
that has multiple occurrences within a document leaves the
possibility to define local keys that are unique only in the scope of
each occurrence of a document. When a key is global to a document,
defining it using the document element as a root may cause it to be
less error-prone.
</p>

<p>The contribution of <tt class="literal">xs:key</tt> to the PSVI is a node
table in each occurrence of the root key element that contains the
list of the key sequences for this root element. The scope of these
node tables is limited to the root element in which they are
contained and its ancestors. This scope is used to determine the
behavior of the key references and impacts the choice of the key root
element when the key is referenced (see <tt class="literal"><a href="ch15_01.htm">xs:keyref</a></tt>).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>These XPath-based features do not follow the object-oriented,
namespace-aware general philosophy of W3C XML Schema. The XPath
expressions are specified independently of the
element's content model and the constraints for the
elements of all the possible namespaces must be defined in the schema
for the namespace of the constraint root element.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="library"&gt;
  &lt;xs:complexType&gt;
    .../...
  &lt;/xs:complexType&gt;
  &lt;xs:key name="book"&gt;
    &lt;xs:selector xpath="book"/&gt;
    &lt;xs:field xpath="isbn"/&gt;
  &lt;/xs:key&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
The name of the key.</p>
</dd>

</dl>

</div>

<a name="ch15-77355" /><a name="INDEX-1087" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:keyref</b></font></td><td align="right"><i>Definition of a key reference.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:keyref
           id            = xs:ID
           name          = xs:NCName
           refer         = xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:selector, xs:field+))
&lt;/xs:keyref&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:element (within xs:all), xs:element (reference
or local definition), xs:element (global definition)
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:keyref</tt> is used to define a reference to a
simple or compound key or to a unique constraint.
</p>

<p>The syntax of <tt class="literal">xs:keyref</tt> is very similar to the
syntax of <tt class="literal">xs:key</tt> or <tt class="literal">xs:unique</tt>.
The only difference is the <tt class="literal">refer</tt> attribute, which
must contain the name of the referred key or unique constraint.
</p>

<p>The root element for the <tt class="literal">keyref</tt> is the element in
which the key is defined. The key reference is often defined with the
same root element as its referred key or unique constraint, in which
case the matching is simple and straightforward.
</p>

<p>The root element of the <tt class="literal">keyref</tt> may also be defined
in any element for which it is in the scope of a matching constraint
node table, i.e., in all the ancestors of the root element of the
referred key or unique constraint. In this case, an additional check
is performed; for each matching key reference, the validator should
test that the key or unique value is defined only once in all the
matching key or unique root elements.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Key references defined in an ancestor of their referenced key or
unique constraint actually add additional constraints on the
referenced key or the unique key, which may be unexpected. A set of
identifiers that match a key or unique constraint may become invalid
when a key reference is defined.
</p>

<p>If, for instance, local keys are defined to identify characters
within the scope of a book, these keys would allow the reuse of the
same characters' identifiers in distinct books, such
as in the following:
</p>

<blockquote><pre class="code">&lt;book&gt; 
  &lt;isbn&gt; 0836217462 &lt;/isbn&gt; 
  &lt;title&gt; Being a Dog Is a Full-Time Job &lt;/title&gt; 
  &lt;character id="PP"&gt; 
    &lt;name&gt; Peppermint Patty &lt;/name&gt; 
    &lt;qualification&gt; bold, brash and tomboyish &lt;/qualification&gt; 
  &lt;/character&gt; 
  &lt;character id="Snoopy"&gt; 
    &lt;name&gt; Snoopy &lt;/name&gt; 
    &lt;qualification&gt; hero of the book &lt;/qualification&gt; 
  &lt;/character&gt; 
  &lt;character id="Schroeder"&gt; 
    &lt;name&gt; Schroeder &lt;/name&gt; 
    &lt;qualification&gt; brought classical music to the Peanuts strip&lt;/qualification&gt; 
  &lt;/character&gt; 
  &lt;character id="Lucy"&gt; 
    &lt;name&gt; Lucy &lt;/name&gt; 
    &lt;qualification&gt; bossy, crabby and selfish &lt;/qualification&gt; 
  &lt;/character&gt; 
&lt;/book&gt; 
&lt;book&gt; 
  &lt;isbn&gt; 0805033106 &lt;/isbn&gt; 
  &lt;title&gt; Peanuts Every Sunday &lt;/title&gt; 
  &lt;character id="Sally"&gt; 
    &lt;name&gt; Sally Brown &lt;/name&gt; 
    &lt;qualification&gt; always looks for the easy way out &lt;/qualification&gt; 
  &lt;/character&gt; 
  &lt;character id="Snoopy"&gt; 
    &lt;name&gt; Snoopy &lt;/name&gt; 
    &lt;qualification&gt; extroverted beagle &lt;/qualification&gt; 
  &lt;/character&gt; 
&lt;/book&gt;</pre></blockquote>


<p>If we add a key reference to reference these keys from the books,
using the same identifier for characters in different books will be
allowed if, and only if, these keys are not referenced.
</p>

<p>This example is then valid:</p>

<blockquote><pre class="code">&lt;library&gt; 
  &lt;book&gt; 
    &lt;isbn&gt; 0836217462 &lt;/isbn&gt; 
    &lt;title&gt; Being a Dog Is a Full-Time Job &lt;/title&gt; 
    &lt;character id="PP"&gt; 
      &lt;name&gt; Peppermint Patty &lt;/name&gt; 
      &lt;qualification&gt; bold, brash and tomboyish &lt;/qualification&gt; 
    &lt;/character&gt; 
    &lt;character id="Snoopy"&gt; 
      &lt;name&gt; Snoopy &lt;/name&gt; 
      &lt;qualification&gt; hero of the book &lt;/qualification&gt; 
    &lt;/character&gt; 
    &lt;character id="Schroeder"&gt; 
      &lt;name&gt; Schroeder &lt;/name&gt; 
      &lt;qualification&gt; brought classical music to the Peanuts strip &lt;/qualification&gt; 
    &lt;/character&gt; 
    &lt;character id="Lucy"&gt; 
      &lt;name&gt; Lucy &lt;/name&gt; 
      &lt;qualification&gt; bossy, crabby and selfish &lt;/qualification&gt; 
    &lt;/character&gt; 
  &lt;/book&gt; 
  &lt;book&gt; 
    &lt;isbn&gt; 0805033106 &lt;/isbn&gt; 
    &lt;title&gt; Peanuts Every Sunday &lt;/title&gt; 
    &lt;character id="Sally"&gt; 
      &lt;name&gt; Sally Brown &lt;/name&gt; 
      &lt;qualification&gt; always looks for the easy way out &lt;/qualification&gt; 
    &lt;/character&gt; 
    &lt;character id="Snoopy"&gt; 
      &lt;name&gt; Snoopy &lt;/name&gt; 
      &lt;qualification&gt; extroverted beagle &lt;/qualification&gt; 
    &lt;/character&gt; 
  &lt;/book&gt; 
  &lt;comment about="Sally"&gt; Sally is cute &lt;/comment&gt; 
&lt;/library&gt;</pre></blockquote>


<p>Because "Sally" is a unique key, it
becomes invalid if we add a comment element referring to
"Snoopy," which is mentioned twice.
</p>

<p>A complete schema for this document might be the following (note how
the <tt class="literal">xs:keyref</tt> refers to a
<tt class="literal">xs:unique</tt> constraint, which is defined for a child
of the current node):
</p>

<blockquote><pre class="code">&lt;xs:schema elementFormDefault="qualified" xmlns:xs=
  "http://www.w3.org/2001/XMLSchema"&gt;
&lt;xs:element name="library"&gt; 
  &lt;xs:complexType&gt; 
    &lt;xs:sequence&gt; 
      &lt;xs:element name="book" maxOccurs="unbounded"&gt; 
        &lt;xs:complexType&gt; 
          &lt;xs:sequence&gt; 
            &lt;xs:element name="isbn" type="xs:NMTOKEN"/&gt; 
            &lt;xs:element name="title" type="xs:string"/&gt; 
            &lt;xs:element name="character" maxOccurs="unbounded"&gt; 
              &lt;xs:complexType&gt; 
                &lt;xs:sequence&gt; 
                  &lt;xs:element name="name" type="xs:string"/&gt; 
                  &lt;xs:element name="qualification" type="xs:string"/&gt; 
                &lt;/xs:sequence&gt;
                &lt;xs:attribute name="id" type="xs:string"/&gt; 
              &lt;/xs:complexType&gt; 
            &lt;/xs:element&gt; 
          &lt;/xs:sequence&gt; 
        &lt;/xs:complexType&gt; 
        &lt;xs:key name="character"&gt; 
        &lt;xs:selector xpath="character"/&gt; 
        &lt;xs:field xpath="@id"/&gt; 
        &lt;/xs:key&gt; 
      &lt;/xs:element&gt; 
      &lt;xs:element name="comment" minOccurs="0" maxOccurs="unbounded"&gt; 
        &lt;xs:complexType&gt; 
          &lt;xs:simpleContent&gt; 
            &lt;xs:extension base="xs:string"&gt; 
            &lt;xs:attribute name="about" type="xs:string"/&gt; 
            &lt;/xs:extension&gt; 
          &lt;/xs:simpleContent&gt; 
        &lt;/xs:complexType&gt; 
      &lt;/xs:element&gt; 
    &lt;/xs:sequence&gt; 
  &lt;/xs:complexType&gt; 
  &lt;xs:unique name="book"&gt; 
  &lt;xs:selector xpath="book"/&gt; 
  &lt;xs:field xpath="isbn"/&gt; 
  &lt;/xs:unique&gt; 
  &lt;xs:keyref name="comment" refer="character"&gt; 
  &lt;xs:selector xpath="comment"/&gt; 
  &lt;xs:field xpath="@about"/&gt; 
  &lt;/xs:keyref&gt; 
&lt;/xs:element&gt; 
&lt;/xs:schema&gt;</pre></blockquote>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="library"&gt;
  &lt;xs:complexType&gt;
    .../...
  &lt;/xs:complexType&gt;
  &lt;xs:key name="ID"&gt;
    &lt;xs:selector xpath="book|author|character"/&gt;
    &lt;xs:field xpath="@id"/&gt;
  &lt;/xs:key&gt;
  &lt;xs:keyref name="IDREF" refer="ID"&gt;
    &lt;xs:selector xpath="book/author-ref|book/character-ref"/&gt;
    &lt;xs:field xpath="@ref"/&gt;
  &lt;/xs:keyref&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Name of the key reference.</p>
</dd>


<dt><tt class="literal">refer</tt></dt>
<dd>
Name of the key or unique constraint referred by the key <a name="INDEX-1087" />reference.
</p>
</dd>

</dl>

</div>

<a name="ch15-77366" /><a name="INDEX-1088" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:length</b></font></td><td align="right"><i>Facet to define the length of a value.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:length
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:length&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for: xs:anyURI, xs:base64Binary, xs:ENTITIES,
xs:ENTITY, xs:hexBinary, xs:ID, xs:IDREF, xs:IDREFS, xs:language,
xs:Name, xs:NCName, xs:NMTOKEN, xs:NMTOKENS, xs:normalizedString,
xs:NOTATION, xs:QName, xs:string, xs:token
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:length</tt> is a facet that allows the definition of
the length expressed in a unit that depends on the datatype. For most
of the datatypes, the unit is the character as defined in the XML 1.0
Recommendation (i.e., Unicode characters defined by ISO/IEC 10646
that may be represented on more than 8 bits). The exceptions are the
binary datatypes (<tt class="literal">xs:hexBinary</tt> and
<tt class="literal">xs:base64Binary</tt>), for which lengths are expressed
in number of bytes (8 bits) of binary data, and all the list
datatypes, for which lengths are expressed in number of list items.
</p>

<p><tt class="literal">xs:length</tt> constrains the value space. In practice,
this means that it is checked after whitespace replacement and
collapsing, as defined by the <tt class="literal">xs:whiteSpace</tt> facet.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>This is a logical length that has often no direct relation to the
size of storage needed for the value.
</p>

<p>The value of this facet cannot be modified during further
restrictions, and the value of the <tt class="literal">fixed</tt> attribute
is meaningless (the behavior is always as if the facet were fixed).
</p>

<p>Although also not specified in the Recommendation,
<tt class="literal">xs:length</tt> interacts with the
<tt class="literal">xs:minLength</tt> and <tt class="literal">xs:maxLength</tt>
and shouldn't set the length to a value not in the
range between <tt class="literal">xs:minLength</tt> and
<tt class="literal">xs:maxLength</tt> of its base type.
</p>

<p>Fixing the <tt class="literal">xs:length</tt> facet
doesn't fix the <tt class="literal">xs:maxLength</tt> and
<tt class="literal">xs:minLength</tt> facets. To fix the three facets,
define two restriction steps, since it is forbidden to apply these
facets in the same restriction step.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="standardNotations"&gt;
  &lt;xs:restriction base="xs:NOTATION"&gt;
    &lt;xs:length value="8"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">true</tt>, the value of the length cannot
be modified during further restrictions (meaningless for this facet
whose value can never be modified in further restrictions).
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet.</p>
</dd>

</dl>

</div>

<a name="ch15-77377" /><a name="INDEX-1089" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:list</b></font></td><td align="right"><i>Derivation by list.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:list
           id               = xs:ID
           itemType         = xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:simpleType?))
&lt;/xs:list&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:simpleType (local definition), xs:simpleType
(global definition)
</p>
<h4 class="refsect1">Description</h4>


<p>Derivation by list is the process of transforming a simple datatype
(named the item type) into a whitespace-separated list of values from
this datatype.
</p>

<p>The item type can be defined inline by adding a
<tt class="literal">simpleType</tt> definition as a child element of the
list element, or by reference, using the <tt class="literal">itemType</tt>
attribute (it is an error to use both).
</p>

<p>The semantic and list of facets applicable on the item type are lost
and the new datatype inherits a list of facets, which is common to
all the list datatypes: <tt class="literal">xs:enumeration</tt>,
<tt class="literal">xs:length</tt>, <tt class="literal">xs:maxLength</tt>,
<tt class="literal">xs:minLength</tt>, and <tt class="literal">xs:pattern</tt>
and its whitespaces are always collapsed.
</p>

<p>After a derivation by list, the type of the resulting datatype is a
list of whatever the item type was (atomic or union).
</p>

<p>It is possible to define lists of atomic datatypes that allow
whitespaces such as <tt class="literal">xs:string</tt>. In this case, the
whitespaces are always considered separators.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The facets that can be applied to a list datatype are common to all
the list datatypes, and add constraints to the list as a whole
(rather than on the items composing the list). The constraints on the
item composing the lists, therefore, need to be applied before the
derivation by list.
</p>

<p>The list separators cannot be chosen and are always whitespaces.</p>

<p>It is explicitly forbidden by the Recommendation to define lists of
lists. Lists of unions and unions of lists are both allowed, so it
should be possible to work around this limitation by defining a dummy
union of a list and using this union as a list item if needed.
However, lists of lists are effectively pointless, since all the list
types have the same set of separators.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="integerList"&gt;
  &lt;xs:list itemType="xs:integer"/&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">itemType</tt></dt>
<dd>
Reference to the item type when not defined inline by a
<tt class="literal">xs:simpleType</tt> element.
</p>
</dd>

</dl>

</div>

<a name="ch15-77386" /><a name="INDEX-1090" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:maxExclusive</b></font></td><td align="right"><i>Facet to define a maximum (exclusive) value.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:maxExclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:maxExclusive&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for:xs:byte, xs:date, xs:dateTime, xs:decimal,
xs:double, xs:duration, xs:float, xs:gDay, xs:gMonth, xs:gMonthDay,
xs:gYear, xs:gYearMonth, xs:int, xs:integer, xs:long,
xs:negativeInteger, xs:nonNegativeInteger, xs:nonPositiveInteger,
xs:positiveInteger, xs:short, xs:time, xs:unsignedByte,
xs:unsignedInt, xs:unsignedLong, xs:unsignedShort
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:maxExclusive</tt> defines an exclusive maximum
value. To be valid, a value must be strictly less than the value of
<tt class="literal">xs:maxExclusive</tt>. This facet constrains the value
space.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>It is forbidden to define both <tt class="literal">xs:maxExclusive</tt> and
<tt class="literal">xs:maxInclusive</tt> in the same restriction step.
Although not explicitly specified in the Recommendation, it
doesn't make sense to define several
<tt class="literal">xs:maxExclusive</tt> facets in a single restriction
step also.
</p>

<p>Within a restriction step, <tt class="literal">xs:maxExclusive</tt> is also
dependent on <tt class="literal">xs:minExclusive</tt> and
<tt class="literal">xs:minInclusive</tt>, since using inconsistent values
leads to datatypes with empty value spaces.
</p>

<p><tt class="literal">xs:maxExclusive</tt> must restrict the value space of
its base type, and its value must be in the value space of the base
type.
</p>

<p>Fixing the <tt class="literal">maxExclusive</tt> facet
doesn't fix the <tt class="literal">xs:maxInclusive</tt>
facet. To fix both facets, define two restriction steps since it is
forbidden to apply these two facets in the same restriction step.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="myInteger"&gt;
  &lt;xs:restriction base="xs:integer"&gt;
    &lt;xs:minInclusive value="-2"/&gt;
    &lt;xs:maxExclusive value="5"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">fixed</tt>, the value of this facet cannot
be changed in further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet (must be in the value space of the base type).</p>
</dd>

</dl>

</div>

<a name="ch15-77397" /><a name="INDEX-1091" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:maxInclusive</b></font></td><td align="right"><i>Facet to define a maximum (inclusive) value.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:maxInclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:maxInclusive&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for: xs:byte, xs:date, xs:dateTime, xs:decimal,
xs:double, xs:duration, xs:float, xs:gDay, xs:gMonth, xs:gMonthDay,
xs:gYear, xs:gYearMonth, xs:int, xs:integer, xs:long,
xs:negativeInteger, xs:nonNegativeInteger, xs:nonPositiveInteger,
xs:positiveInteger, xs:short, xs:time, xs:unsignedByte,
xs:unsignedInt, xs:unsignedLong, xs:unsignedShort
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:maxInclusive</tt> defines an inclusive maximum
value. To be valid, a value must be less than or equal to the value
of <tt class="literal">xs:maxInclusive</tt>.
</p>

<p>This facet constrains the value space.</p>


<h4 class="refsect1">Restrictions</h4>


<p>It is forbidden to define both <tt class="literal">xs:maxExclusive</tt> and
<tt class="literal">xs:maxInclusive</tt> in the same restriction step.
Although not explicitly specified in the Recommendation, it
doesn't make sense to define several
<tt class="literal">xs:maxInclusive</tt> facets in a single restriction
step either.
</p>

<p>Within a restriction step, <tt class="literal">xs:maxInclusive</tt> is also
dependent on <tt class="literal">xs:minExclusive</tt> and
<tt class="literal">xs:minInclusive</tt>, since using inconsistent values
leads to datatypes with empty value spaces.
</p>

<p><tt class="literal">xs:maxInclusive</tt> must restrict the value space of
its base type, and its value must be in the value space of the base
type.
</p>

<p>Fixing the <tt class="literal">maxInclusive</tt> facet
doesn't fix the <tt class="literal">xs:maxExclusive</tt>
facet. To fix both facets, define two restriction steps since it is
forbidden to apply these two facets in the same restriction step.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="thousands"&gt;
  &lt;xs:restriction base="xs:double"&gt;
    &lt;xs:maxInclusive value="1e3"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">fixed</tt>, the value of this facet cannot
be changed in further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet (must be in the value space of the base type).</p>
</dd>

</dl>

</div>

<a name="ch15-77408" /><a name="INDEX-1092" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:maxLength</b></font></td><td align="right"><i>Facet to define a maximum length.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:maxLength
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:maxLength&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for:xs:anyURI, xs:base64Binary, xs:ENTITIES,
xs:ENTITY, xs:hexBinary, xs:ID, xs:IDREF, xs:IDREFS, xs:language,
xs:Name, xs:NCName, xs:NMTOKEN, xs:NMTOKENS, xs:normalizedString,
xs:NOTATION, xs:QName, xs:string, xs:token
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:maxLength</tt> is a facet that allows the definition
of the maximum length expressed in a unit that depends on the
datatype. For most of the datatypes, the unit is a character as
defined in the XML 1.0 Recommendation (i.e., Unicode characters
defined by ISO/IEC 10646 that may be represented on more than 8
bits). The exceptions are the binary datatypes
(<tt class="literal">xs:hexBinary</tt> and
<tt class="literal">xs:base64Binary</tt>), for which lengths are expressed
in number of bytes (8 bits) of binary data, and all the list
datatypes, for which lengths are expressed in number of list items.
</p>

<p><tt class="literal">xs:maxLength</tt> constrains the value space. In
practice, this means that it is checked after whitespace replacement
and collapsing, as defined by the <tt class="literal">xs:whiteSpace</tt>
facet.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>This is a logical length, which often has no direct relation to the
size of storage needed for the value.
</p>

<p>It is forbidden to define both <tt class="literal">xs:maxLength</tt> and
<tt class="literal">xs:length</tt> in the same restriction step. Although
not explicitly specified in the Recommendation, it
doesn't make sense to define several
<tt class="literal">xs:maxLength</tt> facets in a single restriction step
either.
</p>

<p>Within a restriction step, <tt class="literal">xs:maxLength</tt> is also
dependent on <tt class="literal">xs:minLength</tt>, since using
inconsistent values leads to datatypes with empty value spaces.
</p>

<p><tt class="literal">xs:maxLength</tt> must restrict the value space of its
base type, and its value must be smaller than the value of
<tt class="literal">xs:maxLength</tt> of its base type, if defined.
</p>

<p>Although not specified in the Recommendation,
<tt class="literal">xs:maxLength</tt> interacts with the
<tt class="literal">xs:length</tt> and shouldn't be used
if <tt class="literal">xs:length</tt> is defined for its base type.
</p>

<p>Fixing the <tt class="literal">xs:maxLength</tt> facet
doesn't fix the <tt class="literal">xs:length</tt> facet.
To fix both facets, define two restriction steps since it is
forbidden to apply these two facets in the same restriction step.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="binaryImage"&gt;
  &lt;xs:restriction base="xs:hexBinary"&gt;
    &lt;xs:maxLength value="1024"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">true</tt>, the value of the facet cannot be
modified during further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet.</p>
</dd>

</dl>

</div>

<a name="ch15-77419" /><a name="INDEX-1093" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:minExclusive</b></font></td><td align="right"><i>Facet to define a minimum (exclusive) value.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:minExclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:minExclusive&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for: xs:byte, xs:date, xs:dateTime, xs:decimal,
xs:double, xs:duration, xs:float, xs:gDay, xs:gMonth, xs:gMonthDay,
xs:gYear, xs:gYearMonth, xs:int, xs:integer, xs:long,
xs:negativeInteger, xs:nonNegativeInteger, xs:nonPositiveInteger,
xs:positiveInteger, xs:short, xs:time, xs:unsignedByte,
xs:unsignedInt, xs:unsignedLong, xs:unsignedShort
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:minExclusive</tt> defines an exclusive minimum
value. To be valid, a value must be strictly greater than the value
of <tt class="literal">xs:minExclusive</tt>.
</p>

<p>This facet constrains the value space.</p>


<h4 class="refsect1">Restrictions</h4>


<p>It is forbidden to define both <tt class="literal">xs:minExclusive</tt> and
<tt class="literal">xs:minInclusive</tt> in the same restriction step.
Although not explicitly specified in the Recommendation, it
doesn't make sense to define several
<tt class="literal">xs:minExclusive</tt> facets in a single restriction
step either.
</p>

<p>Within a restriction step, <tt class="literal">xs:minExclusive</tt> is also
dependent on <tt class="literal">xs:maxExclusive</tt> and
<tt class="literal">xs:maxInclusive</tt>, since using inconsistent values
leads to datatypes with empty value spaces.
</p>

<p><tt class="literal">xs:minExclusive</tt> must restrict the value space of
its base type, and its value must be in the value space of the base
type.
</p>

<p>Fixing the <tt class="literal">xs:minExclusive</tt> facet
doesn't fix the <tt class="literal">xs:minInclusive</tt>
facet. To fix both facets, define two restriction steps since it is
forbidden to apply these two facets in the same restriction step.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="afterTeaTimeInParisInSummer"&gt;
  &lt;xs:restriction base="xs:time"&gt;
    &lt;xs:minExclusive value="17:00:00+02:00"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">fixed</tt>, the value of this facet cannot
be changed in further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet (must be in the value space of the base type).</p>
</dd>

</dl>

</div>

<a name="ch15-77430" /><a name="INDEX-1094" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:minInclusive</b></font></td><td align="right"><i>Facet to define a minimum (inclusive) value.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:minInclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:minInclusive&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for: xs:byte, xs:date, xs:dateTime, xs:decimal,
xs:double, xs:duration, xs:float, xs:gDay, xs:gMonth, xs:gMonthDay,
xs:gYear, xs:gYearMonth, xs:int, xs:integer, xs:long,
xs:negativeInteger, xs:nonNegativeInteger, xs:nonPositiveInteger,
xs:positiveInteger, xs:short, xs:time, xs:unsignedByte,
xs:unsignedInt, xs:unsignedLong, xs:unsignedShort
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:minInclusive</tt> defines an inclusive minimum
value. To be valid, a value must be greater than or equal to the
value of <tt class="literal">xs:minInclusive</tt>.
</p>

<p>This facet constrains the value space.</p>


<h4 class="refsect1">Restrictions</h4>


<p>It is forbidden to define both <tt class="literal">xs:minInclusive</tt> and
<tt class="literal">xs:minExclusive</tt> in the same restriction step.
Although not explicitly specified in the Recommendation, it
doesn't make sense to define several
<tt class="literal">xs:minInclusive</tt> facets in a single restriction
step either.
</p>

<p>Within a restriction step, <tt class="literal">xs:minInclusive</tt> is also
dependent on <tt class="literal">xs:maxExclusive</tt> and
<tt class="literal">xs:maxInclusive</tt>, since using inconsistent values
leads to datatypes with empty value spaces.
</p>

<p><tt class="literal">xs:minInclusive</tt> must restrict the value space of
its base type, and its value must be in the value space of the base
type.
</p>

<p>Fixing the <tt class="literal">xs:minInclusive</tt> facet
doesn't fix the <tt class="literal">xs:minExclusive</tt>
facet. To fix both facets, define two restriction steps since it is
forbidden to apply these two facets in the same restriction step.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="positive"&gt;
  &lt;xs:restriction base="xs:double"&gt;
    &lt;xs:minInclusive value="0"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">fixed</tt>, the value of this facet cannot
be changed in further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet (must be in the value space of the base type).</p>
</dd>

</dl>

</div>

<a name="ch15-77441" /><a name="INDEX-1095" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:minLength</b></font></td><td align="right"><i>Facet to define a minimum length.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:minLength
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:minLength&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for: xs:anyURI, xs:base64Binary, xs:ENTITIES,
xs:ENTITY, xs:hexBinary, xs:ID, xs:IDREF, xs:IDREFS, xs:language,
xs:Name, xs:NCName, xs:NMTOKEN, xs:NMTOKENS, xs:normalizedString,
xs:NOTATION, xs:QName, xs:string, xs:token
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:minLength</tt> is a facet that allows definition of
the minimum length expressed in a unit that depends on the datatype.
For most of the datatypes, the unit is the character as defined in
the XML 1.0 Recommendation (i.e., Unicode characters defined by
ISO/IEC 10646 that may be represented on more than 8 bits). The
exceptions are the binary datatypes (<tt class="literal">xs:hexBinary</tt>
and <tt class="literal">xs:base64Binary</tt>), for which lengths are
expressed in number of bytes (8 bits) of binary data, and all the
list datatypes, for which lengths are expressed in number of list
items.
</p>

<p><tt class="literal">xs:minLength</tt> constrains the value space. In
practice, this means that it is checked after whitespace replacement
and collapsing, as defined by the <tt class="literal">xs:whiteSpace</tt>
facet.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>This is a logical length, which often has no direct relation on the
size of storage needed for the value.
</p>

<p>It is forbidden to define both <tt class="literal">xs:minLength</tt> and
<tt class="literal">xs:length</tt> in the same restriction step. Although
not explicitly specified in the Recommendation, it
doesn't make sense to define several
<tt class="literal">xs:minLength</tt> facets in a single restriction step
either.
</p>

<p>Within a restriction step, <tt class="literal">xs:minLength</tt> is also
dependent on <tt class="literal">xs:maxLength</tt>, since using
inconsistent values leads to datatypes with empty value spaces.
</p>

<p><tt class="literal">xs:minLength</tt> must restrict the value space of its
base type, and its value must be greater than the value of
<tt class="literal">xs:minLength</tt> of its base type if defined.
</p>

<p>Although not specified in the Recommendation,
<tt class="literal">xs:minLength</tt> interacts with
<tt class="literal">xs:length</tt> and shouldn't be used
if <tt class="literal">xs:length</tt> is defined for its base type.
</p>

<p>Fixing the <tt class="literal">xs:minLength</tt> facet
doesn't fix the <tt class="literal">xs:length</tt> facet.
To fix both facets, define two restriction steps since it is
forbidden to apply these two facets in the same restriction step.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="longName"&gt;
  &lt;xs:restriction base="xs:NCName"&gt;
    &lt;xs:minLength value="6"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">true</tt>, the value of the facet cannot be
modified during further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet.</p>
</dd>

</dl>

</div>

<a name="ch15-77452" /><a name="INDEX-1096" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:notation</b></font></td><td align="right"><i>Declaration of a notation.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:notation
           id            = xs:ID
           name          = xs:NCName
           public        = xs:token
           system        = xs:anyURI
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:notation&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:schema</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:notation</tt> is used to declare a notation just
like the NOTATION declarations in DTDs. The main difference is that
W3C XML Schema notations are namespace-aware and can be imported
between schemas. When these declarations are used, the notations are
used in <tt class="literal">xs:enumeration</tt> facets to create simple
types.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>Notations are very seldom used in real world applications.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:notation name="jpeg" public="image/jpeg"
  system="file:///usr/bin/xv"/&gt;  
 
&lt;xs:notation name="gif" public="image/gif"
  system="file:///usr/bin/xv"/&gt;  
 
&lt;xs:notation name="png" public="image/png"
  system="file:///usr/bin/xv"/&gt;  
 
&lt;xs:notation name="svg" public="image/svg"
  system="file:///usr/bin/xsmiles"/&gt;  
 
&lt;xs:notation name="pdf" public="application/pdf"
  system="file:///usr/bin/acroread"/&gt;

&lt;xs:simpleType name="graphicalFormat"&gt;
  &lt;xs:restriction base="xs:NOTATION"&gt;
    &lt;xs:enumeration value="jpeg"/&gt;
    &lt;xs:enumeration value="gif"/&gt;
    &lt;xs:enumeration value="png"/&gt;
    &lt;xs:enumeration value="svg"/&gt;
    &lt;xs:enumeration value="pdf"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Name of the notation (unqualified).</p>
</dd>


<dt><tt class="literal">public</tt></dt>
<dd>
Public identifier (usually its content type).</p>
</dd>


<dt><tt class="literal">system</tt></dt>
<dd>
System identifier (typically the location of a resource that might be
used to process the content type associated with the notation).
</p>
</dd>

</dl>

</div>

<a name="ch15-77465" /><a name="INDEX-1097" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:pattern</b></font></td><td align="right"><i>Facet to define a regular expression pattern constraint.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:pattern
           id             = xs:ID
           value          = anySimpleType
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:pattern&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for:xs:anyURI, xs:base64Binary, xs:boolean,
xs:byte, xs:date, xs:dateTime, xs:decimal, xs:double, xs:duration,
xs:ENTITY, xs:float, xs:gDay, xs:gMonth, xs:gMonthDay, xs:gYear,
xs:gYearMonth, xs:hexBinary, xs:ID, xs:IDREF, xs:int, xs:integer,
xs:language, xs:long, xs:Name, xs:NCName, xs:negativeInteger,
xs:NMTOKEN, xs:nonNegativeInteger, xs:nonPositiveInteger,
xs:normalizedString, xs:NOTATION, xs:positiveInteger, xs:QName,
xs:short, xs:string, xs:time, xs:token, xs:unsignedByte,
xs:unsignedInt, xs:unsignedLong, xs:unsignedShort
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:pattern</tt> allows the definition of regular
expression patterns over the lexical space. The syntax used for these
patterns has been borrowed from Perl regular expressions, and has
been enhanced to support the Unicode character blocks.
</p>

<p>When multiple <tt class="literal">xs:pattern</tt> facets are defined in a
single derivation step, a value is considered valid if it matches at
least one of the patterns, meaning that a logical
<tt class="literal">or</tt> is performed on all the patterns defined in a
same derivation step.
</p>

<p>Patterns are applied to the lexical space of the base datatype,
meaning that a logical <tt class="literal">and</tt> is performed on
patterns defined in different derivation steps.
</p>

<p>The syntax of these patterns is explained in more detail in <a href="ch06_01.htm">Chapter 6, "Using Regular Expressions to Specify Simple Datatypes"</a>. 
</p>


<h4 class="refsect1">Restrictions</h4>


<p><tt class="literal">xs:pattern</tt> is a common workaround to define
datatypes that look like datatypes missing from the list of
predefined datatypes. It is possible, for instance, to simulate
decimals using a separator other than the decimal point with a
pattern. Such datatypes need to be based on
<tt class="literal">xs:token</tt>, and will still not have the semantic of
<tt class="literal">xs:decimal</tt> and its list of facets.
</p>

<p><tt class="literal">xs:pattern</tt> cannot be fixed.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="nonScientific"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:pattern value="[^eE]*"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;


&lt;xs:simpleType name="noLeading0"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:pattern value="[^0].*"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet.</p>
</dd>

</dl>

</div>

<a name="ch15-77474" /><a name="INDEX-1098" /><a name="INDEX-1099" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:redefine</b></font></td><td align="right"><i>Inclusion of a W3C XML Schema for the same namespace with possible override.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:redefine
           id             = xs:ID
           schemaLocation = xs:anyURI
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation | (xs:simpleType | xs:complexType | xs:group |
                      xs:attributeGroup))*
&lt;/xs:redefine&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:schema</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:redefine</tt> is similar to
<tt class="literal">xs:include</tt> with one exception: the definition of
simple and complex types and attribute and element groups can be
changed. Changes performed on these components must lead to
components that are valid restrictions or extensions of the original
ones.
</p>

<p>Simple and complex types are redefined using the usual mechanism of
derivation: the new types must be defined as derivations by
restriction or extension of their previous definition, which is
considered to be the base type.
</p>

<p>Element and attribute groups are redefined by giving a new
definition, and may refer to themselves to indicate that the content
of their original definition must be included. In this case, this
self-reference is not considered a recursive definition (which is
forbidden in element and attribute groups), but an extension of the
original group.
</p>

<p>When <tt class="literal">xs:redefine</tt> is used and no redefinitions are
specified, its effect is similar to <tt class="literal">xs:include</tt>.
</p>


<h4 class="refsect1">Restrictions</h4>


<p><tt class="literal">xs:redefine</tt> can be used only to include schemas
with either the same target namespace or no target namespace. There
is no equivalent to import and redefine schema definitions in a
single operation. The schema must be redefined and imported in two
different operations.
</p>

<p>Arbitrary redefinitions are not allowed. After redefinition, the
components must be valid derivations (by extension or restriction) of
their definitions before redefinition.
</p>

<p><tt class="literal">xs:element</tt>, <tt class="literal">xs:attribute</tt>, and
<tt class="literal">xs:notation</tt> cannot be redefined.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:redefine schemaLocation="complex-types2.xsd"&gt;
  &lt;xs:complexType name="book"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="book"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="isbn"/&gt;
          &lt;xs:element ref="title"/&gt; 
          &lt;xs:element ref="author" minOccurs="0"
            maxOccurs="unbounded"/&gt; 
          &lt;xs:element ref="character" minOccurs="0"
            maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="id" type="bookID"/&gt;
        &lt;xs:attribute ref="available"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:redefine&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">schemaLocation</tt></dt>
<dd>
Location of the schema to <a name="INDEX-1099" />redefine. 
</p>
</dd>

</dl>

</div>

<a name="ch15-48510" /><a name="INDEX-1100" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:restriction(simple type)</b></font></td><td align="right"><i>Derivation of a simple datatype by restriction.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:restriction
           base          = xs:QName
           id            = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:simpleType?, (xs:minExclusive |
                      xs:minInclusive | xs:maxExclusive | xs:maxInclusive |
                      xs:totalDigits | xs:fractionDigits | xs:length |
                      xs:minLength | xs:maxLength | xs:enumeration |
                      xs:whiteSpace | xs:pattern)*))
&lt;/xs:restriction&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:simpleType (local definition), xs:simpleType
(global definition)
</p>
<h4 class="refsect1">Description</h4>


<p>Deriving a simple datatype by restriction is the action of defining a
new datatype by adding constraints (called facets) on a base datatype
to restrict its lexical and value spaces.
</p>

<p>The base datatype can be defined by reference (using the
<tt class="literal">base</tt> attribute) or inline (through a
<tt class="literal">xs:simpleType</tt> element defining a local datatype).
</p>

<p>Each of the facets is defined as a child element after the optional
embedded <tt class="literal">xs:simpleType</tt> definition.
</p>

<p>Each facet has its own meaning and depending on the facet, acts on
the lexical space, on the value space, or on the whitespace
transformation performed between the lexical and value spaces.
Depending on the base datatype, a facet may also have a different
behavior. See the detailed description of each facet in this chapter
for more information.
</p>

<p>Derivations by restrictions can be applied to any type of datatype
(atomic, list, or union), and don't change the type
of the datatype (atomic, list, and union datatypes stay atomic, list,
or union, after a derivation by restriction).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The same element name (<tt class="literal">xs:restriction</tt>) is used in
three different contexts with highly different meanings. Be careful
to distinguish restriction in the context of a simple datatype, a
simple content model, and a complex content model.
</p>

<p>The <tt class="literal">base</tt> attribute and the
<tt class="literal">xs:simpleType</tt> embedded definition must not be used
together (the base type is defined either by reference or embedded).
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="myInteger"&gt;
  &lt;xs:restriction base="xs:integer"&gt;
    &lt;xs:minInclusive value="-2"/&gt;
    &lt;xs:maxExclusive value="5"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">base</tt></dt>
<dd>
Qualified name of the base datatype when defined by reference.</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77492" /><a name="INDEX-1101" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:restriction(simple content)</b></font></td><td align="right"><i>Derivation of a simple content model by restriction.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:restriction
           base          = xs:QName
           id            = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:simpleType?, (xs:minExclusive |
                      xs:minInclusive | xs:maxExclusive | xs:maxInclusive |
                      xs:totalDigits | xs:fractionDigits | xs:length |
                      xs:minLength | xs:maxLength | xs:enumeration | xs:whiteSpace |
                      xs:pattern)*)?, ((xs:attribute | xs:attributeGroup)*,
                      xs:anyAttribute?))
&lt;/xs:restriction&gt;           
</pre></td><td align="right" /></tr></table>May be included in: xs:simpleContent</p>
<h4 class="refsect1">Description</h4>


<p>The restriction of simple content complex types is an operation that
allows the addition of new constraints to both the attributes and the
text node allowed in simple content elements (this reduces the set of
valid instances structures). The restriction of the text node is done
using the same facets that are available for restricting simple
types; the restriction of the attributes is done by providing a list
of modified attribute definitions or references. The attribute types
used in this list must be identical or explicit derivations by
restriction of the types used during the definition of the base type.
The controls applied to the attributes must result in a restriction
of their definition (for instance, a value may be fixed, an attribute
that was optional may become either required or prohibited, etc.).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The same element name (<tt class="literal">xs:restriction</tt>) is used in
three different contexts with highly different meanings. Be careful
to distinguish restriction in the context of a simple datatype, a
simple content model, and a complex content model.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="title"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:restriction base="tokenWithLangAndNote"&gt;
        &lt;xs:maxLength value="255"/&gt;
        &lt;xs:attribute name="lang"&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:restriction base="xs:language"&gt;
              &lt;xs:enumeration value="en"/&gt;
              &lt;xs:enumeration value="es"/&gt;
            &lt;/xs:restriction&gt;
          &lt;/xs:simpleType&gt;
        &lt;/xs:attribute&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">base</tt></dt>
<dd>
Qualified name of the base type.</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77501" /><a name="INDEX-1102" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:restriction(complex content)</b></font></td><td align="right"><i>Derivation of a complex content model by restriction.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:restriction
           base          = xs:QName
           id            = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:group | xs:all | xs:choice | xs:sequence)?,
                      ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?))
&lt;/xs:restriction&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:complexContent</p>
<h4 class="refsect1">Description</h4>


<p>The restriction of a complex content complex type is an operation
that allows the addition of new constraints to both the attributes
and child elements in complex content elements (this reduces the set
of valid instances structures). It can be seen as a declaration of
intention that a new content model is a subset of a base content
model (the declaration by intention is checked by the schema
processors). The new content model is entirely described under
<tt class="literal">xs:restriction</tt> and must represent a restriction to
what was allowed by the base content model (i.e., any content valid
per the restricted type must also be valid per the base type). The
only exception is attributes whose description may be skipped under
<tt class="literal">xs:restriction</tt>, if not changed.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>To facilitate the checking done by schema processors, the new derived
content model must follow the definition of the base type particle
per particle. Each of them must be explicit derivations by
restriction.
</p>

<p>The same element name (<tt class="literal">xs:restriction</tt>) is used in
three different contexts with highly different meanings. Be careful
to be able to distinguish restrictions in the context of a simple
datatype, a simple content model, and a complex content model.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="author"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="person"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="name"/&gt;
          &lt;xs:element ref="born"/&gt;
          &lt;xs:element ref="dead" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">base</tt></dt>
<dd>
Qualified name of the base type.</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77510" /><a name="INDEX-1103" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:schema</b></font></td><td align="right"><i>Document element of a W3C XML Schema.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:schema
           attributeFormDefault = ( "qualified" | "unqualified" ) : "unqualified"
           blockDefault         = ( "#all" | list of ( "extension" | "restriction" |
                                    "substitution" ) ) : ""
           elementFormDefault   = ( "qualified" | "unqualified" ) : "unqualified"
           finalDefault         = ( "#all" | list of ( "extension" | "restriction" )
                                    ) : ""
           id                   = xs:ID
           targetNamespace      = xs:anyURI
           version              = xs:token
           xml:lang             = xml:lang
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:include | xs:import | xs:redefine | xs:annotation)*, (,
                      ( | (xs:simpleType | xs:complexType | xs:group |
                      xs:attributeGroup) | xs:element | xs:attribute |
                      xs:notation), xs:annotation*)*)
&lt;/xs:schema&gt;
</pre></td><td align="right" /></tr></table>May be included in: (must be root element)</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:schema</tt> is the document (root) element of any
W3C XML Schema. It's both a container for all the
declarations and definitions of the schema and a place holder for a
number of default values expressed as attributes. The compositors
embedded directly under <tt class="literal">xs:schema</tt> have a special
role, since they are considered global definitions that can be
referenced elsewhere.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>A <tt class="literal">xs:schema</tt> element (and therefore a schema) is
associated with a maximum of one namespace and must import the
definitions of compositors for other namespaces if needed.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xs:element name="name" type="xs:string"/&gt;
  &lt;xs:element name="qualification" type="xs:string"/&gt;
  &lt;xs:element name="born" type="xs:date"/&gt;
  &lt;xs:element name="dead" type="xs:date"/&gt;
  &lt;xs:element name="isbn" type="xs:NMTOKEN"/&gt;
  &lt;xs:attribute name="id" type="xs:ID"/&gt;
  &lt;xs:attribute name="available" type="xs:boolean"/&gt;
  &lt;xs:attribute name="lang" type="xs:language"/&gt;
  .../...
&lt;/xs:schema&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">attributeFormDefault</tt></dt>
<dd>
Default value for the <tt class="literal">form</tt> attributes of
<tt class="literal">xs:attribute</tt>, determining whether attributes will
be namespace-qualified by default.
</p>
</dd>


<dt><tt class="literal">blockDefault</tt></dt>
<dd>
Default value of the <tt class="literal">block</tt> attribute of
<tt class="literal">xs:element</tt> and <tt class="literal">xs:complexType</tt>.
</p>
</dd>


<dt><tt class="literal">elementFormDefault</tt></dt>
<dd>
Default value for the <tt class="literal">form</tt> attributes of
<tt class="literal">xs:element</tt>, determining whether attributes will be
namespace-qualified by default
</p>
</dd>


<dt><tt class="literal">finalDefault</tt></dt>
<dd>
Default value of the <tt class="literal">final</tt> attribute of
<tt class="literal">xs:element</tt> and <tt class="literal">xs:complexType</tt>.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">targetNamespace</tt></dt>
<dd>
Namespace attached to this schema. All the qualified elements and
attributes defined in this schema will belong to this namespace. This
namespace will also be attached to all the global components.
</p>
</dd>


<dt><tt class="literal">version</tt></dt>
<dd>
Version of the schema (for user convenience).</p>
</dd>


<dt><tt class="literal">xml</tt></dt>
<dd>
Language of the schema.</p>
</dd>

</dl>

</div>

<a name="ch15-77531" /><a name="INDEX-1104" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:selector</b></font></td><td align="right"><i>Definition of the the path selecting an element for a uniqueness constraint.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:selector
           id             = xs:ID
           xpath          = xs:token
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:selector&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:key, xs:keyref, xs:unique</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:selector</tt> is used to define the element on which
a uniqueness constraint or reference is checked (it cannot be an
attribute, since attributes are already unique per XML 1.0). It is
identified by a relative XPath expression.
</p>

<p>The constraint is checked while looping on the XPath expression is
resolved relative to the root element of the constraint. It serves as
the location from which <tt class="literal">xs:field</tt> XPath expressions
are resolved.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>The <tt class="literal">xpath</tt> attribute uses a simple subset of XPath
1.0. The motivation of the W3C XML Schema Working Group for defining
this subset is to simplify the work of the implementers of schema
processors, and also to define a subset that constrains the path to
stay within the scope of the current element.
</p>

<p>This subset is restricted to use the child only; self and descendant,
and self XPath axes through their abbreviated syntaxes without
including any test in any of the XPath location steps and without
using any XPath functions. It is identical to the subset defined for
<tt class="literal">xs:field</tt>, except that attributes are allowed in
<tt class="literal">xs:field</tt> and forbidden in
<tt class="literal">xs:selector</tt>.
</p>

<p>The formal extended BNF given in the W3C Recommendation is as follow:</p>

<blockquote><pre class="code">Selector ::= Path ( '|' Path )* Path ::= ('.//')? Step ( '/' Step )* Step ::= '.' | 
NameTest NameTest ::= QName | '*' | NCName ':' '*'</pre></blockquote>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="book" maxOccurs="unbounded"&gt;
  &lt;xs:complexType&gt;
    .../...
  &lt;/xs:complexType&gt;
  &lt;xs:unique name="book"&gt;
    &lt;xs:selector xpath="book"/&gt;
    .../...
  &lt;/xs:unique&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">xpath</tt></dt>
<dd>
Relative XPath expression identifying the element on which the
constraint applies.
</p>
</dd>

</dl>

</div>

<a name="ch15-67662" /><a name="INDEX-1105" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:sequence(outside a group)</b></font></td><td align="right"><i>Compositor to define an ordered group of elements.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:sequence
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs          = xs:nonNegativeInteger : "1"
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:element | xs:group | xs:choice |
                      xs:sequence | xs:any) )*)
&lt;/xs:sequence&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:choice (outside a group), xs:choice (within a
group), xs:complexType (local definition), xs:complexType (global
definition), xs:extension (complex content), xs:restriction (complex
content), xs:sequence (within a group), xs:sequence (outside a group)
</p>
<h4 class="refsect1">Description</h4>


<p>This compositor is used to define an ordered list or set of elements.
It can hold its own <tt class="literal">minOccurs</tt> and
<tt class="literal">maxOccurs</tt> attributes to define a number of
occurrences of the whole sequence.
</p>


<h4 class="refsect1">Restrictions</h4>


<p><tt class="literal">xs:sequence</tt> may not be included in an
<tt class="literal">xs:all</tt> compositor, and
<tt class="literal">xs:sequence</tt> may not include
<tt class="literal">xs:all</tt> compositors.
</p>

<p>When <tt class="literal">xs:sequence</tt> is included in an
<tt class="literal">xs:group</tt> compositor, its content model is slightly
different (see <a href="ch15_01.htm">xs:sequence(within a group)</a> (within a
group)).
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="library"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="book" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">maxOccurs</tt></dt>
<dd>
Maximum number of occurrences.</p>
</dd>


<dt><tt class="literal">minOccurs</tt></dt>
<dd>
Minimum number of occurrences.</p>
</dd>

</dl>

</div>

<a name="ch15-77551" /><a name="INDEX-1106" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:sequence(within a group)</b></font></td><td align="right"><i>Compositor to define an ordered group of elements. The number of occurrences cannot be defined when xs:all is used within a group.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:sequence
           id          = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:element | xs:group | xs:choice |
                      xs:sequence | xs:any) )*)
&lt;/xs:sequence&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:group (definition)</p>
<h4 class="refsect1">Description</h4>


<p>This compositor is used to define ordered list of elements.</p>


<h4 class="refsect1">Restrictions</h4>


<p><tt class="literal">xs:sequence</tt> may not include
<tt class="literal">xs:all</tt> compositors.
</p>

<p>When <tt class="literal">xs:sequence</tt> is used outside an
<tt class="literal">xs:group</tt> compositor, its content model is slightly
different (see <a href="ch15_01.htm">xs:sequence(outside a group)</a> (outside a
group)).
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:group name="name"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element ref="name"/&gt;
    &lt;xs:sequence minOccurs="0"&gt;
      &lt;xs:element ref="middle-name" minOccurs="0"/&gt;
      &lt;xs:element ref="last-name"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:group&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77558" /><a name="INDEX-1107" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:simpleContent</b></font></td><td align="right"><i>Simple content model declaration.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:simpleContent
           id          = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:restriction | xs:extension))
&lt;/xs:simpleContent&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:complexType (local definition), xs:complexType
(global definition)
</p>
<h4 class="refsect1">Description</h4>


<p>This element allows the definition of a simple content model by
derivation of a simple type or of another simple content complex
type. It is not a component by itself (simple contents are not named)
but rather declaration of the intention to define a simple content
model by derivation.
</p>

<p>The derivation method is not defined by the
<tt class="literal">xs:simpleContent</tt> element, but by the choice of its
child element (which is <tt class="literal">xs:restriction</tt> for a
derivation by restriction, or <tt class="literal">xs:extension</tt> for a
derivation by extension).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>None.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="title"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xs:string"&gt;
        &lt;xs:attribute ref="lang"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-64918" /><a name="INDEX-1108" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:simpleType(global definition)</b></font></td><td align="right"><i>Global simple type declaration that can be referenced within the same schema by other schemas.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:simpleType
           final         = ( "#all" | ( "list" | "union" | "restriction" ) )
           id            = xs:ID
           name          = xs:NCName
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:restriction | xs:list | xs:union))
&lt;/xs:simpleType&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:redefine, xs:schema</p>
<h4 class="refsect1">Description</h4>


<p>Global user-defined simple datatypes are defined directly under the
<tt class="literal">xs:schema</tt> document element (or redefined using
<tt class="literal">xs:redefine</tt>) outside of the scope of any specific
content model. They can be referenced through their qualified name in
the same schema or by any other schema that has included or imported
this schema.
</p>

<p>Like local simple datatypes, these are defined by derivation from
other simple datatypes (either predefined by W3C XML Schema or other
user-defined datatypes) using one of the three derivation methods
available for simple types: <tt class="literal">xs:restriction</tt> to add
new constraints to a datatype, <tt class="literal">xs:list</tt> to define
lists of values, and <tt class="literal">xs:union</tt> to perform the union
of the lexical spaces of several datatypes).
</p>

<p>The <tt class="literal">name</tt> attribute is unqualified since the
datatype is considered to belong to the target namespace of the
schema in which it is defined. During a reference, the prefix that
has been defined for this namespace needs to be added.
</p>

<p>Although simple datatypes are considered to belong to the target
namespace of schema in which they are defined, they can be referenced
to create new datatypes, attributes, or elements for any namespace.
</p>

<p>Further derivations (by list, union, restriction, or all) can be
blocked using the <tt class="literal">final</tt> attribute.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>W3C XML Schema doesn't provide any mechanism to add
new primary datatypes, new facets, or to act on the transformation
performed between the lexical and value spaces (for instance, it is
not possible to change the representation of the decimal point).
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="totalDigits"&gt;
  &lt;xs:restriction base="xs:integer"&gt;
    &lt;xs:totalDigits value="5"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">final</tt></dt>
<dd>
When set, this attribute blocks any further derivations of this
datatype (by list, union, derivation, or all).
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Unqualified name of this datatype.</p>
</dd>

</dl>

</div>

<a name="ch15-77576" /><a name="INDEX-1109" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:simpleType(local definition)</b></font></td><td align="right"><i>Local simple type definition (local definitions cannot be referenced).
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:simpleType
           id          = xs:ID
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?, (xs:restriction | xs:list | xs:union))
&lt;/xs:simpleType&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:attribute (reference or local definition),
xs:attribute (global definition), xs:element (within xs:all),
xs:element (reference or local definition), xs:element (global
definition), xs:list, xs:restriction (simple type), xs:restriction
(simple content), xs:union
</p>
<h4 class="refsect1">Description</h4>


<p>Local simple datatypes are defined directly where needed (during
element, attribute, or other simple type definitions) for local
anonymous usage, and cannot be referenced as such in other places of
a schema.
</p>

<p>Like global simple datatypes, these are defined by derivation from
other simple datatypes (either predefined by W3C XML Schema or other
user-defined datatypes) using one of the three derivation methods
available for simple types: <tt class="literal">xs:restriction</tt> to add
new constraints to a datatype, <tt class="literal">xs:list</tt> to define
lists of values, and <tt class="literal">xs:union</tt> to perform the union
of the lexical spaces of several datatypes).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>W3C XML Schema doesn't provide any mechanism for
creating new primary datatypes, new facets, or to act on the
transformation performed between the lexical and value spaces (for
instance, it is not possible to change the representation of the
decimal point).
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="myInteger"&gt;
  &lt;xs:restriction&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:integer"&gt;
        &lt;xs:maxExclusive value="5"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:minInclusive value="-2"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>

</dl>

</div>

<a name="ch15-77583" /><a name="INDEX-1110" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:totalDigits</b></font></td><td align="right"><i>Facet to define the total number of digits of a numeric datatype.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:totalDigits
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:positiveInteger
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:totalDigits&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for: xs:byte, xs:decimal, xs:int, xs:integer,
xs:long, xs:negativeInteger, xs:nonNegativeInteger,
xs:nonPositiveInteger, xs:positiveInteger, xs:short, xs:unsignedByte,
xs:unsignedInt, xs:unsignedLong, xs:unsignedShort
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:totalDigits</tt> defines the maximum number of
digits of decimal and derived datatypes (both after and before the
decimal point, not counting the decimal point itself).
</p>

<p>This facet constrains the value space, which means that the number of
digits is checked after the value is transformed to its canonical
form and the leading and trailing zeros are removed.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>It is also possible to use <tt class="literal">xs:pattern</tt> to constrain
the number of total digits in the lexical space.
</p>

<p>Within a restriction step, <tt class="literal">xs:totalDigits</tt> is
dependent on <tt class="literal">xs:fractionDigits</tt> since using
inconsistent values leads to datatypes with empty value spaces.
</p>

<p><tt class="literal">xs:totalDigits</tt> must restrict the value space of
its base type. Its value must be smaller than the value of the
<tt class="literal">xs:totalDigits</tt> of its base type if defined.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="totalDigits"&gt;
  &lt;xs:restriction base="xs:integer"&gt;
    &lt;xs:totalDigits value="5"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">true</tt>, the value of the facet cannot be
modified during further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet.</p>
</dd>

</dl>

</div>

<a name="ch15-77594" /><a name="INDEX-1111" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:union</b></font></td><td align="right"><i>Derivation of simple datatypes by union.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:union
           id          = xs:ID
           memberTypes = list of xs:QName
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:simpleType*))
&lt;/xs:union&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:simpleType (local definition), xs:simpleType
(global definition)
</p>
<h4 class="refsect1">Description</h4>


<p>Deriving a simple datatype by union merges the lexical spaces of
several simple datatypes (called member types) to create a new simple
datatype.
</p>

<p>Whatever the type (atomic, list, or union) of the member types, the
resulting datatype has a type <tt class="literal">union</tt>.
</p>

<p>The member types can be defined either by reference (through the
<tt class="literal">memberTypes</tt> attribute) or embedded as simple
datatype local definitions in the <tt class="literal">xs:union</tt>
element. Both styles can be mixed.
</p>

<p>The semantic of the member datatypes is lost at least as far as
validation is concerned, and the only facets that can be further
applied to the resulting datatype are <tt class="literal">xs:pattern</tt>
and <tt class="literal">xs:enumeration</tt>.
</p>

<p>However, the semantic of the member datatypes isn't
completely lost for an application built on a PSVI, since the
validator needs to perform canonicalization according to the first
member type that matches the instance value. This implies that order
matters in the list of member types. When both styles are used, the
datatypes referenced in the <tt class="literal">memberTypes</tt> are tested
before the locally defined datatypes.
</p>


<h4 class="refsect1">Restrictions</h4>


<p>None.</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="integerOrData"&gt;
  &lt;xs:union memberTypes="xs:integer xs:date"/&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">memberTypes</tt></dt>
<dd>
List of member types (member types can also be embedded as
<tt class="literal">xs:simpleType</tt> in the <tt class="literal">xs:union</tt>
element).
</p>
</dd>

</dl>

</div>

<a name="ch15-77603" /><a name="INDEX-1112" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:unique</b></font></td><td align="right"><i>Definition of a uniqueness constraint.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:unique
           id            = xs:ID
           name          = xs:NCName
           {any attributes with non-schema namespace}
           &gt;
           Content: ((xs:annotation?), (xs:selector, xs:field+))
&lt;/xs:unique&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:element (within xs:all), xs:element (reference
or local definition), xs:element (global definition)
</p>
<h4 class="refsect1">Description</h4>


<p><tt class="literal">xs:unique</tt> is used to define simple or compound
constraints, which unambiguously identify each element in which they
are present, from a selected list of subelements within the scope of
a root element.
</p>

<p><tt class="literal">xs:unique</tt> is very similar to
<tt class="literal">xs:key</tt>. Like the constraints defined with
<tt class="literal">xs:key</tt>, constraints defined with
<tt class="literal">xs:unique</tt> are unique in the scope of their root
element and may be referenced by <tt class="literal">xs:keyref</tt>. The
only difference between <tt class="literal">xs:unique</tt> and
<tt class="literal">xs:key</tt> is that the <tt class="literal">xs:unique</tt>
keys may be undefined in any of the elements in the selection list,
while <tt class="literal">xs:key</tt> identifiers must be defined for all
the elements in the selection list.
</p>

<p>The root element for the constraint is the element in which the
constraint is defined. The location of the root element must be
carefully chosen since the unity of the constraint is checked only
within the node elements that are its children. Defining a root
element that has multiple occurrences within a document leaves the
possibility of defining local constraints that are unique only in the
scope of each occurrence of a document. When a constraint is global
to a document, defining it using the document element as a root may
cause it to be less error-prone.
</p>

<p>The contribution of <tt class="literal">xs:unique</tt> to the PSVI is a
node table in each occurrence of the root key element that contains
the list of the key sequences for this root element. The scope of
these node tables is limited to the root element in which they are
contained and all its ancestors. This scope is used to determine the
behavior of the key references and impacts the choice of the
constraint root element when the constraint is referenced (see the
section <tt class="literal"><a href="ch15_01.htm">xs:keyref</a></tt>).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>These XPath-based features do not follow the object-oriented,
namespace-aware general philosophy of W3C XML Schema. The XPath
expressions are specified independently of the
element's content model, and the constraints for the
elements of all the possible namespaces must be defined in the schema
for the namespace of the constraint root element.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:element name="library"&gt;
  &lt;xs:complexType&gt;
    .../...
  &lt;/xs:complexType&gt;
  &lt;xs:unique name="book"&gt;
    &lt;xs:selector xpath="book"/&gt;
    &lt;xs:field xpath="isbn"/&gt;
  &lt;/xs:unique&gt;
&lt;/xs:element&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">name</tt></dt>
<dd>
Name of the unique constraint.</p>
</dd>

</dl>

</div>

<a name="ch15-77612" /><a name="INDEX-1113" /><a name="INDEX-1114" /><a name="INDEX-1115" /><div class="refentry"><table width="515" border="0" cellpadding="5"><tr><td align="left"><font size="+1"><b>xs:whiteSpace</b></font></td><td align="right"><i>Facet to define whitespace behavior.
</i></td></tr></table><hr width="515" size="3" noshade="true" align="left" color="black" /><table width="515" border="0" cellpadding="5"><tr><td align="left"><pre>
&lt;xs:whiteSpace
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = ( "preserve" | "replace" | "collapse" )
           {any attributes with non-schema namespace}
           &gt;
           Content: (xs:annotation?)
&lt;/xs:whiteSpace&gt;
</pre></td><td align="right" /></tr></table>May be included in: xs:restriction (simple type), xs:restriction
(simple content)
</p><p>May be used as facet for:xs:ENTITIES, xs:ENTITY, xs:ID, xs:IDREF,
xs:IDREFS, xs:language, xs:Name, xs:NCName, xs:NMTOKEN, xs:NMTOKENS,
xs:normalizedString, xs:string, xs:token
</p>
<h4 class="refsect1">Description</h4>


<p>This facet defines the treatment to perform on whitespace--i.e.,
<tt class="literal">#x20</tt> (space), <tt class="literal">#x9</tt> (tab),
<tt class="literal">#xA</tt> (linefeed), and <tt class="literal">#xD</tt>
(carriage return)--during the transformation between the lexical
and value spaces.
</p>

<p>Its values are <tt class="literal">preserve</tt> (whitespace characters are
kept unchanged), <tt class="literal">replace</tt> (all instances of
whitespace are replaced with a space), and
<tt class="literal">collapse</tt> (leading and trailing whitespace is
removed and all the other sequences of contiguous whitespace are
replaced by a single space).
</p>


<h4 class="refsect1">Restrictions</h4>


<p>This is the only facet (or feature of W3C XML Schema) that interacts
with the canonicalization transformation.
</p>

<p>It is not possible to "relax" the
whitespace behavior during a restriction: if a datatype has a
whitespace set as <tt class="literal">preserve</tt>, its derived datatypes
can have any whitespace behavior, but if its whitespace is set as
<tt class="literal">replace</tt>, its derived datatypes can only have
whitespace equal to <tt class="literal">replace</tt> or
<tt class="literal">collapse</tt>. If its whitespace is equal to
<tt class="literal">collapse</tt>, all its derived datatypes must have the
same behavior.
</p>

<p>This limitation is somewhat paradoxical since it allows the actual
expansion of the lexical space of a datatype during a derivation by
restriction.
</p>


<h4 class="refsect1">Example</h4>

<blockquote><pre class="code">&lt;xs:simpleType name="CapitalizedNameWS"&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:whiteSpace value="collapse"/&gt;
    &lt;xs:pattern value="([A-Z]([a-z]*) ?)+"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>


<h4 class="refsect1">Attributes</h4>

<dl>
<dt><tt class="literal">fixed</tt></dt>
<dd>
When set to <tt class="literal">fixed</tt>, the value of this facet cannot
be changed in further restrictions.
</p>
</dd>


<dt><tt class="literal">id</tt></dt>
<dd>
W3C XML Schema's element ID.</p>
</dd>


<dt><tt class="literal">value</tt></dt>
<dd>
Value of the facet<a name="INDEX-1114" /> <a name="INDEX-1115" />. 
</p>
</dd>

</dl>



</div>
</div>

<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch14_05.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch16_01.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">14.5. Which One and What For?</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">16. Datatype Reference Guide</td></tr></table></div>
<hr width="684" align="left" />

<img src="../gifs/navbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
      </map>

</body></html>