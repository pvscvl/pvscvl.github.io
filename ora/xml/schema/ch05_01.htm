<html><head><title>Creating Simple Datatypes (XML Schema)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Eric van der Vlist" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596002521L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="XML Schema" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="XML Schema" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch04_08.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch05_02.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>


<h1 class="chapter">Chapter 5. Creating Simple Datatypes</h1>
<div class="htmltoc"><h4 class="tochead">Contents:</h4>
  <p> <a href="#xmlschema-CHP-5-SECT-1">Derivation By Restriction</a><br />
<a href="ch05_02.htm">Derivation By List</a><br />
<a href="ch05_03.htm">Derivation By Union</a><br />
<a href="ch05_04.htm">Some Oddities of Simple Types</a><br />
<a href="ch05_05.htm">Back to Our Library</a><br /></p></div>

<p>So far, <a name="INDEX-229" /></a>we have
used only predefined datatypes. In this chapter, we will see how to
create new simple types, taking advantage of the different derivation
mechanisms and facets of derivation by restriction.
</p>

<p>W3C XML Schema has defined three independent and complementary
mechanisms for defining our own custom datatypes, using existing
datatypes as starting points. These new user datatypes that are built
upon existing predefined datatypes or on other user datatypes are
called "derivation."
</p>

<p>The three <a name="INDEX-230" /></a>derivation methods are derivation by
restriction (where constraints are added on a datatype without
changing its original semantic or meaning), derivation by list (where
new datatypes are defined as being lists of values belonging to a
datatype and take the semantic of list datatypes), and derivation by
union (where new datatypes are defined as allowing values from a set
of other datatypes and lose most of their semantic).
</p>

<p>As with the <a name="INDEX-231" /></a><tt class="literal">xs:complexType</tt>,
definitions (which we saw in our Russian doll design) and
<a name="INDEX-232" /></a><tt class="literal"><a href="ch15_01.htm">xs:simpleType(global definition)</a></tt> can be
either named or anonymous. Despite this similarity, simple and
complex types are very different. A simple type is a restriction on
the value of an element or an attribute (i.e., a constraint on the
content of a set of documents) while a complex type is a definition
of a content model (i.e., a constraint on the markup). This is why
the derivation methods for simple and complex types are very
different, even though W3C XML Schema used the same element name
(<tt class="literal">xs:restriction</tt>) for both. This is a common source of
confusion.
</p>



<a name="ch05-3-fm2xml" /></a><blockquote><b>TIP:</b> 
These derivation methods are flexible and powerful. However, that W3C
XML Schema needs many different primary datatypes can be seen as
proof that they are not sufficient to create a new primary datatype.
The reason being that the derivation methods are only acting on the
value space or on the lexical space (as defined in <a href="ch04_01.htm">Chapter 4, "Using Predefined Simple Datatypes"</a>), but they cannot modify the relations between
these two spaces, nor create new value or lexical spaces. This
subject has been debated by the W3C XML Schema Working Group, which
has not found an agreement for ways to define an abstract datatype
system that would allow definition of several lexical
representations. The most obvious consequence of this decision is
that, despite the protestation from the W3C I18N Working Group,
<em class="emphasis">W3C XML Schema</em> doesn't allow
the definition of localized decimal or date datatypes.
<p></p>
</blockquote>
<div class="sect1"><a name="xmlschema-CHP-5-SECT-1" /></a>
<h2 class="sect1">5.1. Derivation By Restriction</h2>

<p>Restriction <a name="INDEX-233" /></a>is
<a name="INDEX-234" /></a>probably the most commonly used and
natural derivation method.Datatypes are created by restriction by
adding new constraints to the possible values. <em class="emphasis">W3C XML
Schema</em> itself has been using derivation by restriction to
define most of derived predefined datatypes, such as <tt class="literal"><a href="ch16_01.htm">xs:positiveInteger</a></tt>, which is a derivation by
restriction of <tt class="literal"><a href="ch16_01.htm">xs:integer</a></tt>. The
restrictions can be defined along different aspects or axes that
<em class="emphasis">W3C XML Schema</em> calls
"facets."
</p>

<p>A derivation by restriction is done using a <a name="INDEX-235" /></a><tt class="literal">xs:restriction</tt>
element and each facet is defined using a specific element embedded
in the <tt class="literal">xs:restriction</tt> element. The datatype on which
the restriction is applied is called the base datatype, which can be
referenced though a <tt class="literal">&lt;base&gt;</tt> attribute or
defined in the <tt class="literal">xs:restriction</tt> element:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="myInteger"&gt;
  &lt;xs:restriction base="xs:integer"&gt;
    &lt;xs:minInclusive value="-2"/&gt;
    &lt;xs:maxExclusive value="5"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>It can also be defined in two steps using an embedded <tt class="literal"><a href="ch15_01.htm">xs:simpleType(global definition)</a></tt> anonymous definition:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="myInteger"&gt;
  &lt;xs:restriction&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:integer"&gt;
        &lt;xs:maxExclusive value="5"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:minInclusive value="-2"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>The <tt class="literal"><a href="ch15_01.htm">xs:minInclusive</a></tt> and
<tt class="literal"><a href="ch15_01.htm">xs:maxExclusive</a></tt> elements are two
facets that can be applied to an integer datatype. As can be guessed
from their names, they specify the minimum inclusive (i.e., that can
be reached) and maximum exclusive (i.e., that is not allowed) values.
We will introduce the list of facets in the next section. Depending
on the facet, each acts directly either on the value space or on the
lexical space of the datatype, and the same facet may have different
effects depending on the datatype on which it is applied.
</p>

<p>Whatever facet is being applied on a datatype, the semantic of its
primitive type is unchanged, the list of facets that can be applied
cannot be extended, and one must be careful to choose, when possible,
a datatype whose primitive type matches the purpose of the node in
which it will be used. For instance, while it is possible to
constrain a string datatype to match non-ISO 8601 dates using
patterns, this solution should be used only when absolutely required
since this datatype would still be considered a string and lack
facets, such as <tt class="literal"><a href="ch15_01.htm">xs:minInclusive</a></tt> or
<tt class="literal"><a href="ch15_01.htm">xs:maxExclusive</a></tt> that are defined on
date datatypes but that have no meaning (for W3C XML Schema) on a
string.
</p>



<a name="ch05-5-fm2xml" /></a><blockquote><b>TIP:</b> 
The impact of the "right" choice of
the base datatype with a semantic as close as possible to its actual
usage in the instance documents will become more critical when W3C
XML Schema aware applications become available. Such applications
will have a different behavior depending on the datatype information
found in the PSVI. A "wrong" choice
will have side effects. For instance, the first drafts of XPath 2.0
propose to interpret values according to predefined datatypes and the
results of equality tests on values or the sort orders would depend
on the datatypes.
<p></p>
</blockquote>

<a name="xmlschema-CHP-5-SECT-1.1" /></a><div class="sect2">
<h3 class="sect2">5.1.1. Facets</h3>

<p>Before <a name="INDEX-236" /></a>we start
looking at the list of facets, we'll discuss the way
they work. They may be classified into three categories:
<tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt> defines the
whitespace processing that happens between the parser and lexical
spaces--but can be used only on <tt class="literal"><a href="ch16_01.htm">xs:string</a></tt> and <tt class="literal"><a href="ch16_01.htm">xs:normalizedString</a></tt>. <tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt> works on the lexical space; all the
other facets constrain the value space. The availability of the
facets and their effect depend on the datatype on which they are
applied. We will see them in the context of groups of datatypes
sharing the same set of facets.
</p>

<a name="xmlschema-CHP-5-SECT-1.1.1" /></a><div class="sect3">
<h3 class="sect3">5.1.1.1. Whitespace collapsed strings</h3>

<p>These <a name="INDEX-237" /></a> <a name="INDEX-238" /></a>datatypes share the fact that they are
character strings (even though technically W3C XML Schema
doesn't consider all of them as derived from the
<tt class="literal"><a href="ch16_01.htm">xs:string</a></tt> datatypes) and that
whitespaces are collapsed before validation, as defined in the
Recommendation, "all occurrences of #x9 (tab), #xA
(line feed), and #xD (carriage return) are replaced with #x20 (space)
and then, contiguous sequences of #x20s are collapsed to a single
#x20, and initial and/or final #x20s are deleted."
</p>

<p>Those datatypes are: <tt class="literal"><a href="ch16_01.htm">xs:ENTITY</a></tt>,
<tt class="literal"><a href="ch16_01.htm">xs:ID</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:IDREF</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:language</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:Name</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:NCName</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:NMTOKEN</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:token</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:anyURI</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:base64Binary</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:hexBinary</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:NOTATION</a></tt>, and <tt class="literal"><a href="ch16_01.htm">xs:QName</a></tt>. Their facets are explained in the
next section:
</p>

<a name="xmlschema-CHP-5-SECT-1.1.1.1" /></a><div class="sect4">
<h4 class="sect4">5.1.1.1.1. <a href="ch15_01.htm">xs:enumeration</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:enumeration</a></tt>
<a name="INDEX-239" /></a>allows definition of a list of
possible values. Here's an example:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="schemaRecommendations"&gt;
  &lt;xs:restriction base="xs:anyURI"&gt;
    &lt;xs:enumeration value="http://www.w3.org/TR/xmlschema-0/"/&gt;
    &lt;xs:enumeration value="http://www.w3.org/TR/xmlschema-1/"/&gt;
    &lt;xs:enumeration value="http://www.w3.org/TR/xmlschema-2/"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This facet is constraining the value space. For most of the string
(and assimilated) datatypes, lexical and values are identical and
this doesn't make any difference; however, it does
make a difference for <tt class="literal"><a href="ch16_01.htm">xs:anyURI</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:base64Binary</a></tt>, and <tt class="literal"><a href="ch16_01.htm">xs:QName</a></tt>. For instance,
"<a href="../../../../../../dmoz.org/World/Fran&#xE7%3Bais/">http://dmoz.org/World/Fran&#xE7;ais/</a>"
and "<a href="../../../../../../dmoz.org/World/Français/">http://dmoz.org/World/Fran%e7ais/</a>"
would be considered equal for <tt class="literal"><a href="ch16_01.htm">xs:anyURI</a></tt>, the line breaks would be ignored
for <tt class="literal"><a href="ch16_01.htm">xs:base64Binary</a></tt>, and the match
would be done on the tuples {namespace URI, local name} for
<tt class="literal"><a href="ch16_01.htm">xs:QName</a></tt>, ignoring the prefix
used in the schema and instance documents.
</p>

<p>One should also note that <tt class="literal"><a href="ch16_01.htm">xs:anyURI</a></tt> datatypes are not
"absolutized" by W3C XML Schema and
do not support <tt class="literal">xml:base</tt>. This means that if the
"schemaRecommendations" defined in
the previous example is assigned to a XLink <tt class="literal">href</tt>
attribute, it must fail to validate the following instance element:
</p>

<blockquote><pre class="code">&lt;a xml:base="http://www.w3.org/TR/" href="xmlschema-1/"&gt;
  XML Schema Part 2: Datatypes
&lt;/a&gt;</pre></blockquote>

<p>We cannot leave this section without discussing
<a name="INDEX-240" /></a><tt class="literal"><a href="ch16_01.htm">xs:NOTATION</a></tt>. This datatype is the only case of a
predefined datatype that cannot be used directly in a schema and must
be used through derived types specifying a set of <tt class="literal"><a href="ch15_01.htm">xs:enumeration</a></tt> facets. Even though notations are very seldom
used in real-life applications, this book wouldn't
be complete without at least an example of notations. If we take the
usual example of a picture using a notation in an attribute to
qualify the content of a binary field as follows:
</p>

<blockquote><pre class="code">&lt;?xml version="1.0"?&gt; 
&lt;picture type="png"&gt; 
 
  iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAIAAAACUFjqAAAABmJLR0QA/wD/AP+gvaeTAAAA
  CXBIWXMAAAsSAAALEgHS3X78AAAAB3RJTUUH0QofESYx2JhwGwAAAFZJREFUeNqlj8ENwDAI
  A6HqGDCWp2QQ2AP2oI9IbaQm/dRPn9EJ7m7a56DPPDgiIoKIzGyBM9Pdx+4ueXabWVUBEJHR
  nLNJVbfuqspMAEOxwO9r/vX3BTEnKRXtqqslAAAAAElFTkSuQmCC
&lt;/picture&gt;</pre></blockquote>

<p>The schema might be written as (note how the notations need to be
declared in the schema to be used in an <tt class="literal"><a href="ch15_01.htm">xs:enumeration</a></tt>
facet):
</p>

<blockquote><pre class="code">&lt;?xml version="1.0"?&gt; 
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt; 
  &lt;xs:notation name="jpeg" public="image/jpeg"
    system="file:///usr/bin/xv"/&gt; 
  &lt;xs:notation name="gif" public="image/gif"
    system="file:///usr/bin/xv"/&gt; 
  &lt;xs:notation name="png" public="image/png"
    system="file:///usr/bin/xv"/&gt; 
  &lt;xs:notation name="svg" public="image/svg"
    system="file:///usr/bin/xsmiles"/&gt; 
  &lt;xs:notation name="pdf" public="application/pdf"
    system="file:///usr/bin/acroread"/&gt;
  &lt;xs:simpleType name="graphicalFormat"&gt;
    &lt;xs:restriction base="xs:NOTATION"&gt;
      &lt;xs:enumeration value="jpeg"/&gt;
      &lt;xs:enumeration value="gif"/&gt;
      &lt;xs:enumeration value="png"/&gt;
      &lt;xs:enumeration value="svg"/&gt;
      &lt;xs:enumeration value="pdf"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:element name="picture"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:simpleContent&gt;
        &lt;xs:extension base="xs:base64Binary"&gt;
          &lt;xs:attribute name="type" type="graphicalFormat"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:schema&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.1.2" /></a><div class="sect4">
<h4 class="sect4">5.1.1.1.2. <a href="ch15_01.htm">xs:length</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:length</a></tt>
<a name="INDEX-241" /></a>
<a name="INDEX-242" /></a>defines a fixed length measured in number
of characters (general case) or bytes
(<tt class="literal">xs:hexBinary</tt> and
<tt class="literal">xs:base64Binary</tt>):
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="standardNotations"&gt;
  &lt;xs:restriction base="xs:NOTATION"&gt;
    &lt;xs:length value="8"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This facet also constrains the value space. For <tt class="literal"><a href="ch16_01.htm">xs:anyURI</a></tt>, this may be difficult to predict
since the length is checked after the character normalization. For
<tt class="literal"><a href="ch16_01.htm">xs:QName</a></tt>, this is even worse
since the W3C XML Schema recommendation has not given any definition
of the length of an <tt class="literal"><a href="ch16_01.htm">xs:QName</a></tt>
tuple. Fortunately, in practice, constraining the length of these
datatypes doesn't seem to be very useful, and
it's a good idea to avoid using these constrains on
these datatypes. The same restriction applies to the next two facets.
</p>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.1.3" /></a><div class="sect4">
<h4 class="sect4">5.1.1.1.3. <a href="ch15_01.htm">xs:maxLength</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:maxLength</a></tt>
<a name="INDEX-243" /></a>defines
a maximum length measured in number of characters (general case) or
bytes (<tt class="literal">xs:hexBinary</tt> and
<tt class="literal">xs:base64Binary</tt>):
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="binaryImage"&gt;
  &lt;xs:restriction base="xs:hexBinary"&gt;
    &lt;xs:maxLength value="1024"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.1.4" /></a><div class="sect4">
<h4 class="sect4">5.1.1.1.4. <a href="ch15_01.htm">xs:minLength</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:minLength</a></tt>
<a name="INDEX-244" /></a>defines
a minimum length measured in number of characters (general case) or
bytes (hexBinary and base64Binary):
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="longName"&gt;
  &lt;xs:restriction base="xs:NCName"&gt;
    &lt;xs:minLength value="6"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.1.5" /></a><div class="sect4">
<h4 class="sect4">5.1.1.1.5. <a href="ch15_01.htm">xs:pattern</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt>
<a name="INDEX-245" /></a>defines a pattern that must be matched
by the string (we will explore patterns in more detail in the next
chapter) :
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="httpURI"&gt;
  &lt;xs:restriction base="xs:anyURI"&gt;
    &lt;xs:pattern value="http://.*"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>Several pattern facets can be defined in a single derivation step.
They are then merged together through a logical
"or" (a value will match the
restricted datatype if it matches one of the patterns).
</p>



<a name="ch05-7-fm2xml" /></a><blockquote><b>TIP:</b> 
Because of the impossibility of defining a single order that would be
useful for all the regional alphabets, <em class="emphasis">W3C XML
Schema</em> has decided to handle the string datatypes as being
unordered. The consequence is there are no facets to define minimal
or maximal values for <a name="INDEX-246" /></a> <a name="INDEX-247" /></a>string datatypes.
<p></p>
</blockquote>

</div>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.2" /></a><div class="sect3">
<h3 class="sect3">5.1.1.2. Other strings</h3>

<p>The
<a name="INDEX-248" /></a>whitespaces of these other strings are
not collapsed before validation, and a new facet (<tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt>) is available, in addition to the
facets just described, to specify the treatment to apply on
whitespaces for the user-defined datatypes derived from them.
</p>

<p>Those <a name="INDEX-249" /></a> <a name="INDEX-250" /></a>datatypes
are: <tt class="literal"><a href="ch16_01.htm">xs:normalizedString</a></tt> and
<tt class="literal"><a href="ch16_01.htm">xs:string</a></tt>.
</p>

<a name="xmlschema-CHP-5-SECT-1.1.2.1" /></a><div class="sect4">
<h4 class="sect4">5.1.1.2.1. <a href="ch15_01.htm">xs:whiteSpace</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt>
<a name="INDEX-251" /></a>defines
the way to handle whitespaces--i.e., #x20 (space), #x9 (tab),
#xA (linefeed), and #xD (carriage return)--for this datatype:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="CapitalizedNameWS"&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:whiteSpace value="collapse"/&gt;
    &lt;xs:pattern value="([A-Z]([a-z]*) ?)+"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>The values of an <tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt>
facet are "preserve" (whitespaces
are kept unchanged), "replace" (all
the instances of any whitespace are replaced with a space), and
"collapse" (leading and trailing
whitespaces are removed and all the other sequences of contiguous
whitespaces are replaced by a single space). This facet is atypical
since it specifies a treatment to be done on a value before applying
any validation test on this value. In the earlier example, setting
whitespace to "collapse" allows
testing of a single space character in the pattern
(" ?"). This ensures the
whitespaces are collapsed before the pattern is tested and will match
any number of whitespaces.
</p>

<p>The whitespace behavior cannot be relaxed during a restriction: if a
datatype has a whitespace set as
"preserve," its derived datatypes
can have any whitespace behavior; if its whitespace is set as
"replace," its derived datatypes
can only have whitespace equal to
"replace" or
"collapse"; if its whitespace is
"collapse," all its derived
datatypes must have the same behavior. This means <tt class="literal"><a href="ch16_01.htm">xs:string</a></tt> is the only datatype that can be
used to derive datatypes without any whitespace processing and
<tt class="literal"><a href="ch16_01.htm">xs:string</a></tt> and <tt class="literal"><a href="ch16_01.htm">xs:normalizedString</a></tt> are the only datatypes that can be
used to derive datatypes normalizing the whitespaces.
</p>

<p>In practice, this facet isn't really useful for
user-defined datatypes since the whitespace processing largely
dictates the choice of the predefined datatype to use. When we need a
datatype that does no whitespace processing, we must use
<tt class="literal"><a href="ch16_01.htm">xs:string</a></tt> and not
<tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt>. When we need a
datatype that normalizes the whitespaces, instead of using
<tt class="literal"><a href="ch16_01.htm">xs:string</a></tt> and applying a
<tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt> facet, we can use
<tt class="literal"><a href="ch16_01.htm">xs:normalizedString</a></tt> directly, which has
the same effect. When we need a datatype that collapses the
whitespaces, we can use <tt class="literal"><a href="ch16_01.htm">xs:token</a></tt> if it's a
string--since, again, <tt class="literal"><a href="ch16_01.htm">xs:token</a></tt> is not a token in the usual meaning
of the word but rather a "tokenized
string"--as well as any nonstring datatype. The
whitespace processing will already be set to
"collapse" without any need to use
<tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt>. The previous example
given is then equivalent to:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="CapitalizedNameWS"&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:pattern value="([A-Z]([a-z]*) ?)+"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>



<a name="ch05-9-fm2xml" /></a><blockquote><b>TIP:</b> 
Technically speaking, the W3C Working Group hasn't
"fixed" the <tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt> facet for
<tt class="literal">xs:token</tt> and its derived datatypes. However,
<tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt> has been set to
"collapse" for <tt class="literal"><a href="ch16_01.htm">xs:token</a></tt>; since the facet
can't be relaxed in further restriction, this value
cannot be changed in any datatype derived from these datatypes.
<p></p>
</blockquote>

</div>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.3" /></a><div class="sect3">
<h3 class="sect3">5.1.1.3. Float datatypes</h3>

<p>The facets <a name="INDEX-252" /></a>
<a name="INDEX-253" /></a>of: <tt class="literal"><a href="ch16_01.htm">xs:double</a></tt> and <tt class="literal"><a href="ch16_01.htm">xs:float</a></tt> are described in the next sections.
</p>

<a name="xmlschema-CHP-5-SECT-1.1.3.1" /></a><div class="sect4">
<h4 class="sect4">5.1.1.3.1. <a href="ch15_01.htm">xs:enumeration</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:enumeration</a></tt>
<a name="INDEX-254" /></a>allows definition of a list of
possible values and operates on the value space--for example:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="enumeration"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:enumeration value="-INF"/&gt;
    &lt;xs:enumeration value="1.618033989"/&gt;
    &lt;xs:enumeration value="3e3"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This simple type will match literals such as:</p>

<blockquote><pre class="code">&lt;enumeration&gt;
  1.618033989
&lt;/enumeration&gt;

&lt;enumeration&gt;
  3e3
&lt;/enumeration&gt;

&lt;enumeration&gt;
  003000.0000
&lt;/enumeration&gt;</pre></blockquote>

<p>This example shows (as we've briefly seen with
<tt class="literal"><a href="ch16_01.htm">xs:anyURI</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:QName</a></tt>, and <tt class="literal"><a href="ch16_01.htm">xs:base64Binary</a></tt>) two different lexical
representations ("3e3" and
"003000.0000") for the same value.
It also shows, as expected, that all the lexical representations have
the same value, so one of the enumerated values will be accepted.
</p>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.3.2" /></a><div class="sect4">
<h4 class="sect4">5.1.1.3.2. <a href="ch15_01.htm">xs:maxExclusive</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:maxExclusive</a></tt>
<a name="INDEX-255" /></a>defines a maximum value that cannot
be reached:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="maxExclusive"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:maxExclusive value="10"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This datatype validates
"9.999999999999999," but not
"10." 
</p>

<p>The <tt class="literal"><a href="ch15_01.htm">xs:maxExclusive</a></tt> facet is
especially useful for datatypes such as <tt class="literal"><a href="ch16_01.htm">xs:float</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:double</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:decimal</a></tt>, or even for datetime types that can
cope with infinitesimal values and in which it is not possible to
determine the greatest value that is smaller than a value.
</p>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.3.3" /></a><div class="sect4">
<h4 class="sect4">5.1.1.3.3. <a href="ch15_01.htm">xs:maxInclusive</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:maxInclusive</a></tt>
<a name="INDEX-256" /></a>defines a maximum value that can be
reached:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="thousands"&gt;
  &lt;xs:restriction base="xs:double"&gt;
    &lt;xs:maxInclusive value="1e3"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.3.4" /></a><div class="sect4">
<h4 class="sect4">5.1.1.3.4. <a href="ch15_01.htm">xs:minExclusive</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:minExclusive</a></tt>
<a name="INDEX-257" /></a>defines a minimum value that cannot
be reached:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="strictlyPositive"&gt;
  &lt;xs:restriction base="xs:double"&gt;
    &lt;xs:minExclusive value="0"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.3.5" /></a><div class="sect4">
<h4 class="sect4">5.1.1.3.5. <a href="ch15_01.htm">xs:minInclusive</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:minInclusive</a></tt>
<a name="INDEX-258" /></a>defines a minimum value that can be
reached:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="positive"&gt;
  &lt;xs:restriction base="xs:double"&gt;
    &lt;xs:minInclusive value="0"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.3.6" /></a><div class="sect4">
<h4 class="sect4">5.1.1.3.6. <a href="ch15_01.htm">xs:pattern</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt>
<a name="INDEX-259" /></a>defines a pattern that must be
matched by the lexical value of the datatype:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="nonScientific"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:pattern value="[^eE]*"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="noLeading0"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:pattern value="[^0].*"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This example shows how a pattern, acting on the lexical value of the
float, can disable the use of scientific notation
(<tt class="literal">xxxEyyy</tt>) or leading zeros.
</p>



<a name="ch05-11-fm2xml" /></a><blockquote><b>TIP:</b> 
The <tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt> is the only facet
that directly acts on the lexical space of the datatype.
<p></p>
</blockquote>

</div>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.4" /></a><div class="sect3">
<h3 class="sect3">5.1.1.4. Date and time datatypes</h3>

<p>These <a name="INDEX-260" /></a>
<a name="INDEX-261" /></a>datatypes are partially ordered, and
bounds can be defined even though some restrictions apply. These
datatypes are: <a name="INDEX-262" /></a>
<a name="INDEX-263" /></a>
<a name="INDEX-264" /></a>
<a name="INDEX-265" /></a>
<a name="INDEX-266" /></a><tt class="literal"><a href="ch16_01.htm">xs:date</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:dateTime</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:duration</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:gDay</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:gMonth</a></tt>, <a name="INDEX-267" /></a>
<a name="INDEX-268" /></a>
<a name="INDEX-269" /></a>
<a name="INDEX-270" /></a><tt class="literal"><a href="ch16_01.htm">xs:gMonthDay</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:gYear</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:gYearMonth</a></tt>, and <tt class="literal"><a href="ch16_01.htm">xs:time</a></tt> and their facets are the same as
those of the float datatypes, as shown in the next sections.:
</p>

<a name="xmlschema-CHP-5-SECT-1.1.4.1" /></a><div class="sect4">
<h4 class="sect4">5.1.1.4.1. <a href="ch15_01.htm">xs:enumeration</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:enumeration</a></tt> <a name="INDEX-271" /></a>allows definition of a list of
possible values as well as works on the value space--for
example:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="ModernSwissHistoricalDates"&gt;
  &lt;xs:restriction base="xs:gYear"&gt;
    &lt;xs:enumeration value="1864"/&gt;
    &lt;xs:enumeration value="1872"/&gt;
    &lt;xs:enumeration value="1914"/&gt;
    &lt;xs:enumeration value="1939"/&gt;
    &lt;xs:enumeration value="1971"/&gt;
    &lt;xs:enumeration value="1979"/&gt;
    &lt;xs:enumeration value="1992"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This simple type will match literals such as:</p>

<blockquote><pre class="code">1939</pre></blockquote>

<p>Since no <a name="INDEX-272" /></a>time zone is specified for the dates in
the enumeration, the time zone is undetermined. These dates do not
match any date with a time zone specified, such as:
</p>

<blockquote><pre class="code">1939Z</pre></blockquote>

<p>or:</p>

<blockquote><pre class="code">1939+10:00</pre></blockquote>

<p>The same issue appears if enumerations include a time zone, such as
in:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="wakeUpTime"&gt;
  &lt;xs:restriction base="xs:time"&gt;
    &lt;xs:enumeration value="07:00:00-07:00"/&gt;
    &lt;xs:enumeration value="07:15:00-07:00"/&gt;
    &lt;xs:enumeration value="07:30:00-07:00"/&gt;
    &lt;xs:enumeration value="07:45:00-07:00"/&gt;
    &lt;xs:enumeration value="08:00:00-07:00"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This new datatype matches:</p>

<blockquote><pre class="code">07:00:00-07:00</pre></blockquote>

<p>as well as:</p>

<blockquote><pre class="code">11:00:00-04:00</pre></blockquote>

<p>and even:</p>

<blockquote><pre class="code">07:15:00-07:15</pre></blockquote>

<p>but will not validate any time with a time zone.</p>

<p>Even though handling both times with and without time zones is
problematic and questionable, it is possible to mix enumerations of
values with and without time zones, such as:
</p>

<a name="INDEX-273" /></a><blockquote><pre class="code">&lt;xs:simpleType name="sevenOClockPST"&gt;
  &lt;xs:restriction base="xs:time"&gt;
    &lt;xs:enumeration value="07:00:00-07:00"/&gt;
    &lt;xs:enumeration value="07:00:00"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.4.2" /></a><div class="sect4">
<h4 class="sect4">5.1.1.4.2. <a href="ch15_01.htm">xs:maxExclusive</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:maxExclusive</a></tt>
<a name="INDEX-274" /></a>defines a maximum value
that can be reached:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="beforeY2K"&gt;
  &lt;xs:restriction base="xs:dateTime"&gt;
    &lt;xs:maxExclusive value="2000-01-01T00:00:00Z"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This datatype validates any date strictly less than Y2K UTC, such as:</p>

<blockquote><pre class="code">1999-12-31T23:59:59Z</pre></blockquote>

<p>or:</p>

<blockquote><pre class="code">1999-12-31T23:59:59.999999999999Z</pre></blockquote>

<p>It will also validate the following; even if expressed using any
other time zone, such as:
</p>

<blockquote><pre class="code">2000-01-01T11:59:59+12:00</pre></blockquote>

<p>It doesn't validate:</p>

<blockquote><pre class="code">2000-01-01T00:00:00Z</pre></blockquote>

<p>The interval of indeterminacy of +/-14 hours is applied when compared
to datetimes without a time zone. The greatest datetime without a
time zone (without counting the fractions of seconds) is therefore:
</p>

<blockquote><pre class="code">1999-12-31T09:59:59</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.4.3" /></a><div class="sect4">
<h4 class="sect4">5.1.1.4.3. <a href="ch15_01.htm">xs:maxInclusive</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:maxInclusive</a></tt>
<a name="INDEX-275" /></a>defines a maximum value
that can be reached:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="AQuarterOrLess"&gt;
  &lt;xs:restriction base="xs:duration"&gt;
    &lt;xs:maxInclusive value="P3M"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This datatype validates all the durations less than or equal to 3
months. Durations such as <tt class="literal">P2M</tt> (2 months) or
<tt class="literal">P3M</tt> (3 months) qualify. If both months and days
are used, <tt class="literal">P2M30D</tt> (2 months and 30 days) will be
valid, but <tt class="literal">P2M31D</tt> (2 months and 31 days), or even
<tt class="literal">P2M30DT1S</tt> (2 months, 30 days and 1 second), will
be rejected because of the indetermination of the actual duration
when parts from year/month on one side and day/hours/minutes/seconds
on the other side are used.
</p>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.4.4" /></a><div class="sect4">
<h4 class="sect4">5.1.1.4.4. <a href="ch15_01.htm">xs:minExclusive</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:minExclusive</a></tt>
<a name="INDEX-276" /></a>defines a minimum value
that can be reached:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="afterTeaTimeInParisInSummer"&gt;
  &lt;xs:restriction base="xs:time"&gt;
    &lt;xs:minExclusive value="17:00:00+02:00"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.4.5" /></a><div class="sect4">
<h4 class="sect4">5.1.1.4.5. <a href="ch15_01.htm">xs:minInclusive</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:minInclusive</a></tt>
<a name="INDEX-277" /></a>defines a minimum value
that can be reached:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="afterOrOnThe20th"&gt;
  &lt;xs:restriction base="xs:gDay"&gt;
    &lt;xs:minInclusive value="---20"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>We can also take back our example using durations and define:</p>

<blockquote><pre class="code">&lt;xs:simpleType name="AQuarterOrMore"&gt;
  &lt;xs:restriction base="xs:duration"&gt;
    &lt;xs:minInclusive value="P3M"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This datatype validates all durations that are more than or equal to
3 months. Durations such as <tt class="literal">P4M</tt> (4 months) or
<tt class="literal">P3M</tt> (3 months) will qualify. If both months and
days are used, <tt class="literal">P2M31D</tt> (2 months and 31 days) will
be valid, but <tt class="literal">P2M30D</tt> (2 months and 30 days), or
even <tt class="literal">P2M30DT23H59M59S</tt> (2 months, 30 days, 23
hours, 59 minutes and 59 seconds), will be rejected because of the
indetermination of the actual duration.
</p>

<p>Because of this indeterminacy, W3C XML Schema considers our third
month to have 30 days when we apply <tt class="literal"><a href="ch15_01.htm">xs:minInclusive</a></tt>, and
31 days when we apply <tt class="literal"><a href="ch15_01.htm">xs:maxInclusive</a></tt>. In practice, it
may be wise to invalidate the usage of combinations allowing such an
indeterminacy. We will see in the next chapter how to do it with a
pattern.
</p>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.4.6" /></a><div class="sect4">
<h4 class="sect4">5.1.1.4.6. <a href="ch15_01.htm">xs:pattern</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt>
<a name="INDEX-278" /></a>defines a pattern that must be
matched by the lexical value of the datatype. We will see patterns in
detail in the next chapter. To get an idea of what they look like,
look at the following datatype. It forbids usage of a time zone by
<a name="INDEX-279" /></a>
<a name="INDEX-280" /></a>
<a name="INDEX-281" /></a>
<a name="INDEX-282" /></a>an
<tt class="literal"><a href="ch16_01.htm">xs:dateTime</a></tt> <a name="INDEX-283" /></a> <a name="INDEX-284" /></a> <a name="INDEX-285" /></a> <a name="INDEX-286" /></a> <a name="INDEX-287" /></a>datatype:
</p>

<a name="INDEX-288" /></a><a name="INDEX-289" /></a><blockquote><pre class="code">&lt;xs:simpleType name="noTimeZone"&gt;
  &lt;xs:restriction base="xs:dateTime"&gt;
    &lt;xs:pattern value=".*T[^Z+-]*"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
</pre></blockquote>

</div>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.5" /></a><div class="sect3">
<h3 class="sect3">5.1.1.5. Integer and derived datatypes</h3>

<p>These <a name="INDEX-290" /></a>
<a name="INDEX-291" /></a>datatypes are: <a name="INDEX-292" /></a>
<a name="INDEX-293" /></a> <a name="INDEX-294" /></a>
<a name="INDEX-295" /></a><tt class="literal"><a href="ch16_01.htm">xs:byte</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:int</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:integer</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:long</a></tt>,
<a name="INDEX-296" /></a>
<a name="INDEX-297" /></a>
<a name="INDEX-298" /></a>
<a name="INDEX-299" /></a><tt class="literal"><a href="ch16_01.htm">xs:negativeInteger</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:nonNegativeInteger</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:nonPositiveInteger</a></tt>, <a name="INDEX-300" /></a>
<a name="INDEX-301" /></a> <a name="INDEX-302" /></a>
<a name="INDEX-303" /></a> <a name="INDEX-304" /></a><tt class="literal"><a href="ch16_01.htm">xs:positiveInteger</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:short</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:unsignedByte</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:unsignedInt</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:unsignedLong</a></tt>, and
<tt class="literal"><a href="ch16_01.htm">xs:unsignedShort</a></tt>.
</p>

<p>They accept the same facets of float datatypes as datetime of float
datatypes, which we just saw, plus an additional facet to constraint
the number of digits, as shown next.
</p>

<a name="xmlschema-CHP-5-SECT-1.1.5.1" /></a><div class="sect4">
<h4 class="sect4">5.1.1.5.1. <a href="ch15_01.htm">xs:totalDigits</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:totalDigits</a></tt>
<a name="INDEX-305" /></a>defines the maximum number of decimal
digits:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="totalDigits"&gt;
  &lt;xs:restriction base="xs:integer"&gt;
    &lt;xs:totalDigits value="5"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>This datatype accepts only integers with up to five decimal digits.</p>

<p><tt class="literal"><a href="ch15_01.htm">xs:totalDigits</a></tt> acts on the value
space, which means that the integer
"000012345," whose canonical value
is "12345," matches the datatype
defined previously.
</p>

</div>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.6" /></a><div class="sect3">
<h3 class="sect3">5.1.1.6. Decimals</h3>

<p>This <a name="INDEX-306" /></a>
<a name="INDEX-307" /></a>single datatype
<a name="INDEX-308" /></a>(<tt class="literal"><a href="ch16_01.htm">xs:decimal</a></tt>) accepts all the facets of the
integers and an additional facet to define the number of fractional
digits as shown next.
</p>

<a name="xmlschema-CHP-5-SECT-1.1.6.1" /></a><div class="sect4">
<h4 class="sect4">5.1.1.6.1. <a href="ch15_01.htm">xs:fractionDigits</a></h4>

<p><tt class="literal"><a href="ch15_01.htm">xs:fractionDigits</a></tt>
<a name="INDEX-309" /></a>specifies the maximum number of decimal
digits in the fractional part (after the dot) :
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="fractionDigits"&gt;
  &lt;xs:restriction base="xs:decimal"&gt;
    &lt;xs:fractionDigits value="2"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p><tt class="literal"><a href="ch15_01.htm">xs:fractionDigits</a></tt> acts on the value
space, which means that the integer
"1.12000," whose canonical value is
"1.12," matches the datatype
defined previously.
</p>

</div>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.7" /></a><div class="sect3">
<h3 class="sect3">5.1.1.7. Booleans</h3>

<p>With <a name="INDEX-310" /></a>only one facet allowed, as far as
restriction facets are concerned, the simplest datatype is
<tt class="literal"><a href="ch16_01.htm">xs:boolean</a></tt>. The value space of
this simple datatype is limited to
"true" and
"false," but its lexical space also
includes "0" and
"1." The <tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt> facet can be used to exclude one of
these formats.
</p>

<a name="xmlschema-CHP-5-SECT-1.1.7.1" /></a><div class="sect4">
<h4 class="sect4">5.1.1.7.1. <a href="ch15_01.htm">xs:pattern</a></h4>

<p>The <a name="INDEX-311" /></a>functionality of <tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt> is usually very rich; however, given
the limited number of values of the <tt class="literal"><a href="ch16_01.htm">xs:boolean</a></tt>, its only use here appears to be to
fix a format:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="trueOrFalse"&gt;
  &lt;xs:restriction base="xs:boolean"&gt;
    &lt;xs:pattern value="true"/&gt;
    &lt;xs:pattern value="false"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

</div>

<a name="xmlschema-CHP-5-SECT-1.1.8" /></a><div class="sect3">
<h3 class="sect3">5.1.1.8. List datatypes</h3>

<p>The available facets for the list datatypes
(<a name="INDEX-312" /></a> <a name="INDEX-313" /></a>
<a name="INDEX-314" /></a><tt class="literal"><a href="ch16_01.htm">xs:IDREFS</a></tt>, <tt class="literal"><a href="ch16_01.htm">xs:ENTITIES</a></tt>, and
<tt class="literal"><a href="ch16_01.htm">xs:NMTOKENS</a></tt>) are the facets
available for all the datatypes that are derived by list, as we will
see in the next <a name="INDEX-315" /></a>section. 
</p>

</div>
</div>
<a name="xmlschema-CHP-5-SECT-1.2" /></a><div class="sect2">
<h3 class="sect2">5.1.2. Multiple Restrictions and Fixed Attribute</h3>

<p>New <a name="INDEX-316" /></a> <a name="INDEX-317" /></a> <a name="INDEX-318" /></a>restrictions can be
applied to datatypes that are already derived by restriction from
other types.
</p>

<p>When the new restrictions are done on facets that have not yet been
constrained, the new facets are just added to the set of facets
already defined. The value and <a name="INDEX-319" /></a>lexical spaces of the new datatype are the
intersection of all the restrictions. Things become more complex when
the same facets are being redefined, and restricting facets can
extend the value space.
</p>

<p>As far as multiple facet definitions are concerned, we can classify
the facets into four categories, described in the next sections.
</p>

<a name="xmlschema-CHP-5-SECT-1.2.1" /></a><div class="sect3">
<h3 class="sect3">5.1.2.1. Facet that can be changed but needs to be more restrictive</h3>

<p>This is the general case. <tt class="literal"><a href="ch15_01.htm">xs:enumeration</a></tt>, <tt class="literal"><a href="ch15_01.htm">xs:fractionDigits</a></tt>, <tt class="literal"><a href="ch15_01.htm">xs:maxExclusive</a></tt>, <tt class="literal"><a href="ch15_01.htm">xs:maxInclusive</a></tt>, <tt class="literal"><a href="ch15_01.htm">xs:maxLength</a></tt>, <tt class="literal"><a href="ch15_01.htm">xs:minExclusive</a></tt>, <tt class="literal"><a href="ch15_01.htm">xs:minInclusive</a></tt>, <tt class="literal"><a href="ch15_01.htm">xs:minLength</a></tt>, and <tt class="literal"><a href="ch15_01.htm">xs:totalDigits</a></tt> are in this case.
</p>

<p>For all these facets, it is forbidden to add a facet that expands the
<a name="INDEX-320" /></a>value space of the base
datatype. The following examples demonstrate such errors:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="minInclusive"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:minInclusive value="10"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="minInclusive2"&gt;
  &lt;xs:restriction base="minInclusive"&gt;
    &lt;xs:minInclusive value="0"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>or:</p>

<blockquote><pre class="code">&lt;xs:simpleType name="enumeration"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:enumeration value="-INF"/&gt;
    &lt;xs:enumeration value="1.618033989"/&gt;
    &lt;xs:enumeration value="3e3"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="enumeration2"&gt;
  &lt;xs:restriction base="enumeration"&gt;
    &lt;xs:enumeration value="0"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.2.2" /></a><div class="sect3">
<h3 class="sect3">5.1.2.2. Facet that cannot be changed</h3>

<p>The <tt class="literal"><a href="ch15_01.htm">xs:length</a></tt><a name="INDEX-321" /></a> facet is the only one in this
category. The length of a derived datatype cannot be redefined if the
length of its parent has been defined.
</p>

<p><tt class="literal"><a href="ch15_01.htm">xs:length</a></tt> can be seen as a
shortcut for assigning an equal value to <tt class="literal"><a href="ch15_01.htm">xs:maxLength</a></tt> and <tt class="literal"><a href="ch15_01.htm">xs:minLength</a></tt>. This behavior is coherent with what
happens if these two facets are both used with the same value:
further values of <tt class="literal"><a href="ch15_01.htm">xs:maxLength</a></tt>
must be inferior or equal to the length, and further values of
<tt class="literal"><a href="ch15_01.htm">xs:minLength</a></tt> must be greater than
or equal to the length. Since <tt class="literal"><a href="ch15_01.htm">xs:minLength</a></tt> must also be smaller than or equal
to <tt class="literal"><a href="ch15_01.htm">xs:maxLength</a></tt>, the only
possibility is that they all need to stay equal to the length as
previously defined.
</p>

</div>

<a name="xmlschema-CHP-5-SECT-1.2.3" /></a><div class="sect3">
<h3 class="sect3">5.1.2.3. Facet that performs the intersection of the lexical spaces</h3>

<p>The <tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt><a name="INDEX-322" /></a> facet is the only facet that can be
applied multiple times. It always restricts the lexical space by
performing a straight intersection of the lexical spaces. The
following <tt class="literal">noScientificNoLeading0</tt> datatype will try
to match the patterns for both the base datatype and the new
restriction:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="nonScientific"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:pattern value="[^eE]*"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="noScientificNoLeading0"&gt;
  &lt;xs:restriction base="nonScientific"&gt;
    &lt;xs:pattern value="[^0].*"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

</div>

<a name="xmlschema-CHP-5-SECT-1.2.4" /></a><div class="sect3">
<h3 class="sect3">5.1.2.4. Facet that does its job before the lexical space</h3>

<p><tt class="literal"><a href="ch15_01.htm">xs:whiteSpace</a></tt>
<a name="INDEX-323" /></a>is a remarkable
exception. This facet defines the whitespace processing and can
actually expand the set of accepted instance documents during a
"restriction," as shown in the
following example:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="greetings"&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:whiteSpace value="replace"/&gt;
    &lt;xs:enumeration value="hi"/&gt;
    &lt;xs:enumeration value="hello"/&gt;
    &lt;xs:enumeration value="how do you do?"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
      
&lt;xs:simpleType name="restricted-greetings"&gt;
  &lt;xs:restriction base="greetings"&gt;
    &lt;xs:whiteSpace value="collapse"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>

<p>While the first datatype
("greetings") accepts:
</p>

<blockquote><pre class="code">how do you do?</pre></blockquote>

<p>but rejects a string such as:</p>

<blockquote><pre class="code">how do     you do?</pre></blockquote>

<p>the type issued from the
"restriction" accepts both.
</p>

</div>

<a name="xmlschema-CHP-5-SECT-1.2.5" /></a><div class="sect3">
<h3 class="sect3">5.1.2.5. Fixed facets</h3>

<p>Each facet (except <tt class="literal"><a href="ch15_01.htm">xs:enumeration</a></tt>
and <tt class="literal"><a href="ch15_01.htm">xs:pattern</a></tt>) includes a
<a name="INDEX-324" /></a>
<a name="INDEX-325" /></a><tt class="literal">fixed</tt> attribute which,
when set to <tt class="literal">true</tt>, disables the possibility of
modifying the facet during further restrictions by derivation.
</p>

<p>If we want to make sure that the minimum value of our
<tt class="literal">minInclusive</tt> cannot be modified, we write:
</p>

<blockquote><pre class="code">&lt;xs:simpleType name="minInclusive"&gt;
  &lt;xs:restriction base="xs:float"&gt;
    &lt;xs:minInclusive value="10" fixed="true"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>



<a name="ch05-13-fm2xml" /></a><blockquote><b>NOTE:</b> 
This is the method used by the schema for <em class="emphasis">W3C XML
Schema</em> to fix the value of the facets used to derive
predefined datatypes. For instance, the type <tt class="literal"><a href="ch16_01.htm">xs:integer</a></tt> is derived from <tt class="literal"><a href="ch16_01.htm">xs:decimal</a></tt> through:
<p></p>

<blockquote><pre class="code">&lt;xs:simpleType name="integer" id="integer"&gt;
  &lt;xs:restriction base="xs:decimal"&gt;
    &lt;xs:fractionDigits value="0" fixed="true"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</pre></blockquote>
</blockquote>

<p><tt class="literal">&lt;<a href="ch15_01.htm">xs:enumeration</a></tt><tt class="literal">&gt;</tt> <a name="INDEX-326" /></a>and
<tt class="literal">&lt;<a href="ch15_01.htm">xs:pattern</a></tt><tt class="literal">&gt;</tt> <a name="INDEX-327" /></a> <a name="INDEX-328" /></a> <a name="INDEX-329" /></a>cannot <a name="INDEX-330" /></a>be <a name="INDEX-331" /></a>fixed.
</p>

</div>
</div>
</div>

<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch04_08.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch05_02.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">4.8. Back to Our Library</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">5.2. Derivation By List</td></tr></table></div>
<hr width="684" align="left" />

<img src="../gifs/navbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
      </map>

</body></html>