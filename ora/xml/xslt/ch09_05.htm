<html><head><title>XSLT Source Code (XSLT)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Doug Tidwell" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596000537L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="XSLT" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="XSL" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch09_04.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"></td><td align="right" valign="top" width="228"><a href="ch09_06.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>



    <h2 class="sect1">9.5. XSLT Source Code</h2>
    <p>
<a name="INDEX-774" />
<a name="INDEX-775" />
<a name="INDEX-776" />


Now that we've discussed the design issues we went through as we defined our XML document structure, we'll talk about how our XSLT stylesheets transform XML-tagged tutorials into the files we want. </p>
    <div class="sect2">
      <h3 class="sect2">9.5.1. Stylesheets and Modes</h3>
      <p>
<a name="INDEX-777" />
<a name="INDEX-778" />

To start with, we use the XSLT <tt class="literal">mode</tt> attribute to process the same set of nodes several times. Our template for the root element is similar to a Java or C++ program whose <tt class="literal">main()</tt> method contains nothing but subroutine calls:</p>
      <blockquote><pre class="code">
&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="tutorial" mode="build-main-index"/&gt;
  &lt;xsl:apply-templates select="tutorial" mode="build-section-indexes"/&gt;
  &lt;xsl:apply-templates select="tutorial" mode="build-individual-panels"/&gt;
  &lt;xsl:apply-templates select="tutorial" mode="generate-graphics"/&gt;
  &lt;xsl:apply-templates select="tutorial" mode="generate-pdf-file"&gt;
    &lt;xsl:with-param name="page-size" select="'letter'"/&gt;
  &lt;/xsl:apply-templates&gt;
  &lt;xsl:apply-templates select="tutorial" mode="generate-pdf-file"&gt;
    &lt;xsl:with-param name="page-size" select="'a4'"/&gt;
  &lt;/xsl:apply-templates&gt;
  &lt;xsl:apply-templates select="tutorial" mode="generate-zip-file"/&gt;
&lt;/xsl:template&gt;</pre></blockquote>
      <p>If this were a Java program, we might create a <tt class="literal">main()</tt> method that looks like this:</p>
      <blockquote><pre class="code">
public static void main(String[] argv)
{
  buildMainIndex();
  buildSectionIndexes();
  buildIndividualPanels();
  generateGraphics();
  generatePDFFile("letter");

  generatePDFFile("a4");
  generateZipFile();
}</pre></blockquote>
      <p>This style of coding facilitates maintenance; if the PDF files aren't generated correctly, the templates with <tt class="literal">mode="generate-pdf-file"</tt> are the obvious place to start debugging. In addition, we structured the files so that all the templates for a given <tt class="literal">mode</tt> are in a single file that can be included into our main stylesheet:</p>
      <blockquote><pre class="code">
&lt;xsl:include href="toot-o-matic-variables.xsl"/&gt;

&lt;xsl:include href="xslt-utilities.xsl"/&gt;
&lt;xsl:include href="dw-style.xsl"/&gt;

&lt;xsl:include href="build-main-index.xsl"/&gt;
&lt;xsl:include href="build-section-indexes.xsl"/&gt;
&lt;xsl:include href="build-individual-panels.xsl"/&gt;
&lt;xsl:include href="build-graphics.xsl"/&gt;
&lt;xsl:include href="build-pdf-file.xsl"/&gt;
&lt;xsl:include href="build-zip-file.xsl"/&gt;</pre></blockquote>
      <p>In addition to the obviously named files, the file <em class="emphasis">toot-o-matic-variables.xsl</em> defines several global variables used throughout the stylesheets, <em class="emphasis">xslt-utilities.xsl</em> is a library of generic routines (substring replacement, for example) we use, and <em class="emphasis">dw-style.xsl</em> defines the look and feel of our HTML pages.</p>
    </div>
    <div class="sect2">
      <h3 class="sect2">9.5.2. Initializing Global Variables</h3>
      <p>
<a name="INDEX-779" />
<a name="INDEX-780" />
<a name="INDEX-781" />

It's worth discussing the global variables initialized in <em class="emphasis">toot-o-matic-variables.xsl</em>. All of these variables are used throughout our various stylesheets, and initializing them saves us a significant amount of processing time. The most significant variable is <tt class="literal">$mouse-effects</tt>. This variable is an automatically generated segment of JavaScript code used to process mouseover effects on all the HTML pages we generate. Here's how the generated code looks:</p>
      <blockquote><pre class="code">
&lt;!-- var emailAbstract="developerWorks is proud to present the Toot-O-Matic,...";
var justTitle="Building tutorials with the Toot-O-Matic";
var tutorialPrereqs="http://www-4.ibm.com/education/tootomatic";
var menu1blurb="Installing and configuring Toot-O-Matic"; 
var menu2blurb="Creating your first tutorial"; 
var menu3blurb="developerWorks editorial guidelines"; 
var menu4blurb="Toot-O-Matic tag guide"; 
var menu5blurb="Toot-O-Matic tag reference"; 
var menu6blurb="Troubleshooting"; 
var menu7blurb="Feedback"; 

var browser = "x";
if (navigator.userAgent.indexOf("Mozilla/4") != -1) browser = "N3";
else if (navigator.userAgent.indexOf("Mozilla/3") != -1) browser = "N3";
else browser = "x";
      
if (browser=="N3")
{
  var menu1over=new Image(108,68); 
  var menu1out=new Image(108,68); 
  var menu2over=new Image(108,68); 
  var menu2out=new Image(108,68); 
  var menu3over=new Image(108,68); 
  var menu3out=new Image(108,68); 
  ...
  var topmainover=new Image(77,15);
  var topmainout=new Image(77,15);
  var bottommainover=new Image(77,15);
  var bottommainout=new Image(77,15);
  var topsectionover=new Image(98,15);
  var topsectionout=new Image(98,15);
  var bottomsectionover=new Image(98,15);
  var bottomsectionout=new Image(98,15);
  var topfeedbackover=new Image(80,15);
  var topfeedbackout=new Image(80,15);
  var bottomfeedbackover=new Image(80,15);
  var bottomfeedbackout=new Image(80,15);
  var toppreviousover=new Image(77,15);
  var toppreviousout=new Image(77,15);
  var bottompreviousover=new Image(77,15);
  var bottompreviousout=new Image(77,15);
  var topnextover=new Image(60,15);
  var topnextout=new Image(60,15);
  var bottomnextover=new Image(60,15);
  var bottomnextout=new Image(60,15);
  var topnextsectionover=new Image(108,15);
  var topnextsectionout=new Image(108,15);
  var bottomnextsectionover=new Image(108,15);
  var bottomnextsectionout=new Image(108,15);
      
  menu1over.src="imagemaster/himenu1.jpg"; 
  menu1out.src="imagemaster/menu1.jpg"; 
  menu2over.src="imagemaster/himenu2.jpg"; 
  menu2out.src="imagemaster/menu2.jpg"; 
  menu3over.src="imagemaster/himenu3.jpg"; 
  menu3out.src="imagemaster/menu3.jpg"; 
  ...
  var mainblurb="Main menu";
  var sectionblurb="Section menu";
  var feedbackblurb="Give feedback on this tutorial";
  var previousblurb="Go to previous panel";
  var nextblurb="Go to next panel";
  var nextsectionblurb="Go to next section";

  topmainover.src="../i/h-main.gif";
  topmainout.src="../i/main.gif";
...
}
function iOut(image)
{
  if (browser=="N3")document[image].src=eval(image + "out.src");
}
function iOver(image)
{
  if (browser=="N3")document[image].src=eval(image + "over.src");
}
// --&gt;</pre></blockquote>
      <p>This JavaScript code is used for the mouseover effects on the HTML panels. To streamline processing, we generate this code as a variable. (We've removed roughly half the code here to keep the listing short; most of this code deals with initializing a number of variables.)  Whenever we create a new HTML page, we simply insert this variable into the output document:</p>
      <blockquote><pre class="code">
&lt;script language="javascript"&gt;
  &lt;xsl:value-of select="$mouse-effects"/&gt;
&lt;/script&gt;</pre></blockquote>
      <p>As in traditional programming, storing frequently used values in a variable instead of calculating them each time simplifies the code and improves performance. Notice in the code listing that a significant amount of JavaScript code is generated from the XML source document. This fragment is the XSLT that generates a set of JavaScript variables that contain the titles of all the sections:</p>
      <blockquote><pre class="code">
&lt;xsl:for-each select="/tutorial/section"&gt;
  &lt;xsl:text&gt;var menu&lt;/xsl:text&gt;
  &lt;xsl:value-of select="position()"/&gt;
  &lt;xsl:text&gt;blurb="&lt;/xsl:text&gt;
  &lt;xsl:value-of select="title"/&gt;
  &lt;xsl:text&gt;"; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="$newline"/&gt;
&lt;/xsl:for-each&gt;</pre></blockquote>
      <p>The code generates seven new variables, one for each <tt class="literal">&lt;section&gt;</tt> element in our tutorial:</p>
      <blockquote><pre class="code">
var menu1blurb="Installing and configuring Toot-O-Matic"; 
var menu2blurb="Creating your first tutorial"; 
var menu3blurb="developerWorks editorial guidelines"; 
var menu4blurb="Toot-O-Matic tag guide"; 
var menu5blurb="Toot-O-Matic tag reference"; 
var menu6blurb="Troubleshooting"; 
var menu7blurb="Feedback";</pre></blockquote>
<a name="INDEX-782" />
      <blockquote><b>NOTE:</b> 
This is one of many cases when a naming convention is invaluable. If we want the JavaScript variable that contains the title of the fifth section, we know that variable is named <tt class="literal">menu5blurb</tt>. This technique is useful in many other places, as well. If we're creating HTML files for the third <tt class="literal">&lt;section&gt;</tt>, and we're currently processing the fourth <tt class="literal">&lt;panel&gt;</tt> in that <tt class="literal">&lt;section&gt;</tt>, and the root filename we're using is <em class="emphasis">tootomatic</em>, the newly created HTML file will be named <em class="emphasis">tootomatic-3-4.html</em>. Similarly, if we want to create a link to the previous and next HTML files, those files are named <em class="emphasis">tootomatic-3-3.html</em> and <em class="emphasis">tootomatic-3-5.html</em>, respectively. You'll see this technique used throughout this case study.
<a name="INDEX-783" />
<a name="INDEX-784" />

</p>
      </blockquote>
    </div>
    <div class="sect2">
      <h3 class="sect2">9.5.3. Generating the Main Menu Panel</h3>
      <p>
<a name="INDEX-785" />
<a name="INDEX-786" />

The Main menu panel consists of a standard header and footer, with a list of all sections of the tutorial in between. Clicking on any of the section titles takes you to the first panel in that section. To enhance the visual appeal of the panel, generated graphics and mouseover effects are used to display the panel title. </p>
      <p>The stylesheet that generates the list of sections is straightforward. The header and footer are generated from boilerplate text; the list of sections is generated with an <tt class="literal">&lt;xsl:for-each&gt;</tt> element:</p>
      <blockquote><pre class="code">
&lt;xsl:for-each select="section"&gt;
  &lt;a border="0"&gt;
    &lt;xsl:attribute name="href"&gt;
      &lt;xsl:value-of select="$fn"/&gt;
      &lt;xsl:text&gt;-&lt;/xsl:text&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt;-1.html&lt;/xsl:text&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="onMouseOver"&gt;
      &lt;xsl:text&gt;iOver('menu&lt;/xsl:text&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt;'); self.status=menu&lt;/xsl:text&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt;blurb; return true;&lt;/xsl:text&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="onMouseOut"&gt;
      &lt;xsl:text&gt;iOut('menu&lt;/xsl:text&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt;'); self.status=''; return true;&lt;/xsl:text&gt;
    &lt;/xsl:attribute&gt;
    &lt;img width="380" height="20" border="0"&gt;
      &lt;xsl:attribute name="name"&gt;
        &lt;xsl:text&gt;menu&lt;/xsl:text&gt;
        &lt;xsl:value-of select="position()"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:attribute name="src"&gt;
        &lt;xsl:text&gt;imagemaster/&lt;/xsl:text&gt;
        &lt;xsl:text&gt;menu&lt;/xsl:text&gt;
        &lt;xsl:value-of select="position()"/&gt;
        &lt;xsl:text&gt;.jpg&lt;/xsl:text&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:attribute name="alt"&gt;
        &lt;xsl:value-of select="position()"/&gt;
        &lt;xsl:text&gt;. &lt;/xsl:text&gt;
        &lt;xsl:value-of select="title"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/img&gt;
  &lt;/a&gt;
  &lt;br/&gt;
&lt;/xsl:for-each&gt;</pre></blockquote>
      <p>This XSLT produces the following HTML code for our example XML file:</p>
      <blockquote><pre class="code">
&lt;a border="0" href="tootomatic-1-1.html" 
  onMouseOver="iOver('menu1'); self.status=menu1blurb; return true;" 
  onMouseOut="iOut('menu1'); self.status=''; return true;"&gt;
  &lt;img border="0" height="20" width="380" name="menu1" 
    src="imagemaster/menu1.jpg" 
    alt="1. Installing and configuring Toot-O-Matic"&gt;
&lt;/a&gt;
&lt;br&gt;
&lt;a border="0" href="tootomatic-2-1.html" 
  onMouseOver="iOver('menu2'); self.status=menu2blurb; return true;" 
  onMouseOut="iOut('menu2'); self.status=''; return true;"&gt;
  &lt;img border="0" height="20" width="380" name="menu2" 
    src="imagemaster/menu2.jpg" 
    alt="2. Creating your first tutorial"&gt;
&lt;/a&gt;
&lt;br&gt;
&lt;a border="0" href="tootomatic-3-1.html" 
  onMouseOver="iOver('menu3'); self.status=menu3blurb; return true;" 
  onMouseOut="iOut('menu3'); self.status=''; return true;"&gt;
  &lt;img border="0" height="20" width="380" name="menu3" 
    src="imagemaster/menu3.jpg" 
    alt="3. developerWorks editorial guidelines"&gt;
&lt;/a&gt;
&lt;br&gt;
&lt;a border="0" href="tootomatic-4-1.html" 
  onMouseOver="iOver('menu4'); self.status=menu4blurb; return true;" 
  onMouseOut="iOut('menu4'); self.status=''; return true;"&gt;
  &lt;img border="0" height="20" width="380" name="menu4" 
    src="imagemaster/menu4.jpg" 
    alt="4. Toot-O-Matic tag guide"&gt;
&lt;/a&gt;
&lt;br&gt;
&lt;a border="0" href="tootomatic-5-1.html" 
  onMouseOver="iOver('menu5'); self.status=menu5blurb; return true;" 
  onMouseOut="iOut('menu5'); self.status=''; return true;"&gt;
  &lt;img border="0" height="20" width="380" name="menu5" 
    src="imagemaster/menu5.jpg" 
    alt="5. Toot-O-Matic tag reference"&gt;
&lt;/a&gt;
&lt;br&gt;
&lt;a border="0" href="tootomatic-6-1.html" 
  onMouseOver="iOver('menu6'); self.status=menu6blurb; return true;" 
  onMouseOut="iOut('menu6'); self.status=''; return true;"&gt;
  &lt;img border="0" height="20" width="380" name="menu6" 
    src="imagemaster/menu6.jpg" 
    alt="6. Troubleshooting"&gt;
&lt;/a&gt;
&lt;br&gt;
&lt;a border="0" href="tootomatic-7-1.html" 
  onMouseOver="iOver('menu7'); self.status=menu7blurb; return true;" 
  onMouseOut="iOut('menu7'); self.status=''; return true;"&gt;
  &lt;img border="0" height="20" width="380" name="menu7" 
    src="imagemaster/menu7.jpg" 
    alt="7. Feedback"&gt;
&lt;/a&gt;</pre></blockquote>
      <p>Notice the number of things that are automatically generated in this list of sections. We know the filename of any given section, thanks to our filenaming convention. The first panel in the fifth section of the tutorial is <em class="emphasis">tootomatic-5-1.html</em>, for example. For the JavaScript mouseover effects we mentioned previously, we name the <tt class="literal">&lt;img&gt;</tt> elements in the list <tt class="literal">menu1</tt>, <tt class="literal">menu2</tt>, etc. Similarly, the name of each graphic is <em class="emphasis">imagemaster/menu1.jpg</em>, <em class="emphasis">imagemaster/menu2.jpg</em>, etc. The <tt class="literal">onMouseOver</tt> attribute uses variables such as <tt class="literal">menu1blurb</tt> and <tt class="literal">menu2blurb</tt>. Generating these items removes the chance for human error (once the stylesheets are correct) and allows us to control the look and feel of the HTML pages in the tutorial.
<a name="INDEX-787" />
<a name="INDEX-788" />

</p>
    </div>
    <div class="sect2">
      <h3 class="sect2">9.5.4. Generating the Section Indexes</h3>
      <p>
<a name="INDEX-789" />
<a name="INDEX-790" />

To generate a section index, we create an HTML file with an ordered list of all of the <tt class="literal">&lt;panel&gt;</tt> elements in the current <tt class="literal">&lt;section&gt;</tt>. Retrieving the titles of all the panels can be done with a <tt class="literal">&lt;xsl:for-each&gt;</tt> element in the stylesheet:</p>
      <blockquote><pre class="code">
&lt;xsl:for-each select="panel"&gt;
  &lt;img border="0" src="../i/arrow.gif"/&gt;&#xA0;
  &lt;a&gt;
    &lt;xsl:attribute name="href"&gt;
      &lt;xsl:value-of select="$fn"/&gt;&lt;xsl:text&gt;-&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$sectionNumber"/&gt;&lt;xsl:text&gt;-&lt;/xsl:text&gt;
      &lt;xsl:value-of select="position()"/&gt;&lt;xsl:text&gt;.html&lt;/xsl:text&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:value-of select="position()"/&gt;&lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:value-of select="title"/&gt;
  &lt;/a&gt;
  &lt;br/&gt;
&lt;/xsl:for-each&gt;</pre></blockquote>
      <p>In this listing, the variable <tt class="literal">$fn</tt> is defined as the root filename used to generate all HTML filenames for this tutorial. The filename convention used for section indexes is <em class="emphasis">index1.html</em> for the first section index, <em class="emphasis">index2.html</em> for the second section index, etc. This convention makes it easy to generate the section index when we need it, and it makes it easy for the individual panels in a given section to reference the proper section index on each panel.</p>
      <p>We use the Xalan <tt class="literal">Redirect</tt> extension to write output to multiple files. Here's how we invoke that extension to begin writing output to another file:</p>
      <blockquote><pre class="code">
&lt;xsl:for-each select="section"&gt;
  &lt;redirect:write select="concat($curDir, $fileSep, 'index', position(), 
    '.html')"&gt;</pre></blockquote>
      <p>The <tt class="literal">select</tt> attribute of the <tt class="literal">&lt;redirect:write&gt;</tt> element defines the name of the output file. To generate this filename, we concatenate the current directory to which we're writing files (a global variable), the file separator character (another global variable), the text <tt class="literal">index</tt>, the position of this section, and the text <tt class="literal">.html</tt>. If we use the <em class="emphasis">tootomatic</em> directory on a Windows machine, the index for the second <tt class="literal">&lt;section&gt;</tt> will be written to the file <em class="emphasis">tootomatic\index2.html</em>. We use the <em class="emphasis">Redirect</em> extension whenever we need to generate an HTML file for a section index or an individual panel. </p>
    </div>
    <a name="xslt-CHP-9-SECT-5.5" /><div class="sect2">
      <h3 class="sect2">9.5.5. Generating the Individual Panels</h3>
      <p>
<a name="INDEX-791" />
<a name="INDEX-792" />

The masthead and footer of each panel are fairly straightforward; both use a predefined format and a series of links common to all pages on IBM sites. This is a perfect use for named templates. We need to create certain HTML markup for the masthead of each HTML page, and we need to create more markup for the footer of each page. In addition, we need to create the title bar at the top of each page and a navigation bar (an area with Previous and Next links, among other things) at the top and bottom of most pages. We use four templates, cleverly named <tt class="literal">dw-masthead</tt>, <tt class="literal">dw-title-bar</tt>, <tt class="literal">dw-nav-bar</tt>, and <tt class="literal">dw-footer</tt>, to do this:</p>
      <blockquote><pre class="code">
&lt;xsl:call-template name="dw-masthead"/&gt;
&lt;xsl:call-template name="dw-title-bar"/&gt;
&lt;xsl:call-template name="dw-nav-bar"&gt;
  &lt;xsl:with-param name="includeMain" select="'youBetcha'"/&gt;
  &lt;xsl:with-param name="sectionNumber" select="$sectionNumber"/&gt;
  &lt;xsl:with-param name="position" select="$pos"/&gt;
  &lt;xsl:with-param name="last" select="$last"/&gt;
  &lt;xsl:with-param name="topOrBottom" select="'top'"/&gt;
  &lt;xsl:with-param name="oneOrTwo" select="'two'"/&gt;
&lt;/xsl:call-template&gt;

&lt;!-- Processing for the main body of the page goes here --&gt;

&lt;xsl:call-template name="dw-nav-bar"&gt;
  &lt;xsl:with-param name="includeMain" select="'youBetcha'"/&gt;
  &lt;xsl:with-param name="sectionNumber" select="$sectionNumber"/&gt;
  &lt;xsl:with-param name="position" select="$pos"/&gt;
  &lt;xsl:with-param name="last" select="$last"/&gt;
  &lt;xsl:with-param name="topOrBottom" select="'bottom'"/&gt;
  &lt;xsl:with-param name="oneOrTwo" select="'two'"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="dw-footer"/&gt;</pre></blockquote>
      <p>Of the four templates, only <tt class="literal">dw-nav-bar</tt> takes any parameters. Depending on the page we're currently generating, we may or may not need the Main menu button (we don't include this button on the Main menu panel). We need the current section number so the navigation bar can create filenames for the links to the section menu, the previous panel, and the next panel. The <tt class="literal">position</tt> parameter defines the position of this particular panel; <tt class="literal">last</tt> defines the position of the last panel. If <tt class="literal">position</tt> is 1, then the Previous button will be disabled. If <tt class="literal">position</tt> is equal to <tt class="literal">last</tt>, then the Next button will be disabled. The parameter <tt class="literal">topOrBottom</tt> defines whether this navigation bar is being created at the top or bottom of the panel (we have to name the images differently so the JavaScript mouseover effects work correctly). Finally, the <tt class="literal">oneOrTwo</tt> parameter determines whether this panel will have two navigation bars or just one. This is also necessary for the mouseover effects.</p>
      <p>Now that we've built all these parts of the page, building the actual content of the panel is somewhat anticlimactic. We support a limited set of HTML tags (the 20 or so most-used tags, added sparingly as we've needed to add new functions to the tool), most of which are converted directly into their HTML equivalents. </p>
    </div>
    <div class="sect2">
      <h3 class="sect2">9.5.6. Generating the PDF Files</h3>
      <p>
<a name="INDEX-793" />
<a name="INDEX-794" />
<a name="INDEX-795" />
<a name="INDEX-796" />

<a name="INDEX-797" />
<a name="INDEX-798" />
<a name="INDEX-799" />
<a name="INDEX-800" />
<a name="INDEX-801" />


Converting the XML document to an XSL Formatting Objects (XSL-FO) stream is fairly straightforward, as well. Our printed layout consists of the graphics and text from the tutorial, combined with page numbers, headers, and footers to create high-quality printed output. We use the Apache XML Project's FOP (Formatting Objects to PDF) tool to do this. </p>
      <p>When we invoke the PDF-generating templates with the <tt class="literal">mode=generate-pdf</tt> attribute, we pass in the <tt class="literal">page-size</tt> parameter to set the dimensions of the printed page. We generate PDFs with both letter-sized and A4-sized pages to support our customers around the world.</p>
      
<p>To create the PDF, we first create the output file of formatting objects, converting the various XML tags from our source document into the various formatting objects we need:</p>
      <blockquote><pre class="code">
&lt;fo:block font-size="16pt" line-height="19pt" font-weight="bold" 
  space-after.optimum="12pt"&gt;
  Introduction to JavaServer Pages
&lt;/fo:block&gt;
&lt;fo:block space-after.optimum="6pt"&gt;
  In today's environment, most web sites want to display dynamic 
  content based on the user and the session. Most content, such 
  as images, text, and banner ads, is most easily built with 
  HTML editors. So we need to mix the "static" content of HTML 
  files with "directives" for accessing or generating dynamic 
  content. 
&lt;/fo:block&gt;
&lt;fo:block space-after.optimum="6pt"&gt;
  JavaServer Pages meet this need. They provide server-side 
  scripting support for generating web pages with combined 
  static and dynamic content. 
&lt;/fo:block&gt;</pre></blockquote>
      <p>Currently, the XSL:FO specification is a candidate recommendation at the World Wide Web Consortium (W3C). Because future changes are likely, we won't discuss the formatting objects themselves. It suffices to say that our stylesheet defines page layouts (margins, running headers and footers, etc.) and then creates a number of formatting objects inside those page layouts. The FOP tool handles the details of calculating line, page, and column breaks, page references, and hyperlinks.</p>
      <p>Once the file of formatting objects is created, we call an extension function to convert the formatting objects file into a PDF. Here's the exension's main code:</p>
      <blockquote><pre class="code">
public static void buildPDFFile(String foFilename, String pdfFilename)
{
  try
  {
    XMLReader parser = 
      (XMLReader) Class.forName("org.apache.xerces.parsers.SAXParser")
                       .newInstance();
    Driver driver = new Driver();
    driver.setRenderer("org.apache.fop.render.pdf.PDFRenderer", 
                       Version.getVersion());
    driver.addElementMapping("org.apache.fop.fo.StandardElementMapping");
    driver.addElementMapping("org.apache.fop.svg.SVGElementMapping");
    driver.addPropertyList("org.apache.fop.fo.StandardPropertyListMapping");
    driver.addPropertyList("org.apache.fop.svg.SVGPropertyListMapping");
    driver.setOutputStream(new FileOutputStream(pdfFilename));
    driver.buildFOTree(parser, new InputSource(foFilename));
    driver.format();
    driver.render();
  }</pre></blockquote>
      <p>The code merely creates the FOP <tt class="literal">Driver</tt> object, sets its various properties, and then tells it to render the formatting objects in a PDF file. The main difficulty here is in determining how the various XML elements should be converted to formatting objects; once the conversion is done, we have a tool that generates high-quality printable output from our XML source files. Best of all, this code uses open source tools exclusively.</p>
    </div>
    <div class="sect2">
      <h3 class="sect2">9.5.7. Generating the JPEG Files</h3>
      <p>
<a name="INDEX-802" />
<a name="INDEX-803" />
<a name="INDEX-804" />

Another thing we need to produce for the tutorial is a series of JPEG files. To have precise control over the appearance of the titles in the tutorial, we create a JPEG file in which the title text is written in a particular font. We discussed this code in <a href="ch08_01.htm">Chapter 8, "Extending XSLT"</a>, so we won't go over it here. Here's the first significant section of the <em class="emphasis">build-graphics.xsl</em> file:</p>
      <blockquote><pre class="code">
&lt;xsl:template match="tutorial" mode="generate-graphics"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('jpeg:buildJPEGFile')"&gt;
      &lt;xsl:value-of 
        select="jpeg:buildJPEGFile(title, 
        concat('master', $fileSep, 'masthead.jpg'),
        concat($curDir, $fileSep, 'imagemaster', $fileSep, 'masthead.jpg'),
        $baseFont, 27, 5, 30, 0, 0, 0)"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:message terminate="yes"&gt;
        Error! JPEG library not available!
      &lt;/xsl:message&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;</pre></blockquote>
      <p>The <tt class="literal">buildJPEGFile</tt> function takes several parameters, including the title text (in the example, our XPath expression passes in the value of the <tt class="literal">title</tt> element), the name of the background JPEG file (we load this file, draw the text on top of it, and then save the new JPEG), the name of the new JPEG file, the name of the font, and other details about the font size, the x- and y-coordinates where the text should start, and the color in which to draw it. </p>
      <p>Although neither this extension nor the stylesheet that calls it are rocket science, they save us a tremendous amount of time in the tutorial development process. Before we had the Toot-O-Matic, we had to ask our highly trained, highly talented, and highly overworked graphics staff to create these graphics for us; now we do it automatically and the graphics staff can focus their talents on more important things. </p>
    </div>
    <div class="sect2">
      <h3 class="sect2">9.5.8. Generating the Zip File</h3>
      <p>
<a name="INDEX-805" />
<a name="INDEX-806" />

Our last task is to generate a zip file that contains all the files needed to view the tutorial locally. This includes all HTML files, all standard graphics, all JPEGs we generate, and any graphics referenced in the XML source (anything in an <tt class="literal">&lt;img&gt;</tt> tag). We call another Java extension to build the zip file. Determining which files should be loaded into the zip file relies heavily on our naming conventions. </p>
      <p>
<a name="INDEX-807" />

When we invoke the <tt class="literal">buildZipFile</tt> function, we pass in several arguments. The first three are the root filename, the directory to which we write the output files, and the file separator for this platform. The next argument is the <tt class="literal">&lt;tutorial&gt;</tt> node itself; the extension uses DOM functions to determine what files should be added to the zip file. The final argument is a <tt class="literal">node-set</tt> of all the things that reference graphics files in the XML source. That includes the <tt class="literal">img</tt> attribute of any tag and the <tt class="literal">src</tt> attribute of the <tt class="literal">&lt;img&gt;</tt> element. Here's what the function call looks like:</p>
      <blockquote><pre class="code">
&lt;xsl:template match="tutorial" mode="generate-zip-file"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('zip:buildZipFile')"&gt;
      &lt;xsl:variable name="referencedGraphics" 
        select="./@img|//image-column/@img|//img/@src"/&gt;
      &lt;xsl:value-of 
        select="zip:buildZipFile($fn, $curDir, 
                                 $fileSep, ., $referencedGraphics)"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:message terminate="yes"&gt;
        Error! Zip file library not available!
      &lt;/xsl:message&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;</pre></blockquote>
      <p>In the extension function code itself, we start by creating the <tt class="literal">ZipOutputStream</tt> itself:</p>
      <blockquote><pre class="code">
ZipOutputStream zipOut = 
  new ZipOutputStream(new FileOutputStream(currentDirectory + 
                                           fileSeparator + 
                                           baseFilename + ".zip"));</pre></blockquote>
      <p>Once we've created our <tt class="literal">ZipOutputStream</tt>, we'll see if there's a comment for the zip file in the <tt class="literal">zip-file-comment</tt> attribute of the <tt class="literal">&lt;tutorial&gt;</tt> element:</p>
      <blockquote><pre class="code">
Node currentNode = tutorialElement.nextNode();

while (currentNode != null)
{
  if (currentNode.getLocalName().equals("tutorial"))
  {
    ElementImpl currentElement = (ElementImpl)currentNode;
    String zipFileComment = currentElement.getAttribute("zip-file-comment");
    if (zipFileComment != null)
      zipOut.setComment(zipFileComment);
    else
    {
      zipFileComment = currentElement.getAttribute("alt");
      if (zipFileComment != null)
        zipOut.setComment(zipFileComment);
    }</pre></blockquote>
      <p>With everything we do with the DOM nodes, we'll need to make sure we actually work with the appropriate nodes; that's why we use the function call <tt class="literal">getLocalName().equals("tutorial")</tt>. Once we've found the <tt class="literal">&lt;tutorial&gt;</tt> element, we can work with its children to figure out the names of all the HTML and JPEG files we need to add to the zip file. If the <tt class="literal">&lt;tutorial&gt;</tt> element has five <tt class="literal">&lt;section&gt;</tt> children, and the first <tt class="literal">&lt;section&gt;</tt> contains eleven <tt class="literal">&lt;panel&gt;</tt>s, then we'll need to write the files <em class="emphasis">tootomatic-1-1.html</em> through <em class="emphasis">tootomatic-1-11.html</em> to the zip file. (This assumes that the base filename we use is <em class="emphasis">tootomatic</em>.)  Here's an excerpt from the code:</p>
      <blockquote><pre class="code">
int numKids = currentElement.getChildCount();
int numSections = 0;
for (int i = 0; i &lt; numKids; i++)
{
  Node currentChild = currentElement.getChild(i);
  if (currentChild.getLocalName().equals("section"))
  {
    ElementImpl currentChildElement = (ElementImpl)currentChild
    fileToZip = new File(currentDirectory + fileSeparator + "index" + 
                         ++numSections + ".html");
    fis = new FileInputStream(fileToZip);
    entry = new ZipEntry(currentDirectory + fileSeparator + 
                                  fileToZip.getName());
    if (zipOut != null)
    {
      zipOut.putNextEntry(entry);
      while((bytes_read = fis.read(buffer)) != -1)
        zipOut.write(buffer, 0, bytes_read);
    }
    fis.close();

    int numGrandkids = currentChildElement.getChildCount();
    int numPanels = 0;
    for (int j = 0; j &lt; numGrandkids; j++)
    {
      Node currentGrandchildElement = currentChildElement.getChild(j);
      if (currentGrandchildElement.getLocalName().equals("panel"))
      {
        fileToZip = new File(currentDirectory + fileSeparator +
                             baseFilename + "-" + numSections + "-" + 
                             ++numPanels + ".html");
        fis = new FileInputStream(fileToZip);
        entry = new ZipEntry(currentDirectory + fileSeparator + 
                             fileToZip.getName());
        if (zipOut != null)
        {
          zipOut.putNextEntry(entry);
          while((bytes_read = fis.read(buffer)) != -1)
            zipOut.write(buffer, 0, bytes_read);
        }
        fis.close();
      }
    }
  }
}</pre></blockquote>
      <p>Now that we know how many <tt class="literal">&lt;section&gt;</tt> elements are in our <tt class="literal">&lt;tutorial&gt;</tt>, we can write all the generated JPEG graphics to the zip file. Our extension function also contains a static array of the filenames of all standard files used by every tutorial:</p>
      <blockquote><pre class="code">
static String standardFiles[] = {"c.gif", "sw-gold.gif", 
                                 "main.gif", "xmain.gif",
                                 "section.gif", "xsection.gif", 
                                 "feedback.gif", "xfeedback.gif", 
                                 "previous.gif", "xprevious.gif", 
                                 "next.gif", "xnext.gif",
                                 "icon-discuss.gif", "icon-email.gif", 
                                 "icon-pdf-ltr.gif", "icon-zip.gif",
                                 "icon-pdf-a4.gif", 
                                 "mast_logo.gif", "shopibm.gif", 
                                 "support.gif", "downloads.gif", 
                                 "mast_lnav_sp.gif", "about.gif",
                                 "h-menu.gif", "h-main.gif", 
                                 "h-section.gif", "h-feedback.gif",
                                 "h-previous.gif", "h-next.gif", 
                                 "nextsection.gif", "h-nextsection.gif",
                                 "arrow.gif", "mgradient.gif",
                                 "email.gif", "dw-logo2.gif", 
                                 "btn-send.gif", "btn-close.gif",
                                 "emailfriend.js"};</pre></blockquote>
      <p>We store each of these standard files in the zip file for each tutorial. Storing the names of the files in an array makes it easy to add or delete new files from the list. If this list of files changed frequently, we would consider writing an XML-based configuration file that listed all standard files. We could then parse that file, extract the filenames from it, and add those files to the zip file.</p>
      <p>Our next task is to use our <tt class="literal">node-set</tt> of graphics elements to add all referenced graphics to the zip file:</p>
      <blockquote><pre class="code">
currentNode = graphicsElements.nextNode();

HashMap zipEntries = new HashMap();
while (currentNode != null)

{
  String nextGraphicsFile = currentNode.getNodeValue();
  if (!zipEntries.containsKey(nextGraphicsFile))
  {
    fileToZip = new File(currentNode.getNodeValue());
    fis = new FileInputStream(fileToZip);
    entry = new ZipEntry(currentDirectory + fileSeparator + 
                             currentNode.getNodeValue());
    zipOut.putNextEntry(entry);
    while ((bytes_read = fis.read(buffer)) != -1)
      zipOut.write(buffer, 0, bytes_read);
    zipEntries.put(nextGraphicsFile, nextGraphicsFile);
  }
  currentNode = graphicsElements.nextNode();
}</pre></blockquote>
      <p>As we add a referenced graphics file to the zip file, we put the name of the file into a <tt class="literal">HashMap</tt>. If we attempt to add a file to the zip archive and that file is already in the archive, we'll get an exception. To avoid that problem, we check each filename before we add it to the zip file. </p>
      <p>Our last task is to close the <tt class="literal">ZipOutputStream</tt>:

<a name="INDEX-808" />
<a name="INDEX-809" />
<a name="INDEX-810" />
<a name="INDEX-811" />
<a name="INDEX-812" />
<a name="INDEX-813" />
<a name="INDEX-814" />


</p>
      <blockquote><pre class="code">
zipOut.flush();    
zipOut.close();</pre></blockquote>
    </div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch09_04.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch09_06.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">9.4. XML Document Design</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">9.6. Summary</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
</map>

</body></html>
