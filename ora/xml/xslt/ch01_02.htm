<html><head><title>XML Basics (XSLT)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Doug Tidwell" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596000537L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="XSLT" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="XSL" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch01_01.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"></td><td align="right" valign="top" width="228"><a href="ch01_03.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>



    <h2 class="sect1">1.2. XML Basics</h2>
    <p>
<a name="INDEX-29" />
<a name="INDEX-30" />

Almost everything we do in this book deals with XML documents. XSLT stylesheets are XML documents themselves, and they're designed to transform an XML document into something else. If you don't have much experience with XML, we'll review the basics here. For more information on XML, check out Erik T. Ray's <em class="citetitle">Learning XML</em> (O'Reilly, 2001) and Elliotte Rusty Harold and W. Scott Means's <em class="citetitle">XML in a Nutshell</em> (O'Reilly, 2001).</p>
    <div class="sect2">
      <h3 class="sect2">1.2.1. XML's Heritage</h3>
      <p>
<a name="INDEX-31" />
<a name="INDEX-32" />
<a name="INDEX-33" />
<a name="INDEX-34" />


XML's heritage is in the Standard Generalized Markup Language (SGML). Created by Dr. Charles Goldfarb in the 1970s, SGML is widely used in high-end publishing systems. Unfortunately, SGML's perceived complexity prevented its widespread adoption across the industry (SGML also stands for "sounds great, maybe later"). SGML got a boost when Tim Berners-Lee based HTML on SGML. Overnight, the whole computing industry was using a markup language to build documents and applications. </p>
      <p>The problem with HTML is that its tags were designed for
      the interaction between humans and machines. When the Web was
      invented in the late 1980s, that was just fine. As the Web moved
      into all aspects of our lives, HTML was asked to do lots of
      strange things. We've all built HTML pages with awkward table
      structures, 1-pixel 
GIFs, and other nonsense just to get the page to look right in the browser. XML is designed to get us out of this rut and back into the world of structured documents.</p>
      <p>Whatever its limitations, HTML is the most popular markup language ever created. Given its popularity, why do we need XML?  Consider this extremely informative HTML element:</p>
      <blockquote><pre class="code">
&lt;td&gt;12304&lt;/td&gt;</pre></blockquote>
      <p>What does this fascinating piece of content represent?  </p>
      <ul>
         <li>
          <p>Is it the postal code for Schenectady, New York?  </p>
        </li>
        <li>
          <p>Is it the number of light bulbs replaced each month in Las Vegas?  </p>
        </li>
        <li>
          <p>Is it the number of Volkswagens sold in Hong Kong last year?  </p>
        </li>
        <li>
          <p>Is it the number of tons of steel in the Sydney Harbour Bridge?  </p>
        </li>
      </ul>
      <p>The answer:  maybe, maybe not. The point of this silly example is that there's no structure to this data. Even if we included the entire table, it takes intelligence (real, live intelligence, the kind between your ears) to make sense of this data. If you saw this cell in a table next to another cell that contained the text "Schenectady," and the heading above the table read "Postal Codes for the State of New York," as a human being, you could interpret the contents of this cell correctly. On the other hand, if you wanted to write a piece of code that took any HTML table and attempted to determine whether any of the cells in the table contained postal codes, you'd find that difficult, to say the least.</p>
      <p>Most HTML pages have one goal in mind: the appearance of the document. Veterans of the markup industry know that this is definitely not the way to create content. The <em class="emphasis">separation of content and presentation</em> is a long-established tenet of the publishing industry; unfortunately, most HTML pages aren't even close to approaching this ideal. An XML document should contain information, marked up with tags that describe what all the pieces of information are, as well as the relationship between those items. Presenting the document (also known as <em class="emphasis">rendering</em>) involves rules and decisions separate from the document itself. As we work through dozens of sample documents and applications, you'll see how delaying the rendering decisions as long as possible has significant advantages. </p>
      <p>Let's look at another marked-up document. Consider this:</p>
      <blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;postalcodes&gt;
  &lt;title&gt;Most-used postal codes in November 2000&lt;/title&gt;
  &lt;item&gt;
    &lt;city&gt;Schenectady&lt;/city&gt;
    &lt;postalcode&gt;12304&lt;/postalcode&gt;
    &lt;usage-count&gt;2039&lt;/usage-count&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;city&gt;Kuala Lumpur&lt;/city&gt;
    &lt;postalcode&gt;57000&lt;/postalcode&gt;
    &lt;usage-count&gt;1983&lt;/usage-count&gt;
  &lt;/item&gt;
  &lt;item&gt;
    &lt;city&gt;London&lt;/city&gt;
    &lt;postalcode&gt;SW1P 4RG&lt;/postalcode&gt;
    &lt;usage-count&gt;1722&lt;/usage-count&gt;
  &lt;/item&gt;
  ...
&lt;/postalcodes&gt;</pre></blockquote>
      <p>Although we're still in the realm of contrived examples, it would be fairly easy to write a piece of code to find the postal codes in any document that used this set of tags (as opposed to HTML's <tt class="literal">&lt;table&gt;</tt>, <tt class="literal">&lt;tr&gt;</tt>, <tt class="literal">&lt;td&gt;</tt>, etc.). Our code would look for the contents of any <tt class="literal">&lt;postalcode&gt;</tt> elements in the document. (Not to get ahead of ourselves here, but writing an XSLT stylesheet to do this might take all of 30 minutes, including a 25-minute nap.)  A well-designed XML document identifies each piece of data in the document and models the relationships between those pieces of data. This means we can be confident that we're processing an XML document correctly. </p>
      <p>Again, the key idea here is that we're separating content from presentation. Our XML document clearly delineates the pieces of data and puts them into a format we can parse easily. In this book, we illustrate a number of techniques for transforming this XML document into a variety of formats. Among other things, we can transform the item <tt class="literal">&lt;postalcode&gt;12304&lt;/postalcode&gt;</tt> into <tt class="literal">&lt;td&gt;12304&lt;/td&gt;</tt>.</p>
    </div>
    <a name="xslt-CHP-1-SECT-2.2" /><div class="sect2">
      <h3 class="sect2">1.2.2. XML Document Rules</h3>
      <p>
<a name="INDEX-35" />
<a name="INDEX-36" />


Continuing our trip through the basics of XML, there are several rules you need to keep in mind when creating XML documents. All stylesheets we develop in this book are themselves XML documents, so all the rules of XML documents apply to everything we do. The rules are pretty simple, even though the vast majority of HTML documents don't follow them.</p>
      <p>
<a name="INDEX-37" />

One important point:  The XML 1.0 specification makes it clear that when an XML parser finds an XML document that breaks the rules, the parser is supposed to throw an exception and stop. The parser is not allowed to guess what the document structure should actually be. This specification avoids recreating the HTML world, where lots of ugly documents are still rendered by the average browser. </p>
      <div class="sect3">
        <h3 class="sect3">1.2.2.1. An XML document must be contained in a single element</h3>
        <p>
<a name="INDEX-38" />
<a name="INDEX-39" />


The first element in your XML document must contain the entire document. That first element is called the <em class="emphasis">document element</em> or the <em class="emphasis">root element</em>. If more than one document element is in the document, the XML parser throws an exception. This XML document is perfectly legal:</p>
        <blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;greeting&gt;
  Hello, World!
&lt;/greeting&gt;</pre></blockquote>
        <p>(To be precise, this document is <em class="emphasis">well-formed</em>. XML documents are described as <em class="emphasis">well-formed</em> and <em class="emphasis">valid</em>; we'll define those terms in a minute.)  This XML document isn't legal at all:</p>
        <blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;greeting&gt;
  Hello, World!
&lt;/greeting&gt;
&lt;greeting&gt;
  Hey, Y'all!
&lt;/greeting&gt;</pre></blockquote>
        <p>There are two root elements in this document, so an XML parser refuses to process it. Also, be aware that the XML declaration (the <tt class="literal">&lt;?xml version="1.0"?&gt;</tt> part, more on this in a minute) isn't an element at all.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.2. All elements must be nested</h3>
        <p>If you start one element inside another, you have to end it there, too. An HTML browser is happy to render this document:</p>
        <blockquote><pre class="code">
&lt;b&gt;I really, &lt;i&gt;really&lt;/b&gt; like XML.&lt;/i&gt;</pre></blockquote>
        <p>But an XML parser will throw an exception when it sees this document. If you want the same effect, you would need to code this:</p>
        <blockquote><pre class="code">
&lt;b&gt;I really, &lt;i&gt;really&lt;/i&gt;&lt;/b&gt;&lt;i&gt; like XML.&lt;/i&gt;</pre></blockquote>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.3. All attributes must be quoted</h3>
        <p>
<a name="INDEX-40" />

You can quote the attributes with either single quotes or double quotes. These two XML tags are equivalent:</p>
        <blockquote><pre class="code">
&lt;a href="http://www.oreilly.com"&gt;
&lt;a href='http://www.oreilly.com'&gt;</pre></blockquote>
        

<p>If you need to define an attribute with the value , you can use single quotes inside double quotes, as we just did. If you need both single and double quotes in an attribute, use the predefined entities <tt class="literal">&amp;quot;</tt> for double quotes and <tt class="literal">&amp;apos;</tt> for single quotes.</p>
        <p>One more note: XML doesn't allow attributes without values. In other words, HTML elements like <tt class="literal">&lt;ol compact&gt;</tt> aren't valid in XML. To code this element in XML, you'd have to give the attribute a value, as in <tt class="literal">&lt;ol compact="yes"&gt;</tt>.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.4. XML tags are case-sensitive</h3>
        <p>
<a name="INDEX-41" />

In HTML, <tt class="literal">&lt;h1&gt;</tt> and <tt class="literal">&lt;H1&gt;</tt> are the same. In XML, they're not. If you try to end an <tt class="literal">&lt;h1&gt;</tt> element with <tt class="literal">&lt;/H1&gt;</tt>, the parser will throw an exception.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.5. All end tags are required</h3>
        <p>This is another area where most HTML documents break. Your browser doesn't care whether you don't have a <tt class="literal">&lt;/p&gt;</tt> or <tt class="literal">&lt;/br&gt;</tt> tag, but your XML parser does. </p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.6. Empty tags can contain the end marker</h3>
        <p>In other words, these two XML fragments are identical:</p>
        <blockquote><pre class="code">
&lt;lily age="6"&gt;&lt;/lily&gt;
        
&lt;lily age="6"/&gt;</pre></blockquote>
        <p>
<a name="INDEX-42" />

Notice that there is nothing, not even whitespace, between the start tag and the end tag in the first example; that's what makes this an empty tag. </p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.7. XML declarations</h3>
        <p>
<a name="INDEX-43" />
<a name="INDEX-44" />

Some XML documents begin with an <em class="emphasis">XML declaration</em>. An XML declaration is a line similar to this:</p>
        <blockquote><pre class="code">
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</pre></blockquote>
        <p>If no <tt class="literal">encoding</tt> is specified, the XML parser assumes you're using UTF-8, a Unicode standard that uses different numbers of bytes to represent virtually every character and ideograph from the world's languages. Be aware that each parser supports a different set of encodings, so you need to check your parser's documentation to find out what your options are. </p>
      </div>
      <a name="xslt-CHP-1-SECT-2.2.8" /><div class="sect3">
        <h3 class="sect3">1.2.2.8. Document Type Definitions (DTDs) and XML Schemas</h3>
        <p>

<a name="INDEX-45" />
<a name="INDEX-46" />
<a name="INDEX-47" />

All of the rules we've discussed so far apply to all XML documents. In addition, you can use DTDs and Schemas to define other constraints for your XML documents. DTDs and Schemas are metalanguages that let you define the characteristics of an XML vocabulary. For example, you might want to specify that any XML document describing a purchase order must begin with a <tt class="literal">&lt;po&gt;</tt> element, and the <tt class="literal">&lt;po&gt;</tt> element in turn contains a <tt class="literal">&lt;customer-id&gt;</tt> element, one or more <tt class="literal">&lt;item-ordered&gt;</tt> elements, and an <tt class="literal">&lt;order-date&gt;</tt> element. In addition, each <tt class="literal">&lt;item-ordered&gt;</tt> element must contain a <tt class="literal">part-number</tt> attribute and a <tt class="literal">quantity</tt> attribute.</p>
        <p>Here's a sample DTD that defines the constraints we just mentioned:</p>
        <blockquote><pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!ELEMENT po (customer-id , item-ordered+ , order-date)&gt;

&lt;!ELEMENT customer-id (#PCDATA)&gt;

&lt;!ELEMENT item-ordered EMPTY&gt;

&lt;!ATTLIST item-ordered  part-number CDATA  #REQUIRED
                        quantity    CDATA  #REQUIRED &gt;
&lt;!ELEMENT order-date EMPTY&gt;

&lt;!ATTLIST order-date  day   CDATA  #REQUIRED
                      month CDATA  #REQUIRED
                      year  CDATA  #REQUIRED &gt;</pre></blockquote>
        <p>And here's an XML Schema that defines the same document type:</p>
        <blockquote><pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2000/10/XMLSchema"&gt;

  &lt;xsd:element name="po"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="customer-id"/&gt;
        &lt;xsd:element ref="item-ordered" maxOccurs="unbounded"/&gt;
        &lt;xsd:element ref="order-date"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="customer-id" type="xsd:string"/&gt;

  &lt;xsd:element name="item-ordered"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:attribute name="part-number" use="required"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:string"&gt;
            &lt;xsd:pattern value="[0-9]{5}-[0-9]{4}-[0-9]{5}"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:attribute&gt;
      &lt;xsd:attribute name="quantity" use="required" type="xsd:integer"/&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="order-date"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:attribute name="day" use="required"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:integer"&gt;
            &lt;xsd:maxInclusive value="31"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:attribute&gt;
      &lt;xsd:attribute name="month" use="required"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:integer"&gt;
            &lt;xsd:maxInclusive value="12"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:attribute&gt;
      &lt;xsd:attribute name="year" use="required"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:integer"&gt;
            &lt;xsd:maxInclusive value="2100"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:attribute&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;
&lt;/xsd:schema&gt;</pre></blockquote>
        <p>Schemas have two significant advantages over DTDs:</p>
        <ul>
          <li>

<a name="INDEX-48" />

            <p><em class="emphasis">They can define datatypes and other complex structures that are difficult or impossible to do in a DTD.</em>  In the previous example, we defined various constraints for the data in our XML documents. We defined that the <tt class="literal">day</tt> attribute must be an integer between 1 and 31, and the <tt class="literal">month</tt> attribute must be an integer between 1 and 12. We also used a regular expression to define a <tt class="literal">part-number</tt> attribute as a five-digit number, a dash, a four-digit number, a dash, and another five-digit number. None of those things are possible in a DTD. </p>
          </li>
          <li>
            <p><em class="emphasis">Schemas are themselves XML
          documents</em>. Since they are XML documents, we can
          write XSLT stylesheets to manipulate them. There are
          products in the marketplace today that take a schema and
          generate documentation from it. <a href="ch01_02.htm">Figure 1-1</a> shows some sample output generated from our schema.</p>
            <a name="xslt-CHP-1-FIG-1" /><div class="figure"><img height="368" alt="Figure 1-1" src="figs/xslt.0101.gif" width="481" /></div><h4 class="objtitle">Figure 1-1. Automatically generated XML Schema documentation</h4>
            <p>Generating this output is relatively straightforward
          because the tool transforms an XML document. The schema
          defines a variety of elements and attributes and constraints
          on valid data, all of which can be easily converted into
          other formats, such as the HTML shown in <a href="ch01_02.htm">Figure 1-1</a>.
<a name="INDEX-49" />
<a name="INDEX-50" />


</p>
          </li>
        </ul>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.9. Well-formed versus valid documents</h3>
        <p>

<a name="INDEX-51" />
<a name="INDEX-52" />
<a name="INDEX-53" />
<a name="INDEX-54" />


Any XML document that follows the rules described here is said to be <em class="emphasis">well-formed</em>. In addition, if an XML document references a set of rules that define how the document is structured (either a DTD or an XML Schema), and it follows all those rules, it is said to be a <em class="emphasis">valid</em> document. </p>
        <p>All valid documents are well-formed; on the other hand, not all well-formed documents are valid. </p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.10. Tags versus elements</h3>
        <p>
<a name="INDEX-55" />
<a name="INDEX-56" />
<a name="INDEX-57" />
<a name="INDEX-58" />


Although many people use the two terms interchangably, a tag is different from an element. A tag is the text between the angle brackets (<tt class="literal">&lt;</tt> and <tt class="literal">&gt;</tt>). There are start tags, end tags, and empty tags. A tag consists of a tag name and, if it is a start tag or an empty tag, some optional attributes. (Unlike other markup languages, end tags in XML cannot contain attributes.)  An element consists of the start tag for the element, the end tag for the element, and everything in between. This might include text, other elements, and comments, as well as other things such as entity references and processing instructions. </p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.2.11. Namespaces</h3>
        <p>
<a name="INDEX-59" />

A final XML topic we'll mention here is <em class="emphasis">namespaces.</em>  Namespaces are designed to distinguish between two tags that have the same name. For example, if I design an XML vocabulary for books and you design an XML vocabulary for paintings, it's likely that both of us will define a <tt class="literal">&lt;title&gt;</tt> element. My <tt class="literal">&lt;title&gt;</tt> element refers to the title of a book, while yours refers to the title of a painting. If someone needs to create an XML document that refers to both books and paintings, they can use a namespace to distinguish between the two <tt class="literal">&lt;title&gt;</tt> elements. Namespaces are defined and used as follows:</p>
        <blockquote><pre class="code">
&lt;xyz xmlns:books="http://www.myco.com/books.dtd" 
     xmlns:paintings="http://www.yourco.com/paintings.xsd"&gt;</pre></blockquote>
        <p>In this example, the <tt class="literal">xmlns:books</tt> attribute associates a string with the <tt class="literal">books</tt> DTD, and the <tt class="literal">xmlns:paintings</tt> attribute associates a string with the <tt class="literal">paintings</tt> schema. This means that a <tt class="literal">title</tt> element from the <tt class="literal">books</tt> DTD would be coded as <tt class="literal">&lt;books:title&gt;</tt>, while a <tt class="literal">title</tt> element from the <tt class="literal">paintings</tt> schema would be referred to as <tt class="literal">&lt;paintings:title&gt;</tt>.</p>
        <p>
<a name="INDEX-60" />
<a name="INDEX-61" />

I mention namespaces here primarily because all XSLT elements we use in this book are prefixed with the <tt class="literal">xsl</tt> namespace prefix. All stylesheets we write begin like this:</p>
        <blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;</pre></blockquote>
        <p>This opening associates the <tt class="literal">xsl</tt> namespace prefix with the string <tt class="literal">http://www.w3.org/1999/XSL/Transform</tt>. The value of the namespace prefix doesn't matter; we could start our stylesheets like this:</p>
        <blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;pdq:stylesheet xmlns:pdq="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;</pre></blockquote>
        <p>What matters is the string to which the namespace prefix is mapped. Also keep in mind that all XSLT stylesheets use namespace prefixes to process the XML elements they contain. By default, anything that doesn't use the <tt class="literal">xsl</tt> namespace prefix is not processed -- it's written to the result tree. We'll discuss these topics in more detail as we go through the book.

<a name="INDEX-62" />
<a name="INDEX-63" />


</p>
      </div>
    </div>
    <div class="sect2">
      <h3 class="sect2">1.2.3. DOM and SAX</h3>
      <p>
<a name="INDEX-64" />
<a name="INDEX-65" />
<a name="INDEX-66" />
<a name="INDEX-67" />
<a name="INDEX-68" />
<a name="INDEX-69" />
<a name="INDEX-70" />


The two most popular APIs used to parse XML documents are the Document Object Model (DOM) and the Simple API for XML (SAX). DOM is an official recommendation of the W3C (available at <a href="../../../../../../www.w3.org/TR/REC-DOM-Level-1">http://www.w3.org/TR/REC-DOM-Level-1</a>), while SAX is a de facto standard created by David Megginson and others on the XML-DEV mailing list (<a href="../../../../../../lists.xml.org/archives">http://lists.xml.org/archives</a>). We'll discuss these two APIs briefly here. We won't use them much in this book, but discussing them will give you some insight into how most XSLT processors work. </p>
<a name="INDEX-71" />
      <blockquote><b>TIP:</b> See <a href="../../../../../../www.megginson.com/SAX/">http://www.megginson.com/SAX/</a> for the SAX standard. (Make sure the letters <tt class="literal">SAX</tt> are in uppercase.)  If you'd like to learn more about the XML-DEV mailing list, send email with "subscribe xml-dev" in the body of the message to 
<a href="mailto:majordomo@xml.org"><em class="email">majordomo@xml.org</em></a>. You can also check out <a href="../../../../../../www.lists.ic.ac.uk/hypermail/xml-dev">http://www.lists.ic.ac.uk/hypermail/xml-dev</a> to see the XML-DEV mailing list archives.</p>
      </blockquote>
      <div class="sect3">
        <h3 class="sect3">1.2.3.1. DOM</h3>
        <p>DOM is designed to build a tree view of your document. Remember that all XML documents must be contained in a single element; that single element becomes the root of the tree. The DOM specification defines several language-neutral interfaces, described here:</p>
        <dl>
          
            <dt><tt class="literal">Node</tt></dt>
            <dd>
              This interface is the base datatype of the DOM. <tt class="literal">Element</tt>, <tt class="literal">document</tt>, <tt class="literal">text</tt>, <tt class="literal">comment</tt>, and <tt class="literal">attr</tt> all extend the <tt class="literal">Node</tt> interface.</p>
            </dd>
          
          
            <dt><tt class="literal">Document</tt></dt>
            <dd>
              This object contains the DOM representation of the XML document. Given a <tt class="literal">Document</tt> object, you can get the root of the tree (the <tt class="literal">Document</tt> element); from the root, you can move through the tree to find all elements, attributes, text, comments, processing instructions, etc., in the XML document.</p>
            </dd>
          
          
            <dt><tt class="literal">Element</tt></dt>
            <dd>
              This interface represents an element in an XML document.</p>
            </dd>
          
          
            <dt><tt class="literal">Attr</tt></dt>
            <dd>
              This interface represents an attribute of an element in an XML document.</p>
            </dd>
          
          
            <dt><tt class="literal">Text</tt></dt>
            <dd>
              This interface represents a piece of text from the XML document. Any text in your XML document becomes a <tt class="literal">Text</tt> node. This means that the text of a DOM object is a child of the object, not a property of it. The text of an <tt class="literal">Element</tt> is represented as a <tt class="literal">Text</tt> child of an <tt class="literal">Element</tt> object; the text of an <tt class="literal">Attr</tt> is also represented that way.</p>
            </dd>
          
          
            <dt><tt class="literal">Comment</tt></dt>
            <dd>
              This interface represents a comment in the XML document. A comment begins with <tt class="literal">&lt;!--</tt> and ends with <tt class="literal">--&gt;</tt>. The only restriction on its contents is that two consecutive hyphens (<tt class="literal">--</tt>) can appear only at the start or end of the comment. Other than that, a comment can include angle brackets (<tt class="literal">&lt; &gt;</tt>), ampersands (<tt class="literal">&amp;</tt>), single or double quotation marks (<tt class="literal">' "</tt>), and anything else. </p>
            </dd>
          
          
            <dt><tt class="literal">ProcessingInstruction</tt></dt>
            <dd>
              This interface represents a processing instruction in the XML document. Processing instructions look like this:</p>
              <blockquote><pre class="code">
&lt;?xml-stylesheet href="case-study.xsl" type="text/xsl"?&gt;
&lt;?cocoon-process type="xslt"?&gt;</pre></blockquote>
              <p>Processing instructions contain processor-specific information. The first of the two PIs (PI is XML jargon -- feel free to drop this into casual conversations to impress your friends) is the standard way to associate an XSLT stylesheet with an XML document (more on this in a minute). The second PI is used by Cocoon, an XML publishing framework from the Apache Software Foundation. (If you're not familiar with Cocoon, look at the Cocoon home page at <a href="../../../../../../xml.apache.org/cocoon">http://xml.apache.org/cocoon</a>.)</p>
            </dd>
          
        </dl>
        <p>When you parse an XML document with a DOM parser, it:</p>
        <ul>
          <li>
            <p>Creates objects (<tt class="literal">Element</tt>s, <tt class="literal">Attr</tt>, <tt class="literal">Text</tt>, <tt class="literal">Comment</tt>s) representing the contents of the document. These objects implement the interfaces defined in the DOM specification.</p>
          </li>
          <li>
            <p>Arranges these objects in a tree. Each <tt class="literal">Element</tt> in the XML document has some properties (such as the element's name), and may also have some children.</p>
          </li>
          <li>
            <p>Parses the entire document before control returns to your code. This means that for large documents, there is a significant delay while the document is parsed.</p>
          </li>
        </ul>
        <p>The most significant thing about the DOM is that it is based on a tree view of your document. An XSLT processor uses a very similar tree view (with some slight differences, such as the fact that not everything we deal with in XPath and XSLT has the same root element). Understanding how a DOM parser works makes it easier to understand how an XSLT processor views your document. </p>
        <div class="sect4">
          <h4 class="sect4">1.2.3.1.1. A sample DOM tree</h4>
          <p>DOM, XSLT, and XPath all use tree structures to
      represent data from an XML document. For this reason, it's
      important to have at least a casual knowledge of how DOM builds
      a tree structure. Our earlier
      <tt class="literal">&lt;postalcodes&gt;</tt> document is shown as a
      DOM tree in <a href="ch01_02.htm">Figure 1-2</a>.</p>
          <a name="xslt-CHP-1-FIG-2" /><div class="figure"><img height="327" alt="Figure 1-2" src="figs/xslt.0102.gif" width="481" /></div><h4 class="objtitle">Figure 1-2. DOM tree representation of an XML document</h4>
<a name="INDEX-72" />
<a name="INDEX-73" />
          <blockquote><b>NOTE:</b> 

The image in <a href="ch01_02.htm">Figure 1-2</a> was produced by the DOMit servlet, an XML validation service available at <a href="../../../../../../www-106.ibm.com/developerworks/features/xmlvalidatorform.html">http://www-106.ibm.com/developerworks/features/xmlvalidatorform.html</a>.</p>
          </blockquote>
<a name="INDEX-74" />
          <p>If we want to find different parts of our XML document, sort the subtrees based on the first character of the text of the <tt class="literal">&lt;postalcode&gt;</tt> element, or select only the subtrees in which the text of the <tt class="literal">&lt;usage-count&gt;</tt> element has a numeric value greater than 500, we have to start at the top of the DOM tree and work our way down through the root element's descendants. When we write XSLT stylesheets, we also start at the root of the tree and work our way down. </p>
          <blockquote><b>WARNING:</b> To be honest, the DOM tree built for our document is more complicated than our beautiful picture indicates. The whitespace characters in our document (carriage return/line feed, tabs, spaces, etc.) become <tt class="literal">Text</tt> nodes. Normally it's a good idea to remove this whitespace so the DOM tree won't be littered with these useless <tt class="literal">Text</tt> nodes, but I included them here to give you a sense of the XML document's structure. </p>
          </blockquote>
        </div>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.3.2. SAX</h3>
        <p>The Simple API for XML was developed by David Megginson and others on the XML-DEV mailing list. It has several important differences from DOM:</p>
        <ul>
          <li>
            <p>The SAX API is interactive. As a SAX parser processes your document, it sends events to your code. You don't have to wait for the parser to finish the entire document as you do with the DOM; you get events from the parser immediately. These events let you know when the parser finds the start of the document, the start of an element, some text, the end of an element, a processing instruction, the end of the document, etc. </p>
          </li>
          <li>
            <p>SAX is designed to avoid the large memory footprint of DOM. In the SAX world, you're told when the parser finds things in the XML document; it's up to you to save those things. If you don't do anything to store the data found by the parser, it goes into the bit bucket. </p>
          </li>
          <li>
            <p>SAX doesn't provide the hierarchical view of the document that DOM does. If you need to know a lot about the structure of an XML document and the context of a given element, SAX isn't much help. Each SAX event is stateless; that is, a SAX event won't tell you, "Here's some text for the <tt class="literal">&lt;postalcode&gt;</tt> element I mentioned earlier." A SAX parser only tells you, "Here's some text."  If you need to know about an XML document's structure, you have to keep track of that information yourself. </p>
          </li>
        </ul>
        <p>The best thing about SAX is that it is interactive. Most of the transformations currently done with XSLT take place on the server. As of this writing, most XSLT processors are based on DOM parsers. In the near future, however, we'll see XSLT processors based on SAX parsers. This means that the processor can start generating results almost as soon as the parse of the source document begins, resulting in better throughput and creating the perception of faster service. Because DOM, XPath, and XSLT all use trees to represent XML documents, DOM is more relevant to our discussions here. Nevertheless, it's useful to know how SAX parsers work, especially as SAX-based XSLT processors begin to rear their speedy little heads.

<a name="INDEX-75" />
<a name="INDEX-76" />
</p>
      </div>
    </div>
    <div class="sect2">
      <h3 class="sect2">1.2.4. XML Standards</h3>
      <p>
<a name="INDEX-77" />
<a name="INDEX-78" />
<a name="INDEX-79" />
<a name="INDEX-80" />
<a name="INDEX-81" />



When we talk about writing stylesheets, we'll work with two standards:  XSLT and XPath. XSLT defines a set of primitives used to describe a document transformation, while XPath defines a syntax for describing locations in XML documents. When we write stylesheets, we'll use XSLT to tell the processor what to do, and we'll use XPath to tell the processor what to do it to. Both standards are available at the W3C's web site; see <a href="../../../../../../www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a> and <a href="../../../../../../www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a> for more information. </p>
      <p>There are other XML-related standards, of course. We'll discuss them here briefly, with a short mention of how (or whether) they relate to our work with XSLT and XPath. </p>
      <div class="sect3">
        <h3 class="sect3">1.2.4.1. XML 1.0</h3>
        <p>
<a name="INDEX-82" />

XML 1.0 is the foundation upon which everything else is built. See <a href="../../../../../../www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a>.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.2. The Extensible Stylesheet Language (XSL)</h3>
        <p>
<a name="INDEX-83" />
<a name="INDEX-84" />
<a name="INDEX-85" />

Also called the <em class="emphasis">Formatting Objects specification</em> or <em class="emphasis">XSL-FO</em>, this standard deals with rendering XML elements. Although most people think of rendering as formatting for a browser or a printed page, researchers use the specification to render XML elements as Braille or as audio files. (That being said, the main market for this technology is in producing high-quality printed output.)  As of this writing, the XSL-FO specification is a Candidate Recommendation at the W3C. A couple of our examples in this book use formatting objects and the Apache XML Project's Formatting Object to PDF translator (FOP) tool; see <a href="../../../../../../xml.apache.org/fop">http://xml.apache.org/fop</a> for more information on FOP. For more information on XSL, see <a href="../../../../../../www.w3.org/TR/xsl">http://www.w3.org/TR/xsl</a>.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.3. XML Schemas</h3>
        <p>
<a name="INDEX-86" />

In our earlier examples, we had a brief example of an XML Schema. Part 1 of the specification deals with XML document structures; it contains XML elements that define what can appear in an XML document. You use these elements to specify which elements can be nested inside others, how many times each element can appear, the attributes of those elements, and other features. Part 2 of the specification defines basic datatypes used in XML Schemas and rules for deriving new datatypes from existing ones. </p>
        <p>The two specifications are available at <a href="../../../../../../www.w3.org/TR/xmlschema-1">http://www.w3.org/TR/xmlschema-1</a> and <a href="../../../../../../www.w3.org/TR/xmlschema-2">http://www.w3.org/TR/xmlschema-2</a>. For a good introduction to XML Schemas, see the XML Schema Primer, available at <a href="../../../../../../www.w3.org/TR/xmlschema-0">http://www.w3.org/TR/xmlschema-0</a>.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.4. The Simple API for XML (SAX)</h3>
        <p>
<a name="INDEX-87" />


The SAX API defines the events and interfaces used to interact with a SAX parser. SAX and DOM are the most common APIs used to work with XML documents. See <a href="../../../../../../www.megginson.com/SAX/">http://www.megginson.com/SAX/</a> for the complete specification. (Note that the letters "SAX" must be in uppercase.)</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.5. Document Object Model (DOM) Level 1</h3>
        <p>
<a name="INDEX-88" />

The DOM, as we discussed earlier, is a programming API for documents. It defines a set of interfaces and methods used to view an XML document as a tree structure. XSLT and XPath use a similar tree view of XML documents. See <a href="../../../../../../www.w3.org/TR/REC-DOM-Level-1">http://www.w3.org/TR/REC-DOM-Level-1</a> for more information.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.6. Document Object Model (DOM) Level 2</h3>
        <p>The DOM Level 2 standard builds on DOM Level 1. It adds several new features:  </p>
        <ul>
          <li>
            <p>HTML support, providing a DOM view of HTML documents</p>
          </li>
          <li>
            <p>CSS and stylesheet interfaces</p>
          </li>
          <li>
            <p>Document events</p>
          </li>
          <li>
            <p>Tree traversal methods</p>
          </li>
          <li>
            <p>Range selection methods</p>
          </li>
          <li>
            <p>Views of DOM trees, in which the view is separate from the DOM itself</p>
          </li>
        </ul>
        <p>The new features of DOM Level 2 don't affect our work directly. If you read the specification, you'll see that certain features, such as views, stylesheet interfaces, and tree traversal, provide features useful to an XSLT processor. Although future XSLT processors will be built on XML parsers that provide these functions, that won't change any of the techniques we cover in this book. See <a href="../../../../../../www.w3.org/TR/DOM-Level-2">http://www.w3.org/TR/DOM-Level-2</a> for the complete specification.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.7. Namespaces in XML</h3>
        <p>
<a name="INDEX-89" />

As we mentioned earlier, namespaces provide a way to avoid name collisions when two XML elements have the same name. See <a href="../../../../../../www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</a> for more information.</p>
      </div>
      <a name="xslt-CHP-1-SECT-2.4.8" /><div class="sect3">
        <h3 class="sect3">1.2.4.8. Associating stylesheets with XML documents</h3>
        <p>
<a name="INDEX-90" />
<a name="INDEX-91" />

It's possible to reference an XSLT stylesheet within an XML document. This specification uses processing instructions to define one or more stylesheets that should be used to transform an XML document. You can define different stylesheets to be used for different browsers. See <a href="../../../../../../www.w3.org/TR/xml-stylesheet">http://www.w3.org/TR/xml-stylesheet</a> for complete information. Here's the start of an XML document, with two associated stylesheets:</p>
        <blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet href="docbook/html/docbook.xsl" type="text/xsl"?&gt;
&lt;?xml-stylesheet href="docbook/wap/docbook.xsl"  type="text/xsl" media="wap"?&gt;</pre></blockquote>
        <p>In this example, the first stylesheet is the default because it doesn't have a <tt class="literal">media</tt> attribute. The second stylesheet will be used when the <tt class="literal">User-Agent</tt> field from the HTTP header contains the string <tt class="literal">wap</tt>, identifying the requester of a document as a WAP browser. The advantage of this technique is that you can define several different stylesheets within a particular document and have each stylesheet generate useful results for different browser or client types. The disadvantage of this technique is that we're effectively putting rendering instructions into our XML document, something we prefer to avoid. </p>
        <p>If you use Microsoft Internet Explorer Version 5.0 or higher, you can install the Microsoft's XSLT processor so that opening an XML document in your browser will cause it to be transformed and rendered automatically. For more details on how to install and configure the XML tools to work with the brower, see <a href="../../../../../../www.microsoft.com/xml">http://www.microsoft.com/xml</a>. In the previous example, if we opened an XML document that began this way, the browser would transform the XML document according to the rules defined in <em class="filename">docbook/html/docbook.xsl</em> and render the results as if it were any HTML page. </p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.9. Scalable Vector Graphics (SVG)</h3>
        <p>
<a name="INDEX-92" />
<a name="INDEX-93" />

The SVG specification defines an XML vocabulary for vector graphics. Described by some as "PostScript with angle brackets," it allows you to define images that can be scaled to any size or resolution. See <a href="../../../../../../www.w3.org/TR/SVG/">http://www.w3.org/TR/SVG/</a> for details.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.10. Canonical XML Version 1.0</h3>
        <p>

<a name="INDEX-94" />
Sometimes comparing two XML documents is necessary (when digitally signing an XML document, for example). The Canonical XML specification defines a canonical form of XML that makes comparing two documents easy. See <a href="../../../../../../www.w3.org/TR/xml-c14n">http://www.w3.org/TR/xml-c14n</a> for the complete specification.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.11. XML digital signatures</h3>
        <p>
<a name="INDEX-95" />

A joint effort of the W3C and the Internet Engineering Task Force (IETF), XML digital signatures provide a mechanism for storing digital signatures in an XML document. The XML document then provides an envelope used to store, send, and retrieve digital signatures for any kind of digital resource. The latest draft of the specification can be found at <a href="../../../../../../www.w3.org/TR/xmldsig-core">http://www.w3.org/TR/xmldsig-core</a>.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.12. XML Pointer Language (XPointer) Version 1.0</h3>
        <p>
<a name="INDEX-96" />
<a name="INDEX-97" />

XPointer provides a way to identify a fragment of a web resource. It uses XPath to identify fragments. For details, see <a href="../../../../../../www.w3.org/TR/xptr">http://www.w3.org/TR/xptr</a>.</p>
      </div>
      <div class="sect3">
        <h3 class="sect3">1.2.4.13. XML Linking Language (XLink) Version 1.0</h3>
        <p>
<a name="INDEX-98" />
<a name="INDEX-99" />


XLink defines an XML vocabulary for linking to other web resources within an XML document. It supports the unidirectional links we're all familiar with in HTML, as well as more sophisticated links. See <a href="../../../../../../www.w3.org/TR/xlink/">http://www.w3.org/TR/xlink/</a>.
<a name="INDEX-100" />
<a name="INDEX-101" />
<a name="INDEX-102" />
<a name="INDEX-103" />



</p>
      </div>
    </div>
  

<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch01_01.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch01_03.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">1. Getting Started</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">1.3. Installing Xalan</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
</map>

</body></html>
