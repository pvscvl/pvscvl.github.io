<html><head><title>XSLT Reference (XSLT)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Doug Tidwell" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596000537L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="XSLT" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="XSLT" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch09_06.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"></td><td align="right" valign="top" width="228"><a href="appb_01.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>



<h1 class="chapter">Appendix A. XSLT Reference</h1>
<p>

<a name="INDEX-817" />
<a name="INDEX-818" />
<a name="INDEX-819" />
<a name="INDEX-820" />


This chapter is a complete reference to all the elements defined in the XSLT specification.</p>




<a name="INDEX-821" /><a name="INDEX-822" /><div class="refentry">
<table width="684" border="0" cellpadding="5">
<tr><td width="30%" align="left">
<font size="+1"><b><i>&lt;xsl:apply-imports&gt;</i></b></font></td>
<td align="right"><i>Allows you to apply any overridden templates to the current node. It is comparable to the super() method in Java.
</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:apply-imports&gt;</tt> is an empty element. </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:apply-imports&gt;</tt> appears inside a template. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 5.6, Overriding Template Rules.</p>

<h4 class="refsect1">Example</h4>
<p>Here is a short XML file we'll use to illustrate <tt class="literal">&lt;xsl:apply-imports&gt;</tt>:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;test&gt;

  &lt;p&gt;This is a test XML document used by several 
  of our sample stylesheets.&lt;/p&gt;
  &lt;question&gt;
    &lt;text&gt;When completed, the Eiffel Tower was the 
    tallest building in the world.&lt;/text&gt;
    &lt;true correct="yes"&gt;You're correct!  The Eiffel 
    Tower was the world's tallest building until 1930.&lt;/true&gt;
    &lt;false&gt;No, the Eiffel Tower was the world's tallest 
    building for over 30 years.&lt;/false&gt;
  &lt;/question&gt;
  &lt;question&gt;
    &lt;text&gt;New York's Empire State Building knocked the 
    Eiffel Tower from its pedestal.&lt;/text&gt;
    &lt;true&gt;No, that's not correct.&lt;/true&gt;
    &lt;false correct="yes"&gt;Correct!  New York's Chrysler 
    Building, completed in 1930, became the world's tallest.&lt;/false&gt;
  &lt;/question&gt;
&lt;/test&gt;</pre></blockquote>
<p>Here's the stylesheet we'll import:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;body&gt;
        &lt;xsl:for-each select="//text|//true|//false"&gt;
          &lt;p&gt;
            &lt;xsl:apply-templates select="."/&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="text"&gt;
    &lt;xsl:text&gt;True or False: &lt;/xsl:text&gt;&lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="true|false"&gt;
    &lt;b&gt;&lt;xsl:value-of select="name()"/&gt;:&lt;/b&gt;
    &lt;br/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>


<p>This template provides basic formatting for the
<tt class="literal">&lt;true&gt;</tt> and <tt class="literal">&lt;false&gt;</tt>
elements, as shown in <a href="appa_01.htm">Figure A-1</a>.</p>
<a name="xslt-APPA-FIG-1" /><div class="figure"><img height="317" alt="Figure A-1" src="figs/xslt.aa01.gif" width="455" /></div><h4 class="objtitle">Figure A-1. Document generated with basic formatting</h4>
<p>We'll illustrate <tt class="literal">&lt;xsl:apply-imports&gt;</tt> with this stylesheet, which imports the other stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:import href="imported.xsl"/&gt;
  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;A Brief Test&lt;/title&gt;
        &lt;style&gt;
          &lt;xsl:comment&gt; 
            p.question {font-size: 125%; font-weight: bold} 
            p.right    {color: green}
            p.wrong    {color: red}
          &lt;/xsl:comment&gt;
        &lt;/style&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;A Brief Test&lt;/h1&gt;
        &lt;xsl:for-each select="//question"&gt;
          &lt;table border="1"&gt;
            &lt;xsl:apply-templates select="text"/&gt;
            &lt;xsl:apply-templates select="true|false"/&gt;
          &lt;/table&gt;
          &lt;br/&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="text"&gt;
    &lt;tr bgcolor="lightslategray"&gt;
      &lt;td&gt;
        &lt;p class="question"&gt;
          &lt;xsl:apply-imports/&gt;
        &lt;/p&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="true|false"&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="@correct='yes'"&gt;
            &lt;p class="right"&gt;
              &lt;xsl:apply-imports/&gt;
            &lt;/p&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;p class="wrong"&gt;
              &lt;xsl:apply-imports/&gt;
            &lt;/p&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Using <tt class="literal">&lt;xsl:apply-imports&gt;</tt> allows us to augment the behavior of the imported templates.  Our new stylesheet produces this document:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;A Brief Test&lt;/title&gt;
&lt;style&gt;
&lt;!-- 
            p.question {font-size: 125%; font-weight: bold} 
            p.right    {color: green}
            p.wrong    {color: red}
          --&gt;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;A Brief Test&lt;/h1&gt;
&lt;table border="1"&gt;
&lt;tr bgcolor="lightslategray"&gt;
&lt;td&gt;
&lt;p class="question"&gt;True or False: When completed, the Eiffel 
Tower was the tallest building in the world.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p class="right"&gt;
&lt;b&gt;true:&lt;/b&gt;
&lt;br&gt;You're correct!  The Eiffel Tower was the world's tallest 
building until 1930.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p class="wrong"&gt;
&lt;b&gt;false:&lt;/b&gt;
&lt;br&gt;No, the Eiffel Tower was the world's tallest building for 
over 30 years.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;table border="1"&gt;
&lt;tr bgcolor="lightslategray"&gt;
&lt;td&gt;
&lt;p class="question"&gt;True or False: New York's Empire State Building 
knocked the Eiffel Tower from its pedestal.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p class="wrong"&gt;
&lt;b&gt;true:&lt;/b&gt;
&lt;br&gt;No, that's not correct.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;
&lt;p class="right"&gt;
&lt;b&gt;false:&lt;/b&gt;
&lt;br&gt;Correct!  New York's Chrysler Building, completed in 1930, 
became the world's tallest.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>When rendered, this stylesheet looks like <a href="appa_01.htm">Figure A-2</a>.</p>
<a name="xslt-APPA-FIG-2" /><div class="figure"><img height="367" alt="Figure A-2" src="figs/xslt.aa02.gif" width="455" /></div><h4 class="objtitle">Figure A-2. Document generated with &lt;xsl:apply-imports&gt;</h4>
</div>
<a name="INDEX-823" /><a name="INDEX-824" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:apply-templates&gt;</i></b></font></td><td align="right"><i>Instructs the XSLT processor to apply the appropriate templates to a node-set.  </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>select</i></dt>
<dd>
Contains an XPath expression that selects the nodes to which templates should be applied.  Valid values include <tt class="literal">*</tt> to select the entire node-set.  Without this attribute, all element children of the current node are selected. </p>
</dd>


<dt><i>mode</i></dt>
<dd>
Defines a processing mode, a convenient syntax that lets you write specific templates for specific purposes.  For example, I could write an <tt class="literal">&lt;xsl:template&gt;</tt> with <tt class="literal">mode="toc"</tt> to process a node for the table of contents of a document, and other <tt class="literal">&lt;xsl:template&gt;</tt>s with <tt class="literal">mode="print"</tt>, <tt class="literal">mode="online"</tt>, <tt class="literal">mode="index"</tt>, etc. to process the same information for different purposes.  </p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>The <tt class="literal">&lt;xsl:apply-templates&gt;</tt> element can contain any number of <tt class="literal">&lt;xsl:sort&gt;</tt> and <tt class="literal">&lt;xsl:with-param&gt;</tt> elements.  In most cases, <tt class="literal">&lt;xsl:apply-templates&gt;</tt> is empty. </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:apply-templates&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 5.4, Applying Template Rules. </p>

<h4 class="refsect1">Example</h4>
<p>In our case study (see <a href="ch09_01.htm">Chapter 9, "Case Study: The Toot-O-Matic"</a>), we needed to create several different outputs from the same data.  We addressed this need with the <tt class="literal">mode</tt> attribute of the <tt class="literal">&lt;xsl:apply-templates&gt;</tt> element.  Here's the main template (<tt class="literal">match="/"</tt>):</p>
<blockquote><pre class="code">
&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="tutorial" mode="build-main-index"/&gt;
  &lt;redirect:write select="concat($curDir, $fileSep, 'index.html')"&gt; 
    &lt;xsl:apply-templates select="tutorial" mode="build-main-index"/&gt;
  &lt;/redirect:write&gt;
  &lt;xsl:apply-templates select="tutorial" mode="build-section-indexes"/&gt;
  &lt;xsl:apply-templates select="tutorial" mode="build-individual-panels"/&gt;
  &lt;xsl:apply-templates select="tutorial" mode="generate-graphics"/&gt;
  &lt;xsl:apply-templates select="tutorial" mode="generate-pdf-file"&gt;
    &lt;xsl:with-param name="page-size" select="'ltr'"/&gt;
  &lt;/xsl:apply-templates&gt;

  &lt;xsl:apply-templates select="tutorial" mode="generate-pdf-file"&gt;
    &lt;xsl:with-param name="page-size" select="'a4'"/&gt;
  &lt;/xsl:apply-templates&gt;
  &lt;xsl:apply-templates select="tutorial" mode="generate-zip-file"/&gt;
&lt;/xsl:template&gt;</pre></blockquote>
<p>Notice that this example selects the <tt class="literal">&lt;tutorial&gt;</tt> element eight times, but applies templates with a different mode (or different parameters for the same mode) each time. </p>
</div>
<a name="INDEX-825" /><a name="INDEX-826" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:attribute&gt;</i></b></font></td><td align="right"><i>Allows you to create an attribute in the output document. The advantage of &lt;xsl:attribute&gt; is that it allows you to build the attribute's value from parts of the input document, hardcoded text, values returned by functions, and any other value you can access from your stylesheet.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
The <tt class="literal">name</tt> attribute defines the name of the attribute created by the <tt class="literal">&lt;xsl:attribute&gt;</tt> element. (No matter how you try to say this, talking about the attributes of the <tt class="literal">&lt;xsl:attribute&gt;</tt> element is confusing, isn't it?)</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>namespace</i></dt>
<dd>
The <tt class="literal">namespace</tt> attribute defines the namespace URI that should be used for this attribute in the output document. You don't have control over the namespace prefix used; the only thing you specify with the <tt class="literal">namespace</tt> attribute is the URI of the namespace.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>An XSLT template. In other words, you can build the contents of an attribute with <tt class="literal">&lt;xsl:choose&gt;</tt> elements, <tt class="literal">&lt;xsl:text&gt;</tt>, and <tt class="literal">&lt;xsl:value-of&gt;</tt> elements. </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:attribute&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.1.3, Creating Attributes with <tt class="literal">xsl:attribute</tt>.</p>

<h4 class="refsect1">Example</h4>
<p>For this example, we want to create an HTML table from the following XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>We'll create a table that has each <tt class="literal">&lt;listitem&gt;</tt> in a separate row in the right column of the table, and a single cell with <tt class="literal">rowspan</tt> equal to the number of <tt class="literal">&lt;listitem&gt;</tt> elements in the XML document on the left. Clearly we can't hardcode a value for the <tt class="literal">rowspan</tt> attribute because the number of <tt class="literal">&lt;listitem&gt;</tt>s can change. This stylesheet uses <tt class="literal">&lt;xsl:attribute&gt;</tt> to do what we want:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="list/title"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates select="list"/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="list"&gt;
    &lt;table border="1" width="75%"&gt;
      &lt;tr&gt;
        &lt;td bgcolor="lightslategray" width="100" align="right"&gt;
          &lt;xsl:attribute name="rowspan"&gt;
            &lt;xsl:value-of select="count(listitem)"/&gt;
          &lt;/xsl:attribute&gt;
          &lt;p style="font-size: 125%"&gt;
            &lt;xsl:value-of select="title"/&gt;
          &lt;/p&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of select="listitem[1]"/&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
      &lt;xsl:for-each select="listitem"&gt;
        &lt;xsl:if test="position() &gt; 1"&gt;
          &lt;tr&gt;
            &lt;td&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/xsl:if&gt;
      &lt;/xsl:for-each&gt;
    &lt;/table&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here is the generated HTML document:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Albums I've bought recently:&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table width="75%" border="1"&gt;
&lt;tr&gt;
&lt;td align="right" width="100" rowspan="7" bgcolor="lightslategray"&gt;
&lt;p style="font-size: 125%"&gt;Albums I've bought recently:&lt;/p&gt;
&lt;/td&gt;&lt;td&gt;The Sacred Art of Dub&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Only the Poor Man Feel It&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Excitable Boy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Aki Special&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Combat Rock&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Talking Timbuktu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;The Birth of the Cool&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>Notice that the <tt class="literal">&lt;td&gt;</tt> element had several attributes hardcoded on it; those attributes are combined with the attribute we created with <tt class="literal">&lt;xsl:attribute&gt;</tt>. You can have as many <tt class="literal">&lt;xsl:attribute&gt;</tt> elements as you want, but they must appear together as the first thing inside the element to which you add attributes. <a href="appa_01.htm">Figure A-3</a> shows how our generated HTML document looks.</p>
<a name="xslt-appa-a3" /><div class="figure"><img height="231" alt="Figure A-3" src="figs/xslt.aa03.gif" width="405" /></div><h4 class="objtitle">Figure A-3. Document with generated Attributes</h4>
<p>Be aware that in this instance, we could have used an attribute-value template. You could generate the value of the <tt class="literal">rowspan</tt> attribute like this:</p>
<blockquote><pre class="code">
&lt;td bgcolor="lightslategray" rowspan="{count(listitem)}"
  width="100" align="right"&gt;</pre></blockquote>
<p>The expression in curly braces (<tt class="literal">{}</tt>) is evaluated and replaced with whatever its value happens to be. In this case, <tt class="literal">count(listitem)</tt> returns the number <tt class="literal">7</tt>, which becomes the value of the <tt class="literal">rowspan</tt> attribute.</p>
</div>
<a name="INDEX-827" /><a name="INDEX-828" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:attribute-set&gt;</i></b></font></td><td align="right"><i>Allows you to define a group of attributes for the output document. You can then reference the entire attribute set with its name, rather than create all attributes individually. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
Defines the name of this attribute set. </p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>use-attribute-sets</i></dt>
<dd>
Lists one or more attribute sets that should be used by this attribute set. If you specify more than one set, separate their names with whitespace characters. You can use this attribute to embed other <tt class="literal">&lt;xsl:attribute-set&gt;</tt>s in this one, but be aware that an <tt class="literal">&lt;xsl:attribute-set&gt;</tt> that directly or indirectly embeds itself results in an error. In other words, if attribute set <tt class="literal">A</tt> embeds attribute set <tt class="literal">B</tt>, which in turn embeds attribute set <tt class="literal">C</tt>, which in turn embeds attribute set <tt class="literal">A</tt>, the XSLT processor will signal an error.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>One or more <tt class="literal">&lt;xsl:attribute&gt;</tt> elements.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:stylesheet&gt;</tt>. <tt class="literal">&lt;xsl:attribute-set&gt;</tt> is a top-level element and can only appear as a child of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.1.4, Named Attribute Sets.</p>

<h4 class="refsect1">Example</h4>
<p>For this example, we'll create a stylesheet that defines attribute sets for regular text, emphasized text, and large text. Just for variety's sake, we'll use the Extensible Stylesheet Language Formatting Objects (XSL-FO) specification to convert our XML document into a PDF file. Here's our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:attribute-set name="regular-text"&gt;
    &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-family"&gt;sans-serif&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;

  &lt;xsl:attribute-set name="emphasized-text" use-attribute-sets="regular-text"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;

  &lt;xsl:attribute-set name="large-text" use-attribute-sets="regular-text"&gt;
    &lt;xsl:attribute name="font-size"&gt;18pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="space-after.optimum"&gt;21pt&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;

  &lt;xsl:template match="/"&gt;
    &lt;fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
      &lt;fo:layout-master-set&gt;
        &lt;fo:simple-page-master margin-right="75pt" margin-left="75pt" 
          page-height="11in" page-width="8.5in"
          margin-bottom="25pt" margin-top="25pt" master-name="main"&gt;
          &lt;fo:region-before extent="25pt"/&gt;
          &lt;fo:region-body margin-top="50pt" margin-bottom="50pt"/&gt;
          &lt;fo:region-after extent="25pt"/&gt;
        &lt;/fo:simple-page-master&gt;
        &lt;fo:page-sequence-master master-name="standard"&gt;
          &lt;fo:repeatable-page-master-alternatives&gt;
            &lt;fo:conditional-page-master-reference master-name="main" 
              odd-or-even="any"/&gt;
          &lt;/fo:repeatable-page-master-alternatives&gt;
        &lt;/fo:page-sequence-master&gt;
      &lt;/fo:layout-master-set&gt;
      
      &lt;fo:page-sequence master-name="standard"&gt;
        &lt;fo:flow flow-name="xsl-region-body"&gt;
          &lt;xsl:apply-templates select="list"/&gt;
        &lt;/fo:flow&gt;
      &lt;/fo:page-sequence&gt;
    &lt;/fo:root&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="list"&gt;
    &lt;fo:block xsl:use-attribute-sets="large-text"&gt;
      &lt;xsl:value-of select="title"/&gt;
    &lt;/fo:block&gt;
    &lt;fo:list-block provisional-distance-between-starts="0.4cm"
      provisional-label-separation="0.15cm"&gt;
      &lt;xsl:for-each select="listitem"&gt;
        &lt;fo:list-item start-indent="0.5cm" space-after.optimum="17pt"&gt;
          &lt;fo:list-item-label&gt;
            &lt;fo:block xsl:use-attribute-sets="regular-text"&gt;*&lt;/fo:block&gt;
          &lt;/fo:list-item-label&gt;
          &lt;fo:list-item-body&gt;
            &lt;fo:block xsl:use-attribute-sets="emphasized-text"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/fo:block&gt;
          &lt;/fo:list-item-body&gt;
        &lt;/fo:list-item&gt;
      &lt;/xsl:for-each&gt;
    &lt;/fo:list-block&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Notice that both the <tt class="literal">emphasized-text</tt> and <tt class="literal">large-text</tt> attribute sets use the <tt class="literal">regular-text</tt> attribute set as a base.  In the case of <tt class="literal">large-text</tt>, the <tt class="literal">font-size</tt> attribute defined in the <tt class="literal">large-text</tt> attribute set overrides the <tt class="literal">font-size</tt> attribute included from the <tt class="literal">regular-text</tt> attribute set.  We'll apply our stylesheet to the following XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>The stylesheet generates this messy-looking file of formatting objects, which describe how the text of our XML source document should be rendered:  </p>
<blockquote><pre class="code">
&lt;fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
&lt;fo:layout-master-set&gt;
&lt;fo:simple-page-master master-name="main" margin-top="25pt" 
margin-bottom="25pt" page-width="8.5in" page-height="11in" 
margin-left="75pt" margin-right="75pt"&gt;
&lt;fo:region-before extent="25pt"/&gt;
&lt;fo:region-body margin-bottom="50pt" margin-top="50pt"/&gt;
&lt;fo:region-after extent="25pt"/&gt;
&lt;/fo:simple-page-master&gt;
&lt;fo:page-sequence-master master-name="standard"&gt;
&lt;fo:repeatable-page-master-alternatives&gt;
&lt;fo:conditional-page-master-reference odd-or-even="any" master-name="main"/&gt;
&lt;/fo:repeatable-page-master-alternatives&gt;
&lt;/fo:page-sequence-master&gt;
&lt;/fo:layout-master-set&gt;
&lt;fo:page-sequence master-name="standard"&gt;
&lt;fo:flow flow-name="xsl-region-body"&gt;
&lt;fo:block font-size="18pt" font-family="sans-serif" 
font-weight="bold" space-after.optimum="21pt"&gt;A few of my 
favorite albums&lt;/fo:block&gt;
&lt;fo:list-block provisional-label-separation="0.15cm" 
provisional-distance-between-starts="0.4cm"&gt;
&lt;fo:list-item space-after.optimum="17pt" start-indent="0.5cm"&gt;
&lt;fo:list-item-label&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif"&gt;*&lt;/fo:block&gt;
&lt;/fo:list-item-label&gt;
&lt;fo:list-item-body&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif" 
font-style="italic"&gt;A Love Supreme&lt;/fo:block&gt;
&lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;fo:list-item space-after.optimum="17pt" start-indent="0.5cm"&gt;
&lt;fo:list-item-label&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif"&gt;*&lt;/fo:block&gt;
&lt;/fo:list-item-label&gt;
&lt;fo:list-item-body&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif" 
font-style="italic"&gt;Beat Crazy&lt;/fo:block&gt;
&lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;fo:list-item space-after.optimum="17pt" start-indent="0.5cm"&gt;
&lt;fo:list-item-label&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif"&gt;*&lt;/fo:block&gt;
&lt;/fo:list-item-label&gt;
&lt;fo:list-item-body&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif" 
font-style="italic"&gt;Here Come the Warm Jets&lt;/fo:block&gt;
&lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;fo:list-item space-after.optimum="17pt" start-indent="0.5cm"&gt;
&lt;fo:list-item-label&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif"&gt;*&lt;/fo:block&gt;
&lt;/fo:list-item-label&gt;
&lt;fo:list-item-body&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif" 
font-style="italic"&gt;Kind of Blue&lt;/fo:block&gt;
&lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;fo:list-item space-after.optimum="17pt" start-indent="0.5cm"&gt;
&lt;fo:list-item-label&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif"&gt;*&lt;/fo:block&gt;
&lt;/fo:list-item-label&gt;
&lt;fo:list-item-body&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif" 
font-style="italic"&gt;London Calling&lt;/fo:block&gt;
&lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;fo:list-item space-after.optimum="17pt" start-indent="0.5cm"&gt;
&lt;fo:list-item-label&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif"&gt;*&lt;/fo:block&gt;
&lt;/fo:list-item-label&gt;
&lt;fo:list-item-body&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif" 
font-style="italic"&gt;Remain in Light&lt;/fo:block&gt;
&lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;fo:list-item space-after.optimum="17pt" start-indent="0.5cm"&gt;
&lt;fo:list-item-label&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif"&gt;*&lt;/fo:block&gt;
&lt;/fo:list-item-label&gt;
&lt;fo:list-item-body&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif" 
font-style="italic"&gt;The Joshua Tree&lt;/fo:block&gt;
&lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;fo:list-item space-after.optimum="17pt" start-indent="0.5cm"&gt;
&lt;fo:list-item-label&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif"&gt;*&lt;/fo:block&gt;
&lt;/fo:list-item-label&gt;
&lt;fo:list-item-body&gt;
&lt;fo:block font-size="12pt" font-family="sans-serif" 
font-style="italic"&gt;The Indestructible Beat of Soweto&lt;/fo:block&gt;
&lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;/fo:list-block&gt;
&lt;/fo:flow&gt;
&lt;/fo:page-sequence&gt;
&lt;/fo:root&gt;</pre></blockquote>
<p>Be aware that as of this writing (May 2001), the XSL-FO specification isn't final, so there's no guarantee that these formatting objects will work correctly with future XSL-FO tools. Here's how we invoke the Apache XML Project's FOP (Formatting Objects to PDF translator) tool to create a PDF:</p>
<blockquote><pre class="code">
java org.apache.fop.apps.CommandLine test.fo test.pdf</pre></blockquote>
<p>The FOP tool creates a PDF that looks like <a href="appa_01.htm">Figure A-4</a>.</p>
<a name="xslt-appa-a4" /><div class="figure"><img height="309" alt="Figure A-4" src="figs/xslt.aa04.gif" width="455" /></div><h4 class="objtitle">Figure A-4. PDF generated from an XSL-FO file</h4>
</div>
<a name="INDEX-829" /><a name="INDEX-830" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:call-template&gt;</i></b></font></td><td align="right"><i>Lets you invoke a particular template by name.  This invocation is a convenient way to create commonly used output.  For example, if you create an HTML page and all your HTML pages have the same masthead and footer, you could define templates named masthead and footer, then use &lt;xsl:call-template&gt; to invoke those templates as needed. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
The name of the template you're invoking. </p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>This element can contain any number of optional <tt class="literal">&lt;xsl:with-param&gt;</tt> elements.  </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:call-template&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 6, Named Templates.</p>

<h4 class="refsect1">Example</h4>

<p>The <tt class="literal">&lt;xsl:call-template&gt;</tt> element gives
you an excellent way to create modular stylesheets.  In our case study
(see <a href="ch09_01.htm">Chapter 9, "Case Study: The Toot-O-Matic"</a>), we need to generate common items at
the top and bottom of every HTML page we generate. We build a
navigation bar and title bar at the top of each panel in a similar
way. Rather than intermingle these templates with the rest of our
stylesheets, we put the templates for the common sections of the HTML
pages in a separate stylesheet, then reference them when
needed. </p>

<blockquote><pre class="code">
&lt;xsl:call-template name="dw-masthead"/&gt;
&lt;xsl:call-template name="dw-title-bar"/&gt;
&lt;xsl:call-template name="dw-nav-bar"&gt;
  &lt;xsl:with-param name="includeMain" select="'youBetcha'"/&gt;
  &lt;xsl:with-param name="sectionNumber" select="$sectionNumber"/&gt;
  &lt;xsl:with-param name="position" select="$pos"/&gt;
  &lt;xsl:with-param name="last" select="$last"/&gt;
  &lt;xsl:with-param name="topOrBottom" select="'top'"/&gt;
  &lt;xsl:with-param name="oneOrTwo" select="'two'"/&gt;
&lt;/xsl:call-template&gt;

&lt;!-- Processing for the main body of the page goes here --&gt;

&lt;xsl:call-template name="dw-nav-bar"&gt;
  &lt;xsl:with-param name="includeMain" select="'youBetcha'"/&gt;
  &lt;xsl:with-param name="sectionNumber" select="$sectionNumber"/&gt;
  &lt;xsl:with-param name="position" select="$pos"/&gt;
  &lt;xsl:with-param name="last" select="$last"/&gt;
  &lt;xsl:with-param name="topOrBottom" select="'bottom'"/&gt;
  &lt;xsl:with-param name="oneOrTwo" select="'two'"/&gt;
&lt;/xsl:call-template&gt;
&lt;xsl:call-template name="dw-footer"/&gt;</pre></blockquote>
<p>In this code fragment, we've invoked four templates to generate
  the look and feel we want our HTML pages to have. If we decide to
  change the look and feel of our tutorials, changing those four named
  templates lets us change the look and feel by simply transforming
  the XML document again. See <a href="ch09_05.htm">Section 9.5.5, "Generating the Individual Panels"</a> in
  <a href="ch09_01.htm">Chapter 9, "Case Study: The Toot-O-Matic"</a> for details on how this works. </p>
</div>
<a name="INDEX-831" /><a name="INDEX-832" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:choose&gt;</i></b></font></td><td align="right"><i>The &lt;xsl:choose&gt; element is XSLT's version of the switch or case statement found in many procedural programming languages. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>Contains one or more <tt class="literal">&lt;xsl:when&gt;</tt> elements and might contain a single <tt class="literal">&lt;xsl:otherwise&gt;</tt> element. Any <tt class="literal">&lt;xsl:otherwise&gt;</tt> elements must be the last element inside <tt class="literal">&lt;xsl:choose&gt;</tt>.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:choose&gt;</tt> appears inside a template. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 9.2, Conditional Processing with <tt class="literal">xsl:choose</tt>.</p>

<h4 class="refsect1">Example</h4>
<p>Here's an example that uses <tt class="literal">&lt;xsl:choose&gt;</tt> to select the background color for the rows of an HTML table. We cycle among four different values, using <tt class="literal">&lt;xsl:choose&gt;</tt> to determine the value of the <tt class="literal">bgcolor</tt> attribute in the generated HTML document. Here's the XML document we'll use:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>

<p>And here's our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="html"/&gt;
 
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:value-of select="list/title"/&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="list/title"/&gt;&lt;/h1&gt;
        &lt;table border="1"&gt;
          &lt;xsl:for-each select="list/listitem"&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;xsl:attribute name="bgcolor"&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="position() mod 4 = 0"&gt;
                      &lt;xsl:text&gt;papayawhip&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 1"&gt;
                      &lt;xsl:text&gt;mintcream&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 2"&gt;
                      &lt;xsl:text&gt;lavender&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:text&gt;whitesmoke&lt;/xsl:text&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/xsl:attribute&gt;
                &lt;xsl:value-of select="."/&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>


<p>We use <tt class="literal">&lt;xsl:choose&gt;</tt> to determine the background color of each generated <tt class="literal">&lt;td&gt;</tt> element.  Here's the generated HTML document, which cycles through the various background colors:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Albums I've bought recently:&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Albums I've bought recently:&lt;/h1&gt;
&lt;table border="1"&gt;
&lt;tr&gt;
&lt;td bgcolor="mintcream"&gt;The Sacred Art of Dub&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="lavender"&gt;Only the Poor Man Feel It&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="whitesmoke"&gt;Excitable Boy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="papayawhip"&gt;Aki Special&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="mintcream"&gt;Combat Rock&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="lavender"&gt;Talking Timbuktu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="whitesmoke"&gt;The Birth of the Cool&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>When rendered, our HTML document looks like <a href="appa_01.htm">Figure A-5</a>.</p>
<a name="xslt-appa-a5" /><div class="figure"><img height="248" alt="Figure A-5" src="figs/xslt.aa05.gif" width="455" /></div><h4 class="objtitle">Figure A-5. Document cycling among different background colors</h4>
</div>
<a name="INDEX-833" /><a name="INDEX-834" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:comment&gt;</i></b></font></td><td align="right"><i>Allows you to create a comment in the output document. Comments are sometimes used to add legal notices, disclaimers, or information about when the output document was created. Another useful application of the &lt;xsl:comment&gt; element is the generation of CSS definitions or JavaScript code in an HTML document.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>An XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:comment&gt;</tt> appears in a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.4, Creating Comments. </p>

<h4 class="refsect1">Example</h4>
<p>Here's a stylesheet that generates a comment to define CSS styles in an HTML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;XSLT and CSS Demo&lt;/title&gt;
        &lt;style&gt;
          &lt;xsl:comment&gt; 
            p.big      {font-size: 125%; font-weight: bold} 
            p.green    {color: green; font-weight: bold}
            p.red      {color: red; font-style: italic}
          &lt;/xsl:comment&gt;
        &lt;/style&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates select="list/title"/&gt;
        &lt;xsl:apply-templates select="list/listitem"/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="title"&gt;
    &lt;p class="big"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="listitem"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="position() mod 2"&gt;
        &lt;p class="green"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;p class="red"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  
&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>This stylesheet creates three CSS styles inside an HTML comment.  We'll apply the stylesheet to this document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>

<p>The stylesheet will apply one CSS style to the <tt class="literal">&lt;title&gt;</tt> element and will alternate between two CSS styles for the <tt class="literal">&lt;listitem&gt;</tt>s.  Here's the generated HTML:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;XSLT and CSS Demo&lt;/title&gt;
&lt;style&gt;
&lt;!-- 
            p.big      {font-size: 125%; font-weight: bold} 
            p.green    {color: green; font-weight: bold}
            p.red      {color: red; font-style: italic}
          --&gt;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p class="big"&gt;Albums I've bought recently:&lt;/p&gt;
&lt;p class="green"&gt;The Sacred Art of Dub&lt;/p&gt;
&lt;p class="red"&gt;Only the Poor Man Feel It&lt;/p&gt;
&lt;p class="green"&gt;Excitable Boy&lt;/p&gt;
&lt;p class="red"&gt;Aki Special&lt;/p&gt;
&lt;p class="green"&gt;Combat Rock&lt;/p&gt;
&lt;p class="red"&gt;Talking Timbuktu&lt;/p&gt;
&lt;p class="green"&gt;The Birth of the Cool&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>When rendered, the document looks like <a href="appa_01.htm">Figure A-6</a>.</p>
<a name="xslt-appa-a6" /><div class="figure"><img height="323" alt="Figure A-6" src="figs/xslt.aa06.gif" width="405" /></div><h4 class="objtitle">Figure A-6. Document with generated comment nodes</h4>
</div>
<a name="INDEX-835" /><a name="INDEX-836" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:copy&gt;</i></b></font></td><td align="right"><i>Makes a shallow copy of an element to the result tree.  This element only copies the current node and its namespace nodes. The children of the current node and any attributes it has are not copied.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>use-attribute-sets</i></dt>
<dd>
Lists one or more attribute sets that should be used by this element. If you specify more than one attribute set, separate their names with whitespace characters. See the description of the <tt class="literal">&lt;xsl:attribute-set&gt;</tt> element for more information.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>An XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:copy&gt;</tt> appears in a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.5, Copying.</p>

<h4 class="refsect1">Example</h4>
<p>We'll demonstrate <tt class="literal">&lt;xsl:copy&gt;</tt> with an example that copies an element to the result tree. Notice that we do not specifically request that the attribute nodes of the source document be processed, so the result tree will not contain any attributes. Here is our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;

  &lt;xsl:template match="*"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates/&gt;

    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll test our stylesheet with the following XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>Here are the results:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>The <tt class="literal">&lt;xsl:copy&gt;</tt> does a shallow copy, which gives you more control over the output than the <tt class="literal">&lt;xsl:copy-of&gt;</tt> element does. However, you must explicitly specify any child nodes or attribute nodes you would like copied to the result tree. The <tt class="literal">&lt;xsl:apply-templates&gt;</tt> element selects all text, element, comment, and processing-instruction children of the current element; without this element, the result tree would contain only a single, empty <tt class="literal">&lt;report&gt;</tt> element. Compare this approach with the example in the <tt class="literal">&lt;xsl:copy-of&gt;</tt> element.</p>
</div>
<a name="INDEX-837" /><a name="INDEX-838" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:copy-of&gt;</i></b></font></td><td align="right"><i>Copies things to the result tree. The select attribute defines the content to be copied. If the select attribute identifies a result-tree fragment, the complete fragment is copied to the result tree. If select identifies a node-set, all nodes in the node-set are copied to the result tree in document order; unlike &lt;xsl:copy&gt;, the node is copied in its entirety, including any namespace nodes, attribute nodes, and child nodes. If the select attribute identifies something other than a result-tree fragment or a node-set, it is converted to a string and inserted into the result tree.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>select</i></dt>
<dd>
Contains an XPath expression that defines the nodes to be copied to the output document.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:copy-of&gt;</tt> is an empty element. </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:copy-of&gt;</tt> appears inside a template. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 11.3, Using Values of Variables and Parameters with <tt class="literal">xsl:copy-of</tt>.
</p>

<h4 class="refsect1">Example</h4>
<p>We'll demonstrate <tt class="literal">&lt;xsl:copy-of&gt;</tt> with a simple stylesheet that copies the input document to the result tree. Here is our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;


  &lt;xsl:template match="/"&gt;
    &lt;xsl:copy-of select="."/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll test our stylesheet with the following document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>When we transform the XML document, the results are strikingly similar to the input document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>The only difference between the two documents is that the stylesheet engine has added an <tt class="literal">encoding</tt> to the XML declaration. Compare this to the example in the <tt class="literal">&lt;xsl:copy&gt;</tt> element.</p>
</div>
<a name="INDEX-839" /><a name="INDEX-840" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:decimal-format&gt;</i></b></font></td><td align="right"><i>Defines a number format to be used when writing numeric values to the output document. If the &lt;decimal-format&gt; does not have a name, it is assumed to be the default number format used for all output. On the other hand, if a number format is named, it can be referenced from the format-number() function.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
Gives a name to this format.</p>
</dd>


<dt><i>decimal-separator</i></dt>
<dd>
Defines the character (usually either a period or comma) used as the decimal point. This character is used both in the format string and in the output. The default value is the period character (<tt class="literal">.</tt>).</p>
</dd>


<dt><i>grouping-separator</i></dt>
<dd>
Defines the character (usually either a period or comma) used as the thousands separator. This character is used both in the format string and in the output. The default value is the comma (<tt class="literal">,</tt>).</p>
</dd>


<dt><i>infinity</i></dt>
<dd>
Defines the string used to represent infinity. Be aware that XSLT's number facilities support both positive and negative infinity. This string is used only in the output. The default value is the string "Infinity".</p>
</dd>


<dt><i>minus-sign</i></dt>
<dd>
Defines the character used as the minus sign. This character is used only in the output. The default value is the hyphen character (<tt class="literal">-</tt>, #x2D).</p>
</dd>


<dt><i>NaN</i></dt>
<dd>
Defines the string displayed when the value to be formatted is not a number. This string is used only in the output; the default value is the string "NaN".</p>
</dd>


<dt><i>percent</i></dt>
<dd>
Defines the character used as the percent sign. This character is used both in the format string and in the output. The default value is the percent sign (<tt class="literal">%</tt>).</p>
</dd>


<dt><i>per-mille</i></dt>
<dd>
Defines the character used as the per-mille sign. This character is used both in the format string and in the output. The default value is the Unicode per-mille character (#x2030).</p>
</dd>


<dt><i>zero-digit</i></dt>
<dd>
Defines the character used for the digit zero. This character is used both in the format string and in the output. The default is the digit zero (<tt class="literal">0</tt>).</p>
</dd>


<dt><i>digit</i></dt>
<dd>
Defines the character used in the format string to stand for a digit. The default is the number sign character (<tt class="literal">#</tt>).</p>
</dd>


<dt><i>pattern-separator</i></dt>
<dd>
Defines the character used to separate the positive and negative subpatterns in a pattern. The default value is the semicolon (<tt class="literal">;</tt>). This character is used only in the format string.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:decimal-format&gt;</tt> is an empty element.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:decimal-format&gt;</tt> is a top-level element and can only appear as a child of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.3, Number Formatting.</p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet that defines two <tt class="literal">&lt;decimal-format&gt;</tt>s:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:decimal-format name="f1"
    decimal-separator=":"
    grouping-separator="/"/&gt;

  &lt;xsl:decimal-format name="f2"
    infinity="Really, really big"
    NaN="[not a number]"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the &lt;decimal-format&gt; element:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(1528.3, '#/###:00', 'f1')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(1528.3, '#/###:00;-#/###:00', 'f1')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(1 div 0, '###,###.00', 'f2')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(1 div 0, '###,###.00', 'f2')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(blue div orange, '#.##', 'f2')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(blue div orange, '#.##', 'f2')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="report/month"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="document('')/*/months:name[@sequence=current()/@sequence]"/&gt;
      &lt;xsl:text&gt; - &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-flown, '##,###')"/&gt;
      &lt;xsl:text&gt; miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-earned, '##,###')"/&gt;
      &lt;xsl:text&gt; miles earned.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:text&gt;     (&lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="format-number(miles-flown div sum(//miles-flown), '##%')"/&gt;
      &lt;xsl:text&gt; of all miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="format-number(miles-earned div sum(//miles-earned), '##%')"/&gt;
      &lt;xsl:text&gt; of all miles earned.)&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt; 
    &lt;xsl:text&gt;   Total miles flown: &lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(sum(//miles-flown), '##,###')"/&gt;
    &lt;xsl:text&gt;, total miles earned: &lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(sum(//miles-earned), '##,###')"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll use this stylesheet against the following document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>When we process this document with the stylesheet, here are the results:</p>
<blockquote><pre class="code">

Tests of the &lt;decimal-format&gt; element:

   format-number(1528.3, '#/###:00', 'f1')=1/528:30
   format-number(1 div 0, '###,###.00', 'f2')=Really, really big
   format-number(blue div orange, '#.##', 'f2')=[not a number]

   January - 12,379 miles flown, 35,215 miles earned.
     (15% of all miles flown, 15% of all miles earned.)

   February - 32,857 miles flown, 92,731 miles earned.
     (39% of all miles flown, 39% of all miles earned.)

   March - 19,920 miles flown, 76,725 miles earned.
     (24% of all miles flown, 32% of all miles earned.)

   April - 18,903 miles flown, 31,781 miles earned.
     (22% of all miles flown, 13% of all miles earned.)

   Total miles flown: 84,059, total miles earned: 236,452</pre></blockquote>
</div>
<a name="INDEX-841" /><a name="INDEX-842" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:element&gt;</i></b></font></td><td align="right"><i>Allows you to create an element in the output document. It works similarly to the &lt;xsl:attribute&gt; element.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
Defines the name of this element. A value of <tt class="literal">name="fred"</tt> will produce a <tt class="literal">&lt;fred&gt;</tt> element in the output document. </p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>namespace</i></dt>
<dd>
Defines the namespace used for this attribute.</p>
</dd>


<dt><i>use-attribute-sets</i></dt>
<dd>
Lists one or more attribute sets that should be used by this element. If you specify more than one attribute set, separate their names with whitespace characters.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>An XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:element&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.1.2, Creating Elements with <tt class="literal">xsl:element</tt>.</p>

<h4 class="refsect1">Example</h4>
<p>We'll use a generic stylesheet that copies the input document to the result tree, with one exception: all attributes in the original documents are converted to child elements in the result tree. The name of the new element will be the name of the format attribute, and its text will be the value of the attribute. Because we don't know the name of the attribute until we process the XML source document, we must use the <tt class="literal">&lt;xsl:element&gt;</tt> element to create the result tree. Here's how our stylesheet looks:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;

  &lt;xsl:template match="*"&gt;
    &lt;xsl:element name="{name()}"&gt;
      &lt;xsl:for-each select="@*"&gt;
        &lt;xsl:element name="{name()}"&gt;
          &lt;xsl:value-of select="."/&gt;
        &lt;/xsl:element&gt;
      &lt;/xsl:for-each&gt;
      &lt;xsl:apply-templates select="*|text()"/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>This stylesheet uses the <tt class="literal">&lt;xsl:element&gt;</tt> element in two places: first to create a new element with the same name as the original element, and second to create a new element with the same name as each attribute. We'll apply the stylesheet to this document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>Here are our results:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month&gt;&lt;sequence&gt;01&lt;/sequence&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;&lt;sequence&gt;02&lt;/sequence&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;&lt;sequence&gt;03&lt;/sequence&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;&lt;sequence&gt;04&lt;/sequence&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>

<p>The <tt class="literal">&lt;xsl:element&gt;</tt> element created all the elements in the output document, including the <tt class="literal">&lt;sequence&gt;</tt> elements that were created from the <tt class="literal">sequence</tt> attributes in the original document.</p>
</div>
<a name="INDEX-843" /><a name="INDEX-844" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:fallback&gt;</i></b></font></td><td align="right"><i>Defines a template that should be used when an extension element can't be found. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>An XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:fallback&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 15, Fallback.</p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet that uses <tt class="literal">&lt;xsl:fallback&gt;</tt> to terminate the transformation if an extension element can't be found:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:db="xalan://DatabaseExtension"
  extension-element-prefixes="db"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="report/title"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="report/title"/&gt;&lt;/h1&gt;
        &lt;xsl:for-each select="report/section"&gt;
          &lt;h2&gt;&lt;xsl:value-of select="title"/&gt;&lt;/h2&gt;
          &lt;xsl:for-each select="dbaccess"&gt;
            &lt;db:accessDatabase&gt;
              &lt;xsl:fallback&gt;
                &lt;xsl:message terminate="yes"&gt;
                  Database library not available!
                &lt;/xsl:message&gt;
              &lt;/xsl:fallback&gt; 
            &lt;/db:accessDatabase&gt;
          &lt;/xsl:for-each&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>

<p>When we use this stylesheet to transform a document, the <tt class="literal">&lt;xsl:fallback&gt;</tt> element is processed if the extension element can't be found:</p>
<blockquote><pre class="code">

Database library not available!

Processing terminated using xsl:message</pre></blockquote>
<p>In this case, the extension element is the Java class <tt class="literal">DatabaseExtension</tt>. If, for whatever reason, that class can't be loaded, the <tt class="literal">&lt;xsl:fallback&gt;</tt> element is processed. Note that the <tt class="literal">&lt;xsl:fallback&gt;</tt> element is processed only when the extension element can't be found; if the code that implements that extension element is found, but fails, it must be handled some other way. Also be aware that the exact format of the message and the gracefulness of stylesheet termination will vary from one XSLT processor to the next. </p>
</div>
<a name="INDEX-845" /><a name="INDEX-846" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:for-each&gt;</i></b></font></td><td align="right"><i>Acts as XSLT's iteration operator. This element has a select attribute that selects some nodes from the current context. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>select</i></dt>
<dd>
Contains an XPath expression that selects nodes from the current context.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>
<tt class="literal">&lt;xsl:for-each&gt;</tt> contains a template that is evaluated against each of the selected nodes. The <tt class="literal">&lt;xsl:for-each&gt;</tt> element can contain one or more <tt class="literal">&lt;xsl:sort&gt;</tt> elements to order the selected nodes before they are processed. All <tt class="literal">&lt;xsl:sort&gt;</tt> elements must appear first, before the template begins. </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:for-each&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 8, Repetition.</p>

<h4 class="refsect1">Example</h4>
<p>We'll demonstrate the <tt class="literal">&lt;xsl:for-each&gt;</tt> element with the following stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:variable name="complicatedVariable"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="count(//listitem) &gt; 10"&gt;
        &lt;xsl:text&gt;really long list&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="count(//listitem) &gt; 5"&gt;
        &lt;xsl:text&gt;moderately long list&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;fairly short list&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Here is a &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$complicatedVariable"/&gt;
    &lt;xsl:text&gt;:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:variable name="listitems" select="list/listitem"/&gt;
    &lt;xsl:call-template name="processListitems"&gt;
      &lt;xsl:with-param name="items" select="$listitems"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="processListitems"&gt;
    &lt;xsl:param name="items"/&gt;
    &lt;xsl:for-each select="$items"&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt;.  &lt;/xsl:text&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>In this stylesheet, we use an <tt class="literal">&lt;xsl:param&gt;</tt> named <tt class="literal">items</tt> to illustrate the <tt class="literal">&lt;xsl:for-each&gt;</tt> element. The <tt class="literal">items</tt> parameter contains some number of <tt class="literal">&lt;listitem&gt;</tt> elements from the XML source document; the <tt class="literal">&lt;xsl:for-each&gt;</tt> element iterates through all those elements and processes each one. We'll use our stylesheet with the following XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>When we run the transformation, here are the results:</p>
<blockquote><pre class="code">
Here is a moderately long list:
1.  A Love Supreme
2.  Beat Crazy
3.  Here Come the Warm Jets
4.  Kind of Blue
5.  London Calling
6.  Remain in Light
7.  The Joshua Tree
8.  The Indestructible Beat of Soweto</pre></blockquote>
<p>The <tt class="literal">&lt;xsl:for-each&gt;</tt> element has iterated through all the <tt class="literal">&lt;listitem&gt;</tt> elements from the XML source document and has processed each one. </p>
</div>
<a name="INDEX-847" /><a name="INDEX-848" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:if&gt;</i></b></font></td><td align="right"><i>Implements an if statement. It contains a test attribute and an XSLT template. If the test attribute evaluates to the boolean value true, the XSLT template is processed. This element implements an if statement only; if you need an if-then-else statement, use the &lt;xsl:choose&gt; element with a single &lt;xsl:when&gt; and a single &lt;xsl:otherwise&gt;.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>test</i></dt>
<dd>
The <tt class="literal">test</tt> attribute contains a boolean expression. If it evaluates to the boolean value <tt class="literal">true</tt>, then the XSLT template inside the <tt class="literal">&lt;xsl:if&gt;</tt> element is processed.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>An XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:if&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 9.1, Conditional Processing with <tt class="literal">xsl:if</tt>.</p>

<h4 class="refsect1">Example</h4>
<p>We'll illustrate the <tt class="literal">&lt;xsl:if&gt;</tt> element with the following stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Here are the odd-numbered items from the list:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="list/listitem"&gt;
      &lt;xsl:if test="(position() mod 2) = 1"&gt;
        &lt;xsl:number format="1. "/&gt;
        &lt;xsl:value-of select="."/&gt;
        &lt;xsl:value-of select="$newline"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
  
&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>This stylesheet uses the <tt class="literal">&lt;xsl:if&gt;</tt> element to see if a given <tt class="literal">&lt;listitem&gt;</tt>'s position is an odd number. If it is, we write it to the result tree. We'll test our stylesheet with this XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>

<p>When we run this transformation, here are the results:</p>
<blockquote><pre class="code">
Here are the odd-numbered items from the list:
1. A Love Supreme
3. Here Come the Warm Jets
5. London Calling
7. The Joshua Tree</pre></blockquote>
</div>
<a name="INDEX-849" /><a name="INDEX-850" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:import&gt;</i></b></font></td><td align="right"><i>Allows you to import the templates found in another XSLT stylesheet. Unlike &lt;xsl:include&gt;, all templates imported with &lt;xsl:import&gt; have a lower priority than those in the including stylesheet. Another difference between &lt;xsl:include&gt; and &lt;xsl:import&gt; is that &lt;xsl:include&gt; can appear anywhere in a stylesheet, while &lt;xsl:import&gt; can appear only at the beginning.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>href</i></dt>
<dd>
Defines the URI of the imported stylesheet.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:import&gt;</tt> is an empty element.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:import&gt;</tt> is a top-level element and can appear only as a child of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 2.6.2, Stylesheet Import. </p>

<h4 class="refsect1">Example</h4>
<p>Here is a simple stylesheet that we'll import:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;


  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:apply-templates select="list/title"/&gt;
    &lt;xsl:apply-templates select="list/listitem"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="title"&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:text&gt;: &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="listitem"&gt;
    &lt;xsl:text&gt;HERE IS LISTITEM NUMBER &lt;/xsl:text&gt;
    &lt;xsl:value-of select="position()"/&gt;
    &lt;xsl:text&gt;:  &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll test both this stylesheet and the one that imports it with this XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>When we process our XML source document with this stylesheet, here are the results:</p>
<blockquote><pre class="code">
A few of my favorite albums:

HERE IS LISTITEM NUMBER 1:  A Love Supreme
HERE IS LISTITEM NUMBER 2:  Beat Crazy
HERE IS LISTITEM NUMBER 3:  Here Come the Warm Jets
HERE IS LISTITEM NUMBER 4:  Kind of Blue
HERE IS LISTITEM NUMBER 5:  London Calling
HERE IS LISTITEM NUMBER 6:  Remain in Light
HERE IS LISTITEM NUMBER 7:  The Joshua Tree
HERE IS LISTITEM NUMBER 8:  The Indestructible Beat of Soweto</pre></blockquote>
<p>Now we'll use <tt class="literal">&lt;xsl:import&gt;</tt> in another stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:import href="listitem.xsl"/&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:apply-templates select="list/title"/&gt;
    &lt;xsl:apply-templates select="list/listitem"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="listitem"&gt;
    &lt;xsl:value-of select="position()"/&gt;
    &lt;xsl:text&gt;.  &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results created by our second stylesheet:</p>
<blockquote><pre class="code">
A few of my favorite albums:

1.  A Love Supreme
2.  Beat Crazy
3.  Here Come the Warm Jets
4.  Kind of Blue
5.  London Calling
6.  Remain in Light
7.  The Joshua Tree
8.  The Indestructible Beat of Soweto</pre></blockquote>
<p>Notice that both stylesheets had a template with <tt class="literal">match="listitem"</tt>. The template in the imported stylesheet has a lower priority, so it is not used. Only the imported stylesheet has a template with <tt class="literal">match="title"</tt>, so the imported template is used for the <tt class="literal">&lt;title&gt;</tt> element. </p>
</div>
<a name="INDEX-851" /><a name="INDEX-852" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:include&gt;</i></b></font></td><td align="right"><i>Allows you to include another XSLT stylesheet. This element allows you to put common transformations in a separate stylesheet, then include the templates from that stylesheet at any time. Unlike &lt;xsl:import&gt;, all templates included with &lt;xsl:include&gt; have the same priority as those in the including stylesheet. Another difference is that &lt;xsl:include&gt; can appear anywhere in a stylesheet, while &lt;xsl:import&gt; must appear at the beginning. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>href</i></dt>
<dd>
Defines the URI of the included stylesheet.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:include&gt;</tt> is an empty element.</p>

<h4 class="refsect1">Appears in</h4>
<p> <tt class="literal">&lt;xsl:include&gt;</tt> is a top-level element and can appear only as a child of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 2.6.1, Stylesheet Inclusion. </p>

<h4 class="refsect1">Example</h4>

<p>The <tt class="literal">&lt;xsl:include&gt;</tt> element is a good way
to break your stylesheets into smaller pieces. (Those smaller pieces
are often easier to reuse.) In our case study (see <a href="ch09_01.htm">Chapter 9, "Case Study: The Toot-O-Matic"</a>), we had a number of different stylesheets, each
of which contained templates for a particular purpose. Here's how our
<tt class="literal">&lt;xsl:include&gt;</tt> elements look:</p>

<blockquote><pre class="code">
&lt;xsl:include href="toot-o-matic-variables.xsl"/&gt;

&lt;xsl:include href="xslt-utilities.xsl"/&gt;
&lt;xsl:include href="dw-style.xsl"/&gt;

&lt;xsl:include href="build-main-index.xsl"/&gt;
&lt;xsl:include href="build-section-indexes.xsl"/&gt;
&lt;xsl:include href="build-individual-panels.xsl"/&gt;
&lt;xsl:include href="build-graphics.xsl"/&gt;
&lt;xsl:include href="build-pdf-file.xsl"/&gt;
&lt;xsl:include href="build-zip-file.xsl"/&gt;</pre></blockquote>
<p>Segmenting your stylesheets this way can make debugging simpler, as well. In our example here, all the rules for creating a PDF file are in the stylesheet <em class="filename">build-pdf-file.xsl</em>. If the PDF files are not built correctly, <em class="filename">build-pdf-file.xsl</em> is most likely the source of the problem. All visual elements of our generated HTML pages are created in the stylesheet <em class="filename">dw-style.xsl</em>. If we need to change the look of all the HTML pages, changing the templates in <em class="filename">dw-style.xsl</em> will do the trick. </p>
</div>
<a name="INDEX-853" /><a name="INDEX-854" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:key&gt;</i></b></font></td><td align="right"><i>Defines an index against the current document. The element is defined with three attributes: a name, which names this index; a match, an XPath expression that describes the nodes to be indexed; and a use attribute, an XPath expression that defines the property used to create the index.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
Defines a name for this key.</p>
</dd>


<dt><i>match</i></dt>
<dd>
Represents an XPath expression that defines the nodes to be indexed by this key.</p>
</dd>


<dt><i>use</i></dt>
<dd>
Represents an XPath expression that defines the property of the indexed nodes that will be used to retrieve nodes from the index. </p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:key&gt;</tt> is an empty element.</p>

<h4 class="refsect1">Appears in</h4>
<p> <tt class="literal">&lt;xsl:key&gt;</tt> is a top-level element and can only appear as a child of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.2, Keys. </p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet that defines two <tt class="literal">&lt;xsl:key&gt;</tt> relations against an XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output method="html" indent="yes"/&gt;
&lt;xsl:strip-space elements="*"/&gt;

  &lt;xsl:key name="language-index" match="defn" use="@language"/&gt;
  &lt;xsl:key name="term-ids"       match="term" use="@id"/&gt;

  &lt;xsl:param name="targetLanguage"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates select="glossary"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="glossary"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:text&gt;Glossary Listing: &lt;/xsl:text&gt;
          &lt;xsl:value-of select="key('language-index', 
        $targetLanguage)[1]/preceding-sibling::term"/&gt;
          &lt;xsl:text&gt; - &lt;/xsl:text&gt;
          &lt;xsl:value-of select="key('language-index', 
        $targetLanguage)[last()]/preceding-sibling::term"/&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;
          &lt;xsl:text&gt;Glossary Listing: &lt;/xsl:text&gt;
          &lt;xsl:value-of select="key('language-index', 
        $targetLanguage)[1]/ancestor::glentry/term"/&gt;
          &lt;xsl:text&gt; - &lt;/xsl:text&gt;
          &lt;xsl:value-of select="key('language-index', 
        $targetLanguage)[last()]/ancestor::glentry/term"/&gt;
        &lt;/h1&gt;
        &lt;xsl:for-each select="key('language-index', $targetLanguage)"&gt;
          &lt;xsl:apply-templates select="ancestor::glentry"/&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  ...

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>For a complete discussion of this stylesheet, illustrating how
the <tt class="literal">&lt;xsl:key&gt;</tt> relations are used, see <a href="ch05_02.htm">Section 5.2.3, "Stylesheets That Use the key() Function"</a> in <a href="ch05_01.htm">Chapter 5, "Creating Links and Cross-References"</a>.</p>
</div>
<a name="INDEX-855" /><a name="INDEX-856" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:message&gt;</i></b></font></td><td align="right"><i>Sends a message. How the message is sent can vary from one XSLT processor to the next, but it's typically written to the standard output device. This element is useful for debugging stylesheets.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>terminate="yes"|"no"</i></dt>
<dd>
If this attribute has the value <tt class="literal">yes</tt>, the XSLT processor stops execution after issuing this message. The default value for this attribute is <tt class="literal">no</tt>; if the <tt class="literal">&lt;xsl:message&gt;</tt> doesn't terminate the processor, the message is sent and processing continues.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>An XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:message&gt;</tt> appears inside a template. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 13, Messages.</p>

<h4 class="refsect1">Example</h4>
<p>Here's a stylesheet that uses the <tt class="literal">&lt;xsl:message&gt;</tt> element to trace the transformation of an XML document. We'll use our list of recently purchased albums again:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>We'll list all of the purchased albums in an HTML table, with the background color of each row alternating through various colors. Our stylesheet uses an <tt class="literal">&lt;xsl:choose&gt;</tt> element inside an <tt class="literal">&lt;xsl:attribute&gt;</tt> element to determine the value of the <tt class="literal">bgcolor</tt> attribute. If a given <tt class="literal">&lt;listitem&gt;</tt> is converted to an HTML <tt class="literal">&lt;tr&gt;</tt> with a background color of <tt class="literal">lavender</tt>, we'll issue a celebratory message:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:value-of select="list/title"/&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="list/title"/&gt;&lt;/h1&gt;
        &lt;table border="1"&gt;
          &lt;xsl:for-each select="list/listitem"&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;xsl:attribute name="bgcolor"&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="position() mod 4 = 0"&gt;
                      &lt;xsl:text&gt;papayawhip&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 1"&gt;
                      &lt;xsl:text&gt;mintcream&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 2"&gt;
                      &lt;xsl:text&gt;lavender&lt;/xsl:text&gt;
                      &lt;xsl:message terminate="no"&gt;
                        &lt;xsl:text&gt;Table row #&lt;/xsl:text&gt;
                        &lt;xsl:value-of select="position()"/&gt;
                        &lt;xsl:text&gt; is lavender!&lt;/xsl:text&gt;
                      &lt;/xsl:message&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:text&gt;whitesmoke&lt;/xsl:text&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/xsl:attribute&gt;
                &lt;xsl:value-of select="."/&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Note that the XSLT specification doesn't define how the message is issued. When we use this stylesheet with Xalan 2.0.1, we get these results:</p>
<blockquote><pre class="code">
file:///D:/O'Reilly/XSLT/bookSamples/AppendixA/message.xsl; Line 32; Column 51;
Table row #2 is lavender!
file:///D:/O'Reilly/XSLT/bookSamples/AppendixA/message.xsl; Line 32; Column 51;
Table row #6 is lavender!</pre></blockquote>

<p>Xalan gives us feedback on the part of the stylesheet that generated each message. Saxon, on the other hand, keeps things short and sweet:</p>
<blockquote><pre class="code">
Table row #2 is lavender!
Table row #6 is lavender!</pre></blockquote>
<p>For variety's sake, here's how XT processes the <tt class="literal">&lt;xsl:message&gt;</tt> element:</p>
<blockquote><pre class="code">
file:/D:/O'Reilly/XSLT/bookSamples/AppendixA/test4.xml:5: Table row #2 is lavender!
file:/D:/O'Reilly/XSLT/bookSamples/AppendixA/test4.xml:9: Table row #6 is lavender!</pre></blockquote>
<p>XT gives information about the line in the XML source document that generated the message.</p>
</div>
<a name="INDEX-857" /><a name="INDEX-858" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:namespace-alias&gt;</i></b></font></td><td align="right"><i>Allows you to define an alias for a namespace when using the namespace directly would complicate processing. This seldom-used element is the simplest way to write a stylesheet that generates another stylesheet.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>stylesheet-prefix</i></dt>
<dd>
Defines the prefix used in the stylesheet to refer to the namespace.</p>
</dd>


<dt><i>result-prefix</i></dt>
<dd>
Defines the prefix for the namespace referred to by the alias. This prefix must be declared in the stylesheet, regardless of whether any elements in the stylesheet use it. </p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:namespace-alias&gt;</tt> is an empty element. </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:stylesheet&gt;</tt>. <tt class="literal">&lt;xsl:namespace-alias&gt;</tt> is a top-level element and can appear only as a child of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.1.1, Literal Result Elements. </p>

<h4 class="refsect1">Example</h4>
<p>This element is not used frequently, and the reasons for its existence are based on the somewhat obscure case of an XSLT stylesheet that needs to generate another XSLT stylesheet. Our test case here creates a stylesheet that generates the identity transform, a stylesheet that simply copies any input document to the result tree. Here's our original stylesheet that uses the namespace alias:</p>
<blockquote><pre class="code">
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xslout="(the namespace URI doesn't matter here)"&gt;

  &lt;xsl:output method="xml" indent="yes"/&gt;
 
  &lt;xsl:namespace-alias stylesheet-prefix="xslout"
    result-prefix="xsl"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xslout:stylesheet version="1.0"&gt;
      &lt;xslout:output method="xml"/&gt;
      &lt;xslout:template match="/"&gt;
        &lt;xslout:copy-of select="."/&gt;
      &lt;/xslout:template&gt;
    &lt;/xslout:stylesheet&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When we run this stylesheet with any XML document at all, we get a new stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xslout:stylesheet xmlns:xslout="http://www.w3.org/1999/XSL/Transform" 
  version="1.0"&gt;
&lt;xslout:output method="xml"/&gt;
&lt;xslout:template match="/"&gt;
&lt;xslout:copy-of select="."/&gt;
&lt;/xslout:template&gt;
&lt;/xslout:stylesheet&gt;</pre></blockquote>
<p>You can take this generated stylesheet and use it to copy any XML document. In our original stylesheet, we use an <tt class="literal">&lt;xsl:namespace-alias&gt;</tt> because we have no other way of identifying to the XSLT processor with which XSLT elements should be processed and which ones should be treated as literals passed to the output. Using the namespace alias lets us generate the XSLT elements we need in our output. Notice in the result document that the correct namespace value was declared automatically on the <tt class="literal">&lt;xslout:stylesheet&gt;</tt> element. </p>
</div>
<a name="INDEX-859" /><a name="INDEX-860" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:number&gt;</i></b></font></td><td align="right"><i>Counts something.  It is most often used to number parts of a document, although it can also be used to format a numeric value.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

        <dt><i>count</i></dt>
        <dd>
        The <tt class="literal">count</tt> attribute is an XPath expression that defines what should be counted. </p>
      </dd>


        <dt><i>level</i></dt>
        <dd>
        This attribute defines what levels of the source tree should be considered when numbering elements.  The three valid values for this attribute are <tt class="literal">single</tt>, <tt class="literal">multiple</tt>, and <tt class="literal">any</tt>:</p>
        <dl>
          
            <dt><b>
<tt class="literal">single</tt>
</b></dt>
            <dd>
              Counts items at one level only.  The XSLT processor goes to the first node in the <tt class="literal">ancestor-or-self</tt> axis that matches the <tt class="literal">count</tt> attribute, then counts that node plus all its preceding siblings that also match the <tt class="literal">count</tt> attribute.  </p>
            </dd>
          
          
            <dt><b>
<tt class="literal">multiple</tt>
</b></dt>
            <dd>
              Counts items at multiple levels.  The XSLT processor looks at all ancestors of the current node and the current node itself, then it selects all of those nodes that match the <tt class="literal">count</tt> attribute.  </p>
            </dd>
          
          
            <dt><b>
<tt class="literal">any</tt>
</b></dt>
            <dd>
              Includes all of the current node's ancestors (as <tt class="literal">level="multiple"</tt> does) as well as all elements in the <tt class="literal">preceding</tt> axis.  </p>
            </dd>
          
        </dl>
        <p>In all of these cases, if the <tt class="literal">from</tt> attribute is used, the only ancestors that are examined are descendants of the nearest ancestor that matches the <tt class="literal">from</tt> attribute.  In other words, with <tt class="literal">from="h1"</tt>, the only nodes considered for counting are those that appear under the nearest <tt class="literal">&lt;h1&gt;</tt> attribute. </p>
      </dd>
     

        <dt><i>from</i></dt>
        <dd>
        The <tt class="literal">from</tt> attribute is an XPath expression that defines where counting starts.  For example, you can use the <tt class="literal">from</tt> attribute to say that counting should begin at the previous <tt class="literal">&lt;h1&gt;</tt> element. </p>
      </dd>


        <dt><i>value</i></dt>
        <dd>
        An expression that is converted to a number.  Using this attribute is a quick way to format a number; the element <tt class="literal">&lt;xsl:number value="7" format="i:"/&gt;</tt> returns the string "vii:".</p>
      </dd>


        <dt><i>format</i></dt>
        <dd>
        The <tt class="literal">format</tt> attribute defines the format of the generated number:</p>
        <dl>
          
            <dt><b>
<tt class="literal">format="1"</tt>
</b></dt>
            <dd>
              Formats a sequence of numbers as <tt class="literal">1 2 3 4 5 6 7 8 9 10 11 ...</tt>.</p>
            </dd>
          
          
            <dt><b>
<tt class="literal">format="01"</tt>
</b></dt>
            <dd>
              Formats a sequence of numbers as <tt class="literal">01 02 03 04 ... 09 10 11 ... 99 100 101 ...</tt>.</p>
            </dd>
          
          
            <dt><b>
<tt class="literal">format="a"</tt>
</b></dt>
            <dd>
              Formats a sequence of numbers as <tt class="literal">a b c d e f ... x y z aa ab ac ...</tt>.</p>
            </dd>
          
          
            <dt><b>
<tt class="literal">format="A"</tt>
</b></dt>
            <dd>
              Formats a sequence of numbers as <tt class="literal">A B C D E F ... X Y Z AA AB AC ...</tt>.</p>
            </dd>
          
          
            <dt><b>
<tt class="literal">format="i"</tt>
</b></dt>
            <dd>
              Formats a sequence of numbers as <tt class="literal">i ii iii iv v vi vii viii ix x ...</tt>.</p>
            </dd>
          
          
            <dt><b>
<tt class="literal">format="I"</tt>
</b></dt>
            <dd>
              Formats a sequence of numbers as <tt class="literal">I II III IV V VI VII VIII IX X ...</tt>.</p>
            </dd>
          
          
            <dt><b>
<tt class="literal">format="anything else"</tt>
</b></dt>
            <dd>
              How this works is depends on the XSLT processor you're using.  The XSLT specification lists several other numbering schemes (Thai digits, Katakana numbering, traditional Hebrew numbering, etc.); check your XSLT processor's documentation to see which formats it supports.  If the XSLT processor doesn't support the numbering scheme you requested, the XSLT spec requires that it use <tt class="literal">format="1"</tt> as the default. </p>
            </dd>
          
        </dl>
      </dd>


        <dt><i>lang</i></dt>
        <dd>
        The <tt class="literal">lang</tt> attribute defines the language whose alphabet should be used.  Different XSLT processors support different language values, so check the documentation of your favorite XSLT processor for more information.</p>
      </dd>


        <dt><i>letter-value</i></dt>
        <dd>
        This attribute has the value <tt class="literal">alphabetic</tt> or <tt class="literal">traditional</tt>.  There are a number of languages in which two letter-based numbering schemes are used; one assigns numeric values in alphabetic sequence, while the other uses a tradition native to that language.  (Roman numerals -- a letter-based numbering scheme that doesn't use an alphabetic order -- are one example.)  The default for this attribute is <tt class="literal">alphabetic</tt>.</p>
      </dd>


        <dt><i>grouping-separator</i></dt>
        <dd>
        This attribute is the character that should be used between groups of digits in a generated number.  The default is the comma (<tt class="literal">,</tt>).</p>
      </dd>


        <dt><i>grouping-size</i></dt>
        <dd>
        This attribute defines the number of digits that appear in each group; the default is <tt class="literal">3</tt>.</p>
      </dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>None.  <tt class="literal">&lt;xsl:number&gt;</tt> is an empty element. </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:number&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.7, Numbering.</p>

<h4 class="refsect1">Example</h4>
<p>To fully illustrate how <tt class="literal">&lt;xsl:number&gt;</tt> works, we'll need an XML document with many things to count.  Here's the document we'll use:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;book&gt;
  &lt;chapter&gt;
    &lt;title&gt;Alfa Romeo&lt;/title&gt;
    &lt;sect1&gt;
      &lt;title&gt;Bentley&lt;/title&gt;
    &lt;/sect1&gt;
    &lt;sect1&gt;
      &lt;title&gt;Chevrolet&lt;/title&gt;
      &lt;sect2&gt;
        &lt;title&gt;Dodge&lt;/title&gt;
        &lt;sect3&gt;
          &lt;title&gt;Eagle&lt;/title&gt;
        &lt;/sect3&gt;
      &lt;/sect2&gt;
    &lt;/sect1&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Ford&lt;/title&gt;
    &lt;sect1&gt;
      &lt;title&gt;GMC&lt;/title&gt;
      &lt;sect2&gt;
        &lt;title&gt;Honda&lt;/title&gt;
        &lt;sect3&gt;
          &lt;title&gt;Isuzu&lt;/title&gt;
        &lt;/sect3&gt;
        &lt;sect3&gt;
          &lt;title&gt;Javelin&lt;/title&gt;
        &lt;/sect3&gt;
        &lt;sect3&gt;
          &lt;title&gt;K-Car&lt;/title&gt;
        &lt;/sect3&gt;
        &lt;sect3&gt;
          &lt;title&gt;Lincoln&lt;/title&gt;
        &lt;/sect3&gt;
      &lt;/sect2&gt;
      &lt;sect2&gt;
        &lt;title&gt;Mercedes&lt;/title&gt;
      &lt;/sect2&gt;
      &lt;sect2&gt;
        &lt;title&gt;Nash&lt;/title&gt;
        &lt;sect3&gt;
          &lt;title&gt;Opel&lt;/title&gt;
        &lt;/sect3&gt;
        &lt;sect3&gt;
          &lt;title&gt;Pontiac&lt;/title&gt;
        &lt;/sect3&gt;
      &lt;/sect2&gt;
      &lt;sect2&gt;
        &lt;title&gt;Quantum&lt;/title&gt;
        &lt;sect3&gt;
          &lt;title&gt;Rambler&lt;/title&gt;
        &lt;/sect3&gt;
        &lt;sect3&gt;
          &lt;title&gt;Studebaker&lt;/title&gt;
        &lt;/sect3&gt;
      &lt;/sect2&gt;
    &lt;/sect1&gt;
    &lt;sect1&gt;
      &lt;title&gt;Toyota&lt;/title&gt;
      &lt;sect2&gt;
        &lt;title&gt;Um, is there a car that starts with "U"?&lt;/title&gt;
      &lt;/sect2&gt;
    &lt;/sect1&gt;
    &lt;sect1&gt;
      &lt;title&gt;Volkswagen&lt;/title&gt;
    &lt;/sect1&gt;
  &lt;/chapter&gt;
&lt;/book&gt;</pre></blockquote>
<p>We'll use <tt class="literal">&lt;xsl:number&gt;</tt> in several different ways to illustrate the various options we have in numbering things.  We'll look at the stylesheet and the results, then we'll discuss them.  Here's the stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:apply-templates select="book" mode="number-1"/&gt;
    &lt;xsl:apply-templates select="book" mode="number-2"/&gt;
    &lt;xsl:apply-templates select="book" mode="number-3"/&gt;
    &lt;xsl:apply-templates select="book" mode="number-4"/&gt;
    &lt;xsl:apply-templates select="book" mode="number-5"/&gt;
    &lt;xsl:apply-templates select="book" mode="number-6"/&gt;

    &lt;xsl:apply-templates select="book" mode="number-7"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="book" mode="number-1"&gt;
    &lt;xsl:text&gt;Test #1: level="multiple", 
         count="chapter|sect1|sect2|sect3", 
         format="1.1.1.1. "&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="chapter|.//sect1|.//sect2|.//sect3"&gt;
      &lt;xsl:number level="multiple" count="chapter|sect1|sect2|sect3"
        format="1.1.1.1. "/&gt;
        &lt;xsl:value-of select="title"/&gt;
        &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="book" mode="number-2"&gt;
    &lt;xsl:text&gt;Test #2: level="any", 
         count="chapter|sect1|sect2|sect3", 
         format="1. "&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="chapter|.//sect1|.//sect2|.//sect3"&gt;
      &lt;xsl:number level="any" count="chapter|sect1|sect2|sect3"
        format="1. "/&gt;
        &lt;xsl:value-of select="title"/&gt;
        &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="book" mode="number-3"&gt;
    &lt;xsl:text&gt;Test #3: level="single", 
         count="chapter|sect1|sect2|sect3", 
         format="1.1.1.1. "&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="chapter|.//sect1|.//sect2|.//sect3"&gt;
      &lt;xsl:number level="single" count="chapter|sect1|sect2|sect3"
        format="1.1.1.1. "/&gt;
        &lt;xsl:value-of select="title"/&gt;
        &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="book" mode="number-4"&gt;
    &lt;xsl:text&gt;Test #4: level="multiple", 
         select=".//sect2",
         count="chapter|sect1|sect2", 
         format="I-A-i: "&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select=".//sect2"&gt;
      &lt;xsl:number level="multiple" count="chapter|sect1|sect2"
        format="I-A-i: "/&gt;
        &lt;xsl:value-of select="title"/&gt;
        &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="book" mode="number-5"&gt;
    &lt;xsl:text&gt;Test #5: level="any", 
         count="[various elements]"
         from="[various elements]"
         format="1.1.1.1. "&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select=".//sect3"&gt;
      &lt;xsl:number level="any" from="book" count="chapter" format="1."/&gt;
      &lt;xsl:number level="any" from="chapter" count="sect1" format="1."/&gt;
      &lt;xsl:number level="any" from="sect1" count="sect2" format="1."/&gt;
      &lt;xsl:number level="any" from="sect2" count="sect3" format="1. "/&gt;
      &lt;xsl:value-of select="title"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="book" mode="number-6"&gt;
    &lt;xsl:text&gt;Test #6: level="any", 
         count="chapter|sect1|sect2|sect3",
         grouping-separator=",",
         using a variable to start counting at 1000.&lt;/xsl:text&gt; 
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="chapter|.//sect1|.//sect2|.//sect3"&gt;
      &lt;xsl:variable name="value1"&gt;
        &lt;xsl:number level="any" count="chapter|sect1|sect2|sect3"/&gt;
      &lt;/xsl:variable&gt;
      &lt;xsl:number value="$value1 + 999"
        grouping-separator="." grouping-size="3"/&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
      &lt;xsl:value-of select="title"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="book" mode="number-7"&gt;
    &lt;xsl:text&gt;Test #7: level="multiple", 
         count="chapter|sect1|sect2|sect3", 
         format="1.1.1.1. ",
         selecting up to the first two &lt;sect1&gt; elements from chapter 2.&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="chapter[2]/sect1[position() &lt; 3]"&gt;
      &lt;xsl:for-each select="chapter|.//sect1|.//sect2|.//sect3"&gt;
        &lt;xsl:number level="multiple" count="chapter|sect1|sect2|sect3"
          format="1.1.1.1. "/&gt;
        &lt;xsl:value-of select="title"/&gt;
        &lt;xsl:value-of select="$newline"/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are our results:</p>
<blockquote><pre class="code">

Test #1: level="multiple", 
         count="chapter|sect1|sect2|sect3", 
         format="1.1.1.1. "

1. Alfa Romeo
1.1. Bentley
1.2. Chevrolet
1.2.1. Dodge
1.2.1.1. Eagle
2. Ford
2.1. GMC
2.1.1. Honda
2.1.1.1. Isuzu
2.1.1.2. Javelin
2.1.1.3. K-Car
2.1.1.4. Lincoln
2.1.2. Mercedes
2.1.3. Nash
2.1.3.1. Opel
2.1.3.2. Pontiac
2.1.4. Quantum
2.1.4.1. Rambler
2.1.4.2. Studebaker
2.2. Toyota

2.2.1. Um, is there a car that starts with "U"?
2.3. Volkswagen

Test #2: level="any", 
         count="chapter|sect1|sect2|sect3", 
         format="1. "

1. Alfa Romeo
2. Bentley
3. Chevrolet
4. Dodge
5. Eagle
6. Ford
7. GMC
8. Honda
9. Isuzu
10. Javelin
11. K-Car
12. Lincoln
13. Mercedes
14. Nash
15. Opel
16. Pontiac
17. Quantum
18. Rambler
19. Studebaker
20. Toyota
21. Um, is there a car that starts with "U"?
22. Volkswagen

Test #3: level="single", 
         count="chapter|sect1|sect2|sect3", 
         format="1.1.1.1. "

1. Alfa Romeo
1. Bentley
2. Chevrolet
1. Dodge
1. Eagle
2. Ford
1. GMC
1. Honda
1. Isuzu
2. Javelin
3. K-Car
4. Lincoln
2. Mercedes
3. Nash
1. Opel
2. Pontiac
4. Quantum
1. Rambler
2. Studebaker
2. Toyota
1. Um, is there a car that starts with "U"?
3. Volkswagen

Test #4: level="multiple", 
         select=".//sect2",
         count="chapter|sect1|sect2", 
         format="I-A-i: "

I-B-i: Dodge
II-A-i: Honda
II-A-ii: Mercedes
II-A-iii: Nash
II-A-iv: Quantum
II-B-i: Um, is there a car that starts with "U"?

Test #5: level="any", 
         count="[various elements]"
         from="[various elements]"
         format="1.1.1.1. "

1.2.1.1. Eagle
2.1.1.1. Isuzu
2.1.1.2. Javelin
2.1.1.3. K-Car
2.1.1.4. Lincoln
2.1.3.1. Opel
2.1.3.2. Pontiac
2.1.4.1. Rambler
2.1.4.2. Studebaker

Test #6: level="any", 
         count="chapter|sect1|sect2|sect3",
         grouping-separator=",",
         using a variable to start counting at 1000.

1,000. Alfa Romeo
1,001. Bentley
1,002. Chevrolet
1,003. Dodge
1,004. Eagle
1,005. Ford
1,006. GMC
1,007. Honda
1,008. Isuzu
1,009. Javelin
1,010. K-Car
1,011. Lincoln
1,012. Mercedes
1,013. Nash
1,014. Opel
1,015. Pontiac
1,016. Quantum
1,017. Rambler
1,018. Studebaker
1,019. Toyota
1,020. Um, is there a car that starts with "U"?
1,021. Volkswagen

Test #7: level="multiple", 
         count="chapter|sect1|sect2|sect3", 
         format="1.1.1.1. ",
         selecting up to the first two &lt;sect1&gt; elements from chapter 2.

2.1. GMC
2.1.1. Honda
2.1.1.1. Isuzu
2.1.1.2. Javelin
2.1.1.3. K-Car
2.1.1.4. Lincoln
2.1.2. Mercedes
2.1.3. Nash
2.1.3.1. Opel
2.1.3.2. Pontiac
2.1.4. Quantum
2.1.4.1. Rambler
2.1.4.2. Studebaker
2.2. Toyota
2.2.1. Um, is there a car that starts with "U"?</pre></blockquote>
<p>In Test 1, we used <tt class="literal">level="multiple"</tt> to count the <tt class="literal">&lt;chapter&gt;</tt>, <tt class="literal">&lt;sect1&gt;</tt>, <tt class="literal">&lt;sect2&gt;</tt>, and <tt class="literal">&lt;sect3&gt;</tt> elements.  Numbering these at multiple levels gives us a dotted-decimal number for each element.  We can look at the number next to <tt class="literal">Studebaker</tt> and know that it is the second <tt class="literal">&lt;sect3&gt;</tt> element inside the fourth <tt class="literal">&lt;sect2&gt;</tt> element inside the first <tt class="literal">&lt;sect1&gt;</tt> element inside the second <tt class="literal">&lt;chapter&gt;</tt> element.  </p>
<p>Test 2 uses <tt class="literal">level="any"</tt> to count all of the <tt class="literal">&lt;chapter&gt;</tt>, <tt class="literal">&lt;sect1&gt;</tt>, <tt class="literal">&lt;sect2&gt;</tt>, and <tt class="literal">&lt;sect3&gt;</tt> elements in order.  </p>
<p>Test 3 uses <tt class="literal">level="single"</tt> to count the elements at each level.  This means that the fourth <tt class="literal">&lt;sect3&gt;</tt> element inside a given <tt class="literal">&lt;sect2&gt;</tt> element will be numbered with a <tt class="literal">4</tt> (or <tt class="literal">iv</tt> or <tt class="literal">D</tt> or whatever the appropriate value would be).  Notice that the number used for each element is the same as the last number beside each element in Test 1.  </p>
<p>Test 4 does a couple of things differently: first, it uses the uppercase-alpha and lowercase-roman numbering styles.  Second, it counts elements at multiple levels (for the <tt class="literal">&lt;chapter&gt;</tt>, <tt class="literal">&lt;sect1&gt;</tt>, and <tt class="literal">&lt;sect2&gt;</tt> elements), but we only process the <tt class="literal">&lt;sect2&gt;</tt> elements.  Even though we only output the title text for the <tt class="literal">&lt;sect2&gt;</tt> elements, we can still generate the appropriate multilevel numbers.  </p>
<p>Test 5 generates numbers similarly to Test 4, except that it uses the <tt class="literal">from</tt> attribute.  We generate numbers for <tt class="literal">&lt;sect3&gt;</tt> elements in four stages; first, we count the <tt class="literal">&lt;chapter&gt;</tt> ancestors, starting at the first <tt class="literal">&lt;book&gt;</tt> ancestor; then we count the <tt class="literal">&lt;sect1&gt;</tt> ancestors, starting at the first <tt class="literal">&lt;chapter&gt;</tt> ancestor, etc.  </p>
<p>Test 6 starts counting at 1000 instead of 1.  To do this, we have to store the value generated by <tt class="literal">&lt;xsl:number&gt;</tt> in a variable, then output the value of the variable plus 1000.  Notice that we can use an expression in the <tt class="literal">value</tt> attribute of the <tt class="literal">&lt;xsl:number&gt;</tt> element.  We also used the <tt class="literal">grouping-separator</tt> attribute to use a comma to separate groups of three digits. </p>
<p>Last but not least, Test 7 only numbers items from the first and second <tt class="literal">&lt;sect1&gt;</tt> elements (<tt class="literal">&lt;sect1&gt;</tt> elements whose <tt class="literal">position()</tt> is less than 3) in the second <tt class="literal">&lt;chapter&gt;</tt> element.  Even though we're only processing these sections, we can still use <tt class="literal">&lt;xsl:number&gt;</tt> to generate the correct numbers for the elements. </p>
</div>
<a name="INDEX-861" /><a name="INDEX-862" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:otherwise&gt;</i></b></font></td><td align="right"><i>Defines the else or default case in an &lt;xsl:choose&gt; element. This element always appears inside an &lt;xsl:choose&gt; element, and it must always appear last.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Subinstruction (<tt class="literal">&lt;xsl:otherwise&gt;</tt> always appears as part of an <tt class="literal">&lt;xsl:choose&gt;</tt> element).</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>A template.</p>

<h4 class="refsect1">Appears in</h4>
<p>The <tt class="literal">&lt;xsl:choose&gt;</tt> element.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 9.2, Conditional Processing with <tt class="literal">xsl:choose</tt>.</p>

<h4 class="refsect1">Example</h4>
<p>As an example, we'll use an <tt class="literal">&lt;xsl:choose&gt;</tt> element that cycles through a set of values for the background color of a cell in an HTML table. We'll use this XML document as our input:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>Here is our stylesheet, which uses <tt class="literal">&lt;xsl:choose&gt;</tt> inside an <tt class="literal">&lt;xsl:attribute&gt;</tt> element to determine the correct value for the <tt class="literal">bgcolor</tt> attribute. We have an <tt class="literal">&lt;xsl:otherwise&gt;</tt> element that generates the value <tt class="literal">whitesmoke</tt> for every fourth <tt class="literal">&lt;listitem&gt;</tt> in our source document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:value-of select="list/title"/&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="list/title"/&gt;&lt;/h1&gt;
        &lt;table border="1"&gt;
          &lt;xsl:for-each select="list/listitem"&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;xsl:attribute name="bgcolor"&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="@bgcolor"&gt;
                      &lt;xsl:value-of select="@bgcolor"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 0"&gt;
                      &lt;xsl:text&gt;papayawhip&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 1"&gt;
                      &lt;xsl:text&gt;mintcream&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 2"&gt;
                      &lt;xsl:text&gt;lavender&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:text&gt;whitesmoke&lt;/xsl:text&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/xsl:attribute&gt;
                &lt;xsl:value-of select="."/&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here is our generated HTML document. Notice that every fourth row has a background color of <tt class="literal">whitesmoke</tt>; that value was generated by the <tt class="literal">&lt;xsl:otherwise&gt;</tt> element: </p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Albums I've bought recently:&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Albums I've bought recently:&lt;/h1&gt;
&lt;table border="1"&gt;
&lt;tr&gt;
&lt;td bgcolor="mintcream"&gt;The Sacred Art of Dub&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="lavender"&gt;Only the Poor Man Feel It&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="whitesmoke"&gt;Excitable Boy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="papayawhip"&gt;Aki Special&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="mintcream"&gt;Combat Rock&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="lavender"&gt;Talking Timbuktu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="whitesmoke"&gt;The Birth of the Cool&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>



<p>When rendered, our HTML document looks like <a href="appa_01.htm">Figure A-7</a>.</p>
<a name="xslt-appa-a7" /><div class="figure"><img height="249" alt="Figure A-7" src="figs/xslt.aa07.gif" width="455" /></div><h4 class="objtitle">Figure A-7. Document cycling among different background colors</h4>
</div>
<a name="INDEX-863" /><a name="INDEX-864" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:output&gt;</i></b></font></td><td align="right"><i>Defines the characteristics of the output document.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>method</i></dt>
<dd>
Typically has one of three values:  <tt class="literal">xml</tt>, <tt class="literal">html</tt>, or <tt class="literal">text</tt>. This value indicates the type of document that is generated. An XSLT processor can add other values to this list; how those values affect the generated document is determined by the XSLT processor. </p>
</dd>


<dt><i>version</i></dt>
<dd>
Defines the value of the <tt class="literal">version</tt> attribute of the XML or HTML declaration in the output document. This attribute is used only when <tt class="literal">method="html"</tt> or <tt class="literal">method="xml"</tt>.</p>
</dd>


<dt><i>encoding</i></dt>
<dd>
Defines the value of the <tt class="literal">encoding</tt> attribute of the XML declaration in the output document. </p>
</dd>


<dt><i>omit-xml-declaration</i></dt>
<dd>
Defines whether the XML declaration is omitted in the output document. Allowable values are <tt class="literal">yes</tt> and <tt class="literal">no</tt>. This attribute is used only when <tt class="literal">method="xml"</tt>.</p>
</dd>


<dt><i>standalone</i></dt>
<dd>
Defines the value of the <tt class="literal">standalone</tt> attribute of the XML declaration in the output document. Valid values are <tt class="literal">yes</tt> and <tt class="literal">no</tt>. This attribute is used only when <tt class="literal">method="xml"</tt>.</p>
</dd>


<dt><i>doctype-public</i></dt>
<dd>
Defines the value of the <tt class="literal">PUBLIC</tt> attribute of the <tt class="literal">DOCTYPE</tt> declaration in the output document. This attribute defines the public identifier of the output document's DTD. It is used only when <tt class="literal">method="html"</tt> or <tt class="literal">method="xml"</tt>.</p>
</dd>


<dt><i>doctype-system</i></dt>
<dd>
Defines the value of the <tt class="literal">SYSTEM</tt> attribute of the <tt class="literal">DOCTYPE</tt> declaration in the output document. It defines the system identifier of the output document's DTD. This attribute is used only when <tt class="literal">method="html"</tt> or <tt class="literal">method="xml"</tt>.</p>
</dd>


<dt><i>cdata-section-elements</i></dt>
<dd>
Lists the elements that should be written as <tt class="literal">CDATA</tt> sections in the output document. All restrictions and escaping conventions of <tt class="literal">CDATA</tt> sections are handled by the XSLT processor. If you need to list more than one element, separate the element names with one or more whitespace characters. This attribute is used only when <tt class="literal">method="xml"</tt>.</p>
</dd>


<dt><i>indent</i></dt>
<dd>
Specifies whether the tags in the output document should be indented. Allowable values are <tt class="literal">yes</tt> and <tt class="literal">no</tt>. This attribute is used only when <tt class="literal">method="xml"</tt> or <tt class="literal">method="html"</tt>, and the XSLT processor is not required to honor it.</p>
</dd>


<dt><i>media-type</i></dt>
<dd>
Defines the MIME type of the output document.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:output&gt;</tt> is an empty element.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:output&gt;</tt> is a top-level element and can only appear as a child of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 16, Output. </p>

<h4 class="refsect1">Example</h4>
<p>To illustrate the three output methods defined in the XSLT specification, we'll create three stylesheets, each of which uses one of the three methods. We'll use the following XML document in all three examples:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>We'll now look at our three stylesheets and the results produced by each. First, let's look at the <tt class="literal">method="xml"</tt> stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output 
    method="xml" 
    doctype-public="-//W3C/DTD XHTML 1.0//EN"
    doctype-system="file:///d:/xhtml.dtd"
    encoding="ISO-8859-1"
    indent="no"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="/list/title"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="/list/title"/&gt;&lt;/h1&gt;
        &lt;p&gt;
          &lt;xsl:for-each select="/list/listitem"&gt;
            &lt;xsl:number format="1. "/&gt;
            &lt;xsl:value-of select="."/&gt;
            &lt;br/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/p&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>This stylesheet generates the following results:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C/DTD XHTML 1.0//EN" "file:///d:/xhtml.dtd"&gt; 
&lt;html&gt;&lt;head&gt;&lt;title&gt;A few of my favorite albums&lt;/title&gt; 
&lt;/head&gt;&lt;body&gt;&lt;h1&gt;A few of my favorite albums&lt;/h1&gt; 
&lt;p&gt;1. A Love Supreme&lt;br/&gt;2. Beat Crazy&lt;br/&gt;3. Here Come the  
Warm Jets&lt;br/&gt;4. Kind of Blue&lt;br/&gt;5. London Calling&lt;br/&gt;6. 
Remain in Light&lt;br/&gt;7. The Joshua Tree&lt;br/&gt;8. The Indestructible  
Beat of Soweto&lt;br/&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre></blockquote>
<p>(We actually added line breaks to this listing; the original output put everything from <tt class="literal">&lt;html&gt;</tt> through <tt class="literal">&lt;/html&gt;</tt> on a single line.)</p><p>The output document has the <tt class="literal">encoding</tt> we specified in our stylesheet, and the <tt class="literal">DOCTYPE</tt> declaration includes the <tt class="literal">PUBLIC</tt> and <tt class="literal">SYSTEM</tt> identifiers we requested as well. Even with the line breaks we added, it's still obvious that this document has not been formatted with any extra whitespace whatsoever. We also have empty <tt class="literal">&lt;br/&gt;</tt> elements in our output document; those elements will be handled differently when we specify <tt class="literal">method="html"</tt>. Speaking of which, here is our <tt class="literal">method="html"</tt> stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output 
    method="html" 
    encoding="ISO-8859-1"
    doctype-public="-//W3C/DTD HTML 1.0 Transitional//EN"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="/list/title"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="/list/title"/&gt;&lt;/h1&gt;
        &lt;p&gt;
          &lt;xsl:for-each select="/list/listitem"&gt;
            &lt;xsl:number format="1. "/&gt;
            &lt;xsl:value-of select="."/&gt;
            &lt;br/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/p&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here is the HTML document generated by this stylesheet:</p>
<blockquote><pre class="code">
&lt;!DOCTYPE HTML PUBLIC "-//W3C/DTD HTML 1.0 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;
&lt;title&gt;A few of my favorite albums&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;A few of my favorite albums&lt;/h1&gt;
&lt;p&gt;1. A Love Supreme&lt;br&gt;2. Beat Crazy&lt;br&gt;3. Here Come 
the Warm Jets&lt;br&gt;4. Kind of Blue&lt;br&gt;5. London Calling&lt;br&gt;6. 
Remain in Light&lt;br&gt;7. The Joshua Tree&lt;br&gt;8. The Indestructible 
Beat of Soweto&lt;br&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>(As before, we added line breaks to make the listing legible.)  Notice that the XSLT processor has automatically inserted a <tt class="literal">&lt;META&gt;</tt> element in the <tt class="literal">&lt;head&gt;</tt> of our HTML document. The <tt class="literal">&lt;br&gt;</tt> elements that were empty in our previous stylesheet are now old-fashioned <tt class="literal">&lt;br&gt;</tt> tags. Even though this style of XSLT output results in a document that is not valid XML (or XHTML), the document will work with existing HTML browsers. </p>
<p>Our final stylesheet will use <tt class="literal">method="text"</tt>:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="/list/title"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="/list/title"/&gt;&lt;/h1&gt;
        &lt;p&gt;
          &lt;xsl:for-each select="/list/listitem"&gt;
            &lt;xsl:number format="1. "/&gt;
            &lt;xsl:value-of select="."/&gt;
            &lt;br/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/p&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results, such as they are, from this stylesheet:</p>
<blockquote><pre class="code">
A few of my favorite albumsA few of my favorite albums1. A Love Supreme2. Beat 
Crazy3. Here Come the Warm Jets4. Kind of Blue5. London Calling6. Remain in 
Light7. The Joshua Tree8. The Indestructible Beat of Soweto</pre></blockquote>
<p>(As before, we inserted line breaks so the document would fit on the page.)  These results are basically worthless. Why weren't our carefully coded HTML elements output to the text document?  The reason is that the <tt class="literal">text</tt> output method only outputs text nodes to the result tree. Even though we requested that various HTML elements be generated along the way, they're ignored because we specified <tt class="literal">method="text"</tt>.</p>
</div>
<a name="INDEX-865" /><a name="INDEX-866" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:param&gt;</i></b></font></td><td align="right"><i>Defines the name and value of a parameter to be used by a template. This element can appear as a top-level element or inside the &lt;xsl:template&gt; element. If the &lt;xsl:param&gt; appears as a top-level element, it is a global parameter, visible to all areas of the stylesheet. The value of the parameter can be defined in one of two ways:  specified in the select attribute, or defined in an XSLT template inside the &lt;xsl:param&gt; element itself. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
Defines the name of this parameter. </p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>select</i></dt>
<dd>
Contains an XPath expression that defines the value of this parameter. </p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>If the <tt class="literal">select</tt> attribute is used, <tt class="literal">&lt;xsl:param&gt;</tt> should be empty. Otherwise, it contains an XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>

<tt class="literal">&lt;xsl:stylesheet&gt;</tt> and
<tt class="literal">&lt;xsl:template&gt;</tt>. If an
<tt class="literal">&lt;xsl:param&gt;</tt> appears as a child of
<tt class="literal">&lt;xsl:stylesheet&gt;</tt>, then it is a global
parameter visible throughout the stylesheet. XSLT doesn't define the
way global parameters are passed to the XSLT processor, so check the
documentation for your processor to see how this is done. (See <a href="ch04_04.htm">Section 4.4.3, "Global Parameters"</a> in <a href="ch04_01.htm">Chapter 4, "Branching and Control Elements"</a>
for an overview of how to pass parameters to the most popular XSLT
processors.)  </p>


<h4 class="refsect1">Defined in</h4>
<p>XSLT section 11, Variables and Parameters. </p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet that defines several <tt class="literal">&lt;xsl:param&gt;</tt> elements, both global and local. Notice that one of the parameters is a node-set; parameters can be of any XPath or XSLT datatype: </p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;


  &lt;xsl:param name="favoriteNumber" select="23"/&gt;
  &lt;xsl:param name="favoriteColor"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="list/title"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:variable name="listitems" select="list/listitem"/&gt;
    &lt;xsl:call-template name="processListitems"&gt;
      &lt;xsl:with-param name="items" select="$listitems"/&gt;
      &lt;xsl:with-param name="color" select="'yellow'"/&gt;
      &lt;xsl:with-param name="number" select="$favoriteNumber"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="processListitems"&gt;
    &lt;xsl:param name="items"/&gt;
    &lt;xsl:param name="color" select="'blue'"/&gt;

    &lt;xsl:for-each select="$items"&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt;.  &lt;/xsl:text&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    
    &lt;xsl:text&gt;Your favorite color is &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$favoriteColor"/&gt;
    &lt;xsl:text&gt;.&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;The color passed to this template is &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$color"/&gt;
    &lt;xsl:text&gt;.&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll use this stylesheet to transform the following document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>Here are the results:</p>
<blockquote><pre class="code">

A few of my favorite albums
1.  A Love Supreme
2.  Beat Crazy
3.  Here Come the Warm Jets
4.  Kind of Blue
5.  London Calling
6.  Remain in Light
7.  The Joshua Tree
8.  The Indestructible Beat of Soweto

Your favorite color is purple.
The color passed to this template is yellow.</pre></blockquote>
<p>To generate these results, we passed the value <tt class="literal">purple</tt> to the XSLT processor. With Xalan, the value is passed like this:</p>
<blockquote><pre class="code">
java org.apache.xalan.xslt.Process -in test4.xml -xsl param.xsl 
  -param favoriteColor purple</pre></blockquote>

<p>(The command should be entered on a single line.)  See <a href="ch04_04.htm">Section 4.4.3, "Global Parameters"</a> in <a href="ch04_01.htm">Chapter 4, "Branching and Control Elements"</a> for a more
complete discussion of global parameters and how they can be set for
various XSLT processors. </p>

</div>
<a name="INDEX-867" /><a name="INDEX-868" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:preserve-space&gt;</i></b></font></td><td align="right"><i>Defines the source document elements for which whitespace should be preserved.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

        <dt><i>elements</i></dt>
        <dd>
        This attribute defines the elements for which whitespace should be preserved.  If you need to define more than one element, separate the element names with one or more whitespace characters.  </p>
      </dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>None.  <tt class="literal">&lt;xsl:preserve-space&gt;</tt> is an empty element.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;preserve-space&gt;</tt> is a top-level element and can only appear as a child of 
<tt class="literal">&lt;xsl:stylesheet&gt;</tt>
.  </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 3.4, Whitespace Stripping.</p>

<h4 class="refsect1">Example</h4>
<p>We'll illustrate how <tt class="literal">&lt;preserve-space&gt;</tt> works with the following stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;
  &lt;xsl:preserve-space elements="listing"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="/code-sample/title"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="/code-sample/listing"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll use this stylesheet to process the following document:</p>
      <blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;code-sample&gt;
  &lt;title&gt;Conditional variable initialization&lt;/title&gt;
  &lt;listing&gt;
  &lt;type&gt;int&lt;/type&gt; &lt;variable&gt;y&lt;/variable&gt; = &lt;constant&gt;23&lt;/constant&gt;;
  &lt;type&gt;int&lt;/type&gt; &lt;variable&gt;x&lt;/variable&gt;;
    &lt;keyword&gt;if&lt;/keyword&gt; (&lt;variable&gt;y&lt;/variable&gt; &gt; &lt;constant&gt;10&lt;/constant&gt;)
    &lt;variable&gt;x&lt;/variable&gt; = &lt;constant&gt;5&lt;/constant&gt;;
  &lt;keyword&gt;else&lt;/keyword&gt; 
    &lt;keyword&gt;if&lt;/keyword&gt; (&lt;variable&gt;y&lt;/variable&gt; &gt; &lt;constant&gt;5&lt;/constant&gt;)
      &lt;variable&gt;x&lt;/variable&gt; = &lt;constant&gt;3&lt;/constant&gt;;
  &lt;keyword&gt;else&lt;/keyword&gt;
    &lt;variable&gt;x&lt;/variable&gt; = &lt;constant&gt;1&lt;/constant&gt;;
  &lt;/listing&gt;
&lt;/code-sample&gt;
      </pre></blockquote>

      <p>When we process this document with our stylesheet, we get these results:</p>
<blockquote><pre class="code">

Conditional variable initialization

  int y = 23;
  int x;
    if (y &gt; 10)
    x = 5;
  else
    if (y &gt; 5)
      x = 3;
  else
    x = 1;</pre></blockquote>
<p>Compare this example to the one for the <tt class="literal">&lt;strip-space&gt;</tt> element.</p>
</div>
<a name="INDEX-869" /><a name="INDEX-870" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:processing-instruction&gt;</i></b></font></td><td align="right"><i>Creates a processing instruction in the output document.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
Defines the name of this processing instruction.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>An XSLT template. The contents of the template become the data of the processing instruction.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:processing-instruction&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.3, Creating Processing Instructions.</p>

<h4 class="refsect1">Example</h4>
<p>We'll demonstrate a stylesheet that adds a processing instruction to an XML document. The processing instruction will associate the stylesheet <em class="filename">template.xsl</em> with this XML document. Here is our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;


  &lt;xsl:template match="/"&gt;
    &lt;xsl:processing-instruction name="xml-stylesheet"&gt;href="docbook/html/docbook.xsl" 
       type="text/xsl"&lt;/xsl:processing-instruction&gt;
    &lt;xsl:copy-of select="."/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>This stylesheet simply uses the <tt class="literal">&lt;xsl:copy-of&gt;</tt> element to copy the input document to the result tree, adding a processing instruction along the way. We'll use our stylesheet with this XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>When we run this transformation, here are the results:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet href="docbook/html/docbook.xsl" type="text/xsl"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>Note that the contents of a processing instruction are text. Even though the processing instruction we just generated looks like it contains two attributes, you can't create the processing instruction like this:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:processing-instruction name="xml-stylesheet"&gt;

      &lt;!-- This doesn't work!  You can't put &lt;xsl:attribute&gt;
           elements inside a &lt;xsl:processing-instruction&gt; element. --&gt;

      &lt;xsl:attribute name="href"&gt;
        &lt;xsl:text&gt;docbook/html/docbook.xsl&lt;/xsl:text&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:attribute name="type"&gt;
        &lt;xsl:text&gt;text/xsl&lt;/xsl:text&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:processing-instruction&gt;
    &lt;xsl:copy-of select="."/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>If you try this, you'll get an exception from the XSLT processor. </p>
</div>
<a name="INDEX-871" /><a name="INDEX-872" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:sort&gt;</i></b></font></td><td align="right"><i>Defines a sort key for the current context. This element appears as a child of the &lt;xsl:apply-templates&gt; or &lt;xsl:for-each&gt; elements. Within those elements, the first &lt;xsl:sort&gt; defines the primary sort key, the second &lt;xsl:sort&gt; defines the secondary sort key, etc.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Subinstruction (<tt class="literal">&lt;xsl:sort&gt;</tt> always appears as a child of the <tt class="literal">&lt;xsl:apply-templates&gt;</tt> or <tt class="literal">&lt;xsl:for-each&gt;</tt> elements)</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>select</i></dt>
<dd>
An XPath expression that defines the nodes to be sorted. </p>
</dd>


<dt><i>lang</i></dt>
<dd>
A string that defines the language used by the sort. The language codes are defined in RFC1766, available at <a href="../../../../../../www.ietf.org/rfc/rfc1766.txt">http://www.ietf.org/rfc/rfc1766.txt</a>.</p>
</dd>


<dt><i>data-type</i></dt>
<dd>
An attribute that defines the type of the items to be sorted. Allowable values are <tt class="literal">number</tt> and <tt class="literal">text</tt>; the default is <tt class="literal">text</tt>. An XSLT processor has the option of supporting other values as well. Sorting the values <tt class="literal">32 10 120</tt> with <tt class="literal">data-type="text"</tt> returns <tt class="literal">10 120 32</tt>, while <tt class="literal">data-type="number"</tt> returns <tt class="literal">10 32 120</tt>.</p>
</dd>


<dt><i>order</i></dt>
<dd>
An attribute that defines the order of the sort. Allowable values are <tt class="literal">ascending</tt> and <tt class="literal">descending</tt>. </p>
</dd>


<dt><i>case-order</i></dt>
<dd>
An attribute that defines the order in which upper- and lowercase letters are sorted. Allowable values are <tt class="literal">upper-first</tt> and <tt class="literal">lower-first</tt>.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>None.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:apply-templates&gt;</tt> and <tt class="literal">&lt;xsl:for-each&gt;</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 10, Sorting.</p>

<h4 class="refsect1">Example</h4>
<p>We'll illustrate <tt class="literal">&lt;xsl:sort&gt;</tt> with this stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:call-template name="ascending-alpha-sort"&gt;
      &lt;xsl:with-param name="items" select="/sample/textlist/listitem"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:call-template name="ascending-alpha-sort"&gt;
      &lt;xsl:with-param name="items" select="/sample/numericlist/listitem"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:call-template name="ascending-numeric-sort"&gt;
      &lt;xsl:with-param name="items" select="/sample/numericlist/listitem"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:call-template name="descending-alpha-sort"&gt;
      &lt;xsl:with-param name="items" select="/sample/textlist/listitem"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="ascending-alpha-sort"&gt;
    &lt;xsl:param name="items"/&gt;
    &lt;xsl:text&gt;Ascending text sort:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="$items"&gt;
      &lt;xsl:sort select="."/&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="descending-alpha-sort"&gt;
    &lt;xsl:param name="items"/&gt;
    &lt;xsl:text&gt;Descending text sort:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="$items"&gt;
      &lt;xsl:sort select="." order="descending"/&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="ascending-numeric-sort"&gt;
    &lt;xsl:param name="items"/&gt;
    &lt;xsl:text&gt;Ascending numeric sort:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="$items"&gt;
      &lt;xsl:sort select="." data-type="number"/&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Our stylesheet defines three named templates, each of which sorts <tt class="literal">&lt;listitem&gt;</tt>s in a different order or with a different <tt class="literal">data-type</tt>. We'll use this stylesheet against this document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;sample&gt;
  &lt;numericlist&gt;
    &lt;listitem&gt;1&lt;/listitem&gt;
    &lt;listitem&gt;3&lt;/listitem&gt;
    &lt;listitem&gt;23&lt;/listitem&gt;
    &lt;listitem&gt;120&lt;/listitem&gt;
    &lt;listitem&gt;2&lt;/listitem&gt;
  &lt;/numericlist&gt;
  &lt;textlist&gt;
    &lt;listitem&gt;3&lt;/listitem&gt;
    &lt;listitem&gt;apple&lt;/listitem&gt;
    &lt;listitem&gt;orange&lt;/listitem&gt;
    &lt;listitem&gt;dragonfruit&lt;/listitem&gt;
    &lt;listitem&gt;carambola&lt;/listitem&gt;
  &lt;/textlist&gt;
&lt;/sample&gt;</pre></blockquote>

<p>Here are the results:</p>
<blockquote><pre class="code">

Ascending text sort:
3
apple
carambola
dragonfruit
orange

Ascending text sort:
1
120
2
23
3

Ascending numeric sort:
1
2
3
23
120

Descending text sort:
orange
dragonfruit
carambola
apple
3</pre></blockquote>
<p>Notice that the <tt class="literal">data-type="numeric"</tt> attribute causes data to be sorted in numeric order. </p>
</div>
<a name="INDEX-873" /><a name="INDEX-874" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:strip-space&gt;</i></b></font></td><td align="right"><i>Defines the source-document elements for which whitespace should be removed.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

        <dt><i>elements</i></dt>
        <dd>
        Contains a space-separated list of source document elements for which nonsignificant whitespace should be removed.  Nonsignificant whitespace typically means text nodes that contain nothing but whitespace; whitespace that appears in and around text is preserved.  </p>
      </dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>None.  <tt class="literal">&lt;xsl:strip-space&gt;</tt> is an empty element.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:strip-space&gt;</tt> is a top-level element, and can only appear as a child of 
<tt class="literal">&lt;xsl:stylesheet&gt;</tt>
.  </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 3.4, Whitespace Stripping.  </p>

<h4 class="refsect1">Example</h4>
<p>We'll illustrate the <tt class="literal">&lt;xsl:strip-space&gt;</tt> element with the following stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;
  &lt;xsl:strip-space elements="listing"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="/code-sample/title"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="/code-sample/listing"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll use this stylesheet to process the following document:</p>
      <blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;code-sample&gt;
  &lt;title&gt;Conditional variable initialization&lt;/title&gt;
  &lt;listing&gt;
  &lt;type&gt;int&lt;/type&gt; &lt;variable&gt;y&lt;/variable&gt; = &lt;constant&gt;23&lt;/constant&gt;;
  &lt;type&gt;int&lt;/type&gt; &lt;variable&gt;x&lt;/variable&gt;;

    &lt;keyword&gt;if&lt;/keyword&gt; (&lt;variable&gt;y&lt;/variable&gt; &gt; &lt;constant&gt;10&lt;/constant&gt;)
    &lt;variable&gt;x&lt;/variable&gt; = &lt;constant&gt;5&lt;/constant&gt;;
  &lt;keyword&gt;else&lt;/keyword&gt; 
    &lt;keyword&gt;if&lt;/keyword&gt; (&lt;variable&gt;y&lt;/variable&gt; &gt; &lt;constant&gt;5&lt;/constant&gt;)
      &lt;variable&gt;x&lt;/variable&gt; = &lt;constant&gt;3&lt;/constant&gt;;
  &lt;keyword&gt;else&lt;/keyword&gt;
    &lt;variable&gt;x&lt;/variable&gt; = &lt;constant&gt;1&lt;/constant&gt;;
  &lt;/listing&gt;
&lt;/code-sample&gt;</pre></blockquote>
<p>Here are the results:</p>
<blockquote><pre class="code">

Conditional variable initialization
inty = 23;
  intx;
    if (y &gt; 10)
    x = 5;
  elseif (y &gt; 5)
      x = 3;
  elsex = 1;</pre></blockquote>
<p>Notice that all the extra whitespace from the <tt class="literal">&lt;listing&gt;</tt> element has been removed.  This includes the space between the various elements contained inside <tt class="literal">&lt;listing&gt;</tt>, such as <tt class="literal">&lt;keyword&gt;</tt>, <tt class="literal">&lt;constant&gt;</tt>, and <tt class="literal">&lt;variable&gt;</tt>.  Compare this example to the one for the <tt class="literal">&lt;preserve-space&gt;</tt> element.</p>
</div>
<a name="INDEX-875" /><a name="INDEX-876" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:stylesheet&gt;</i></b></font></td><td align="right"><i>The root element of an XSLT stylesheet. It is identical to the &lt;xsl:transform&gt; element, which was included in the XSLT specification for historical purposes. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Contains the entire stylesheet</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>version</i></dt>
<dd>
Indicates the version of XSLT that the stylesheet requires. For XSLT version 1.0, its value should always be <tt class="literal">"1.0"</tt>. As later versions of the XSLT specification are defined, the required values for the <tt class="literal">version</tt> attribute will be defined along with them. </p>
</dd>


<dt><i>xmlns:xsl</i></dt>
<dd>
Defines the URI for the XSL namespace. For XSLT Version 1.0, this attribute's value should be <tt class="literal">http://www.w3.org/1999/XSL/Transform</tt>. Note that most XSLT processors will give you a warning message if your <tt class="literal">xmlns:xsl</tt> declaration does not have the proper value.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>id</i></dt>
<dd>
Defines an ID for this stylesheet. </p>
</dd>


<dt><i>extension-element-prefixes</i></dt>
<dd>

<p>Defines any namespace prefixes used to invoke extension elements. Multiple namespace prefixes are separated by whitespace.</p>
</dd>


<dt><i>exclude-result-prefixes</i></dt>
<dd>
Defines namespace prefixes that should not be sent to the output document. Multiple namespace prefixes are separated by whitespace.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>This element contains the entire stylesheet. The following items can be children of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>:</p>
<ul>
        <li>
          <p>
<tt class="literal">&lt;xsl:import&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:include&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:strip-space&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:preserve-space&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:output&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:key&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:decimal-format&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:namespace-alias&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:attribute-set&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:variable&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:param&gt;</tt>
</p>
        </li>
        <li>
          <p>
<tt class="literal">&lt;xsl:template&gt;</tt>
</p>
        </li>
      </ul>

<h4 class="refsect1">Appears in</h4>
<p>None. <tt class="literal">&lt;xsl:stylesheet&gt;</tt> is the root element of the stylesheet.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 2.2, Stylesheet Element. </p>

<h4 class="refsect1">Example</h4>
<p>For the sake of completeness, we'll include an example here. We'll use the Hello World document from the XML 1.0 specification for our example:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;greeting&gt;
  Hello, World!
&lt;/greeting&gt;</pre></blockquote>
<p>We'll transform our document with this stylesheet:</p>
<blockquote><pre class="code">
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates select="greeting"/&gt;
  &lt;/xsl:template&gt;
  
  &lt;xsl:template match="greeting"&gt;
    &lt;html&gt;
      &lt;body&gt;
        &lt;h1&gt;
          &lt;xsl:value-of select="."/&gt;
        &lt;/h1&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When we transform our document with this stylesheet, here are the results:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;
  Hello, World!
&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
</div>
<a name="INDEX-877" /><a name="INDEX-878" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:template&gt;</i></b></font></td><td align="right"><i>Defines an output template. For templates that begin &lt;xsl:template match="x", the template defines a transformation for a given element. Templates that begin &lt;xsl:template name="x" define a set of output elements that are processed whenever the template is invoked. All &lt;xsl:template&gt; elements must have either the match or the name attribute defined. Although not common, it is also possible to create &lt;xsl:template&gt; elements that have both a match and a name.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Top-level element</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>match</i></dt>

<dd>
A pattern that defines the elements for which this template should be invoked. For example, <tt class="literal">&lt;xsl:template match="xyz"&gt;</tt> defines a template for processing <tt class="literal">&lt;xyz&gt;</tt> elements. </p>
</dd>


<dt><i>name</i></dt>
<dd>
An attribute that names this template. Named templates are invoked with the <tt class="literal">&lt;xsl:call-template&gt;</tt> element. </p>
</dd>


<dt><i>mode</i></dt>
<dd>
An attribute that defines a mode for this template. A mode is a convenient syntax that allows you to write specific templates for specific purposes. For example, I could write an <tt class="literal">&lt;xsl:template&gt;</tt> with <tt class="literal">mode="toc"</tt> to process a node for the table of contents of a document and other <tt class="literal">&lt;xsl:template&gt;</tt>s with <tt class="literal">mode="print"</tt>, <tt class="literal">mode="online"</tt>, <tt class="literal">mode="index"</tt>, etc. to process the same information for different purposes. </p>
</dd>


<dt><i>priority</i></dt>
<dd>
An attribute that assigns a numeric priority to this template. The value can be any numeric value except <tt class="literal">Infinity</tt>. If the XSLT processor cannot determine which template to use (in other words, more than one template has the same default priority), the <tt class="literal">priority</tt> attribute allows you to define a tiebreaker. </p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>An XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:stylesheet&gt;</tt>. <tt class="literal">&lt;xsl:template&gt;</tt> is a top-level element and can only appear as a child of <tt class="literal">&lt;xsl:stylesheet&gt;</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 5.3, Defining Template Rules. </p>

<h4 class="refsect1">Example</h4>
<p>We'll use a template that copies all nodes from the input document to the output document, with one important difference: all attributes in the original document are converted to elements in the output document. The name of each generated element is the name of the original attribute, and the text of each element is the attribute's value. Here's our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;
  &lt;xsl:template match="*"&gt;
    &lt;xsl:element name="{name()}"&gt;
      &lt;xsl:for-each select="@*"&gt;
        &lt;xsl:element name="{name()}"&gt;
          &lt;xsl:value-of select="."/&gt;
        &lt;/xsl:element&gt;
      &lt;/xsl:for-each&gt;
      &lt;xsl:apply-templates select="*|text()"/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></blockquote>

<p>Our stylesheet contains a single <tt class="literal">&lt;xsl:template&gt;</tt> that transforms every node in the original document. We'll use our stylesheet to transform the following XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>Here are the results of our transformation:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month&gt;&lt;sequence&gt;01&lt;/sequence&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;&lt;sequence&gt;02&lt;/sequence&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;&lt;sequence&gt;03&lt;/sequence&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month&gt;&lt;sequence&gt;04&lt;/sequence&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
</div>
<a name="INDEX-879" /><a name="INDEX-880" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:text&gt;</i></b></font></td><td align="right"><i>Allows you to write literal text to the output document. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>disable-output-escaping</i></dt>
<dd>
Defines whether special characters are escaped when they are written to the output document. For example, if the literal text contains the character <tt class="literal">&gt;</tt>, it is normally written to the output document as <tt class="literal">&amp;gt;</tt>. If you code <tt class="literal">disable-output-escaping="yes"</tt>, the character <tt class="literal">&gt;</tt> is written instead. The XSLT processor uses this attribute only if you're using the <tt class="literal">html</tt> or <tt class="literal">xml</tt> output methods. If you're using <tt class="literal">&lt;xsl:output method="text"&gt;</tt>, the attribute is ignored because output escaping is not done for the <tt class="literal">text</tt> output method.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>
<tt class="literal">#PCDATA</tt>, literal text, and entity references.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:text&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.2, Creating Text. </p>

<h4 class="refsect1">Example</h4>
<p>This sample stylesheet generates text with <tt class="literal">&lt;xsl:text&gt;</tt>. We intermingle <tt class="literal">&lt;xsl:text&gt;</tt> elements and <tt class="literal">&lt;xsl:value-of&gt;</tt> elements to create a coherent sentence. In this case, we simply generate a text document, but this technique works equally well to create the text of an HTML or XML element. Here is the stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:text&gt;Your document contains &lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(//*)"/&gt;
    &lt;xsl:text&gt; elements and &lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(//@*)"/&gt;
    &lt;xsl:text&gt; attributes. &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text disable-output-escaping="yes"&gt;&lt;Have a great day!&gt;&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Also notice our use of <tt class="literal">&lt;xsl:variable&gt;</tt> to generate line breaks. The <tt class="literal">&lt;xsl:text&gt;</tt> element inside the <tt class="literal">&lt;xsl:variable&gt;</tt> element contains a line break, so writing the value of that variable to the result tree gives us the line break we want. Given this XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>Our stylesheet produces these results:</p>
<blockquote><pre class="code">
Your document contains 9 elements and 5 attributes.
&lt;Have a great day!&gt;</pre></blockquote>
<p>Since we use the <tt class="literal">text</tt> output method, the <tt class="literal">disable-output-escaping</tt> attribute has no effect. If you change the stylesheet to use <tt class="literal">&lt;xsl:output method="html"/&gt;</tt> or <tt class="literal">&lt;xsl:output method="xml"/&gt;</tt>, then <tt class="literal">disable-output-escaping</tt> is used. Here are the results for <tt class="literal">disable-output-escaping="yes"</tt>:</p>
<blockquote><pre class="code">
Your document contains 10 elements and 2 attributes.
&lt;Have a great day!&gt;</pre></blockquote>
<p>And here are the results for <tt class="literal">disable-output-escaping="no"</tt>, the default:</p>
<blockquote><pre class="code">
Your document contains 10 elements and 2 attributes.
&amp;lt;Have a great day!&amp;gt;</pre></blockquote>
</div>
<a name="INDEX-881" /><a name="INDEX-882" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:transform&gt;</i></b></font></td><td align="right"><i>This is a synonym for &lt;xsl:stylesheet&gt;.  It was included in the XSLT 1.0 spec for historical purposes.  Its attributes, content, and all other properties are the same as those for &lt;xsl:stylesheet&gt;.  See &lt;xsl:stylesheet&gt; for more information.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table></div>
<a name="INDEX-883" /><a name="INDEX-884" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:value-of&gt;</i></b></font></td><td align="right"><i>Calculates the value of an XPath expression, converts that value to a string, and then writes the value to the result tree.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>select</i></dt>
<dd>
The XPath expression that is evaluated and written to the output document.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>disable-output-escaping</i></dt>
<dd>
An attribute that defines whether special characters are escaped when written to the output document. For example, if the literal text contains the character <tt class="literal">&gt;</tt>, it is normally written to the output document as <tt class="literal">&amp;gt;</tt>. If you code <tt class="literal">disable-output-escaping="yes"</tt>, the character <tt class="literal">&gt;</tt> is written instead. The XSLT processor uses this attribute only if you use the <tt class="literal">html</tt> or <tt class="literal">xml</tt> output methods. If you use <tt class="literal">&lt;xsl:output method="test"&gt;</tt>, the attribute is ignored becasue output escaping is not done for the <tt class="literal">text</tt> output method. See <a href="appa_01.htm">Reference A.30</a> for a more thorough discussion of the <tt class="literal">disable-output-escaping</tt> attribute.</p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>None. <tt class="literal">&lt;xsl:value-of&gt;</tt> is an empty element.</p>

<h4 class="refsect1">Appears in</h4>
<p><tt class="literal">&lt;xsl:value-of&gt;</tt> appears inside a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 7.6.1, Generating Text with <tt class="literal">xsl:value-of</tt>.</p>

<h4 class="refsect1">Example</h4>
<p>We'll use the <tt class="literal">&lt;xsl:value-of&gt;</tt> element to generate some text. Here is our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xsl version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:text&gt;Your document contains&lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(//*)"/&gt;
    &lt;xsl:text&gt; elements and &lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(//@*)"/&gt;
    &lt;xsl:text&gt; attributes.  &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Have a great day!&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></blockquote>

<p>We'll use this XML document as input:</p>

<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>

<p>Here are the results:</p>
<blockquote><pre class="code">
Your document contains 14 elements and 4 attributes.
Have a great day!</pre></blockquote>
</div>

<a name="INDEX-885" /><a name="INDEX-886" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:variable&gt;</i></b></font></td><td align="right"><i>Defines a variable. If &lt;xsl:variable&gt; occurs as a top-level element, it is a global variable that is accessible throughout the stylesheet. Otherwise, the variable is local and exists only in the element that contains the &lt;xsl:variable&gt;. The value of the variable can be defined in one of two ways:  specified in the select attribute or defined in an XSLT template inside the &lt;xsl:variable&gt; element itself. If neither method is used, the value of the variable is an empty string.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Either a top-level element or an instruction</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
An attribute that names this variable.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>select</i></dt>
<dd>
An XPath expression that defines the value of this variable. </p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>The <tt class="literal">&lt;xsl:variable&gt;</tt> element can be empty, or it can contain an XSLT template. If it contains an XSLT template, the value of the <tt class="literal">select</tt> attribute (if any exists) is ignored.</p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:stylesheet&gt;</tt> as a top-level element or in a template.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 11, Variables and Parameters. </p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet that defines a number of variables:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:variable name="favoriteNumber" select="23"/&gt;
  &lt;xsl:variable name="favoriteColor" select="'blue'"/&gt;
  &lt;xsl:variable name="complicatedVariable"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="count(//listitem) &gt; 10"&gt;
        &lt;xsl:text&gt;really long list&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="count(//listitem) &gt; 5"&gt;
        &lt;xsl:text&gt;moderately long list&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;fairly short list&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:text&gt;Hello!  Your favorite number is &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$favoriteNumber"/&gt;
    &lt;xsl:text&gt;.&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Your favorite color is &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$favoriteColor"/&gt;
    &lt;xsl:text&gt;.&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Here is a &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$complicatedVariable"/&gt;
    &lt;xsl:text&gt;:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:variable name="listitems" select="list/listitem"/&gt;
    &lt;xsl:call-template name="processListitems"&gt;
      &lt;xsl:with-param name="items" select="$listitems"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="processListitems"&gt;
    &lt;xsl:param name="items"/&gt;
    &lt;xsl:variable name="favoriteColor"&gt;
      &lt;xsl:text&gt;chartreuse&lt;/xsl:text&gt;
    &lt;/xsl:variable&gt;
    
    &lt;xsl:text&gt;    (Your favorite color is now &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$favoriteColor"/&gt;
    &lt;xsl:text&gt;.)&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="$items"&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt;.  &lt;/xsl:text&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll use our stylesheet to transform the following document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>

<p>Here are the results of our transformation:</p>
<blockquote><pre class="code">
Hello!  Your favorite number is 23.
Your favorite color is blue.

Here is a moderately long list:
    (Your favorite color is now chartreuse.)
1.  The Sacred Art of Dub
2.  Only the Poor Man Feel It
3.  Excitable Boy
4.  Aki Special
5.  Combat Rock
6.  Talking Timbuktu
7.  The Birth of the Cool</pre></blockquote>
<p>Several things are worth mentioning in our stylesheet. First, notice that when we defined values for the first two variables (<tt class="literal">favoriteNumber</tt> and <tt class="literal">favoriteColor</tt>), we had to quote the string "blue", but didn't have to quote <tt class="literal">23</tt>. If we don't quote <tt class="literal">blue</tt>, the XSLT processor assumes we mean all the <tt class="literal">&lt;blue&gt;</tt> elements in the current context. We don't have to quote <tt class="literal">23</tt> because XML element names can't start with a number. It's a good idea to always quote literals, even those that can't be element names; chances are good that you'll forget this process at some point. </p>
<p>Also notice that we have two variables named <tt class="literal">favoriteColor</tt>. One is a global variable because its parent is the <tt class="literal">&lt;xsl:stylesheet&gt;</tt> element; the other is a local variable because it is defined in a <tt class="literal">&lt;xsl:template&gt;</tt>. When we access <tt class="literal">favoriteColor</tt> in the <tt class="literal">match="/"</tt> template, it has one value; when we access it inside the <tt class="literal">name="processListitems"</tt> template, it has another. Having two variables at the same level with the same name is an error. It's also an error to define an <tt class="literal">&lt;xsl:variable&gt;</tt> and an <tt class="literal">&lt;xsl:param&gt;</tt> with the same name at the same level. </p>
<p>Using an <tt class="literal">&lt;xsl:choose&gt;</tt> element to initialize an <tt class="literal">&lt;xsl:variable&gt;</tt> is a common technique. This technique is the equivalent of this procedural programming construct:</p>
<blockquote><pre class="code">
String complicatedVariable;
if (count(listitems) &gt; 10)
  complicatedVariable = "really long list";
else if (count(listitems)) &gt; 5)
  complicatedVariable = "moderately long list";
else
  complicatedVariable = "fairly short list";</pre></blockquote>
<p>The last point we'll make is that a variable can be any of the XPath or XSLT variable types, including a node-set. When we call the <tt class="literal">processListitems</tt> template, the parameter we pass to it is a variable containing the node-set of all the <tt class="literal">&lt;listitem&gt;</tt> elements in our document. Inside the <tt class="literal">processListitems</tt> template, our variable (which is now technically a parameter) can be used inside an <tt class="literal">&lt;xsl:for-each&gt;</tt> element. </p>
</div>
<a name="INDEX-887" /><a name="INDEX-888" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:when&gt;</i></b></font></td><td align="right"><i>Defines one branch of an &lt;xsl:choose&gt; element.  It is equivalent to the Java case statement.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Subinstruction (<tt class="literal">&lt;xsl:when&gt;</tt> always appears as a child of an <tt class="literal">&lt;xsl:choose&gt;</tt> element)</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

        <dt><i>test</i></dt>
        <dd>
        Contains a boolean expression that is evaluated.  If the expression evaluates to <tt class="literal">true</tt>, the contents of the <tt class="literal">&lt;xsl:when&gt;</tt> element are processed; otherwise, the contents of the <tt class="literal">&lt;xsl:when&gt;</tt> are ignored.</p>
      </dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<p>None.</p>

<h4 class="refsect1">Content</h4>
<p>An XSLT template.</p>

<h4 class="refsect1">Appears in</h4>
<p>The <tt class="literal">&lt;xsl:choose&gt;</tt> element only. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 9.2, Conditional Processing with <tt class="literal">xsl:choose</tt>.</p>

<h4 class="refsect1">Example</h4>
<p>This example uses an <tt class="literal">&lt;xsl:choose&gt;</tt> element and three <tt class="literal">&lt;xsl:when&gt;</tt> elements to cycle through a set of values.  Now we will generate rows of an HTML table for each <tt class="literal">&lt;listitem&gt;</tt>:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>In our stylesheet, we'll generate table rows with the background colors of <tt class="literal">mintcream</tt>, <tt class="literal">lavender</tt>, <tt class="literal">whitesmoke</tt>, and <tt class="literal">papayawhip</tt>.  For each <tt class="literal">&lt;listitem&gt;</tt> in our source document, one of the <tt class="literal">&lt;xsl:when&gt;</tt> elements (or the <tt class="literal">&lt;xsl:otherwise&gt;</tt> element) generates the appropriate color.</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;


  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:value-of select="list/title"/&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="list/title"/&gt;&lt;/h1&gt;
        &lt;table border="1"&gt;
          &lt;xsl:for-each select="list/listitem"&gt;
            &lt;tr&gt;
              &lt;td&gt;
                &lt;xsl:attribute name="bgcolor"&gt;
                  &lt;xsl:choose&gt;
                    &lt;xsl:when test="@bgcolor"&gt;
                      &lt;xsl:value-of select="@bgcolor"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 0"&gt;
                      &lt;xsl:text&gt;papayawhip&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 1"&gt;
                      &lt;xsl:text&gt;mintcream&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test="position() mod 4 = 2"&gt;
                      &lt;xsl:text&gt;lavender&lt;/xsl:text&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                      &lt;xsl:text&gt;whitesmoke&lt;/xsl:text&gt;
                    &lt;/xsl:otherwise&gt;
                  &lt;/xsl:choose&gt;
                &lt;/xsl:attribute&gt;
                &lt;xsl:value-of select="."/&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
      </pre></blockquote>

<p>When we process our XML source document with this stylesheet, here are the results:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Albums I've bought recently:&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Albums I've bought recently:&lt;/h1&gt;
&lt;table border="1"&gt;
&lt;tr&gt;
&lt;td bgcolor="mintcream"&gt;The Sacred Art of Dub&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="lavender"&gt;Only the Poor Man Feel It&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="whitesmoke"&gt;Excitable Boy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="papayawhip"&gt;Aki Special&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="mintcream"&gt;Combat Rock&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="lavender"&gt;Talking Timbuktu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="whitesmoke"&gt;The Birth of the Cool&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>All <tt class="literal">&lt;td&gt;</tt> elements with a background color of <tt class="literal">papayawhip</tt>, <tt class="literal">mintcream</tt>, or <tt class="literal">lavender</tt> were generated by one of the <tt class="literal">&lt;xsl:when&gt;</tt> elements.</p>
</div>
<a name="INDEX-889" /><a name="INDEX-890" /><a name="INDEX-891" /><a name="INDEX-892" /><a name="INDEX-893" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>&lt;xsl:with-param&gt;</i></b></font></td><td align="right"><i>Defines a parameter to be passed to a template. When the template is invoked, values can be passed in for the parameter.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Category</h4>
<p>Subinstruction (<tt class="literal">&lt;xsl:with-param&gt;</tt> always appears inside an <tt class="literal">&lt;xsl:apply-templates&gt;</tt> or <tt class="literal">&lt;xsl:call-template&gt;</tt> element)</p>

<h4 class="refsect1">Description</h4>
<p> <tt class="literal">&lt;xsl:with-param&gt;</tt> defines a parameter to be passed to a template. When the template is invoked, values can be passed in for the parameter. The value of the parameter can be defined in one of three ways:</p>
<ul>
        <li>
          <p>If the <tt class="literal">&lt;xsl:with-param&gt;</tt> element is empty and does not contain a <tt class="literal">select</tt> attribute, then no value is passed to the template.</p>
        </li>
        <li>
          <p>If the <tt class="literal">&lt;xsl:with-param&gt;</tt> element is empty and has a <tt class="literal">select</tt> attribute, the value of the parameter is the value of the <tt class="literal">select</tt> attribute.</p>
        </li>
        <li>
          <p>If the <tt class="literal">&lt;xsl:with-param&gt;</tt> element contains an XSLT template, the value of the parameter is the result of processing the template.</p>
        </li>
      </ul>
<p>If no value is passed to the template (<tt class="literal">&lt;xsl:with-param name="x"/&gt;</tt>), then the default value of the parameter, if any, is used instead. The default value of the parameter is defined on the <tt class="literal">&lt;xsl:param&gt;</tt> element inside the <tt class="literal">&lt;xsl:template&gt;</tt> itself; see the description of the <tt class="literal">&lt;xsl:param&gt;</tt> element for more details.</p>

<h4 class="refsect1">Required Attributes</h4>
<dl>

<dt><i>name</i></dt>
<dd>
Names this parameter.</p>
</dd>

</dl>

<h4 class="refsect1">Optional Attributes</h4>
<dl>

<dt><i>select</i></dt>
<dd>
An XPath expression that defines the value of this parameter. </p>
</dd>

</dl>

<h4 class="refsect1">Content</h4>
<p>The <tt class="literal">&lt;xsl:with-param&gt;</tt> element can be empty, or it can contain an XSLT template. If it contains an XSLT template, the value of the <tt class="literal">select</tt> attribute (if any exists) is ignored. </p>

<h4 class="refsect1">Appears in</h4>
<p>
<tt class="literal">&lt;xsl:apply-templates&gt;</tt> and <tt class="literal">&lt;xsl:call-template&gt;</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 11.6, Passing Parameters to Templates. </p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet with a number of parameters. Notice that some parameters are global and defined outside the stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:param name="favoriteNumber" select="23"/&gt;
  &lt;xsl:param name="favoriteColor"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="list/title"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:variable name="listitems" select="list/listitem"/&gt;
    &lt;xsl:call-template name="processListitems"&gt;
      &lt;xsl:with-param name="items" select="$listitems"/&gt;
      &lt;xsl:with-param name="color" select="'yellow'"/&gt;
      &lt;xsl:with-param name="number" select="$favoriteNumber"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="processListitems"&gt;
    &lt;xsl:param name="items"/&gt;
    &lt;xsl:param name="color" select="'blue'"/&gt;

    &lt;xsl:for-each select="$items"&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt;.  &lt;/xsl:text&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    
    &lt;xsl:text&gt;Your favorite color is &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$favoriteColor"/&gt;
    &lt;xsl:text&gt;.&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;The color passed to this template is &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$color"/&gt;
    &lt;xsl:text&gt;.&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll use this stylesheet to transform this document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>Our stylesheet contains two global parameters, <tt class="literal">favoriteNumber</tt> and <tt class="literal">favoriteColor</tt>, and defines a default value for <tt class="literal">favoriteNumber</tt>. The stylesheet also passes a parameter from the <tt class="literal">match="/"</tt> template to the <tt class="literal">name="processListitems"</tt> template; that parameter contains a node-set. Here are the results of the transformation:</p>
<blockquote><pre class="code">

Albums I've bought recently:
1.  The Sacred Art of Dub
2.  Only the Poor Man Feel It
3.  Excitable Boy
4.  Aki Special
5.  Combat Rock
6.  Talking Timbuktu
7.  The Birth of the Cool

Your favorite color is orange.
The color passed to this template is yellow.</pre></blockquote>
<p>To generate these results with Xalan, we use this command:</p>
<blockquote><pre class="code">
java org.apache.xalan.xslt.Process -in test4.xml -xsl with-param.xsl 
  -param favoriteColor orange</pre></blockquote>
<p>The command should appear on a single line. See <a href="ch04_04.htm">Section 4.4.3, "Global Parameters"</a> in <a href="ch04_01.htm">Chapter 4, "Branching and Control Elements"</a> for a complete discussion of global parameters and how you define them for various XSLT processors.
<a name="INDEX-890" />
<a name="INDEX-891" />
<a name="INDEX-892" />


</p>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch09_06.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="appb_01.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">9.6. Summary</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">B. XPath Reference</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
      </map>

</body></html>
