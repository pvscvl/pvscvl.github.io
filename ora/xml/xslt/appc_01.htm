<html><head><title>XSLT and XPath Function Reference (XSLT)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Doug Tidwell" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596000537L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="XSLT" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="XSLT" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="appb_06.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"></td><td align="right" valign="top" width="228"><a href="appd_01.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>



<h1 class="chapter">Appendix C. XSLT and XPath Function Reference</h1>
<p>
<a name="INDEX-935" />
<a name="INDEX-936" />
<a name="INDEX-937" />

This section lists all functions defined by XSLT and XPath.</p>


<a name="INDEX-938" /><a name="INDEX-939" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>boolean() Function</i></b></font></td><td align="right"><i>Converts its argument to a boolean value. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>boolean(</b></tt><em class="replaceable">object</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>An object. The object is converted to a boolean value. This conversion is described in the following subsection. </p>

<h4 class="refsect1">Output</h4>
<p>The boolean value corresponding to the input object. Objects are converted to boolean values as follows:</p>
<ul>
        <li>
          <p>A number is <tt class="literal">true</tt> if and only if it is not zero, negative zero, or <tt class="literal">NaN</tt> (not a number).</p>
        </li>
        <li>
          <p>A node-set is <tt class="literal">true</tt> if and only if it is not empty.</p>
        </li>
        <li>
          <p>A string is <tt class="literal">true</tt> if and only if its length is greater than zero.</p>
        </li>
        <li>
          <p>All other datatypes are converted in a way specific to those datatypes.</p>
        </li>
      </ul>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.3, Boolean Functions.</p>

<h4 class="refsect1">Example</h4>
<p>The following example demonstrates the results of invoking the <tt class="literal">boolean()</tt> function against a variety of argument types. Here's our XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;test&gt;
&lt;p&gt;This is a test XML document used by several 
of our sample stylesheets.&lt;/p&gt;
&lt;question&gt;
&lt;text&gt;When completed, the Eiffel Tower was the 
tallest building in the world.&lt;/text&gt;
&lt;true&gt;Yes!  The Eiffel Tower was the world's 
tallest building until 1932, when
New York's Empire State Building opened. &lt;/true&gt;
&lt;false&gt;No, the Eiffel Tower was the world's tallest 
building for over 30 years.&lt;/false&gt;
&lt;/question&gt;
&lt;/test&gt;</pre></blockquote>
<p>We'll process this document with the following stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the boolean() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="boolean(true())"&gt;
        &lt;xsl:text&gt;   "boolean(true())"   returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "boolean(true())"   returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="boolean(true)"&gt;

        &lt;xsl:text&gt;   "boolean(true)"     returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "boolean(true)"     returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="boolean('false')"&gt;
        &lt;xsl:text&gt;   "boolean('false')"  returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "boolean('false')"  returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="boolean('7')"&gt;
        &lt;xsl:text&gt;   "boolean('7')"      returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "boolean('7')"      returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="boolean(/true)"&gt;
        &lt;xsl:text&gt;   "boolean(/true)"    returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "boolean(/true)"    returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="boolean(//true)"&gt;
        &lt;xsl:text&gt;   "boolean(//true)"   returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "boolean(//true)"   returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results:</p>
<blockquote><pre class="code">

Tests of the boolean() function:

   "boolean(true())"   returned true!
   "boolean(true)"     returned false!
   "boolean('false')"  returned true!
   "boolean('7')"      returned true!
   "boolean(/true)"    returned false!
   "boolean(//true)"   returned true!
</pre></blockquote>
<p>See <a href="ch04_02.htm#xslt-CHP-4-SECT-2.1.2">Section 4.2.1.2, "Boolean examples"</a> in <a href="ch04_01.htm">Chapter 4, "Branching and Control Elements"</a> for more examples and information.</p>
</div>
<a name="INDEX-940" /><a name="INDEX-941" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>ceiling() Function</i></b></font></td><td align="right"><i>Returns the smallest integer that is not less than the argument. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>ceiling(</b></tt><em class="replaceable">number</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>A number. If the argument is not a number, it is transformed into a number as if it had been processed by the <tt class="literal">number()</tt> function. If the argument cannot be transformed into a number, the <tt class="literal">ceiling()</tt> function returns the value <tt class="literal">NaN</tt> (not a number).</p>

<h4 class="refsect1">Output</h4>
<p>The smallest integer that is not less than the argument, or <tt class="literal">NaN</tt> if the argument cannot be converted to a number.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.4, Number Functions.</p>

<h4 class="refsect1">Example</h4>
<p>The following stylesheet shows the results of invoking the <tt class="literal">ceiling()</tt> function against a variety of values. We'll use this XML document as input:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>Here's the stylesheet that uses the <tt class="literal">ceiling()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;
  &lt;months:name sequence="05"&gt;May&lt;/months:name&gt;
  &lt;months:name sequence="06"&gt;June&lt;/months:name&gt;
  &lt;months:name sequence="07"&gt;July&lt;/months:name&gt;
  &lt;months:name sequence="08"&gt;August&lt;/months:name&gt;
  &lt;months:name sequence="09"&gt;September&lt;/months:name&gt;
  &lt;months:name sequence="10"&gt;October&lt;/months:name&gt;
  &lt;months:name sequence="11"&gt;November&lt;/months:name&gt;
  &lt;months:name sequence="12"&gt;December&lt;/months:name&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the ceiling() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "ceiling('7.983')" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="ceiling('7.983')"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "ceiling('-7.893')" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="ceiling('-7.893')"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "ceiling(/report/month[@sequence='01']/miles-flown)" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="ceiling(/report/month[@sequence='01']/miles-flown)"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "ceiling(document('')/*/&lt;/xsl:text&gt;
    &lt;xsl:text&gt;months:name[@sequence='02'])" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="ceiling(document('')/*/months:name[@sequence='02'])"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="/report/month"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="document('')/*/months:name[@sequence=current()/@sequence]"/&gt;
      &lt;xsl:text&gt; - &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-flown, '##,###')"/&gt;
      &lt;xsl:text&gt; miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-earned, '##,###')"/&gt;
      &lt;xsl:text&gt; miles earned.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:text&gt;      (Averaged &lt;/xsl:text&gt;
      &lt;xsl:value-of select="ceiling(miles-earned div miles-flown)"/&gt;
      &lt;xsl:text&gt; miles earned for each mile flown.)&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When we transform the XML document with our stylesheet, here are the results:</p>
<blockquote><pre class="code">

Tests of the ceiling() function:

   "ceiling('7.983')" = 8
   "ceiling('-7.893')" = -7
   "ceiling(/report/month[@sequence='01']/miles-flown)" = 12379
   "ceiling(document('')/*/months:name[@sequence='02'])" = NaN

   January - 12,379 miles flown, 35,215 miles earned.
      (Averaged 3 miles earned for each mile flown.)

   February - 32,857 miles flown, 92,731 miles earned.
      (Averaged 3 miles earned for each mile flown.)

   March - 19,920 miles flown, 76,725 miles earned.
      (Averaged 4 miles earned for each mile flown.)

   April - 18,903 miles flown, 31,781 miles earned.
      (Averaged 2 miles earned for each mile flown.)

</pre></blockquote>

<p>Notice that when we invoked the <tt class="literal">ceiling()</tt> function against the string "February" (what <tt class="literal">document('')/*/months:name[@sequence='02']</tt> resolves to), the function returned <tt class="literal">NaN</tt>. You can compare these results to those from the <tt class="literal">floor()</tt> function and the <tt class="literal">round()</tt> function. </p>
</div>
<a name="INDEX-942" /><a name="INDEX-943" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>concat() Function</i></b></font></td><td align="right"><i>Takes all of its arguments and concatenates them. Any arguments that are not strings are converted to strings as if processed by the string() function. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table>
<h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>concat(</b></tt><em class="replaceable">string</em><em class="replaceable">string</em><em class="replaceable">string*</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
<h4 class="refsect1">Inputs</h4>
<p>Two or more strings.</p>

<h4 class="refsect1">Output</h4>
<p>The concatenation of all of the input strings.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions.</p>

<h4 class="refsect1">Example</h4>
<p>We'll use this XML file to demonstrate how <tt class="literal">concat()</tt> works:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>In our stylesheet, we'll use the <tt class="literal">concat()</tt> function to create filenames for various JPEG files. The filenames are composed from several pieces of information, concatenated by the <tt class="literal">concat()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="list/listitem"&gt;
      &lt;xsl:text&gt;See the file &lt;/xsl:text&gt;
      &lt;xsl:value-of select="concat('album', position(), '.jpg')"/&gt;
      &lt;xsl:text&gt; to see the title of album #&lt;/xsl:text&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Our stylesheet generates these results:</p>
<blockquote><pre class="code">

See the file album1.jpg to see the title of album #1
See the file album2.jpg to see the title of album #2
See the file album3.jpg to see the title of album #3
See the file album4.jpg to see the title of album #4
See the file album5.jpg to see the title of album #5
See the file album6.jpg to see the title of album #6
See the file album7.jpg to see the title of album #7
See the file album8.jpg to see the title of album #8
</pre></blockquote>
</div>
<a name="INDEX-944" /><a name="INDEX-945" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>contains() Function</i></b></font></td><td align="right"><i>Determines if the first argument string contains the second.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>contains(</b></tt><em class="replaceable">string</em><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>Two strings. If the first string contains the second string, the function returns the boolean value <tt class="literal">true</tt>.</p>

<h4 class="refsect1">Output</h4>
<p>The boolean value <tt class="literal">true</tt> if the first argument contains the second; <tt class="literal">false</tt> otherwise. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions. </p>

<h4 class="refsect1">Example</h4>
<p>This stylesheet uses the <tt class="literal">replace-substring</tt> named template. It passes three arguments to the <tt class="literal">replace-substring</tt> template: the original string, the substring to be searched for in the original string, and the substring to replace the target substring in the original string. The <tt class="literal">replace-substring</tt> template uses the <tt class="literal">contains()</tt>, <tt class="literal">substring-after()</tt>, and <tt class="literal">substring-before()</tt> functions extensively. </p>
<p>Here is our sample stylesheet. It replaces all occurrences of <tt class="literal">World</tt> with the string "Mundo":</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:variable name="test"&gt;
      &lt;xsl:call-template name="replace-substring"&gt;
        &lt;xsl:with-param name="original"&gt;Hello World!&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="substring"&gt;World&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="replacement"&gt;Mundo&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:value-of select="$test"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="replace-substring"&gt;
    &lt;xsl:param name="original"/&gt;
    &lt;xsl:param name="substring"/&gt;
    &lt;xsl:param name="replacement" select="''"/&gt;
    &lt;xsl:variable name="first"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:value-of select="substring-before($original, $substring)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$original"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:variable name="middle"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:value-of select="$replacement"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:text&gt;&lt;/xsl:text&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:variable name="last"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:choose&gt;
            &lt;xsl:when test="contains(substring-after($original, 
                                        $substring), $substring)"&gt;
              &lt;xsl:call-template name="replace-substring"&gt;
                &lt;xsl:with-param name="original"&gt;
                  &lt;xsl:value-of 
                    select="substring-after($original, $substring)"/&gt;
                &lt;/xsl:with-param&gt;
                &lt;xsl:with-param name="substring"&gt;
                  &lt;xsl:value-of select="$substring"/&gt;
                &lt;/xsl:with-param&gt;
                &lt;xsl:with-param name="replacement"&gt;
                  &lt;xsl:value-of select="$replacement"/&gt;
                &lt;/xsl:with-param&gt;
              &lt;/xsl:call-template&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
              &lt;xsl:value-of 
                select="substring-after($original, $substring)"/&gt;
            &lt;/xsl:otherwise&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:text&gt;&lt;/xsl:text&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:value-of select="concat($first, $middle, $last)"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>The stylesheet produces these results, regardless of the XML document used as input:</p>
<blockquote><pre class="code">
Hello Mundo!
</pre></blockquote>
</div>
<a name="INDEX-946" /><a name="INDEX-947" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>count() Function</i></b></font></td><td align="right"><i>Counts the number of nodes in a given node-set.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>count(</b></tt><em class="replaceable">node-set</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>A node-set.</p>

<h4 class="refsect1">Output</h4>
<p>The number of nodes in the node-set. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.1, Node Set Functions.</p>

<h4 class="refsect1">Examples</h4>
<p>Here's the XML document we'll use to illustrate the <tt class="literal">count()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;test&gt;
  &lt;p&gt;This is a test XML document used by 
  several of our sample stylesheets.&lt;/p&gt;
  &lt;question&gt;
    &lt;text&gt;When completed, the Eiffel Tower was the 
    tallest building in the world.&lt;/text&gt;
    &lt;true&gt;You're correct!  The Eiffel Tower was the 
    world's tallest building until 1930.&lt;/true&gt;
    &lt;false&gt;No, the Eiffel Tower was the world's 
    tallest building for over 30 years.&lt;/false&gt;
  &lt;/question&gt;
  &lt;question&gt;
    &lt;text&gt;New York's Empire State Building knocked 
    the Eiffel Tower from its pedestal.&lt;/text&gt;
    &lt;true&gt;No, that's not correct.&lt;/true&gt;
    &lt;false&gt;Correct!  New York's Chrysler Building, 
    completed in 1930, became the world's tallest.&lt;/false&gt;
  &lt;/question&gt;
&lt;/test&gt;</pre></blockquote>
<p>Here's a stylesheet that illustrates the <tt class="literal">count()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the count() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   count(/test)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(/test)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   count(/true)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(/true)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   count(//true)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(//true)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   count(//test|//true|//text)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(//test|//true|//text)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:variable name="numberOfQuestions" select="count(/test/question)"/&gt;
    &lt;xsl:for-each select="/test/question"&gt;
      &lt;xsl:text&gt;   This is question number &lt;/xsl:text&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt; of &lt;/xsl:text&gt;
      &lt;xsl:value-of select="$numberOfQuestions"/&gt;

      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results of our stylesheet:</p>
<blockquote><pre class="code">

Tests of the count() function:

   count(/test)=1
   count(/true)=0
   count(//true)=2
   count(//test|//true|//text)=5
   This is question number 1 of 2
   This is question number 2 of 2
</pre></blockquote>
<p>The first four invocations of the <tt class="literal">count()</tt> function merely use XPath expressions to count something in the XML document. The last use of <tt class="literal">count()</tt> counts the number of <tt class="literal">&lt;question&gt;</tt> elements in our document and stores that value in a variable. Generating text like "item x of y" is a common technique; our use of the <tt class="literal">count()</tt> and <tt class="literal">position()</tt> is how this generation is commonly done.</p>
</div>
<a name="INDEX-948" /><a name="INDEX-949" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>current() Function</i></b></font></td><td align="right"><i>Returns a node-set that has the current node as its only member. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>node-set <tt class="userinput"><b>current(</b></tt><tt class="userinput"><b>)</b></tt></pre></tt></p>

        
      

<h4 class="refsect1">Inputs</h4>
<p>None. </p>

<h4 class="refsect1">Output</h4>
<p>A node-set that has the current node as its only member. Most of the time, the current node is no different than the context node. These two XSLT elements have the same meaning:</p>
<blockquote><pre class="code">
&lt;xsl:value-of select="current()"/&gt;
&lt;xsl:value-of select="."/&gt;</pre></blockquote>
<p>Within a predicate expression, however, the current node and the context node are usually different. The example section that follows illustrates when you need to use the <tt class="literal">current()</tt> function.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.4, Miscellaneous Additional Functions.</p>

<h4 class="refsect1">Example</h4>

<p>We'll use the <tt class="literal">current()</tt> function along with a lookup table. Here's the document we'll transform:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>Here's our stylesheet. We'll do the same transform twice, one time with the <tt class="literal">current()</tt> function and one time without it:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;months:name sequence="12"&gt;December&lt;/months:name&gt;
  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;
  &lt;months:name sequence="05"&gt;May&lt;/months:name&gt;
  &lt;months:name sequence="06"&gt;June&lt;/months:name&gt;
  &lt;months:name sequence="07"&gt;July&lt;/months:name&gt;
  &lt;months:name sequence="08"&gt;August&lt;/months:name&gt;
  &lt;months:name sequence="09"&gt;September&lt;/months:name&gt;
  &lt;months:name sequence="10"&gt;October&lt;/months:name&gt;
  &lt;months:name sequence="11"&gt;November&lt;/months:name&gt;

  &lt;xsl:output method="text"/&gt;


  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the current() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="/report/month"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="document('')/*/months:name[@sequence=current()/@sequence]"/&gt;
      &lt;xsl:text&gt; - &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-flown, '##,###')"/&gt;
      &lt;xsl:text&gt; miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-earned, '##,###')"/&gt;
      &lt;xsl:text&gt; miles earned.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:text&gt;      (Averaged &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="format-number(miles-earned div miles-flown, '##.#')"/&gt;
      &lt;xsl:text&gt; miles earned for each mile flown.)&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;

    &lt;xsl:text&gt;Let's try it again, without using current() this time:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;

    &lt;xsl:for-each select="/report/month"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="document('')/*/months:name[@sequence=./@sequence]"/&gt;
      &lt;xsl:text&gt; - &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-flown, '##,###')"/&gt;
      &lt;xsl:text&gt; miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-earned, '##,###')"/&gt;
      &lt;xsl:text&gt; miles earned.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:text&gt;      (Averaged &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="format-number(miles-earned div miles-flown, '##.#')"/&gt;
      &lt;xsl:text&gt; miles earned for each mile flown.)&lt;/xsl:text&gt;

      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results:</p>
<blockquote><pre class="code">

A test of the current() function:

   January - 12,379 miles flown, 35,215 miles earned.
      (Averaged 2.8 miles earned for each mile flown.)

   February - 32,857 miles flown, 92,731 miles earned.
      (Averaged 2.8 miles earned for each mile flown.)

   March - 19,920 miles flown, 76,725 miles earned.
      (Averaged 3.9 miles earned for each mile flown.)

   April - 18,903 miles flown, 31,781 miles earned.
      (Averaged 1.7 miles earned for each mile flown.)


Let's try it again, without using current() this time:

   December - 12,379 miles flown, 35,215 miles earned.
      (Averaged 2.8 miles earned for each mile flown.)

   December - 32,857 miles flown, 92,731 miles earned.
      (Averaged 2.8 miles earned for each mile flown.)

   December - 19,920 miles flown, 76,725 miles earned.
      (Averaged 3.9 miles earned for each mile flown.)

   December - 18,903 miles flown, 31,781 miles earned.
      (Averaged 1.7 miles earned for each mile flown.)
</pre></blockquote>
<p>The second time around, our stylesheet matched each <tt class="literal">&lt;month&gt;</tt> element to the month <tt class="literal">December</tt>. The difference is that the dot syntax (<tt class="literal">.</tt>) represents the current node at that point in the XPath expression, while the <tt class="literal">current()</tt> function represents the current node before the XSLT processor began evaluating the XPath expression. </p>
<p>In other words, the XSLT processor starts with the first <tt class="literal">&lt;months:name&gt;</tt> element, attempting to find the element whose <tt class="literal">sequence</tt> attribute matches another <tt class="literal">sequence</tt> attribute we're examining. If we specify the other <tt class="literal">sequence</tt> attribute with <tt class="literal">./@sequence</tt>, it indicates the <tt class="literal">sequence</tt> attribute of the current node at this point in the expression, which is the first <tt class="literal">&lt;months:name&gt;</tt> element. That always returns the value of the first <tt class="literal">&lt;months:name&gt;</tt> element. Using the <tt class="literal">current()</tt> function, on the other hand, returns the node that was current when we started to evaluate this expression; <tt class="literal">current()</tt> gives us the behavior we want. </p>
</div>
<a name="INDEX-950" /><a name="INDEX-951" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>document() Function</i></b></font></td><td align="right"><i>Allows you to process multiple source documents in a single stylesheet. This extremely powerful and flexible function is the subject of , so we'll only include a brief overview of the function here.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>node-set <tt class="userinput"><b>document(</b></tt><em class="replaceable">object</em><em class="replaceable">node-set?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>The <tt class="literal">document()</tt> function most commonly takes a
      string as its argument; that string is treated as a URI, and the
      XSLT processor attempts to open that URI and parse it. If the
      string is empty (the function call is
      <tt class="literal">document('')</tt>), the
      <tt class="literal">document()</tt> function parses the stylesheet
      itself. See <a href="ch07_03.htm">Section 7.3, "Invoking the document() Function"</a> in <a href="ch07_01.htm">Chapter 7, "Combining XML Documents"</a> for all the details on the parameters to the <tt class="literal">document()</tt> function. </p>

<h4 class="refsect1">Output</h4>
<p>A node-set containing the nodes identified by the input argument. Again, <a href="ch07_01.htm">Chapter 7, "Combining XML Documents"</a> has all the details, so we won't rehash them here.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.1, Multiple Source Documents.</p>

<h4 class="refsect1">Example</h4>
<p>The following example uses the <tt class="literal">document()</tt> function with an empty string to implement a lookup table. Here is our XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>We can use the <tt class="literal">document()</tt> function to convert the <tt class="literal">sequence</tt> attribute of the <tt class="literal">&lt;month&gt;</tt> element into the name of the corresponding month. Here is our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;
  &lt;months:name sequence="05"&gt;May&lt;/months:name&gt;
  &lt;months:name sequence="06"&gt;June&lt;/months:name&gt;
  &lt;months:name sequence="07"&gt;July&lt;/months:name&gt;
  &lt;months:name sequence="08"&gt;August&lt;/months:name&gt;
  &lt;months:name sequence="09"&gt;September&lt;/months:name&gt;
  &lt;months:name sequence="10"&gt;October&lt;/months:name&gt;
  &lt;months:name sequence="11"&gt;November&lt;/months:name&gt;
  &lt;months:name sequence="12"&gt;December&lt;/months:name&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the document() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="/report/month"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="document('')/*/months:name[@sequence=current()/@sequence]"/&gt;
      &lt;xsl:text&gt; - &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-flown, '##,###')"/&gt;
      &lt;xsl:text&gt; miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-earned, '##,###')"/&gt;
      &lt;xsl:text&gt; miles earned.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:text&gt;      (Averaged &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="format-number(miles-earned div miles-flown, '##.#')"/&gt;
      &lt;xsl:text&gt; miles earned for each mile flown.)&lt;/xsl:text&gt;

      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results, with the correct month names included in the output:</p>
<blockquote><pre class="code">

A test of the document() function:

   January - 12,379 miles flown, 35,215 miles earned.
      (Averaged 2.8 miles earned for each mile flown.)

   February - 32,857 miles flown, 92,731 miles earned.
      (Averaged 2.8 miles earned for each mile flown.)

   March - 19,920 miles flown, 76,725 miles earned.
      (Averaged 3.9 miles earned for each mile flown.)

   April - 18,903 miles flown, 31,781 miles earned.
      (Averaged 1.7 miles earned for each mile flown.)
</pre></blockquote>
</div>
<a name="INDEX-952" /><a name="INDEX-953" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>element-available() Function</i></b></font></td><td align="right"><i>Determines if a given element is available to the XSLT processor. This function allows you to design stylesheets that react gracefully if a particular element is not available to process an XML document. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>element-available(</b></tt><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>The element's name. The name should be qualified with a namespace; if the namespace URI is the same as the XSLT namespace URI, then the element name refers to an element defined by XSLT. Otherwise, the name refers to an extension element. If the element name has a null namespace URI, then the <tt class="literal">element-available</tt> function returns <tt class="literal">false</tt>. </p>

<h4 class="refsect1">Output</h4>
<p>The boolean value <tt class="literal">true</tt> if the element is available; <tt class="literal">false</tt> otherwise. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 15, Fallback.</p>

<h4 class="refsect1">Example</h4>
<p>We'll use the following example to test the <tt class="literal">element-available()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;book&gt;
  &lt;title&gt;XSLT&lt;/title&gt;
  &lt;chapter&gt;
    &lt;title&gt;Getting Started&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;The Hello World Example&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;XPath&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Stylesheet Basics&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Branching and Control Elements&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Functions&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Creating Links and Cross-References&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Sorting and Grouping Elements&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
  &lt;chapter&gt;
    &lt;title&gt;Combining XML Documents&lt;/title&gt;
    &lt;para&gt;If this chapter had any text, it would appear here.&lt;/para&gt;
  &lt;/chapter&gt;
&lt;/book&gt;</pre></blockquote>
<p>Here is our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:redirect="org.apache.xalan.xslt.extensions.Redirect"

  xmlns:saxon="http://icl.com/saxon"
  extension-element-prefixes="redirect saxon"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="element-available('redirect:write')"&gt;
        &lt;xsl:for-each select="/book/chapter"&gt;
          &lt;redirect:write select="concat('chapter', position(), '.html')"&gt;
            &lt;html&gt;
              &lt;head&gt;
                &lt;title&gt;&lt;xsl:value-of select="title"/&gt;&lt;/title&gt;
              &lt;/head&gt;
              &lt;body&gt;
                &lt;h1&gt;&lt;xsl:value-of select="title"/&gt;&lt;/h1&gt;
                &lt;xsl:apply-templates select="para"/&gt;
                &lt;xsl:if test="not(position()=1)"&gt;
                  &lt;p&gt;
                    &lt;a href="chapter{position()-1}.html"&gt;Previous&lt;/a&gt;
                  &lt;/p&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:if test="not(position()=last())"&gt;
                  &lt;p&gt;
                    &lt;a href="chapter{position()+1}.html"&gt;Next&lt;/a&gt;
                  &lt;/p&gt;
                &lt;/xsl:if&gt;
              &lt;/body&gt;
            &lt;/html&gt;
          &lt;/redirect:write&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="element-available('saxon:output')"&gt;
        &lt;xsl:for-each select="/book/chapter"&gt;
          &lt;saxon:output file="chapter{position()}.html"&gt;
            &lt;html&gt;
              &lt;head&gt;
                &lt;title&gt;&lt;xsl:value-of select="title"/&gt;&lt;/title&gt;
              &lt;/head&gt;
              &lt;body&gt;
                &lt;h1&gt;&lt;xsl:value-of select="title"/&gt;&lt;/h1&gt;
                &lt;xsl:apply-templates select="para"/&gt;
                &lt;xsl:if test="not(position()=1)"&gt;
                  &lt;p&gt;
                    &lt;a href="chapter{position()-1}.html"&gt;Previous&lt;/a&gt;
                  &lt;/p&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:if test="not(position()=last())"&gt;

                  &lt;p&gt;
                    &lt;a href="chapter{position()+1}.html"&gt;Next&lt;/a&gt;
                  &lt;/p&gt;
                &lt;/xsl:if&gt;
              &lt;/body&gt;
            &lt;/html&gt;
          &lt;/saxon:output&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;&lt;xsl:value-of select="/book/title"/&gt;&lt;/title&gt;
          &lt;/head&gt;
          &lt;xsl:for-each select="/book/chapter"&gt;
            &lt;h1&gt;&lt;xsl:value-of select="title"/&gt;&lt;/h1&gt;
            &lt;xsl:apply-templates select="para"/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/html&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:if test="not(element-available('write'))"&gt;
      &lt;xsl:message terminate="no"&gt;
        The &lt;write&gt; element is not available!
      &lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="para"&gt;
    &lt;p&gt;&lt;xsl:apply-templates select="*|text()"/&gt;&lt;/p&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>This stylesheet attempts to take the content in the XML file and write portions of it out to different HTML files. The first <tt class="literal">&lt;chapter&gt;</tt> element is written to the file <em class="filename">chapter1.html</em>, the second <tt class="literal">&lt;chapter&gt;</tt> element is written to the file <em class="filename">chapter2.html</em>, and so on. Our stylesheet attempts to use Xalan's <tt class="literal">&lt;redirect:write&gt;</tt> element first; if that element is not available, it checks for Saxon's <tt class="literal">&lt;saxon:output&gt;</tt> element. If neither of those elements is available, it writes the contents of all <tt class="literal">&lt;chapter&gt;</tt> elements to the same output stream. The stylesheet also calls the <tt class="literal">element-available()</tt> function with the nonqualified element name <tt class="literal">write</tt>; this call always returns <tt class="literal">false</tt> because the element name is not namespace qualified. </p>
<p>When we use Xalan to process the XML file with our stylesheet, here are the results on the console:</p>
<blockquote><pre class="code">
file:///D:/O'Reilly/XSLT/bookSamples/AppendixC/elementavailable.xsl; Line 66; 
Column 35; The &lt;write&gt; element is not available!</pre></blockquote>

<p>The stylesheet generates the files <em class="filename">chapter1.html</em> through <em class="filename">chapter9.html</em>, with each file containing data from one of the <tt class="literal">&lt;chapter&gt;</tt> elements in the original file. Our stylesheet also generates hyperlinks between the chapter files; here's what <em class="filename">chapter3.html</em> looks like:</p>
<blockquote><pre class="code">
&lt;html&gt;
   &lt;head&gt;
      &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
   
      &lt;title&gt;XPath&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;h1&gt;XPath&lt;/h1&gt;
      &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
      &lt;p&gt;&lt;a href="chapter2.html"&gt;Previous&lt;/a&gt;&lt;/p&gt;
      &lt;p&gt;&lt;a href="chapter4.html"&gt;Next&lt;/a&gt;&lt;/p&gt;
   &lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>When rendered in a browser, the file looks like <a href="appc_01.htm">Figure C-1</a>.</p>
<a name="xslt-appc-c1" /><div class="figure"><img height="205" alt="Figure C-1" src="figs/xslt.ac01.gif" width="386" /></div><h4 class="objtitle">Figure C-1. Sample HTML output file</h4>
<p>Clicking on the Previous link takes you to the file <em class="filename">chapter2.html</em>, while clicking on the Next link takes you to <em class="filename">chapter4.html</em>.</p>
<p>Using our stylesheet with Saxon (using the command <tt class="literal">java com.icl.saxon.StyleSheet chapterlist.xml elementavailable.xsl</tt>) produces similar results on the console:</p>
<blockquote><pre class="code">
The &lt;write&gt; element is not available!</pre></blockquote>
<p>Although the format of the message is slightly different, the output in the multiple HTML files is the same. </p>

<p>Finally, if we use the Oracle XML parser, none of the elements we query will be available, so all the output is written to a single file. We'll invoke the processor with this command. (The command should be on one line.)</p>
<blockquote><pre class="code">
java oracle.xml.parser.v2.oraxsl chapterlist.xml 
  elementavailable.xsl chapters.html</pre></blockquote>
<p>Here's the console output:</p>
<blockquote><pre class="code">
Message: The &lt;write&gt; element is not available!</pre></blockquote>
<p>The output file, <em class="filename">chapters.html</em>, looks like this:</p>
<blockquote><pre class="code">
&lt;html xmlns:redirect="org.apache.xalan.xslt.extensions.Redirect" 
  xmlns:saxon="http://icl.com/saxon"&gt;
   &lt;head&gt;
      &lt;META http-equiv="Content-Type" content="text/html"&gt;
      &lt;title&gt;XSLT&lt;/title&gt;
   &lt;/head&gt;
   &lt;h1&gt;Getting Started&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
   &lt;h1&gt;The Hello World Example&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
   &lt;h1&gt;XPath&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
   &lt;h1&gt;Stylesheet Basics&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
   &lt;h1&gt;Branching and Control Elements&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
   &lt;h1&gt;Functions&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
   &lt;h1&gt;Creating Links and Cross-References&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
   &lt;h1&gt;Sorting and Grouping Elements&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
   &lt;h1&gt;Combining XML Documents&lt;/h1&gt;
   &lt;p&gt;If this chapter had any text, it would appear here.&lt;/p&gt;
&lt;/html&gt;</pre></blockquote>
<p>When rendered, our output looks like <a href="appc_01.htm">Figure C-2</a>.</p>
<a name="xslt-appc-c2" /><div class="figure"><img height="361" alt="Figure C-2" src="figs/xslt.ac02.gif" width="386" /></div><h4 class="objtitle">Figure C-2. HTML document listing all chapters</h4>
<p>In this example, the <tt class="literal">element-available()</tt> function allows us to determine what processing capabilities are available and respond gracefully to whatever we find. </p>
</div>
<a name="INDEX-954" /><a name="INDEX-955" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>false() Function</i></b></font></td><td align="right"><i>Always returns the boolean value false. Remember that the strings "true" and "false" don't have any special significance in XSLT. This function (and the true() function) allow you to generate boolean values directly when you need them. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>false(</b></tt><tt class="userinput"><b>)</b></tt></pre></tt></p>

        
      

<h4 class="refsect1">Inputs</h4>
<p>None.</p>

<h4 class="refsect1">Output</h4>
<p>The boolean value <tt class="literal">false</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.3, Boolean Functions.</p>

<h4 class="refsect1">Example</h4>
<p>Here's a brief example that uses the <tt class="literal">false()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;


  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the false() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="false()"&gt;
        &lt;xsl:text&gt;   "false()"   returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "false()"   returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When using this stylesheet against any XML document, it generates this less-than-exciting result:</p>
<blockquote><pre class="code">

A test of the false() function:

   "false()"   returned false!
</pre></blockquote>
</div>
<a name="INDEX-956" /><a name="INDEX-957" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>floor() Function</i></b></font></td><td align="right"><i>Returns the largest integer that is not greater than the argument. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>floor(</b></tt><em class="replaceable">number</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>A number. If the argument is not a number, it is transformed into a number as if it had been processed by the <tt class="literal">number()</tt> function. If the argument cannot be transformed into a number, the <tt class="literal">floor()</tt> function returns <tt class="literal">NaN</tt> (not a number).</p>

<h4 class="refsect1">Output</h4>
<p>The largest integer that is not greater than the argument, or <tt class="literal">NaN</tt> if the argument cannot be converted into a number. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.4, Number Functions. </p>

<h4 class="refsect1">Example</h4>
<p>The following stylesheet shows the results of invoking the <tt class="literal">floor()</tt> function against a variety of values. We'll use this XML document as input:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>Here's the stylesheet that uses the <tt class="literal">floor()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;
  &lt;months:name sequence="05"&gt;May&lt;/months:name&gt;
  &lt;months:name sequence="06"&gt;June&lt;/months:name&gt;
  &lt;months:name sequence="07"&gt;July&lt;/months:name&gt;
  &lt;months:name sequence="08"&gt;August&lt;/months:name&gt;
  &lt;months:name sequence="09"&gt;September&lt;/months:name&gt;
  &lt;months:name sequence="10"&gt;October&lt;/months:name&gt;
  &lt;months:name sequence="11"&gt;November&lt;/months:name&gt;
  &lt;months:name sequence="12"&gt;December&lt;/months:name&gt;

  &lt;xsl:output method="text"/&gt;


  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the floor() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "floor('7.983')" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="floor('7.983')"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "floor('-7.893')" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="floor('-7.893')"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "floor(/report/month[@sequence='01']&lt;/xsl:text&gt;
    &lt;xsl:text&gt;/miles-flown)" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="floor(/report/month[@sequence='01']/miles-flown)"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "floor(document('')/*/months:name&lt;/xsl:text&gt;
    &lt;xsl:text&gt;[@sequence='02'])" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="floor(document('')/*/months:name[@sequence='02'])"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="/report/month"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="document('')/*/months:name[@sequence=current()/@sequence]"/&gt;
      &lt;xsl:text&gt; - &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-flown, '##,###')"/&gt;
      &lt;xsl:text&gt; miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-earned, '##,###')"/&gt;
      &lt;xsl:text&gt; miles earned.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:text&gt;      (Averaged &lt;/xsl:text&gt;
      &lt;xsl:value-of select="floor(miles-earned div miles-flown)"/&gt;
      &lt;xsl:text&gt; miles earned for each mile flown.)&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here is the output of our stylesheet:</p>
<blockquote><pre class="code">

Tests of the floor() function:

   "floor('7.983')" = 7
   "floor('-7.893')" = -8
   "floor(/report/month[@sequence='01']/miles-flown)" = 12379
   "floor(document('')/*/months:name[@sequence='02'])" = NaN

   January - 12,379 miles flown, 35,215 miles earned.
      (Averaged 2 miles earned for each mile flown.)

   February - 32,857 miles flown, 92,731 miles earned.
      (Averaged 2 miles earned for each mile flown.)

   March - 19,920 miles flown, 76,725 miles earned.
      (Averaged 3 miles earned for each mile flown.)

   April - 18,903 miles flown, 31,781 miles earned.
      (Averaged 1 miles earned for each mile flown.)
</pre></blockquote>
<p>Notice that when we invoked the <tt class="literal">ceiling()</tt> function against the string "February" (that's what <tt class="literal">document('')/*/months:name[@sequence='02']</tt> resolves to), the function returned <tt class="literal">NaN</tt>. You can compare these results to those from the <tt class="literal">ceiling()</tt> function and the <tt class="literal">round()</tt> function. </p>
</div>
<a name="INDEX-958" /><a name="INDEX-959" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>format-number() Function</i></b></font></td><td align="right"><i>Takes a number and formats it as a string. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>format-number(</b></tt><em class="replaceable">number</em><em class="replaceable">string</em><em class="replaceable">string?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>The number to be formatted and the format pattern string are required. The third argument is the optional name of a decimal format; if the third argument is not supplied, the default decimal format is used. </p>

<h4 class="refsect1">Output</h4>
<p>The number, formatted according to the rules supplied by the other arguments. The special characters used in the second argument are:</p>
<dl>
        
          <dt><b>
<tt class="literal">#</tt>
</b></dt>
          <dd>
            Represents a digit. Trailing or leading zeroes are not displayed. Formatting the number <tt class="literal">4.0</tt> with the string "#.##" returns the string "4". </p>
          </dd>
        
        
          <dt><b>
<tt class="literal">0</tt>
</b></dt>
          <dd>
            Represents a digit. Unlike the <tt class="literal">#</tt> character, the <tt class="literal">0</tt> always displays a zero. Formatting the number <tt class="literal">4.1</tt> with the string "#.00" returns the string "4.10".</p>
          </dd>
        
        
          <dt><b>
<tt class="literal">.</tt>
</b></dt>
          <dd>
            Represents the decimal point. </p>
          </dd>
        
        
          <dt><b>
<tt class="literal">-</tt>
</b></dt>
          <dd>
            Represents the minus sign.</p>
          </dd>
        
        
          <dt><b>
<tt class="literal">,</tt>
</b></dt>
          <dd>
            Is the grouping separator.</p>
          </dd>
        
        
          <dt><b>
<tt class="literal">;</tt>
</b></dt>
          <dd>
            Separates the positive-number pattern from the negative-number pattern. </p>
          </dd>
        
        
          <dt><b>
<tt class="literal">%</tt>
</b></dt>
          <dd>
            Indicates that a number should be displayed as a percentage. The value will be multiplied by 100, then displayed as a percentage. Formatting the number <tt class="literal">.76</tt> with the string "##%" returns the string "76%".</p>
          </dd>
        
        
          <dt><b>
<tt class="literal">\u2030</tt>
</b></dt>
          <dd>
            Is the Unicode character for the per-thousand (per-mille) sign. The value will be multiplied by 1000, then displayed as a per mille. Formatting the number <tt class="literal">.768</tt> with the string "###\u2030" returns the string "768<img height="23" alt="Figure C.11" src="figs/U2030.gif" width="18" />".</p>
          </dd>
        
      </dl>
<p>The third argument, if given, must be the name of an <tt class="literal">&lt;xsl:decimal-format&gt;</tt> element. The <tt class="literal">&lt;xsl:decimal-format&gt;</tt> element lets you define the character that should be used for the decimal point and the grouping separator, the string used to represent infinity, and other formatting options. See <a href="appa_01.htm">Reference A.10</a> for more information.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.3, Number Formatting.</p>

<h4 class="refsect1">Example</h4>
<p>The following stylesheet uses the <tt class="literal">format-number()</tt> function in various ways:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;


  &lt;xsl:decimal-format name="f1"
    decimal-separator=":"
    grouping-separator="/"/&gt;

  &lt;xsl:decimal-format name="f2"
    infinity="Really, really big"
    NaN="[not a number]"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the format-number() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(528.3, '#.#;-#.#')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(528.3, '#.#;-#.#')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(528.3, '0,000.00;-0,000.00')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(528.3, '0,000.00;-0,000.00')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(-23528.3, '$#,###.00;($#,###.00)')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(-23528.3, '$#,###.00;($#,###.00)')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(1528.3, '#/###:00', 'f1')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(1528.3, '#/###:00;-#/###:00', 'f1')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(1 div 0, '###,###.00', 'f2')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(1 div 0, '###,###.00', 'f2')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   format-number(blue div orange, '#.##', 'f2')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(blue div orange, '#.##', 'f2')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="report/month"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="document('')/*/months:name[@sequence=current()/@sequence]"/&gt;
      &lt;xsl:text&gt; - &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-flown, '##,###')"/&gt;
      &lt;xsl:text&gt; miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-earned, '##,###')"/&gt;
      &lt;xsl:text&gt; miles earned.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:text&gt;     (&lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="format-number(miles-flown div sum(//miles-flown), '##%')"/&gt;
      &lt;xsl:text&gt; of all miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="format-number(miles-earned div sum(//miles-earned), '##%')"/&gt;
      &lt;xsl:text&gt; of all miles earned.)&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt; 
    &lt;xsl:text&gt;   Total miles flown: &lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(sum(//miles-flown), '##,###')"/&gt;
    &lt;xsl:text&gt;, total miles earned: &lt;/xsl:text&gt;
    &lt;xsl:value-of select="format-number(sum(//miles-earned), '##,###')"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>We'll use this XML document with our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>When we run this stylesheet, here are the results:</p>
<blockquote><pre class="code">

Tests of the format-number() function:

   format-number(528.3, '#.#;-#.#')=528.3
   format-number(528.3, '0,000.00;-0,000.00')=0,528.30
   format-number(-23528.3, '$#,###.00;($#,###.00)')=($23,528.30)
   format-number(1528.3, '#/###:00', 'f1')=1/528:30
   format-number(1 div 0, '###,###.00', 'f2')=Really, really big
   format-number(blue div orange, '#.##', 'f2')=[not a number]

   January - 12,379 miles flown, 35,215 miles earned.
     (15% of all miles flown, 15% of all miles earned.)

   February - 32,857 miles flown, 92,731 miles earned.
     (39% of all miles flown, 39% of all miles earned.)

   March - 19,920 miles flown, 76,725 miles earned.
     (24% of all miles flown, 32% of all miles earned.)

   April - 18,903 miles flown, 31,781 miles earned.
     (22% of all miles flown, 13% of all miles earned.)

   Total miles flown: 84,059, total miles earned: 236,452</pre></blockquote>
<p>The first few examples illustrate some of the more complicated formatting options available, along with references to the <tt class="literal">&lt;xsl:decimal-format&gt;</tt> elements in the stylesheet. The last section is a more typical use of the <tt class="literal">format-number</tt> function: formatting values selected or calculated from an XML document. </p>
</div>
<a name="INDEX-960" /><a name="INDEX-961" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>function-available() Function</i></b></font></td><td align="right"><i>Determines if a given function is available to the XSLT processor. This function allows you to design stylesheets that react gracefully if a particular function is not available to process an XML document. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>function-available(</b></tt><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>The name function's name. The name is usually qualified with a namespace; if the namespace of the function name is non-null, the function is an extension function. Otherwise, the function is one of the functions defined in the XSLT or XPath specifications. </p>

<h4 class="refsect1">Output</h4>
<p>The boolean value <tt class="literal">true</tt> if the function is available, <tt class="literal">false</tt> otherwise. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 15, Fallback. </p>

<h4 class="refsect1">Example</h4>
<p>We'll use the following XML document to test the <tt class="literal">function-available()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;

  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>Here's our stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:jpeg="class:JPEGWriter"
  extension-element-prefixes="jpeg"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="list/listitem"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="function-available('jpeg:createJPEG')"&gt; 
          &lt;xsl:value-of 
            select="jpeg:createJPEG(., 'bg.jpg', 
            concat('album', position(), '.jpg'), 
            'Swiss 721 Bold Condensed', 'BOLD', 22, 52, 35)"/&gt;
          &lt;xsl:text&gt;See the file &lt;/xsl:text&gt;
          &lt;xsl:value-of select="concat('album', position(), '.jpg')"/&gt;
          &lt;xsl:text&gt; to see the title of album #&lt;/xsl:text&gt;
          &lt;xsl:value-of select="position()"/&gt;
          &lt;xsl:value-of select="$newline"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="position()"/&gt;
          &lt;xsl:text&gt;. &lt;/xsl:text&gt;
          &lt;xsl:value-of select="."/&gt;
          &lt;xsl:value-of select="$newline"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>

<p>In our stylesheet, if the <tt class="literal">createJPEG()</tt> function is available, we'll invoke it to create JPEG files for the titles of all our favorite albums. If the function is not available, we'll simply write those titles to the output stream. Here are the results we get when the <tt class="literal">createJPEG()</tt> function is available:</p>
<blockquote><pre class="code">

See the file album1.jpg to see the title of album #1
See the file album2.jpg to see the title of album #2
See the file album3.jpg to see the title of album #3
See the file album4.jpg to see the title of album #4
See the file album5.jpg to see the title of album #5
See the file album6.jpg to see the title of album #6
See the file album7.jpg to see the title of album #7
See the file album8.jpg to see the title of album #8
</pre></blockquote>
<p>All album titles (the text of the <tt class="literal">&lt;listitem&gt;</tt> elements) are converted to JPEG graphics. In this example, the file <em class="filename">album8.jpg</em> looks like <a href="appc_01.htm">Figure C-3</a>.</p>
<a name="xslt-appc-c3" /><div class="figure"><img height="41" alt="Figure C-3" src="figs/xslt.ac03.gif" width="403" /></div><h4 class="objtitle">Figure C-3. Generated graphic for the eighth &lt;listitem&gt; element</h4>
<p>If we delete the file <em class="filename">JPEGWriter.class</em> (if the <em class="filename">.class</em> file is missing, the function isn't available), we get these results instead:</p>
<blockquote><pre class="code">

1. A Love Supreme
2. Beat Crazy
3. Here Come the Warm Jets
4. Kind of Blue
5. London Calling
6. Remain in Light
7. The Joshua Tree
8. The Indestructible Beat of Soweto
</pre></blockquote>
</div>
<a name="INDEX-962" /><a name="INDEX-963" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>generate-id() Function</i></b></font></td><td align="right"><i>Generates a unique ID (an XML name) for a given node. If no node-set is given, generate-id() generates an ID for the context node.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>generate-id(</b></tt><em class="replaceable">node-set?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>An optional node-set. If no node-set is given, this function generates an ID for the context node. If the node-set is empty, <tt class="literal">generate-id()</tt> returns an empty string. </p>

<h4 class="refsect1">Output</h4>
<p>A unique ID, or an empty string if an empty node-set is given. Several things about the <tt class="literal">generate-id()</tt> function are important to know:</p>
<ul>
        <li>
          <p>For a given transformation, every time you invoke <tt class="literal">generate-id()</tt> against a given node, the XSLT processor must return the same ID. The ID can't change while you're doing a transformation. If you ask the XSLT processor to transform your document with this stylesheet tomorrow, there's no guarantee that <tt class="literal">generate-id()</tt> will generate the same ID the second time around. All of tomorrow's calls to <tt class="literal">generate-id()</tt> will generate the same ID, but that ID might not be the one generated today.</p>
        </li>
        <li>
          <p>The <tt class="literal">generate-id()</tt> function is not required to check if its generated ID duplicates an ID that's already in the document. In other words, if an element in your document has an attribute of type <tt class="literal">ID</tt> with the value <tt class="literal">sdk3829a</tt>, there's a remote possibility that an ID returned by <tt class="literal">generate-id()</tt> would have the value <tt class="literal">sdk3829a</tt>. It's not likely, but it could happen.</p>
        </li>
        <li>
          <p>If you invoke <tt class="literal">generate-id()</tt> against two different nodes, the two generated IDs must be different.</p>
        </li>
        <li>
          <p>Given a node-set, <tt class="literal">generate-id()</tt> returns an ID for the node in the node-set that occurs first in document order. </p>
        </li>
        <li>
          <p>If the node-set you pass to the function is empty (you invoke <tt class="literal">generate-id(fleeber)</tt>, but there are no <tt class="literal">&lt;fleeber&gt;</tt> elements in the current context), <tt class="literal">generate-id()</tt> returns an empty string.</p>
        </li>
      </ul>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.4, Miscellaneous Additional Functions.</p>

<h4 class="refsect1">Example</h4>
<p>Here's a simple stylesheet that uses the <tt class="literal">document('')</tt> function to access all of its own <tt class="literal">&lt;xsl:text&gt;</tt> nodes. It then uses <tt class="literal">generate-id()</tt> to generate a unique ID for each of those nodes, then calls <tt class="literal">generate-id()</tt> again to illustrate that the function generates the same ID for a given node. Here's the stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the generate-id() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="document('')//xsl:text"&gt;
      &lt;xsl:text&gt;Node name: &lt;/xsl:text&gt;
      &lt;xsl:value-of select="name()"/&gt;
      &lt;xsl:text&gt; - generated id: &lt;/xsl:text&gt;
      &lt;xsl:value-of select="generate-id()"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Now we'll try it again...&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="document('')//xsl:text"&gt;
      &lt;xsl:text&gt;Node name: &lt;/xsl:text&gt;
      &lt;xsl:value-of select="name()"/&gt;
      &lt;xsl:text&gt; - generated id: &lt;/xsl:text&gt;
      &lt;xsl:value-of select="generate-id()"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Our stylesheet generates these results:</p>
<blockquote><pre class="code">

A test of the generate-id() function:

Node name: xsl:text - generated id: NC
Node name: xsl:text - generated id: N16
Node name: xsl:text - generated id: N22
Node name: xsl:text - generated id: N28
Node name: xsl:text - generated id: N38
Node name: xsl:text - generated id: N44
Node name: xsl:text - generated id: N4A


Now we'll try it again...

Node name: xsl:text - generated id: NC
Node name: xsl:text - generated id: N16
Node name: xsl:text - generated id: N22
Node name: xsl:text - generated id: N28
Node name: xsl:text - generated id: N38
Node name: xsl:text - generated id: N44
Node name: xsl:text - generated id: N4A
</pre></blockquote>
<p>The IDs generated each time are the same. </p>
</div>
<a name="INDEX-964" /><a name="INDEX-965" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>id() Function</i></b></font></td><td align="right"><i>Returns the node in the source tree whose ID attribute matches the value passed in as input. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>node-set <tt class="userinput"><b>id(</b></tt><em class="replaceable">object</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>An object. If the input object is a node-set, the result is a node-set that contains the result of applying the <tt class="literal">id()</tt> function to the string value of each node in the argument node-set. Usually, the argument is some other node type, which is (or is converted to) a string. That string is then used as the search value while all attributes of type ID are searched. </p>
<p>Remember that a limitation of the XML <tt class="literal">ID</tt> datatype is that a single set of names across all attributes is declared to be of type <tt class="literal">ID</tt>. The XSLT <tt class="literal">key()</tt> function and the associated <tt class="literal">&lt;xsl:key&gt;</tt> element address this and other limitations; see the <tt class="literal">key()</tt> function and <tt class="literal">&lt;xsl:key&gt;</tt> for more information.</p>

<h4 class="refsect1">Output</h4>
<p>A node-set containing all nodes whose attributes of type <tt class="literal">ID</tt> match the string values of the input node-set. In practice, this node-set is a single node, the node whose attribute of type <tt class="literal">ID</tt> matches a string value. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.1, Node Set Functions.</p>

<h4 class="refsect1">Example</h4>
<p>For our example, we'll take this shortened version of the glossary we discussed earlier:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" ?&gt;
&lt;!DOCTYPE glossary SYSTEM "glossary.dtd"&gt;
&lt;glossary&gt;
  &lt;glentry&gt;
    &lt;term id="applet"&gt;applet&lt;/term&gt;
    &lt;defn&gt;
      An application program,
      written in the Java programming language, that can be 
      retrieved from a web server and executed by a web browser. 
      A reference to an applet appears in the markup for a web 
      page, in the same way that a reference to a graphics
      file appears; a browser retrieves an applet in the same 
      way that it retrieves a graphics file. 
      For security reasons, an applet's access rights are limited
      in two ways: the applet cannot access the filesystem of the 
      client upon which it is executing, and the applet's 
      communication across the network is limited to the server 
      from which it was downloaded. 
      Contrast with &lt;xref refid="servlet"/&gt;.
    &lt;/defn&gt;
  &lt;/glentry&gt;

  &lt;glentry&gt;
    &lt;term id="servlet"&gt;servlet&lt;/term&gt;
    &lt;defn&gt;
      An application program, written in the Java programming language, 
      that is executed on a web server. A reference to a servlet 
      appears in the markup for a web page, in the same way that a 
      reference to a graphics file appears. The web server executes
      the servlet and sends the results of the execution (if there are
      any) to the web browser. Contrast with &lt;xref refid="applet" /&gt;.
    &lt;/defn&gt;
  &lt;/glentry&gt;
&lt;/glossary&gt;</pre></blockquote>
<p>Here's the stylesheet we'll use to resolve the references:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output method="html" indent="yes"/&gt;
&lt;xsl:strip-space elements="*"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates select="glossary"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="glossary"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:text&gt;Glossary Listing &lt;/xsl:text&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;
          &lt;xsl:text&gt;Glossary Listing &lt;/xsl:text&gt;
        &lt;/h1&gt;
        &lt;xsl:apply-templates select="glentry"/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="glentry"&gt;
    &lt;p&gt;
      &lt;b&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="name"&gt;
            &lt;xsl:value-of select="term/@id" /&gt;
          &lt;/xsl:attribute&gt;
        &lt;/a&gt;

        &lt;xsl:value-of select="term"/&gt;
        &lt;xsl:text&gt;: &lt;/xsl:text&gt;
      &lt;/b&gt;
      &lt;xsl:apply-templates select="defn"/&gt;
    &lt;/p&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="defn"&gt;
    &lt;xsl:apply-templates 
     select="*|comment()|processing-instruction()|text()"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xref"&gt;
    &lt;a&gt;
      &lt;xsl:attribute name="href"&gt;
        &lt;xsl:text&gt;#&lt;/xsl:text&gt;&lt;xsl:value-of select="@refid"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="id(@refid)/@xreftext"&gt;
          &lt;xsl:value-of select="id(@refid)/@xreftext"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="id(@refid)"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/a&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Our stylesheet generates these results:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Glossary Listing &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Glossary Listing &lt;/h1&gt;
&lt;p&gt;
&lt;b&gt;&lt;a name="applet"&gt;&lt;/a&gt;applet: &lt;/b&gt;
      An application program,
      written in the Java programming language, that can be 
      retrieved from a web server and executed by a web browser. 
      A reference to an applet appears in the markup for a web 
      page, in the same way that a reference to a graphics
      file appears; a browser retrieves an applet in the same 
      way that it retrieves a graphics file. 
      
      For security reasons, an applet's access rights are limited
      in two ways: the applet cannot access the filesystem of the 
      client upon which it is executing, and the applet's 
      communication across the network is limited to the server 
      from which it was downloaded. 
      Contrast with &lt;a href="#servlet"&gt;servlet&lt;/a&gt;.
    &lt;/p&gt;
&lt;p&gt;
&lt;b&gt;&lt;a name="servlet"&gt;&lt;/a&gt;servlet: &lt;/b&gt;
      An application program, written in the Java programming language, 
      that is executed on a web server. A reference to a servlet 
      appears in the markup for a web page, in the same way that a 
      reference to a graphics file appears. The web server executes
      the servlet and sends the results of the execution (if there are
      any) to the web browser. Contrast with &lt;a href="#applet"&gt;applet&lt;/a&gt;.
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>When rendered in a browser, our hyperlinked document looks like <a href="appc_01.htm">Figure C-4</a>.</p>
<a name="xslt-appc-c4" /><div class="figure"><img height="299" alt="Figure C-4" src="figs/xslt.ac04.gif" width="481" /></div><h4 class="objtitle">Figure C-4. Generated HTML glossary</h4>
</div>
<a name="INDEX-966" /><a name="INDEX-967" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>key() Function</i></b></font></td><td align="right"><i>References a relation defined with an &lt;xsl:key&gt; element. Conceptually, the key() function works similarly to the id() function, although keys are more flexible than IDs.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>node-set <tt class="userinput"><b>key(</b></tt><em class="replaceable">string</em><em class="replaceable">object</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>The name of the key (defined by an <tt class="literal">&lt;xsl:key&gt;</tt> element) and an object. If the object is a node-set, then the <tt class="literal">key()</tt> function applies itself to the string value of each node in the node-set and returns the node-set of the result of all those <tt class="literal">key()</tt> function invocations. If the object is any other type, it is converted to a string as if by a call to the <tt class="literal">string()</tt> function. </p>

<h4 class="refsect1">Output</h4>
<p>A node-set containing the nodes in the same document as the context node whose values for the requested key match the search argument(s). In other words, if our stylesheet has an <tt class="literal">&lt;xsl:key&gt;</tt> element that defines a key named <tt class="literal">postalcodes</tt> based on the <tt class="literal">&lt;postalcode&gt;</tt> child of all <tt class="literal">&lt;address&gt;</tt> elements in the current document, the function call <tt class="literal">key(postalcodes, '34829')</tt> returns a node-set containing all the <tt class="literal">&lt;address&gt;</tt> elements with a <tt class="literal">&lt;postalcode&gt;</tt> element whose value is <tt class="literal">34829</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.2, Keys.</p>

<h4 class="refsect1">Example</h4>
<p>To illustrate the power of the <tt class="literal">key()</tt> function, we'll use this document -- a truncated version of the glossary we discussed in <a href="ch05_01.htm">Chapter 5, "Creating Links and Cross-References"</a>:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0" ?&gt;
&lt;glossary&gt;
  &lt;glentry&gt;
    &lt;term id="applet"&gt;applet&lt;/term&gt;
    &lt;defn topic="Java" language="en"&gt;
      An application program,
      written in the Java programming language, that can be 
      retrieved from a web server and executed by a web browser. 
      A reference to an applet appears in the markup for a web 
      page, in the same way that a reference to a graphics
      file appears; a browser retrieves an applet in the same 
      way that it retrieves a graphics file. 
      For security reasons, an applet's access rights are limited
      in two ways: the applet cannot access the filesystem of the 
      client upon which it is executing, and the applet's 
      communication across the network is limited to the server 
      from which it was downloaded. 
      Contrast with &lt;xref refid="servlet"/&gt;.
    &lt;/defn&gt;

    &lt;defn topic="Java" language="it"&gt;
      [Pretend this is an Italian definition of applet.]
    &lt;/defn&gt;
    &lt;defn topic="Java" language="es"&gt;
      [Pretend this is a Spanish definition of applet.]
    &lt;/defn&gt;
  &lt;/glentry&gt;

  &lt;glentry&gt;
    &lt;term id="DMZlong" xreftext="demilitarized zone"&gt;demilitarized 
      zone (DMZ)&lt;/term&gt;
    &lt;defn topic="security" language="en"&gt;
      In network security, a network that is isolated from, and 
      serves as a neutral zone between, a trusted network (for example, 
      a private intranet) and an untrusted network (for example, the
      Internet). One or more secure gateways usually control access 
      to the DMZ from the trusted or the untrusted network.
    &lt;/defn&gt;
    &lt;defn topic="security" language="it"&gt;
      [Pretend this is an Italian definition of DMZ.]
    &lt;/defn&gt;
    &lt;defn topic="security" language="es"&gt;
      [Pretend this is a Spanish definition of DMZ.]
    &lt;/defn&gt;
    &lt;defn topic="security" language="jp"&gt;
      [Pretend this is a Japanese definition of DMZ.]
    &lt;/defn&gt;
    &lt;defn topic="security" language="de"&gt;
      [Pretend this is a German definition of DMZ.]
    &lt;/defn&gt;
  &lt;/glentry&gt;

  &lt;glentry&gt;
    &lt;term id="servlet"&gt;servlet&lt;/term&gt;
    &lt;defn topic="Java" language="en"&gt;
      An application program, written in the Java programming language, 
      that is executed on a web server. A reference to a servlet 
      appears in the markup for a web page, in the same way that a 
      reference to a graphics file appears. The web server executes
      the servlet and sends the results of the execution (if there are
      any) to the web browser. Contrast with &lt;xref refid="applet" /&gt;.
    &lt;/defn&gt;
    &lt;defn topic="Java" language="es"&gt;
      [Pretend this is a Spanish definition of servlet.]
    &lt;/defn&gt;
    &lt;defn topic="Java" language="it"&gt;
      [Pretend this is an Italian definition of servlet.]
    &lt;/defn&gt;

    &lt;defn topic="Java" language="de"&gt;
      [Pretend this is a German definition of servlet.]
    &lt;/defn&gt;
    &lt;defn topic="Java" language="jp"&gt;
      [Pretend this is a Japanese definition of servlet.]
    &lt;/defn&gt;
  &lt;/glentry&gt;
&lt;/glossary&gt;</pre></blockquote>
<p>Here's the stylesheet we'll use to process this document. Notice that we define two <tt class="literal">&lt;xsl:key&gt;</tt> elements to index the XML document in two different ways:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output method="html" indent="yes"/&gt;
&lt;xsl:strip-space elements="*"/&gt;

  &lt;xsl:key name="language-index" match="defn" use="@language"/&gt;
  &lt;xsl:key name="term-ids"       match="term" use="@id"/&gt;

  &lt;xsl:param name="targetLanguage"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:apply-templates select="glossary"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="glossary"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:text&gt;Glossary Listing: &lt;/xsl:text&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;
          &lt;xsl:text&gt;Glossary Listing: &lt;/xsl:text&gt;
        &lt;/h1&gt;
        &lt;xsl:for-each select="key('language-index', $targetLanguage)"&gt;
          &lt;xsl:apply-templates select="ancestor::glentry"/&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="glentry"&gt;
    &lt;p&gt;
      &lt;b&gt;
        &lt;a&gt;
          &lt;xsl:attribute name="name"&gt;
            &lt;xsl:value-of select="term/@id" /&gt;
          &lt;/xsl:attribute&gt;
        &lt;/a&gt;
        &lt;xsl:value-of select="term"/&gt;
        &lt;xsl:text&gt;: &lt;/xsl:text&gt;
      &lt;/b&gt;
      &lt;xsl:apply-templates select="defn[@language=$targetLanguage]"/&gt;
    &lt;/p&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="defn"&gt;
    &lt;xsl:apply-templates 
     select="*|comment()|processing-instruction()|text()"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xref"&gt;
    &lt;a&gt;
      &lt;xsl:attribute name="href"&gt;
        &lt;xsl:text&gt;#&lt;/xsl:text&gt;&lt;xsl:value-of select="@refid"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="key('term-ids', @refid)[1]/@xreftext"&gt;
          &lt;xsl:value-of select="key('term-ids', @refid)[1]/@xreftext"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="key('term-ids', @refid)[1]"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/a&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Transforming the glossary with a <tt class="literal">targetLanguage</tt> of <tt class="literal">en</tt> gives these results:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Glossary Listing: &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Glossary Listing: &lt;/h1&gt;
&lt;p&gt;
&lt;b&gt;&lt;a name="applet"&gt;&lt;/a&gt;applet: &lt;/b&gt;
      An application program,
      written in the Java programming language, that can be 
      retrieved from a web server and executed by a web browser. 
      A reference to an applet appears in the markup for a web 
      page, in the same way that a reference to a graphics
      file appears; a browser retrieves an applet in the same 
      way that it retrieves a graphics file. 
      For security reasons, an applet's access rights are limited
      in two ways: the applet cannot access the filesystem of the 
      client upon which it is executing, and the applet's 
      communication across the network is limited to the server 
      from which it was downloaded. 
      Contrast with &lt;a href="#servlet"&gt;servlet&lt;/a&gt;.
    &lt;/p&gt;
&lt;p&gt;
&lt;b&gt;&lt;a name="DMZlong"&gt;&lt;/a&gt;demilitarized 
      zone (DMZ): &lt;/b&gt;
      In network security, a network that is isolated from, and 
      serves as a neutral zone between, a trusted network (for example, 
      a private intranet) and an untrusted network (for example, the
      Internet). One or more secure gateways usually control access 
      to the DMZ from the trusted or the untrusted network.
    &lt;/p&gt;
&lt;p&gt;
&lt;b&gt;&lt;a name="servlet"&gt;&lt;/a&gt;servlet: &lt;/b&gt;
      An application program, written in the Java programming language, 
      that is executed on a web server. A reference to a servlet 
      appears in the markup for a web page, in the same way that a 
      reference to a graphics file appears. The web server executes
      the servlet and sends the results of the execution (if there are
      any) to the web browser. Contrast with &lt;a href="#applet"&gt;applet&lt;/a&gt;.
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p><a href="appc_01.htm">Figure C-5</a> shows how this document looks when it's rendered in a browser.
Using a <tt class="literal">targetLanguage</tt> of <tt class="literal">jp</tt> gives us these results instead:</p><a name="xslt-appc-c5" /><div class="figure"><img height="432" alt="Figure C-5" src="figs/xslt.ac05.gif" width="420" /></div><h4 class="objtitle">Figure C-5. Generated HTML glossary</h4>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;Glossary Listing: &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Glossary Listing: &lt;/h1&gt;
&lt;p&gt;
&lt;b&gt;&lt;a name="DMZlong"&gt;&lt;/a&gt;demilitarized 
      zone (DMZ): &lt;/b&gt;
      [Pretend this is a Japanese definition of DMZ.]
    &lt;/p&gt;
&lt;p&gt;
&lt;b&gt;&lt;a name="servlet"&gt;&lt;/a&gt;servlet: &lt;/b&gt;
      [Pretend this is a Japanese definition of servlet.]
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
      &lt;/programlisting&gt;</pre></blockquote>
<p>When rendered, the document looks like <a href="appc_01.htm">Figure C-6</a>. Notice that we get entirely different results when we change the <tt class="literal">targetLanguage</tt>.</p>
<a name="xslt-appc-c6" /><div class="figure"><img height="150" alt="Figure C-6" src="figs/xslt.ac06.gif" width="420" /></div><h4 class="objtitle">Figure C-6. Generated HTML glossary</h4>
</div>
<a name="INDEX-968" /><a name="INDEX-969" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>lang() Function</i></b></font></td><td align="right"><i>Determines whether a given language string is the same as, or is a sublanguage of, the language of the context node, as defined by an xml:lang attribute.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>lang(</b></tt><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>A string representing a language code. If the context node has a language of <tt class="literal">xml:lang="en-us"</tt>, invoking the <tt class="literal">lang()</tt> function with any of the values <tt class="literal">en</tt>, <tt class="literal">EN</tt>, and <tt class="literal">en-us</tt> returns the boolean value <tt class="literal">true</tt>, while invoking <tt class="literal">lang()</tt> with the value <tt class="literal">en-gb</tt> returns the boolean value <tt class="literal">false</tt>.</p>

<h4 class="refsect1">Output</h4>
<p>If the argument string is the same as, or is a sublanguage of, the context node's language, <tt class="literal">lang()</tt> returns the boolean value <tt class="literal">true</tt>. If the context node does not have an <tt class="literal">xml:lang</tt> attribute, then the value of the <tt class="literal">xml:lang</tt> attribute of its nearest ancestor is used instead. If there is no such attribute, then the <tt class="literal">lang()</tt> function returns the boolean value <tt class="literal">false</tt>. When comparing the language code of the context node with the argument string, the <tt class="literal">lang()</tt> function ignores case.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.3, Boolean Functions.</p>

<h4 class="refsect1">Example</h4>
<p>Here is an XML document that uses language codes:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list xml:lang="en"&gt;
  &lt;title&gt;Albums I've bought recently:&lt;/title&gt;
  &lt;listitem&gt;The Sacred Art of Dub&lt;/listitem&gt;
  &lt;listitem&gt;Only the Poor Man Feel It&lt;/listitem&gt;
  &lt;listitem&gt;Excitable Boy&lt;/listitem&gt;
  &lt;listitem xml:lang="sw"&gt;Aki Special&lt;/listitem&gt;
  &lt;listitem xml:lang="en-gb"&gt;Combat Rock&lt;/listitem&gt;
  &lt;listitem xml:lang="zu"&gt;Talking Timbuktu&lt;/listitem&gt;
  &lt;listitem xml:lang="jz"&gt;The Birth of the Cool&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>Here's a stylesheet that uses the <tt class="literal">lang()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;


  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="list/listitem"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="lang('EN')"&gt;
          &lt;xsl:text&gt;Here's an English-language album: &lt;/xsl:text&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:text&gt;-------&gt; Here's some World music: &lt;/xsl:text&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Finally, here are the results:</p>
<blockquote><pre class="code">

Here's an English-language album: The Sacred Art of Dub
Here's an English-language album: Only the Poor Man Feel It
Here's an English-language album: Excitable Boy
-------&gt; Here's some World music: Aki Special
Here's an English-language album: Combat Rock
-------&gt; Here's some World music: Talking Timbuktu
-------&gt; Here's some World music: The Birth of the Cool
</pre></blockquote>
</div>
<a name="INDEX-970" /><a name="INDEX-971" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>last() Function</i></b></font></td><td align="right"><i>Returns the position of the last node in the current context. This function is useful for defining templates for the last occurrence of a given element or for testing if a given node is the last in the node-set to which it belongs.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>last(</b></tt><tt class="userinput"><b>)</b></tt></pre></tt></p>

        
      

<h4 class="refsect1">Inputs</h4>
<p>None.</p>

<h4 class="refsect1">Output</h4>
<p>A number equal to the number of nodes in the current context. For example, if the current context contains 12 <tt class="literal">&lt;li&gt;</tt> nodes, <tt class="literal">last()</tt> returns 12.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.1, Node Set Functions. </p>

<h4 class="refsect1">Example</h4>
<p>We'll use the <tt class="literal">last()</tt> function to handle the last item in a list in a special way. Here's the XML document we'll use:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>Here is the stylesheet that handles the last <tt class="literal">&lt;listitem&gt;</tt> in the list differently:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:value-of select="/list/title"/&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;
          &lt;xsl:value-of select="/list/title"/&gt;
        &lt;/h1&gt;
        &lt;ul&gt;
          &lt;xsl:for-each select="/list/listitem"&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="position()=last()"&gt;
                &lt;li&gt;&lt;b&gt;Last, but not least: &lt;/b&gt;&lt;xsl:value-of select="."/&gt;&lt;/li&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:otherwise&gt;
                &lt;li&gt;&lt;xsl:value-of select="."/&gt;&lt;/li&gt;
              &lt;/xsl:otherwise&gt;
            &lt;/xsl:choose&gt;
          &lt;/xsl:for-each&gt;
        &lt;/ul&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When we transform the XML document with this stylesheet, here are the results:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;A few of my favorite albums&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;A few of my favorite albums&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A Love Supreme&lt;/li&gt;
&lt;li&gt;Beat Crazy&lt;/li&gt;
&lt;li&gt;Here Come the Warm Jets&lt;/li&gt;
&lt;li&gt;Kind of Blue&lt;/li&gt;
&lt;li&gt;London Calling&lt;/li&gt;
&lt;li&gt;Remain in Light&lt;/li&gt;
&lt;li&gt;The Joshua Tree&lt;/li&gt;
&lt;li&gt;
&lt;b&gt;Last, but not least: &lt;/b&gt;The Indestructible Beat of Soweto&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>When rendered, the HTML file looks like <a href="appc_01.htm">Figure C-7</a>.</p>
<a name="xslt-appc-c7" /><div class="figure"><img height="252" alt="Figure C-7" src="figs/xslt.ac07.gif" width="396" /></div><h4 class="objtitle">Figure C-7. Generated HTML document</h4>
</div>
<a name="INDEX-972" /><a name="INDEX-973" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>local-name() Function</i></b></font></td><td align="right"><i>Returns the local part of the first node in the argument node-set. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>local-name(</b></tt><em class="replaceable">node-set?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>A node-set. If the node-set is empty, the function returns an empty string. If the node-set is omitted, the function uses a node-set with the context node as its only member.</p>

<h4 class="refsect1">Output</h4>
<p>A string corresponding to the local name of the first element in the argument node-set. If the node-set is empty, the <tt class="literal">local-name()</tt> function returns an empty string. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.1, Node Set Functions. </p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet that uses the <tt class="literal">document()</tt> function to process all its own nodes. It then calls the <tt class="literal">local-name()</tt> function against each node.</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;months:name sequence="12"&gt;December&lt;/months:name&gt;
  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;
  &lt;months:name sequence="05"&gt;May&lt;/months:name&gt;
  &lt;months:name sequence="06"&gt;June&lt;/months:name&gt;
  &lt;months:name sequence="07"&gt;July&lt;/months:name&gt;
  &lt;months:name sequence="08"&gt;August&lt;/months:name&gt;
  &lt;months:name sequence="09"&gt;September&lt;/months:name&gt;
  &lt;months:name sequence="10"&gt;October&lt;/months:name&gt;
  &lt;months:name sequence="11"&gt;November&lt;/months:name&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the local-name() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="document('')//*"&gt;
      &lt;xsl:text&gt;local-name: &lt;/xsl:text&gt;
      &lt;xsl:value-of select="local-name()"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>The stylesheet generates these results:</p>
<blockquote><pre class="code">

A test of the local-name() function:

local-name: stylesheet
local-name: name
local-name: name
local-name: name
local-name: name
local-name: name
local-name: name
local-name: name
local-name: name
local-name: name
local-name: name
local-name: name
local-name: name
local-name: output
local-name: variable
local-name: text
local-name: template
local-name: value-of
local-name: text
local-name: value-of
local-name: value-of
local-name: for-each
local-name: text
local-name: value-of
local-name: value-of</pre></blockquote>
</div>
<a name="INDEX-974" /><a name="INDEX-975" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>name() Function</i></b></font></td><td align="right"><i>Returns the qualified name of a node. The qualified name includes the appropriate namespace prefix. For information on the namespace URI (not the prefix), XPath provides the namespace-uri() function.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>name(</b></tt><em class="replaceable">node-set?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>An optional node-set. If no node-set is given, the <tt class="literal">name()</tt> function creates a node-set with the context node as its only member. </p>

<h4 class="refsect1">Output</h4>
<p>The expanded name of the node. If the argument node-set is empty, or if the first node in the node-set does not have an expanded name, an empty string is returned. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.1, Node Set Functions.</p>

<h4 class="refsect1">Example</h4>
<p>Here is the XML document we'll use to demonstrate the <tt class="literal">name()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>We'll use this stylesheet to output the value of the <tt class="literal">name()</tt> function for each node in the XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;months:name sequence="12"&gt;December&lt;/months:name&gt;
  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;
  &lt;months:name sequence="05"&gt;May&lt;/months:name&gt;
  &lt;months:name sequence="06"&gt;June&lt;/months:name&gt;
  &lt;months:name sequence="07"&gt;July&lt;/months:name&gt;
  &lt;months:name sequence="08"&gt;August&lt;/months:name&gt;
  &lt;months:name sequence="09"&gt;September&lt;/months:name&gt;
  &lt;months:name sequence="10"&gt;October&lt;/months:name&gt;
  &lt;months:name sequence="11"&gt;November&lt;/months:name&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the name() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="document('')//*"&gt;
      &lt;xsl:text&gt;name: &lt;/xsl:text&gt;
      &lt;xsl:value-of select="name()"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When we transform the XML document with this stylesheet, here are the results:</p>
<blockquote><pre class="code">

A test of the name() function:

name: xsl:stylesheet
name: months:name
name: months:name
name: months:name
name: months:name
name: months:name
name: months:name
name: months:name
name: months:name
name: months:name
name: months:name
name: months:name
name: months:name
name: xsl:output
name: xsl:variable
name: xsl:text
name: xsl:template
name: xsl:value-of
name: xsl:text
name: xsl:value-of
name: xsl:value-of
name: xsl:for-each
name: xsl:text
name: xsl:value-of
name: xsl:value-of
</pre></blockquote>
</div>
<a name="INDEX-976" /><a name="INDEX-977" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>namespace-uri() Function</i></b></font></td><td align="right"><i>Returns the namespace URI of the first node in the argument node-set. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>namespace-uri(</b></tt><em class="replaceable">node-set?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>A node-set. If the node-set is omitted, the <tt class="literal">namespace-uri()</tt> function creates a node-set that has the context node as its only member.</p>

<h4 class="refsect1">Output</h4>
<p>The namespace URI of the first node in the argument node-set.  If the argument node-set is empty, the first node has no namespace URI, or the first node has a namespace URI that is null, an empty string is returned. Be aware that the <tt class="literal">namespace-uri()</tt> function returns an empty string for all nodes other than element and attribute nodes. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.1, Node Set Functions. </p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet that uses the <tt class="literal">document()</tt> function to examine its own nodes and then invoke the <tt class="literal">namespace-uri()</tt> against each of them:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;
  &lt;months:name sequence="05"&gt;May&lt;/months:name&gt;
  &lt;months:name sequence="06"&gt;June&lt;/months:name&gt;
  &lt;months:name sequence="07"&gt;July&lt;/months:name&gt;
  &lt;months:name sequence="08"&gt;August&lt;/months:name&gt;
  &lt;months:name sequence="09"&gt;September&lt;/months:name&gt;
  &lt;months:name sequence="10"&gt;October&lt;/months:name&gt;
  &lt;months:name sequence="11"&gt;November&lt;/months:name&gt;
  &lt;months:name sequence="12"&gt;December&lt;/months:name&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the namespace-uri() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="document('')//*"&gt;
      &lt;xsl:text&gt;namespace URI: &lt;/xsl:text&gt;
      &lt;xsl:value-of select="namespace-uri()"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results of our stylesheet:</p>
<blockquote><pre class="code">

A test of the namespace-uri() function:

namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: Lookup table for month names
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
namespace URI: http://www.w3.org/1999/XSL/Transform
</pre></blockquote>
</div>
<a name="INDEX-978" /><a name="INDEX-979" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>normalize-space() Function</i></b></font></td><td align="right"><i>Removes extra whitespace from its argument string.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>normalize-space(</b></tt><em class="replaceable">string?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>An optional string. If the argument is omitted, the <tt class="literal">normalize-space()</tt> function uses the string value of the context node. </p>

<h4 class="refsect1">Output</h4>
<p>The argument string, with whitespace removed as follows:</p>
<ul>
        <li>
          <p>All leading whitespace is removed.</p>
        </li>
        <li>
          <p>All trailing whitespace is removed.</p>
        </li>
        <li>
          <p>Within the string, any sequence of whitespace characters is replaced with a single space.</p>
        </li>
      </ul>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions.</p>

<h4 class="refsect1">Example</h4>
<p>Here is a short example that demonstrates how <tt class="literal">normalize-space()</tt> works:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;


  &lt;xsl:variable name="testString"&gt;
    &lt;xsl:text&gt;                 This
is


a string
with lots of


whitespace.

&lt;/xsl:text&gt;
    &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the normalize-space() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   normalize-space('       Hello,            World!')="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="normalize-space('       Hello,            World!')"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   normalize-space($newline)="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="normalize-space($newline)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   normalize-space($testString)="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="normalize-space($testString)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>The stylesheet generates this output:</p>
<blockquote><pre class="code">

Tests of the normalize-space() function:

   normalize-space('       Hello,            World!')="Hello, World!"
   normalize-space($newline)=""
   normalize-space($testString)="This is a string with lots of whitespace."
</pre></blockquote>
</div>
<a name="INDEX-980" /><a name="INDEX-981" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>not() Function</i></b></font></td><td align="right"><i>Returns the negation of its argument. If the argument is not a boolean value already, it is converted to a boolean value using the rules described in the boolean() function entry.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>not(</b></tt><em class="replaceable">boolean</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>A boolean value, or more commonly, an XPath expression that evaluates to a boolean value.</p>

<h4 class="refsect1">Output</h4>
<p>
<tt class="literal">false</tt> if the input parameter is <tt class="literal">true</tt>; <tt class="literal">true</tt> if the input parameter is <tt class="literal">false</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.3, Boolean Functions.</p>

<h4 class="refsect1">Example</h4>
<p>To demonstrate the <tt class="literal">not()</tt> function, we'll use the same stylesheet and XML document we used for the <tt class="literal">boolean()</tt> function. Here's our XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;test&gt;
&lt;p&gt;This is a test XML document used by several 
of our sample stylesheets.&lt;/p&gt;
&lt;question&gt;
&lt;text&gt;When completed, the Eiffel Tower was the 
tallest building in the world.&lt;/text&gt;
&lt;true&gt;Yes!  The Eiffel Tower was the world's 
tallest building until 1932, when
New York's Empire State Building opened. &lt;/true&gt;
&lt;false&gt;No, the Eiffel Tower was the world's 
tallest building for over 30 years.&lt;/false&gt;
&lt;/question&gt;
&lt;/test&gt;</pre></blockquote>
<p>We'll process this document with the following stylesheet, which uses the <tt class="literal">not()</tt> to negate all <tt class="literal">boolean()</tt> function calls:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the not() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="not(boolean(true()))"&gt;
        &lt;xsl:text&gt;   "not(boolean(true()))"   returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "not(boolean(true()))"   returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="not(boolean(true))"&gt;
        &lt;xsl:text&gt;   "not(boolean(true))"     returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "not(boolean(true))"     returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="not(boolean('false'))"&gt;
        &lt;xsl:text&gt;   "not(boolean('false'))"  returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "not(boolean('false'))"  returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="not(boolean('7'))"&gt;
        &lt;xsl:text&gt;   "not(boolean('7'))"      returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "not(boolean('7'))"      returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="not(boolean(/true))"&gt;
        &lt;xsl:text&gt;   "not(boolean(/true))"    returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "not(boolean(/true))"    returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="not(boolean(//true))"&gt;
        &lt;xsl:text&gt;   "not(boolean(//true))"   returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "not(boolean(//true))"   returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results:</p>
<blockquote><pre class="code">

Tests of the not() function:

   "not(boolean(true()))"   returned false!
   "not(boolean(true))"     returned true!
   "not(boolean('false'))"  returned false!
   "not(boolean('7'))"      returned false!
   "not(boolean(/true))"    returned true!
   "not(boolean(//true))"   returned false!
</pre></blockquote>
<p>As you'd expect, these results are the exact opposite of the results we got when we tested the <tt class="literal">boolean()</tt> function.</p>
</div>
<a name="INDEX-982" /><a name="INDEX-983" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>number() Function</i></b></font></td><td align="right"><i>Converts its argument to a number. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>number(</b></tt><em class="replaceable">object?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>An object. The object is converted to a number as described in the following subsection. </p>

<h4 class="refsect1">Output</h4>
<p>A number. The object is converted to a number as follows:</p>
<ul>
        <li>
          <p>If the argument is a boolean value, the value <tt class="literal">true</tt> is converted to the number <tt class="literal">1</tt>; the value <tt class="literal">false</tt> is converted to the number <tt class="literal">0</tt>.</p>
        </li> 
<li>
          <p>If the argument is a node-set, the node-set is converted to a string as if it were passed to the <tt class="literal">string()</tt> function, then that string is converted to a number like any other string. (Remember that the <tt class="literal">string()</tt> function returns the string value of the first node in the node-set.)</p>
        </li>
        <li>
          <p>If the argument is a string, it is converted as follows:</p>
          <ul>
            <li>
              <p>If the string consists of optional whitespace, followed by an optional minus sign (<tt class="literal">-</tt>), followed by a number, followed by whitespace, it is converted to the floating-point value nearest to the mathematical value represented by the string. (The IEEE 754 standard defines a <tt class="literal">round-to-nearest</tt> rule; see the standard for more information.)</p>
            </li>
            <li>
              <p>Any other string is converted to the value <tt class="literal">NaN</tt> (not a number).</p>
            </li>
          </ul>
        </li>
        <li>
          <p>If the argument is any other type, it is converted to a number in a way that depends on that type. See the documentation for your XSLT processor to find out what other types are supported and how they are converted to numbers. </p>
        </li>
      </ul>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.4, Number Functions.</p>

<h4 class="refsect1">Example</h4>
<p>Here is the XML document we'll use to test the <tt class="literal">number()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>We'll test the <tt class="literal">number()</tt> function with a variety of arguments:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;


  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the number() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   number(true())=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="number(true())"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   number(false())=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="number(false())"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   number(/report/month[2]/miles-flown)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="number(/report/month[2]/miles-flown)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   number(//miles-flown)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="number(//miles-flown)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   number(/report/title)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="number(/report/title)"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>The output of our stylesheet looks like this:</p>
<blockquote><pre class="code">

Tests of the number() function:

   number(true())=1
   number(false())=0
   number(/report/month[2]/miles-flown)=32857
   number(//miles-flown)=12379
   number(/report/title)=NaN
</pre></blockquote>
</div>
<a name="INDEX-984" /><a name="INDEX-985" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>position() Function</i></b></font></td><td align="right"><i>Returns a number equal to the context position from the current context.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>position(</b></tt><tt class="userinput"><b>)</b></tt></pre></tt></p>

        
      

<h4 class="refsect1">Inputs</h4>
<p>None.</p>

<h4 class="refsect1">Output</h4>
<p>A number equal to the position of the current node in the evaluation context. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.1, Node Set Functions.</p>

<h4 class="refsect1">Examples</h4>
<p>This example uses the <tt class="literal">position()</tt> function to determine the background color of the rows of a table. The background colors cycle through the options <tt class="literal">white</tt>, <tt class="literal">darkgray</tt>, and <tt class="literal">lightgreen</tt>. Here's the XML document we'll use:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>We'll use this stylesheet to generate our HTML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="html"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;
          &lt;xsl:value-of select="/list/title"/&gt;
        &lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;
          &lt;xsl:value-of select="/list/title"/&gt;
        &lt;/h1&gt;
        &lt;table border="1"&gt;
          &lt;xsl:for-each select="/list/listitem"&gt;
            &lt;xsl:variable name="background-color"&gt;
              &lt;xsl:choose&gt;
                &lt;xsl:when test="position() mod 3 = 1"&gt;white&lt;/xsl:when&gt;
                &lt;xsl:when test="position() mod 3 = 2"&gt;darkgray&lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt;lightgreen&lt;/xsl:otherwise&gt;
              &lt;/xsl:choose&gt;
            &lt;/xsl:variable&gt;
            &lt;tr bgcolor="{$background-color}"&gt;
              &lt;td&gt;
                &lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Our stylesheet generates the following results:</p>
<blockquote><pre class="code">
&lt;html&gt;
&lt;head&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;A few of my favorite albums&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;A few of my favorite albums&lt;/h1&gt;
&lt;table border="1"&gt;
&lt;tr bgcolor="white"&gt;
&lt;td&gt;&lt;b&gt;A Love Supreme&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor="darkgray"&gt;
&lt;td&gt;&lt;b&gt;Beat Crazy&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor="lightgreen"&gt;
&lt;td&gt;&lt;b&gt;Here Come the Warm Jets&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor="white"&gt;
&lt;td&gt;&lt;b&gt;Kind of Blue&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor="darkgray"&gt;
&lt;td&gt;&lt;b&gt;London Calling&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor="lightgreen"&gt;
&lt;td&gt;&lt;b&gt;Remain in Light&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor="white"&gt;
&lt;td&gt;&lt;b&gt;The Joshua Tree&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor="darkgray"&gt;
&lt;td&gt;&lt;b&gt;The Indestructible Beat of Soweto&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
<p>When rendered, the HTML file looks like <a href="appc_01.htm">Figure C-8</a>.</p>
<a name="xslt-appc-c8" /><div class="figure"><img height="293" alt="Figure C-8" src="figs/xslt.ac08.gif" width="413" /></div><h4 class="objtitle">Figure C-8. HTML file displaying items with different background colors</h4>
</div>
<a name="INDEX-986" /><a name="INDEX-987" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>round() Function</i></b></font></td><td align="right"><i>Returns the integer closest to the argument.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>round(</b></tt><em class="replaceable">number</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      
<h4 class="refsect1">Description</h4>
<p>  If two numbers are equally close to the argument (<tt class="literal">1</tt> and <tt class="literal">2</tt> are equally close to <tt class="literal">1.5</tt>), the number closest to positive infinity is returned. Various argument values are handled as follows:</p>
<ul>
        <li>
          <p>If the argument is <tt class="literal">NaN</tt> (not a number), the <tt class="literal">round()</tt> function returns <tt class="literal">NaN</tt>. </p>
        </li>
        <li>
          <p>If the argument is positive infinity, then positive infinity is returned. </p>
        </li>
        <li>
          <p>If the argument is negative infinity, then negative infinity is returned. </p>
        </li>
        <li>
          <p>If the argument is positive zero, then positive zero is returned. </p>
        </li>
        <li>
          <p>If the argument is negative zero, then negative zero is returned. </p>
        </li>
        <li>
          <p>If the argument is between zero and -0.5, then negative zero is returned. </p>
        </li>
      </ul>

<h4 class="refsect1">Inputs</h4>
<p>A number. If the argument is not a number, it is converted to a number as if it were passed to the <tt class="literal">number()</tt> function. </p>

<h4 class="refsect1">Output</h4>
<p>The integer that is closest to the argument. Special cases are handled as described in this section. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.4, Number Functions.</p>

<h4 class="refsect1">Example</h4>
<p>The following stylesheet shows the results of invoking the <tt class="literal">round()</tt> function against a variety of values. We'll use this XML document as input:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>
<p>Here's the stylesheet that uses the <tt class="literal">round()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:months="Lookup table for month names"&gt;

  &lt;months:name sequence="01"&gt;January&lt;/months:name&gt;
  &lt;months:name sequence="02"&gt;February&lt;/months:name&gt;
  &lt;months:name sequence="03"&gt;March&lt;/months:name&gt;
  &lt;months:name sequence="04"&gt;April&lt;/months:name&gt;
  &lt;months:name sequence="05"&gt;May&lt;/months:name&gt;
  &lt;months:name sequence="06"&gt;June&lt;/months:name&gt;
  &lt;months:name sequence="07"&gt;July&lt;/months:name&gt;
  &lt;months:name sequence="08"&gt;August&lt;/months:name&gt;
  &lt;months:name sequence="09"&gt;September&lt;/months:name&gt;
  &lt;months:name sequence="10"&gt;October&lt;/months:name&gt;
  &lt;months:name sequence="11"&gt;November&lt;/months:name&gt;
  &lt;months:name sequence="12"&gt;December&lt;/months:name&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the round() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "round('7.983')" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="round('7.983')"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "round('7.5')" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="round('7.5')"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "round('-7.893')" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="round('-7.893')"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "round('-7.5')" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="round('-7.5')"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "round(/report/month[@sequence='01']/miles-flown)" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="round(/report/month[@sequence='01']/miles-flown)"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   "round(document('')/*/months:name[@sequence='02'])" = &lt;/xsl:text&gt;
    &lt;xsl:value-of select="round(document('')/*/months:name[@sequence='02'])"/&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;

    &lt;xsl:for-each select="/report/month"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of 
        select="document('')/*/months:name[@sequence=current()/@sequence]"/&gt;
      &lt;xsl:text&gt; - &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-flown, '##,###')"/&gt;
      &lt;xsl:text&gt; miles flown, &lt;/xsl:text&gt;
      &lt;xsl:value-of select="format-number(miles-earned, '##,###')"/&gt;
      &lt;xsl:text&gt; miles earned.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
      &lt;xsl:text&gt;      (Averaged &lt;/xsl:text&gt;
      &lt;xsl:value-of select="round(miles-earned div miles-flown)"/&gt;
      &lt;xsl:text&gt; miles earned for each mile flown.)&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When we process our XML document with this stylesheet, the results are:</p>
<blockquote><pre class="code">

Tests of the round() function:

   "round('7.983')" = 8
   "round('7.5')" = 8
   "round('-7.893')" = -8
   "round('-7.5')" = -7
   "round(/report/month[@sequence='01']/miles-flown)" = 12379
   "round(document('')/*/months:name[@sequence='02'])" = NaN

   January - 12,379 miles flown, 35,215 miles earned.
      (Averaged 3 miles earned for each mile flown.)

   February - 32,857 miles flown, 92,731 miles earned.
      (Averaged 3 miles earned for each mile flown.)

   March - 19,920 miles flown, 76,725 miles earned.
      (Averaged 4 miles earned for each mile flown.)

   April - 18,903 miles flown, 31,781 miles earned.
      (Averaged 2 miles earned for each mile flown.)
</pre></blockquote>
<p>You can compare these results to those from the <tt class="literal">ceiling()</tt> and <tt class="literal">floor()</tt> functions. </p>
</div>

<a name="INDEX-988" /><a name="INDEX-989" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>starts-with() Function</i></b></font></td><td align="right"><i>Determines if the first argument string begins with the second argument. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>starts-with(</b></tt><em class="replaceable">string</em><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>Two strings. </p>

<h4 class="refsect1">Output</h4>
<p>If the first string begins with the second, <tt class="literal">starts-with()</tt> returns the boolean value <tt class="literal">true</tt>; otherwise it returns <tt class="literal">false</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions. </p>

<h4 class="refsect1">Example</h4>
<p>We'll use this sample XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;title&gt;A few of my favorite albums&lt;/title&gt;
  &lt;listitem&gt;A Love Supreme&lt;/listitem&gt;
  &lt;listitem&gt;Beat Crazy&lt;/listitem&gt;
  &lt;listitem&gt;Here Come the Warm Jets&lt;/listitem&gt;
  &lt;listitem&gt;Kind of Blue&lt;/listitem&gt;
  &lt;listitem&gt;London Calling&lt;/listitem&gt;
  &lt;listitem&gt;Remain in Light&lt;/listitem&gt;
  &lt;listitem&gt;The Joshua Tree&lt;/listitem&gt;
  &lt;listitem&gt;The Indestructible Beat of Soweto&lt;/listitem&gt;
&lt;/list&gt;</pre></blockquote>
<p>This stylesheet outputs contents of all <tt class="literal">&lt;listitem&gt;</tt> elements that begin with the string "The":</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="list/listitem"&gt;
      &lt;xsl:if test="starts-with(., 'The')"&gt;
        &lt;xsl:value-of select="position()"/&gt;
        &lt;xsl:text&gt;. &lt;/xsl:text&gt;
        &lt;xsl:value-of select="."/&gt;
        &lt;xsl:value-of select="$newline"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Our stylesheet generates this result:</p>
<blockquote><pre class="code">

7. The Joshua Tree
8. The Indestructible Beat of Soweto
</pre></blockquote>
</div>
<a name="INDEX-990" /><a name="INDEX-991" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>string() Function</i></b></font></td><td align="right"><i>Returns the string value of the argument. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>string(</b></tt><em class="replaceable">object</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>

<p>An object. The object is converted to a string, as described in the following subsection. </p>

<h4 class="refsect1">Output</h4>
<p>A string. The input argument is converted to a string as follows:</p>
<ul>
        <li>
          <p>If the argument is a node-set, the first node in the node-set is converted to a string. (The first node in the node-set is the one that occurs first in document order.)</p>
        </li>
        <li>
          <p>If the argument is a number, it is converted to a string as follows:</p>
          <ul>
            <li>
              <p>The value <tt class="literal">NaN</tt> is converted to the string "NaN".</p>
            </li>
            <li>
              <p>Positive zero is converted to the string "0".</p>
            </li>
            <li>
              <p>Negative zero is converted to the string "0".</p>
            </li>
            <li>
              <p>Positive infinity is converted to the string "Infinity".</p>
            </li>
            <li>
              <p>Negative infinity is converted to the string "-Infinity".</p>
            </li>
            <li>
              <p>An integer is converted to a string representing that integer, using no decimal point and no leading zeros. If the integer is negative, it will be preceded by a minus sign (<tt class="literal">-</tt>).</p>
            </li>
            <li>
              <p>Any other number is converted to a string with a decimal point, at least one number before the decimal point, and at least one number after the decimal point. If the number is negative, it will be preceded by a minus sign (<tt class="literal">-</tt>). There will not be any leading zeros before the decimal point (with the possible exception of the one required digit before the decimal point). After the decimal point, there will be only as many digits as needed to distinguish this number from all other numeric values defined by the IEEE 754 standard, the same standard used by the Java <tt class="literal">float</tt> and <tt class="literal">double</tt> types.</p>
            </li>
          </ul>
        </li>
        <li>
          <p>If the argument is a boolean value, the value <tt class="literal">true</tt> is represented by the string "true" and the value <tt class="literal">false</tt> is represented by the string "false".</p>
        </li>
        <li>
          <p>If the argument is any other type, it is converted to a string in a way that depends on that type. See the documentation for your XSLT processor to find out what other types are supported and how they are converted to strings.</p>
        </li>
      </ul>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions.</p>

<h4 class="refsect1">Example</h4>
<p>Here is the XML document we'll use to test the <tt class="literal">string()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;test&gt;
  &lt;p&gt;This is a test XML document used by several 
  of our sample stylesheets.&lt;/p&gt;
  &lt;question&gt;
    &lt;text&gt;When completed, the Eiffel Tower was the 
    tallest building in the world.&lt;/text&gt;
    &lt;true&gt;You're correct!  The Eiffel Tower was the 
    world's tallest building until 1930.&lt;/true&gt;
    &lt;false&gt;No, the Eiffel Tower was the world's 
    tallest building for over 30 years.&lt;/false&gt;
  &lt;/question&gt;
  &lt;question&gt;
    &lt;text&gt;New York's Empire State Building knocked 
    the Eiffel Tower from its pedestal.&lt;/text&gt;
    &lt;true&gt;No, that's not correct.&lt;/true&gt;
    &lt;false&gt;Correct!  New York's Chrysler Building, 
    completed in 1930, became the world's tallest.&lt;/false&gt;
  &lt;/question&gt;
&lt;/test&gt;</pre></blockquote>
<p>We'll test the <tt class="literal">string()</tt> function with a variety of arguments:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the string() function:&lt;/xsl:text&gt;


    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string(count(/test))=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string(count(/test))"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string(count(/test/question))=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string(count(/test/question))"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string('4')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string('4')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string(true())=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string(true())"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string(false())=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string(false())"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string(count(/test/question) &gt; 5)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string(count(/test/question) &gt; 5)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Here are the string values of some &lt;text&gt; elements:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="/test/question/text"&gt;
      &lt;xsl:text&gt;   &lt;/xsl:text&gt;
      &lt;xsl:value-of select="string(.)"/&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results of our stylesheet:</p>
<blockquote><pre class="code">

Tests of the string() function:

   string(count(/test))=1
   string(count(/test/question))=2
   string('4')=4
   string(true())=true
   string(false())=false
   string(count(/test/question) &gt; 5)=false

Here are the string values of some &lt;text&gt; elements:
   When completed, the Eiffel Tower was the tallest building in the world.
   New York's Empire State Building knocked the Eiffel Tower from its pedestal.
</pre></blockquote>
</div>
<a name="INDEX-992" /><a name="INDEX-993" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>string-length() Function</i></b></font></td><td align="right"><i>Returns the number of characters in the string passed in as the argument to this function. If no argument is specified, the context node is converted to a string and the length of that string is returned.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>string-length(</b></tt><em class="replaceable">string?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>An optional string. </p>

<h4 class="refsect1">Output</h4>
<p>The number of characters defined in the string. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions.</p>

<h4 class="refsect1">Example</h4>
<p>The following example demonstrates the results of invoking the <tt class="literal">string-length()</tt> function against various argument types. Here's the XML document we'll use for our example:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;test&gt;
  &lt;p&gt;This is a test XML document used by several 
  of our sample stylesheets.&lt;/p&gt;
  &lt;question&gt;
    &lt;text&gt;When completed, the Eiffel Tower was the 
    tallest building in the world.&lt;/text&gt;
    &lt;true&gt;You're correct!  The Eiffel Tower was the 
    world's tallest building until 1930.&lt;/true&gt;
    &lt;false&gt;No, the Eiffel Tower was the world's 
    tallest building for over 30 years.&lt;/false&gt;
  &lt;/question&gt;
  &lt;question&gt;
    &lt;text&gt;New York's Empire State Building knocked 
    the Eiffel Tower from its pedestal.&lt;/text&gt;
    &lt;true&gt;No, that's not correct.&lt;/true&gt;
    &lt;false&gt;Correct!  New York's Chrysler Building, 
    completed in 1930, became the world's tallest.&lt;/false&gt;
  &lt;/question&gt;
&lt;/test&gt;</pre></blockquote>
<p>We'll process this document with the following stylesheet:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;


  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the string-length() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string-length(/test)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string-length(/test)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string-length(/true)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string-length(/true)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string-length(//true)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string-length(//true)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   string-length(//test|//true|//text)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="string-length(//test|//true|//text)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:for-each select="/test/question"&gt;
      &lt;xsl:text&gt;   Question #&lt;/xsl:text&gt;
      &lt;xsl:value-of select="position()"/&gt;
      &lt;xsl:text&gt; contains &lt;/xsl:text&gt;
      &lt;xsl:value-of select="string-length()"/&gt;
      &lt;xsl:text&gt; characters.&lt;/xsl:text&gt;
      &lt;xsl:value-of select="$newline"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Here are the results of our stylesheet:</p>
<blockquote><pre class="code">

Tests of the string-length() function:

   string-length(/test)=522
   string-length(/true)=0
   string-length(//true)=78
   string-length(//test|//true|//text)=522

   Question #1 contains 239 characters.
   Question #2 contains 203 characters.
</pre></blockquote>
<p>When we invoked the <tt class="literal">string-length()</tt> function without any arguments, the context node was converted to a string, then the length of that string was returned. The two <tt class="literal">&lt;question&gt;</tt> elements were handled this way inside the <tt class="literal">&lt;xsl:for-each&gt;</tt> element. </p>
</div>
<a name="INDEX-994" /><a name="INDEX-995" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>substring() Function</i></b></font></td><td align="right"><i>Returns a portion of a given string. The second and third arguments determine what portion of the string is returned. The second argument specifies the position of the first character of the substring, and the optional third argument specifies how many characters should be returned. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>substring(</b></tt><em class="replaceable">string</em><em class="replaceable">number</em><em class="replaceable">number?</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>The <tt class="literal">substring()</tt> function takes a string and one or two numbers as arguments. The string is the string from which the substring will be extracted. The second argument is used as the starting position of the returned substring, and the optional third argument specifies how many characters are returned.</p>

<h4 class="refsect1">Output</h4>
<p>With two arguments (a string and a starting position), the <tt class="literal">substring()</tt> function returns all characters in the string, starting with the starting position. Be aware that the first character in an XPath string is at position 1, not 0.</p>
<p>With three arguments (a string, a starting position, and a length), the <tt class="literal">substring()</tt> function returns all characters in the string whose position is greater than or equal to the starting position and whose position is less than or equal to the starting position plus the length.</p>
<p>Normally, the arguments to the <tt class="literal">substring()</tt> function are integers, although they may be more complicated expressions. See the "Example" section that follows for some unusual cases.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions.</p>

<h4 class="refsect1">Example</h4>
<p>We'll use this XML document to demonstrate how the <tt class="literal">substring()</tt> function works:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;test&gt;
  &lt;p&gt;This is a test XML document used by several 
    of our sample stylesheets.&lt;/p&gt;
  &lt;question&gt;
    &lt;text&gt;When completed, the Eiffel Tower was the 
    tallest building in the world.&lt;/text&gt;
    &lt;true&gt;You're correct!  The Eiffel Tower was the 
    world's tallest building until 1930.&lt;/true&gt;

    &lt;false&gt;No, the Eiffel Tower was the world's 
    tallest building for over 30 years.&lt;/false&gt;
  &lt;/question&gt;
  &lt;question&gt;
    &lt;text&gt;New York's Empire State Building knocked the 
    Eiffel Tower from its pedestal.&lt;/text&gt;
    &lt;true&gt;No, that's not correct.&lt;/true&gt;
    &lt;false&gt;Correct!  New York's Chrysler Building, 
    completed in 1930, became the world's tallest.&lt;/false&gt;
  &lt;/question&gt;
&lt;/test&gt;</pre></blockquote>
<p>Here's the stylesheet we'll use:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the substring() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring('Now is the time', 4)="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="substring('Now is the time', 4)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring('Now is the time', 4, 6)="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="substring('Now is the time', 4, 6)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring('Now is the time', 4, -6)="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="substring('Now is the time', 4, -6)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring('Now is the time', -3, 6)="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="substring('Now is the time', -3, 6)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring('Now is the time', 54, 6)="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="substring('Now is the time', 54, 6)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   count(//*)=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="count(//*)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring('Here is a really long string', &lt;/xsl:text&gt; 
    &lt;:xsl:text&gt;count(//*))="&lt;/xsl:text&gt;
    &lt;xsl:value-of 
      select="substring('Here is a really long string', count(//*))"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring('Here is a less long string', &lt;/xsl:text&gt;
    &lt;xsl:text&gt;count(//*) mod 7, 7)="&lt;/xsl:text&gt;
    &lt;xsl:value-of 
      select="substring('Here is a less long string', count(//*) mod 7, 7)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring(/test/question[1]/text, 3, 7)="&lt;/xsl:text&gt;
    &lt;xsl:value-of select="substring(//*, 3, 7)"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When using the Saxon processor, here are the results:</p>
<blockquote><pre class="code">

Tests of the substring() function:

   substring('Now is the time', 4)=" is the time"
   substring('Now is the time', 4, 6)=" is th"
   substring('Now is the time', 4, -6)=""
   substring('Now is the time', -3, 6)="No"
   substring('Now is the time', 54, 6)=""

   count(//*)=10
   substring('Here is a really long string', count(//*))=" really long string"
   substring('Here is a less long string', count(//*) mod 7, 7)="re is a"
   substring(/test/question[1]/text, 3, 7)=" This i"
</pre></blockquote>
<p>When running the same transformation with Xalan, we get a runtime error:</p>
<blockquote><pre class="code">
file:///D:/O'Reilly/XSLT/bookSamples/AppendixC/substringfunction.xsl; Line 26;
  Column 65;
Tests of the substring() function:


   substring('Now is the time', 4)=" is the time"
   substring('Now is the time', 4, 6)=" is th"
   substring('Now is the time', 4, -6)="
XSLT Error (javax.xml.transform.TransformerException): String index out of range
: -3</pre></blockquote>
<p>As of this writing, XT, Saxon, and Oracle's processors all gave the correct results; both Xalan and Microsoft's XSLT tools generated runtime exceptions. The lesson here is to use reasonable arguments to the <tt class="literal">substring()</tt> function so you won't be at the mercy of different implementations. </p>
</div>
<a name="INDEX-996" /><a name="INDEX-997" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>substring-after() Function</i></b></font></td><td align="right"><i>Returns the substring of the first argument after the first occurrence of the second argument in the first argument. If the second argument does not occur in the first argument, the substring-after() function returns an empty string. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>substring-after(</b></tt><em class="replaceable">string</em><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>Two strings. The first string is the string to be searched, and the second string is the string to be searched for in the first string. </p>

<h4 class="refsect1">Output</h4>
<p>The portion of the first argument that occurs after the first occurrence of the second argument. If the second argument does not appear in the first argument, the function returns an empty string. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions. </p>

<h4 class="refsect1">Example</h4>
<p>This stylesheet uses the <tt class="literal">replace-substring</tt> named template. It passes three arguments to the <tt class="literal">replace-substring</tt> template: the original string, the substring to be searched for in the original string, and the substring to replace the target substring in the original string. The <tt class="literal">replace-substring</tt> template uses the <tt class="literal">contains()</tt>, <tt class="literal">substring-after()</tt>, and <tt class="literal">substring-before()</tt> functions extensively. </p>


<p>Here is our sample stylesheet. It replaces all occurrences of <tt class="literal">World</tt> with the string "Mundo":</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:variable name="test"&gt;
      &lt;xsl:call-template name="replace-substring"&gt;
        &lt;xsl:with-param name="original"&gt;Hello World!&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="substring"&gt;World&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="replacement"&gt;Mundo&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:value-of select="$test"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="replace-substring"&gt;
    &lt;xsl:param name="original"/&gt;
    &lt;xsl:param name="substring"/&gt;
    &lt;xsl:param name="replacement" select="''"/&gt;
    &lt;xsl:variable name="first"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:value-of select="substring-before($original, $substring)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$original"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;

    &lt;xsl:variable name="middle"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:value-of select="$replacement"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:text&gt;&lt;/xsl:text&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:variable name="last"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:choose&gt;
            &lt;xsl:when test="contains(substring-after($original, $substring), 
                             $substring)"&gt;

              &lt;xsl:call-template name="replace-substring"&gt;
                &lt;xsl:with-param name="original"&gt;
                  &lt;xsl:value-of 
                    select="substring-after($original, $substring)"/&gt;
                &lt;/xsl:with-param&gt;
                &lt;xsl:with-param name="substring"&gt;
                  &lt;xsl:value-of select="$substring"/&gt;
                &lt;/xsl:with-param&gt;
                &lt;xsl:with-param name="replacement"&gt;
                  &lt;xsl:value-of select="$replacement"/&gt;
                &lt;/xsl:with-param&gt;
              &lt;/xsl:call-template&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
              &lt;xsl:value-of select="substring-after($original, $substring)"/&gt;
            &lt;/xsl:otherwise&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:text&gt;&lt;/xsl:text&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:value-of select="concat($first, $middle, $last)"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>The stylesheet produces these results, regardless of the XML document used as input:</p>
<blockquote><pre class="code">
Hello Mundo!
</pre></blockquote>
</div>
<a name="INDEX-998" /><a name="INDEX-999" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>substring-before() Function</i></b></font></td><td align="right"><i>Returns the substring of the first argument before the first occurrence of the second argument in the first argument. If the second argument does not occur in the first argument, the substring-before() function returns an empty string. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>substring-before(</b></tt><em class="replaceable">string</em><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>Two strings. The first string is the string to be searched, and the second string is the string to be searched for in the first string. </p>

<h4 class="refsect1">Output</h4>
<p>The portion of the first argument that occurs before the first occurrence of the second argument. If the second argument does not appear in the first argument, the function returns an empty string. </p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions.</p>

<h4 class="refsect1">Example</h4>
<p>This stylesheet uses the <tt class="literal">replace-substring</tt> named template. It passes three arguments to the <tt class="literal">replace-substring</tt> template: the original string, the substring to be searched for in the original string, and the substring to replace the target substring in the original string. The <tt class="literal">replace-substring</tt> template uses the <tt class="literal">contains()</tt>, <tt class="literal">substring-after()</tt>, and <tt class="literal">substring-before()</tt> functions extensively. </p>
<p>Here is our sample stylesheet. It replaces all occurrences of <tt class="literal">World</tt> with the string "Mundo":</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:variable name="test"&gt;
      &lt;xsl:call-template name="replace-substring"&gt;
        &lt;xsl:with-param name="original"&gt;Hello World!&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="substring"&gt;World&lt;/xsl:with-param&gt;
        &lt;xsl:with-param name="replacement"&gt;Mundo&lt;/xsl:with-param&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:value-of select="$test"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="replace-substring"&gt;
    &lt;xsl:param name="original"/&gt;
    &lt;xsl:param name="substring"/&gt;
    &lt;xsl:param name="replacement" select="''"/&gt;
    &lt;xsl:variable name="first"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:value-of select="substring-before($original, $substring)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$original"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:variable name="middle"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:value-of select="$replacement"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:text&gt;&lt;/xsl:text&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:variable name="last"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:choose&gt;
            &lt;xsl:when test="contains(substring-after($original, $substring), 
                                      $substring)"&gt;
              &lt;xsl:call-template name="replace-substring"&gt;
                &lt;xsl:with-param name="original"&gt;
                  &lt;xsl:value-of 
                    select="substring-after($original, $substring)"/&gt;
                &lt;/xsl:with-param&gt;
                &lt;xsl:with-param name="substring"&gt;
                  &lt;xsl:value-of select="$substring"/&gt;
                &lt;/xsl:with-param&gt;
                &lt;xsl:with-param name="replacement"&gt;
                  &lt;xsl:value-of select="$replacement"/&gt;
                &lt;/xsl:with-param&gt;
              &lt;/xsl:call-template&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
              &lt;xsl:value-of select="substring-after($original, $substring)"/&gt;
            &lt;/xsl:otherwise&gt;
          &lt;/xsl:choose&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:text&gt;&lt;/xsl:text&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:value-of select="concat($first, $middle, $last)"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>The stylesheet produces these results, regardless of the XML document used as input:</p>
<blockquote><pre class="code">
Hello Mundo!
</pre></blockquote>
</div>
<a name="INDEX-1000" /><a name="INDEX-1001" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>sum() Function</i></b></font></td><td align="right"><i>Converts all nodes in the argument node-set to numbers, and then returns the sum of all of those numbers. If any node in the node-set can't be converted to numbers (passing them to the number() function returns NaN), the sum() function returns NaN. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>number <tt class="userinput"><b>sum(</b></tt><em class="replaceable">node-set</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>A node-set. Any node in the node-set that is not a number is converted to a number as if it were passed to the <tt class="literal">number()</tt> function, then the numeric values of all of the nodes are summed. </p>

<h4 class="refsect1">Output</h4>
<p>The sum of the numeric values of all of the nodes in the argument node-set. If any node in the argument node-set cannot be converted to a number, the <tt class="literal">sum()</tt> function returns <tt class="literal">NaN</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.4, Number Functions. </p>

<h4 class="refsect1">Example</h4>
<p>We'll demonstrate the <tt class="literal">sum()</tt> function against the following XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;report&gt;
  &lt;title&gt;Miles Flown in 2001&lt;/title&gt;
  &lt;month sequence="01"&gt;
    &lt;miles-flown&gt;12379&lt;/miles-flown&gt;
    &lt;miles-earned&gt;35215&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="02"&gt;
    &lt;miles-flown&gt;32857&lt;/miles-flown&gt;
    &lt;miles-earned&gt;92731&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="03"&gt;
    &lt;miles-flown&gt;19920&lt;/miles-flown&gt;
    &lt;miles-earned&gt;76725&lt;/miles-earned&gt;
  &lt;/month&gt;
  &lt;month sequence="04"&gt;
    &lt;miles-flown&gt;18903&lt;/miles-flown&gt;
    &lt;miles-earned&gt;31781&lt;/miles-earned&gt;
  &lt;/month&gt;
&lt;/report&gt;</pre></blockquote>

<p>Here is a stylesheet that uses the <tt class="literal">sum()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the sum() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Total miles flown this year:  &lt;/xsl:text&gt;
    &lt;xsl:value-of 
      select="format-number(sum(/report/month/miles-flown), '###,###')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Total miles earned this year: &lt;/xsl:text&gt;
    &lt;xsl:value-of 
      select="format-number(sum(/report/month/miles-earned), '###,###')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>Processing the XML document with this stylesheet generates these results:</p>
<blockquote><pre class="code">

A test of the sum() function:

Total miles flown this year:  84,059

Total miles earned this year: 236,452
</pre></blockquote>
</div>
<a name="INDEX-1002" /><a name="INDEX-1003" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>system-property() Function</i></b></font></td><td align="right"><i>Returns the value of the system property named by the argument to the function.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>object <tt class="userinput"><b>system-property(</b></tt><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      
<h4 class="refsect1">Description</h4>
<p>
  By definition, all XSLT processors must support three system properties:
</p>
<dl>

          <dt><tt class="literal">xsl:version</tt></dt>

          <dd>A floating-point number representing the version of XSLT implemented by this XSLT processor. As of this writing, the only official version of XSLT supported by any XSLT processors is <tt class="literal">1.0</tt>.</p></dd>
        
        
          <dt><b>
<tt class="literal">xsl:vendor</tt>
</b></dt>
          <dd>A string that identifies the vendor of this XSLT processor.</p></dd>
        
        
          <dt><b>
<tt class="literal">xsl:vendor-url</tt>
</b></dt>
          <dd>A string containing the URL identifying the vendor of the XSLT processor. This string is typically the home page of the vendor's web site.</p></dd>
        
      </dl>
<h4 class="refsect1">Inputs</h4>

<p>  
The XSLT 1.0 specification defines three properties: <tt class="literal">xsl:version</tt>, <tt class="literal">xsl:vendor</tt>, and <tt class="literal">xsl:vendor-url</tt>. These properties must be supported by all XSLT processors. Other properties may be supported by individual processors; check your processor's documentation for more information.</p>

<h4 class="refsect1">Output</h4>
<p>The value of the queried property. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.4, Miscellaneous Additional Functions. </p>

<h4 class="refsect1">Example</h4>
<p>Here is a stylesheet that queries different properties of the XSLT processor:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  
  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:text&gt;xsl:version = "&lt;/xsl:text&gt;
    &lt;xsl:value-of select="system-property('xsl:version')"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;xsl:vendor = "&lt;/xsl:text&gt;
    &lt;xsl:value-of select="system-property('xsl:vendor')"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;xsl:vendor-url = "&lt;/xsl:text&gt;

    &lt;xsl:value-of select="system-property('xsl:vendor-url')"/&gt;
    &lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>

<p>When the stylesheet is applied toward any XML document with the Xalan XSLT processor (invoked by the following command):</p>

<blockquote><pre class="code">
java org.apache.xalan.xslt.Process -in test1.xml -xsl systemproperties.xsl</pre></blockquote>

<p>The results are:</p>
<blockquote><pre class="code">
xsl:version = "1"
xsl:vendor = "Apache Software Foundation"
xsl:vendor-url = "http://xml.apache.org/xalan"
</pre></blockquote>

<p>The following command invokes the results for Michael Kay's Saxon processor:</p>

<blockquote><pre class="code">
java com.icl.saxon.StyleSheet test1.xml systemproperties.xsl</pre></blockquote>

<p>Here are the results:</p>

<blockquote><pre class="code">
xsl:version = "1"                                                      
xsl:vendor = "SAXON 6.4.3 from Michael Kay"                     
xsl:vendor-url = "http://saxon.sourceforge.net"</pre></blockquote>

<p>We invoked Oracle's XML parser with:</p>

<blockquote><pre class="code">
java oracle.xml.parser.v2.oraxsl test1.xml systemproperties.xsl</pre></blockquote>

<p>Here are the results:</p>
<blockquote><pre class="code">
xsl:version = "1"
xsl:vendor = "Oracle Corporation."
xsl:vendor-url = "http://www.oracle.com"</pre></blockquote>
<p>We invoked James Clark's XT processor with:</p> 

<blockquote><pre class="code">
java com.jclark.xsl.sax.Driver test1.xml systemproperties.xsl</pre></blockquote>

<p>Here are the results:</p>
<blockquote><pre class="code">
xsl:version = "1"
xsl:vendor = "James Clark"
xsl:vendor-url = "http://www.jclark.com/"
</pre></blockquote>
<p>Finally, we invoked Microsoft's XSLT processor with:</p>

<h4 class="refsect1">Synopsis</h4><p><tt>msxsl test1.xml systemproperties.xsl</pre></tt></p>

<p>Here are the results:</p>
<blockquote><pre class="code">
xsl:version = "1"
xsl:vendor = "Microsoft"
xsl:vendor-url = "http://www.microsoft.com"</pre></blockquote>

</div>
<a name="INDEX-1004" /><a name="INDEX-1005" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>translate() Function</i></b></font></td><td align="right"><i>Allows you to convert individual characters in a string from one value to another. In many languages, this function is powerful enough to convert characters from one case to another. </i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>translate(</b></tt><em class="replaceable">string</em><em class="replaceable">string</em><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>Three strings. The first is the original, untranslated string, and the second and third strings define the characters to be converted. </p>

<h4 class="refsect1">Output</h4>
<p>The original string, translated as follows:</p>
<ul>
        <li>
          <p>If a character in the original string appears in the second argument string, it is replaced with the corresponding character in the third argument string. In other words, if the character <tt class="literal">J</tt> appears in the original string and <tt class="literal">J</tt> appears as the fourth character in the second argument string, the <tt class="literal">J</tt> is replaced with the fourth character from the third argument string. (Don't worry, we'll have some examples to clear this up in just a minute.)</p>
        </li>
        <li>
          <p>If a character in the original string appears in the second argument string and there is no corresponding character in the third argument string (the second argument string is longer than the third), then that character is deleted. In other words, if the character <tt class="literal">J</tt> appears in the original string, and <tt class="literal">J</tt> appears as the fourth character in the second argument string, and the third argument string is three characters long, the <tt class="literal">J</tt> is deleted. </p>
        </li>
        <li>
          <p>If a character in the second argument string appears more than once, the first occurrence determines the replacement character.</p>
        </li>
        <li>
          <p>If the third argument string is longer than the second argument string, the extra characters are ignored. </p>
        </li>
      </ul>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.2, String Functions. </p>

<h4 class="refsect1">Example</h4>
<p>Here's a stylesheet with several examples of the <tt class="literal">translate()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Tests of the translate() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Convert a string to uppercase:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   translate('Doug', 'abcdefghijklmnopqrstuvwxyz', &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;             'ABCDEFGHIJKLMNOPQRSTUVWXYZ')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="translate('Doug', 
      'abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Convert a string to lowercase:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   translate('Doug', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;             'abcdefghijklmnopqrstuvwxyz')=&lt;/xsl:text&gt;
    &lt;xsl:value-of 
      select="translate('Doug', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 
                        'abcdefghijklmnopqrstuvwxyz')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Remove parentheses, spaces, and dashes&lt;/xsl:text&gt;
    &lt;xsl:text&gt; from a U.S. phone number:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   translate('(555) 555-1212', '() -', '')=&lt;/xsl:text&gt;
    &lt;xsl:value-of select="translate('(555) 555-1212', '() -', '')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;Replace all but the last four digits of a &lt;/xsl:text&gt;
    &lt;xsl:text&gt;credit card number with Xs:&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:variable name="credit" select="'4918 3829 9920 1810'"/&gt;
    &lt;xsl:text&gt;   $credit='&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$credit"/&gt;
    &lt;xsl:text&gt;'&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   translate(substring($credit, 1, 15), &lt;/xsl:text&gt;
    &lt;xsl:text&gt;'1234567890 ', 'XXXXXXXXXX-')&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   substring($credit, 16)&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   The first part is &lt;/xsl:text&gt;
    &lt;xsl:value-of 
      select="translate(substring($credit, 1, 15), '123457890 ', 
        'XXXXXXXXX-')"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   The second part is &lt;/xsl:text&gt;
    &lt;xsl:value-of select="substring($credit, 16)"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   Here's how they look together: &lt;/xsl:text&gt;
    &lt;xsl:value-of 
      select="translate(substring($credit, 1, 15), '123457890 ', 
        'XXXXXXXXX-')"/&gt;
    &lt;xsl:value-of select="substring($credit, 16)"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When we use this stylesheet with any XML document, here are the results:</p>
<blockquote><pre class="code">

Tests of the translate() function:

Convert a string to uppercase:
   translate('Doug', 'abcdefghijklmnopqrstuvwxyz',
             'ABCDEFGHIJKLMNOPQRSTUVWXYZ')=DOUG

Convert a string to lowercase:
   translate('Doug', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
             'abcdefghijklmnopqrstuvwxyz')=doug

Remove parentheses, spaces, and dashes from a U.S. phone number:
   translate('(555) 555-1212', '() -', '')=5555551212

Replace all but the last four digits of a credit card number with Xs:
   $credit='4918 3829 9920 1810'
   translate(substring($credit, 1, 15), '1234567890 ', 'XXXXXXXXXX-')
   substring($credit, 16)

   The first part is XXXX-XXXX-XXXX-
   The second part is 1810

   Here's how they look together: XXXX-XXXX-XXXX-1810
</pre></blockquote>
</div>
<a name="INDEX-1006" /><a name="INDEX-1007" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>true() Function</i></b></font></td><td align="right"><i>Always returns the boolean value true.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>boolean <tt class="userinput"><b>true(</b></tt><tt class="userinput"><b>)</b></tt></pre></tt></p>

        
      

<h4 class="refsect1">Inputs</h4>
<p>None.</p>

<h4 class="refsect1">Output</h4>
<p>The boolean value <tt class="literal">true</tt>.</p>

<h4 class="refsect1">Defined in</h4>
<p>XPath section 4.3, Boolean Functions.</p>

<h4 class="refsect1">Example</h4>
<p>Here's a brief example that uses the <tt class="literal">true()</tt> function:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the true() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="true()"&gt;
        &lt;xsl:text&gt;   "true()"   returned true!&lt;/xsl:text&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:text&gt;   "true()"   returned false!&lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></blockquote>

<p>When using this stylesheet against any XML document, it generates this less-than-exciting result:</p>
<blockquote><pre class="code">

A test of the true() function:

   "true()"   returned true!
</pre></blockquote>
</div>
<a name="INDEX-1008" /><a name="INDEX-1009" /><a name="INDEX-1010" /><a name="INDEX-1011" /><a name="INDEX-1012" /><a name="INDEX-1013" /><a name="INDEX-1014" /><div class="refentry"><table width="684" border="0" cellpadding="5"><tr><td valign="top" width="30%" align="left"><font size="+1"><b><i>unparsed-entity-uri() Function</i></b></font></td><td align="right"><i>Returns the URI of the unparsed entity with the specified name. If there is no such entity, unparsed-entity-uri returns an empty string.</i></td></tr></table><hr width="684" size="3" noshade="true" align="left" color="black" /><table width="684" border="0" cellpadding="5"><tr><td align="left" /><td align="right" /></tr></table><h4 class="refsect1">Synopsis</h4><p><tt>string <tt class="userinput"><b>unparsed-entity-uri(</b></tt><em class="replaceable">string</em><tt class="userinput"><b>)</b></tt></pre></tt></p>
        
      

<h4 class="refsect1">Inputs</h4>
<p>The name of the unparsed entity.</p>

<h4 class="refsect1">Output</h4>
<p>The URI of the unparsed entity with the specified name. </p>

<h4 class="refsect1">Defined in</h4>
<p>XSLT section 12.4, Miscellaneous Additional Functions. </p>

<h4 class="refsect1">Example</h4>

<p>Unparsed entities are rarely used; they refer to non-XML data, as in the entity <tt class="literal">author-picture</tt> in this XML document:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE book [
  &lt;!ENTITY author-picture SYSTEM "dougtidwell.jpg" NDATA JPEG&gt;
]&gt;
&lt;book&gt;
  &lt;prolog cover-image="author-picture"/&gt;
  &lt;body&gt;
    &lt;p&gt;Pretend that lots of useful content appears here.&lt;/p&gt;
  &lt;/body&gt;
&lt;/book&gt;</pre></blockquote>
<p>We'll use this stylesheet to process our unparsed entity:</p>
<blockquote><pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="text"/&gt;

  &lt;xsl:variable name="newline"&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;A test of the unparsed-entity-uri() function:&lt;/xsl:text&gt;

    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:value-of select="$newline"/&gt;
    &lt;xsl:text&gt;   The cover image is located at &lt;/xsl:text&gt;
    &lt;xsl:value-of select="unparsed-entity-uri(/book/prolog/@cover-image)"/&gt;
    &lt;xsl:text&gt;.&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$newline"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></blockquote>
<p>When we transform the XML document with our stylesheet, the results look like this:</p>
<blockquote><pre class="code">

A test of the unparsed-entity-uri() function:

   The cover image is located at file:///D:/O'Reilly/dougtidwell.jpg.

</pre></blockquote>
<p>The URI of the unparsed entity is based on the base URI of the XML document itself.
<a name="INDEX-1009" />
<a name="INDEX-1010" />
<a name="INDEX-1011" />
<a name="INDEX-1012" />
<a name="INDEX-1013" />

</p>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="appb_06.htm"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="appd_01.htm"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">B.6. The XPath Context</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">D. XSLT Guide</td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="../jxslt/index.htm"><area shape="rect" coords="466,1,533,112" href="index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm">
      </map>

</body></html>
