<html><head><title>Another Servlet Example (Java and XSLT)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Eric M. Burke" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596001453L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Java and XSLT" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Java and XSLT" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch06_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch06_04.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>



<h2 class="sect1">6.3. Another Servlet Example</h2>

<p>In our next example, the <a name="INDEX-669" />servlet will utilize DOM and
XSLT to create its web pages. This achieves our goal of separation
between data and presentation, making it possible to fully customize
the HTML output without making any changes to the Java code. Although
an XML approach makes the code more complex for a small example
program such as this, the benefits quickly outweigh the costs as web
applications get more sophisticated. The same is true for an
Enterprise JavaBeans approach. For a trivial program, the
configuration requirements seem very complex; but as the application
complexity increases, the benefits of a sophisticated architecture
become obvious.
</p>

<p>Our program will consist of two web pages, allowing visitors to enter
personal information. The first page will prompt for their name,
phone, and email, and the second page will display a summary of the
data that was entered. The first page does validation, forcing the
user to enter all of the required fields.
</p>

<a name="javaxslt-CHP-6-SECT-3.1" /><div class="sect2">
<h3 class="sect2">6.3.1. Design</h3>

<p><a name="INDEX-670" />The
primary goal of this small application is to demonstrate how to use
XSLT from a servlet. Specifically, JAXP will be used with DOM to
create some dynamic XML data, then XSLT stylesheets will be used to
transform that data into HTML. The design is presented in <a href="ch06_03.htm">Figure 6-4</a>. 
</p>

<a name="javaxslt-CHP-6-FIG-4" /><div class="figure"><img src="figs/jxt_0604.gif" alt="Figure 6-4" width="425" height="280" /></div><h4 class="objtitle">Figure 6-4. Personal data design</h4>

<p>As <a href="ch06_03.htm">Figure 6-4</a> shows,
<tt class="literal">PersonalDataServlet</tt><a name="INDEX-671" />
is a subclass of <tt class="literal">HttpServlet</tt>. This servlet
overrides both <tt class="literal">doGet( )</tt> and <tt class="literal">doPost(
)</tt>. When the visitor first visits this web site, an HTTP GET
request causes the <tt class="literal">doGet(
)</tt><a name="INDEX-672" />
<a name="INDEX-673" /> method to be called, which shows a form
that allows the user to enter his or her information. When they hit
the submit button on the web page, the <tt class="literal">doPost(
)</tt><a name="INDEX-674" />
<a name="INDEX-675" /> method validates all form fields and shows
the confirmation page if everything is valid. If one or more fields
are missing, the form is redisplayed with an error message.
</p>

<p>The <tt class="literal">PersonalData</tt><a name="INDEX-676" /> class simply holds data that the user has
entered, and is located via the <tt class="literal">HttpSession</tt>. Each
visitor gets his or her own copy of <tt class="literal">HttpSession</tt>,
therefore they get their own copy of <tt class="literal">PersonalData</tt>.
In order to convert this data to XML, a separate helper class called
<tt class="literal">PersonalDataXML</tt><a name="INDEX-677" /> was created.
</p>

<p>The decision to use a separate helper class for XML generation was
not arbitrary. Many people like to put code directly into classes
like <tt class="literal">PersonalData</tt>, such as a <tt class="literal">getXML(
)</tt> method, that performs this task. By placing the XML
generation logic into a totally separate class, however, it will be
easier to migrate to a technology like JDOM without breaking current
clients in any way. A new class called
<tt class="literal">PersonalDataJDOM</tt> could be added to the system
while preserving all of the existing code. This approach also keeps
the <tt class="literal">PersonalData</tt> class smaller, since all it has
to do is hang on to the data.
</p>

<p>The first web page is shown in <a href="ch06_03.htm">Figure 6-5</a>. As you
can see, required fields are marked with an asterisk (*). This screen
is rendered using
<em class="filename">editPersonalData.xslt</em><a name="INDEX-678" />.
</p>

<a name="javaxslt-CHP-6-FIG-5" /><div class="figure"><img src="figs/jxt_0605.gif" alt="Figure 6-5" width="355" height="343" /></div><h4 class="objtitle">Figure 6-5. Blank personal information form</h4>

<p><a href="ch06_03.htm">Figure 6-6</a> shows how this same screen looks after
the user clicks on the Submit button. If data is missing, an error
message is displayed in red and required fields are marked in bold.
Any other error messages are also displayed in red. This view is also
rendered using <tt class="literal">editPersonalData.xslt</tt>.
</p>

<a name="javaxslt-CHP-6-FIG-6" /><div class="figure"><img src="figs/jxt_0606.gif" alt="Figure 6-6" width="357" height="341" /></div><h4 class="objtitle">Figure 6-6. Personal information form with errors</h4>

<p>Once all of the data has been entered properly, the screen shown in
<a href="ch06_03.htm">Figure 6-7</a> is displayed. Unlike the previous
examples, this screen is rendered using
<em class="filename">confirmPersonalData.xslt</em>. To make changes to any
of these screens, one needs to edit only the appropriate
stylesheet.<a name="INDEX-679" /> 
</p>

<a name="javaxslt-CHP-6-FIG-7" /><div class="figure"><img src="figs/jxt_0607.gif" alt="Figure 6-7" width="357" height="302" /></div><h4 class="objtitle">Figure 6-7. Confirmation page</h4>

</div>
<a name="javaxslt-CHP-6-SECT-3.2" /><div class="sect2">
<h3 class="sect2">6.3.2. XML and Stylesheets</h3>

<p><a name="INDEX-680" /> <a name="INDEX-681" />Deciding how to structure your XML
can have significant impact on your ability to customize the output
of a web application. In our current example, the same XML file is
used for all web pages. This XML is shown in <a href="ch06_03.htm">Example 6-3</a>. 
</p>

<a name="javaxslt-CHP-6-EX-3" /><div class="example">
<h4 class="objtitle">Example 6-3. Example XML output </h4>
<blockquote><pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;page&gt;
  &lt;!-- the next element is optional: --&gt;
  &lt;!-- &lt;requiredFieldsMissing/&gt; --&gt;
  &lt;personalData&gt;
    &lt;firstName required="true"&gt;Eric&lt;/firstName&gt;
    &lt;lastName required="true"&gt;Burke&lt;/lastName&gt;
    &lt;daytimePhone required="true"&gt;636-123-4567&lt;/daytimePhone&gt;
    &lt;eveningPhone/&gt;
    &lt;email required="true"&gt;burke_e@yahoo.com&lt;/email&gt;
  &lt;/personalData&gt;
&lt;/page&gt;</pre></blockquote>
</div>

<p>As you can see, the XML is very minimal. None of the captions, such
as <tt class="literal">"First</tt> <tt class="literal">Name:"</tt>, are included,
because they are all specified in the XSLT stylesheets. Even the
asterisk character (*) is omitted, giving the XSLT author complete
control over how things are rendered. The XML is used only for data,
so you can use the stylesheets to include graphics, render the output
in a foreign language, or combine page fragments from other sources,
such as headers and footers, into your web pages.
</p>

<p>The
<tt class="literal">&lt;requiredFieldsMissing/&gt;</tt><a name="INDEX-682" />
<a name="INDEX-683" /> element is
optional. If omitted, the XSLT stylesheet will not display error
messages about missing fields. This is useful when the data is
generated the first time because all fields will be blank, and you
probably don't want to show a bunch of error messages. In our
servlet, the <tt class="literal">doGet( )</tt> method is called when the
user first requests this web page, so it is here where we disable
this element.
</p>

<p>It is important to mention that this XML is used only for
documentation purposes and for testing the XSLT stylesheets. Once you
move into a production environment, the XML will be generated
dynamically using the <tt class="literal">PersonalData</tt> and
<tt class="literal">PersonalDataXML</tt> classes, so this static file will
not be required. You will probably want to hang on to your static
XML, however, as this will make it easier to experiment with changes
to the XSLT.
</p>

<p>The XSLT stylesheet that creates the HTML form is shown in <a href="ch06_03.htm">Example 6-4</a>. The stylesheets are substantially longer than
the XML data, which is typical. In a more simplistic approach to
servlet development, all of this logic would be hardcoded into the
source code as a series of <tt class="literal">println( )</tt> statements,
making the servlet much larger and less flexible.<a name="INDEX-684" />
<a name="INDEX-685" />
</p>

<a name="javaxslt-CHP-6-EX-4" /><div class="example">
<h4 class="objtitle">Example 6-4. editPersonalData.xslt </h4>
<blockquote><pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0" 
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/&gt;
  &lt;!--

  ***************************************************************
  ** Top level template. Creates the framework for the XHTML page
  ************************************************************--&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;&lt;title&gt;Edit Personal Information&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates select="page/personalData"/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;!--

  ***************************************************************
  ** Match the &lt;personalData&gt; element.
  ************************************************************--&gt;
  &lt;xsl:template match="personalData"&gt;
    &lt;h3&gt;Personal Information&lt;/h3&gt;
    &lt;xsl:if test="../requiredFieldsMissing"&gt;
      &lt;div style="color: red; font-size: larger;"&gt;
        Error: one or more required fields are missing.
      &lt;/div&gt;
    &lt;/xsl:if&gt;
    &lt;i&gt;Fields marked with (*) are required.&lt;/i&gt;
    &lt;form action="/chap6/personalData" method="post"&gt;
      &lt;table border="0" cellpadding="2" cellspacing="0"&gt;
        &lt;!-- Select all immediate children, such as firstName,
             lastName, daytimePhone, etc... --&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/table&gt;
      &lt;div align="center"&gt;
        &lt;hr/&gt;
        &lt;input type="submit" name="submitBtn" value="Submit"/&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/xsl:template&gt;
  &lt;!--

  ***************************************************************
  ** Output a new row in the table for each field.
  ************************************************************--&gt;
  &lt;xsl:template 
      match="firstName|lastName|daytimePhone|eveningPhone|email"&gt;
    &lt;tr&gt;
      &lt;xsl:if test="@required='true'
                    and ../../requiredFieldsMissing
                    and .=''"&gt;
        &lt;xsl:attribute name="style"&gt;
          &lt;xsl:text&gt;color:red; font-weight:bold;&lt;/xsl:text&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;td&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="name( )='firstName'"&gt;
            First Name:&lt;/xsl:when&gt;
          &lt;xsl:when test="name( )='lastName'"&gt;
            Last Name:&lt;/xsl:when&gt;
          &lt;xsl:when test="name( )='daytimePhone'"&gt;
            Daytime Phone:&lt;/xsl:when&gt;
          &lt;xsl:when test="name( )='eveningPhone'"&gt;
            Evening Phone:&lt;/xsl:when&gt;
          &lt;xsl:when test="name( )='email'"&gt;
            Email:&lt;/xsl:when&gt;
        &lt;/xsl:choose&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;input type="text" name="{name( )}" value="{.}"/&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:if test="@required='true'"&gt;*&lt;/xsl:if&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></blockquote>
</div>

<p><a name="INDEX-686" />
<a name="INDEX-687" />The
first seven lines of <em class="filename">editPersonalData.xslt</em>
contain boilerplate code that configures the XSLT processor to
produce XHTML 1.0 using the transitional DTD. In particular, our
result tree uses the <tt class="literal">&lt;i&gt;...&lt;/i&gt;</tt> tag,
so we cannot use the XHTML strict DTD. The top level template matches
the <tt class="literal">"/"</tt> pattern as usual, outputting the framework
for the XHTML document.
</p>

<p>The next template matches the <tt class="literal">&lt;personalData&gt;</tt>
element, producing a heading followed by an optional error message.
The error message is displayed if the XML data contains the
<tt class="literal">&lt;requiredFieldsMissing/&gt;</tt> element, which is
easily determined via the <tt class="literal">&lt;xsl:if&gt;</tt> element:
</p>

<blockquote><pre class="code">&lt;xsl:template match="personalData"&gt;
  &lt;h3&gt;Personal Information&lt;/h3&gt;
  &lt;xsl:if test="../requiredFieldsMissing"&gt;
    &lt;div style="color: red; font-size: larger;"&gt;
      Error: one or more required fields are missing.
    &lt;/div&gt;
  &lt;/xsl:if&gt;</pre></blockquote>

<p>This template then produces the <tt class="literal">&lt;form&gt;</tt>
element, which specifies that HTTP POST should be used to submit the
information. The <tt class="literal">action</tt> attribute indicates that
this form will send its data to our servlet. As you will see, the
form action<a href="#FOOTNOTE-24">[24]</a> matches the URL pattern that we will set up in the
deployment descriptor later in this chapter:
</p><blockquote class="footnote"> <a name="FOOTNOTE-24" /><p> [24] To avoid hardcoding the form action in
the XSLT stylesheet, pass it as a stylesheet parameter.</p>
</blockquote>

<blockquote><pre class="code">&lt;i&gt;Fields marked with (*) are required.&lt;/i&gt;
&lt;form action="/chap6/personalData" method="post"&gt;</pre></blockquote>

<p>The template finally produces a table so that all of the headings and
text fields are properly aligned. As in earlier stylesheet examples,
this template creates the table, while another template creates each
row in the table:
</p>

<blockquote><pre class="code">&lt;table border="0" cellpadding="2" cellspacing="0"&gt;
  &lt;!-- Select all immediate children, such as firstName,
       lastName, daytimePhone, etc... --&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/table&gt;
&lt;div align="center"&gt;
  &lt;hr/&gt;
  &lt;input type="submit" name="submitBtn" value="Submit"/&gt;
&lt;/div&gt;
&lt;/form&gt;
&lt;/xsl:template&gt;</pre></blockquote>

<p>Since this particular instance of
<tt class="literal">&lt;xsl:apply-templates/&gt;</tt> does not utilize the
<tt class="literal">select</tt> attribute, all child elements will be
selected. The next template is designed to match each of the possible
types of elements that can appear and will be instantiated once for
each occurrence of <tt class="literal">&lt;firstName&gt;</tt>,
<tt class="literal">&lt;lastName&gt;</tt>, etc.:
</p>

<blockquote><pre class="code">&lt;xsl:template 
    match="firstName|lastName|daytimePhone|eveningPhone|email"&gt;</pre></blockquote>

<p>This template first produces a <tt class="literal">&lt;tr&gt;</tt> element.
If this particular element has a <tt class="literal">required="true"</tt>
attribute, the XML data contains
<tt class="literal">&lt;requiredFieldsMissing/&gt;</tt>. The value of this
element is an empty string, the font is changed to bold and red. This
indicates to the user that a required field was missing. The font
weight and color are inserted as the <tt class="literal">style</tt>
attribute on the <tt class="literal">&lt;tr&gt;</tt> element as follows:
</p>

<blockquote><pre class="code">&lt;tr&gt;
  &lt;xsl:if test="@required='true'
                and ../../requiredFieldsMissing
                and .=''"&gt;
    &lt;xsl:attribute name="style"&gt;
      &lt;xsl:text&gt;color:red; font-weight:bold;&lt;/xsl:text&gt;
    &lt;/xsl:attribute&gt;
  &lt;/xsl:if&gt;</pre></blockquote>

<p>The template then produces its first <tt class="literal">&lt;td&gt;</tt>
tag, which contains the caption for the current field. It would be
nice if XSLT offered a lookup table mechanism for situations such as
this, but <tt class="literal">&lt;xsl:choose&gt;</tt> does get the job
done:
</p>

<blockquote><pre class="code">&lt;td&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="name( )='firstName'"&gt;
      First Name:&lt;/xsl:when&gt;
    &lt;xsl:when test="name( )='lastName'"&gt;
      Last Name:&lt;/xsl:when&gt;
    &lt;xsl:when test="name( )='daytimePhone'"&gt;
      Daytime Phone:&lt;/xsl:when&gt;
    &lt;xsl:when test="name( )='eveningPhone'"&gt;
      Evening Phone:&lt;/xsl:when&gt;
    &lt;xsl:when test="name( )='email'"&gt;
      Email:&lt;/xsl:when&gt;
  &lt;/xsl:choose&gt;
&lt;/td&gt;</pre></blockquote>

<p>This is still better than hardcoding the captions into the XML or
servlet because we can make changes to the stylesheet without
recompiling anything. You can even change the captions to a foreign
language without affecting any of the Java code, offering remarkable
flexibility to web page designers.
</p>

<a name="javaxslt-CHP-6-SIDEBAR-1" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">Design Choices</h4>
&nbsp;
<p><a name="INDEX-688" />The two stylesheets,
<em class="filename">editPersonalData.xslt</em> and
<em class="filename">confirmPersonalData.xslt</em>, had a lot in common.
To keep things simple, they were written as two independent
stylesheets. This is not the only way to implement this code,
however. For instance, we could have searched for common
functionality and included that functionality from both stylesheets
using <tt class="literal">&lt;xsl:import&gt;</tt> or
<tt class="literal">&lt;xsl:include&gt;</tt>. This approach did not work
here because, although the stylesheets were structured similarly,
each template produced different output. As the web site gets more
sophisticated, however, you will begin to encounter common page
elements such as navigation bars that should not be duplicated in
multiple places.
</p>
&nbsp;
<p>Another approach would be to combine both stylesheets into a single
stylesheet and pass a top-level parameter indicating whether to use
"edit" mode or "confirm" mode. In this
approach, the servlet would pass the parameter to the stylesheet via
JAXP's <tt class="literal">Transformer</tt> class and the
<tt class="literal">&lt;xsl:param&gt;</tt> element. Inside of the
stylesheet, we would write lots of
<tt class="literal">&lt;xsl:choose&gt;</tt> or
<tt class="literal">&lt;xsl:if&gt;</tt> elements to control the output
based on the value of the parameter. The JAXP code would look
something like this:
</p>
&nbsp;
<blockquote><pre class="code">javax.xml.transform.Transformer trans = ...
trans.setParameter("personalDataMode", "edit");</pre></blockquote>
&nbsp;
<p>While this approach has its place, it did not make sense for this
particular example because every template produced different output.
It would have resulted in a more complex solution than simply writing
two separate stylesheets. On the other hand, if you encounter a
situation where several web pages are almost identical except for a
small section that changes, passing a stylesheet parameter is
probably the way to go, because you only have to write the
conditional logic around the section that changes.
</p>
</td></tr></table><p></blockquote>

<p>The next column in the table contains the input field:</p>

<blockquote><pre class="code">&lt;td&gt;
  &lt;input type="text" name="{name( )}" value="{.}"/&gt;
&lt;/td&gt;</pre></blockquote>

<p>In the XHTML output, this yields a cell containing <tt class="literal">&lt;input
type="text"</tt> <tt class="literal">name="firstName"
value="Eric"/&gt;</tt>. Finally, the last column in the table
contains an asterisk if the field has the
<tt class="literal">required="true"</tt> attribute:
</p>

<blockquote><pre class="code">&lt;td&gt;
  &lt;xsl:if test="@required='true'"&gt;*&lt;/xsl:if&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:template&gt;</pre></blockquote>

<p>The next stylesheet, <em class="filename">confirmPersonalData.xslt</em>,
is listed in <a href="ch06_03.htm">Example 6-5</a>. This stylesheet is shorter
because it shows only a summary of what the user entered on the
previous page. It does not have to display any error messages or show
an HTML form. The overall structure of the stylesheet is identical to
<em class="filename">editPersonalData.xslt</em>, however, so a
line-by-line description is not
necessary.<a name="INDEX-689" />
<a name="INDEX-690" />
</p>

<a name="javaxslt-CHP-6-EX-5" /><div class="example">
<h4 class="objtitle">Example 6-5. confirmPersonalData.xslt </h4>
<blockquote><pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0" 
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;xsl:output method="xml" indent="yes" encoding="UTF-8"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"/&gt;
  &lt;!--

  ***************************************************************
  ** Top level template. Creates the framework for the XHTML page
  ************************************************************--&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Personal Data Summary&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates select="page/personalData"/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;!--

  ***************************************************************
  ** Match the &lt;personalData&gt; element.
  ************************************************************--&gt;
  &lt;xsl:template match="personalData"&gt;
    &lt;h2&gt;Thank You!&lt;/h2&gt;
    &lt;h3&gt;Your Information...&lt;/h3&gt;
    
    &lt;table border="0" cellpadding="2" cellspacing="0"&gt;
      &lt;!-- Select all immediate children, such as firstName,
           lastName, daytimePhone, etc... --&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;a href="/chap6/personalData"&gt;Click here 
         to edit this information...&lt;/a&gt;&lt;/p&gt;    

  &lt;/xsl:template&gt;
  &lt;!--

  ***************************************************************
  ** Output a new row in the table for each field.
  ************************************************************--&gt;
  &lt;xsl:template
    match="firstName|lastName|daytimePhone|eveningPhone|email"&gt;
  
    &lt;tr&gt;
      &lt;td&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="name( )='firstName'"&gt;
            First Name:&lt;/xsl:when&gt;
          &lt;xsl:when test="name( )='lastName'"&gt;
            Last Name:&lt;/xsl:when&gt;
          &lt;xsl:when test="name( )='daytimePhone'"&gt;
            Daytime Phone:&lt;/xsl:when&gt;
          &lt;xsl:when test="name( )='eveningPhone'"&gt;
            Evening Phone:&lt;/xsl:when&gt;
          &lt;xsl:when test="name( )='email'"&gt;
            Email:&lt;/xsl:when&gt;
        &lt;/xsl:choose&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></blockquote>
</div>

</div>
<a name="javaxslt-CHP-6-SECT-3.3" /><div class="sect2">
<h3 class="sect2">6.3.3. Source Code</h3>

<p>The first piece of source code to examine is shown in <a href="ch06_03.htm">Example 6-6</a>. The
<tt class="literal">PersonalData</tt><a name="INDEX-691" /> class is simply a data holder and does
not contain any XML code or database code. By keeping classes like
this simple, you can easily write standalone unit tests that verify
if your code is written properly. If this code were written as part
of the servlet instead of a standalone class, it would be very
difficult to test outside of the web browser environment.<a name="INDEX-692" />
</p>

<a name="javaxslt-CHP-6-EX-6" /><div class="example">
<h4 class="objtitle">Example 6-6. PersonalData.java </h4>
<blockquote><pre class="code">package chap6;

/**
 * A helper class that stores personal information. XML generation
 * is intentionally left out of this class. This class ensures
 * that its data cannot be null, nor can it contain extra
 * whitespace.
 */
public class PersonalData {
    private String firstName;
    private String lastName;
    private String daytimePhone;
    private String eveningPhone;
    private String email;

    public PersonalData( ) {
        this("", "", "", "", "");
    }

    public PersonalData(String firstName, String lastName,
            String daytimePhone, String eveningPhone, String email) {
        this.firstName = cleanup(firstName);
        this.lastName = cleanup(lastName);
        this.daytimePhone = cleanup(daytimePhone);
        this.eveningPhone = cleanup(eveningPhone);
        this.email = cleanup(email);
    }

    /**
     * &lt;code&gt;eveningPhone&lt;/code&gt; is the only optional field.
     *
     * @return true if all required fields are present.
     */
    public boolean isValid( ) {
        return this.firstName.length( ) &gt; 0
                &amp;&amp; this.lastName.length( ) &gt; 0
                &amp;&amp; this.daytimePhone.length( ) &gt; 0
                &amp;&amp; this.email.length( ) &gt; 0;
    }

    public void setFirstName(String firstName) {
        this.firstName = cleanup(firstName);
    }

    public void setLastName(String lastName) {
        this.lastName = cleanup(lastName);
    }

    public void setDaytimePhone(String daytimePhone) {
        this.daytimePhone = cleanup(daytimePhone);
    }

    public void setEveningPhone(String eveningPhone) {
        this.eveningPhone = cleanup(eveningPhone);
    }

    public void setEmail(String email) {
        this.email = cleanup(email);
    }

    public String getFirstName( ) { return this.firstName; }
    public String getLastName( ) { return this.lastName; }
    public String getDaytimePhone( ) { return this.daytimePhone; }
    public String getEveningPhone( ) { return this.eveningPhone; }
    public String getEmail( ) { return this.email; }

    /**
     * Cleanup the String parameter by replacing null with an
     * empty String, and by trimming whitespace from non-null Strings.
     */
    private static String cleanup(String str) {
        return (str != null) ? str.trim( ) : "";
    }
}</pre></blockquote>
</div>

<p><a name="INDEX-693" />Although the
<tt class="literal">PersonalData</tt> class is merely a data holder, it can
include simple validation logic. For example, the default constructor
initializes all fields to non-null values:
</p>

<blockquote><pre class="code">public PersonalData( ) {
    this("", "", "", "", "");
    }</pre></blockquote>

<p>Additionally, all of the set methods make use of the private
<tt class="literal">cleanup( )</tt><a name="INDEX-694" />
<a name="INDEX-695" /> method:
</p>

<blockquote><pre class="code">private static String cleanup(String str) {
    return (str != null) ? str.trim( ) : "";
}</pre></blockquote>

<p>As a result, instances of this class will avoid null references and
whitespace, eliminating the need to perform constant error checking
in the servlet and XML generation classes. Trimming whitespace is
particularly helpful because a user may simply press the spacebar in
one of the required fields, potentially bypassing your validation
rules. The
<tt class="literal">PersonalData</tt><a name="INDEX-696" />
class also contains an explicit validation method that checks for all
required fields:
</p>

<blockquote><pre class="code">public boolean isValid( ) {
    return this.firstName.length( ) &gt; 0
            &amp;&amp; this.lastName.length( ) &gt; 0
            &amp;&amp; this.daytimePhone.length( ) &gt; 0
            &amp;&amp; this.email.length( ) &gt; 0;
}</pre></blockquote>

<p>The only field that is not required is
<tt class="literal">eveningPhone</tt>, so it is not checked here. By
putting this method into this class, we further reduce the work
required of the servlet.
</p>

<p>The next class, <tt class="literal">PersonalDataXML</tt>, is presented in
<a href="ch06_03.htm">Example 6-7</a>. It is responsible for converting
<tt class="literal">PersonalData</tt> objects into DOM
<tt class="literal">Document</tt> objects. By converting to DOM instead of
a text XML file, we avoid having to parse the XML as it is fed into
an XSLT processor. Instead, we will use the
<tt class="literal">javax.xml.transform.DOMSource</tt> class to pass the
DOM tree directly.<a name="INDEX-697" />
</p>

<a name="javaxslt-CHP-6-EX-7" /><div class="example">
<h4 class="objtitle">Example 6-7. PersonalDataXML.java </h4>
<blockquote><pre class="code">package chap6;

import javax.xml.parsers.*;
import org.w3c.dom.*;

/**
 * Responsible for converting a PersonalData object into an XML
 * representation using DOM.
 */
public class PersonalDataXML {

    /**
     * @param personalData the data to convert to XML.
     * @param includeErrors if true, an extra field will be included in
     * the XML, indicating that the browser should warn the user about
     * required fields that are missing.
     * @return a DOM Document that contains the web page.
     */
    <tt class="userinput"><b>public Document produceDOMDocument(PersonalData personalData,
            boolean includeErrors) throws ParserConfigurationException {</b></tt>

        // use Sun's JAXP to create the DOM Document
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance( );
        DocumentBuilder docBuilder = dbf.newDocumentBuilder( );
        Document doc =  docBuilder.newDocument( );

        // create &lt;page&gt;, the root of the document
        Element pageElem = doc.createElement("page");
        doc.appendChild(pageElem);

        // if needed, append &lt;requiredFieldsMissing/&gt;
        if (includeErrors &amp;&amp; !personalData.isValid( )) {
            pageElem.appendChild(doc.createElement(
                    "requiredFieldsMissing"));
        }

        Element personalDataElem = doc.createElement("personalData");
        pageElem.appendChild(personalDataElem);

        // use a private helper function to avoid some of DOM's
        // tedious code
        addElem(doc, personalDataElem, "firstName",
                personalData.getFirstName( ), true);
        addElem(doc, personalDataElem, "lastName",
                personalData.getLastName( ), true);
        addElem(doc, personalDataElem, "daytimePhone",
                personalData.getDaytimePhone( ), true);
        addElem(doc, personalDataElem, "eveningPhone",
                personalData.getEveningPhone( ), false);
        addElem(doc, personalDataElem, "email",
                personalData.getEmail( ), true);

        return doc;
    }

    /**
     * A helper method that simplifies this class.
     *
     * @param doc the DOM Document, used as a factory for
     *        creating Elements.
     * @param parent the DOM Element to add the child to.
     * @param elemName the name of the XML element to create.
     * @param elemValue the text content of the new XML element.
     * @param required if true, insert 'required="true"' attribute.
     */
    private void addElem(Document doc, Element parent, String elemName,
            String elemValue, boolean required) {
        Element elem = doc.createElement(elemName);
        elem.appendChild(doc.createTextNode(elemValue));
        if (required) {
            elem.setAttribute("required", "true");
        }
        parent.appendChild(elem);
    }
}</pre></blockquote>
</div>

<p><a name="INDEX-698" />The
following code begins with its two <tt class="literal">import</tt>
statements. The <tt class="literal">javax.xml.parsers</tt> package contains
the JAXP interfaces, and the <tt class="literal">org.w3c.dom</tt> package
contains the standard DOM interfaces and classes:
</p>

<blockquote><pre class="code">import javax.xml.parsers.*;
import org.w3c.dom.*;</pre></blockquote>

<p>The key to this class is its public API, which allows a
<tt class="literal">PersonalData</tt> object to be converted into a DOM
<tt class="literal">Document</tt> object:
</p>

<blockquote><pre class="code"><tt class="userinput"><b>
    public Document produceDOMDocument(PersonalData personalData,</b></tt><tt class="userinput"><b>
            boolean includeErrors) throws ParserConfigurationException {</b></tt></pre></blockquote>
<p>The includeErrors parameter indicates whether or not to include the
&lt;requiredFieldsMissing/&gt; element in the result. If this method
throws a ParserConfigurationException, the most likely cause is a
CLASSPATH problem. This frequently occurs when an older version of
JAXP is present.
</p>

<p>When using JAXP, it takes a few lines of code to obtain the
appropriate implementation of the DocumentBuilder abstract class. By
using the factory pattern, our code is safely insulated from
vendor-specific DOM implementations:
</p>
<blockquote><pre class="code">
// use Sun's JAXP to create the DOM Document
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance( );
DocumentBuilder docBuilder = dbf.newDocumentBuilder( );
Document doc =  docBuilder.newDocument( );</pre></blockquote>

<p>Once the <tt class="literal">doc</tt> object has been created, we use it to
create all remaining elements in the XML data. For example, the
<tt class="literal">&lt;page&gt;</tt> element is created first:
</p>

<blockquote><pre class="code">// create &lt;page&gt;, the root of the document
Element pageElem = doc.createElement("page");
doc.appendChild(pageElem);</pre></blockquote>

<p>Since <tt class="literal">&lt;page&gt;</tt> is the root element, it is the
only thing added directly to our document. All remaining elements
will be added as children or descendents of
<tt class="literal">&lt;page&gt;</tt>. Even though we are not adding
anything else directly to the <tt class="literal">doc</tt> object, we must
continue using it as the factory for creating the remaining elements:
</p>

<blockquote><pre class="code">// if needed, append &lt;requiredFieldsMissing/&gt;
if (includeErrors &amp;&amp; !personalData.isValid( )) {
    pageElem.appendChild(doc.createElement(
            "requiredFieldsMissing"));
}</pre></blockquote>

<p>Since DOM can be tedious, the children of
<tt class="literal">&lt;personalData&gt;</tt> are created in a helper
method called <tt class="literal">addElem(
)</tt><a name="INDEX-699" />
<a name="INDEX-700" />:
</p>

<blockquote><pre class="code">Element personalDataElem = doc.createElement("personalData");
pageElem.appendChild(personalDataElem);

// use a private helper function to avoid some of DOM's
// tedious code
addElem(doc, personalDataElem, "firstName",
        personalData.getFirstName( ), true);
...</pre></blockquote>

<p>You can refer back to <a href="ch06_03.htm">Example 6-7</a> for the complete
implementation of the <tt class="literal">addElem( )</tt> method. A sample
of its output is:
</p>

<blockquote><pre class="code">&lt;firstName required="true"&gt;Eric&lt;/firstName&gt;</pre></blockquote>

<p>The final piece of code,
<em class="filename">PersonalDataServlet.java</em>, is presented in <a href="ch06_03.htm">Example 6-8</a>. This is a basic approach to servlet
development that works for smaller programs such as this, but has a
few scalability problems that we will discuss later in this chapter.
Although we have removed all of the HTML and XML generation from this
servlet, it is still responsible for handling incoming requests from
the browser. As your web application grows to more and more screens,
the code gets correspondingly larger.<a name="INDEX-701" />
</p>

<a name="javaxslt-CHP-6-EX-8" /><div class="example">
<h4 class="objtitle">Example 6-8. PersonalDataServlet.java </h4>
<blockquote><pre class="code">package chap6;

import java.io.*;
import java.net.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;

/**
 * A demonstration servlet that produces two pages. In the first page,
 * the user is prompted to enter "personal information", including
 * name, phone number, and Email. In the second page, a summary of this
 * information is displayed. XSLT is used for all HTML rendering,
 * so this servlet does not enforce any particular look and feel.
 */
public class PersonalDataServlet extends HttpServlet {
    private PersonalDataXML personalDataXML = new PersonalDataXML( );
    private Templates editTemplates;
    private Templates thanksTemplates;

    /**
     * One-time initialization of this Servlet.
     */
    public void init( ) throws UnavailableException {
        TransformerFactory transFact = TransformerFactory.newInstance( );
        String curName = null;
        try {
            curName = "/WEB-INF/xslt/editPersonalData.xslt";
            URL xsltURL = getServletContext( ).getResource(curName);
            String xsltSystemID = xsltURL.toExternalForm( );
            this.editTemplates = transFact.newTemplates(
                    new StreamSource(xsltSystemID));

            curName = "/WEB-INF/xslt/confirmPersonalData.xslt";
            xsltURL = getServletContext( ).getResource(curName);
            xsltSystemID = xsltURL.toExternalForm( );
            this.thanksTemplates = transFact.newTemplates(
                    new StreamSource(xsltSystemID));
        } catch (TransformerConfigurationException tce) {
            log("Unable to compile stylesheet", tce);
            throw new UnavailableException("Unable to compile stylesheet");
        } catch (MalformedURLException mue) {
            log("Unable to locate XSLT file: " + curName);
            throw new UnavailableException(
                    "Unable to locate XSLT file: " + curName);
        }
    }

    /**
     * Handles HTTP GET requests, such as when the user types in
     * a URL into his or her browser or clicks on a hyperlink.
     */
    protected void doGet(HttpServletRequest request,
            HttpServletResponse response) throws IOException,
            ServletException {
        PersonalData personalData = getPersonalData(request);
        // the third parameter, 'false', indicates that error
        // messages should not be displayed when showing the page.
        showPage(response, personalData, false, this.editTemplates);
    }

    /**
     * Handles HTTP POST requests, such as when the user clicks on
     * a Submit button to update his or her personal data.
     */
    protected void doPost(HttpServletRequest request,
            HttpServletResponse response) throws IOException,
            ServletException {

        // locate the personal data object and update it with
        // the information the user just submitted.
        PersonalData pd = getPersonalData(request);
        pd.setFirstName(request.getParameter("firstName"));
        pd.setLastName(request.getParameter("lastName"));
        pd.setDaytimePhone(request.getParameter("daytimePhone"));
        pd.setEveningPhone(request.getParameter("eveningPhone"));
        pd.setEmail(request.getParameter("email"));

        if (!pd.isValid( )) {
            // show the 'Edit' page with an error message
            showPage(response, pd, true, this.editTemplates);
        } else {
            // show a confirmation page
            showPage(response, pd, false, this.thanksTemplates);
        }
    }

    /**
     * A helper method that sends the personal data to the client
     * browser as HTML. It does this by applying an XSLT stylesheet
     * to the DOM tree.
     */
    private void showPage(HttpServletResponse response,
            PersonalData personalData, boolean includeErrors,
            Templates stylesheet) throws IOException, ServletException {
        try {
            org.w3c.dom.Document domDoc =
                    this.personalDataXML.produceDOMDocument(
                    personalData, includeErrors);

            Transformer trans = stylesheet.newTransformer( );

            response.setContentType("text/html");
            PrintWriter writer = response.getWriter( );

            trans.transform(new DOMSource(domDoc), new StreamResult(writer));
        } catch (Exception ex) {
            showErrorPage(response, ex);
        }
    }

    /**
     * If any exceptions occur, this method can be called to display
     * the stack trace in the browser window.
     */
    private void showErrorPage(HttpServletResponse response,
            Throwable throwable) throws IOException {
        PrintWriter pw = response.getWriter( );
        pw.println("&lt;html&gt;&lt;body&gt;&lt;h1&gt;An Error Has Occurred&lt;/h1&gt;&lt;pre&gt;");
        throwable.printStackTrace(pw);
        pw.println("&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;");
    }

    /**
     * A helper method that retrieves the PersonalData object from
     * the HttpSession.
     */
    private PersonalData getPersonalData(HttpServletRequest request) {
        HttpSession session = request.getSession(true);
        PersonalData pd = (PersonalData) session.getAttribute(
                "chap6.PersonalData");
        if (pd == null) {
            pd = new PersonalData( );
            session.setAttribute("chap6.PersonalData", pd);
        }
        return pd;
    }
}</pre></blockquote>
</div>

<p><a name="INDEX-702" />Our
servlet begins with a long list of <tt class="literal">import</tt>
statements, indicating dependencies on the servlet API as well as the
JAXP package. The servlet itself is a subclass of
<tt class="literal">HttpServlet</tt>, as usual, and has three private
fields:
</p>

<blockquote><pre class="code">public class PersonalDataServlet extends HttpServlet {
    private PersonalDataXML personalDataXML = new PersonalDataXML( );
    private Templates editTemplates;
    private Templates thanksTemplates;</pre></blockquote>

<p>It is important to ensure that each of these fields is thread-safe.
Because many clients share the same servlet instance, it is highly
probable that these fields will be accessed concurrently. Instances
of <tt class="literal">PersonalDataXML</tt> are thread-safe because they
are stateless, meaning they contain no data that can be concurrently
modified. The <tt class="literal">Templates</tt> instances are compiled
representations of the two stylesheets this servlet uses and are also
designed to be thread-safe.
</p>

<p>As the comments indicate, the <tt class="literal">init(
)</tt><a name="INDEX-703" />
<a name="INDEX-704" /> method performs a one-time initialization
of the servlet. A servlet container will invoke this method before
this servlet is asked to handle any client requests. The
<tt class="literal">init( )</tt> method is further guaranteed to execute to
completion before any other threads can access this servlet, so
concurrency is not an issue at this point. If anything fails during
initialization, an instance of
<tt class="literal">UnavailableException</tt><a name="INDEX-705" />
is thrown:
</p>

<blockquote><pre class="code">public void init( ) throws UnavailableException {
    TransformerFactory transFact = TransformerFactory.newInstance( );
    String curName = null;
    ...</pre></blockquote>

<p>This exception is provided in the <tt class="literal">javax.servlet</tt>
package and indicates that the servlet could not be loaded
successfully. In our case, the most common cause of this error is a
configuration problem. For example, your XSLT stylesheets may be
installed in the wrong directory, or some JAR file was not found.
</p>

<p>The next thing the <tt class="literal">init( )</tt> method does is load the
two stylesheets into memory. The XSLT stylesheets are stored on the
file system, so <tt class="literal">StreamSource</tt> will be used to read
them into JAXP. But you definitely do not want to hardcode the
absolute <a name="INDEX-706" /> <a name="INDEX-707" />pathname of the stylesheets. If you do
this, your code will probably work on your personal machine but will
fail once it is deployed onto a production web server. For example,
<em class="filename">C:/java/tomcat/webapps/chap6/WEB-INF</em> is a
Windows-specific absolute pathname. Using something so specific would
cause the servlet to fail on all non-Windows platforms, as well as
other Windows machines that have Tomcat installed in a different
directory. The best approach is to use a relative pathname such as
<em class="filename">/WEB-INF</em>, so the stylesheets can be located
regardless of where your web application is deployed.
</p>

<p>A <a name="INDEX-708" />relative pathname has to be relative
to some starting location, so we use the
<tt class="literal">ServletContext</tt><a name="INDEX-709" />
<a name="INDEX-710" />
class. <tt class="literal">ServletContext</tt> has the ability to locate
resources relative to the deployed directory of the current web
application, so you can avoid absolute pathnames in your code. The
details of mapping the relative pathname to the absolute pathname are
taken care of by the servlet container, thus making your code more
portable.
</p>

<p>In this example, <em class="filename">chap6.war</em> is deployed to
Tomcat's <em class="filename">webapps</em> directory. Tomcat will
expand it into the <em class="filename">webapps/chap6</em> directory,
which contain subdirectories that match the directory structure of
the WAR file. We start by assigning the current XSLT filename to the
<tt class="literal">curName</tt><a name="INDEX-711" /> variable, using the following
pathname:
</p>

<blockquote><pre class="code">try {
    curName = "/WEB-INF/xslt/editPersonalData.xslt";</pre></blockquote>

<p>Two options are available at this point. The
<tt class="literal">ServletContext</tt> can provide either an
<tt class="literal">InputStream</tt> or a <tt class="literal">URL</tt>, both of
which represent the XSLT stylesheet. If you use an
<tt class="literal">InputStream</tt>, however, the XSLT processor sees your
stylesheet as a stream of bytes. It will not know where this
datastream originated, so it will not automatically know how to
resolve URI references. This becomes a problem if your stylesheet
imports or includes another stylesheet because this other stylesheet
will not be located. To resolve this problem when using
<tt class="literal">InputStream</tt>, the
<tt class="literal">javax.xml.transform.Source</tt> interface provides the
<tt class="literal">setSystemId( )</tt><a name="INDEX-712" />
<a name="INDEX-713" /> method. This allows the XSLT processor to
resolve URI references in the stylesheet (see <a href="ch05_01.htm">Chapter 5, "XSLT Processing with Java"</a>). 
</p>

<p>For this servlet, we avoid this issue by using a
<tt class="literal">URL</tt> instead of an <tt class="literal">InputStream</tt>.
The <tt class="literal">URL</tt> is converted into a system identifier,
which makes it possible to create a <tt class="literal">StreamSource</tt>
instance. That is, in turn, used to create a
<tt class="literal">Templates</tt> instance for this stylesheet:
</p>

<blockquote><pre class="code">URL xsltURL = getServletContext( ).getResource(curName);
String xsltSystemID = xsltURL.toExternalForm( );
this.editTemplates = transFact.newTemplates(
        new StreamSource(xsltSystemID));</pre></blockquote>

<p>The same process is repeated for the second stylesheet, followed by
basic exception handling:
</p>

<blockquote><pre class="code">   curName = "/WEB-INF/xslt/confirmPersonalData.xslt";
   xsltURL = getServletContext( ).getResource(curName);
   xsltSystemID = xsltURL.toExternalForm( );
   this.thanksTemplates = transFact.newTemplates(
          new StreamSource(xsltSystemID));
   } catch (TransformerConfigurationException tce) {
   log("Unable to compile stylesheet", tce);
          throw new UnavailableException("Unable to compile stylesheet");
} catch (MalformedURLException mue) {
    log("Unable to locate XSLT file: " + curName);
    throw new UnavailableException(
            "Unable to locate XSLT file: " + curName);
}
}</pre></blockquote>

<p>The <tt class="literal">log()</tt><a name="INDEX-714" />
<a name="INDEX-715" /> method causes messages to be written to one
of Tomcat's log files, found in the
<em class="filename">TOMCAT_HOME/logs</em> directory. The
<tt class="literal">UnavailableException</tt> simply indicates that this
servlet is unavailable, so it will not be loaded into memory. The
user will see an error page in their browser at this point.
</p>

<p>If the <tt class="literal">init( )</tt> method completes successfully, the
servlet will be available to handle requests from clients. In this
servlet, the <tt class="literal">doGet( )</tt> and <tt class="literal">doPost(
)</tt> methods have been implemented; therefore, both HTTP GET
and POST protocols are supported. When the user first enters the
application, they will click on a hyperlink, type a URL into their
browser, or visit a saved bookmark. In all of these cases, the
browser issues an HTTP GET request that ultimately causes the
<tt class="literal">doGet( )</tt> method to be invoked:
</p>

<blockquote><pre class="code">protected void doGet(HttpServletRequest request,
        HttpServletResponse response) throws IOException,
        ServletException {
    PersonalData personalData = getPersonalData(request);
    // the third parameter, 'false', indicates that error
    // messages should not be displayed when showing the page.
    showPage(response, personalData, false, this.editTemplates);
}</pre></blockquote>

<p>The first thing the <tt class="literal">doGet( )</tt> method does is
retrieve the instance of <tt class="literal">PersonalData</tt> associated
with this particular user. The appropriate code has been factored out
into the <tt class="literal">getPersonalData(
)</tt><a name="INDEX-716" />
<a name="INDEX-717" /> helper method, since this same
functionality is required by the <tt class="literal">doPost( )</tt> method
as well. You can refer back to <a href="ch06_03.htm">Example 6-8</a> to see
how <tt class="literal">getPersonalData( )</tt> is implemented. It
basically uses <tt class="literal">HttpSession</tt> to locate the
appropriate instance of <tt class="literal">PersonalData</tt>. If the
object is not found in the session, a new instance is created and
stored.
</p>

<p>The <tt class="literal">doGet( )</tt> method then calls the
<tt class="literal">showPage( )</tt><a name="INDEX-718" />
<a name="INDEX-719" /> method, which does the actual work of
sending the web page to the browser. The parameters to
<tt class="literal">showPage( )</tt> include:
</p>

<ul><li>
<p>The <tt class="literal">HttpServletResponse</tt>, which provides access to
the <tt class="literal">PrintWriter</tt>. The result of the transformation
will be sent to this writer.
</p>
</li><li>
<p>The instance of <tt class="literal">PersonalData</tt>, so the
<tt class="literal">showPage( )</tt> method knows what data to display.
</p>
</li><li>
<p>A <tt class="literal">false</tt> parameter, indicating that error messages
should not be shown. That makes sense because <tt class="literal">doGet(
)</tt> is called when the page is first displayed, and users
should not be warned about invalid data before they type something.
</p>
</li><li>
<p>A reference to the appropriate stylesheet. In this case, the
stylesheet will show the HTML form so the user can fill out his or
her information.
</p>
</li></ul>
<p>Once the user fills out the form and submits it to the servlet, the
<tt class="literal">doPost( )</tt> method is invoked. The code for
<tt class="literal">doPost( )</tt> is similar to <tt class="literal">doGet(
)</tt> (see <a href="ch06_03.htm">Example 6-8</a>). The only difference
here is that all incoming data is validated via the
<tt class="literal">PersonalData</tt> class. If the request is valid, the
"Thank You" page is displayed. Otherwise, the current
page is redisplayed with error messages enabled. As you can see in
the code, the only distinction between these two pages is that they
use different stylesheets.
</p>

<p>The final piece to this puzzle resides in the <tt class="literal">showPage(
)</tt> method. This method begins by creating a DOM
<tt class="literal">Document</tt> instance by delegating to the
<tt class="literal">PersonalDataXML</tt> helper class. As you can see in
the following code, the servlet stays quite small because the DOM
generation is factored out into the helper class:
</p>

<blockquote><pre class="code">private void showPage(HttpServletResponse response,
        PersonalData personalData, boolean includeErrors,
        Templates stylesheet) throws IOException, ServletException {
    try {
        org.w3c.dom.Document domDoc =
                this.personalDataXML.produceDOMDocument(
                personalData, includeErrors);</pre></blockquote>

<p>This method then proceeds to create a new instance of
<tt class="literal">Transformer</tt>. You may recall from <a href="ch05_01.htm">Chapter 5, "XSLT Processing with Java"</a> that <tt class="literal">Transformer</tt> instances
are very lightweight and merely hold state information for the
current transformation. Since <tt class="literal">Transformer</tt>
instances are not thread-safe, the instance is a local variable in
this method. With local variables, each thread gets its own copy:
</p>

<blockquote><pre class="code">Transformer trans = stylesheet.newTransformer( );</pre></blockquote>

<p>Next, the content type is configured for the
<tt class="literal">HttpServletResponse</tt>, a
<tt class="literal">PrintWriter</tt> is obtained, and the transformation is
performed. The result tree is sent directly to the response's
<tt class="literal">PrintWriter</tt>:
</p>

<blockquote><pre class="code">            response.setContentType("text/html");
            PrintWriter writer = response.getWriter( );

            trans.transform(new DOMSource(domDoc), new StreamResult(writer));
        } catch (Exception ex) {
            showErrorPage(response, ex);
        }
    }</pre></blockquote>

<p>If any exception occurs, the <tt class="literal">showErrorPage(
)</tt><a name="INDEX-720" />
<a name="INDEX-721" /> method is invoked. Since an exception can
indicate that some XML library is unavailable, the
<tt class="literal">showErrorPage( )</tt> does not attempt to use XML or
XSLT for its output. If it does, another similar exception would
almost certainly occur. Instead, it uses hardcoded <tt class="literal">println(
)</tt> statements to generate its HTML (see <a href="ch06_03.htm">Example 6-8</a>). 
</p>

</div>
<a name="javaxslt-CHP-6-SECT-3.4" /><div class="sect2">
<h3 class="sect2">6.3.4. Deployment</h3>

<p><a href="ch06_03.htm">Figure 6-8</a> shows the complete contents of the WAR
file used in this example. You may notice that
<em class="filename">SplashScreenServlet.class</em> is still listed in
this WAR file. This example is merely an extension of the example
created earlier in this chapter. As in the earlier example, placing
the <tt class="literal">.class</tt> files under the classes directory made
them available to the <tt class="literal">ClassLoader</tt> used by this web
application.
</p>

<a name="javaxslt-CHP-6-FIG-8" /><div class="figure"><img src="figs/jxt_0608.gif" alt="Figure 6-8" width="296" height="309" /></div><h4 class="objtitle">Figure 6-8. WAR file for PersonalDataServlet</h4>

<p>The XSLT stylesheets are placed under the
<em class="filename">WEB-INF/xslt</em> directory. Since anything under the
<em class="filename">WEB-INF</em> directory is hidden from clients, the
XSLT stylesheets are not directly visible to anyone visiting your web
site. If you want to make these stylesheets publicly visible, move
them out of the <em class="filename">WEB-INF</em> directory. The
<em class="filename">index.html</em> file, for example, is the publicly
visible "home page" for this web application. It merely
contains a link that the user can click on to view the servlet.
Although the stylesheets are hidden from clients, they are accessible
from your Java code. Referring back to the code in <a href="ch06_03.htm">Example 6-8</a>, the <tt class="literal">init( )</tt> method used
the following to locate the stylesheets:
</p>

<blockquote><pre class="code">curName = "/WEB-INF/xslt/editPersonalData.xslt";
URL xsltURL = getServletContext( ).getResource(curName);</pre></blockquote>

<p>As this code illustrates, the locations of the stylesheets are
entirely relative to their position in the <a name="INDEX-722" />WAR file. Therefore, your servlet
will still work as the web application is moved onto a production web
server.
</p>

<p>The deployment descriptor, listed in <a href="ch06_03.htm">Example 6-9</a>,
has been expanded to include the new
<tt class="literal">PersonalDataServlet</tt> class. The lines that have
changed from our first iteration are
emphasized.<a name="INDEX-723" /> <a name="INDEX-724" />
</p>

<a name="javaxslt-CHP-6-EX-9" /><div class="example">
<h4 class="objtitle">Example 6-9. Expanded deployment descriptor </h4>
<blockquote><pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE web-app 
  PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN"
  "http://java.sun.com/j2ee/dtds/web-app_2.2.dtd"&gt;
&lt;web-app&gt;
  <tt class="userinput"><b>&lt;servlet&gt;
    &lt;servlet-name&gt;personalDataServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;chap6.PersonalDataServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;</b></tt>
  &lt;servlet&gt;
    &lt;servlet-name&gt;splashScreen&lt;/servlet-name&gt;
    &lt;servlet-class&gt;chap6.SplashScreenServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  <tt class="userinput"><b>&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;personalDataServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/personalData/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</b></tt>
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;splashScreen&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/splash/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></blockquote>
</div>

</div>
<a name="javaxslt-CHP-6-SECT-3.5" /><div class="sect2">
<h3 class="sect2">6.3.5. How to Compile, Deploy, and Run</h3>

<p>In Java, it often seems that half of the battle is devoted to
figuring out CLASSPATH issues. In order to compile this example, the
following JAR files must be listed on the
<a name="INDEX-725" />CLASSPATH:
</p>

<dl>
<dt><i><em class="filename">jaxp.jar</em></tt></i></dt>
<dd>
Java API for XML Processing (JAXP) 1.1</p>
</dd>

</dl>

<dl>
<dt><i><em class="filename">xalan.jar</em></tt></i></dt>
<dd>
Xalan XSLT processor (use the one included with JAXP)</p>
</dd>

</dl>

<dl>
<dt><i><em class="filename">crimson.jar</em></tt></i></dt>
<dd>
Crimson XML parser (use the one included with JAXP)</p>
</dd>

</dl>

<dl>
<dt><i><em class="filename">servlet.jar</em></tt></i></dt>
<dd>
Included with the Tomcat servlet container</p>
</dd>

</dl>

<p>Of course, the directory containing your own source code must also be
listed on the
<a name="INDEX-726" />CLASSPATH. Once
everything is set up, you can compile
<em class="filename">PersonalData.java</em>,
<em class="filename">PersonalDataXML.java</em>, and
<em class="filename">PersonalDataServlet.java</em> by typing
<tt class="userinput"><b>javac *.java</b></tt>. Whether you also wish to include
<em class="filename">SplashScreenServlet.java</em> is entirely up to you.
</p>

<p>As mentioned earlier in this chapter, use the
<em class="filename">jar</em> command to create the WAR file. To create
<em class="filename">chap6.war</em><a name="INDEX-727" />,
simply arrange your files into the directory structure shown in <a href="ch06_03.htm">Figure 6-8</a> and issue the following command from the
directory that contains <em class="filename">index.html</em>:
</p>

<blockquote><pre class="code"><tt class="userinput"><b>jar -cvfM ../chap6.war .</b></tt></pre></blockquote>

<p>This command places <em class="filename">chap6.war</em> in the parent of
your current working directory; the forward slash
(<tt class="literal">/</tt>) works on Windows as well as Unix clients. Once
the <a name="INDEX-728" />WAR file has been created, you can
view its contents by changing to its directory and issuing the
following command:
</p>

<blockquote><pre class="code"><tt class="userinput"><b>jar -tvf chap6.war</b></tt></pre></blockquote>

<p>This shows the table of contents for the WAR file, which must match
the structure shown in <a href="ch06_03.htm">Figure 6-8</a>.
</p>

<p>Deployment to Tomcat is easy: just copy
<em class="filename">chap6.war</em><a name="INDEX-729" /> to the
<em class="filename">TOMCAT_HOME/webapps</em> directory while Tomcat is
not running. You can attempt to execute the servlet now, but it will
probably not work because <em class="filename">jaxp.jar</em>,
<em class="filename">xalan.jar</em>, and <em class="filename">crimson.jar</em>
must be installed in the <em class="filename">TOMCAT_HOME/lib</em>
directory before they can be available for your web application.
</p>

<p><a name="INDEX-730" />The most
difficult aspect of this step is installing the correct versions of
these JAR files. Depending on which version of Tomcat you are
running, older versions of <em class="filename">jaxp.jar</em> and
<em class="filename">crimson.jar</em> may already be found in the
<em class="filename">TOMCAT_HOME/lib</em> directory. The safest approach
is to download JAXP 1.1, which includes all three of these JAR files,
and copy them from the JAXP distribution to the
<em class="filename">TOMCAT_HOME/lib</em> directory.
</p>

<p>Once these steps are complete, start Tomcat and access the following
URL:
</p>

<blockquote class="simplelist">

<p><em class="emphasis">http://localhost:8080/chap6/personalData</em></p>

</blockquote>

<p>This should bring up the personal information page with a blank form,
ready for input.
</p>

</div>
<a name="javaxslt-CHP-6-SECT-3.6" /><div class="sect2">
<h3 class="sect2">6.3.6. Locating Stylesheets with Initialization Parameters</h3>

<p><a name="INDEX-731" />
<a name="INDEX-732" />As you just saw, an easy way to locate
stylesheets is simply to place them somewhere underneath the
<em class="filename">WEB-INF</em> directory of a WAR file. While this is
an ideal solution for solitary web applications, there are situations
where the same stylesheets are shared across a whole group of web
apps. In this case, embedding the stylesheets into various WAR files
is not viable.
</p>

<p>Ideally, the stylesheets will be located in a shared directory
somewhere, but that directory location will not be hardcoded into any
servlets. The simple way to accomplish this is via initialization
parameters. These are name/value pairs of strings specified in the
deployment descriptor and retrieved via the
<tt class="literal">Servlet</tt> or <tt class="literal">ServletContext</tt>.
</p>

<p><a name="INDEX-733" />Servlet initialization parameters are
tied to specific servlets, and context initialization parameters are
tied to an entire web application. For the purposes of specifying the
XSLT stylesheet location, it makes sense to use context parameters.
These can be specified in the deployment descriptor as follows:
</p>

<blockquote><pre class="code">&lt;web-app&gt;<tt class="userinput"><b>
  &lt;context-param&gt;</b></tt><tt class="userinput"><b>
    &lt;param-name&gt;xslt_directory&lt;/param-name&gt;</b></tt><tt class="userinput"><b>
    &lt;param-value&gt;C:/dev/xslt&lt;/param-value&gt;</b></tt><tt class="userinput"><b>
  &lt;/context-param&gt;</b></tt>
  &lt;servlet&gt;
    ...
  &lt;/servlet&gt;
&lt;/web-app&gt;</pre></blockquote>

<p>And the values of these parameters can be retrieved using the
following methods on the
<tt class="literal">javax.servlet.ServletContext</tt> interface:
</p>

<blockquote><pre class="code">public interface ServletContext {
    // if the parameter name does not exist, return null
    String getInitParameter(String name);
    Enumeration getInitParameterNames( );
    ...remaining methods omitted
}</pre></blockquote>

<p>So in order to locate the stylesheet, one might write the following
code in a servlet's <tt class="literal">init(
)</tt><a name="INDEX-734" />
<a name="INDEX-735" /> method:
</p>

<blockquote><pre class="code">public class MyServlet extends HttpServlet {
    private String xsltDirectory;

    public void init(ServletConfig config) throws ServletException {
        super.init(config);<tt class="userinput"><b>
        this.xsltDirectory = config.getServletContext( ).getInitParameter(</b></tt><tt class="userinput"><b>
                "xslt_directory");</b></tt>
        if (this.xsltDirectory == null) {
            throw new UnavailableException(
                    "xslt_directory is a required context-param");
        }
    }

    ...remainder of code omitted
}</pre></blockquote>

<p>Now that the actual location of the stylesheets has been moved into
the deployment descriptor, changes can be made without any edits to
the servlet.<a name="INDEX-736" /> 
</p>

</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch06_02.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch06_04.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">6.2. WAR Files and Deployment</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">6.4. Stylesheet Caching Revisited</td></tr></table></div>
<hr width="684" align="left" />

<img src="../gifs/navbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm"></map>

</body></html>