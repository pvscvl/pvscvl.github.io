<html><head><title>XML Review (Java and XSLT)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Eric M. Burke" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596001453L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Java and XSLT" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Java and XSLT" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch01_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch01_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>



<h2 class="sect1">1.2. XML Review</h2>

<p>In a nutshell, <a name="INDEX-41" />XML is a format for storing structured
data. Although it looks a lot like HTML, XML is much more strict with
quotes, properly terminated tags, and other such details. XML does
not define tag names, so document authors must invent their own set
of tags or look towards a standards organization that defines a
suitable XML <em class="emphasis">markup
language</em><a name="INDEX-42" />. A markup language is essentially a
set of custom tags with semantic meaning behind each tag; XSLT is one
such markup language, since it is expressed using XML syntax.
</p>

<p>The terms
<em class="emphasis">element</em><a name="INDEX-43" />
and
<em class="emphasis">tag</em><a name="INDEX-44" />
are often used interchangeably, and both are used in this book.
Speaking from a more technical viewpoint, element refers to the
concept being modeled, while tag refers to the actual markup that
appears in the XML document. So <tt class="literal">&lt;account&gt;</tt> is
a tag that represents an <tt class="literal">account</tt> element in a
computer program.
</p>

<a name="javaxslt-CHP-1-SECT-2.1" /><div class="sect2">
<h3 class="sect2">1.2.1. SGML, XML, and Markup Languages</h3>

<p><a name="INDEX-45" />Standard Generalized Markup Language
(SGML) forms the basis for HTML, XHTML, XML, and XSLT, but in very
different ways for each. <a href="ch01_02.htm">Figure 1-2</a> illustrates the
relationships between these technologies.
</p>

<a name="javaxslt-CHP-1-FIG-2" /><div class="figure"><img src="figs/jxt_0102.gif" alt="Figure 1-2" width="311" height="161" /></div><h4 class="objtitle">Figure 1-2. SGML heritage</h4>

<p>SGML is a very sophisticated
<em class="emphasis">metalanguage</em><a name="INDEX-46" />
designed for large and complex documentation. As a metalanguage, it
defines syntax rules for tags but does not define any specific tags.
HTML, on the other hand, is a specific markup language implemented
using SGML. A <a name="INDEX-47" />markup language defines its own set of
tags, such as <tt class="literal">&lt;h1&gt;</tt> and
<tt class="literal">&lt;p&gt;</tt>. Because HTML is a markup language
instead of a metalanguage, you cannot add new tags and are at the
mercy of the browser vendor to properly implement those tags.
</p>

<p>XML, as shown in <a href="ch01_02.htm">Figure 1-2</a>, is a subset of SGML.
XML documents are compatible with SGML documents, however XML is a
much smaller language. A key goal of XML is simplicity, since it has
to work well on the Web where bandwidth and limited client processing
power is a concern. Because of its simplicity, XML is easier to parse
and validate, making it a better performer than SGML. XML is also a
metalanguage, which explains why XML does not define any tags of its
own. XSLT is a particular markup language implemented using XML, and
will be covered in detail in the next two chapters.
</p>

<p><a name="INDEX-48" />XHTML, like XSLT, is also an XML-based
markup language. XHTML is designed to be a replacement for HTML and
is almost completely compatible with existing web browsers. Unlike
HTML, however, XHTML is based strictly on XML, and the rules for
well-formed documents are very clearly defined. This means that it is
much easier for vendors to develop editors and programming tools to
deal with XHTML, because the syntax is much more predictable and can
be validated just like any other XML document. Many of the examples
in this book use XHTML instead of HTML, although XSLT can easily
handle either format.
</p>

<a name="javaxslt-CHP-1-SIDEBAR-1" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">XHTML Basics</h4>
&nbsp;
<p><a name="INDEX-49" />XHTML is a W3C Recommendation that
represents the future of HTML. Based on HTML 4.0, XHTML is designed
to be compatible with existing web browsers while complying fully
with XML. This means that a properly written XHTML document is always
a well-formed XML document. Furthermore, XHTML documents must adhere
to one or more of the XHTML DTDs, therefore XHTML pages can be
validated using today's XML parsers such as Apache's
Crimson.
</p>
&nbsp;
<p>XHTML is designed to be modular; therefore, subsets can be extracted
and utilized for wireless devices such as cell phones. XHTML Basic,
also a W3C Recommendation, is one such modularization effort, and
will likely become a force to be reckoned with in the wireless space.
</p>
&nbsp;
<p>Here is an example XHTML document:</p>
&nbsp;
<blockquote><pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Hello, World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Hello, World!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></blockquote>
&nbsp;
<p>Some of the most important XHTML rules include:</p>
&nbsp;
<ul><li>
<p>XHTML documents must be well-formed XML and must adhere to one of the
XHTML DTDs. As expected with XML, all elements must be properly
terminated, attribute values must be quoted, and elements must be
properly nested.
</p>
</li></ul>
<ul><li>
<p>The <tt class="literal">&lt;!DOCTYPE ...&gt;</tt> tag is required.</p>
</li></ul>
<ul><li>
<p>Unlike HTML, tags must be lowercase.</p>
</li></ul>
<ul><li>
<p>The root element must be <tt class="literal">&lt;html&gt;</tt> and must
designate the XHTML namespace as shown in the previous example.
</p>
</li></ul>
<ul><li>
<p><tt class="literal">&lt;head&gt;</tt> and <tt class="literal">&lt;body&gt;</tt>
are required.
</p>
</li></ul>
<p>The preceding document adheres to the <em class="emphasis">strict</em>
DTD, which eliminates deprecated HTML tags and many style-related
tags. Two other DTDs, <em class="emphasis">transitional</em> and
<em class="emphasis">frameset</em>, provide more compatibility with
existing web browsers but should be avoided when possible. For full
information, refer to the W3C's specifications and
documentation at <a href="../../../../../../www.w3.org/">http://www.w3.org</a>.
</p>
</td></tr></table><p></blockquote>

<p>As we look at more advanced techniques for processing XML with XSLT,
we will see that XML is not always dealt with in terms of a text file
containing tags. From a certain perspective, XML files and their tags
are really just a serialized representation of the underlying XML
elements. This serialized form is good for storing XML data in files
but may not be the most efficient format for exchanging data between
systems or programmatically modifying the underlying data. For
particularly large documents, a relational or object database offers
far better scalability and performance than native XML text files.
</p>

</div>
<a name="javaxslt-CHP-1-SECT-2.2" /><div class="sect2">
<h3 class="sect2">1.2.2. XML Syntax</h3>

<p><a href="ch01_02.htm">Example 1-1</a> <a name="INDEX-50" />
<a name="INDEX-51" />shows a sample XML document that
contains data about U.S. Presidents. This document is said to be
<em class="emphasis">well-formed</em><a name="INDEX-52" /> <a name="INDEX-53" /> because it adheres to several basic
rules about proper XML formatting.
</p>

<a name="javaxslt-CHP-1-EX-1" /><div class="example">
<h4 class="objtitle">Example 1-1. presidents.xml </h4>
<blockquote><pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE presidents SYSTEM "presidents.dtd"&gt;
&lt;presidents&gt;
  &lt;president&gt;
    &lt;term from="1789" to="1797"/&gt;
    &lt;name&gt;
      &lt;first&gt;George&lt;/first&gt;
      &lt;last&gt;Washington&lt;/last&gt;
    &lt;/name&gt;
    &lt;party&gt;Federalist&lt;/party&gt;
    &lt;vicePresident&gt;
      &lt;name&gt;
        &lt;first&gt;John&lt;/first&gt;
        &lt;last&gt;Adams&lt;/last&gt;
      &lt;/name&gt;
    &lt;/vicePresident&gt;
  &lt;/president&gt;
  &lt;president&gt;
    &lt;term from="1797" to="1801"/&gt;
    &lt;name&gt;
      &lt;first&gt;John&lt;/first&gt;
      &lt;last&gt;Adams&lt;/last&gt;
    &lt;/name&gt;
    &lt;party&gt;Federalist&lt;/party&gt;
    &lt;vicePresident&gt;
      &lt;name&gt;
        &lt;first&gt;Thomas&lt;/first&gt;
        &lt;last&gt;Jefferson&lt;/last&gt;
      &lt;/name&gt;
    &lt;/vicePresident&gt;
  &lt;/president&gt;

  &lt;!-- remaining presidents omitted --&gt;

&lt;/presidents&gt;</pre></blockquote>
</div>

<p>In HTML, a missing tag here and there or mismatched quotes are not
disastrous. Browsers make every effort to go ahead and display these
poorly formatted documents anyway. This makes the Web a much more
enjoyable environment because users are not bombarded with constant
syntax errors.
</p>

<p>Since the primary role of XML is to represent structured data, being
well-formed is very important. When two banking systems exchange
data, if the message is corrupted in any way, the receiving system
must reject the message altogether or risk making the wrong
assumptions. This is important for XSLT programmers to understand
because XSLT itself is expressed using XML. When writing stylesheets,
you must always adhere to the basic rules for well-formed documents.
</p>

<p>All well-formed XML documents must have exactly one <em class="emphasis">root
element</em><a name="INDEX-54" /> <a name="INDEX-55" />.
In <a href="ch01_02.htm">Example 1-1</a>, the root element is
<tt class="literal">&lt;presidents&gt;</tt>. This forms the base of a tree
data structure in which every other element has exactly one parent
and zero or more children. Elements must also be properly terminated
and nested:
</p>

<blockquote><pre class="code">&lt;name&gt;
  &lt;first&gt;George&lt;/first&gt;
  &lt;last&gt;Washington&lt;/last&gt;
&lt;/name&gt;</pre></blockquote>

<p>Although
<em class="emphasis">whitespace</em><a name="INDEX-56" />
<a name="INDEX-57" />
(spaces, tabs, and linefeeds) between elements is typically
irrelevant, it can make documents more readable if you take the time
to indent consistently. Although XML parsers preserve whitespace, it
does not affect the meaning of the underlying elements. In this
example, the <tt class="literal">&lt;first&gt;</tt> tag must be terminated
with a corresponding <tt class="literal">&lt;/first&gt;</tt>. The following
XML would be illegal because the tags are not properly nested:
</p>

<blockquote><pre class="code">&lt;name&gt;
  &lt;first&gt;George<tt class="userinput"><b>
    &lt;last&gt;Washington&lt;/first&gt;</b></tt><tt class="userinput"><b>
  &lt;/last&gt;</b></tt>
&lt;/name&gt;</pre></blockquote>

<p>XML provides an alternate syntax for terminating elements that do not
have children, formally known as <em class="emphasis">empty
elements</em><a name="INDEX-58" /> <a name="INDEX-59" />. The <tt class="literal">&lt;term&gt;</tt>
element is one such example:
</p>

<blockquote><pre class="code">&lt;term from="1797" to="1801"/&gt;</pre></blockquote>

<p>The closing slash indicates that this element does not contain any
<em class="emphasis">content</em><a name="INDEX-60" />
<a name="INDEX-61" />, although it may contain
<em class="emphasis">attributes</em><a name="INDEX-62" />.
An attribute is a name/value pair, such as
<tt class="literal">from="1797"</tt>. Another requirement for well-formed
XML is that all attribute values be enclosed in quotes
(<tt class="literal">""</tt>) or apostrophes (<tt class="literal">''</tt>).
</p>

<p>Most presidents had middle names, some did not have vice presidents,
and others had several vice presidents. For our example XML file,
these are known as <em class="emphasis">optional elements</em>. Ulysses
Grant, for example, had two vice presidents. He also had a middle
name:
</p>

<blockquote><pre class="code">&lt;president&gt;
  &lt;term from="1869" to="1877"/&gt;
  &lt;name&gt;
    &lt;first&gt;Ulysses&lt;/first&gt;<tt class="userinput"><b>
    &lt;middle&gt;Simpson&lt;/middle&gt;</b></tt>
    &lt;last&gt;Grant&lt;/last&gt;
  &lt;/name&gt;
  &lt;party&gt;Republican&lt;/party&gt;<tt class="userinput"><b>
  &lt;vicePresident&gt;</b></tt><tt class="userinput"><b>
    &lt;name&gt;</b></tt><tt class="userinput"><b>
      &lt;first&gt;Schuyler&lt;/first&gt;</b></tt><tt class="userinput"><b>
      &lt;last&gt;Colfax&lt;/last&gt;</b></tt><tt class="userinput"><b>
    &lt;/name&gt;</b></tt><tt class="userinput"><b>
  &lt;/vicePresident&gt;</b></tt><tt class="userinput"><b>
  &lt;vicePresident&gt;</b></tt><tt class="userinput"><b>
    &lt;name&gt;</b></tt><tt class="userinput"><b>
      &lt;first&gt;Henry&lt;/first&gt;</b></tt><tt class="userinput"><b>
      &lt;last&gt;Wilson&lt;/last&gt;</b></tt><tt class="userinput"><b>
    &lt;/name&gt;</b></tt><tt class="userinput"><b>
  &lt;/vicePresident&gt;</b></tt>
&lt;/president&gt;</pre></blockquote>

<p><a name="INDEX-63" />Capitalization is also important
in XML. Unlike HTML, all XML tags are case sensitive. This means that
<tt class="literal">&lt;president&gt;</tt> is not the same as
<tt class="literal">&lt;PRESIDENT&gt;</tt>. It does not matter which
capitalization scheme you use, provided you are consistent. As you
might guess, since XHTML documents are also XML documents, they too
are case sensitive. In XHTML, all tags must be lowercase, such as
<tt class="literal">&lt;html&gt;</tt>, <tt class="literal">&lt;body&gt;</tt>, and
<tt class="literal">&lt;head&gt;</tt>.
</p>

<p>The following list summarizes the basic rules for a
<a name="INDEX-64" />well-formed XML document:
</p>

<ul><li>
<p>It must contain exactly one root element; the remainder of the
document forms a tree structure, in which every element is contained
within exactly one parent.
</p>
</li><li>
<p>All elements must be properly terminated. For example,
<tt class="literal">&lt;name&gt;Eric&lt;/name&gt;</tt> is properly
terminated because the <tt class="literal">&lt;name&gt;</tt> tag is
terminated with <tt class="literal">&lt;/name&gt;</tt>. In XML, you can
also create empty elements like <tt class="literal">&lt;married/&gt;</tt>.
</p>
</li><li>
<p>Elements must be properly nested. This is legal:</p>

<blockquote><pre class="code">&lt;b&gt;&lt;i&gt;bold and italic&lt;/i&gt;&lt;/b&gt;</pre></blockquote>

<p>But this is illegal:</p>

<blockquote><pre class="code">&lt;b&gt;&lt;i&gt;bold and italic&lt;/b&gt;&lt;/i&gt;</pre></blockquote>
</li></ul>


<ul><li>
<p>Attributes must be quoted using either quotes or apostrophes. For
example:
</p>

<blockquote><pre class="code">&lt;date month="march" day='01' year="1971"/&gt;</pre></blockquote>
</li></ul>
<ul><li>
<p>Attributes must contain name/value pairs. Some HTML elements contain
marker attributes, such as <tt class="literal">&lt;td nowrap&gt;</tt>. In
XHTML, you would write this as <tt class="literal">&lt;td
nowrap="nowrap"/&gt;</tt>. This is compatible with XML and
should work in existing web browsers.
</p>
</li></ul>
<p>This is not the complete list of rules but is sufficient to get you
through the examples in this book. Clearly, most HTML documents are
not well-formed. Many tags, such as <tt class="literal">&lt;br&gt;</tt> or
<tt class="literal">&lt;hr&gt;</tt>, violate the rule that all elements
must be properly terminated. In addition, browsers do not complain
when attribute values are not quoted. This will have interesting
ramifications for us when we write XSLT stylesheets, which are
themselves written in XML but often produce HTML. What this basically
means is that the stylesheet must contain well-formed XML, so it is
difficult to produce HTML that is not well-formed. XHTML is certainly
a more natural fit because it is also XML, just like the XSLT
stylesheet.
</p>

</div>
<a name="javaxslt-CHP-1-SECT-2.3" /><div class="sect2">
<h3 class="sect2">1.2.3. Validation</h3>

<p>A well-formed XML document adheres to the basic syntax guidelines
just outlined. A <em class="emphasis">valid</em><a name="INDEX-65" /> <a name="INDEX-66" /> XML document goes one step further
by adhering to either a <a name="INDEX-67" />Document Type Definition (DTD) or an
<a name="INDEX-68" />XML Schema. In
order to be considered valid, an XML document must first be
well-formed. Stated simply, DTDs are the traditional approach to
validation, and XML Schemas are the logical successor. XML Schema is
another specification from the W3C and offers much more sophisticated
validation capabilities than DTDs. Since XML Schema is very new, DTDs
will continue to be used for quite some time. You can learn more
about <a name="INDEX-69" />XML Schema at <a href="../../../../../../www.w3.org/XML/Schema">http://www.w3.org/XML/Schema</a>.
</p>

<p>The second line of <a href="ch01_02.htm">Example 1-1</a> contains the
following <em class="emphasis">document type
declaration</em><a name="INDEX-70" />:
</p>

<blockquote><pre class="code">&lt;!DOCTYPE presidents SYSTEM "presidents.dtd"&gt;</pre></blockquote>

<p>This refers to the DTD that exists in the same directory as the
<em class="filename">presidents.xml</em> file. In many cases, the DTD will
be referenced by a URI instead:
</p>

<blockquote><pre class="code">&lt;!DOCTYPE presidents SYSTEM "http://www.javaxslt.com/dtds/presidents.dtd"&gt;</pre></blockquote>

<p>Regardless of where the DTD is located, it contains rules that define
the allowable structure of the XML data. <a href="ch01_02.htm">Example 1-2</a>
shows the DTD for our list of presidents.
</p>

<a name="javaxslt-CHP-1-EX-2" /><div class="example">
<h4 class="objtitle">Example 1-2. presidents.dtd </h4>
<blockquote><pre class="code">&lt;!ELEMENT presidents (president+)&gt;
&lt;!ELEMENT president (term, name, party, vicePresident*)&gt;
&lt;!ELEMENT name (first, middle*, last, nickname?)&gt;
&lt;!ELEMENT vicePresident (name)&gt;
&lt;!ELEMENT first (#PCDATA)&gt;
&lt;!ELEMENT last (#PCDATA)&gt;
&lt;!ELEMENT middle (#PCDATA)&gt;
&lt;!ELEMENT nickname (#PCDATA)&gt;
&lt;!ELEMENT party (#PCDATA)&gt;
&lt;!ELEMENT term EMPTY&gt;
&lt;!ATTLIST term
	from CDATA #REQUIRED
	to CDATA #REQUIRED
&gt;</pre></blockquote>
</div>

<p>The first line in the DTD says that the
<tt class="literal">&lt;presidents&gt;</tt> element can contain one or more
<tt class="literal">&lt;president&gt;</tt> elements as children. The
<tt class="literal">&lt;president&gt;</tt>, in turn, contains one each of
<tt class="literal">&lt;term&gt;</tt>, <tt class="literal">&lt;name&gt;</tt>, and
<tt class="literal">&lt;party&gt;</tt> in that order. It then may contain
zero or more <tt class="literal">&lt;vicePresident&gt;</tt> elements. If
the XML data did not adhere to these rules, the XML parser would have
rejected it as invalid.
</p>

<p>The <tt class="literal">&lt;name&gt;</tt> element can contain the following
content: exactly one <tt class="literal">&lt;first&gt;</tt>, followed by
zero or more <tt class="literal">&lt;middle&gt;</tt>, followed by exactly
one <tt class="literal">&lt;last&gt;</tt>, followed by zero or one
<tt class="literal">&lt;nickname&gt;</tt>. If you are wondering why
<tt class="literal">&lt;middle&gt;</tt> can occur many times, consider this
former president:
</p>

<blockquote><pre class="code">&lt;name&gt;
  &lt;first&gt;George&lt;/first&gt; <tt class="userinput"><b>
  &lt;middle&gt;Herbert&lt;/middle&gt; </b></tt><tt class="userinput"><b>
  &lt;middle&gt;Walker&lt;/middle&gt; </b></tt>
  &lt;last&gt;Bush&lt;/last&gt; 
&lt;/name&gt;</pre></blockquote>

<p>Elements such as <tt class="literal">&lt;first&gt;George&lt;/first&gt;</tt>
are said to contain
<tt class="literal">#PCDATA</tt><a name="INDEX-71" />
<a name="INDEX-72" />,
<a name="INDEX-73" />which stands for
<em class="emphasis">parsed character data</em>. This is ordinary text
that can contain markup, such as nested tags. The
<tt class="literal">CDATA</tt> type, which is used for attribute values,
cannot contain markup. This means that
<tt class="literal">&lt;</tt><a name="INDEX-74" /> characters appearing in
attribute values will have to be encoded in your XML documents as
<tt class="literal">&amp;lt;</tt><a name="INDEX-75" />. The
<tt class="literal">&lt;term&gt;</tt> element is <tt class="literal">EMPTY</tt>,
meaning that it cannot have content. This is not to say that it
cannot contain attributes, however. This DTD specifies that
<tt class="literal">&lt;term&gt;</tt> must have <tt class="literal">from</tt> and
<tt class="literal">to</tt> attributes:
</p>

<blockquote><pre class="code">&lt;term from="1869" to="1877"/&gt;</pre></blockquote>

<p>We will not cover the remaining syntax rules for DTDs in this book,
primarily because they do not have much impact on our code as we
apply XSLT stylesheets. DTDs are primarily used during the parsing
process, when XML data is read from a file into memory. When
generating XML for a web site, you generally produce new XML rather
than parse existing XML, so there is much less need to validate. One
area where we will use DTDs, however, is when we examine how to write
unit tests for our Java and XSLT code. This will be covered in <a href="ch09_01.htm">Chapter 9, "Development Environment, Testing, and Performance"</a>.<a name="INDEX-76" /> 
</p>

</div>
<a name="javaxslt-CHP-1-SECT-2.4" /><div class="sect2">
<h3 class="sect2">1.2.4. Java and XML</h3>

<p><a name="INDEX-77" />Java APIs for XML such as SAX, DOM, and
JDOM will be used throughout this book. Although we will not go into
a great deal of detail on specific parsing APIs, the Java-based XSLT
tools do build on these technologies, so it is important to have a
basic understanding of what each API does and where it fits into the
XML landscape. For in-depth information on any of these topics, you
might want to pick up a copy of <em class="filename">Java &amp; XML</em>
by Brett McLaughlin (O'Reilly).
</p>

<p>A <a name="INDEX-78" />parser is a tool
that reads XML data into memory. The most common pattern is to parse
the XML data from a text file, although Java XML parsers can also
read XML from any Java <tt class="literal">InputStream</tt> or even a URL.
If a DTD or Schema is used, then validating parsers will ensure that
the XML is valid during the parsing process. This means that once
your XML files have been successfully parsed into memory, a lot less
custom Java validation code has to be written.
</p>

<a name="javaxslt-CHP-1-SECT-2.4.1" /><div class="sect3">
<h3 class="sect3">1.2.4.1. SAX</h3>

<p>In the Java community, <a name="INDEX-79" />Simple API for XML (SAX) is the most
commonly used XML parsing method today. <a name="INDEX-80" />SAX is a free API available from David
Megginson and members of the XML-DEV mailing list (<a href="../../../../../../www.xml.org/xml-dev">http://www.xml.org/xml-dev</a>). It can be
downloaded<a href="#FOOTNOTE-2">[2]</a> from <a href="../../../../../../www.megginson.com/SAX">http://www.megginson.com/SAX</a>. Although SAX
has been ported to several other languages, we will focus on the Java
features. SAX is only responsible for scanning through XML data top
to bottom and sending event notifications as elements, text, and
other items are encountered; it is up to the recipient of these
events to process the data. SAX parsers do not store the entire
document in memory, therefore they have the potential to be very fast
for even huge files.
</p><blockquote class="footnote"> <a name="FOOTNOTE-2" /><p> [2] One does not generally need to download
SAX directly because it is supported by and included with all of the
popular XML parsers.</p> </blockquote>

<p>Currently, there are two versions of <a name="INDEX-81" />SAX:
1.0 and 2.0. Many changes were made in version 2.0, and the SAX
examples in this book use this version. Most SAX parsers should
support the older 1.0 classes and interfaces, however, you will
receive deprecation warnings from the Java compiler if you use these
older features.
</p>

<p>Java SAX parsers are implemented using a series of interfaces. The
most important interface is
<tt class="literal">org.xml.sax.ContentHandler</tt><a name="INDEX-82" />
<a name="INDEX-83" />,
which has methods such as <tt class="literal">startDocument(
)</tt><a name="INDEX-84" />
<a name="INDEX-85" />, <tt class="literal">startElement(
)</tt><a name="INDEX-86" />
<a name="INDEX-87" />, <tt class="literal">characters(
)</tt><a name="INDEX-88" />
<a name="INDEX-89" />, <tt class="literal">endElement(
)</tt><a name="INDEX-90" />
<a name="INDEX-91" />, and <tt class="literal">endDocument(
)</tt><a name="INDEX-92" />
<a name="INDEX-93" />. During the parsing process,
<tt class="literal">startDocument( )</tt> is called once, then
<tt class="literal">startElement( )</tt> and <tt class="literal">endElement(
)</tt> are called once for each tag in the XML data. For the
following XML:
</p>

<blockquote><pre class="code">&lt;first&gt;George&lt;/first&gt;</pre></blockquote>

<p>the <tt class="literal">startElement( )</tt> method will be called,
followed by <tt class="literal">characters( )</tt>, followed by
<tt class="literal">endElement( )</tt>. The <tt class="literal">characters(
)</tt> method provides the text <tt class="literal">"George"</tt> in
this example. This basic process continues until the end of the
document, at which time <tt class="literal">endDocument( )</tt> is called.
</p>

<a name="ch01-13-fm2xml" /><blockquote><b>NOTE:</b> 

Depending on the SAX implementation, the <tt class="literal">characters( )</tt> method may break up contiguous character data into several chunks of data. In this case, the <tt class="literal">characters( )</tt> method will be called several times until the character data is entirely parsed.
</p>
</blockquote>
<p>Since <tt class="literal">ContentHandler</tt> is an interface, it is up to
your application code to somehow implement this interface and
subsequently do something when the parser invokes its methods. SAX
does provide a class called
<tt class="literal">DefaultHandler</tt><a name="INDEX-94" />
<a name="INDEX-95" />
that implements the <tt class="literal">ContentHandler</tt> interface. To
use <tt class="literal">DefaultHandler</tt>, create a subclass and override
the methods that interest you. The other methods can safely be
ignored, since they are just empty methods. If you are familiar with
AWT programming, you may recognize that this idiom is identical to
event adapter classes such as
<tt class="literal">java.awt.event.WindowAdapter</tt>.
</p>

<p>Getting back to XSLT, you may be wondering where SAX fits into the
picture. It turns out that XSLT processors typically have the ability
to gather input from a series of SAX events as an alternative to
static XML files. Somewhat nonintuitively, it also turns out that you
can generate your own series of SAX events rather
easily -- without using a SAX parser. Since a SAX parser just
calls a series of methods on the <tt class="literal">ContentHandler</tt>
interface, you can write your own pseudo-parser that does the same
thing. We will explore this in <a href="ch05_01.htm">Chapter 5, "XSLT Processing with Java"</a> when we
talk about using SAX and an XSLT processor to apply transformations
to non-XML data, such as results from a database query or content of
a comma separated values (CSV) file.
</p>

</div>

<a name="javaxslt-CHP-1-SECT-2.4.2" /><div class="sect3">
<h3 class="sect3">1.2.4.2. DOM</h3>

<p>The <a name="INDEX-96" />Document Object Model (DOM) is an API
that allows computer programs to manipulate the underlying data
structure of an XML document. DOM is a W3C Recommendation, and
implementations are available for many programming languages. The
in-memory representation of XML is typically referred to as a
<em class="emphasis">DOM tree</em><a name="INDEX-97" /> because DOM is a tree data structure. The
root of the tree represents the XML document itself, using the
<tt class="literal">org.w3c.dom.Document</tt><a name="INDEX-98" />
<a name="INDEX-99" />
interface. The <em class="emphasis">document root
element</em><a name="INDEX-100" />, on the other hand, is represented
using the
<tt class="literal">org.w3c.dom.Element</tt><a name="INDEX-101" />
<a name="INDEX-102" />
interface. In the presidents example, the
<tt class="literal">&lt;presidents&gt;</tt> element is the document root
element. In <a name="INDEX-103" />DOM,
almost every interface extends from the
<tt class="literal">org.w3c.dom.Node</tt> interface;
<tt class="literal">Document</tt> and <tt class="literal">Element</tt> are no
exception. The <tt class="literal">Node</tt><a name="INDEX-104" /> interface provides numerous methods
to navigate and modify the DOM tree consistently.
</p>

<p>Strangely enough, the DOM Level 2 Recommendation does not provide
standard mechanisms for reading or writing XML data. Instead, each
vendor implementation does this a little bit differently. This is
generally not a big problem because every DOM implementation out
there provides some mechanism for both parsing and
<em class="emphasis">serializing</em>, or writing out XML files. The
unfortunate result, however, is that reading and writing XML will
cause vendor-specific code to creep into any application you write.
</p>

<a name="ch01-15-fm2xml" /><blockquote><b>NOTE:</b> 

At the time of this writing, a new W3C document called "Document Object Model (DOM) Level 3 Content Models and Load and Save Specification" was in the working draft status. Once this specification reaches the recommendation status, DOM will provide a standard mechanism for reading and writing XML.
</p></blockquote>
<p>Since DOM does not specify a standard way to read XML data into
memory, most DOM (if not all) implementations delegate this task to a
dedicated parser. In the case of Java, SAX is the preferred parsing
technology. <a href="ch01_02.htm">Figure 1-3</a> illustrates the typical
interaction between SAX parsers and DOM implementations.
</p>

<a name="javaxslt-CHP-1-FIG-3" /><div class="figure"><img src="figs/jxt_0103.gif" alt="Figure 1-3" width="467" height="200" /></div><h4 class="objtitle">Figure 1-3. DOM and SAX interaction</h4>

<p>Although it is important to understand how these pieces fit together,
we will not go into detailed parsing syntax in this book. As we
progress to more sophisticated topics, we will almost always be
generating XML dynamically rather than parsing in static XML data
files. For this reason, let's look at how DOM can be used to
generate a new document from scratch. <a href="ch01_02.htm">Example 1-3</a>
contains XML for a personal library.
</p>

<a name="javaxslt-CHP-1-EX-3" /><div class="example">
<h4 class="objtitle">Example 1-3. library.xml </h4>
<blockquote><pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE library SYSTEM "library.dtd"&gt;
&lt;library&gt;
  &lt;!-- This is an XML comment --&gt;
  &lt;publisher id="oreilly"&gt;
    &lt;name&gt;O'Reilly&lt;/name&gt;
    &lt;street&gt;1005 Gravenstein Hwy North&lt;/street&gt;
    &lt;city&gt;Sebastopol&lt;/city&gt;
    &lt;state&gt;CA&lt;/state&gt;
    &lt;postal&gt;95472&lt;/postal&gt;
  &lt;/publisher&gt;
  &lt;book publisher="oreilly" isbn="1-56592-709-5"&gt;
    &lt;edition&gt;1&lt;/edition&gt;
    &lt;publicationDate mm="10" yy="1999"/&gt;
    &lt;title&gt;XML Pocket Reference&lt;/title&gt;
    &lt;author&gt;Robert Eckstein&lt;/author&gt;
  &lt;/book&gt;
  &lt;book publisher="oreilly" isbn="0-596-00016-2"&gt;
    &lt;edition&gt;1&lt;/edition&gt;
    &lt;publicationDate mm="06" yy="2000"/&gt;
    &lt;title&gt;Java and XML&lt;/title&gt;
    &lt;author&gt;Brett McLaughlin&lt;/author&gt;
  &lt;/book&gt;
&lt;/library&gt;</pre></blockquote>
</div>

<p>As shown in <em class="filename">library.xml</em>, a
<tt class="literal">&lt;library&gt;</tt> consists of
<tt class="literal">&lt;publisher&gt;</tt> elements and
<tt class="literal">&lt;book&gt;</tt> elements. To generate this XML, we
will use Java classes called <tt class="literal">Library</tt>,
<tt class="literal">Book</tt>, and <tt class="literal">Publisher</tt>. These
classes are not shown here, but they are really simple. For example,
here is a portion of the <tt class="literal">Book</tt> class:
</p>

<blockquote><pre class="code">public class Book {
  private String author;
  private String title;
  ...

  public String getAuthor( ) {
    return this.author;
  }

  public String getTitle( ) {
    return this.title;
  }
  ...
}</pre></blockquote>

<p>Each of these three helper classes is merely used to hold data. The
code that creates XML is encapsulated in a separate class called
<tt class="literal">LibraryDOMCreator</tt>, which is shown in <a href="ch01_02.htm">Example 1-4</a>. 
</p>

<a name="javaxslt-CHP-1-EX-4" /><div class="example">
<h4 class="objtitle">Example 1-4. XML generation using DOM </h4>
<blockquote><pre class="code">package chap1;

import java.io.*;
import java.util.*;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * An example from <a href="ch01_01.htm">Chapter 1, "Introduction "</a>. Creates the library XML file using the
 * DOM API.
 */
public class LibraryDOMCreator {

    /**
     * Create a new DOM org.w3c.dom.Document object from the specified
     * Library object.
     *
     * @param library an application defined class that
     * provides a list of publishers and books.
     * @return a new DOM document.
     */
    public Document createDocument(Library library)
            throws javax.xml.parsers.ParserConfigurationException {
        // Use Sun's Java API for XML Parsing to create the
        // DOM Document
        javax.xml.parsers.DocumentBuilderFactory dbf =
            javax.xml.parsers.DocumentBuilderFactory.newInstance( );
        javax.xml.parsers.DocumentBuilder docBuilder =
            dbf.newDocumentBuilder( );
        Document doc = docBuilder.newDocument( );

        // NOTE: DOM does not provide a factory method for creating:
        //   &lt;!DOCTYPE library SYSTEM "library.dtd"&gt;
        // Apache's Xerces provides the createDocumentType method
        // on their DocumentImpl class for doing this.  Not used here.

        // create the &lt;library&gt; document root element
        Element root = doc.createElement("library");
        doc.appendChild(root);

        // add &lt;publisher&gt; children to the &lt;library&gt; element
        Iterator publisherIter = library.getPublishers().iterator( );
        while (publisherIter.hasNext( )) {
            Publisher pub = (Publisher) publisherIter.next( );
            Element pubElem = createPublisherElement(doc, pub);
            root.appendChild(pubElem);
        }

        // now add &lt;book&gt; children to the &lt;library&gt; element
        Iterator bookIter = library.getBooks().iterator( );
        while (bookIter.hasNext( )) {
            Book book = (Book) bookIter.next( );
            Element bookElem = createBookElement(doc, book);
            root.appendChild(bookElem);
        }

        return doc;
    }

    private Element createPublisherElement(Document doc, Publisher pub) {
        Element pubElem = doc.createElement("publisher");

        // set id="oreilly" attribute
        pubElem.setAttribute("id", pub.getId( ));

        Element name = doc.createElement("name");
        name.appendChild(doc.createTextNode(pub.getName( )));
        pubElem.appendChild(name);

        Element street = doc.createElement("street");
        street.appendChild(doc.createTextNode(pub.getStreet( )));
        pubElem.appendChild(street);

        Element city = doc.createElement("city");
        city.appendChild(doc.createTextNode(pub.getCity( )));
        pubElem.appendChild(city);

        Element state= doc.createElement("state");
        state.appendChild(doc.createTextNode(pub.getState( )));
        pubElem.appendChild(state);

        Element postal = doc.createElement("postal");
        postal.appendChild(doc.createTextNode(pub.getPostal( )));
        pubElem.appendChild(postal);

        return pubElem;
    }

    private Element createBookElement(Document doc, Book book) {
        Element bookElem = doc.createElement("book");

        bookElem.setAttribute("publisher", book.getPublisher().getId( ));
        bookElem.setAttribute("isbn", book.getISBN( ));

        Element edition = doc.createElement("edition");
        edition.appendChild(doc.createTextNode(
                Integer.toString(book.getEdition( ))));
        bookElem.appendChild(edition);

        Element publicationDate = doc.createElement("publicationDate");
        publicationDate.setAttribute("mm",
                Integer.toString(book.getPublicationMonth( )));
        publicationDate.setAttribute("yy",
                Integer.toString(book.getPublicationYear( )));
        bookElem.appendChild(publicationDate);

        Element title = doc.createElement("title");
        title.appendChild(doc.createTextNode(book.getTitle( )));
        bookElem.appendChild(title);

        Element author = doc.createElement("author");
        author.appendChild(doc.createTextNode(book.getAuthor( )));
        bookElem.appendChild(author);

        return bookElem;
    }

    public static void main(String[] args) throws IOException,
            javax.xml.parsers.ParserConfigurationException {
        Library lib = new Library( );
        LibraryDOMCreator ldc = new LibraryDOMCreator( );
        Document doc = ldc.createDocument(lib);

        // write the Document using Apache Xerces
        // output the Document with UTF-8 encoding; indent each line
        org.apache.xml.serialize.OutputFormat fmt =
            new org.apache.xml.serialize.OutputFormat(doc, "UTF-8", true);
        org.apache.xml.serialize.XMLSerializer serial =
            new org.apache.xml.serialize.XMLSerializer(System.out, fmt);
        serial.serialize(doc.getDocumentElement( ));
    }
}</pre></blockquote>
</div>

<p>This example starts with the usual series of
<tt class="literal">import</tt> statements. Notice that
<tt class="literal">org.w3c.dom.*</tt> is imported, but packages such as
<tt class="literal">org.apache.xml.serialize.*</tt> are not. The code is
written this way in order to make it obvious that many of the classes
you will use are not part of the standard DOM API. These nonstandard
classes all use fully qualified class and package names in the code.
Although DOM itself is a W3C recommendation, many common tasks are
not covered by the spec and can only be accomplished by reverting to
vendor-specific code.
</p>

<p>The workhorse of this class is the <tt class="literal">createDocument</tt>
method, which takes a <tt class="literal">Library</tt> as a parameter and
returns an <tt class="literal">org.w3c.dom.Document</tt> object. This
method could throw a <tt class="literal">ParserConfigurationException</tt>,
which indicates that Sun's Java API for XML Parsing (JAXP)
could not locate an XML parser:
</p>

<blockquote><pre class="code">public Document createDocument(Library library)
        throws javax.xml.parsers.ParserConfigurationException {</pre></blockquote>

<p>The <tt class="literal">Library</tt> class simply stores data representing
a personal library of books. In a real application, the
<tt class="literal">Library</tt> class might also be responsible for
connecting to a back-end data source. This arrangement provides a
clear separation between XML generation code and the underlying
database. The sole purpose of <tt class="literal">LibraryDOMCreator</tt> is
to crank out DOM trees, making it easy for one programmer to work on
this class while another focuses on the implementation of
<tt class="literal">Library</tt>, <tt class="literal">Book</tt>, and
<tt class="literal">Publisher</tt>.
</p>

<p>The next step is to begin constructing a DOM
<tt class="literal">Document</tt> object:
</p>

<blockquote><pre class="code">javax.xml.parsers.DocumentBuilderFactory dbf =
    javax.xml.parsers.DocumentBuilderFactory.newInstance( );
javax.xml.parsers.DocumentBuilder docBuilder =
    dbf.newDocumentBuilder( );
Document doc = docBuilder.newDocument( );</pre></blockquote>

<p>This code relies on <a name="INDEX-105" />JAXP because the standard DOM API does
not provide any support for creating a new
<tt class="literal">Document</tt> object in a standard way. Different
<a name="INDEX-106" />parsers have their own proprietary
way of doing this, which brings us to the whole point of JAXP: it
encapsulates differences between various XML parsers, allowing Java
programmers to use a consistent API regardless of which parser they
use. As we will see in <a href="ch05_01.htm">Chapter 5, "XSLT Processing with Java"</a>, JAXP 1.1 adds a
consistent wrapper around various XSLT processors in addition to
standard SAX and DOM parsers.
</p>

<p>JAXP provides a <tt class="literal">DocumentBuilderFactory</tt> to
construct a <tt class="literal">DocumentBuilder</tt>, which is then used to
construct new <tt class="literal">Document</tt> objects. The
<tt class="literal">Document</tt> class is a part of DOM, so most of the
remaining code is defined by the DOM specification.
</p>

<p>In <a name="INDEX-107" />DOM, new XML elements must always be
created using factory methods, such as
<tt class="literal">createElement(...)</tt>, on an instance of
<tt class="literal">Document</tt>. These elements must then be added to
either the document itself or one of the elements within the document
before they actually become part of the XML:
</p>

<blockquote><pre class="code">// create the &lt;library&gt; document root element
Element root = doc.createElement("library");
doc.appendChild(root);</pre></blockquote>

<p>At this point, the <tt class="literal">&lt;library/&gt;</tt> element is
empty, but it has been added to the document. The code then proceeds
to add all <tt class="literal">&lt;publisher&gt;</tt> children:
</p>

<blockquote><pre class="code">// add &lt;publisher&gt; children to the &lt;library&gt; element
Iterator publisherIter = library.getPublishers().iterator( );
while (publisherIter.hasNext( )) {
    Publisher pub = (Publisher) publisherIter.next( );<tt class="userinput"><b>
    Element pubElem = createPublisherElement(doc, pub);</b></tt><tt class="userinput"><b>
    root.appendChild(pubElem);</b></tt>
}</pre></blockquote>

<p>For each instance of <tt class="literal">Publisher</tt>, a
<tt class="literal">&lt;publisher&gt;</tt> <tt class="literal">Element</tt> is
created and then added to <tt class="literal">&lt;library&gt;</tt>. The
<tt class="literal">createPublisherElement</tt> method is a private helper
method that simply goes through the tedious <a name="INDEX-108" />DOM steps required to create each XML
element. One thing that may not seem entirely obvious is the way that
text is added to elements, such as <tt class="literal">O'Reilly</tt> in the
<tt class="literal">&lt;name&gt;O'Reilly&lt;/name&gt;</tt> tag:
</p>

<blockquote><pre class="code">Element name = doc.createElement("name");
name.appendChild(doc.createTextNode(pub.getName( )));
pubElem.appendChild(name);</pre></blockquote>

<p>The first line is pretty obvious, simply creating an empty
<tt class="literal">&lt;name/&gt;</tt> element. The next line then adds a
new text node as a child of the name object rather than setting the
value directly on the name. This is indicative of the way that DOM
represents XML: any parsed character data is considered to be a child
of a node, rather than part of the node itself. DOM uses the
<tt class="literal">org.w3c.dom.Text</tt> interface, which extends from
<tt class="literal">org.w3c.dom.Node</tt>, to represent text nodes. This is
often a nuisance because it results in at least one extra line of
code for each element you wish to generate.
</p>

<p>The
<tt class="literal">main()</tt><a name="INDEX-109" />
<a name="INDEX-110" />
method in <a href="ch01_02.htm">Example 1-4</a> creates a
<tt class="literal">Library</tt> object, converts it into a DOM tree, then
prints the XML text to <tt class="literal">System.out</tt>. Since the
standard DOM API does not provide a standard way to convert a DOM
tree to XML, we introduce Xerces specific code to convert the DOM
tree to text form:
</p>

<blockquote><pre class="code">// write the document using Apache Xerces
// output the document with UTF-8 encoding; indent each line
org.apache.xml.serialize.OutputFormat fmt =
    new org.apache.xml.serialize.OutputFormat(doc, "UTF-8", true);
org.apache.xml.serialize.XMLSerializer serial =
    new org.apache.xml.serialize.XMLSerializer(System.out, fmt);
serial.serialize(doc.getDocumentElement( ));</pre></blockquote>

<p>As we will see in <a href="ch05_01.htm">Chapter 5, "XSLT Processing with Java"</a>, JAXP 1.1 does provide
a mechanism to perform this task using its transformation APIs, so we
do not technically have to use the Xerces code listed here. The JAXP
approach maximizes portability but introduces the overhead of an XSLT
processor when all we really need is DOM.<a name="INDEX-111" />
</p>

</div>

<a name="javaxslt-CHP-1-SECT-2.4.3" /><div class="sect3">
<h3 class="sect3">1.2.4.3. JDOM</h3>

<p><a name="INDEX-112" />DOM is specified in the language
independent <a name="INDEX-113" />Common Object Request Broker
Architecture Interface Definition Language (CORBA IDL), allowing the
same interfaces and concepts to be utilized by many different
programming languages. Though valuable from a specification
perspective, this approach does not take advantage of specific Java
language features. JDOM is a Java-only API that can be used to create
and modify XML documents in a more natural way. By taking advantage
of Java features, JDOM aims to simplify some of the more tedious
aspects of DOM programming.
</p>

<p><a name="INDEX-114" />
<a name="INDEX-115" />JDOM is not
a W3C specification, but is open source software<a href="#FOOTNOTE-3">[3]</a> available at <a href="../../../../../../www.jdom.org/">http://www.jdom.org</a>. JDOM is great from a
programming perspective because it results in much cleaner, more
maintainable code. Since JDOM has the ability to convert its data
into a standard DOM tree, it integrates nicely with any other XML
tool. JDOM can also utilize whatever XML parser you specify and can
write out XML to any Java output stream or file. It even features a
class called <tt class="literal">SAXOutputter</tt> that allows the JDOM
data to be integrated with any tool that expects a series of SAX
events.
</p><blockquote class="footnote"> <a name="FOOTNOTE-3" /><p> [3] Sun
has accepted <a name="INDEX-116" />JDOM
as Java Specification Request (JSR) 000102; see <a href="../../../../../../java.sun.com/aboutJava/communityprocess/">http://java.sun.com/aboutJava/communityprocess/</a>.</p>
</blockquote>

<p>The code in <a href="ch01_02.htm">Example 1-5</a> shows how much easier JDOM
is than DOM; it does the same thing as the DOM example, but is about
fifty lines shorter. This difference <a name="INDEX-117" /> <a name="INDEX-118" />would be greater for more complex
applications.
</p>

<a name="javaxslt-CHP-1-EX-5" /><div class="example">
<h4 class="objtitle">Example 1-5. XML generation using JDOM </h4>
<blockquote><pre class="code">package com.oreilly.javaxslt.chap1;

import java.io.*;
import java.util.*;
import org.jdom.DocType;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.output.XMLOutputter;

/**
 * An example from <a href="ch01_01.htm">Chapter 1, "Introduction "</a>. Creates the library XML file.
 */
public class LibraryJDOMCreator {

    public Document createDocument(Library library) {
        Element root = new Element("library");
        // JDOM supports the &lt;!DOCTYPE...&gt;
        DocType dt = new DocType("library", "library.dtd");
        Document doc = new Document(root, dt);

        // add &lt;publisher&gt; children to the &lt;library&gt; element
        Iterator publisherIter = library.getPublishers().iterator( );
        while (publisherIter.hasNext( )) {
            Publisher pub = (Publisher) publisherIter.next( );
            Element pubElem = createPublisherElement(pub);
            root.addContent(pubElem);
        }

        // now add &lt;book&gt; children to the &lt;library&gt; element
        Iterator bookIter = library.getBooks().iterator( );
        while (bookIter.hasNext( )) {
            Book book = (Book) bookIter.next( );
            Element bookElem = createBookElement(book);
            root.addContent(bookElem);
        }

        return doc;
    }

    private Element createPublisherElement(Publisher pub) {
        Element pubElem = new Element("publisher");

        pubElem.addAttribute("id", pub.getId( ));
        pubElem.addContent(new Element("name").setText(pub.getName( )));
        pubElem.addContent(new Element("street").setText(pub.getStreet( )));
        pubElem.addContent(new Element("city").setText(pub.getCity( )));
        pubElem.addContent(new Element("state").setText(pub.getState( )));
        pubElem.addContent(new Element("postal").setText(pub.getPostal( )));

        return pubElem;
    }

    private Element createBookElement(Book book) {
        Element bookElem = new Element("book");

        // add publisher="oreilly" and isbn="1234567" attributes
        // to the &lt;book&gt; element
        bookElem.addAttribute("publisher", book.getPublisher().getId( ))
                .addAttribute("isbn", book.getISBN( ));

        // now add an &lt;edition&gt; element to &lt;book&gt;
        bookElem.addContent(new Element("edition").setText(
                Integer.toString(book.getEdition( ))));

        Element pubDate = new Element("publicationDate");
        pubDate.addAttribute("mm",
                Integer.toString(book.getPublicationMonth( )));
        pubDate.addAttribute("yy",
                Integer.toString(book.getPublicationYear( )));
        bookElem.addContent(pubDate);

        bookElem.addContent(new Element("title").setText(book.getTitle( )));
        bookElem.addContent(new Element("author").setText(book.getAuthor( )));

        return bookElem;
    }

    public static void main(String[] args) throws IOException {
        Library lib = new Library( );
        LibraryJDOMCreator ljc = new LibraryJDOMCreator( );
        Document doc = ljc.createDocument(lib);

        // Write the XML to System.out, indent two spaces, include
        // newlines after each element
        new XMLOutputter("  ", true, "UTF-8").output(doc, System.out);
    }
}</pre></blockquote>
</div>

<p>The JDOM example is structured just like the DOM example, beginning
with a method that converts a <tt class="literal">Library</tt> object into
a JDOM <tt class="literal">Document</tt>:
</p>

<blockquote><pre class="code">public Document createDocument(Library library) {</pre></blockquote>

<p>The most striking difference in this particular method is the way in
which the <tt class="literal">Document</tt> and its
<tt class="literal">Element</tt> s are created. In JDOM, you simply create
Java objects to represent items in your XML data. This contrasts with
the DOM approach, which relies on interfaces and factory methods.
Creating the <tt class="literal">Document</tt> is also easy in JDOM:
</p>

<blockquote><pre class="code">Element root = new Element("library");
// JDOM supports the &lt;!DOCTYPE...&gt;
DocType dt = new DocType("library", "library.dtd");
Document doc = new Document(root, dt);</pre></blockquote>

<p>As this comment indicates, JDOM allows you to refer to a DTD, while
DOM does not. This is just another odd limitation of DOM that forces
you to include implementation-specific code in your Java
applications. Another area where JDOM shines is in its ability to
create new elements. Unlike DOM, text is set directly on the
<tt class="literal">Element</tt> objects, which is more intuitive to Java
programmers:
</p>

<blockquote><pre class="code">private Element createPublisherElement(Publisher pub) {
    Element pubElem = new Element("publisher");

    pubElem.addAttribute("id", pub.getId( ));
    pubElem.addContent(new Element("name").setText(pub.getName( )));
    pubElem.addContent(new Element("street").setText(pub.getStreet( )));
    pubElem.addContent(new Element("city").setText(pub.getCity( )));
    pubElem.addContent(new Element("state").setText(pub.getState( )));
    pubElem.addContent(new Element("postal").setText(pub.getPostal( )));

    return pubElem;
}</pre></blockquote>

<p>Since methods such as <tt class="literal">addContent( )</tt> and
<tt class="literal">addAttribute( )</tt> return a reference to the
<tt class="literal">Element</tt> instance, the code shown here could have
been written as one long line. This is similar to
<tt class="literal">StringBuffer.append( )</tt>, which can also be
"chained" together:
</p>

<blockquote><pre class="code">buf.append("a").append("b").append("c");</pre></blockquote>

<p>In an effort to keep the JDOM code more readable, however, our
example adds one element per line.
</p>

<p>The final piece of this pie is the ability to print out the contents
of JDOM as an XML file. JDOM includes a class called
<tt class="literal">XMLOutputter</tt>, which allows us to generate the XML
for a <tt class="literal">Document</tt> object in a single line of code:
</p>

<blockquote><pre class="code">new XMLOutputter("  ", true, "UTF-8").output(doc, System.out);</pre></blockquote>

<p>The three arguments to <tt class="literal">XMLOutputter</tt> indicate that
it should use two spaces for indentation, include linefeeds, and
encode its output using UTF-8.<a name="INDEX-119" /><a name="INDEX-120" /> <a name="INDEX-121" /> 
</p>

</div>

<a name="javaxslt-CHP-1-SECT-2.4.4" /><div class="sect3">
<h3 class="sect3">1.2.4.4. JDOM and DOM interoperability</h3>

<p><a name="INDEX-122" /> <a name="INDEX-123" /> <a name="INDEX-124" />Current XSLT processors are
very flexible, generally supporting any of the following sources for
XML or XSLT input:
</p>

<ul><li>
<p>a DOM tree or output from a SAX parser</p>
</li><li>
<p>any Java <tt class="literal">InputStream</tt> or <tt class="literal">Reader</tt></p>
</li><li>
<p>a URI, file name, or <tt class="literal">java.io.File</tt> object</p>
</li></ul>
<p><a name="INDEX-125" /> <a name="INDEX-126" />JDOM is not directly supported by some
XSLT processors, although this is changing fast.<a href="#FOOTNOTE-4">[4]</a> For this reason, it
is typical to convert a JDOM <tt class="literal">Document</tt> instance to
some other format so it can be fed into an XSLT processor for
transformation. Fortunately, the JDOM package provides a class called
<tt class="literal">DOMOutputter</tt><a name="INDEX-127" />
<a name="INDEX-128" />
that can easily make the transformation:
</p><blockquote class="footnote"> <a name="FOOTNOTE-4" /><p> [4] As
this book went to press, Version 6.4 of SAXON was released with beta
support for transforming JDOM trees. Additionally, JDOM beta 7
introduces two new classes, <tt class="literal">JDOMSource</tt> and
<tt class="literal">JDOMResult</tt>, that interoperate with any
JAXP-compliant XSLT processor.</p> </blockquote>

<blockquote><pre class="code">org.jdom.output.DOMOutputter outputter =
        new org.jdom.output.DOMOutputter( );
org.w3c.dom.Document domDoc = outputter.output(jdomDoc);</pre></blockquote>

<p>The DOM <tt class="literal">Document</tt> object can then be used with any
of the XSLT processors or a whole host of other XML libraries and
tools. JDOM also includes a class that can convert a
<tt class="literal">Document</tt> into a series of SAX events and another
that can send XML data to an <tt class="literal">OutputStream</tt> or
<tt class="literal">Writer</tt>. In time, it seems likely that tools will
begin offering native support for JDOM, making extra conversions
unnecessary. The details of all these techniques are covered in <a href="ch05_01.htm">Chapter 5, "XSLT Processing with Java"</a>. 
</p>

</div>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch01_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch01_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">1. Introduction </td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">1.3. Beyond Dynamic Web Pages</td></tr></table></div>
<hr width="684" align="left" />

<img src="../gifs/navbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="0,0,85,93" href="../index.htm"><area shape="rect" coords="85,0,180,98" href="../sax2/index.htm"><area shape="rect" coords="182,-1,261,100" href="../xmlnut/index.htm"><area shape="rect" coords="263,1,384,96" href="../jxml/index.htm"><area shape="rect" coords="386,1,463,100" href="index.htm"><area shape="rect" coords="466,1,533,112" href="../xslt/index.htm"><area shape="rect" coords="535,-1,610,108" href="../schema/index.htm"><area shape="rect" coords="613,1,696,121" href="../pxml/index.htm"></map>

</body></html>
